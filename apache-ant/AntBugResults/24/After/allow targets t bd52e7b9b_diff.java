diff --git a/CONTRIBUTORS b/CONTRIBUTORS
index f2fafafe5..6cec079a0 100644
--- a/CONTRIBUTORS
+++ b/CONTRIBUTORS
@@ -1,360 +1,361 @@
 Amongst other, the following people contributed to ant:
 
 Adam Blinkinsop
 Adam Bryzak
 Adam Sotona
 Aleksandr Ishutin
 Alex Rosen
 Alexei Yudichev
 Alexey Panchenko
 Alexey Solofnenko
 Alison Winters
 Andreas Ames
 Andreas Mross
 Andrew Everitt
 Andrew Stevens
 Andrey Urazov
 Andy Wood
 Anil K. Vijendran
 Anli Shundi
 Anthony Goubard
 Anthony Green
 Antoine Baudoux
 Antoine Levy-Lambert
 Anton Mazkovoi
 Arnaud Vandyck
 Arnout J. Kuiper
 Aslak Hellesôy
 Atsuhiko Yamanaka
 Avik Sengupta
 Balazs Fejes 2
 Bart Vanhaute
 Benjamin Burgess
 Ben Galbraith
 Benoit Moussaud
 Bernd Dutkowski
 Brad Clark
 Brant Langer Gurganus
 Brian Curnow
 Brian Deitte
 Brian Felder
 Brian Repko
 Bruce Atherton
 Cedomir Igaly
 Charles Hudak
 Charlie Hubbard
 Chris Povirk
 Christian Knorr
 Christoph Wilhelms
 Christophe Labouisse
 Christopher A. Longo
 Christopher Charlier
 Clark Archer
 Clemens Hammacher
 Clement OUDOT
 Conor MacNeill
 Craeg Strong
 Craig Cottingham
 Craig R. McClanahan
 Craig Richardson
 Craig Ryan
 Craig Sandvik
 Curt Arnold
 Curtis White
 Cyrille Morvan
 D'Arcy Smith
 Dale Anson
 Dale Sherwood
 Dan Armbrust
 Daniel Henrique
 Daniel Ribagnac
 Daniel Spilker
 Danno Ferrin
+Danny Yates
 Dante Briones
 Davanum Srinivas
 Dave Brondsema
 Dave Brosius
 David A. Herman
 David Crossley
 David Gärtner
 David S. Johnson
 David Kavanagh
 David LeRoy
 David Leal
 David M. Lloyd
 David Maclean
 David Rees
 Denis Hennessy
 Derek Slager
 Diane Holt
 dIon Gillard
 Dmitry A. Kuminov
 Dominique Devienne
 Donal Quinlan
 Don Brown
 Don Ferguson
 Don Jeffery
 Drew Sudell
 Eduard Wirch
 Edwin Woudt
 Eli Tucker
 Emmanuel Bourg
 Eric Olsen
 Eric Pugh
 Erik Hatcher
 Erik Langenbach
 Erik Meade
 Ernst de Haan
 Frank Harnack
 Frank Somers
 Frank Zeyda
 Frederic Bothamy
 Frederic Lavigne
 Gary S. Weaver
 Gautam Guliani
 Gene-Sung Chung
 Georges-Etienne Legendre
 Gero Vermaas
 Gerrit Riessen
 Gilbert Rebhan
 Gilles Scokart
 Glenn McAllister
 Glenn Twiggs
 Greg Nelson
 Greg Roodt
 Greg Schueler
 Günther Kögel
 Harish Prabandham
 Haroon Rafique
 Hiroaki Nakamura
 Holger Engels
 Holger Joest
 Ignacio Coloma
 Ingenonsya France
 Ingmar Stein
 Irene Rusman
 Ivan Ivanov
 J Bleijenbergh
 Jack J. Woehr
 James Duncan Davidson
 Jan Cumps
 Jan Matèrne
 Jan Mynarik
 Jason Hunter
 Jason Pettiss
 Jason Salter
 Jason Yip
 Jay Dickon Glanville
 Jay Peck
 Jay van der Meer
 JC Mann
 J D Glanville
 Jean-Francois Brousseau
 Jeff Gettle
 Jeff Martin
 Jeff Tulley
 Jeff Turner
 Jene Jasper
 Jeremy Mawson
 Jerome Lacoste
 Jesse Glick
 Jesse Stockall
 Jim Allers
 Joerg Wassmer
 Joey Richey
 Johann Herunter
 John Sisson
 Jon Dickinson
 Jon S. Stevens
 Jon Skeet
 Jose Alberto Fernandez
 Joseph Walton
 Josh Lucas
 Juerg Wanner
 Julian Simpson
 Justin Vallon
 Keiron Liddle
 Keith Visco
 Kevin Greiner
 Kevin Jackson
 Kevin Ross
 Kevin Z Grey
 Kim Hansen
 Kirk Wylie
 Kyle Adams
 Larry Shatzer
 Larry Streepy
 Les Hughes
 Levi Cook
 lucas
 Ludovic Claude
 Maarten Coene
 Magesh Umasankar
 Maneesh Sahu
 Marcel Schutte
 Marcus B&ouml;rger
 Mario Frasca 
 Mariusz Nowostawski
 Mark Hecker
 Mark Salter
 Mark R. Diggory
 Mark A. Ziesemer
 Martijn Kruithof
 Martin Landers
 Martin Poeschl
 Martin van den Bemt
 Martin von Gagern
 Mathieu Champlon
 Mathieu Peltier
 Matt Albrecht
 Matt Benson
 Matt Bishop
 Matt Foemmel
 Matt Grosso
 Matt Humphrey
 Matt Small
 Matthew Hawthorne
 Matthew Inger
 Matthew Kuperus Heun
 Matthew Watson
 Michael Bayne
 Michael Davey
 Michael J. Sikorsky
 Michael McCallum
 Michael Montuori
 Michael Newcomb
 Micheal Nygard
 Michael Saunders
 Miha
 Mike Davis
 Mike Roberts
 mnowostawski
 Nathan Beyer
 Nick Chalko
 Nick Fortescue
 Nick Crossley
 Nick Pellow
 Nicola Ken Barozzi
 Nico Seessle
 Nigel Magnay
 Oliver Merkel
 Oliver Rossmueller
 Omer Shapira
 Oystein Gisnas
 Patrick C. Beard
 Patrick Chanezon
 Patrick G. Heck (Gus Heck)
 Patrick Martin
 Paul Austin
 Paul Christmann
 Paul Galbraith
 Paul King
 Paulo Gaspar
 Pavan Bayyapu
 Pavel Jisl
 Pawel Zuzelski
 Peter B. West
 Peter Donald
 Peter Doornbosch
 Peter Hulst
 Peter Janes
 Peter Reilly
 Phil Hanna
 Philip Hourihane
 Phillip Wells
 Pierre Delisle
 Pierre Dittgen
 R Handerson
 Rami Ojares
 Randy Watler
 Raphael Pierquin
 Ray Waldin
 Remie Bolte
 Richard Evans
 Rick Beton
 Robert Anderson
 Robert Clark
 Robert Flaherty
 Robert Shaw
 Robert Streich
 Robert Watkins
 Roberto Scaramuzzi
 Robin Green
 Robin Verduijn
 Rob Oxspring
 Rob van Oostrum
 Rodrigo Schmidt
 Roger Vaughn
 Roman Ivashin
 Ronen Mashal
 Russell Gold
 Sam Ruby
 Sandra Metz
 Scott Carlson
 Scott Ellsworth
 Scott Johnson
 Scott M. Stirling
 Sean Egan
 Sean P. Kane
 Sebastien Arod
 Shiraz Kanga
 Sebastian Kantha
 Simon Law
 Simone Bordet
 Stefan Bodewig
 Stefan Heimann
 Stefano Mazzocchi
 Stephan Strittmatter
 Stephane Bailliez
 stephan
 Stephan Michels
 Stephen Chin
 Stephen Goetze
 Steve Cohen
 Steve Langley
 Steve Loughran
 Steve Morin
 Steve Wadsworth
 Steven E. Newton
 Takashi Okamoto
 TAMURA Kent
 Taoufik Romdhane
 Tariq Master
 Thomas Aglassinger
 Thomas Butz
 Thomas Christen
 Thomas Christensen
 Thomas Haas
 Thomas Quas
 Tim Drury
 Tim Fennell
 Tim Stephenson
 Timothy Gerard Endres
 Tom Ball
 Tom Brus
 Tom Cunningham
 Tom Dimock
 Tom Eugelink
 Tom May
 Tomasz Bech
 Trejkaz Xaoza
 Ulrich Schmidt
 Valentino Miazzo
 Victor Toni
 Vincent Legoll
 Waldek Herka
 Will Wang
 William Ferguson
 William Webber
 Wolf Siberski
 Wolfgang Baer
 Wolfgang Frech
 Wolfgang Glas
 Wolfgang Werner
 Xavier Hanin
 Xavier Witdouck
 Yohann Roussel
 Yuji Yamano
 Yves Martin
 Zach Garner
 Zdenek Wagner
diff --git a/WHATSNEW b/WHATSNEW
index 3df3ddb56..feb4cf5c2 100644
--- a/WHATSNEW
+++ b/WHATSNEW
@@ -1,1102 +1,1114 @@
 Changes from Ant 1.8.1 TO current SVN version
 =============================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Prior to Ant 1.8.0 the <copy> task and several other tasks would
    overwrite read-only destination files.  Starting with 1.8.0 they
    would only do so under special circumstances.  Ant 1.8.2 now
    consistently won't replace a read-only file by default. The same is
    true for a number of other tasks.
    The <copy>, <move> and <echo> tasks now have a new force attribute
    and <concat> has a new forceReadonly attribute that can be used to
    make the task overwrite read-only destinations.
    Bugzilla Report 49261.
 
  * Removed ant-nodeps.jar; it is now merged into ant.jar.
 
  * DOMElementWriter#encode used to employ special code before encoding
    ampersands so that &#123; remained &#123; rather than being turned
    into &amp;#123;.  This is no longer the case, ampersands will now
    be encoded unconditionally.
    Also DOMElementWriter#encodeData will treat CDATA sections containing a
    literal "]]>" sequence different now - it will split the CDATA
    section between the second "]" and ">" and create two sections.
    This affects <echoxml> task as well as the XML logger or JUnit
    formatter where ampersands will now always get encoded.
    Bugzilla Report 49404.
 
+ * The list elements returned by ProjectHelper#getExtensionStack are
+   now String arrays of length 3 rather than 2 in order to support the
+   onMissingExtensionPoint attribute.
+   Bugzilla Report 49473.   
+
 Fixed bugs:
 -----------
 
  * mmap-based file copy problems under JDK 1.4 on Linux.
    Bugzilla Report 49430.
 
  * The Sun JVM tries to mmap the entire file during a copy. 
    For large files this is not feasible. 
    We now explicitly request to copy at most 16 MiB per request.
    Bugzilla Report 49326.
    
  * DemuxInputStream.read() should return unsigned values
    Bugzilla Report 49279.
 
  * The MIME mailer ignored the port parameter when using SSL.
    Bugzilla Report 49267.
 
  * <xslt> ignored the classpath when using the default TraX processor.
    Bugzilla Report 49271.
 
  * <checksum>'s totalproperty only worked reliably if the same file
    name didn't occur inside more than one directory.
    Bugzilla Report 36748.
 
  * <ftp> could fail to download files from remote subdirectories under
    certain circumstances.
    Bugzilla Report 49296.
 
  * <junit> will now produce better diagnostics when it fails to delete
    a temporary file.
    Bugzilla Report 49419.
 
  * Ant would often scan directories even though there were known to
    only hold excluded files when evaluating filesets.  This never
    resulted in wrong results but degraded performance of the scan
    itself.
    Bugzilla Report 49420.
 
  * <javac> failed for long command lines on OS/2.
    Bugzilla Report 49425.
 
  * <junitreport> did not handle encodings well for stdout/stderr.
    Bugzilla Report 49418.
 
  * <junit> could issue a warning about multiple versions of Ant on the
    CLASSPATH if two CLASSPATH entries differed in case on a
    case-insensitive file system.
    Bugzilla Report 49041.
 
 Other changes:
 --------------
 
  * <concat>'s force attribute has been deprecated in favor of a new
    overwrite attribute that is consistent with <copy>'s attribute
    names.
 
  * You can now specify a list of methods to run in a JUnit test case.
    Bugzilla Report 34748.
 
  * properties in files read because of the -propertyfile command line
    option will now get resolved against other properties that are
    defined before the project starts executing (those from the same or
    earlier -propertfiles or defined via the -D option).
    Bugzilla Report 18732.
 
  * <pathelement>s can now contain wildcards in order to use wildcard
    CLASSPATH entries introduced with Java6.
    The wildcards are not expanded or even evaluated by Ant and will be
    used literally.  The resulting path may be unusable as a CLASSPATH
    for Java versions prior to Java6 and likely doesn't mean anything
    when used in any other way than a CLASSPATH for a forked Java VM. 
    Bugzilla Report 46842.
 
+ * A new attribute allows targets to deal with non-existant extensions
+   points, i.e. they can extend and extension-point if it has been
+   defined or silently work as plain targets if it hasn't.  This is
+   useful for targets that get included/imported in different
+   scenarios where a given extension-point may or may not exist.
+   Bugzilla Report 49473.   
+
 Changes from Ant 1.8.0 TO Ant 1.8.1 
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * ant-trax.jar is no longer produced since TrAX is included in JDK 1.4+.
 
  * Ant no longer ships with Apache Xerces-J or the XML APIs but relies
    on the Java runtime to provide a parser and matching API versions.
    
  * The stylebook ant task and the ant-stylebook.jar are removed.  
 
 Fixed bugs:
 -----------
 
  * Tasks that iterate over task or type definitions, references or
    targets now iterate over copies instead of the live maps to avoid
    ConcurrentModificationExceptions if another thread changes the
    maps.
    Bugzilla Report 48310.
 
  * The filesmatch condition threw a NullPointerException when
    comparing text files and the second file contained fewer lines than
    the first one.
    Bugzilla Report 48715.
 
  * Regression: The <ear> task would allow multiple
    META-INF/application.xml files to be added.
    Bugzilla Report 6836.
 
  * VectorSet#remove(Object) would fail if the size of the vector
    equaled its capacity.
    
  * Regression : ant -diagnostics was returning with exit code 1
    Bugzilla Report 48782
    
  * Fix for exec task sometimes inserts extraneous newlines
    Bugzilla Report 48746
    
  * SymlinkTest#testSymbolicLinkUtilsMethods failing on MacOS
    Bugzilla Report 48785.
 
  * If <concat>'s first resourcecollection child is a <resources>,
    any subsequently added child resourcecollection joins the first.
    Bugzilla Report 48816.        
    
  * <get> with an invalid URL could trigger an NPE in some JVMs.
    Bugzilla Report 48833
    
  * Broken Pipe issue under Ubuntu Linux
    Bugzilla Report 48789
    
  * Properties wrongly read from file or not update during read
    Bugzilla Report 48768       
 
  * AntClassLoader in Ant 1.8.0 has been considerably slower than in
    1.7.1
    Bugzilla Report 48853
    
  * ANT_CMD_LINE_ARGS are rippling through lower level Ant usage 
    Bugzilla Report 48876
    
  * email : IO error sending mail with plain mimetype
    Bugzilla Report 48932    
 
  * the complete-ant-cmd.pl script failed to create a proper cache of
    target if "ant -p" failed.
    Bugzilla Report 48980
 
  * <rmic>'s sourcebase attribute was broken.
    Bugzilla Report 48970
 
  * <copy>'s failonerror didn't work as expected when copying a single
    element resource collection to a file.
    Bugzilla Report 49070
 
  * <get> no longer followed redirects if the redirect URL was relative
    and not an absolute URL.
    Bugzilla Report 48972
 
  * fixed a performance degradation in the code that expands property
    references.
    Bugzilla Reports 48961 and 49079
 
  * <jar filesetmanifest="merge"> was broken on Windows.
    Bugzilla Report 49090
 
  * <symlink> delete failed if the link attribute was a relative path
    to a link inside the current directory without a leading ".".
    Bugzilla Report 49137
 
  * <telnet> and <rexec> failed to find the expected strings when
    waiting for responses and thus always failed.
    Bugzilla Report 49173
 
 Other changes:
 --------------
 
  * Project provides new get methods that return copies instead of the
    live maps of task and type definitions, references and targets.
 
  * Ant is now more lenient with ZIP extra fields and will be able to
    read archives that it failed to read in earlier versions.
    Bugzilla Report 48781.
 
  * The <zip> family of tasks has been sped up for bigger archives.
    Bugzilla Report 48755.
    
  * Add removeKeepExtension option to NetRexxC task.
    Bugzilla Report 48788.
 
  * Add prefix attribute to loadproperties task.
 
  * Add resource attribute to length task.
 
  * PropertyResource will effectively proxy another Resource if ${name}
    evaluates to a Resource object.
 
  * Added forcestring attribute to equals condition to force evaluation
    of Object args as strings; previously only API-level usage of the
    equals condition allowed Object args, but Ant 1.8.x+ property
    evaluation may yield values of any type.
    
  * BuildFileTest.assertPropertyUnset() fails with a slightly more 
    meaningful error message
    Bugzilla Report 48834
    
  * <junit> will now throw an exception if a test name is empty.  This
    used to manifest itself in unrelated errors like
    Bugzilla Report 43586.
 
  * A change that made <exec> more reliable on Windows (Bugzilla Report
    5003) strongly impacts the performance for commands that execute
    quickly, like attrib.  Basically no single execution of a command
    could take less than a second on Windows.
    A few timeouts have been tweaked to allow these commands to finish
    more quickly but still they will take longer than they did with Ant
    1.7.1.
    Bugzilla Report 48734.
 
  * Added SimpleBigProjectLogger, intermediate between NoBannerLogger and
    BigProjectLogger.
 
  * <mappedresources> supports new attributes enablemultiplemappings
    and cache.
 
  * Added the augment task to manipulate existing references via Ant's basic
    introspection mechanisms.
 
 Changes from Ant 1.8.0RC1 TO Ant 1.8.0
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * the appendtolines filter has been renamed to suffixlines.
 
 Fixed bugs:
 -----------
 
  * stack traces were not reported at all by <junit/>
    when filtertrace="on", which is the default.
 
  * ant.bat can now also process the -noclasspath switch when it is 
    the first switch on a command line.
    Bugzilla Report 48186.
 
  * <fixcrlf> now tries to delete the created temporary files earlier.
    Bugzilla Report 48506.
 
  * the implementation of <zip> had been changed in a way that broke
    the jarjar links task and protentially other third-party subclasses
    as well.
    Bugzilla Report 48541.
    
  * <scp> task didn't report build file location when a remote operation failed
    Bugzilla Report 48578.  
 
  * <propertyfile> would add the same comment and a date line each time
    it updated an existing property file.
    Bugzilla Report 48558.
 
  * <sound> didn't work properly in recent Java VMs.
    Bugzilla Report 48637.
 
 Other changes:
 --------------
 
 Changes from Ant 1.7.1 TO Ant 1.8.0RC1
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * if and unless attributes (on <target> as well as various tasks and other
    elements) have long permitted ${property} interpolation. Now, if the result
    evaluates to "true" or "false" (or "yes", "no", "on", "off"), that boolean
    value will be used; otherwise the traditional behavior of treating the value
    as a property name (defined ~ true, undefined ~ false) is used. Existing
    scripts could be broken if they perversely defined a property named "false"
    and expected if="false" to be true, or used if="true" expecting this to be
    triggered only if a property named "true" were defined.
 
  * Ant now requires Java 1.4 or later.
 
  * Improved handling of InterruptException (lets suppose someone/thing
    is trying to kill the thread when we receive an
    InterruptException), when an InterruptException is received, we do
    not wait anymore in a while loop till the end time has been
    reached.
    Bugzilla Report 42924.
 
  * Refactor PropertyHelper and introspection APIs to make extension
    more granular and support setting task/type attribute values to
    objects decoded by custom PropertyEvaluator delegates. Also add
    <propertyhelper> task for registering delegates and/or replacing
    the registered PropertyHelper instance.
    Bugzilla Report 42736.
 
  * Added a restricted form of typedef called <componentdef>. This
    allows definition of elements that can only be within tasks or
    types. This method is now used to define conditions, selectors,
    comparators and filterreaders. This means that tasks may now have
    nested conditions just by implementing the Condition interface,
    rather than extending ConditionBase. It also means that the use of
    namespaces for some of the selectors introduced in Ant 1.7.0 is no
    longer necessary.  Implementing this means that the DynamicElement
    work-around introduced in Ant 1.7.0 has been removed.
    Bugzilla Report 40511.
 
  * In the <touch> task when a <mapper> is used, the millis and
    datetime attributes now override the time of the source resource if
    provisioned.
    Bugzilla Report 43235.
 
  * Remove fall-back mechanism for references that are not resolved
    during normal runtime execution.
 
  * FileUtils.createTempFile now actually creates the file.
    The TempFile task still does not create the file by default, can be
    instructed to do so however using a new parameter.
    Bugzilla Report 33969.
   
  * A lock in Project ensured that a BuildListener's messageLogged
    method was only ever executed by a single thread at a time, while
    all other methods could be invoked by multiple threads
    simultaniously (while within <parallel>, for example).  This lock
    is no longer in place, messageLogged should be made thread-safe
    now.
 
  * <sql>'s onError="stop" no longer fails the build if an error
    occurs,  this is the main difference between stop and error and
    matches what the documentation implied.
    Bugzilla Report 24668.
 
  * Ant's configuration introspection mechanisms have been modified to prefer
    Resource and FileProvider attributes to plain java.io.File attributes;
    however the configuration-from-String behavior remains equivalent, rendering
    a FileResource.
 
  * CBZip2InputStream will now throw an IOException if
    passed in a null or empty InputStream to read from.
    Bugzilla Reports 32200.
 
  * <unzip> will now fail when trying to extract certain broken
    archives that would have been silently ignored in earlier version.
    Bugzilla Report 35000.
 
  * Ant's <zip> family of tasks tries to preserve the existing Unix
    permissions when updating archives or copying entries from one
    archive to another.
    Since not all archiving tools support storing Unix permissions in
    the same way that is used by Ant, sometimes the permissions read by
    Ant seem to be 0, which means nobody is allowed to do anything to
    the file or directory.
    If Ant now encounters a permission set of 0 it will assume that
    this is not the intended value and instead apply its own default
    values.  Ant used to create entries with 0 permissions itself.
    The <zip> family of tasks has a new attribute preserve0permissions
    that can be set to restore the old behavior.
    Bugzilla Report 42122.
 
  * If a batch containing multiple JUnit tests running inside a forked
    Java VM caused the VM to crash (or caused a timeout), the
    formatters would receive an error message for the last test in the
    batch.
    Ant will now pass in a test with the name "Batch-With-Multiple-Tests"
    instead - this is supposed to show more clearly that the last test
    may not have started at all.
    Bugzilla Report 45227.
 
  * If the number of minutes a build takes is bigger then 1000 Ant will
    no longer print a thousands separator in the "elapsed time"
    message.  It used to be the thousands separator of the current
    locale.
    Bugzilla Report 44659.
 
  * <symlink action="delete"> used to fail if the link was broken (i.e.
    pointing to a file or directory that no longer existed).  It will now
    silently try to remove the link.
    Bugzilla Report 41285.
 
  * <delete file="..."> used to log a warning and not delete broken
    symbolic links.  <delete dir="..."/> didn't even log a warning.
    The task will now try to delete them in both cases.
    Bugzilla Report 41285.
 
  * if the dir attribute of a <fileset> points to a symbolic link and
    followsymlinks is set to false, the fileset will no longer be
    scanned and always seem empty.
    Bugzilla Report 45741.
 
  * the .NET tasks that have been deprecated since Ant 1.7.0 have been
    removed, please use the stand-alone Antlib you can find at
    http://ant.apache.org/antlibs/dotnet/index.html
    instead.
 
  * the logic of closing streams connected to forked processes (read
    the input and output of <exec> and friends) has been changed to
    deal with cases where child processes of the forked processes live
    longer than their parents and keep Ant from exiting.
    It is unlikely but possible that the changed logic breaks stream
    handling on certain Java VMs.
    Bugzilla issue 5003.
 
  * <checksum>'s totalproperty was platform dependent because it relied
    on java.io.File#compareTo.  It has now been made platform
    independent, which means that totalPropery values obtained on
    Windows (and other systems where the sort order of File is not case
    sensitive) can be different from the values obtained with earlier
    versions of Ant.
    Bugzilla Report 36748.
 
  * globmapper didn't work properly if the "to" or "from" patterns
    didn't contain a "*".  In particular it implicitly added a * to the
    end of the pattern(s).  This is no longer the case.  If you relied
    on this behavior you will now need to explicitly specify the
    trailing "*".
    Bugzilla Report 46506.
 
  * <copy> silently ignored missing resources even with
    failOnError="true".  If your build tries to copy non-existant
    resources and you relied on this behavior you must now explicitly
    set failOnError to false.
    Bugzilla Report 47362.
 
  * Ant now prefers the java.runtime.version system property over
    java.vm.version for the Created-By Manifest attribute.
    Bugzilla Report 47632.
 
  * The <image> task now supports a nested mapper.  In order to
    implement this, the Java API of the task had to change so any
    custom subclass overriding the processFile method will need to
    adapt (by overriding the new two-arg processFile method).
    Bugzilla Report 23243.
 
  * A new property syntax can be used to set attributes from
    references: ${ant.ref:some-reference}
 
    In most cases this will yield the exact same result as 
    ${toString:some-reference} - only when an attribute setter method
    accepts an object type other than string and the project's
    reference is an Object of matching type the new syntax will pass in
    that object.
 
    If your build file already contains properties whose name starts
    with "ant.ref:" there is a potential for collision.  If your
    property has been set, normal property expansion will take
    precedence over the new syntax.  If the property has not been set
    and a reference with the postfix of your property name exists
    (i.e. in a very unlikely event) then the new syntax would yield a
    different result (an expanded property) than Ant 1.7.1 did.
 
  * A ProjectHelper implementation can now provide the default build file
    name it is expecting, and can specify if they can support a specific build
    file. So Ant is now capable of supporting several ProjectHelper
    implementations, deciding on which to use depending of the input build file.
 
  * Mapper-aware selectors (depends, different, present) now accept typedef'd
    FileNameMappers.
 
 Fixed bugs:
 -----------
 
  * The default logger was failing to print complete stack traces for
    exceptions other than BuildException when inside <ant> or
    <antcall>, thus omitting often important diagnostic
    information.
    Bugzilla 43398 (continued).
 
  * Better handling of package-info.class.
    Bugzilla Report 43114.
 
  * RPM task needed an inserted space between the define and the value.
    Bugzilla Report 46659.
 
  * Got rid of deadlock between in, out and err in the Redirector. 
    Bugzilla Report 44544.
 
  * Caused by AssertionError no longer filtered.
    Bugzilla Report 45631.
  
  * <zip> would sometimes recreate JARs unnecessarily.
    Bugzilla Report 45902.
 
  * <symlink> task couldn't overwrite existing symlinks that pointed to
    nonexistent files
    Bugzilla Report 38199.
 
  * <symlink> task couldn't overwrite files that were in the way of the symlink.
    Bugzilla Report 43426.
    
  * <symlink> task failonerror="false" does not stop build from failing
    when 'ln' command returns non-zero.
    Bugzilla Report 43624  
 
  * <touch> task couldn't differentiate between "no resources
    specified" and "no resources matched."
    Bugzilla Report 43799.
 
  * ManifestClassPath failed when a relative path would traverse the
    file system root.
    Bugzilla Report 44499.
 
  * <globmapper> had an indexoutofbounds when the prefix and postfix
    overlapped.
    Bugzilla Report 44731.
    
  * <typedef> and <taskdef> failed to accept file names with #
    characters in them.
    Bugzilla Report 45190
 
  * A deadlock could occur if a BuildListener tried to access an Ant property
    within messageLogged while a different thread also accessed one.
    Bugzilla Report 45194
 
  * Handle null result of system getProperty() in CommandlineJava.
    Similar to Bugzilla Report 42334.
 
  * Length task did not process nonexistent Resources even though these might
    conceivably still carry file length information.
    Bugzilla Report 45271.
 
  * <javac>'s includeJavaRuntime="false" should work for gcj now.  Note
    that you may need to set includeAntRuntime to false in order to
    have full control.
    Bugzilla Report 34638.
 
  * <sql> would fail if the executed statment didn't return a result
    set with some JDBC driver that dissalow Statement.getResultSet to
    be called in such a situation.
    Bugzilla Report 36265 
 
  * if the executed statement in <sql> returned a result set and an
    update count, the count would be lost.
 
  * if an executed statement in <sql> mixes update count and result set
    parts, some result sets wouldn't get printed.
    Bugzilla Report 32168.
 
  * XmlLogger could lose messages if <parallel> is used.
    Bugzilla Report 25734.
 
  * <scp> creates remoteToDir if it doesn't exist.
    Bugzilla Report 42781
 
  * CBZip2OutputStream threw an exception if it was closed prior to
    writing anything.
    Bugzilla Reports 32200, 45836
 
  * The IPlanetDeploymentTool didn't use the configured DTD locations.
    Bugzilla Report 31876.
 
  * The ant shell script printed a warning under Cygwin if JAVA_HOME
    was not set.
    Bugzilla Report 45245.
 
  * <filterset> sometimes incorrectly flagged infinite recursions of
    filter tokens
    Bugzilla Report 44226.
    
  * failures were treated as errors in forked JUnit tests when JUnit 4
    was used.
    Bugzilla Report 43892.
 
  * <jar> and <manifest> disallowed manifest attributes whose name
    contained the character '8'.
    Bugzilla Report 45675.
 
  * BigProjectLogger would set the project's basedir to the current
    working directory.
    Bugzilla Report 45607.
 
  * only <formatter>s that logged to a file were notified if forked VM
    crashed or a timeout occured in <junit>.
    Bugzilla Report 37312.
 
  * ant -v -version would print the version information twice.
    Bugzilla Report 45695.
 
  * when nested into builds that have been invoked by <ant> tasks
    <subant> might set the wrong basedir on the called projects.
    Bugzilla Report 30569.
 
  * If the message of the failed assertion of a forked JUnit test
    contained line feeds some excess output ended up in Ant's log.
    Bugzilla Report 45411.
 
  * <symlink action="delete"> failed to delete a link that pointed to
    a parent directory.
    Bugzilla Report 45743.
 
  * <symlink action="delete"> failed if ant lacked permission to rename
    the link's target.
    Bugzilla Report 41525.
 
  * when checking whether a jar is signed, <signjar> ignored the
    sigfile attribute.
    Bugzilla Report 44805.
 
  * When using JavaMail all <mail> tasks used the same mail host
    regardless of their configuration.
    Bugzilla Report 37970.
 
  * <signjar> and <issigned> didn't handle aliases with characters other
    than numbers, letters, hyphen or underscore properly.
    Bugzilla Report 45820.
 
  * <filterset> could miss multi-character begin tokens in some cases.
    Bugzilla Report 45094.
 
  * <depend> didn't close JARs that were part of the classpath.
    Bugzilla Report 45955.
 
  * in some cases <depend> would delete class files even if it didn't
    find the corresponding source files.
    Bugzilla Report 45916.
 
  * <javadoc> failed if the nested <bottom> or <head> contained line
    breaks.
    Bugzilla Report 43342.
 
  * encoding="auto" has been broken in <mail> since Ant 1.7.0 and only
    worked if JavaMail was available.
    Bugzilla Report 42389.
 
  * MailLogger could cause a NullPointerException.
    Bugzilla Report 44009.
 
  * <junit> didn't recognize failed assertions as failures if they
    caused subclasses of AssertionError to be thrown (like
    org.junit.ComparisonFailure that is thrown when assertEquals
    fails).
    Bugzilla Report 45028.
 
  * the Unix "ant" wrapper script failed to protect wildcards in
    command line arguments in some cases.
    Bugzilla Report 31601.
 
  * <cvstagdiff> crippled file names and could miss some entries if
    multiple modules have been specified.
    Bugzilla Report 35301.
 
  * Tasks with a "public void add(SomeType)" method failed to work as
    TaskContainers at the same time.
    Bugzilla Report 41647.
 
  * Tasks that implementes DynamicElemen or DynamicElementNS failed to
    work as TaskContainers at the same time.
    Bugzilla Report 41647.
 
  * combining SSL and authentication in <mail> and MailLogger failed in
    some setups.
    Bugzilla Report 46063.
 
  * if an error occurs while logging the buildFinished event, the
    original error is now logged to System.err.
    Bugzilla Report 25086.
 
  * <copy> failed with a NullPointerException when copying a resource
    without a name.  It will now fail with a meaningful error message.
    Bugzilla Report 39960.
 
  * <xslt> now uses the configured classpath to load the factory (when
    using TraX) before falling back to Ant's own classpath.
    Bugzilla Report 46172.
 
  * <dependset> complained about files being modified in the future if
    they had been just very recently (within Ant's assumed granularity
    of the file system).
    Bugzilla Report 43665.
 
  * <sshexec> didn't store the ouput in outputproperty if the remote
    command failed.
    Bugzilla Report 46340.
 
  * DirectoryScanner's slow-scanning algorithm that is used when you
    ask for excluded or not-included files and/or directories could
    miss some files and directories in the presence of recursive
    exclude patterns.
 
  * <sort> resource collection kept only one of entries deemed equal by
    the chosen Comparator.
    Bugzilla Report 46527.
 
  * the ZipFile class used by <unzip> and others could leave the
    archive open (making it undeletable on Windows as long as the java
    VM was running) for files with an unexpected internal structure.
    Bugzilla Report 46559.
 
  * The zip package now supports the extra fields invented by InfoZIP
    in order to store Unicode file names and comments.
 
  * The zip package detects the encoding bit set by more modern
    archivers when they write UTF-8 filenames and optionally sets it
    when writing zips or jars.
    Bugzilla Report 45548
 
  * <sync> could run into a NullPointerException when faced with broken
    symbolic links.
    Bugzilla Report 46747.
 
  * The ant shell script should now support MSYS/MinGW as well.
    Bugzilla Report 46936.
 
  * <signjar> has a new force attribute that allows re-signing of jars
    that are already signed.
    Bugzilla Report 46891.
 
  * <sshexec> now again honors failonerror in the face of connection
    errors.
    Bugzilla Report 46829.
 
  * The <replacetokens> filter threw an exception if the stream to
    filter ended with a begin token.
    Bugzilla Report 47306.
 
  * <scriptmapper>, <scriptfilter> and <scriptcondition> didn't support
    the setbeans attribute.
    Bugzilla Report 47336.
 
  * <loadproperties>' encoding attribute didn't work.
    Bugzilla Report 47382.
 
  * Ant created tar archives could contain random bytes at the end
    which confused some untar implementations.
    Bugzilla Report 47421.
 
  * various places where unchecked PrintWriters could hide exceptions
    have been revisited to now check the error status or not use a
    PrintWriter at all.
    Bugzilla Report 43537.
 
  * filesetmanifest="mergewithoutmain" in <jar> didn't treat inline
    manifests as expected.
    Bugzilla Report 29731.
 
  * <record> didn't work properly with nested builds.
    Bugzilla Report 41368. 
 
  * <jar> with filesetmanifest different from skip didn't work if the
    update attribute has been set to true.
    Bugzilla Report 30751.
 
  * The default stylesheets for <junitreport> failed to properly escape
    XML content in exception stack traces.
    Bugzilla Report 39492.
 
  * AntClassLoader didn't set the proper CodeSource for loaded classes.
    Bugzilla Report 20174.
 
  * AntClassLoader.getResourceAsStream would return streams to
    resources it didn't return with getResource and to classes it
    failed to load.
    Bugzilla Report 44103.
 
  * Logging exceptions without a message would cause a
    NullPointerException.
    Bugzilla Report 47623.
 
  * WeblogicDeploymentTool could fail on platforms with a file
    separator other than "/".
    Bugzilla Report 35649.
 
  * The update attribute of the modified selector was ignored.
    Bugzilla Report 32597.
 
  * <manifest> and <jar> can now merge Class-Path attributes from
    multiple sources and optionally flatten them into a single
    attribute.
    The default behaviour still is to keep multiple Class-Path
    attributes if they have been specified and to only include the
    attributes of the last merged manifest.
    Bugzilla Report 39655.
 
  * <delete> didn't work correctly with a <modified> selector because
    it was scanning the same filesets more than once.
    Bugzilla Report 43574.
 
  * when using custom filterreaders with the <filterreader classname="">
    syntax Ant could leak memory.
    The problem didn't occur when using <typedef> or <componentdef> to
    define the filterreader which is the recommended approach.
    Bugzilla Report 45439.
 
  * Ant didn't set the proper "magic" value for tar entries containing
    long file names in GNU longfile mode.
    Bugzilla Report 47653.
 
  * The tar task failed to recognize that the archive had to be
    (re-)created in some cases where the sources are filesystem based
    resources but not filesets.
    Bugzilla Report 48035. 
 
  * <sshexec>'s outputproperty was prefixed by the executed command
    when the command attribute has been used, breaking backwards
    compatibility to Ant 1.7.0.
    Bugzilla Report 48040.
 
  * different task instances of the same <scriptdef>ed tasks could
    overwrite each others attributes/nested elements.
    Bugzilla Report 41602.
 
  * The Hashvalue algortihm implementation of the modified task could
    fail to read the file(s) completely.
    Bugzilla Report 48313.
 
 Other changes:
 --------------
 
  * The get task now also follows redirects from http to https
    Bugzilla Report 47433
 
  * A HostInfo task was added performing information on hosts, including info on 
    the host ant is running on. 
    Bugzilla Reports 45861 and 31164.
 
  * There is now a FileProvider interface for resources that act as a source
    of filenames. This should be used by tasks that require resources
    to provide filenames, rather than require that all resources
    are instances or subclasses of FileResource.
    Bugzilla Report 43348
    
  * There is now a URLProvider interface for resources that act as a
    source of URLs. This should be used by tasks that require resources
    to provide URLs, rather than require that all resources are
    instances or subclasses of URLResource.
    
  * Fixcrlf now gives better error messages on bad directory attributes.
    Bugzilla Report 43936
    
  * a new property ant.project.default-target holds the value of the
    current <project>'s default attribute.
 
  * a new property ant.project.invoked-targets holds a comma separated
    list of the targets that have been specified on the command line
    (the IDE, an <ant> task ...) when invoking the current project.
 
  * The <type> resource selector has had an "any" type added for better
    configurability.
 
  * Ant should detect the OS as both a Mac and a Unix system when
    running on OpenJDK.
    Bugzilla Report 44889.
 
  * new protected getConnection and getStatement methods allow
    subclasses of SQLExec more control - or access to the cached
    instances when overriding other methods like runStatements.
    Bugzilla Report 27178.
 
  * <sql> has a new failOnConnectionError attribute that can be used to
    keep a build going even if the task failed to connect to the
    database.
    Bugzilla Report 36712.
 
  * A new attribute strictDelimiterMatching can be used to ignore case
    or whitespace differences when <sql> searches for delimiters.
    This is useful if you execute a SQL script that has contains "GO"
    and "go" as delimiters.
    Bugzilla Report 26459.
 
  * A new showWarnings attribute of <sql> allows warnings to be logged.
    Bugzilla Report 41836.
 
  * A new treatWarningsAsErrors attribute of <sql> can be used to fail
    a build if a warning occurs.
    Bugzilla Report 41836.
 
  * Ant now supports scoped properties (see Local task).
    Bugzilla Report 23942.
 
  * <sql>'s CSV output can be controlled via the new attributes
    csvColumnSeparator and csvQuoteCharacter.
    Bugzilla Report 35627.
 
  * <ftp>'s logging has been improved.
    Bugzilla Reports 30932, 31743.
 
  * It is now possible to disable <ftp>'s remote verification.
    Bugzilla Report 35471.
 
  * <sshexec> now supports input in a way similar to <exec>
    Bugzilla Report 39197.
 
  * <scp> can now preserve the file modification time when downloading
    files.
    Bugzilla Report 33939.
 
  * the new task sshsession can run multiple tasks in the presence of
    an SSH session providing (local and remote) tunnels.
    Bugzilla Report 43083.
 
  * ZipOutputStream has been sped up for certain usage scenarios that
    are not used by Ant's family of zip tasks.
    Bugzilla Report 45396.
 
  * <echo> supports an "output" Resource attribute as an alternative to "file".
 
  * <sql> "output" attribute now supports any Resource in addition to a file.
 
  * <scp> no longer requires a passphrase when using key based
    authentication.
    Bugzilla Report 33718.
 
  * a new failOnEmptyArchive attribute on <unzip> and <untar> can now
    make the task fail the build if it tries to extract an empty
    archive.
 
  * <unzip> and <untar> have a new attribute stripAbsolutePathSpec.
    When set to true, Ant will remove any leading path separator from
    the archived entry's name before extracting it (making the name a
    relative file name).
    Bugzilla Report 28911.
 
  * <unzip> will now detect that it was asked to extract a file that is
    not an archive earlier if the file is big.
    Bugzilla Report 45463.
 
  * New file and resource selectors <readable/> and <writable/> have
    been added that select file which the current process can read or
    write.
    Bugzilla Report 45081.
 
  * The filename file selector has a new attribute regex that allows
    files to be selected by matching their names against a regular
    expression.
    Bugzilla Report 45284
 
  * The name resource selector has a new attribute regex that allows
    resources to be selected by matching their names against a regular
    expression.
    Bugzilla Report 45284
 
  * Enhanced performance of Project.fireMessageLoggedEvent and DirectoryScanner 
    Bugzilla Reports 45651 and 45665
 
  * The package list location for offline links can now be specified as
    an URL.
    Bugzilla Report 28881
 
  * <echoxml> now supports XML namespaces.
    Bugzilla Report 36804.
 
  * A new listener for <junit> has been added that tries to invoke the
    tearDown method of a TestCase if that TestCase was run in a forked
    VM and the VM crashed or a timeout occured.  See the <junit> task's
    manual page for details.
    Bugzilla Report 37241.
 
  * The Jar task now supports the addition of a jar index file in update mode.
    Previously the absence of the index was not enough to trigger the rebuild;
    some other update was necessary.
    Bugzilla report 45098.
 
  * <ant> has a new attribute "useNativeBasedir" that makes the child
    build use the same basedir it would have used if invoked from the
    command line.  No matter what other attributes/properties have been
    set.
    Bugzilla Report 45711.
 
  * <patch> has a new optional failOnError attribute.
    Bugzilla Report 44772.
 
  * Antlib descriptors will now be parsed by the configured
    ProjectHelper if the implementation overrides the new
    canParseAntlibDescriptor and parseAntlibDescriptor methods.  If the
    configured helper doesn't override the methods, a new instance of
    ProjectHelper2 will be used just like in Ant 1.7.1.
    Bugzilla Report 42208.
 
  * It is now possible to explicitly set the executable used by
    <signjar>.
    Bugzilla Report 39189.
 
  * <compositemapper>'s order of results is now predictable.
    Bugzilla Report 44873
 
  * a new <firstmatchmapper> has been added, which works similar to
    <compositemapper> but only returns the results of the first nested
    mapper that matches.
    Bugzilla Report 44873
 
  * <get> has a new maxtime attribute that terminates downloads that
    are taking too long.
    Bugzilla Report 45181.
 
  * <ftp> now supports selectors for remote directories as well.
    Bugzilla Report 44726.
 
  * In some cases Ant fails to rename files if the source or target
    file has just recently been closed on Windows.  It will now try to
    delete the offending file once again after giving the Java VM time
    to really close the file.
    Bugzilla Report 45960.
 
  * two new properties can be used to set the MIME-Type and charset
    used by MailLogger.
    Bugzilla Report 27211.
 
  * a new attribute of <mail> allows the task to succeed if it can
    reach at least one given recipient.
    Bugzilla Report 36446.
 
  * two new properties allow MailLogger to send a fixed text instead of
    the log file.
    Bugzilla Report 38029.
 
  * <cvsversion> is supposed to support CVSNT now.
    Bugzilla Report 31409.
 
  * <cvs>' port attribute should now work for all clients that use the
    environment variable CVS_PSERVER_PORT instead of the "official"
    CVS_CLIENT_PORT.
    Bugzilla Report 30124.
 
  * <cvsversion> now works for local repositories as well.
 
  * <cvstagdiff> has an option to ignore removed files now.
    Bugzilla Report 26257.
 
  * <cvs> and friends now support modules with spaces in their names
    via nested <module> elements.
 
  * A new attribute "ignoreEmpty" controls how <concat> deals when
    there are no resources to concatenate.  If it is set to false, the
    destination file will be created regardless, which reinstates the
    behavior of Ant 1.7.0.
    Bugzilla Report 46010.
 
  * If the new remote attribute is set to true, <cvschangelog> can now
    work against a remote repository without any working copy.
    Bugzilla Report 27419.
 
  * start and end tags can now be used instead of dates in
    <cvschangelog>.
    Bugzilla Report 27419.
 
  * MailLogger and <mail> can now optionally enable support for
    STARTTLS.
    Bugzilla Report 46063.
 
  * <import> has new attributes "as" and "prefixSeparator" that can be
    used to control the prefix prepended to the imported targets'
    names.
 
  * a new task <include> provides an alternative to <import> that
    should be preferred when you don't want to override any targets.
 
  * delete has a new attribute removeNotFollowedSymlink.  If set to
    true, symbolic links not followed (because followSymlinks was false
    or the number of symlinks was too big) will be removed.
    Bugzilla Report 36658.
 
  * the os and osfamily attributes of <chown>, <chgrp>, <chmod> and
    <attrib> can now be used to run the commands on operating systems
    other than their "native" environment, i.e. non-Unix or non-Windows
    operating systems respectively.
    Bugzilla Report 7624.
 
  * a new resource collection <mappedresources> generalizes the prefix
    and fullpath attributes of <zipfileset> to arbitrary mappers that
    can be applied to arbitrary resource collections.
    Bugzilla Report 4240.
 
  * <tarfileset> and <zipfileset> have a new attribute
    errorOnMissingArchive that allows "optional" filesets that don't
    break the build if the archive doesn't exist.
    Bugzilla Report 46091.
 
  * <javadoc> has new attributes that correspond to the
    -docfilessubdirs and -excludedocfilessubdir command line arguments.
    Bugzilla Report 34455.
 
  * <xslt> now fails early if a specified stylesheet doesn't exist.
    Bugzilla Report 34525.
 
  * <xslt> now has an option to supress transformer warnings.  This
    option only has an effect for processors that support this feature;
    the "trax" processor included with Ant does support it.
diff --git a/contributors.xml b/contributors.xml
index 76157d616..c72594345 100644
--- a/contributors.xml
+++ b/contributors.xml
@@ -1,1306 +1,1310 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 -->
 <!DOCTYPE contributors
 [
 <!ELEMENT name (first?, middle?, last)>
 <!ELEMENT contributors (introduction, name+)>
 <!ELEMENT first (#PCDATA)>
 <!ELEMENT introduction (#PCDATA)>
 <!ELEMENT middle (#PCDATA)>
 <!ELEMENT last (#PCDATA)>
 ]
 >
 
 <contributors>
   <introduction>
   These are some of the many people who have helped Ant become so successful.
   </introduction>
   <name>
     <first>Adam</first>
     <last>Blinkinsop</last>
   </name>
   <name>
     <first>Adam</first>
     <last>Bryzak</last>
   </name>
   <name>
     <first>Adam</first>
     <last>Sotona</last>
   </name>
   <name>
     <first>Aleksandr</first>
     <last>Ishutin</last>
   </name>
   <name>
     <first>Alex</first>
     <last>Rosen</last>
   </name>
   <name>
     <first>Alexei</first>
     <last>Yudichev</last>
   </name>
   <name>
     <first>Alexey</first>
     <last>Panchenko</last>
   </name>
   <name>
     <first>Alexey</first>
     <last>Solofnenko</last>
   </name>
   <name>
     <first>Alison</first>
     <last>Winters</last>
   </name>
   <name>
     <first>Andreas</first>
     <last>Ames</last>
   </name>
   <name>
     <first>Andrew</first>
     <last>Everitt</last>
   </name>
   <name>
     <first>Andrew</first>
     <last>Stevens</last>
   </name>
   <name>
     <first>Andrey</first>
     <last>Urazov</last>
   </name>
   <name>
     <first>Andy</first>
     <last>Wood</last>
   </name>
   <name>
     <first>Anil</first>
     <middle>K.</middle>
     <last>Vijendran</last>
   </name>
   <name>
     <first>Anli</first>
     <last>Shundi</last>
   </name>
   <name>
     <first>Anthony</first>
     <last>Green</last>
   </name>
   <name>
     <first>Antoine</first>
     <last>Baudoux</last>
   </name>
   <name>
     <first>Antoine</first>
     <last>Levy-Lambert</last>
   </name>
   <name>
     <first>Anton</first>
     <last>Mazkovoi</last>
   </name>
   <name>
     <first>Arnaud</first>
     <last>Vandyck</last>
   </name>
   <name>
     <first>Arnout</first>
     <middle>J.</middle>
     <last>Kuiper</last>
   </name>
   <name>
     <first>Aslak</first>
     <last>Helles&#244;y</last>
   </name>
   <name>
     <first>Atsuhiko</first>
     <last>Yamanaka</last>
   </name>
   <name>
     <first>Avik</first>
     <last>Sengupta</last>
   </name>
   <name>
     <first>Balazs</first>
     <last>Fejes 2</last>
   </name>
   <name>
     <first>Bart</first>
     <last>Vanhaute</last>
   </name>
   <name>
     <first>Benjamin</first>
     <last>Burgess</last>
   </name>
   <name>
     <first>Ben</first>
     <last>Galbraith</last>
   </name>
   <name>
     <first>Benoit</first>
     <last>Moussaud</last>
   </name>
   <name>
     <first>Bernd</first>
     <last>Dutkowski</last>
   </name>
   <name>
     <first>Brad</first>
     <last>Clark</last>
   </name>
   <name>
     <first>Brant</first>
     <middle>Langer</middle>
     <last>Gurganus</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Curnow</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Deitte</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Felder</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Repko</last>
   </name>
   <name>
     <first>Bruce</first>
     <last>Atherton</last>
   </name>
   <name>
     <first>Charles</first>
     <last>Hudak</last>
   </name>
   <name>
     <first>Charlie</first>
     <last>Hubbard</last>
   </name>
   <name>
     <first>Chris</first>
     <last>Povirk</last>
   </name>
   <name>
     <first>Christian</first>
     <last>Knorr</last>
   </name>
   <name>
     <first>Christoph</first>
     <last>Wilhelms</last>
   </name>
   <name>
     <first>Christophe</first>
     <last>Labouisse</last>
   </name>
   <name>
     <first>Christopher</first>
     <middle>A.</middle>
     <last>Longo</last>
   </name>
   <name>
     <first>Christopher</first>
     <last>Charlier</last>
   </name>
   <name>
     <first>Clark</first>
     <last>Archer</last>
   </name>
   <name>
     <first>Clemens</first>
     <last>Hammacher</last>
   </name>
   <name>
     <first>Clement</first>
     <last>OUDOT</last>
   </name>
   <name>
     <first>Conor</first>
     <last>MacNeill</last>
   </name>
   <name>
     <first>Craeg</first>
     <last>Strong</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Cottingham</last>
   </name>
   <name>
     <first>Craig</first>
     <middle>R.</middle>
     <last>McClanahan</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Ryan</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Richardson</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Sandvik</last>
   </name>
   <name>
     <first>Curt</first>
     <last>Arnold</last>
   </name>
   <name>
     <first>Curtis</first>
     <last>White</last>
   </name>
   <name>
     <first>Cyrille</first>
     <last>Morvan</last>
   </name>
   <name>
     <first>D'Arcy</first>
     <last>Smith</last>
   </name>
   <name>
     <first>Dale</first>
     <last>Anson</last>
   </name>
   <name>
     <first>Dale</first>
     <last>Sherwood</last>
   </name>
   <name>
     <first>Dan</first>
     <last>Armbrust</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Henrique</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Ribagnac</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Spilker</last>
   </name>
   <name>
     <first>Danno</first>
     <last>Ferrin</last>
   </name>
   <name>
+    <first>Danny</first>
+    <last>Yates</last>
+  </name>
+  <name>
     <first>Dante</first>
     <last>Briones</last>
   </name>
   <name>
     <first>Davanum</first>
     <last>Srinivas</last>
   </name>
   <name>
     <first>Dave</first>
     <last>Brondsema</last>
   </name>
   <name>
     <first>Dave</first>
     <last>Brosius</last>
   </name>
   <name>
     <first>David</first>
     <last>A.</last>
   </name>
   <name>
     <first>David</first>
     <last>Crossley</last>
   </name>
   <name>
     <first>David</first>
     <last>G&#228;rtner</last>
   </name>
   <name>
     <first>David</first>
     <middle>S.</middle>
     <last>Johnson</last>
   </name>
   <name>
     <first>David</first>
     <last>Kavanagh</last>
   </name>
   <name>
     <first>David</first>
     <last>LeRoy</last>
   </name>
   <name>
     <first>David</first>
     <last>Leal</last>
   </name>
   <name>
     <first>David</first>
     <middle>M.</middle>
     <last>Lloyd</last>
   </name>
   <name>
     <first>David</first>
     <last>Maclean</last>
   </name>
   <name>
     <first>David</first>
     <last>Rees</last>
   </name>
   <name>
     <first>Denis</first>
     <last>Hennessy</last>
   </name>
   <name>
     <first>Derek</first>
     <last>Slager</last>
   </name>
   <name>
     <first>Diane</first>
     <last>Holt</last>
   </name>
   <name>
     <first>dIon</first>
     <last>Gillard</last>
   </name>
   <name>
     <first>Dmitry</first>
     <middle>A.</middle>
     <last>Kuminov</last>
   </name>
   <name>
     <first>Dominique</first>
     <last>Devienne</last>
   </name>
   <name>
     <first>Donal</first>
     <last>Quinlan</last>
   </name>
   <name>
     <first>Don</first>
     <last>Bnamen</last>
   </name>
   <name>
     <first>Don</first>
     <last>Ferguson</last>
   </name>
   <name>
     <first>Don</first>
     <last>Jeffery</last>
   </name>
   <name>
     <first>Drew</first>
     <last>Sudell</last>
   </name>
   <name>
     <first>Eduard</first>
     <last>Wirch</last>
   </name>
   <name>
     <first>Edwin</first>
     <last>Woudt</last>
   </name>
   <name>
     <first>Eli</first>
     <last>Tucker</last>
   </name>
   <name>
     <first>Emmanuel</first>
     <last>Bourg</last>
   </name>
   <name>
     <first>Eric</first>
     <last>Olsen</last>
   </name>
   <name>
     <first>Eric</first>
     <last>Pugh</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Hatcher</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Langenbach</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Meade</last>
   </name>
   <name>
     <first>Ernst</first>
     <last>de Haan</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Harnack</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Somers</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Zeyda</last>
   </name>
   <name>
     <first>Frédéric</first>
     <last>Bothamy</last>
   </name>
   <name>
     <first>Frederic</first>
     <last>Lavigne</last>
   </name>
   <name>
     <first>Gary</first>
     <middle>S.</middle>
     <last>Weaver</last>
   </name>
   <name>
     <first>Gautam</first>
     <last>Guliani</last>
   </name>
   <name>
     <first>Gene-Sung</first>
     <last>Chung</last>
   </name>
   <name>
     <first>Georges-Etienne</first>
     <last>Legendre</last>
   </name>
   <name>
     <first>Gero</first>
     <last>Vermaas</last>
   </name>
   <name>
     <first>Gerrit</first>
     <last>Riessen</last>
   </name>
   <name>
     <first>Gilbert</first>
     <last>Rebhan</last>
   </name>
   <name>
     <first>Gilles</first>
     <last>Scokart</last>
   </name>
   <name>
     <first>Glenn</first>
     <last>McAllister</last>
   </name>
   <name>
     <first>Glenn</first>
     <last>Twiggs</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Nelson</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Roodt</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Schueler</last>
   </name>
   <name>
     <first>Günther</first>
     <last>Kögel</last>
   </name>
   <name>
     <first>Harish</first>
     <last>Prabandham</last>
   </name>
   <name>
     <first>Haroon</first>
     <last>Rafique</last>
   </name>
   <name>
     <first>Hiroaki</first>
     <last>Nakamura</last>
   </name>
   <name>
     <first>Holger</first>
     <last>Engels</last>
   </name>
   <name>
     <first>Holger</first>
     <last>Joest</last>
   </name>
   <name>
     <first>Ignacio</first>
     <last>Coloma</last>
   </name>
   <name>
     <first>Ingenonsya</first>
     <last>France</last>
   </name>
   <name>
     <first>Ingmar</first>
     <last>Stein</last>
   </name>
   <name>
     <first>Irene</first>
     <last>Rusman</last>
   </name>
   <name>
     <first>Ivan</first>
     <last>Ivanov</last>
   </name>
   <name>
     <first>J</first>
     <last>Bleijenbergh</last>
   </name>
   <name>
     <first>Jack</first>
     <middle>J.</middle>
     <last>Woehr</last>
   </name>
   <name>
     <first>James</first>
     <middle>Duncan</middle>
     <last>Davidson</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Mat&#232;rne</last>
   </name>
     <name>
       <first>Jan</first>
       <last>Cumps</last>
     </name>
   <name>
     <first>Jan</first>
     <last>Mynarik</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Hunter</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Pettiss</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Salter</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Yip</last>
   </name>
   <name>
     <first>Jay</first>
     <middle>Dickon</middle>
     <last>Glanville</last>
   </name>
   <name>
     <first>Jay</first>
     <last>Peck</last>
   </name>
   <name>
     <first>Jay</first>
     <last>van der Meer</last>
   </name>
   <name>
     <first>JC</first>
     <last>Mann</last>
   </name>
   <name>
     <first>J</first>
     <last>D</last>
   </name>
   <name>
     <first>Jean-Francois</first>
     <last>Brousseau</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Gettle</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Martin</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Tulley</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Turner</last>
   </name>
   <name>
     <first>Jene</first>
     <last>Jasper</last>
   </name>
   <name>
     <first>Jeremy</first>
     <last>Mawson</last>
   </name>
   <name>
     <first>Jerome</first>
     <last>Lacoste</last>
   </name>
   <name>
     <first>Jesse</first>
     <last>Glick</last>
   </name>
   <name>
     <first>Jesse</first>
     <last>Stockall</last>
   </name>
   <name>
     <first>Jim</first>
     <last>Allers</last>
   </name>
   <name>
     <first>Joerg</first>
     <last>Wassmer</last>
   </name>
   <name>
     <first>Joey</first>
     <last>Richey</last>
   </name>
   <name>
     <first>Johann</first>
     <last>Herunter</last>
   </name>
   <name>
     <first>John</first>
     <last>Sisson</last>
   </name>
   <name>
     <first>Jon</first>
     <last>Dickinson</last>
   </name>
   <name>
     <first>Jon</first>
     <last>Skeet</last>
   </name>
   <name>
     <first>Jon</first>
     <middle>S.</middle>
     <last>Stevens</last>
   </name>
   <name>
     <first>Jose</first>
     <middle>Alberto</middle>
     <last>Fernandez</last>
   </name>
   <name>
     <first>Josh</first>
     <last>Lucas</last>
   </name>
   <name>
     <first>Joseph</first>
     <last>Walton</last>
   </name>
   <name>
     <first>Juerg</first>
     <last>Wanner</last>
   </name>
   <name>
     <first>Julian</first>
     <last>Simpson</last>
   </name>
   <name>
     <first>Justin</first>
     <last>Vallon</last>
   </name>
   <name>
     <first>Keiron</first>
     <last>Liddle</last>
   </name>
   <name>
     <first>Keith</first>
     <last>Visco</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Greiner</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Jackson</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Ross</last>
   </name>
   <name>
     <first>Kevin</first>
     <middle>Z</middle>
     <last>Grey</last>
   </name>
   <name>
     <first>Kim</first>
     <last>Hansen</last>
   </name>
   <name>
     <first>Kirk</first>
     <last>Wylie</last>
   </name>
   <name>
     <first>Kyle</first>
     <last>Adams</last>
   </name>
   <name>
     <first>Larry</first>
     <last>Shatzer</last>
   </name>
   <name>
     <first>Larry</first>
     <last>Streepy</last>
   </name>
   <name>
     <first>Les</first>
     <last>Hughes</last>
   </name>
   <name>
     <first>Levi</first>
     <last>Cook</last>
   </name>
   <name>
     <last>lucas</last>
   </name>
   <name>
     <first>Ludovic</first>
     <last>Claude</last>
   </name>
   <name>
     <first>Magesh</first>
     <last>Umasankar</last>
   </name>
   <name>
     <first>Maneesh</first>
     <last>Sahu</last>
   </name>
   <name>
     <first>Marcel</first>
     <last>Schutte</last>
   </name>
   <name>
     <first>Marcus</first>
     <last>Börger</last>
   </name>
   <name>
     <first>Mario</first>
     <last>Frasca</last>
   </name>
   <name>
     <first>Mariusz</first>
     <last>Nowostawski</last>
   </name>
   <name>
     <first>Mark</first>
     <last>Hecker</last>
   </name>
   <name>
     <first>Mark</first>
     <last>Salter</last>
   </name>
   <name>
     <first>Mark</first>
     <middle>R.</middle>
     <last>Diggory</last>
   </name>
   <name>
     <first>Mark</first>
     <middle>A.</middle>
     <last>Ziesemer</last>
   </name>
   <name>
     <first>Martijn</first>
     <last>Kruithof</last>
   </name>
   <name>
     <first>Martin</first>
     <last>Landers</last>
   </name>
   <name>
     <first>Martin</first>
     <last>Poeschl</last>
   </name>
   <name>
     <first>Martin</first>
     <last>van den Bemt</last>
   </name>
   <name>
     <first>Martin</first>
     <last>von Gagern</last>
   </name>
   <name>
     <first>Mathieu</first>
     <last>Champlon</last>
   </name>
   <name>
     <first>Mathieu</first>
     <last>Peltier</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Albrecht</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Benson</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Bishop</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Foemmel</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Grosso</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Humphrey</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Small</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Hawthorne</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Inger</last>
   </name>
   <name>
     <first>Matthew</first>
     <middle>Kuperus</middle>
     <last>Heun</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Watson</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Bayne</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Davey</last>
   </name>
   <name>
     <first>Michael</first>
     <middle>J.</middle>
     <last>Sikorsky</last>
   </name>
   <name>
     <first>Michael</first>
     <last>McCallum</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Newcomb</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Nygard</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Saunders</last>
   </name>
   <name>
     <last>Miha</last>
   </name>
   <name>
     <first>Mike</first>
     <last>Davis</last>
   </name>
   <name>
     <first>Mike</first>
     <last>Roberts</last>
   </name>
   <name>
     <last>mnowostawski</last>
   </name>
   <name>
     <first>Nathan</first>
     <last>Beyer</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Chalko</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Crossley</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Fortescue</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Pellow</last>
   </name>
   <name>
     <first>Nicola</first>
     <last>Ken</last>
   </name>
   <name>
     <first>Nico</first>
     <last>Seessle</last>
   </name>
   <name>
     <first>Nigel</first>
     <last>Magnay</last>
   </name>
   <name>
     <first>Oliver</first>
     <last>Merkel</last>
   </name>
   <name>
     <first>Oliver</first>
     <last>Rossmueller</last>
   </name>
   <name>
     <first>Omer</first>
     <last>Shapira</last>
   </name>
   <name>
     <first>&#216;ystein</first>
     <last>Gisn&#229;s</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>C.</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Chanezon</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Gus</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Austin</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Christmann</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Galbraith</last>
   </name>
   <name>
     <first>Paul</first>
     <last>King</last>
   </name>
   <name>
     <first>Paulo</first>
     <last>Gaspar</last>
   </name>
   <name>
     <first>Pavan</first>
     <last>Bayyapu</last>
   </name>
   <name>
     <first>Pavel</first>
     <last>Jisl</last>
   </name>
   <name>
     <first>Paweł</first>
     <last>Zuzelski</last>
   </name>
   <name>
     <first>Peter</first>
     <middle>B.</middle>
     <last>West</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Donald</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Doornbosch</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Hulst</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Janes</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Reilly</last>
   </name>
   <name>
     <first>Phil</first>
     <last>Hanna</last>
   </name>
   <name>
     <first>Philip</first>
     <last>Hourihane</last>
   </name>
   <name>
     <first>Phillip</first>
     <last>Wells</last>
   </name>
   <name>
     <first>Pierre</first>
     <last>Delisle</last>
   </name>
   <name>
     <first>Pierre</first>
     <last>Dittgen</last>
   </name>
   <name>
     <first>R</first>
     <last>Handerson</last>
   </name>
   <name>
     <first>Rami</first>
     <last>Ojares</last>
   </name>
   <name>
     <first>Randy</first>
     <last>Watler</last>
   </name>
   <name>
     <first>Raphael</first>
     <last>Pierquin</last>
   </name>
   <name>
     <first>Ray</first>
     <last>Waldin</last>
   </name>
   <name>
     <first>Remie</first>
     <last>Bolte</last>
   </name>
   <name>
     <first>Richard</first>
     <last>Evans</last>
   </name>
   <name>
     <first>Rick</first>
     <last>Beton</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Anderson</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Clark</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Flaherty</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Shaw</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Streich</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Watkins</last>
   </name>
   <name>
     <first>Roberto</first>
     <last>Scaramuzzi</last>
   </name>
   <name>
     <first>Robin</first>
     <last>Green</last>
   </name>
   <name>
     <first>Robin</first>
     <last>Verduijn</last>
   </name>
   <name>
     <first>Rob</first>
     <last>Oxspring</last>
   </name>
   <name>
     <first>Rob</first>
     <last>van Oostrum</last>
   </name>
   <name>
     <first>Rodrigo</first>
     <last>Schmidt</last>
   </name>
   <name>
     <first>Roger</first>
     <last>Vaughn</last>
   </name>
   <name>
     <first>Roman</first>
     <last>Ivashin</last>
   </name>
   <name>
     <first>Ronen</first>
     <last>Mashal</last>
   </name>
   <name>
     <first>Russell</first>
     <last>Gold</last>
   </name>
   <name>
     <first>Sam</first>
     <last>Ruby</last>
   </name>
   <name>
     <first>Sandra</first>
     <last>Metz</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Carlson</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Ellsworth</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Johnson</last>
   </name>
   <name>
     <first>Scott</first>
     <middle>M.</middle>
     <last>Stirling</last>
   </name>
   <name>
     <first>Sean</first>
     <last>Egan</last>
   </name>
   <name>
     <first>Sean</first>
     <middle>P.</middle>
     <last>Kane</last>
   </name>
   <name>
     <first>Sebastien</first>
     <last>Arod</last>
   </name>
   <name>
     <first>Shiraz</first>
     <last>Kanga</last>
   </name>
   <name>
     <first>Sebastian</first>
     <last>Kantha</last>
   </name>
   <name>
       <first>Simon</first>
       <last>Law</last>
   </name>
   <name>
     <first>Simone</first>
     <last>Bordet</last>
   </name>
   <name>
     <first>Stefan</first>
     <last>Bodewig</last>
   </name>
   <name>
     <first>Stefan</first>
     <last>Heimann</last>
   </name>
   <name>
     <first>Stefano</first>
     <last>Mazzocchi</last>
   </name>
   <name>
     <first>Stephan</first>
     <last>Strittmatter</last>
   </name>
   <name>
     <first>Stephane</first>
     <last>Bailliez</last>
   </name>
   <name>
     <last>stephan</last>
   </name>
   <name>
     <first>Stephan</first>
     <last>Michels</last>
   </name>
   <name>
     <first>Stephen</first>
     <last>Chin</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Cohen</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Langley</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Loughran</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Morin</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Wadsworth</last>
   </name>
   <name>
     <first>Steven</first>
     <middle>E.</middle>
     <last>Newton</last>
   </name>
   <name>
     <first>Takashi</first>
     <last>Okamoto</last>
   </name>
   <name>
     <first>TAMURA</first>
     <last>Kent</last>
   </name>
   <name>
     <first>Taoufik</first>
     <last>Romdhane</last>
   </name>
   <name>
     <first>Tariq</first>
     <last>Master</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Aglassinger</last>
diff --git a/docs/manual/targets.html b/docs/manual/targets.html
index 01a812e86..c95b7ba29 100644
--- a/docs/manual/targets.html
+++ b/docs/manual/targets.html
@@ -1,289 +1,300 @@
 <!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 -->
 <html>
 
 <head>
   <meta http-equiv="Content-Language" content="en-us"/>
   <link rel="stylesheet" type="text/css" href="stylesheets/style.css"/>
   <title>Targets and Extension-Points</title>
 </head>
 
 <body>
   <h1><a name="targets">Targets</a></h1>
 
   <p>A target is a container of tasks that cooperate to reach a
     desired state during the build process.</p>
 
   <p>Targets can depend on other targets and Ant ensures that these
     other targets have been executed before the current target. For
     example you might have a target for compiling and a
     target for creating a distributable. You can only build a
     distributable when you have compiled first, so the distribute
     target <i>depends on</i> the compile target.</p>
 
   <p>Ant tries to execute the targets in the <code>depends</code>
     attribute in the order they appear (from left to right). Keep in
     mind that it is possible that a target can get executed earlier
     when an earlier target depends on it:</p>
 
 <blockquote>
 <pre>&lt;target name=&quot;A&quot;/&gt;
 &lt;target name=&quot;B&quot; depends=&quot;A&quot;/&gt;
 &lt;target name=&quot;C&quot; depends=&quot;B&quot;/&gt;
 &lt;target name=&quot;D&quot; depends=&quot;C,B,A&quot;/&gt;</pre>
 </blockquote>
 
   <p>Suppose we want to execute target D. From its
     <code>depends</code> attribute, you might think that first target
     C, then B and then A is executed.  Wrong! C depends on B, and B
     depends on A, so first A is executed, then B, then C, and finally
     D.</p>
     
   <blockquote><pre><b>Call-Graph:</b>  A --> B --> C --> D</pre></blockquote>
 
   <p>In a chain of dependencies stretching back from a given target
     such as D above, each target gets executed only once, even when
     more than one target depends on it. Thus, executing the D target
     will first result in C being called, which in turn will first call
     B, which in turn will first call A. After A, then B, then C have
     executed, execution returns to the dependency list of D, which
     will <u>not</u> call B and A, since they were already called in
     process of dependency resolution for C and B respectively as
     dependencies of D. Had no such dependencies been discovered in
     processing C and B, B and A would have been executed after C in
     processing D's dependency list.</p>
 
   <p>A target also has the ability to perform its execution if (or
     unless) a property has been set. This allows, for example, better
     control on the building process depending on the state of the
     system (java version, OS, command-line property defines, etc.).
     To make a target <i>sense</i> this property, you should add
     the <code>if</code> (or <code>unless</code>) attribute with the
     name of the property that the target should react
     to. <strong>Note:</strong> In the most simple case Ant will only
     check whether the property has been set, the value doesn't matter,
     but using property expansions you can build more complex
     conditions.  See
     <a href="properties.html#if+unless">the properties page</a> for
     more details.  For example:</p>
 
 <blockquote>
   <pre>&lt;target name=&quot;build-module-A&quot; if=&quot;module-A-present&quot;/&gt;</pre>
   <pre>&lt;target name=&quot;build-own-fake-module-A&quot; unless=&quot;module-A-present&quot;/&gt;</pre>
 </blockquote>
 
   <p>In the first example, if the <code>module-A-present</code>
     property is set (to any value, e.g. <i>false</i>), the target will
     be run. In the second example, if
     the <code>module-A-present</code> property is set (again, to any
     value), the target will not be run.</p>
 
   <p>Only one propertyname can be specified in the if/unless
     clause. If you want to check multiple conditions, you can use a
     dependend target for computing the result for the check:</p>
 
 <blockquote><pre>
 &lt;target name="myTarget" depends="myTarget.check" if="myTarget.run"&gt;
     &lt;echo&gt;Files foo.txt and bar.txt are present.&lt;/echo&gt;
 &lt/target&gt;
 
 &lt;target name="myTarget.check"&gt;
     &lt;condition property="myTarget.run"&gt;
         &lt;and&gt;
             &lt;available file="foo.txt"/&gt;
             &lt;available file="bar.txt"/&gt;
         &lt;/and&gt;
     &lt;/condition&gt;
 &lt/target&gt;
 </pre></blockquote>
 
   <blockquote><pre><b>Call-Graph:</b>  myTarget.check --> maybe(myTarget)</pre></blockquote>
 
   <p>If no <code>if</code> and no <code>unless</code> attribute is
     present, the target will always be executed.</p>
 
   <p><b>Important:</b> the <code>if</code> and <code>unless</code>
     attributes only enable or disable the target to which they are
     attached. They do not control whether or not targets that a
     conditional target depends upon get executed.  In fact, they do
     not even get evaluated until the target is about to be executed,
     and all its predecessors have already run.
 
   <p>The optional <code>description</code> attribute can be used to
     provide a one-line description of this target, which is printed by
     the <code>-projecthelp</code> command-line option. Targets without
     such a description are deemed internal and will not be listed,
     unless either the <code>-verbose</code> or <code>-debug</code>
     option is used.</p>
 
   <p>It is a good practice to place
     your <a href="Tasks/tstamp.html">tstamp</a> tasks in a
     so-called <i>initialization</i> target, on which all other targets
     depend. Make sure that target is always the first one in the
     depends list of the other targets. In this manual, most
     initialization targets have the name <code>&quot;init&quot;</code>.</p>
     <blockquote><pre>
     &lt;project&gt;
         &lt;target name=&quot;init&quot;&gt;
             &lt;tstamp/&gt;
         &lt;/target&gt;
         &lt;target name=&quot;otherTarget&quot; depends=&quot;init&quot;&gt;
             ...
         &lt;/target&gt;
     &lt;/project&gt;
     </pre></blockquote>
 
   <p>Especially if you only have a few tasks you also could place these
     tasks directly under the project tag (since Ant 1.6.0):</p>
     <blockquote><pre>
     &lt;project&gt;
         &lt;tstamp/&gt;
     &lt;/project&gt;
     </pre></blockquote>
 
   <p>If the depends attribute and the if/unless attribute are set, the
     depends attribute is executed first.</p>
 
   <p>A target has the following attributes:</p>
 
   <table border="1" cellpadding="2" cellspacing="0">
     <tr>
       <td valign="top"><b>Attribute</b></td>
       <td valign="top"><b>Description</b></td>
       <td align="center" valign="top"><b>Required</b></td>
     </tr>
     <tr>
       <td valign="top">name</td>
       <td valign="top">the name of the target.</td>
       <td align="center" valign="top">Yes</td>
     </tr>
     <tr>
       <td valign="top">depends</td>
       <td valign="top">a comma-separated list of names of targets on
         which this target depends.</td>
       <td align="center" valign="top">No</td>
     </tr>
     <tr>
       <td valign="top">if</td>
       <td valign="top">the name of the property that must be set in
         order for this target to execute,
         or <a href="properties.html#if+unless">something evaluating to
           true</a>.</td>
       <td align="center" valign="top">No</td>
     </tr>
     <tr>
       <td valign="top">unless</td>
       <td valign="top">the name of the property that must not be set
         in order for this target to execute,
         or <a href="properties.html#if+unless">something evaluating to
         false</a>.</td>
       <td align="center" valign="top">No</td>
     </tr>
     <tr>
       <td valign="top">description</td>
       <td valign="top">a short description of this target's function.</td>
       <td align="center" valign="top">No</td>
     </tr>
     <tr>
       <td valign="top">extensionOf</td>
       <td valign="top">Adds the current target to the depends list of
         the named <a href="#extension-points">extension-point</a>.
         <em>since Ant 1.8.0.</em></td>
       <td align="center" valign="top">No</td>
     </tr>
+    <tr>
+      <td valign="top">onMissingExtensionPoint</td>
+      <td valign="top">What to do if this target tries to extend a
+        missing
+        <a href="#extension-points">extension-point</a>. ("fail",
+        "warn", "ignore").
+        <em>since Ant 1.8.2.</em></td>
+      <td align="center" valign="top">No. Not allowed unless
+        <code>extensionOf</code> is present. Defaults to <code>fail</code>. 
+      </td>
+    </tr>
   </table>
 
   <p>A target name can be any alphanumeric string valid in the
     encoding of the XML file. The empty string &quot;&quot; is in this
     set, as is comma &quot;,&quot; and space &quot; &quot;.  Please
     avoid using these, as they will not be supported in future Ant
     versions because of all the confusion they cause on command line and IDE. IDE support of
     unusual target names, or any target name containing spaces, varies
     with the IDE.</p>
 
   <p>Targets beginning with a hyphen such
     as <code>&quot;-restart&quot;</code> are valid, and can be used to
     name targets that should not be called directly from the command
     line. <br>
     For Ants main class every option starting with hyphen is an
     option for Ant itself and not a target. For that reason calling these
     target from command line is not possible. On the other hand IDEs usually
     don't use Ants main class as entry point and calling them from the IDE
     is usually possible.</p>
 
   <h1><a name="extension-points">Extension-Points</a></h1>
 
   <p><em>since Ant 1.8.0.</em></p>
 
   <p>Extension-Points are similar to targets in that they have a name and
     a depends list and can be executed from the command line.  Just
     like targets they represent a state during the build process.</p>
 
   <p>Unlike targets they don't contain any tasks, their main purpose
     is to collect targets that contribute to the desired state in
     their depends list.</p>
 
   <p>Targets can add themselves to an extension-points's depends list via
     their extensionOf attribute.  The targets that add themselves will be
     added after the targets of the explicit depends-attribute of the
     extension-point, if multiple targets add themselves, their relative
     order is not defined.</p>
 
   <p>The main purpose of an extension-point is to act as an extension
     point for build files designed to
     be <a href="Tasks/import.html">imported</a>.  In the imported
     file an extension-point defines a state that must be reached and
     targets from other build files can join the depends list of said
     extension-point in order to contribute to that state.</p>
 
   <p>For example your imported build file may need to compile code, it
     might look like:</p>
 <blockquote><pre>
 &lt;target name="create-directory-layout"&gt;
    ...
 &lt;/target&gt;
 &lt;extension-point name="ready-to-compile"
               depends="create-directory-layout"/&gt;
 &lt;target name="compile" depends="ready-to-compile"&gt;
    ...
 &lt;/target&gt;
 </pre></blockquote>
 
   <blockquote><pre><b>Call-Graph:</b>  create-directory-layout --> 'empty slot' --> compile</pre></blockquote>
 
 
   <p>And you need to generate some source before compilation, then in
     your main build file you may use something like</p>
 <blockquote><pre>
 &lt;target name="generate-sources"
         extensionOf="ready-to-compile"&gt;
    ...
 &lt;/target&gt;
 </pre></blockquote>
 
   <blockquote><pre><b>Call-Graph:</b>  create-directory-layout --> generate-sources  --> compile</pre></blockquote>
 
 
   <p>This will ensure that the <em>generate-sources</em> target is
     executed before the <em>compile</em> target.</p>
 
   <p>Don't rely on the order of the depends list,
     if <em>generate-sources</em> depends
     on <em>create-directory-layout</em> then it must explicitly depend
     on it via its own depends attribute.</p>
 </body>
 </html>
diff --git a/src/main/org/apache/tools/ant/ProjectHelper.java b/src/main/org/apache/tools/ant/ProjectHelper.java
index 70aa56238..c5241eb6c 100644
--- a/src/main/org/apache/tools/ant/ProjectHelper.java
+++ b/src/main/org/apache/tools/ant/ProjectHelper.java
@@ -1,555 +1,574 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant;
 
 import java.io.File;
 import java.util.Hashtable;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Locale;
 import java.util.Vector;
 
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.util.LoaderUtils;
 import org.xml.sax.AttributeList;
 
 /**
  * Configures a Project (complete with Targets and Tasks) based on
  * a build file. It'll rely on a plugin to do the actual processing
  * of the file.
  * <p>
  * This class also provide static wrappers for common introspection.
  */
 public class ProjectHelper {
     /** The URI for ant name space */
     public static final String ANT_CORE_URI    = "antlib:org.apache.tools.ant";
 
     /** The URI for antlib current definitions */
     public static final String ANT_CURRENT_URI      = "ant:current";
 
     /** The URI for defined types/tasks - the format is antlib:<package> */
     public static final String ANTLIB_URI     = "antlib:";
 
     /** Polymorphic attribute  */
     public static final String ANT_TYPE = "ant-type";
 
     /**
      * Name of JVM system property which provides the name of the
      * ProjectHelper class to use.
      */
     public static final String HELPER_PROPERTY = MagicNames.PROJECT_HELPER_CLASS;
 
     /**
      * The service identifier in jars which provide Project Helper
      * implementations.
      */
     public static final String SERVICE_ID = MagicNames.PROJECT_HELPER_SERVICE;
 
     /**
      * name of project helper reference that we add to a project
      */
     public static final String PROJECTHELPER_REFERENCE = MagicNames.REFID_PROJECT_HELPER;
 
     /**
      * Configures the project with the contents of the specified build file.
      *
      * @param project The project to configure. Must not be <code>null</code>.
      * @param buildFile A build file giving the project's configuration.
      *                  Must not be <code>null</code>.
      *
      * @exception BuildException if the configuration is invalid or cannot be read
      */
     public static void configureProject(Project project, File buildFile) throws BuildException {
         FileResource resource = new FileResource(buildFile);
         ProjectHelper helper = ProjectHelperRepository.getInstance().getProjectHelperForBuildFile(resource);
         project.addReference(PROJECTHELPER_REFERENCE, helper);
         helper.parse(project, buildFile);
     }
 
+    /**
+     * Possible value for target's onMissingExtensionPoint attribute:
+     * fail if the extension-point is not defined.
+     */
+    public static final String MISSING_EP_FAIL = "fail";
+    /**
+     * Possible value for target's onMissingExtensionPoint attribute:
+     * warn if the extension-point is not defined.
+     */
+    public static final String MISSING_EP_WARN = "warn";
+    /**
+     * Possible value for target's onMissingExtensionPoint attribute:
+     * ignore the extensionOf attribute if the extension-point is not
+     * defined.
+     */
+    public static final String MISSING_EP_IGNORE = "ignore";
+
     /** Default constructor */
     public ProjectHelper() {
     }
 
     // -------------------- Common properties  --------------------
     // The following properties are required by import ( and other tasks
     // that read build files using ProjectHelper ).
 
     private Vector importStack = new Vector();
     private List extensionStack = new LinkedList();
 
     /**
      *  Import stack.
      *  Used to keep track of imported files. Error reporting should
      *  display the import path.
      *
      * @return the stack of import source objects.
      */
     public Vector getImportStack() {
         return importStack;
     }
 
     /**
      * Extension stack.
      * Used to keep track of targets that extend extension points.
      *
-     * @return a list of two element string arrays where the first
-     * element is the name of the extensionpoint and the second the
-     * name of the target
+     * @return a list of three element string arrays where the first
+     * element is the name of the extensionpoint, the second the name
+     * of the target and the third one of the MISSINS_EP constants
+     * defined inside this class - it determines how to deal with
+     * targets that want to extend missing extension-points.
      */
     public List getExtensionStack() {
         return extensionStack;
     }
 
     private final static ThreadLocal targetPrefix = new ThreadLocal() {
             protected Object initialValue() {
                 return (String) null;
             }
         };
 
     /**
      * The prefix to prepend to imported target names.
      *
      * <p>May be set by &lt;import&gt;'s as attribute.</p>
      *
      * @return the configured prefix or null
      *
      * @since Ant 1.8.0
      */
     public static String getCurrentTargetPrefix() {
         return (String) targetPrefix.get();
     }
 
     /**
      * Sets the prefix to prepend to imported target names.
      *
      * @since Ant 1.8.0
      */
     public static void setCurrentTargetPrefix(String prefix) {
         targetPrefix.set(prefix);
     }
 
     private final static ThreadLocal prefixSeparator = new ThreadLocal() {
             protected Object initialValue() {
                 return ".";
             }
         };
 
     /**
      * The separator between the prefix and the target name.
      *
      * <p>May be set by &lt;import&gt;'s prefixSeperator attribute.</p>
      *
      * @since Ant 1.8.0
      */
     public static String getCurrentPrefixSeparator() {
         return (String) prefixSeparator.get();
     }
 
     /**
      * Sets the separator between the prefix and the target name.
      *
      * @since Ant 1.8.0
      */
     public static void setCurrentPrefixSeparator(String sep) {
         prefixSeparator.set(sep);
     }
 
     private final static ThreadLocal inIncludeMode = new ThreadLocal() {
             protected Object initialValue() {
                 return Boolean.FALSE;
             }
         };
 
     /**
      * Whether the current file should be read in include as opposed
      * to import mode.
      *
      * <p>In include mode included targets are only known by their
      * prefixed names and their depends lists get rewritten so that
      * all dependencies get the prefix as well.</p>
      *
      * <p>In import mode imported targets are known by an adorned as
      * well as a prefixed name and the unadorned target may be
      * overwritten in the importing build file.  The depends list of
      * the imported targets is not modified at all.</p>
      *
      * @since Ant 1.8.0
      */
     public static boolean isInIncludeMode() {
         return inIncludeMode.get() == Boolean.TRUE;
     }
 
     /**
      * Sets whether the current file should be read in include as
      * opposed to import mode.
      *
      * @since Ant 1.8.0
      */
     public static void setInIncludeMode(boolean includeMode) {
         inIncludeMode.set(includeMode ? Boolean.TRUE : Boolean.FALSE);
     }
 
     // --------------------  Parse method  --------------------
     /**
      * Parses the project file, configuring the project as it goes.
      *
      * @param project The project for the resulting ProjectHelper to configure.
      *                Must not be <code>null</code>.
      * @param source The source for XML configuration. A helper must support
      *               at least File, for backward compatibility. Helpers may
      *               support URL, InputStream, etc or specialized types.
      *
      * @since Ant1.5
      * @exception BuildException if the configuration is invalid or cannot
      *                           be read
      */
     public void parse(Project project, Object source) throws BuildException {
         throw new BuildException("ProjectHelper.parse() must be implemented "
             + "in a helper plugin " + this.getClass().getName());
     }
 
     /**
      * Get the first project helper found in the classpath
      * 
      * @return an project helper, never <code>null</code>
      * @see org.apache.tools.ant.ProjectHelperRepository#getHelpers()
      */
     public static ProjectHelper getProjectHelper() {
         return (ProjectHelper) ProjectHelperRepository.getInstance().getHelpers().next();
     }
 
     /**
      * JDK1.1 compatible access to the context class loader. Cut & paste from JAXP.
      *
      * @deprecated since 1.6.x.
      *             Use LoaderUtils.getContextClassLoader()
      *
      * @return the current context class loader, or <code>null</code>
      * if the context class loader is unavailable.
      */
     public static ClassLoader getContextClassLoader() {
         return LoaderUtils.isContextLoaderAvailable() ? LoaderUtils.getContextClassLoader() : null;
     }
 
     // -------------------- Static utils, used by most helpers ----------------
 
     /**
      * Configures an object using an introspection handler.
      *
      * @param target The target object to be configured.
      *               Must not be <code>null</code>.
      * @param attrs  A list of attributes to configure within the target.
      *               Must not be <code>null</code>.
      * @param project The project containing the target.
      *                Must not be <code>null</code>.
      *
      * @deprecated since 1.6.x.
      *             Use IntrospectionHelper for each property.
      *
      * @exception BuildException if any of the attributes can't be handled by
      *                           the target
      */
     public static void configure(Object target, AttributeList attrs,
                                  Project project) throws BuildException {
         if (target instanceof TypeAdapter) {
             target = ((TypeAdapter) target).getProxy();
         }
         IntrospectionHelper ih = IntrospectionHelper.getHelper(project, target.getClass());
 
         for (int i = 0, length = attrs.getLength(); i < length; i++) {
             // reflect these into the target
             String value = replaceProperties(project, attrs.getValue(i), project.getProperties());
             try {
                 ih.setAttribute(project, target, attrs.getName(i).toLowerCase(Locale.ENGLISH), value);
             } catch (BuildException be) {
                 // id attribute must be set externally
                 if (!attrs.getName(i).equals("id")) {
                     throw be;
                 }
             }
         }
     }
 
     /**
      * Adds the content of #PCDATA sections to an element.
      *
      * @param project The project containing the target.
      *                Must not be <code>null</code>.
      * @param target  The target object to be configured.
      *                Must not be <code>null</code>.
      * @param buf A character array of the text within the element.
      *            Will not be <code>null</code>.
      * @param start The start element in the array.
      * @param count The number of characters to read from the array.
      *
      * @exception BuildException if the target object doesn't accept text
      */
     public static void addText(Project project, Object target, char[] buf,
         int start, int count) throws BuildException {
         addText(project, target, new String(buf, start, count));
     }
 
     /**
      * Adds the content of #PCDATA sections to an element.
      *
      * @param project The project containing the target.
      *                Must not be <code>null</code>.
      * @param target  The target object to be configured.
      *                Must not be <code>null</code>.
      * @param text    Text to add to the target.
      *                May be <code>null</code>, in which case this
      *                method call is a no-op.
      *
      * @exception BuildException if the target object doesn't accept text
      */
     public static void addText(Project project, Object target, String text)
         throws BuildException {
 
         if (text == null) {
             return;
         }
         if (target instanceof TypeAdapter) {
             target = ((TypeAdapter) target).getProxy();
         }
         IntrospectionHelper.getHelper(project, target.getClass()).addText(project, target, text);
     }
 
     /**
      * Stores a configured child element within its parent object.
      *
      * @param project Project containing the objects.
      *                May be <code>null</code>.
      * @param parent  Parent object to add child to.
      *                Must not be <code>null</code>.
      * @param child   Child object to store in parent.
      *                Should not be <code>null</code>.
      * @param tag     Name of element which generated the child.
      *                May be <code>null</code>, in which case
      *                the child is not stored.
      */
     public static void storeChild(Project project, Object parent, Object child, String tag) {
         IntrospectionHelper ih = IntrospectionHelper.getHelper(project, parent.getClass());
         ih.storeElement(project, parent, child, tag);
     }
 
     /**
      * Replaces <code>${xxx}</code> style constructions in the given value with
      * the string value of the corresponding properties.
      *
      * @param project The project containing the properties to replace.
      *                Must not be <code>null</code>.
      *
      * @param value The string to be scanned for property references.
      *              May be <code>null</code>.
      *
      * @exception BuildException if the string contains an opening
      *                           <code>${</code> without a closing
      *                           <code>}</code>
      * @return the original string with the properties replaced, or
      *         <code>null</code> if the original string is <code>null</code>.
      *
      * @deprecated since 1.6.x.
      *             Use project.replaceProperties().
      * @since 1.5
      */
      public static String replaceProperties(Project project, String value) throws BuildException {
         // needed since project properties are not accessible
          return project.replaceProperties(value);
      }
 
     /**
      * Replaces <code>${xxx}</code> style constructions in the given value
      * with the string value of the corresponding data types.
      *
      * @param project The container project. This is used solely for
      *                logging purposes. Must not be <code>null</code>.
      * @param value The string to be scanned for property references.
      *              May be <code>null</code>, in which case this
      *              method returns immediately with no effect.
      * @param keys  Mapping (String to String) of property names to their
      *              values. Must not be <code>null</code>.
      *
      * @exception BuildException if the string contains an opening
      *                           <code>${</code> without a closing
      *                           <code>}</code>
      * @return the original string with the properties replaced, or
      *         <code>null</code> if the original string is <code>null</code>.
      * @deprecated since 1.6.x.
      *             Use PropertyHelper.
      */
      public static String replaceProperties(Project project, String value, Hashtable keys)
              throws BuildException {
         PropertyHelper ph = PropertyHelper.getPropertyHelper(project);
         return ph.replaceProperties(null, value, keys);
     }
 
     /**
      * Parses a string containing <code>${xxx}</code> style property
      * references into two lists. The first list is a collection
      * of text fragments, while the other is a set of string property names.
      * <code>null</code> entries in the first list indicate a property
      * reference from the second list.
      *
      * <p>As of Ant 1.8.0 this method is never invoked by any code
      * inside of Ant itself.</p>
      *
      * @param value     Text to parse. Must not be <code>null</code>.
      * @param fragments List to add text fragments to.
      *                  Must not be <code>null</code>.
      * @param propertyRefs List to add property names to.
      *                     Must not be <code>null</code>.
      *
      * @deprecated since 1.6.x.
      *             Use PropertyHelper.
      * @exception BuildException if the string contains an opening
      *                           <code>${</code> without a closing <code>}</code>
      */
     public static void parsePropertyString(String value, Vector fragments, Vector propertyRefs)
             throws BuildException {
         PropertyHelper.parsePropertyStringDefault(value, fragments, propertyRefs);
     }
 
     /**
      * Map a namespaced {uri,name} to an internal string format.
      * For BC purposes the names from the ant core uri will be
      * mapped to "name", other names will be mapped to
      * uri + ":" + name.
      * @param uri   The namepace URI
      * @param name  The localname
      * @return      The stringified form of the ns name
      */
     public static String genComponentName(String uri, String name) {
         if (uri == null || uri.equals("") || uri.equals(ANT_CORE_URI)) {
             return name;
         }
         return uri + ":" + name;
     }
 
     /**
      * extract a uri from a component name
      *
      * @param componentName  The stringified form for {uri, name}
      * @return               The uri or "" if not present
      */
     public static String extractUriFromComponentName(String componentName) {
         if (componentName == null) {
             return "";
         }
         int index = componentName.lastIndexOf(':');
         if (index == -1) {
             return "";
         }
         return componentName.substring(0, index);
     }
 
     /**
      * extract the element name from a component name
      *
      * @param componentName  The stringified form for {uri, name}
      * @return               The element name of the component
      */
     public static String extractNameFromComponentName(String componentName) {
         int index = componentName.lastIndexOf(':');
         if (index == -1) {
             return componentName;
         }
         return componentName.substring(index + 1);
     }
 
     /**
      * Add location to build exception.
      * @param ex the build exception, if the build exception
      *           does not include
      * @param newLocation the location of the calling task (may be null)
      * @return a new build exception based in the build exception with
      *         location set to newLocation. If the original exception
      *         did not have a location, just return the build exception
      */
     public static BuildException addLocationToBuildException(
             BuildException ex, Location newLocation) {
         if (ex.getLocation() == null || ex.getMessage() == null) {
             return ex;
         }
         String errorMessage
             = "The following error occurred while executing this line:"
             + System.getProperty("line.separator")
             + ex.getLocation().toString()
             + ex.getMessage();
         if (newLocation == null) {
             return new BuildException(errorMessage, ex);
         }
         return new BuildException(errorMessage, ex, newLocation);
     }
 
     /**
      * Whether this instance of ProjectHelper can parse an Antlib
      * descriptor given by the URL and return its content as an
      * UnknownElement ready to be turned into an Antlib task.
      *
      * <p>This method should not try to parse the content of the
      * descriptor, the URL is only given as an argument to allow
      * subclasses to decide whether they can support a given URL
      * scheme or not.</p>
      *
      * <p>Subclasses that return true in this method must also
      * override {@link #parseAntlibDescriptor
      * parseAntlibDescriptor}.</p>
      *
      * <p>This implementation returns false.</p>
      *
      * @since Ant 1.8.0
      */
     public boolean canParseAntlibDescriptor(Resource r) {
         return false;
     }
 
     /**
      * Parse the given URL as an antlib descriptor and return the
      * content as something that can be turned into an Antlib task.
      *
      * @since ant 1.8.0
      */
     public UnknownElement parseAntlibDescriptor(Project containingProject,
                                                 Resource source) {
         throw new BuildException("can't parse antlib descriptors");
     }
 
     /**
      * Check if the helper supports the kind of file. Some basic check on the
      * extension's file should be done here.
      * 
      * @param buildFile
      *            the file expected to be parsed (never <code>null</code>)
      * @return true if the helper supports it
      * @since Ant 1.8.0
      */
     public boolean canParseBuildFile(Resource buildFile) {
         return true;
     }
 
     /**
      * The file name of the build script to be parsed if none specified on the command line
      * 
      * @return the name of the default file (never <code>null</code>)
      * @since Ant 1.8.0
      */
     public String getDefaultBuildFile() {
         return Main.DEFAULT_BUILD_FILENAME;
     }
 }
diff --git a/src/main/org/apache/tools/ant/helper/ProjectHelper2.java b/src/main/org/apache/tools/ant/helper/ProjectHelper2.java
index 5f29e6aee..681c39691 100644
--- a/src/main/org/apache/tools/ant/helper/ProjectHelper2.java
+++ b/src/main/org/apache/tools/ant/helper/ProjectHelper2.java
@@ -1,1238 +1,1270 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.helper;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.ExtensionPoint;
 import org.apache.tools.ant.Location;
 import org.apache.tools.ant.MagicNames;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.ProjectHelper;
 import org.apache.tools.ant.RuntimeConfigurable;
 import org.apache.tools.ant.Target;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.UnknownElement;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.URLProvider;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.JAXPUtils;
 import org.apache.tools.zip.ZipFile;
 import org.xml.sax.Attributes;
 import org.xml.sax.InputSource;
 import org.xml.sax.Locator;
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXParseException;
 import org.xml.sax.XMLReader;
 import org.xml.sax.helpers.DefaultHandler;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.URL;
 import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Stack;
 
 /**
  * Sax2 based project reader
  *
  */
 public class ProjectHelper2 extends ProjectHelper {
+
     /** Reference holding the (ordered) target Vector */
     public static final String REFID_TARGETS = "ant.targets";
 
     /* Stateless */
 
     // singletons - since all state is in the context
     private static AntHandler elementHandler = new ElementHandler();
     private static AntHandler targetHandler = new TargetHandler();
     private static AntHandler mainHandler = new MainHandler();
     private static AntHandler projectHandler = new ProjectHandler();
 
     /** Specific to ProjectHelper2 so not a true Ant "magic name:" */
     private static final String REFID_CONTEXT = "ant.parsing.context";
 
     /**
      * helper for path -> URI and URI -> path conversions.
      */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * Whether this instance of ProjectHelper can parse an Antlib
      * descriptor given by the URL and return its content as an
      * UnknownElement ready to be turned into an Antlib task.
      *
      * <p>This implementation returns true.</p>
      *
      * @since Ant 1.8.0
      */
     public boolean canParseAntlibDescriptor(Resource resource) {
         return true;
     }
 
     /**
      * Parse the given URL as an antlib descriptor an return the
      * content as something that can be turned into an Antlib task.
      *
      * <p>simply delegates to {@link #parseUnknownElement
      * parseUnknownElement} if the resource provides an URL and throws
      * an exceptipn otherwise.</p>
      *
      * @since Ant 1.8.0
      */
     public UnknownElement parseAntlibDescriptor(Project containingProject,
                                                 Resource resource) {
         URLProvider up = (URLProvider) resource.as(URLProvider.class);
         if (up == null) {
             throw new BuildException("Unsupported resource type: " + resource);
         }
         return parseUnknownElement(containingProject, up.getURL());
     }
 
     /**
      * Parse an unknown element from a url
      *
      * @param project the current project
      * @param source  the url containing the task
      * @return a configured task
      * @exception BuildException if an error occurs
      */
     public UnknownElement parseUnknownElement(Project project, URL source)
         throws BuildException {
         Target dummyTarget = new Target();
         dummyTarget.setProject(project);
 
         AntXMLContext context = new AntXMLContext(project);
         context.addTarget(dummyTarget);
         context.setImplicitTarget(dummyTarget);
 
         parse(context.getProject(), source, new RootHandler(context, elementHandler));
         Task[] tasks = dummyTarget.getTasks();
         if (tasks.length != 1) {
             throw new BuildException("No tasks defined");
         }
         return (UnknownElement) tasks[0];
     }
 
     /**
      * Parse a source xml input.
      *
      * @param project the current project
      * @param source  the xml source
      * @exception BuildException if an error occurs
      */
     public void parse(Project project, Object source) throws BuildException {
         getImportStack().addElement(source);
         AntXMLContext context = null;
         context = (AntXMLContext) project.getReference(REFID_CONTEXT);
         if (context == null) {
             context = new AntXMLContext(project);
             project.addReference(REFID_CONTEXT, context);
             project.addReference(REFID_TARGETS, context.getTargets());
         }
         if (getImportStack().size() > 1) {
             // we are in an imported file.
             context.setIgnoreProjectTag(true);
             Target currentTarget = context.getCurrentTarget();
             Target currentImplicit = context.getImplicitTarget();
             Map    currentTargets = context.getCurrentTargets();
             try {
                 Target newCurrent = new Target();
                 newCurrent.setProject(project);
                 newCurrent.setName("");
                 context.setCurrentTarget(newCurrent);
                 context.setCurrentTargets(new HashMap());
                 context.setImplicitTarget(newCurrent);
                 parse(project, source, new RootHandler(context, mainHandler));
                 newCurrent.execute();
             } finally {
                 context.setCurrentTarget(currentTarget);
                 context.setImplicitTarget(currentImplicit);
                 context.setCurrentTargets(currentTargets);
             }
         } else {
             // top level file
             context.setCurrentTargets(new HashMap());
             parse(project, source, new RootHandler(context, mainHandler));
             // Execute the top-level target
             context.getImplicitTarget().execute();
 
             // resolve extensionOf attributes
             for (Iterator i = getExtensionStack().iterator(); i.hasNext(); ) {
                 String[] extensionInfo = (String[]) i.next();
                 String tgName = extensionInfo[0];
                 String name = extensionInfo[1];
+                String missingBehaviour = extensionInfo[2];
                 Hashtable projectTargets = project.getTargets();
                 if (!projectTargets.containsKey(tgName)) {
-                    throw new BuildException("can't add target "
-                                             + name + " to extension-point "
-                                             + tgName
-                                             + " because the extension-point"
-                                             + " is unknown.");
-                }
-                Target t = (Target) projectTargets.get(tgName);
-                if (!(t instanceof ExtensionPoint)) {
-                    throw new BuildException("referenced target "
-                                             + tgName
-                                             + " is not an extension-point");
+                    String message = "can't add target " + name
+                        + " to extension-point " + tgName
+                        + " because the extension-point is unknown.";
+                    if (missingBehaviour.equals(MISSING_EP_FAIL)) {
+                        throw new BuildException(message);
+                    } else if (missingBehaviour.equals(MISSING_EP_WARN)) {
+                        Target target = (Target) projectTargets.get(name);
+                        context.getProject().log(target,
+                                                 "Warning: " + message,
+                                                 Project.MSG_WARN);
+                    }
+                } else {
+                    Target t = (Target) projectTargets.get(tgName);
+                    if (!(t instanceof ExtensionPoint)) {
+                        throw new BuildException("referenced target "
+                                                 + tgName
+                                                 + " is not an extension-point");
+                    }
+                    t.addDependency(name);
                 }
-                t.addDependency(name);
             }
         }
     }
 
     /**
      * Parses the project file, configuring the project as it goes.
      *
      * @param project the current project
      * @param source  the xml source
      * @param handler the root handler to use (contains the current context)
      * @exception BuildException if the configuration is invalid or cannot
      *                           be read
      */
     public void parse(Project project, Object source, RootHandler handler) throws BuildException {
 
         AntXMLContext context = handler.context;
 
         File buildFile = null;
         URL  url = null;
         String buildFileName = null;
 
         if (source instanceof File) {
             buildFile = (File) source;
         } else if (source instanceof URL) {
             url = (URL) source;
         } else if (source instanceof Resource) {
             FileProvider fp =
                 (FileProvider) ((Resource) source).as(FileProvider.class);
             if (fp != null) {
                 buildFile = fp.getFile();
             } else {
                 URLProvider up =
                     (URLProvider) ((Resource) source).as(URLProvider.class);
                 if (up != null) {
                     url = up.getURL();
                 }
             }
         }
         if (buildFile != null) {
             buildFile = FILE_UTILS.normalize(buildFile.getAbsolutePath());
             context.setBuildFile(buildFile);
             buildFileName = buildFile.toString();
         } else if (url != null) {
             try {
                 context.setBuildFile((File) null);
                 context.setBuildFile(url);
             } catch (java.net.MalformedURLException ex) {
                 throw new BuildException(ex);
             }
             buildFileName = url.toString();
         } else {
             throw new BuildException("Source " + source.getClass().getName()
-                    + " not supported by this plugin");
+                                     + " not supported by this plugin");
         }
         InputStream inputStream = null;
         InputSource inputSource = null;
         ZipFile zf = null;
 
         try {
             /**
              * SAX 2 style parser used to parse the given file.
              */
             XMLReader parser = JAXPUtils.getNamespaceXMLReader();
 
             String uri = null;
             if (buildFile != null) {
                 uri = FILE_UTILS.toURI(buildFile.getAbsolutePath());
                 inputStream = new FileInputStream(buildFile);
             } else {
                 uri = url.toString();
                 int pling = -1;
                 if (uri.startsWith("jar:file")
                     && (pling = uri.indexOf("!")) > -1) {
                     zf = new ZipFile(org.apache.tools.ant.launch.Locator
                                      .fromJarURI(uri), "UTF-8");
                     inputStream =
                         zf.getInputStream(zf.getEntry(uri.substring(pling + 1)));
                 } else {
                     inputStream = url.openStream();
                 }
             }
 
             inputSource = new InputSource(inputStream);
             if (uri != null) {
                 inputSource.setSystemId(uri);
             }
             project.log("parsing buildfile " + buildFileName + " with URI = "
                         + uri + (zf != null ? " from a zip file" : ""),
                         Project.MSG_VERBOSE);
 
             DefaultHandler hb = handler;
 
             parser.setContentHandler(hb);
             parser.setEntityResolver(hb);
             parser.setErrorHandler(hb);
             parser.setDTDHandler(hb);
             parser.parse(inputSource);
         } catch (SAXParseException exc) {
             Location location = new Location(exc.getSystemId(), exc.getLineNumber(), exc
-                    .getColumnNumber());
+                                             .getColumnNumber());
 
             Throwable t = exc.getException();
             if (t instanceof BuildException) {
                 BuildException be = (BuildException) t;
                 if (be.getLocation() == Location.UNKNOWN_LOCATION) {
                     be.setLocation(location);
                 }
                 throw be;
             }
             throw new BuildException(exc.getMessage(), t == null ? exc : t, location);
         } catch (SAXException exc) {
             Throwable t = exc.getException();
             if (t instanceof BuildException) {
                 throw (BuildException) t;
             }
             throw new BuildException(exc.getMessage(), t == null ? exc : t);
         } catch (FileNotFoundException exc) {
             throw new BuildException(exc);
         } catch (UnsupportedEncodingException exc) {
-              throw new BuildException("Encoding of project file " + buildFileName + " is invalid.",
-                    exc);
+            throw new BuildException("Encoding of project file " + buildFileName + " is invalid.",
+                                     exc);
         } catch (IOException exc) {
             throw new BuildException("Error reading project file " + buildFileName + ": "
-                    + exc.getMessage(), exc);
+                                     + exc.getMessage(), exc);
         } finally {
             FileUtils.close(inputStream);
             ZipFile.closeQuietly(zf);
         }
     }
 
     /**
      * Returns main handler
      * @return main handler
      */
     protected static AntHandler getMainHandler() {
         return mainHandler;
     }
 
     /**
      * Sets main handler
      * @param handler  new main handler
      */
     protected static void setMainHandler(AntHandler handler) {
         mainHandler = handler;
     }
 
     /**
      * Returns project handler
      * @return project handler
      */
     protected static AntHandler getProjectHandler() {
         return projectHandler;
     }
 
     /**
      * Sets project handler
      * @param handler  new project handler
      */
     protected static void setProjectHandler(AntHandler handler) {
         projectHandler = handler;
     }
 
     /**
      * Returns target handler
      * @return target handler
      */
     protected static AntHandler getTargetHandler() {
         return targetHandler;
     }
 
     /**
      * Sets target handler
      * @param handler  new target handler
      */
     protected static void setTargetHandler(AntHandler handler) {
         targetHandler = handler;
     }
 
     /**
      * Returns element handler
      * @return element handler
      */
     protected static AntHandler getElementHandler() {
         return elementHandler;
     }
 
     /**
      * Sets element handler
      * @param handler  new element handler
      */
     protected static void setElementHandler(AntHandler handler) {
         elementHandler = handler;
     }
 
     /**
      * The common superclass for all SAX event handlers used to parse
      * the configuration file.
      *
      * The context will hold all state information. At each time
      * there is one active handler for the current element. It can
      * use onStartChild() to set an alternate handler for the child.
      */
     public static class AntHandler  {
         /**
          * Handles the start of an element. This base implementation does
          * nothing.
          *
          * @param uri the namespace URI for the tag
          * @param tag The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name of the element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The context that this element is in.
          *
          * @exception SAXParseException if this method is not overridden, or in
          *                              case of error in an overridden version
          */
         public void onStartElement(String uri, String tag, String qname, Attributes attrs,
                                    AntXMLContext context) throws SAXParseException {
         }
 
         /**
          * Handles the start of an element. This base implementation just
          * throws an exception - you must override this method if you expect
          * child elements.
          *
          * @param uri The namespace uri for this element.
          * @param tag The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The current context.
          * @return a handler (in the derived classes)
          *
          * @exception SAXParseException if this method is not overridden, or in
          *                              case of error in an overridden version
          */
         public AntHandler onStartChild(String uri, String tag, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             throw new SAXParseException("Unexpected element \"" + qname + " \"", context
-                    .getLocator());
+                                        .getLocator());
         }
 
         /**
          * Handle the end of a element.
          *
          * @param uri the namespace uri of the element
          * @param tag the tag of the element
          * @param qname the qualified name of the element
          * @param context the current context
          * @exception SAXParseException if an error occurs
          */
         public void onEndChild(String uri, String tag, String qname, AntXMLContext context)
-                throws SAXParseException {
+            throws SAXParseException {
         }
 
         /**
          * This method is called when this element and all elements nested into it have been
          * handled. I.e., this happens at the &lt;/end_tag_of_the_element&gt;.
          * @param uri the namespace uri for this element
          * @param tag the element name
          * @param context the current context
          */
         public void onEndElement(String uri, String tag, AntXMLContext context) {
         }
 
         /**
          * Handles text within an element. This base implementation just
          * throws an exception, you must override it if you expect content.
          *
          * @param buf A character array of the text within the element.
          *            Will not be <code>null</code>.
          * @param start The start element in the array.
          * @param count The number of characters to read from the array.
          * @param context The current context.
          *
          * @exception SAXParseException if this method is not overridden, or in
          *                              case of error in an overridden version
          */
         public void characters(char[] buf, int start, int count, AntXMLContext context)
-                throws SAXParseException {
+            throws SAXParseException {
             String s = new String(buf, start, count).trim();
 
             if (s.length() > 0) {
                 throw new SAXParseException("Unexpected text \"" + s + "\"", context.getLocator());
             }
         }
 
         /**
          * Will be called every time a namespace is reached.
          * It'll verify if the ns was processed, and if not load the task definitions.
          * @param uri The namespace uri.
          */
         protected void checkNamespace(String uri) {
         }
     }
 
     /**
      * Handler for ant processing. Uses a stack of AntHandlers to
      * implement each element ( the original parser used a recursive behavior,
      * with the implicit execution stack )
      */
     public static class RootHandler extends DefaultHandler {
         private Stack antHandlers = new Stack();
         private AntHandler currentHandler = null;
         private AntXMLContext context;
 
         /**
          * Creates a new RootHandler instance.
          *
          * @param context The context for the handler.
          * @param rootHandler The handler for the root element.
          */
         public RootHandler(AntXMLContext context, AntHandler rootHandler) {
             currentHandler = rootHandler;
             antHandlers.push(currentHandler);
             this.context = context;
         }
 
         /**
          * Returns the current ant handler object.
          * @return the current ant handler.
          */
         public AntHandler getCurrentAntHandler() {
             return currentHandler;
         }
 
         /**
          * Resolves file: URIs relative to the build file.
          *
          * @param publicId The public identifier, or <code>null</code>
          *                 if none is available. Ignored in this
          *                 implementation.
          * @param systemId The system identifier provided in the XML
          *                 document. Will not be <code>null</code>.
          * @return an inputsource for this identifier
          */
         public InputSource resolveEntity(String publicId, String systemId) {
 
             context.getProject().log("resolving systemId: " + systemId, Project.MSG_VERBOSE);
 
             if (systemId.startsWith("file:")) {
                 String path = FILE_UTILS.fromURI(systemId);
 
                 File file = new File(path);
                 if (!file.isAbsolute()) {
                     file = FILE_UTILS.resolveFile(context.getBuildFileParent(), path);
                     context.getProject().log(
-                            "Warning: '" + systemId + "' in " + context.getBuildFile()
-                                    + " should be expressed simply as '" + path.replace('\\', '/')
-                                    + "' for compliance with other XML tools", Project.MSG_WARN);
+                                             "Warning: '" + systemId + "' in " + context.getBuildFile()
+                                             + " should be expressed simply as '" + path.replace('\\', '/')
+                                             + "' for compliance with other XML tools", Project.MSG_WARN);
                 }
                 context.getProject().log("file=" + file, Project.MSG_DEBUG);
                 try {
                     InputSource inputSource = new InputSource(new FileInputStream(file));
                     inputSource.setSystemId(FILE_UTILS.toURI(file.getAbsolutePath()));
                     return inputSource;
                 } catch (FileNotFoundException fne) {
                     context.getProject().log(file.getAbsolutePath() + " could not be found",
-                            Project.MSG_WARN);
+                                             Project.MSG_WARN);
                 }
 
             }
             // use default if not file or file not found
             context.getProject().log("could not resolve systemId", Project.MSG_DEBUG);
             return null;
         }
 
         /**
          * Handles the start of a project element. A project handler is created
          * and initialised with the element name and attributes.
          *
          * @param uri The namespace uri for this element.
          * @param tag The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          *
          * @exception org.xml.sax.SAXParseException if the tag given is not
          *                              <code>"project"</code>
          */
         public void startElement(String uri, String tag, String qname, Attributes attrs)
-                throws SAXParseException {
+            throws SAXParseException {
             AntHandler next = currentHandler.onStartChild(uri, tag, qname, attrs, context);
             antHandlers.push(currentHandler);
             currentHandler = next;
             currentHandler.onStartElement(uri, tag, qname, attrs, context);
         }
 
         /**
          * Sets the locator in the project helper for future reference.
          *
          * @param locator The locator used by the parser.
          *                Will not be <code>null</code>.
          */
         public void setDocumentLocator(Locator locator) {
             context.setLocator(locator);
         }
 
         /**
          * Handles the end of an element. Any required clean-up is performed
          * by the onEndElement() method and then the original handler is restored to the parser.
          *
          * @param uri  The namespace URI for this element.
          * @param name The name of the element which is ending.
          *             Will not be <code>null</code>.
          * @param qName The qualified name for this element.
          *
          * @exception SAXException in case of error (not thrown in this implementation)
          */
         public void endElement(String uri, String name, String qName) throws SAXException {
             currentHandler.onEndElement(uri, name, context);
             AntHandler prev = (AntHandler) antHandlers.pop();
             currentHandler = prev;
             if (currentHandler != null) {
                 currentHandler.onEndChild(uri, name, qName, context);
             }
         }
 
         /**
          * Handle text within an element, calls currentHandler.characters.
          *
          * @param buf  A character array of the test.
          * @param start The start offset in the array.
          * @param count The number of characters to read.
          * @exception SAXParseException if an error occurs
          */
         public void characters(char[] buf, int start, int count) throws SAXParseException {
             currentHandler.characters(buf, start, count, context);
         }
 
         /**
          * Start a namespace prefix to uri mapping
          *
          * @param prefix the namespace prefix
          * @param uri the namespace uri
          */
         public void startPrefixMapping(String prefix, String uri) {
             context.startPrefixMapping(prefix, uri);
         }
 
         /**
          * End a namepace prefix to uri mapping
          *
          * @param prefix the prefix that is not mapped anymore
          */
         public void endPrefixMapping(String prefix) {
             context.endPrefixMapping(prefix);
         }
     }
 
     /**
      * The main handler - it handles the &lt;project&gt; tag.
      *
      * @see org.apache.tools.ant.helper.ProjectHelper2.AntHandler
      */
     public static class MainHandler extends AntHandler {
 
         /**
          * Handle the project tag
          *
          * @param uri The namespace uri.
          * @param name The element tag.
          * @param qname The element qualified name.
          * @param attrs The attributes of the element.
          * @param context The current context.
          * @return The project handler that handles subelements of project
          * @exception SAXParseException if the qualified name is not "project".
          */
         public AntHandler onStartChild(String uri, String name, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             if (name.equals("project")
                 && (uri.equals("") || uri.equals(ANT_CORE_URI))) {
                 return ProjectHelper2.projectHandler;
             }
             if (name.equals(qname)) {
                 throw new SAXParseException("Unexpected element \"{" + uri
-                    + "}" + name + "\" {" + ANT_CORE_URI + "}" + name, context.getLocator());
+                                            + "}" + name + "\" {" + ANT_CORE_URI + "}" + name, context.getLocator());
             }
             throw new SAXParseException("Unexpected element \"" + qname
-                    + "\" " + name, context.getLocator());
+                                        + "\" " + name, context.getLocator());
         }
     }
 
     /**
      * Handler for the top level "project" element.
      */
     public static class ProjectHandler extends AntHandler {
 
         /**
          * Initialisation routine called after handler creation
          * with the element name and attributes. The attributes which
          * this handler can deal with are: <code>"default"</code>,
          * <code>"name"</code>, <code>"id"</code> and <code>"basedir"</code>.
          *
          * @param uri The namespace URI for this element.
          * @param tag Name of the element which caused this handler
          *            to be created. Should not be <code>null</code>.
          *            Ignored in this implementation.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element which caused this
          *              handler to be created. Must not be <code>null</code>.
          * @param context The current context.
          *
          * @exception SAXParseException if an unexpected attribute is
          *            encountered or if the <code>"default"</code> attribute
          *            is missing.
          */
         public void onStartElement(String uri, String tag, String qname, Attributes attrs,
                                    AntXMLContext context) throws SAXParseException {
             String baseDir = null;
             boolean nameAttributeSet = false;
 
             Project project = context.getProject();
             // Set the location of the implicit target associated with the project tag
             context.getImplicitTarget().setLocation(new Location(context.getLocator()));
 
             /** XXX I really don't like this - the XML processor is still
              * too 'involved' in the processing. A better solution (IMO)
              * would be to create UE for Project and Target too, and
              * then process the tree and have Project/Target deal with
              * its attributes ( similar with Description ).
              *
              * If we eventually switch to ( or add support for ) DOM,
              * things will work smoothly - UE can be avoided almost completely
              * ( it could still be created on demand, for backward compatibility )
              */
 
             for (int i = 0; i < attrs.getLength(); i++) {
                 String attrUri = attrs.getURI(i);
                 if (attrUri != null && !attrUri.equals("") && !attrUri.equals(uri)) {
                     continue; // Ignore attributes from unknown uris
                 }
                 String key = attrs.getLocalName(i);
                 String value = attrs.getValue(i);
 
                 if (key.equals("default")) {
                     if (value != null && !value.equals("")) {
                         if (!context.isIgnoringProjectTag()) {
                             project.setDefault(value);
                         }
                     }
                 } else if (key.equals("name")) {
                     if (value != null) {
                         context.setCurrentProjectName(value);
                         nameAttributeSet = true;
                         if (!context.isIgnoringProjectTag()) {
                             project.setName(value);
                             project.addReference(value, project);
                         } else if (isInIncludeMode()) {
                             if (!"".equals(value)
                                 && (getCurrentTargetPrefix() == null
                                     || getCurrentTargetPrefix().length() == 0)
                                 ) {
                                 // help nested include tasks
                                 setCurrentTargetPrefix(value);
                             }
                         }
                     }
                 } else if (key.equals("id")) {
                     if (value != null) {
                         // What's the difference between id and name ?
                         if (!context.isIgnoringProjectTag()) {
                             project.addReference(value, project);
                         }
                     }
                 } else if (key.equals("basedir")) {
                     if (!context.isIgnoringProjectTag()) {
                         baseDir = value;
                     }
                 } else {
                     // XXX ignore attributes in a different NS ( maybe store them ? )
                     throw new SAXParseException("Unexpected attribute \"" + attrs.getQName(i)
-                            + "\"", context.getLocator());
+                                                + "\"", context.getLocator());
                 }
             }
 
             // XXX Move to Project ( so it is shared by all helpers )
             String antFileProp =
                 MagicNames.ANT_FILE + "." + context.getCurrentProjectName();
             String dup = project.getProperty(antFileProp);
             String typeProp =
                 MagicNames.ANT_FILE_TYPE + "." + context.getCurrentProjectName();
             String dupType = project.getProperty(typeProp);
             if (dup != null && nameAttributeSet) {
                 Object dupFile = null;
                 Object contextFile = null;
                 if (MagicNames.ANT_FILE_TYPE_URL.equals(dupType)) {
                     try {
                         dupFile = new URL(dup);
                     } catch (java.net.MalformedURLException mue) {
                         throw new BuildException("failed to parse "
                                                  + dup + " as URL while looking"
                                                  + " at a duplicate project"
                                                  + " name.", mue);
                     }
                     contextFile = context.getBuildFileURL();
                 } else {
                     dupFile = new File(dup);
                     contextFile = context.getBuildFile();
                 }
 
                 if (context.isIgnoringProjectTag() && !dupFile.equals(contextFile)) {
                     project.log("Duplicated project name in import. Project "
-                            + context.getCurrentProjectName() + " defined first in " + dup
-                            + " and again in " + contextFile, Project.MSG_WARN);
+                                + context.getCurrentProjectName() + " defined first in " + dup
+                                + " and again in " + contextFile, Project.MSG_WARN);
                 }
             }
             if (nameAttributeSet) {
                 if (context.getBuildFile() != null) {
                     project.setUserProperty(antFileProp,
                                             context.getBuildFile().toString());
                     project.setUserProperty(typeProp,
                                             MagicNames.ANT_FILE_TYPE_FILE);
                 } else if (context.getBuildFileURL() != null) {
                     project.setUserProperty(antFileProp,
                                             context.getBuildFileURL().toString());
                     project.setUserProperty(typeProp,
                                             MagicNames.ANT_FILE_TYPE_URL);
                 }
             }
             if (context.isIgnoringProjectTag()) {
                 // no further processing
                 return;
             }
             // set explicitly before starting ?
             if (project.getProperty("basedir") != null) {
                 project.setBasedir(project.getProperty("basedir"));
             } else {
                 // Default for baseDir is the location of the build file.
                 if (baseDir == null) {
                     project.setBasedir(context.getBuildFileParent().getAbsolutePath());
                 } else {
                     // check whether the user has specified an absolute path
                     if ((new File(baseDir)).isAbsolute()) {
                         project.setBasedir(baseDir);
                     } else {
                         project.setBaseDir(FILE_UTILS.resolveFile(context.getBuildFileParent(),
-                                baseDir));
+                                                                  baseDir));
                     }
                 }
             }
             project.addTarget("", context.getImplicitTarget());
             context.setCurrentTarget(context.getImplicitTarget());
         }
 
         /**
          * Handles the start of a top-level element within the project. An
          * appropriate handler is created and initialised with the details
          * of the element.
          *
          * @param uri The namespace URI for this element.
          * @param name The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The context for this element.
          * @return a target or an element handler.
          *
          * @exception org.xml.sax.SAXParseException if the tag given is not
          *            <code>"taskdef"</code>, <code>"typedef"</code>,
          *            <code>"property"</code>, <code>"target"</code>,
          *            <code>"extension-point"</code>
          *            or a data type definition
          */
         public AntHandler onStartChild(String uri, String name, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             return (name.equals("target") || name.equals("extension-point"))
                 && (uri.equals("") || uri.equals(ANT_CORE_URI))
                 ? ProjectHelper2.targetHandler : ProjectHelper2.elementHandler;
         }
     }
 
     /**
      * Handler for "target" and "extension-point" elements.
      */
     public static class TargetHandler extends AntHandler {
 
         /**
          * Initialisation routine called after handler creation
          * with the element name and attributes. The attributes which
          * this handler can deal with are: <code>"name"</code>,
          * <code>"depends"</code>, <code>"if"</code>,
          * <code>"unless"</code>, <code>"id"</code> and
          * <code>"description"</code>.
          *
          * @param uri The namespace URI for this element.
          * @param tag Name of the element which caused this handler
          *            to be created. Should not be <code>null</code>.
          *            Ignored in this implementation.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element which caused this
          *              handler to be created. Must not be <code>null</code>.
          * @param context The current context.
          *
          * @exception SAXParseException if an unexpected attribute is encountered
          *            or if the <code>"name"</code> attribute is missing.
          */
         public void onStartElement(String uri, String tag, String qname, Attributes attrs,
                                    AntXMLContext context) throws SAXParseException {
             String name = null;
             String depends = "";
             String extensionPoint = null;
+            String extensionPointMissing = null;
 
             Project project = context.getProject();
             Target target = "target".equals(tag)
                 ? new Target() : new ExtensionPoint();
             target.setProject(project);
             target.setLocation(new Location(context.getLocator()));
             context.addTarget(target);
 
             for (int i = 0; i < attrs.getLength(); i++) {
                 String attrUri = attrs.getURI(i);
                 if (attrUri != null && !attrUri.equals("") && !attrUri.equals(uri)) {
                     continue; // Ignore attributes from unknown uris
                 }
                 String key = attrs.getLocalName(i);
                 String value = attrs.getValue(i);
 
                 if (key.equals("name")) {
                     name = value;
                     if ("".equals(name)) {
                         throw new BuildException("name attribute must " + "not be empty");
                     }
                 } else if (key.equals("depends")) {
                     depends = value;
                 } else if (key.equals("if")) {
                     target.setIf(value);
                 } else if (key.equals("unless")) {
                     target.setUnless(value);
                 } else if (key.equals("id")) {
                     if (value != null && !value.equals("")) {
                         context.getProject().addReference(value, target);
                     }
                 } else if (key.equals("description")) {
                     target.setDescription(value);
                 } else if (key.equals("extensionOf")) {
                     extensionPoint = value;
+                } else if (key.equals("onMissingExtensionPoint")) {
+                    extensionPointMissing = value;
                 } else {
                     throw new SAXParseException("Unexpected attribute \"" + key + "\"", context
-                            .getLocator());
+                                                .getLocator());
                 }
             }
 
             if (name == null) {
                 throw new SAXParseException("target element appears without a name attribute",
-                        context.getLocator());
+                                            context.getLocator());
             }
 
             String prefix = null;
             boolean isInIncludeMode =
                 context.isIgnoringProjectTag() && isInIncludeMode();
             String sep = getCurrentPrefixSeparator();
 
             if (isInIncludeMode) {
                 prefix = getTargetPrefix(context);
                 if (prefix == null) {
                     throw new BuildException("can't include build file "
                                              + context.getBuildFileURL()
                                              + ", no as attribute has been given"
                                              + " and the project tag doesn't"
                                              + " specify a name attribute");
                 }
                 name = prefix + sep + name;
             }
 
             // Check if this target is in the current build file
             if (context.getCurrentTargets().get(name) != null) {
                 throw new BuildException("Duplicate target '" + name + "'",
                                          target.getLocation());
             }
             Hashtable projectTargets = project.getTargets();
             boolean   usedTarget = false;
             // If the name has not already been defined define it
             if (projectTargets.containsKey(name)) {
                 project.log("Already defined in main or a previous import, ignore " + name,
-                        Project.MSG_VERBOSE);
+                            Project.MSG_VERBOSE);
             } else {
                 target.setName(name);
                 context.getCurrentTargets().put(name, target);
                 project.addOrReplaceTarget(name, target);
                 usedTarget = true;
             }
 
             if (depends.length() > 0) {
                 if (!isInIncludeMode) {
                     target.setDepends(depends);
                 } else {
                     for (Iterator iter =
                              Target.parseDepends(depends, name, "depends")
                              .iterator();
                          iter.hasNext(); ) {
                         target.addDependency(prefix + sep + iter.next());
                     }
                 }
             }
             if (!isInIncludeMode && context.isIgnoringProjectTag()
                 && (prefix = getTargetPrefix(context)) != null) {
                 // In an imported file (and not completely
                 // ignoring the project tag or having a preconfigured prefix)
                 String newName = prefix + sep + name;
                 Target newTarget = usedTarget ? new Target(target) : target;
                 newTarget.setName(newName);
                 context.getCurrentTargets().put(newName, newTarget);
                 project.addOrReplaceTarget(newName, newTarget);
             }
+            if (extensionPointMissing != null && extensionPoint == null) {
+                throw new BuildException("onMissingExtensionPoint attribute cannot " +
+                                         "be specified unless extensionOf is specified", 
+                                         target.getLocation());
+
+            }
             if (extensionPoint != null) {
                 ProjectHelper helper =
                     (ProjectHelper) context.getProject().
-                        getReference(ProjectHelper.PROJECTHELPER_REFERENCE);
+                    getReference(ProjectHelper.PROJECTHELPER_REFERENCE);
                 for (Iterator iter =
                          Target.parseDepends(extensionPoint, name, "extensionOf")
                          .iterator();
                      iter.hasNext(); ) {
                     String tgName = (String) iter.next();
                     if (isInIncludeMode()) {
                         tgName = prefix + sep + tgName;
                     }
-
-                    // defer extensionpoint resolution until the full
-                    // import stack has been processed
-                    helper.getExtensionStack().add(new String[] {
-                            tgName, name
-                        });
+                    if (extensionPointMissing == null) {
+                        extensionPointMissing = MISSING_EP_FAIL;
+                    }
+                    if (extensionPointMissing.equals(MISSING_EP_FAIL) ||
+                        extensionPointMissing.equals(MISSING_EP_IGNORE) ||
+                        extensionPointMissing.equals(MISSING_EP_WARN)) {
+                        // defer extensionpoint resolution until the full
+                        // import stack has been processed
+                        helper.getExtensionStack().add(new String[] {
+                                tgName, name, extensionPointMissing
+                            });
+                    } else {
+                        throw new BuildException("onMissingExtensionPoint"
+                                                 + " attribute can only be '"
+                                                 + MISSING_EP_FAIL
+                                                 + "', '" + MISSING_EP_WARN
+                                                 + "' or '" + MISSING_EP_IGNORE
+                                                 + "'", 
+                                                 target.getLocation());
+                    }
                 }
             }
         }
 
         private String getTargetPrefix(AntXMLContext context) {
             String configuredValue = getCurrentTargetPrefix();
             if (configuredValue != null && configuredValue.length() == 0) {
                 configuredValue = null;
             }
             if (configuredValue != null) {
                 return configuredValue;
             }
 
             String projectName = context.getCurrentProjectName();
             if ("".equals(projectName)) {
                 projectName = null;
             }
 
             return projectName;
         }
 
         /**
          * Handles the start of an element within a target.
          *
          * @param uri The namespace URI for this element.
          * @param name The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The current context.
          * @return an element handler.
          *
          * @exception SAXParseException if an error occurs when initialising
          *                              the appropriate child handler
          */
         public AntHandler onStartChild(String uri, String name, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             return ProjectHelper2.elementHandler;
         }
 
         /**
          * Handle the end of the project, sets the current target of the
          * context to be the implicit target.
          *
          * @param uri The namespace URI of the element.
          * @param tag The name of the element.
          * @param context The current context.
          */
         public void onEndElement(String uri, String tag, AntXMLContext context) {
             context.setCurrentTarget(context.getImplicitTarget());
         }
     }
 
     /**
      * Handler for all project elements ( tasks, data types )
      */
     public static class ElementHandler extends AntHandler {
 
         /**
          * Constructor.
          */
         public ElementHandler() {
         }
 
         /**
          * Initialisation routine called after handler creation
          * with the element name and attributes. This configures
          * the element with its attributes and sets it up with
          * its parent container (if any). Nested elements are then
          * added later as the parser encounters them.
          *
          * @param uri The namespace URI for this element.
          * @param tag Name of the element which caused this handler
          *            to be created. Must not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element which caused this
          *              handler to be created. Must not be <code>null</code>.
          * @param context The current context.
          *
          * @exception SAXParseException in case of error (not thrown in
          *                              this implementation)
          */
         public void onStartElement(String uri, String tag, String qname, Attributes attrs,
                                    AntXMLContext context) throws SAXParseException {
             RuntimeConfigurable parentWrapper = context.currentWrapper();
             Object parent = null;
 
             if (parentWrapper != null) {
                 parent = parentWrapper.getProxy();
             }
 
             /* UnknownElement is used for tasks and data types - with
                delayed eval */
             UnknownElement task = new UnknownElement(tag);
             task.setProject(context.getProject());
             task.setNamespace(uri);
             task.setQName(qname);
             task.setTaskType(ProjectHelper.genComponentName(task.getNamespace(), tag));
             task.setTaskName(qname);
 
             Location location = new Location(context.getLocator().getSystemId(), context
-                    .getLocator().getLineNumber(), context.getLocator().getColumnNumber());
+                                             .getLocator().getLineNumber(), context.getLocator().getColumnNumber());
             task.setLocation(location);
             task.setOwningTarget(context.getCurrentTarget());
 
             if (parent != null) {
                 // Nested element
                 ((UnknownElement) parent).addChild(task);
             }  else {
                 // Task included in a target ( including the default one ).
                 context.getCurrentTarget().addTask(task);
             }
 
             context.configureId(task, attrs);
 
             // container.addTask(task);
             // This is a nop in UE: task.init();
 
             RuntimeConfigurable wrapper = new RuntimeConfigurable(task, task.getTaskName());
 
             for (int i = 0; i < attrs.getLength(); i++) {
                 String name = attrs.getLocalName(i);
                 String attrUri = attrs.getURI(i);
                 if (attrUri != null && !attrUri.equals("") && !attrUri.equals(uri)) {
                     name = attrUri + ":" + attrs.getQName(i);
                 }
                 String value = attrs.getValue(i);
                 // PR: Hack for ant-type value
                 //  an ant-type is a component name which can
                 // be namespaced, need to extract the name
                 // and convert from qualified name to uri/name
                 if (ANT_TYPE.equals(name)
-                        || (ANT_CORE_URI.equals(attrUri)
-                            && ANT_TYPE.equals(attrs.getLocalName(i)))) {
+                    || (ANT_CORE_URI.equals(attrUri)
+                        && ANT_TYPE.equals(attrs.getLocalName(i)))) {
                     name = ANT_TYPE;
                     int index = value.indexOf(":");
                     if (index >= 0) {
                         String prefix = value.substring(0, index);
                         String mappedUri = context.getPrefixMapping(prefix);
                         if (mappedUri == null) {
                             throw new BuildException("Unable to find XML NS prefix \"" + prefix
-                                    + "\"");
+                                                     + "\"");
                         }
                         value = ProjectHelper.genComponentName(mappedUri, value
-                                .substring(index + 1));
+                                                               .substring(index + 1));
                     }
                 }
                 wrapper.setAttribute(name, value);
             }
             if (parentWrapper != null) {
                 parentWrapper.addChild(wrapper);
             }
             context.pushWrapper(wrapper);
         }
 
         /**
          * Adds text to the task, using the wrapper
          *
          * @param buf A character array of the text within the element.
          *            Will not be <code>null</code>.
          * @param start The start element in the array.
          * @param count The number of characters to read from the array.
          * @param context The current context.
          *
          * @exception SAXParseException if the element doesn't support text
          *
          * @see ProjectHelper#addText(Project,java.lang.Object,char[],int,int)
          */
         public void characters(char[] buf, int start, int count,
                                AntXMLContext context) throws SAXParseException {
             RuntimeConfigurable wrapper = context.currentWrapper();
             wrapper.addText(buf, start, count);
         }
 
         /**
          * Handles the start of an element within a target. Task containers
          * will always use another task handler, and all other tasks
          * will always use a nested element handler.
          *
          * @param uri The namespace URI for this element.
          * @param tag The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The current context.
          * @return The handler for elements.
          *
          * @exception SAXParseException if an error occurs when initialising
          *                              the appropriate child handler
          */
         public AntHandler onStartChild(String uri, String tag, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             return ProjectHelper2.elementHandler;
         }
 
         /**
          * Handles the end of the element. This pops the wrapper from
          * the context.
          *
          * @param uri The namespace URI for the element.
          * @param tag The name of the element.
          * @param context The current context.
          */
         public void onEndElement(String uri, String tag, AntXMLContext context) {
             context.popWrapper();
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/AntStructure.java b/src/main/org/apache/tools/ant/taskdefs/AntStructure.java
index 475cc832f..8176bcb0f 100644
--- a/src/main/org/apache/tools/ant/taskdefs/AntStructure.java
+++ b/src/main/org/apache/tools/ant/taskdefs/AntStructure.java
@@ -1,487 +1,488 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.PrintWriter;
 import java.io.UnsupportedEncodingException;
 import java.util.Enumeration;
 import java.util.Hashtable;
 import java.util.Iterator;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.IntrospectionHelper;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.TaskContainer;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.Reference;
 
 /**
  * Creates a partial DTD for Ant from the currently known tasks.
  *
  *
  * @since Ant 1.1
  *
  * @ant.task category="xml"
  */
 public class AntStructure extends Task {
 
     private static final String LINE_SEP
         = System.getProperty("line.separator");
 
     private File output;
     private StructurePrinter printer = new DTDPrinter();
 
     /**
      * The output file.
      * @param output the output file
      */
     public void setOutput(File output) {
         this.output = output;
     }
 
     /**
      * The StructurePrinter to use.
      * @param p the printer to use.
      * @since Ant 1.7
      */
     public void add(StructurePrinter p) {
         printer = p;
     }
 
     /**
      * Build the antstructure DTD.
      *
      * @exception BuildException if the DTD cannot be written.
      */
     public void execute() throws BuildException {
 
         if (output == null) {
             throw new BuildException("output attribute is required", getLocation());
         }
 
         PrintWriter out = null;
         try {
             try {
                 out = new PrintWriter(new OutputStreamWriter(new FileOutputStream(output), "UTF8"));
             } catch (UnsupportedEncodingException ue) {
                 /*
                  * Plain impossible with UTF8, see
                  * http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html
                  *
                  * fallback to platform specific anyway.
                  */
                 out = new PrintWriter(new FileWriter(output));
             }
 
             printer.printHead(out, getProject(),
                               new Hashtable(getProject().getTaskDefinitions()),
                               new Hashtable(getProject().getDataTypeDefinitions()));
 
             printer.printTargetDecl(out);
 
             Iterator dataTypes = getProject().getCopyOfDataTypeDefinitions()
                 .keySet().iterator();
             while (dataTypes.hasNext()) {
                 String typeName = (String) dataTypes.next();
                 printer.printElementDecl(
-                    out, getProject(), typeName,
-                    (Class) getProject().getDataTypeDefinitions().get(typeName));
+                                         out, getProject(), typeName,
+                                         (Class) getProject().getDataTypeDefinitions().get(typeName));
             }
 
             Iterator tasks = getProject().getCopyOfTaskDefinitions().keySet()
                 .iterator();
             while (tasks.hasNext()) {
                 String tName = (String) tasks.next();
                 printer.printElementDecl(out, getProject(), tName,
                                          (Class) getProject().getTaskDefinitions().get(tName));
             }
 
             printer.printTail(out);
 
             if (out.checkError()) {
                 throw new IOException("Encountered an error writing Ant"
                                       + " structure");
             }
         } catch (IOException ioe) {
             throw new BuildException("Error writing "
                                      + output.getAbsolutePath(), ioe, getLocation());
         } finally {
             if (out != null) {
                 out.close();
             }
         }
     }
 
     /**
      * Writes the actual structure information.
      *
      * <p>{@link #printHead}, {@link #printTargetDecl} and {@link #printTail}
      * are called exactly once, {@link #printElementDecl} once for
      * each declared task and type.</p>
      */
     public static interface StructurePrinter {
         /**
          * Prints the header of the generated output.
          *
          * @param out PrintWriter to write to.
          * @param p Project instance for the current task
          * @param tasks map (name to implementing class)
          * @param types map (name to implementing class)
          * data types.
          */
         void printHead(PrintWriter out, Project p, Hashtable tasks,
                        Hashtable types);
 
         /**
          * Prints the definition for the target element.
          * @param out PrintWriter to write to.
          */
         void printTargetDecl(PrintWriter out);
 
         /**
          * Print the definition for a given element.
          *
          * @param out PrintWriter to write to.
          * @param p Project instance for the current task
          * @param name element name.
          * @param element class of the defined element.
          */
         void printElementDecl(PrintWriter out, Project p, String name,
                               Class element);
 
         /**
          * Prints the trailer.
          * @param out PrintWriter to write to.
          */
         void printTail(PrintWriter out);
     }
 
     private static class DTDPrinter implements StructurePrinter {
 
         private static final String BOOLEAN = "%boolean;";
         private static final String TASKS = "%tasks;";
         private static final String TYPES = "%types;";
 
         private Hashtable visited = new Hashtable();
 
         public void printTail(PrintWriter out) {
             visited.clear();
         }
 
         public void printHead(PrintWriter out, Project p, Hashtable tasks, Hashtable types) {
             printHead(out, tasks.keys(), types.keys());
         }
 
 
         /**
          * Prints the header of the generated output.
          *
          * <p>Basically this prints the XML declaration, defines some
          * entities and the project element.</p>
          */
         private void printHead(PrintWriter out, Enumeration tasks,
                                Enumeration types) {
             out.println("<?xml version=\"1.0\" encoding=\"UTF-8\" ?>");
             out.println("<!ENTITY % boolean \"(true|false|on|off|yes|no)\">");
             out.print("<!ENTITY % tasks \"");
             boolean first = true;
             while (tasks.hasMoreElements()) {
                 String tName = (String) tasks.nextElement();
                 if (!first) {
                     out.print(" | ");
                 } else {
                     first = false;
                 }
                 out.print(tName);
             }
             out.println("\">");
             out.print("<!ENTITY % types \"");
             first = true;
             while (types.hasMoreElements()) {
                 String typeName = (String) types.nextElement();
                 if (!first) {
                     out.print(" | ");
                 } else {
                     first = false;
                 }
                 out.print(typeName);
             }
             out.println("\">");
 
             out.println("");
 
             out.print("<!ELEMENT project (target | extension-point | ");
             out.print(TASKS);
             out.print(" | ");
             out.print(TYPES);
             out.println(")*>");
             out.println("<!ATTLIST project");
             out.println("          name    CDATA #IMPLIED");
             out.println("          default CDATA #IMPLIED");
             out.println("          basedir CDATA #IMPLIED>");
             out.println("");
         }
 
         /**
          * Prints the definition for the target element.
          */
         public void printTargetDecl(PrintWriter out) {
             out.print("<!ELEMENT target (");
             out.print(TASKS);
             out.print(" | ");
             out.print(TYPES);
             out.println(")*>");
             out.println("");
             printTargetAttrs(out, "target");
             out.println("<!ELEMENT extension-point EMPTY>");
             out.println("");
             printTargetAttrs(out, "extension-point");
         }
 
         /**
          * Prints the definition for the target element.
          */
         private void printTargetAttrs(PrintWriter out, String tag) {
             out.print("<!ATTLIST ");
             out.println(tag);
-            out.println("          id          ID    #IMPLIED");
-            out.println("          name        CDATA #REQUIRED");
-            out.println("          if          CDATA #IMPLIED");
-            out.println("          unless      CDATA #IMPLIED");
-            out.println("          depends     CDATA #IMPLIED");
-            out.println("          extensionOf CDATA #IMPLIED");
-            out.println("          description CDATA #IMPLIED>");
+            out.println("          id                      ID    #IMPLIED");
+            out.println("          name                    CDATA #REQUIRED");
+            out.println("          if                      CDATA #IMPLIED");
+            out.println("          unless                  CDATA #IMPLIED");
+            out.println("          depends                 CDATA #IMPLIED");
+            out.println("          extensionOf             CDATA #IMPLIED");
+            out.println("          onMissingExtensionPoint CDATA #IMPLIED");
+            out.println("          description             CDATA #IMPLIED>");
             out.println("");
         }
 
         /**
          * Print the definition for a given element.
          */
         public void printElementDecl(PrintWriter out, Project p,
                                      String name, Class element) {
 
             if (visited.containsKey(name)) {
                 return;
             }
             visited.put(name, "");
 
             IntrospectionHelper ih = null;
             try {
                 ih = IntrospectionHelper.getHelper(p, element);
             } catch (Throwable t) {
                 /*
                  * XXX - failed to load the class properly.
                  *
                  * should we print a warning here?
                  */
                 return;
             }
 
             StringBuffer sb = new StringBuffer("<!ELEMENT ");
             sb.append(name).append(" ");
 
             if (org.apache.tools.ant.types.Reference.class.equals(element)) {
                 sb.append("EMPTY>").append(LINE_SEP);
                 sb.append("<!ATTLIST ").append(name);
                 sb.append(LINE_SEP).append("          id ID #IMPLIED");
                 sb.append(LINE_SEP).append("          refid IDREF #IMPLIED");
                 sb.append(">").append(LINE_SEP);
                 out.println(sb);
                 return;
             }
 
             Vector v = new Vector();
             if (ih.supportsCharacters()) {
                 v.addElement("#PCDATA");
             }
 
             if (TaskContainer.class.isAssignableFrom(element)) {
                 v.addElement(TASKS);
             }
 
             Enumeration e = ih.getNestedElements();
             while (e.hasMoreElements()) {
                 v.addElement(e.nextElement());
             }
 
             if (v.isEmpty()) {
                 sb.append("EMPTY");
             } else {
                 sb.append("(");
                 final int count = v.size();
                 for (int i = 0; i < count; i++) {
                     if (i != 0) {
                         sb.append(" | ");
                     }
                     sb.append(v.elementAt(i));
                 }
                 sb.append(")");
                 if (count > 1 || !v.elementAt(0).equals("#PCDATA")) {
                     sb.append("*");
                 }
             }
             sb.append(">");
             out.println(sb);
 
             sb = new StringBuffer("<!ATTLIST ");
             sb.append(name);
             sb.append(LINE_SEP).append("          id ID #IMPLIED");
 
             e = ih.getAttributes();
             while (e.hasMoreElements()) {
                 String attrName = (String) e.nextElement();
                 if ("id".equals(attrName)) {
                     continue;
                 }
 
                 sb.append(LINE_SEP).append("          ")
                     .append(attrName).append(" ");
                 Class type = ih.getAttributeType(attrName);
                 if (type.equals(java.lang.Boolean.class)
                     || type.equals(java.lang.Boolean.TYPE)) {
                     sb.append(BOOLEAN).append(" ");
                 } else if (Reference.class.isAssignableFrom(type)) {
                     sb.append("IDREF ");
                 } else if (EnumeratedAttribute.class.isAssignableFrom(type)) {
                     try {
                         EnumeratedAttribute ea =
                             (EnumeratedAttribute) type.newInstance();
                         String[] values = ea.getValues();
                         if (values == null
                             || values.length == 0
                             || !areNmtokens(values)) {
                             sb.append("CDATA ");
                         } else {
                             sb.append("(");
                             for (int i = 0; i < values.length; i++) {
                                 if (i != 0) {
                                     sb.append(" | ");
                                 }
                                 sb.append(values[i]);
                             }
                             sb.append(") ");
                         }
                     } catch (InstantiationException ie) {
                         sb.append("CDATA ");
                     } catch (IllegalAccessException ie) {
                         sb.append("CDATA ");
                     }
                 } else if (type.getSuperclass() != null
                            && type.getSuperclass().getName().equals("java.lang.Enum")) {
                     try {
                         Object[] values = (Object[]) type.getMethod("values", (Class[])  null)
                             .invoke(null, (Object[]) null);
                         if (values.length == 0) {
                             sb.append("CDATA ");
                         } else {
                             sb.append('(');
                             for (int i = 0; i < values.length; i++) {
                                 if (i != 0) {
                                     sb.append(" | ");
                                 }
                                 sb.append(type.getMethod("name", (Class[]) null)
                                           .invoke(values[i], (Object[]) null));
                             }
                             sb.append(") ");
                         }
                     } catch (Exception x) {
                         sb.append("CDATA ");
                     }
                 } else {
                     sb.append("CDATA ");
                 }
                 sb.append("#IMPLIED");
             }
             sb.append(">").append(LINE_SEP);
             out.println(sb);
 
             final int count = v.size();
             for (int i = 0; i < count; i++) {
                 String nestedName = (String) v.elementAt(i);
                 if (!"#PCDATA".equals(nestedName)
                     && !TASKS.equals(nestedName)
                     && !TYPES.equals(nestedName)) {
                     printElementDecl(out, p, nestedName, ih.getElementType(nestedName));
                 }
             }
         }
 
         /**
          * Does this String match the XML-NMTOKEN production?
          * @param s the string to test
          * @return true if the string matches the XML-NMTOKEN
          */
         public static final boolean isNmtoken(String s) {
             final int length = s.length();
             for (int i = 0; i < length; i++) {
                 char c = s.charAt(i);
                 // XXX - we are committing CombiningChar and Extender here
                 if (!Character.isLetterOrDigit(c)
                     && c != '.' && c != '-' && c != '_' && c != ':') {
                     return false;
                 }
             }
             return true;
         }
 
         /**
          * Do the Strings all match the XML-NMTOKEN production?
          *
          * <p>Otherwise they are not suitable as an enumerated attribute,
          * for example.</p>
          * @param s the array of string to test
          * @return true if all the strings in the array math XML-NMTOKEN
          */
         public static final boolean areNmtokens(String[] s) {
             for (int i = 0; i < s.length; i++) {
                 if (!isNmtoken(s[i])) {
                     return false;
                 }
             }
             return true;
         }
     }
 
     /**
      * Does this String match the XML-NMTOKEN production?
      * @param s the string to test
      * @return true if the string matches the XML-NMTOKEN
      */
     protected boolean isNmtoken(String s) {
         return DTDPrinter.isNmtoken(s);
     }
 
     /**
      * Do the Strings all match the XML-NMTOKEN production?
      *
      * <p>Otherwise they are not suitable as an enumerated attribute,
      * for example.</p>
      * @param s the array of string to test
      * @return true if all the strings in the array math XML-NMTOKEN
      */
     protected boolean areNmtokens(String[] s) {
         return DTDPrinter.areNmtokens(s);
     }
 }
diff --git a/src/tests/antunit/core/extension-point-test.xml b/src/tests/antunit/core/extension-point-test.xml
index 810ad33aa..e1875b9fc 100644
--- a/src/tests/antunit/core/extension-point-test.xml
+++ b/src/tests/antunit/core/extension-point-test.xml
@@ -1,91 +1,136 @@
 <?xml version="1.0"?>
 <!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at
 
       http://www.apache.org/licenses/LICENSE-2.0
 
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
 <project xmlns:au="antlib:org.apache.ant.antunit" default="antunit">
 
   <import file="../antunit-base.xml"/>
 
   <extension-point name="testExtensionPointWorksLikeTarget"
                 depends="setProperty, assertProperty"/>
 
   <target name="setProperty">
     <property name="foo" value="bar"/>
   </target>
 
   <target name="assertProperty">
     <au:assertPropertyEquals name="foo" value="bar"/>
   </target>
 
   <target name="testExtensionPointMustBeEmpty">
     <mkdir dir="${output}"/>
     <echo file="${output}/build.xml"><![CDATA[
 <project>
   <extension-point name="foo">
     <echo>bar</echo>
   </extension-point>
 </project>]]></echo>
     <au:expectfailure
        expectedMessage="you must not nest child elements into an extension-point">
       <ant dir="${output}"/>
     </au:expectfailure>
   </target>
 
   <target name="testAddToExtensionPoint">
     <mkdir dir="${output}"/>
     <echo file="${output}/build.xml"><![CDATA[
 <project default="foo">
   <extension-point name="foo"/>
   <target name="bar" extensionOf="foo">
     <echo>In target bar</echo>
   </target>
 </project>]]></echo>
     <ant dir="${output}"/>
     <au:assertLogContains text="In target bar"/>
   </target>
 
   <target name="testCantAddToPlainTarget">
     <mkdir dir="${output}"/>
     <echo file="${output}/build.xml"><![CDATA[
 <project default="foo">
   <target name="foo"/>
   <target name="bar" extensionOf="foo"/>
 </project>]]></echo>
     <au:expectfailure
        expectedMessage="referenced target foo is not an extension-point">
       <ant dir="${output}"/>
     </au:expectfailure>
   </target>
 
   <target name="testExtensionPointInImportedBuildfile" description="Bug 48804">
     <mkdir dir="${output}"/>
     <echo file="${output}/master.xml"><![CDATA[
 <project default="bar">
   <extension-point name="foo"/>
   <target name="bar" depends="foo"/>
 </project>]]></echo>
     <echo file="${output}/build.xml"><![CDATA[
 <project>
   <import file="master.xml"/>
   <target name="prepare" extensionOf="foo">
     <echo>in target prepare</echo>
   </target>
 </project>]]></echo>
     <ant dir="${output}" target="bar"/>
     <au:assertLogContains text="in target prepare"/>
   </target>
 
+  <target name="testMissingExtensionPointCausesError">
+    <mkdir dir="${output}"/>
+    <echo file="${output}/build.xml"><![CDATA[
+<project default="bar">
+  <target name="bar" extensionOf="foo"/>
+</project>]]></echo>
+    <au:expectfailure
+        expectedMessage="can't add target bar to extension-point foo because the extension-point is unknown">
+      <ant dir="${output}" target="bar"/>
+    </au:expectfailure>
+  </target>
+
+  <target name="testMissingExtensionPointCausesWarningWhenConfigured">
+    <mkdir dir="${output}"/>
+    <echo file="${output}/build.xml"><![CDATA[
+<project default="bar">
+  <target name="bar" extensionOf="foo" onMissingExtensionPoint="warn"/>
+</project>]]></echo>
+    <ant dir="${output}" target="bar"/>
+    <au:assertLogContains level="warning"
+        text="can't add target bar to extension-point foo because the extension-point is unknown" />
+  </target>
+
+  <target name="testMissingExtensionPointIgnoredWhenConfigured">
+    <mkdir dir="${output}"/>
+    <echo file="${output}/build.xml"><![CDATA[
+<project default="bar">
+  <target name="bar" extensionOf="foo" onMissingExtensionPoint="ignore"/>
+</project>]]></echo>
+    <ant dir="${output}" target="bar"/>
+    <au:assertLogDoesntContain level="warning"
+        text="can't add target bar to extension-point foo because the extension-point is unknown" />
+  </target>
+
+  <target name="testOnlyAllowsExtensionPointMissingAttributeWhenExtensionOfPresent">
+    <mkdir dir="${output}"/>
+    <echo file="${output}/build.xml"><![CDATA[
+<project default="bar">
+  <target name="bar" onMissingExtensionPoint="ignore"/>
+</project>]]></echo>
+    <au:expectfailure
+        expectedMessage="onMissingExtensionPoint attribute cannot be specified unless extensionOf is specified">
+      <ant dir="${output}" target="bar"/>
+    </au:expectfailure>
+  </target>
 </project>
