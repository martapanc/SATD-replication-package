diff --git a/documentation/src/main/docbook/devguide/en-US/Envers.xml b/documentation/src/main/docbook/devguide/en-US/Envers.xml
index f3acd55206..49d247d35e 100644
--- a/documentation/src/main/docbook/devguide/en-US/Envers.xml
+++ b/documentation/src/main/docbook/devguide/en-US/Envers.xml
@@ -116,1638 +116,1638 @@
                             Name of a field in the audit entity that will hold the revision number.
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.revision_type_field_name</property>
                         </entry>
                         <entry>
                             REVTYPE
                         </entry>
                         <entry>
                             Name of a field in the audit entity that will hold the type of the revision (currently,
                             this can be: add, mod, del).
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.revision_on_collection_change</property>
                         </entry>
                         <entry>
                             true
                         </entry>
                         <entry>
                             Should a revision be generated when a not-owned relation field changes (this can be either
                             a collection in a one-to-many relation, or the field using "mappedBy" attribute in a
                             one-to-one relation).
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.do_not_audit_optimistic_locking_field</property>
                         </entry>
                         <entry>
                             true
                         </entry>
                         <entry>
                             When true, properties to be used for optimistic locking, annotated with
                             <literal>@Version</literal>, will be automatically not audited (their history won't be
                             stored; it normally doesn't make sense to store it).
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.store_data_at_delete</property>
                         </entry>
                         <entry>
                             false
                         </entry>
                         <entry>
                             Should the entity data be stored in the revision when the entity is deleted (instead of only
                             storing the id and all other properties as null). This is not normally needed, as the data is
                             present in the last-but-one revision. Sometimes, however, it is easier and more efficient to
                             access it in the last revision (then the data that the entity contained before deletion is
                             stored twice).
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.default_schema</property>
                         </entry>
                         <entry>
                             null (same schema as table being audited)
                         </entry>
                         <entry>
                             The default schema name that should be used for audit tables. Can be overridden using the
                             <literal>@AuditTable(schema="...")</literal> annotation. If not present, the schema will
                             be the same as the schema of the table being audited.
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.default_catalog</property>
                         </entry>
                         <entry>
                             null (same catalog as table being audited)
                         </entry>
                         <entry>
                             The default catalog name that should be used for audit tables. Can be overridden using the
                             <literal>@AuditTable(catalog="...")</literal> annotation. If not present, the catalog will
                             be the same as the catalog of the normal tables.
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.audit_strategy</property>
                         </entry>
                         <entry>
                             org.hibernate.envers.strategy.DefaultAuditStrategy
                         </entry>
                         <entry>
                             The audit strategy that should be used when persisting audit data. The default stores only
                             the revision, at which an entity was modified. An alternative, the
                             <literal>org.hibernate.envers.strategy.ValidityAuditStrategy</literal> stores both the
                             start revision and the end revision. Together these define when an audit row was valid,
                             hence the name ValidityAuditStrategy.
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.audit_strategy_validity_end_rev_field_name</property>
                         </entry>
                         <entry>
                             REVEND
                         </entry>
                         <entry>
                             The column name that will hold the end revision number in audit entities. This property is
                             only valid if the validity audit strategy is used.
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</property>
                         </entry>
                         <entry>
                             false
                         </entry>
                         <entry>
                             Should the timestamp of the end revision be stored, until which the data was valid, in
                             addition to the end revision itself.  This is useful to be able to purge old Audit records
                             out of a relational database by using table partitioning.  Partitioning requires a column
                             that exists within the table.  This property is only evaluated if the ValidityAuditStrategy
                             is used.
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name</property>
                         </entry>
                         <entry>
                             REVEND_TSTMP
                         </entry>
                         <entry>
                             Column name of the timestamp of the end revision until which the data was valid.  Only used
                             if the ValidityAuditStrategy is used, and
                             <property>org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</property>
                             evaluates to true
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.use_revision_entity_with_native_id</property>
                         </entry>
                         <entry>
                             true
                         </entry>
                         <entry>
                             Boolean flag that determines the strategy of revision number generation. Default
                             implementation of revision entity uses native identifier generator. If current database
                             engine does not support identity columns, users are advised to set this property to false.
                             In this case revision numbers are created by preconfigured
                             <classname>org.hibernate.id.enhanced.SequenceStyleGenerator</classname>. See:
                             <orderedlist>
                                 <listitem><classname>org.hibernate.envers.DefaultRevisionEntity</classname></listitem>
                                 <listitem><classname>org.hibernate.envers.enhanced.SequenceIdRevisionEntity</classname></listitem>
                             </orderedlist>
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.track_entities_changed_in_revision</property>
                         </entry>
                         <entry>
                             false
                         </entry>
                         <entry>
                             Should entity types, that have been modified during each revision, be tracked. The default
                             implementation creates <literal>REVCHANGES</literal> table that stores entity names
                             of modified persistent objects. Single record encapsulates the revision identifier
                             (foreign key to <literal>REVINFO</literal> table) and a string value. For more
                             information refer to <xref linkend="envers-tracking-modified-entities-revchanges"/>
                             and <xref linkend="envers-tracking-modified-entities-queries"/>.
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.global_with_modified_flag</property>
                         </entry>
                         <entry>
                             false, can be individually overriden with <literal>@Audited(withModifiedFlag=true)</literal>
                         </entry>
                         <entry>
                             Should property modification flags be stored for all audited entities and all properties.
                             When set to true, for all properties an additional boolean column in the audit tables will
                             be created, filled with information if the given property changed in the given revision.
                             When set to false, such column can be added to selected entities or properties using the
                             <literal>@Audited</literal> annotation.
                             For more information refer to <xref linkend="envers-tracking-properties-changes"/>
                             and <xref linkend="envers-tracking-properties-changes-queries"/>.
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.modified_flag_suffix</property>
                         </entry>
                         <entry>
                             _MOD
                         </entry>
                         <entry>
                             The suffix for columns storing "Modified Flags".
                             For example: a property called "age", will by default get modified flag with column name "age_MOD".
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.embeddable_set_ordinal_field_name</property>
                         </entry>
                         <entry>
                             SETORDINAL
                         </entry>
                         <entry>
                             Name of column used for storing ordinal of the change in sets of embeddable elements.
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.cascade_delete_revision</property>
                         </entry>
                         <entry>
                             false
                         </entry>
                         <entry>
                             While deleting revision entry, remove data of associated audited entities.
                             Requires database support for cascade row removal. 
                         </entry>
                     </row>
                     <row>
                         <entry>
                             <property>org.hibernate.envers.allow_identifier_reuse</property>
                         </entry>
                         <entry>
                             false
                         </entry>
                         <entry>
                             Guarantees proper validity audit strategy behavior when application reuses identifiers
                             of deleted entities. Exactly one row with <literal>null</literal> end date exists
                             for each identifier.
                         </entry>
                     </row>
                 </tbody>
             </tgroup>
         </table>
 
         <important>
             <para>
                 The following configuration options have been added recently and should be regarded as experimental:
                 <orderedlist>
                     <listitem>
                         org.hibernate.envers.track_entities_changed_in_revision
                     </listitem>
                     <listitem>
                         org.hibernate.envers.using_modified_flag
                     </listitem>
                     <listitem>
                         org.hibernate.envers.modified_flag_suffix
                     </listitem>
                 </orderedlist>
             </para>
         </important>
     </section>
 
     <section>
         <title>Additional mapping annotations</title>
 
         <para>
             The name of the audit table can be set on a per-entity basis, using the
             <literal>@AuditTable</literal> annotation. It may be tedious to add this
             annotation to every audited entity, so if possible, it's better to use a prefix/suffix.
         </para>
 
         <para>
             If you have a mapping with secondary tables, audit tables for them will be generated in
             the same way (by adding the prefix and suffix). If you wish to overwrite this behaviour,
             you can use the <literal>@SecondaryAuditTable</literal> and
             <literal>@SecondaryAuditTables</literal> annotations.
         </para>
 
         <para>
             If you'd like to override auditing behaviour of some fields/properties inherited from
             <interfacename>@Mappedsuperclass</interfacename> or in an embedded component, you can
             apply the <literal>@AuditOverride(s)</literal> annotation on the subtype or usage site
             of the component.
         </para>
 
         <para>
             If you want to audit a relation mapped with <literal>@OneToMany+@JoinColumn</literal>,
             please see <xref linkend="envers-mappingexceptions"/> for a description of the additional
             <literal>@AuditJoinTable</literal> annotation that you'll probably want to use.
         </para>
 
         <para>
             If you want to audit a relation, where the target entity is not audited (that is the case for example with
             dictionary-like entities, which don't change and don't have to be audited), just annotate it with
             <literal>@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)</literal>. Then, while reading historic
             versions of your entity, the relation will always point to the "current" related entity. By default Envers
             throws <classname>javax.persistence.EntityNotFoundException</classname> when "current" entity does not
             exist in the database. Apply <literal>@NotFound(action = NotFoundAction.IGNORE)</literal> annotation
             to silence the exception and assign null value instead. Hereby solution causes implicit eager loading
             of to-one relations.
         </para>
 
         <para>
             If you'd like to audit properties of a superclass of an entity, which are not explicitly audited (which
             don't have the <literal>@Audited</literal> annotation on any properties or on the class), you can list the
             superclasses in the <literal>auditParents</literal> attribute of the <interfacename>@Audited</interfacename>
             annotation. Please note that <literal>auditParents</literal> feature has been deprecated. Use
             <literal>@AuditOverride(forClass = SomeEntity.class, isAudited = true/false)</literal> instead.
         </para>
     </section>
 
     <section>
         <title>Choosing an audit strategy</title>
         <para>
             After the basic configuration it is important to choose the audit strategy that will be used to persist
             and retrieve audit information. There is a trade-off between the performance of persisting and the
             performance of querying the audit information. Currently there two audit strategies.
         </para>
         <orderedlist>
             <listitem>
                 <para>
                     The default audit strategy persists the audit data together with a start revision. For each row
                     inserted, updated or deleted in an audited table, one or more rows are inserted in the audit
                     tables, together with the start revision of its validity. Rows in the audit tables are never
                     updated after insertion.  Queries of audit information use subqueries to select the applicable
                     rows in the audit tables.  These subqueries are notoriously slow and difficult to index.
                 </para>
             </listitem>
             <listitem>
                 <para>
                     The alternative is a validity audit strategy. This strategy stores the start-revision and the
                     end-revision of audit information. For each row inserted, updated or deleted in an audited table,
                     one or more rows are inserted in the audit tables, together with the start revision of its
                     validity. But at the same time the end-revision field of the previous audit rows (if available)
                     are set to this revision.  Queries on the audit information can then use 'between start and end
                     revision' instead of subqueries as used by the default audit strategy.
                 </para>
                 <para>
                     The consequence of this strategy is that persisting audit information will be a bit slower,
                     because of the extra updates involved, but retrieving audit information will be a lot faster.
                     This can be improved by adding extra indexes.
                 </para>
             </listitem>
         </orderedlist>
     </section>
 
     <section xml:id="envers-revisionlog">
         <title>Revision Log</title>
         <subtitle>Logging data for revisions</subtitle>
 
         <para>
             When Envers starts a new revision, it creates a new <firstterm>revision entity</firstterm> which stores
             information about the revision.  By default, that includes just
         </para>
         <orderedlist>
             <listitem>
                 <para>
                     <firstterm>revision number</firstterm> - An integral value (<literal>int/Integer</literal> or
                     <literal>long/Long</literal>).  Essentially the primary key of the revision
                 </para>
             </listitem>
             <listitem>
                 <para>
                     <firstterm>revision timestamp</firstterm> - either a <literal>long/Long</literal> or
                     <classname>java.util.Date</classname> value representing the instant at which the revision was made.
                     When using a <classname>java.util.Date</classname>, instead of a <literal>long/Long</literal> for
                     the revision timestamp, take care not to store it to a column data type which will loose precision.
                 </para>
             </listitem>
         </orderedlist>
 
         <para>
             Envers handles this information as an entity.  By default it uses its own internal class to act as the
             entity, mapped to the <literal>REVINFO</literal> table.
             You can, however, supply your own approach to collecting this information which might be useful to
             capture additional details such as who made a change or the ip address from which the request came.  There
             are 2 things you need to make this work.
         </para>
         <orderedlist>
             <listitem>
                 <para>
                     First, you will need to tell Envers about the entity you wish to use.  Your entity must use the
                     <interfacename>@org.hibernate.envers.RevisionEntity</interfacename> annotation.  It must
                     define the 2 attributes described above annotated with
                     <interfacename>@org.hibernate.envers.RevisionNumber</interfacename> and
                     <interfacename>@org.hibernate.envers.RevisionTimestamp</interfacename>, respectively.  You can extend
                     from <classname>org.hibernate.envers.DefaultRevisionEntity</classname>, if you wish, to inherit all
                     these required behaviors.
                 </para>
                 <para>
                     Simply add the custom revision entity as you do your normal entities.  Envers will "find it".  Note
                     that it is an error for there to be multiple entities marked as
                     <interfacename>@org.hibernate.envers.RevisionEntity</interfacename>
                 </para>
             </listitem>
             <listitem>
                 <para>
                     Second, you need to tell Envers how to create instances of your revision entity which is handled
                     by the <methodname>newRevision</methodname> method of the
                     <interfacename>org.jboss.envers.RevisionListener</interfacename> interface.
                 </para>
                 <para>
                     You tell Envers your custom <interfacename>org.hibernate.envers.RevisionListener</interfacename>
                     implementation to use by specifying it on the
                     <interfacename>@org.hibernate.envers.RevisionEntity</interfacename> annotation, using the
                     <methodname>value</methodname> attribute. If your <interfacename>RevisionListener</interfacename>
                     class is inaccessible from <interfacename>@RevisionEntity</interfacename> (e.g. exists in a different
                     module), set <property>org.hibernate.envers.revision_listener</property> property to it's fully
                     qualified name. Class name defined by the configuration parameter overrides revision entity's
                     <methodname>value</methodname> attribute.
                 </para>
             </listitem>
         </orderedlist>
         <programlisting><![CDATA[@Entity
 @RevisionEntity( MyCustomRevisionListener.class )
 public class MyCustomRevisionEntity {
     ...
 }
 
 public class MyCustomRevisionListener implements RevisionListener {
     public void newRevision(Object revisionEntity) {
         ( (MyCustomRevisionEntity) revisionEntity )...;
     }
 }
 ]]></programlisting>
 
         <para>
             An alternative method to using the <interfacename>org.hibernate.envers.RevisionListener</interfacename>
             is to instead call the <methodname>getCurrentRevision</methodname> method of the
             <interfacename>org.hibernate.envers.AuditReader</interfacename> interface to obtain the current revision,
             and fill it with desired information.  The method accepts a <literal>persist</literal> parameter indicating
             whether the revision entity should be persisted prior to returning from this method. <literal>true</literal>
             ensures that the returned entity has access to its identifier value (revision number), but the revision
             entity will be persisted regardless of whether there are any audited entities changed. <literal>false</literal>
             means that the revision number will be <literal>null</literal>, but the revision entity will be persisted
             only if some audited entities have changed.
         </para>
 
 
         <example>
             <title>Example of storing username with revision</title>
 
             <programlisting>
                 <filename>ExampleRevEntity.java</filename><![CDATA[
 
 package org.hibernate.envers.example;
 
 import org.hibernate.envers.RevisionEntity;
 import org.hibernate.envers.DefaultRevisionEntity;
 
 import javax.persistence.Entity;
 
 @Entity
 @RevisionEntity(ExampleListener.class)
 public class ExampleRevEntity extends DefaultRevisionEntity {
     private String username;
 
     public String getUsername() { return username; }
     public void setUsername(String username) { this.username = username; }
 }]]></programlisting>
 
             <programlisting>
                 <filename>ExampleListener.java</filename><![CDATA[
 
 package org.hibernate.envers.example;
 
 import org.hibernate.envers.RevisionListener;
 import org.jboss.seam.security.Identity;
 import org.jboss.seam.Component;
 
 public class ExampleListener implements RevisionListener {
     public void newRevision(Object revisionEntity) {
         ExampleRevEntity exampleRevEntity = (ExampleRevEntity) revisionEntity;
         Identity identity =
             (Identity) Component.getInstance("org.jboss.seam.security.identity");
 
         exampleRevEntity.setUsername(identity.getUsername());
     }
 }]]></programlisting>
 
         </example>
 
         <section xml:id="envers-tracking-modified-entities-revchanges">
             <title>Tracking entity names modified during revisions</title>
             <para>
                 By default entity types that have been changed in each revision are not being tracked. This implies the
                 necessity to query all tables storing audited data in order to retrieve changes made during
                 specified revision. Envers provides a simple mechanism that creates <literal>REVCHANGES</literal>
                 table which stores entity names of modified persistent objects. Single record encapsulates the revision
                 identifier (foreign key to <literal>REVINFO</literal> table) and a string value.
             </para>
             <para>
                 Tracking of modified entity names can be enabled in three different ways:
             </para>
             <orderedlist>
                 <listitem>
                     <para>
                         Set <property>org.hibernate.envers.track_entities_changed_in_revision</property> parameter to
                         <literal>true</literal>. In this case
                         <classname>org.hibernate.envers.DefaultTrackingModifiedEntitiesRevisionEntity</classname> will
                         be implicitly used as the revision log entity.
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         Create a custom revision entity that extends
                         <classname>org.hibernate.envers.DefaultTrackingModifiedEntitiesRevisionEntity</classname> class.
                     </para>
                     <programlisting>
 <![CDATA[@Entity
 @RevisionEntity
 public class ExtendedRevisionEntity
              extends DefaultTrackingModifiedEntitiesRevisionEntity {
     ...
 }]]></programlisting>
                 </listitem>
                 <listitem>
                     <para>
                         Mark an appropriate field of a custom revision entity with
                         <interfacename>@org.hibernate.envers.ModifiedEntityNames</interfacename> annotation. The property is
                         required to be of <literal><![CDATA[Set<String>]]></literal> type.
                     </para>
                     <programlisting>
 <![CDATA[@Entity
 @RevisionEntity
 public class AnnotatedTrackingRevisionEntity {
     ...
 
     @ElementCollection
     @JoinTable(name = "REVCHANGES", joinColumns = @JoinColumn(name = "REV"))
     @Column(name = "ENTITYNAME")
     @ModifiedEntityNames
     private Set<String> modifiedEntityNames;
     
     ...
 }]]></programlisting>
                 </listitem>
             </orderedlist>
             <para>
                 Users, that have chosen one of the approaches listed above, can retrieve all entities modified in a
                 specified revision by utilizing API described in <xref linkend="envers-tracking-modified-entities-queries"/>.
             </para>
             <para>
                 Users are also allowed to implement custom mechanism of tracking modified entity types. In this case, they
                 shall pass their own implementation of
                 <interfacename>org.hibernate.envers.EntityTrackingRevisionListener</interfacename> interface as the value
                 of <interfacename>@org.hibernate.envers.RevisionEntity</interfacename> annotation.
                 <interfacename>EntityTrackingRevisionListener</interfacename> interface exposes one method that notifies
                 whenever audited entity instance has been added, modified or removed within current revision boundaries.
             </para>
 
             <example>
                 <title>Custom implementation of tracking entity classes modified during revisions</title>
                 <programlisting>
                     <filename>CustomEntityTrackingRevisionListener.java</filename>
 <![CDATA[
 public class CustomEntityTrackingRevisionListener
              implements EntityTrackingRevisionListener {
     @Override
     public void entityChanged(Class entityClass, String entityName,
                               Serializable entityId, RevisionType revisionType,
                               Object revisionEntity) {
         String type = entityClass.getName();
         ((CustomTrackingRevisionEntity)revisionEntity).addModifiedEntityType(type);
     }
 
     @Override
     public void newRevision(Object revisionEntity) {
     }
 }]]></programlisting>
                 <programlisting>
                     <filename>CustomTrackingRevisionEntity.java</filename>
 <![CDATA[
 @Entity
 @RevisionEntity(CustomEntityTrackingRevisionListener.class)
 public class CustomTrackingRevisionEntity {
     @Id
     @GeneratedValue
     @RevisionNumber
     private int customId;
 
     @RevisionTimestamp
     private long customTimestamp;
 
     @OneToMany(mappedBy="revision", cascade={CascadeType.PERSIST, CascadeType.REMOVE})
     private Set<ModifiedEntityTypeEntity> modifiedEntityTypes =
                                               new HashSet<ModifiedEntityTypeEntity>();
     
     public void addModifiedEntityType(String entityClassName) {
         modifiedEntityTypes.add(new ModifiedEntityTypeEntity(this, entityClassName));
     }
     
     ...
 }
 ]]></programlisting>
                 <programlisting>
                     <filename>ModifiedEntityTypeEntity.java</filename>
 <![CDATA[
 @Entity
 public class ModifiedEntityTypeEntity {
     @Id
     @GeneratedValue
     private Integer id;
 
     @ManyToOne
     private CustomTrackingRevisionEntity revision;
     
     private String entityClassName;
     
     ...
 }
 ]]></programlisting>
                 <programlisting><![CDATA[CustomTrackingRevisionEntity revEntity =
     getAuditReader().findRevision(CustomTrackingRevisionEntity.class, revisionNumber);
 Set<ModifiedEntityTypeEntity> modifiedEntityTypes = revEntity.getModifiedEntityTypes()]]></programlisting>
             </example>
         </section>
 
     </section>
 
     <section xml:id="envers-tracking-properties-changes">
         <title>Tracking entity changes at property level</title>
         <para>
             By default the only information stored by Envers are revisions of modified entities.
             This approach lets user create audit queries based on historical values of entity's properties.
 
             Sometimes it is useful to store additional metadata for each revision, when you are interested also in
             the type of changes, not only about the resulting values. The feature described in
             <xref linkend="envers-tracking-modified-entities-revchanges"/>
             makes it possible to tell which entities were modified in given revision.
 
             Feature described here takes it one step further. "Modification Flags" enable Envers to track which
             properties of audited entities were modified in a given revision.
         </para>
         <para>
             Tracking entity changes at property level can be enabled by:
         </para>
         <orderedlist>
             <listitem>
                 <para>
                     setting <property>org.hibernate.envers.global_with_modified_flag</property> configuration
                     property to <literal>true</literal>.  This global switch will cause adding modification flags
                     for all audited properties in all audited entities.
                 </para>
             </listitem>
             <listitem>
                 <para>
                     using <literal>@Audited(withModifiedFlag=true)</literal> on a property or on an entity.
                 </para>
             </listitem>
         </orderedlist>
         <para>
             The trade-off coming with this functionality is an increased size of
             audit tables and a very little, almost negligible, performance drop
             during audit writes. This is due to the fact that every tracked
             property has to have an accompanying boolean column in the
             schema that stores information about the property's modifications. Of
             course it is Envers' job to fill these columns accordingly - no additional work by the
             developer is required. Because of costs mentioned, it is recommended
             to enable the feature selectively, when needed with use of the
             granular configuration means described above.
         </para>
         <para>
             To see how "Modified Flags" can be utilized, check out the very
             simple query API that uses them: <xref linkend="envers-tracking-properties-changes-queries"/>.
         </para>
     </section>
 
     <section xml:id="envers-queries">
 
         <title>Queries</title>
 
         <para>
             You can think of historic data as having two dimension. The first - horizontal -
             is the state of the database at a given revision. Thus, you can
             query for entities as they were at revision N. The second - vertical - are the
             revisions, at which entities changed. Hence, you can query for revisions,
             in which a given entity changed.
         </para>
 
         <para>
             The queries in Envers are similar to Hibernate Criteria queries, so if you are common with them,
             using Envers queries will be much easier.
         </para>
 
         <para>
             The main limitation of the current queries implementation is that you cannot
             traverse relations. You can only specify constraints on the ids of the
             related entities, and only on the "owning" side of the relation. This however
             will be changed in future releases.
         </para>
 
         <para>
             Please note, that queries on the audited data will be in many cases much slower
             than corresponding queries on "live" data, as they involve correlated subselects.
         </para>
 
         <para>
             In the future, queries will be improved both in terms of speed and possibilities, when using the valid-time
             audit strategy, that is when storing both start and end revisions for entities. See
             <xref linkend="envers-configuration"/>.
         </para>
 
         <section xml:id="entities-at-revision">
 
             <title>Querying for entities of a class at a given revision</title>
 
             <para>
                 The entry point for this type of queries is:
             </para>
 
             <programlisting><![CDATA[AuditQuery query = getAuditReader()
     .createQuery()
     .forEntitiesAtRevision(MyEntity.class, revisionNumber);]]></programlisting>
 
             <para>
                 You can then specify constraints, which should be met by the entities returned, by
                 adding restrictions, which can be obtained using the <literal>AuditEntity</literal>
                 factory class. For example, to select only entities, where the "name" property
                 is equal to "John":
             </para>
 
             <programlisting><![CDATA[query.add(AuditEntity.property("name").eq("John"));]]></programlisting>
 
             <para>
                 And to select only entites that are related to a given entity:
             </para>
 
             <programlisting><![CDATA[query.add(AuditEntity.property("address").eq(relatedEntityInstance));
 // or
 query.add(AuditEntity.relatedId("address").eq(relatedEntityId));]]></programlisting>
 
             <para>
                 You can limit the number of results, order them, and set aggregations and projections
                 (except grouping) in the usual way.
                 When your query is complete, you can obtain the results by calling the
                 <literal>getSingleResult()</literal> or <literal>getResultList()</literal> methods.
             </para>
 
             <para>
                 A full query, can look for example like this:
             </para>
 
             <programlisting><![CDATA[List personsAtAddress = getAuditReader().createQuery()
     .forEntitiesAtRevision(Person.class, 12)
     .addOrder(AuditEntity.property("surname").desc())
     .add(AuditEntity.relatedId("address").eq(addressId))
     .setFirstResult(4)
     .setMaxResults(2)
     .getResultList();]]></programlisting>
 
         </section>
 
         <section xml:id="revisions-of-entity">
 
             <title>Querying for revisions, at which entities of a given class changed</title>
 
             <para>
                 The entry point for this type of queries is:
             </para>
 
             <programlisting><![CDATA[AuditQuery query = getAuditReader().createQuery()
     .forRevisionsOfEntity(MyEntity.class, false, true);]]></programlisting>
 
             <para>
                 You can add constraints to this query in the same way as to the previous one.
                 There are some additional possibilities:
             </para>
 
             <orderedlist>
                 <listitem>
                     <para>
                         using <literal>AuditEntity.revisionNumber()</literal> you can specify constraints, projections
                         and order on the revision number, in which the audited entity was modified
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         similarly, using <literal>AuditEntity.revisionProperty(propertyName)</literal> you can specify constraints,
                         projections and order on a property of the revision entity, corresponding to the revision
                         in which the audited entity was modified
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         <literal>AuditEntity.revisionType()</literal> gives you access as above to the type of
                         the revision (ADD, MOD, DEL).
                     </para>
                 </listitem>
             </orderedlist>
 
             <para>
                 Using these methods,
                 you can order the query results by revision number, set projection or constraint
                 the revision number to be greater or less than a specified value, etc. For example, the
                 following query will select the smallest revision number, at which entity of class
                 <literal>MyEntity</literal> with id <literal>entityId</literal> has changed, after revision
                 number 42:
             </para>
 
             <programlisting><![CDATA[Number revision = (Number) getAuditReader().createQuery()
     .forRevisionsOfEntity(MyEntity.class, false, true)
     .setProjection(AuditEntity.revisionNumber().min())
     .add(AuditEntity.id().eq(entityId))
     .add(AuditEntity.revisionNumber().gt(42))
     .getSingleResult();]]></programlisting>
 
             <para>
                 The second additional feature you can use in queries for revisions is the ability
                 to maximalize/minimize a property. For example, if you want to select the
                 revision, at which the value of the <literal>actualDate</literal> for a given entity
                 was larger then a given value, but as small as possible:
             </para>
 
             <programlisting><![CDATA[Number revision = (Number) getAuditReader().createQuery()
     .forRevisionsOfEntity(MyEntity.class, false, true)
     // We are only interested in the first revision
     .setProjection(AuditEntity.revisionNumber().min())
     .add(AuditEntity.property("actualDate").minimize()
         .add(AuditEntity.property("actualDate").ge(givenDate))
         .add(AuditEntity.id().eq(givenEntityId)))
     .getSingleResult();
 ]]></programlisting>
 
             <para>
                 The <literal>minimize()</literal> and <literal>maximize()</literal> methods return a criteria,
                 to which you can add constraints, which must be met by the entities with the
                 maximized/minimized properties. <literal>AggregatedAuditExpression#computeAggregationInInstanceContext()</literal>
                 enables the possibility to compute aggregated expression in the context of each entity instance
                 separately. It turns out useful when querying for latest revisions of all entities of a particular type.
             </para>
 
             <para>
                 You probably also noticed that there are two boolean parameters, passed when
                 creating the query. The first one, <literal>selectEntitiesOnly</literal>, is only valid when
                 you don't set an explicit projection. If true, the result of the query will be
                 a list of entities (which changed at revisions satisfying the specified
                 constraints).
             </para>
 
             <para>
                 If false, the result will be a list of three element arrays. The
                 first element will be the changed entity instance. The second will be an entity
                 containing revision data (if no custom entity is used, this will be an instance
                 of <literal>DefaultRevisionEntity</literal>). The third will be the type of the
                 revision (one of the values of the <literal>RevisionType</literal> enumeration:
                 ADD, MOD, DEL).
             </para>
 
             <para>
                 The second parameter, <literal>selectDeletedEntities</literal>, specifies if revisions,
                 in which the entity was deleted should be included in the results. If yes, such entities
                 will have the revision type DEL and all fields, except the id,
                 <literal>null</literal>.
             </para>
 
         </section>
 
         <section xml:id="envers-tracking-properties-changes-queries">
 
             <title>Querying for revisions of entity that modified given property</title>
 
             <para>
                 For the two types of queries described above it's possible to use
                 special Audit criteria called
                 <literal>hasChanged()</literal>
                 and
                 <literal>hasNotChanged()</literal>
                 that makes use of the functionality
                 described in <xref linkend="envers-tracking-properties-changes"/>.
                 They're best suited for vertical queries,
                 however existing API doesn't restrict their usage for horizontal
                 ones.
 
                 Let's have a look at following examples:
             </para>
 
             <programlisting><![CDATA[AuditQuery query = getAuditReader().createQuery()
     .forRevisionsOfEntity(MyEntity.class, false, true)
     .add(AuditEntity.id().eq(id));
     .add(AuditEntity.property("actualDate").hasChanged())]]>
             </programlisting>
 
             <para>
                 This query will return all revisions of MyEntity with given id,
                 where the
                 <property>actualDate</property>
                 property has been changed.
                 Using this query we won't get all other revisions in which
                 <property>actualDate</property>
                 wasn't touched. Of course nothing prevents user from combining
                 hasChanged condition with some additional criteria - add method
                 can be used here in a normal way.
             </para>
 
             <programlisting><![CDATA[AuditQuery query = getAuditReader().createQuery()
     .forEntitiesAtRevision(MyEntity.class, revisionNumber)
     .add(AuditEntity.property("prop1").hasChanged())
     .add(AuditEntity.property("prop2").hasNotChanged());]]>
             </programlisting>
 
             <para>
                 This query will return horizontal slice for MyEntity at the time
                 revisionNumber was generated. It will be limited to revisions
                 that modified
                 <property>prop1</property>
                 but not <property>prop2</property>.
                 Note that the result set will usually also contain revisions
                 with numbers lower than the revisionNumber, so we cannot read
                 this query as "Give me all MyEntities changed in revisionNumber
                 with
                 <property>prop1</property>
                 modified and
                 <property>prop2</property>
                 untouched". To get such result we have to use the
                 <literal>forEntitiesModifiedAtRevision</literal> query:
             </para>
 
             <programlisting><![CDATA[AuditQuery query = getAuditReader().createQuery()
     .forEntitiesModifiedAtRevision(MyEntity.class, revisionNumber)
     .add(AuditEntity.property("prop1").hasChanged())
     .add(AuditEntity.property("prop2").hasNotChanged());]]>
             </programlisting>
 
         </section>
 
 
         <section xml:id="envers-tracking-modified-entities-queries">
             <title>Querying for entities modified in a given revision</title>
             <para>
                 The basic query allows retrieving entity names and corresponding Java classes changed in a specified revision:
             </para>
             <programlisting><![CDATA[Set<Pair<String, Class>> modifiedEntityTypes = getAuditReader()
     .getCrossTypeRevisionChangesReader().findEntityTypes(revisionNumber);]]></programlisting>
             <para>
                 Other queries (also accessible from <interfacename>org.hibernate.envers.CrossTypeRevisionChangesReader</interfacename>):
             </para>
             <orderedlist>
                 <listitem>
                     <para>
                         <firstterm><methodname>List<![CDATA[<Object>]]> findEntities(Number)</methodname></firstterm>
                         - Returns snapshots of all audited entities changed (added, updated and removed) in a given revision.
                         Executes <literal>n+1</literal> SQL queries, where <literal>n</literal> is a number of different entity
                         classes modified within specified revision.
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         <firstterm><methodname>List<![CDATA[<Object>]]> findEntities(Number, RevisionType)</methodname></firstterm>
                         - Returns snapshots of all audited entities changed (added, updated or removed) in a given revision
                         filtered by modification type. Executes <literal>n+1</literal> SQL queries, where <literal>n</literal>
                         is a number of different entity classes modified within specified revision.
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         <firstterm><methodname><![CDATA[Map<RevisionType, List<Object>>]]> findEntitiesGroupByRevisionType(Number)</methodname></firstterm>
                         - Returns a map containing lists of entity snapshots grouped by modification operation (e.g.
                         addition, update and removal). Executes <literal>3n+1</literal> SQL queries, where <literal>n</literal>
                         is a number of different entity classes modified within specified revision.
                     </para>
                 </listitem>
             </orderedlist>
             <para>
                 Note that methods described above can be legally used only when default mechanism of
                 tracking changed entity names is enabled (see <xref linkend="envers-tracking-modified-entities-revchanges"/>).
             </para>
         </section>
 
     </section>
 
     <section>
         <title>Conditional auditing</title>
         <para>
             Envers persists audit data in reaction to various Hibernate events (e.g. post update, post insert, and
             so on), using a series of even listeners from the <literal>org.hibernate.envers.event.spi</literal>
             package. By default, if the Envers jar is in the classpath, the event listeners are auto-registered with
             Hibernate.
         </para>
         <para>
             Conditional auditing can be implemented by overriding some of the Envers event listeners.
             To use customized Envers event listeners, the following steps are needed:
             <orderedlist>
                 <listitem>
                     <para>
                         Turn off automatic Envers event listeners registration by setting the
                         <literal>hibernate.listeners.envers.autoRegister</literal> Hibernate property to
                         <literal>false</literal>.
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         Create subclasses for appropriate event listeners. For example, if you want to
                         conditionally audit entity insertions, extend the
                         <literal>org.hibernate.envers.event.spi.EnversPostInsertEventListenerImpl</literal>
                         class. Place the conditional-auditing logic in the subclasses, call the super method if
                         auditing should be performed.
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         Create your own implementation of <literal>org.hibernate.integrator.spi.Integrator</literal>,
-                        similar to <literal>org.hibernate.envers.event.spi.EnversIntegrator</literal>. Use your event
+                        similar to <literal>org.hibernate.envers.boot.internal.EnversIntegrator</literal>. Use your event
                         listener classes instead of the default ones.
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         For the integrator to be automatically used when Hibernate starts up, you will need to add a
                         <literal>META-INF/services/org.hibernate.integrator.spi.Integrator</literal> file to your jar.
                         The file should contain the fully qualified name of the class implementing the interface.
                     </para>
                 </listitem>
             </orderedlist>
         </para>
     </section>
 
     <section>
         <title>Understanding the Envers Schema</title>
 
         <para>
             For each audited entity (that is, for each entity containing at least one audited field), an audit table is
             created.  By default, the audit table's name is created by adding a "_AUD" suffix to the original table name,
             but this can be overridden by specifying a different suffix/prefix in the configuration or per-entity using
             the <interfacename>@org.hibernate.envers.AuditTable</interfacename> annotation.
         </para>
 
         <orderedlist>
             <title>Audit table columns</title>
             <listitem>
                 <para>
                     id of the original entity (this can be more then one column in the case of composite primary keys)
                 </para>
             </listitem>
             <listitem>
                 <para>
                     revision number - an integer.  Matches to the revision number in the revision entity table.
                 </para>
             </listitem>
             <listitem>
                 <para>
                     revision type - a small integer
                 </para>
             </listitem>
             <listitem>
                 <para>
                     audited fields from the original entity
                 </para>
             </listitem>
         </orderedlist>
 
         <para>
             The primary key of the audit table is the combination of the original id of the entity and the revision
             number - there can be at most one historic entry for a given entity instance at a given revision.
         </para>
 
         <para>
             The current entity data is stored in the original table and in the audit table.  This is a duplication of
             data, however as this solution makes the query system much more powerful, and as memory is cheap, hopefully
             this won't be a major drawback for the users.  A row in the audit table with entity id ID, revision N and
             data D means: entity with id ID has data D from revision N upwards.  Hence, if we want to find an entity at
             revision M, we have to search for a row in the audit table, which has the revision number smaller or equal
             to M, but as large as possible. If no such row is found, or a row with a "deleted" marker is found, it means
             that the entity didn't exist at that revision.
         </para>
 
         <para>
             The "revision type" field can currently have three values: 0, 1, 2, which means ADD, MOD and DEL,
             respectively. A row with a revision of type DEL will only contain the id of the entity and no data (all
             fields NULL), as it only serves as a marker saying "this entity was deleted at that revision".
         </para>
 
         <para>
             Additionally, there is a revision entity table which contains the information about the
             global revision.  By default the generated table is named <database class="table">REVINFO</database> and
             contains just 2 columns: <database class="field">ID</database> and <database class="field">TIMESTAMP</database>.
             A row is inserted into this table on each new revision, that is, on each commit of a transaction, which
             changes audited data.  The name of this table can be configured, the name of its columns as well as adding
             additional columns can be achieved as discussed in <xref linkend="envers-revisionlog"/>.
         </para>
 
         <para>
             While global revisions are a good way to provide correct auditing of relations, some people have pointed out
             that this may be a bottleneck in systems, where data is very often modified.  One viable solution is to
             introduce an option to have an entity "locally revisioned", that is revisions would be created for it
             independently.  This wouldn't enable correct versioning of relations, but wouldn't also require the
             <database class="table">REVINFO</database> table.  Another possibility is to introduce a notion of
             "revisioning groups": groups of entities which share revision numbering.  Each such group would have to
             consist of one or more strongly connected component of the graph induced by relations between entities.
             Your opinions on the subject are very welcome on the forum! :)
         </para>
 
     </section>
 
     <section xml:id="envers-generateschema">
         <title>Generating schema with Ant</title>
 
         <para>
             If you'd like to generate the database schema file with the Hibernate Tools Ant task,
             you'll probably notice that the generated file doesn't contain definitions of audit
             tables. To generate also the audit tables, you simply need to use
             <literal>org.hibernate.tool.ant.EnversHibernateToolTask</literal> instead of the usual
             <literal>org.hibernate.tool.ant.HibernateToolTask</literal>. The former class extends
             the latter, and only adds generation of the version entities. So you can use the task
             just as you used to.
         </para>
 
         <para>
             For example:
         </para>
 
         <programlisting><![CDATA[<target name="schemaexport" depends="build-demo"
   description="Exports a generated schema to DB and file">
   <taskdef name="hibernatetool"
     classname="org.hibernate.tool.ant.EnversHibernateToolTask"
     classpathref="build.demo.classpath"/>
 
   <hibernatetool destdir=".">
     <classpath>
       <fileset refid="lib.hibernate" />
       <path location="${build.demo.dir}" />
       <path location="${build.main.dir}" />
     </classpath>
     <jpaconfiguration persistenceunit="ConsolePU" />
     <hbm2ddl
       drop="false"
       create="true"
       export="false"
       outputfilename="versioning-ddl.sql"
       delimiter=";"
       format="true"/>
   </hibernatetool>
 </target>]]></programlisting>
 
         <para>
             Will generate the following schema:
         </para>
 
         <programlisting><![CDATA[
     create table Address (
         id integer generated by default as identity (start with 1),
         flatNumber integer,
         houseNumber integer,
         streetName varchar(255),
         primary key (id)
     );
 
     create table Address_AUD (
         id integer not null,
         REV integer not null,
         flatNumber integer,
         houseNumber integer,
         streetName varchar(255),
         REVTYPE tinyint,
         primary key (id, REV)
     );
 
     create table Person (
         id integer generated by default as identity (start with 1),
         name varchar(255),
         surname varchar(255),
         address_id integer,
         primary key (id)
     );
 
     create table Person_AUD (
         id integer not null,
         REV integer not null,
         name varchar(255),
         surname varchar(255),
         REVTYPE tinyint,
         address_id integer,
         primary key (id, REV)
     );
 
     create table REVINFO (
         REV integer generated by default as identity (start with 1),
         REVTSTMP bigint,
         primary key (REV)
     );
 
     alter table Person
         add constraint FK8E488775E4C3EA63
         foreign key (address_id)
         references Address;
     ]]></programlisting>
     </section>
 
 
     <section xml:id="envers-mappingexceptions">
         <title>Mapping exceptions</title>
 
         <section>
 
             <title>What isn't and will not be supported</title>
 
             <para>
                 Bags, as they can contain non-unique elements.
                 The reason is that persisting, for example a bag of String-s, violates a principle
                 of relational databases: that each table is a set of tuples. In case of bags,
                 however (which require a join table), if there is a duplicate element, the two
                 tuples corresponding to the elements will be the same. Hibernate allows this,
                 however Envers (or more precisely: the database connector) will throw an exception
                 when trying to persist two identical elements, because of a unique constraint violation.
             </para>
 
             <para>
                 There are at least two ways out if you need bag semantics:
             </para>
 
             <orderedlist>
                 <listitem>
                     <para>
                         use an indexed collection, with the <literal>@IndexColumn</literal> annotation, or
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         provide a unique id for your elements with the <literal>@CollectionId</literal> annotation.
                     </para>
                 </listitem>
             </orderedlist>
 
         </section>
 
         <section>
 
             <title>What isn't and <emphasis>will</emphasis> be supported</title>
 
             <orderedlist>
                 <listitem>
                     <para>
                         Bag style collection which identifier column has been defined using
                         <interfacename>@CollectionId</interfacename> annotation (JIRA ticket HHH-3950).
                     </para>
                 </listitem>
             </orderedlist>
 
         </section>
 
         <section>
 
             <title><literal>@OneToMany</literal>+<literal>@JoinColumn</literal></title>
 
             <para>
                 When a collection is mapped using these two annotations, Hibernate doesn't
                 generate a join table. Envers, however, has to do this, so that when you read the
                 revisions in which the related entity has changed, you don't get false results.
             </para>
             <para>
                 To be able to name the additional join table, there is a special annotation:
                 <literal>@AuditJoinTable</literal>, which has similar semantics to JPA's
                 <literal>@JoinTable</literal>.
             </para>
 
             <para>
                 One special case are relations mapped with <literal>@OneToMany</literal>+<literal>@JoinColumn</literal> on
                 the one side, and <literal>@ManyToOne</literal>+<literal>@JoinColumn(insertable=false, updatable=false</literal>)
                 on the many side.  Such relations are in fact bidirectional, but the owning side is the collection.
             </para>
             <para>
                 To properly audit such relations with Envers, you can use the <literal>@AuditMappedBy</literal> annotation.
                 It enables you to specify the reverse property (using the <literal>mappedBy</literal> element). In case
                 of indexed collections, the index column must also be mapped in the referenced entity (using
                 <literal>@Column(insertable=false, updatable=false)</literal>, and specified using
                 <literal>positionMappedBy</literal>. This annotation will affect only the way
                 Envers works. Please note that the annotation is experimental and may change in the future.
             </para>
 
         </section>
     </section>
 
     <section xml:id="envers-partitioning">
         <title>Advanced: Audit table partitioning</title>
 
         <section xml:id="envers-partitioning-benefits">
 
             <title>Benefits of audit table partitioning</title>
 
             <para>
                 Because audit tables tend to grow indefinitely they can quickly become really large. When the audit tables have grown
                 to a certain limit (varying per RDBMS and/or operating system) it makes sense to start using table partitioning.
                 SQL table partitioning offers a lot of advantages including, but certainly not limited to:
                 <orderedlist>
                     <listitem>
                         <para>
                             Improved query performance by selectively moving rows to various partitions (or even purging old rows)
                         </para>
                     </listitem>
                     <listitem>
                         <para>
                             Faster data loads, index creation, etc.
                         </para>
                     </listitem>
                 </orderedlist>
             </para>
 
         </section>
 
         <section xml:id="envers-partitioning-columns">
 
             <title>Suitable columns for audit table partitioning</title>
             <para>
                 Generally SQL tables must be partitioned on a column that exists within the table. As a rule it makes sense to use
                 either the <emphasis>end revision</emphasis> or the <emphasis>end revision timestamp</emphasis> column for
                 partioning of audit tables.
                 <note>
                     <para>
                         End revision information is not available for the default AuditStrategy.
                     </para>
 
                     <para>
                         Therefore the following Envers configuration options are required:
                     </para>
                     <para>
                         <literal>org.hibernate.envers.audit_strategy</literal> =
                         <literal>org.hibernate.envers.strategy.ValidityAuditStrategy</literal>
                     </para>
                     <para>
                         <literal>org.hibernate.envers.audit_strategy_validity_store_revend_timestamp</literal> =
                         <literal>true</literal>
                     </para>
 
                     <para>
                         Optionally, you can also override the default values using following properties:
                     </para>
                     <para>
                         <literal>org.hibernate.envers.audit_strategy_validity_end_rev_field_name</literal>
                     </para>
                     <para>
                         <literal>org.hibernate.envers.audit_strategy_validity_revend_timestamp_field_name</literal>
                     </para>
 
                     <para>
                         For more information, see <xref linkend="envers-configuration"/>.
                     </para>
                 </note>
             </para>
 
             <para>
                 The reason why the end revision information should be used for audit table partioning is based on the assumption that
                 audit tables should be partionioned on an &apos;increasing level of interestingness&apos;, like so:
             </para>
 
             <para>
                 <orderedlist>
                     <listitem>
                         <para>
                             A couple of partitions with audit data that is not very (or no longer) interesting.
                             This can be stored on slow media, and perhaps even be purged eventually.
                         </para>
                     </listitem>
                     <listitem>
                         <para>
                             Some partitions for audit data that is potentially interesting.
                         </para>
                     </listitem>
                     <listitem>
                         <para>
                             One partition for audit data that is most likely to be interesting.
                             This should be stored on the fastest media, both for reading and writing.
                         </para>
                     </listitem>
                 </orderedlist>
             </para>
 
 
         </section>
 
         <section xml:id="envers-partitioning-example">
 
             <title>Audit table partitioning example</title>
             <para>
                 In order to determine a suitable column for the &apos;increasing level of interestingness&apos;,
                 consider a simplified example of a salary registration for an unnamed agency.
             </para>
 
             <para>
                 Currently, the salary table contains the following rows for a certain person X:
 
                 <table frame="topbot">
                     <title>Salaries table</title>
                     <tgroup cols="2">
                         <colspec colname="c1" colwidth="1*"/>
                         <colspec colname="c2" colwidth="1*"/>
                         <thead>
                             <row>
                                 <entry>Year</entry>
                                 <entry>Salary (USD)</entry>
                             </row>
                         </thead>
                         <tbody>
                             <row>
                                 <entry>2006</entry>
                                 <entry>3300</entry>
                             </row>
                             <row>
                                 <entry>2007</entry>
                                 <entry>3500</entry>
                             </row>
                             <row>
                                 <entry>2008</entry>
                                 <entry>4000</entry>
                             </row>
                             <row>
                                 <entry>2009</entry>
                                 <entry>4500</entry>
                             </row>
                         </tbody>
                     </tgroup>
                 </table>
             </para>
 
             <para>
                 The salary for the current fiscal year (2010) is unknown. The agency requires that all changes in registered
                 salaries for a fiscal year are recorded (i.e. an audit trail). The rationale behind this is that decisions
                 made at a certain date are based on the registered salary at that time. And at any time it must be possible
                 reproduce the reason why a certain decision was made at a certain date.
             </para>
 
             <para>
                 The following audit information is available, sorted on in order of occurrence:
 
                 <table frame="topbot">
                     <title>Salaries - audit table</title>
                     <tgroup cols="5">
                         <colspec colname="c1" colwidth="1*"/>
                         <colspec colname="c2" colwidth="1*"/>
                         <colspec colname="c3" colwidth="1*"/>
                         <colspec colname="c4" colwidth="1*"/>
                         <colspec colname="c5" colwidth="1*"/>
                         <thead>
                             <row>
                                 <entry>Year</entry>
                                 <entry>Revision type</entry>
                                 <entry>Revision timestamp</entry>
                                 <entry>Salary (USD)</entry>
                                 <entry>End revision timestamp</entry>
                             </row>
                         </thead>
                         <tbody>
                             <row>
                                 <entry>2006</entry>
                                 <entry>ADD</entry>
                                 <entry>2007-04-01</entry>
                                 <entry>3300</entry>
                                 <entry>null</entry>
                             </row>
                             <row>
                                 <entry>2007</entry>
                                 <entry>ADD</entry>
                                 <entry>2008-04-01</entry>
                                 <entry>35</entry>
                                 <entry>2008-04-02</entry>
                             </row>
                             <row>
                                 <entry>2007</entry>
                                 <entry>MOD</entry>
                                 <entry>2008-04-02</entry>
                                 <entry>3500</entry>
                                 <entry>null</entry>
                             </row>
                             <row>
                                 <entry>2008</entry>
                                 <entry>ADD</entry>
                                 <entry>2009-04-01</entry>
                                 <entry>3700</entry>
                                 <entry>2009-07-01</entry>
                             </row>
                             <row>
                                 <entry>2008</entry>
                                 <entry>MOD</entry>
                                 <entry>2009-07-01</entry>
                                 <entry>4100</entry>
                                 <entry>2010-02-01</entry>
                             </row>
                             <row>
                                 <entry>2008</entry>
                                 <entry>MOD</entry>
                                 <entry>2010-02-01</entry>
                                 <entry>4000</entry>
                                 <entry>null</entry>
                             </row>
                             <row >
                                 <entry>2009</entry>
                                 <entry>ADD</entry>
                                 <entry>2010-04-01</entry>
                                 <entry>4500</entry>
                                 <entry>null</entry>
                             </row>
                         </tbody>
                     </tgroup>
                 </table>
             </para>
 
             <section xml:id="envers-partitioning-example-column">
 
                 <title>Determining a suitable partitioning column</title>
                 <para>
                     To partition this data, the &apos;level of interestingness&apos; must be defined.
                     Consider the following:
                     <orderedlist>
                         <listitem>
                             <para>
                                 For fiscal year 2006 there is only one revision. It has the oldest <emphasis>revision timestamp</emphasis>
                                 of all audit rows, but should still be regarded as interesting because it is the latest modification
                                 for this fiscal year in the salary table; its <emphasis>end revision timestamp</emphasis> is null.
                             </para>
                             <para>
                                 Also note that it would be very unfortunate if in 2011 there would be an update of the salary for fiscal
                                 year 2006 (which is possible in until at least 10 years after the fiscal year) and the audit
                                 information would have been moved to a slow disk (based on the age of the
                                 <emphasis>revision timestamp</emphasis>). Remember that in this case Envers will have to update
                                 the <emphasis>end revision timestamp</emphasis> of the most recent audit row.
                             </para>
                         </listitem>
                         <listitem>
                             <para>
                                 There are two revisions in the salary of fiscal year 2007 which both have nearly the same
                                 <emphasis>revision timestamp</emphasis> and a different <emphasis>end revision timestamp</emphasis>.
                                 On first sight it is evident that the first revision was a mistake and probably uninteresting.
                                 The only interesting revision for 2007 is the one with <emphasis>end revision timestamp</emphasis> null.
                             </para>
                         </listitem>
                     </orderedlist>
 
                     Based on the above, it is evident that only the <emphasis>end revision timestamp</emphasis> is suitable for
                     audit table partitioning. The <emphasis>revision timestamp</emphasis> is not suitable.
                 </para>
 
             </section>
 
             <section xml:id="envers-partitioning-example-scheme">
 
                 <title>Determining a suitable partitioning scheme</title>
                 <para>
                     A possible partitioning scheme for the salary table would be as follows:
                     <orderedlist>
                         <listitem>
                             <para>
                                 <emphasis>end revision timestamp</emphasis> year = 2008
                             </para>
                             <para>
                                 This partition contains audit data that is not very (or no longer) interesting.
                             </para>
                         </listitem>
                         <listitem>
                             <para>
                                 <emphasis>end revision timestamp</emphasis> year = 2009
                             </para>
                             <para>
                                 This partition contains audit data that is potentially interesting.
                             </para>
                         </listitem>
                         <listitem>
                             <para>
                                 <emphasis>end revision timestamp</emphasis> year >= 2010 or null
                             </para>
                             <para>
                                 This partition contains the most interesting audit data.
                             </para>
                         </listitem>
                     </orderedlist>
                 </para>
 
                 <para>
                     This partitioning scheme also covers the potential problem of the update of the
                     <emphasis>end revision timestamp</emphasis>, which occurs if a row in the audited table is modified.
                     Even though Envers will update the <emphasis>end revision timestamp</emphasis> of the audit row to
                     the system date at the instant of modification, the audit row will remain in the same partition
                     (the &apos;extension bucket&apos;).
                 </para>
 
                 <para>
                     And sometime in 2011, the last partition (or &apos;extension bucket&apos;) is split into two new partitions:
                     <orderedlist>
                         <listitem>
                             <para>
                                 <emphasis>end revision timestamp</emphasis> year = 2010
                             </para>
                             <para>
                                 This partition contains audit data that is potentially interesting (in 2011).
                             </para>
                         </listitem>
                         <listitem>
                             <para>
                                 <emphasis>end revision timestamp</emphasis> year >= 2011 or null
                             </para>
                             <para>
                                 This partition contains the most interesting audit data and is the new &apos;extension bucket&apos;.
                             </para>
                         </listitem>
                     </orderedlist>
                 </para>
 
             </section>
 
         </section>
     </section>
 
     <section xml:id="envers-links">
         <title>Envers links</title>
 
         <orderedlist>
             <listitem>
                 <para>
                     <link xl:href="http://hibernate.org">Hibernate main page</link>
                 </para>
             </listitem>
             <listitem>
                 <para>
                     <link xl:href="http://community.jboss.org/en/envers?view=discussions">Forum</link>
                 </para>
             </listitem>
             <listitem>
                 <para>
                     <link xl:href="http://opensource.atlassian.com/projects/hibernate/browse/HHH">JIRA issue tracker</link>
                     (when adding issues concerning Envers, be sure to select the "envers" component!)
                 </para>
             </listitem>
             <listitem>
                 <para>
                     <link xl:href="irc://irc.freenode.net:6667/envers">IRC channel</link>
                 </para>
             </listitem>
             <listitem>
                 <para>
                     <link xl:href="http://www.jboss.org/feeds/view/envers">Envers Blog</link>
                 </para>
             </listitem>
             <listitem>
                 <para>
                     <link xl:href="https://community.jboss.org/wiki/EnversFAQ">FAQ</link>
                 </para>
             </listitem>
         </orderedlist>
 
     </section>
 
 </chapter>
\ No newline at end of file
diff --git a/documentation/src/main/docbook/devguide/en-US/chapters/osgi/extras/extension_point_blueprint.xml b/documentation/src/main/docbook/devguide/en-US/chapters/osgi/extras/extension_point_blueprint.xml
index a263100e5b..d9c56fc5d9 100644
--- a/documentation/src/main/docbook/devguide/en-US/chapters/osgi/extras/extension_point_blueprint.xml
+++ b/documentation/src/main/docbook/devguide/en-US/chapters/osgi/extras/extension_point_blueprint.xml
@@ -1,11 +1,11 @@
 <blueprint default-activation="eager"
 	xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 
-	<bean id="integrator" class="org.hibernate.envers.event.spi.EnversIntegrator" />
+	<bean id="integrator" class="org.hibernate.envers.boot.internal.EnversIntegrator" />
 	<service ref="integrator" interface="org.hibernate.integrator.spi.Integrator" />
 
 	<bean id="typeContributor"
-		class="org.hibernate.envers.internal.entities.TypeContributorImpl" />
+		class="org.hibernate.envers.boot.internal.TypeContributorImpl" />
 	<service ref="typeContributor" interface="org.hibernate.boot.model.TypeContributor" />
 
 </blueprint>
\ No newline at end of file
diff --git a/hibernate-core/hibernate-core.gradle b/hibernate-core/hibernate-core.gradle
index 08d254f49f..e485f20a70 100644
--- a/hibernate-core/hibernate-core.gradle
+++ b/hibernate-core/hibernate-core.gradle
@@ -1,162 +1,164 @@
 apply plugin: 'antlr'
 apply plugin: 'hibernate-matrix-testing'
 
 apply plugin: 'version-injection'
 
 versionInjection {
     into( 'org.hibernate.Version', 'getVersionString' )
 }
 
 dependencies {
     compile( libraries.jta )
     compile( libraries.dom4j )
     compile( libraries.commons_annotations )
     compile( libraries.jpa )
     compile( libraries.javassist )
     compile( libraries.antlr )
     compile( libraries.jandex )
 
+    compile( "org.codehaus.woodstox:woodstox-core-asl:4.3.0")
+
     antlr( libraries.antlr )
 
     provided( libraries.ant )
     provided( libraries.jacc )
     provided( libraries.validation )
     provided( libraries.classmate )
 
     testCompile( project(':hibernate-testing') )
     testCompile( libraries.validation )
     testCompile( libraries.jandex )
     testCompile( libraries.classmate )
     testCompile( libraries.mockito )
     testCompile( libraries.validator ) {
         // for test runtime
         transitive = true
     }
     // for testing stored procedure support
     testCompile( libraries.derby )
 
 
     testRuntime( 'jaxen:jaxen:1.1' )
     testRuntime( libraries.javassist )
     testRuntime( libraries.unified_el )
 }
 
 def pomName() {
     return 'Core Hibernate O/RM functionality'
 }
 
 def pomDescription() {
     return 'The core O/RM functionality as provided by Hibernate'
 }
 
 def osgiDescription() {
 	return pomDescription()
 }
 
 jar {
     manifest {
         mainAttributes( 'Main-Class': 'org.hibernate.Version' )
 
         instructionFirst 'Import-Package',
             'javax.security.auth;resolution:=optional',
             'javax.security.jacc;resolution:=optional',
             'javax.validation;resolution:=optional',
             'javax.validation.constraints;resolution:=optional',
             'javax.validation.groups;resolution:=optional',
             'javax.validation.metadata;resolution:=optional',
             // TODO: Shouldn't have to explicitly list this, but the plugin
             // generates it with a [1.0,2) version.
             'javax.persistence;version="2.1.0"',
             // Temporarily support JTA 1.1 -- Karaf and other frameworks still
             // use it.  Without this, the plugin generates [1.2,2).
             // build.gradle adds javax.transaction for all modules
             'javax.transaction.xa;version="[1.1,2)"',
             // optionals
             'javax.management;resolution:=optional',
             'javax.naming.event;resolution:=optional',
             'javax.naming.spi;resolution:=optional',
             'org.apache.tools.ant;resolution:=optional',
 			'org.apache.tools.ant.taskdefs;resolution:=optional',
 			'org.apache.tools.ant.types;resolution:=optional'
 
 //        // TODO: Uncomment once EntityManagerFactoryBuilderImpl no longer
 //        // uses ClassLoaderServiceImpl.
 //        instruction 'Export-Package',
 //            'org.hibernate.boot.registry.classloading.internal',
 //            '*'
     }
 }
 
 ext {
 	jaxbTargetDir = file( "${buildDir}/generated-src/jaxb/main" )
 }
 
 sourceSets.main {
     java.srcDir jaxbTargetDir
 }
 
 // resources inherently exclude sources
 sourceSets.test.resources {
     setSrcDirs( ['src/test/java','src/test/resources'] )
 }
 
 idea {
 	module {
 		sourceDirs += file( "${buildDir}/generated-src/antlr/main" )
 	}
 }
 
 task jaxb {
 	ext {
         // input schemas
         cfgXsd = file( 'src/main/resources/org/hibernate/xsd/cfg/legacy-configuration-4.0.xsd')
 		hbmXsd = file( 'src/main/resources/org/hibernate/xsd/mapping/legacy-mapping-4.0.xsd' )
         ormXsd = file( 'src/main/resources/org/hibernate/jpa/orm_2_0.xsd' )
 
         // input bindings
         cfgXjb = file( 'src/main/xjb/hbm-configuration-bindings.xjb' )
         hbmXjb = file( 'src/main/xjb/hbm-mapping-bindings.xjb' )
         ormXjb = file( 'src/main/xjb/orm-bindings.xjb' )
     }
 
     // configure Gradle up-to-date checking
     inputs.files( [cfgXsd, hbmXsd, ormXsd, cfgXjb, hbmXjb, ormXjb] )
     outputs.dir( jaxbTargetDir )
 
     // perform actions
     doLast {
         jaxbTargetDir.mkdirs()
 
         ant.taskdef(name: 'xjc', classname: 'org.jvnet.jaxb2_commons.xjc.XJC2Task', classpath: configurations.jaxb.asPath)
         ant.jaxbTargetDir = jaxbTargetDir
 
         // hibernate-configuration
         ant.xjc(
                 destdir: '${jaxbTargetDir}',
                 binding: 'src/main/xjb/hbm-configuration-bindings.xjb',
                 schema: cfgXsd.path
         )
 
 		// hibernate-mapping
 		ant.xjc(
 				destdir: '${jaxbTargetDir}',
 				binding: 'src/main/xjb/hbm-mapping-bindings.xjb',
 				schema: hbmXsd.path,
 				extension: 'true'
 		) {
 			arg line:     '-Xinheritance -Xsimplify'
 		}
 
 //        // orm.xml (jpa)
 //        ant.xjc(
 //                destdir: '${jaxbTargetDir}',
 //                package: 'org.hibernate.internal.jaxb.mapping.orm',
 //                binding: 'src/main/xjb/orm-bindings.xjb',
 //                schema: ormXsd.path
 //        )
     }
 
 }
 
 sourceSets.main.sourceGeneratorsTask.dependsOn jaxb
 sourceSets.main.sourceGeneratorsTask.dependsOn generateGrammarSource
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/internal/InFlightMetadataCollectorImpl.java b/hibernate-core/src/main/java/org/hibernate/boot/internal/InFlightMetadataCollectorImpl.java
index cb18e8902a..efd3483b82 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/internal/InFlightMetadataCollectorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/internal/InFlightMetadataCollectorImpl.java
@@ -663,1643 +663,1651 @@ public class InFlightMetadataCollectorImpl implements InFlightMetadataCollector
 
 	@Override
 	public Map<String, ResultSetMappingDefinition> getResultSetMappingDefinitions() {
 		return sqlResultSetMappingMap;
 	}
 
 	@Override
 	public ResultSetMappingDefinition getResultSetMapping(String name) {
 		return sqlResultSetMappingMap.get( name );
 	}
 
 	@Override
 	public void addResultSetMapping(ResultSetMappingDefinition resultSetMappingDefinition) {
 		if ( resultSetMappingDefinition == null ) {
 			throw new IllegalArgumentException( "Result-set mapping was null" );
 		}
 
 		final String name = resultSetMappingDefinition.getName();
 		if ( name == null ) {
 			throw new IllegalArgumentException( "Result-set mapping name is null: " + resultSetMappingDefinition );
 		}
 
 		if ( defaultSqlResultSetMappingNames.contains( name ) ) {
 			return;
 		}
 
 		applyResultSetMapping( resultSetMappingDefinition );
 	}
 
 	public void applyResultSetMapping(ResultSetMappingDefinition resultSetMappingDefinition) {
 		final ResultSetMappingDefinition old = sqlResultSetMappingMap.put(
 				resultSetMappingDefinition.getName(),
 				resultSetMappingDefinition
 		);
 		if ( old != null ) {
 			throw new DuplicateMappingException(
 					DuplicateMappingException.Type.RESULT_SET_MAPPING,
 					resultSetMappingDefinition.getName()
 			);
 		}
 	}
 
 	@Override
 	public void addDefaultResultSetMapping(ResultSetMappingDefinition definition) {
 		final String name = definition.getName();
 		if ( !defaultSqlResultSetMappingNames.contains( name ) && sqlResultSetMappingMap.containsKey( name ) ) {
 			sqlResultSetMappingMap.remove( name );
 		}
 		applyResultSetMapping( definition );
 		defaultSqlResultSetMappingNames.add( name );
 	}
 
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// imports
 
 	@Override
 	public Map<String,String> getImports() {
 		return imports;
 	}
 
 	@Override
 	public void addImport(String importName, String entityName) {
 		if ( importName == null || entityName == null ) {
 			throw new IllegalArgumentException( "Import name or entity name is null" );
 		}
 		log.tracev( "Import: {0} -> {1}", importName, entityName );
 		String old = imports.put( importName, entityName );
 		if ( old != null ) {
 			log.debug( "import name [" + importName + "] overrode previous [{" + old + "}]" );
 		}
 	}
 
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// Table handling
 
 	@Override
 	public Table addTable(
 			String schemaName,
 			String catalogName,
 			String name,
 			String subselectFragment,
 			boolean isAbstract) {
 		final Schema schema = getDatabase().locateSchema(
 				getDatabase().toIdentifier( catalogName ),
 				getDatabase().toIdentifier( schemaName )
 		);
 
 		// annotation binding depends on the "table name" for @Subselect bindings
 		// being set into the generated table (mainly to avoid later NPE), but for now we need to keep that :(
 		final Identifier logicalName;
 		if ( name != null ) {
 			logicalName = getDatabase().toIdentifier( name );
 		}
 		else {
 			logicalName = null;
 		}
 
 		if ( subselectFragment != null ) {
 			return new Table( schema, logicalName, subselectFragment, isAbstract );
 		}
 		else {
 			Table table = schema.locateTable( logicalName );
 			if ( table != null ) {
 				if ( !isAbstract ) {
 					table.setAbstract( false );
 				}
 				return table;
 			}
 			return schema.createTable( logicalName, isAbstract );
 		}
 	}
 
 	@Override
 	public Table addDenormalizedTable(
 			String schemaName,
 			String catalogName,
 			String name,
 			boolean isAbstract,
 			String subselectFragment,
 			Table includedTable) throws DuplicateMappingException {
 		final Schema schema = getDatabase().locateSchema(
 				getDatabase().toIdentifier( catalogName ),
 				getDatabase().toIdentifier( schemaName )
 		);
 
 		// annotation binding depends on the "table name" for @Subselect bindings
 		// being set into the generated table (mainly to avoid later NPE), but for now we need to keep that :(
 		final Identifier logicalName;
 		if ( name != null ) {
 			logicalName = getDatabase().toIdentifier( name );
 		}
 		else {
 			logicalName = null;
 		}
 
 		if ( subselectFragment != null ) {
 			return new DenormalizedTable( schema, logicalName, subselectFragment, isAbstract, includedTable );
 		}
 		else {
 			Table table = schema.locateTable( logicalName );
 			if ( table != null ) {
 				throw new DuplicateMappingException( DuplicateMappingException.Type.TABLE, logicalName.toString() );
 			}
 			else {
 				table = schema.createDenormalizedTable( logicalName, isAbstract, includedTable );
 			}
 			return table;
 		}
 	}
 
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// Mapping impl
 
 	@Override
 	public org.hibernate.type.Type getIdentifierType(String entityName) throws MappingException {
 		final PersistentClass pc = entityBindingMap.get( entityName );
 		if ( pc == null ) {
 			throw new MappingException( "persistent class not known: " + entityName );
 		}
 		return pc.getIdentifier().getType();
 	}
 
 	@Override
 	public String getIdentifierPropertyName(String entityName) throws MappingException {
 		final PersistentClass pc = entityBindingMap.get( entityName );
 		if ( pc == null ) {
 			throw new MappingException( "persistent class not known: " + entityName );
 		}
 		if ( !pc.hasIdentifierProperty() ) {
 			return null;
 		}
 		return pc.getIdentifierProperty().getName();
 	}
 
 	@Override
 	public org.hibernate.type.Type getReferencedPropertyType(String entityName, String propertyName) throws MappingException {
 		final PersistentClass pc = entityBindingMap.get( entityName );
 		if ( pc == null ) {
 			throw new MappingException( "persistent class not known: " + entityName );
 		}
 		Property prop = pc.getReferencedProperty( propertyName );
 		if ( prop == null ) {
 			throw new MappingException(
 					"property not known: " +
 							entityName + '.' + propertyName
 			);
 		}
 		return prop.getType();
 	}
 
 
 	private Map<Identifier,Identifier> logicalToPhysicalTableNameMap = new HashMap<Identifier, Identifier>();
 	private Map<Identifier,Identifier> physicalToLogicalTableNameMap = new HashMap<Identifier, Identifier>();
 
 	@Override
 	public void addTableNameBinding(Identifier logicalName, Table table) {
 		logicalToPhysicalTableNameMap.put( logicalName, table.getNameIdentifier() );
 		physicalToLogicalTableNameMap.put( table.getNameIdentifier(), logicalName );
 	}
 
 	@Override
 	public void addTableNameBinding(String schema, String catalog, String logicalName, String realTableName, Table denormalizedSuperTable) {
 		final Identifier logicalNameIdentifier = getDatabase().toIdentifier( logicalName );
 		final Identifier physicalNameIdentifier = getDatabase().toIdentifier( realTableName );
 
 		logicalToPhysicalTableNameMap.put( logicalNameIdentifier, physicalNameIdentifier );
 		physicalToLogicalTableNameMap.put( physicalNameIdentifier, logicalNameIdentifier );
 	}
 
 	@Override
 	public String getLogicalTableName(Table ownerTable) {
 		final Identifier logicalName = physicalToLogicalTableNameMap.get( ownerTable.getNameIdentifier() );
 		if ( logicalName == null ) {
 			throw new MappingException( "Unable to find physical table: " + ownerTable.getName() );
 		}
 		return logicalName.render();
 	}
 
 	@Override
 	public String getPhysicalTableName(Identifier logicalName) {
 		final Identifier physicalName = logicalToPhysicalTableNameMap.get( logicalName );
 		return physicalName == null ? null : physicalName.render();
 	}
 
 	@Override
 	public String getPhysicalTableName(String logicalName) {
 		return getPhysicalTableName( getDatabase().toIdentifier( logicalName ) );
 	}
 
 	/**
 	 * Internal struct used to maintain xref between physical and logical column
 	 * names for a table.  Mainly this is used to ensure that the defined NamingStrategy
 	 * is not creating duplicate column names.
 	 */
 	private class TableColumnNameBinding implements Serializable {
 		private final String tableName;
 		private Map<Identifier, String> logicalToPhysical = new HashMap<Identifier,String>();
 		private Map<String, Identifier> physicalToLogical = new HashMap<String,Identifier>();
 
 		private TableColumnNameBinding(String tableName) {
 			this.tableName = tableName;
 		}
 
 		public void addBinding(Identifier logicalName, Column physicalColumn) {
 			final String physicalNameString = physicalColumn.getQuotedName( getDatabase().getJdbcEnvironment().getDialect() );
 
 			bindLogicalToPhysical( logicalName, physicalNameString );
 			bindPhysicalToLogical( logicalName, physicalNameString );
 		}
 
 		private void bindLogicalToPhysical(Identifier logicalName, String physicalName) throws DuplicateMappingException {
 			final String existingPhysicalNameMapping = logicalToPhysical.put( logicalName, physicalName );
 			if ( existingPhysicalNameMapping != null ) {
 				final boolean areSame = logicalName.isQuoted()
 						? physicalName.equals( existingPhysicalNameMapping )
 						: physicalName.equalsIgnoreCase( existingPhysicalNameMapping );
 				if ( !areSame ) {
 					throw new DuplicateMappingException(
 							String.format(
 									Locale.ENGLISH,
 									"Table [%s] contains logical column name [%s] referring to multiple physical " +
 											"column names: [%s], [%s]",
 									tableName,
 									logicalName,
 									existingPhysicalNameMapping,
 									physicalName
 							),
 							DuplicateMappingException.Type.COLUMN_BINDING,
 							tableName + "." + logicalName
 					);
 				}
 			}
 		}
 
 		private void bindPhysicalToLogical(Identifier logicalName, String physicalName) throws DuplicateMappingException {
 			final Identifier existingLogicalName = physicalToLogical.put( physicalName, logicalName );
 			if ( existingLogicalName != null && ! existingLogicalName.equals( logicalName ) ) {
 				throw new DuplicateMappingException(
 						String.format(
 								Locale.ENGLISH,
 								"Table [%s] contains physical column name [%s] referred to by multiple physical " +
 										"column names: [%s], [%s]",
 								tableName,
 								physicalName,
 								logicalName,
 								existingLogicalName
 						),
 						DuplicateMappingException.Type.COLUMN_BINDING,
 						tableName + "." + physicalName
 				);
 			}
 		}
 	}
 
 	private Map<Table,TableColumnNameBinding> columnNameBindingByTableMap;
 
 	@Override
 	public void addColumnNameBinding(Table table, String logicalName, Column column) throws DuplicateMappingException {
 		addColumnNameBinding( table, getDatabase().toIdentifier( logicalName ), column );
 	}
 
 	@Override
 	public void addColumnNameBinding(Table table, Identifier logicalName, Column column) throws DuplicateMappingException {
 		TableColumnNameBinding binding = null;
 
 		if ( columnNameBindingByTableMap == null ) {
 			columnNameBindingByTableMap = new HashMap<Table, TableColumnNameBinding>();
 		}
 		else {
 			binding = columnNameBindingByTableMap.get( table );
 		}
 
 		if ( binding == null ) {
 			binding = new TableColumnNameBinding( table.getName() );
 			columnNameBindingByTableMap.put( table, binding );
 		}
 
 		binding.addBinding( logicalName, column );
 	}
 
 	@Override
 	public String getPhysicalColumnName(Table table, String logicalName) throws MappingException {
 		return getPhysicalColumnName( table, getDatabase().toIdentifier( logicalName ) );
 	}
 
 	@Override
 	public String getPhysicalColumnName(Table table, Identifier logicalName) throws MappingException {
 		if ( logicalName == null ) {
 			throw new MappingException( "Logical column name cannot be null" );
 		}
 
 		Table currentTable = table;
 		String physicalName = null;
 
 		while ( currentTable != null ) {
 			final TableColumnNameBinding binding = columnNameBindingByTableMap.get( currentTable );
 			if ( binding != null ) {
 				physicalName = binding.logicalToPhysical.get( logicalName );
 				if ( physicalName != null ) {
 					break;
 				}
 			}
 
 			if ( DenormalizedTable.class.isInstance( currentTable ) ) {
 				currentTable = ( (DenormalizedTable) currentTable ).getIncludedTable();
 			}
 			else {
 				currentTable = null;
 			}
 		}
 
 		if ( physicalName == null ) {
 			throw new MappingException(
 					"Unable to find column with logical name " + logicalName.render() + " in table " + table.getName()
 			);
 		}
 		return physicalName;
 	}
 
 	@Override
 	public String getLogicalColumnName(Table table, String physicalName) throws MappingException {
 		return getLogicalColumnName( table, getDatabase().toIdentifier( physicalName ) );
 	}
 
 
 	@Override
 	public String getLogicalColumnName(Table table, Identifier physicalName) throws MappingException {
 		final String physicalNameString = physicalName.render( getDatabase().getJdbcEnvironment().getDialect() );
 		Identifier logicalName = null;
 
 		Table currentTable = table;
 		while ( currentTable != null ) {
 			final TableColumnNameBinding binding = columnNameBindingByTableMap.get( currentTable );
 
 			if ( binding != null ) {
 				logicalName = binding.physicalToLogical.get( physicalNameString );
 				if ( logicalName != null ) {
 					break;
 				}
 			}
 
 			if ( DenormalizedTable.class.isInstance( currentTable ) ) {
 				currentTable = ( (DenormalizedTable) currentTable ).getIncludedTable();
 			}
 			else {
 				currentTable = null;
 			}
 		}
 
 		if ( logicalName == null ) {
 			throw new MappingException(
 					"Unable to find column with physical name " + physicalNameString + " in table " + table.getName()
 			);
 		}
 		return logicalName.render();
 	}
 
 	@Override
 	public void addAuxiliaryDatabaseObject(AuxiliaryDatabaseObject auxiliaryDatabaseObject) {
 		getDatabase().addAuxiliaryDatabaseObject( auxiliaryDatabaseObject );
 	}
 
 	private final Map<String,AnnotatedClassType> annotatedClassTypeMap = new HashMap<String, AnnotatedClassType>();
 
 	@Override
 	public AnnotatedClassType getClassType(XClass clazz) {
 		AnnotatedClassType type = annotatedClassTypeMap.get( clazz.getName() );
 		if ( type == null ) {
 			return addClassType( clazz );
 		}
 		else {
 			return type;
 		}
 	}
 
 	@Override
 	public AnnotatedClassType addClassType(XClass clazz) {
 		AnnotatedClassType type;
 		if ( clazz.isAnnotationPresent( Entity.class ) ) {
 			type = AnnotatedClassType.ENTITY;
 		}
 		else if ( clazz.isAnnotationPresent( Embeddable.class ) ) {
 			type = AnnotatedClassType.EMBEDDABLE;
 		}
 		else if ( clazz.isAnnotationPresent( javax.persistence.MappedSuperclass.class ) ) {
 			type = AnnotatedClassType.EMBEDDABLE_SUPERCLASS;
 		}
 		else {
 			type = AnnotatedClassType.NONE;
 		}
 		annotatedClassTypeMap.put( clazz.getName(), type );
 		return type;
 	}
 
 	@Override
 	public void addAnyMetaDef(AnyMetaDef defAnn) {
 		if ( anyMetaDefs == null ) {
 			anyMetaDefs = new HashMap<String, AnyMetaDef>();
 		}
 		else {
 			if ( anyMetaDefs.containsKey( defAnn.name() ) ) {
 				throw new AnnotationException( "Two @AnyMetaDef with the same name defined: " + defAnn.name() );
 			}
 		}
 
 		anyMetaDefs.put( defAnn.name(), defAnn );
 	}
 
 	@Override
 	public AnyMetaDef getAnyMetaDef(String name) {
 		if ( anyMetaDefs == null ) {
 			return null;
 		}
 		return anyMetaDefs.get( name );
 	}
 
 
 	@Override
 	public void addMappedSuperclass(Class type, MappedSuperclass mappedSuperclass) {
 		if ( mappedSuperClasses == null ) {
 			mappedSuperClasses = new HashMap<Class, MappedSuperclass>();
 		}
 		mappedSuperClasses.put( type, mappedSuperclass );
 	}
 
 	@Override
 	public MappedSuperclass getMappedSuperclass(Class type) {
 		if ( mappedSuperClasses == null ) {
 			return null;
 		}
 		return mappedSuperClasses.get( type );
 	}
 
 	@Override
 	public PropertyData getPropertyAnnotatedWithMapsId(XClass entityType, String propertyName) {
 		if ( propertiesAnnotatedWithMapsId == null ) {
 			return null;
 		}
 
 		final Map<String, PropertyData> map = propertiesAnnotatedWithMapsId.get( entityType );
 		return map == null ? null : map.get( propertyName );
 	}
 
 	@Override
 	public void addPropertyAnnotatedWithMapsId(XClass entityType, PropertyData property) {
 		if ( propertiesAnnotatedWithMapsId == null ) {
 			propertiesAnnotatedWithMapsId = new HashMap<XClass, Map<String, PropertyData>>();
 		}
 
 		Map<String, PropertyData> map = propertiesAnnotatedWithMapsId.get( entityType );
 		if ( map == null ) {
 			map = new HashMap<String, PropertyData>();
 			propertiesAnnotatedWithMapsId.put( entityType, map );
 		}
 		map.put( property.getProperty().getAnnotation( MapsId.class ).value(), property );
 	}
 
 	@Override
 	public void addPropertyAnnotatedWithMapsIdSpecj(XClass entityType, PropertyData property, String mapsIdValue) {
 		if ( propertiesAnnotatedWithMapsId == null ) {
 			propertiesAnnotatedWithMapsId = new HashMap<XClass, Map<String, PropertyData>>();
 		}
 
 		Map<String, PropertyData> map = propertiesAnnotatedWithMapsId.get( entityType );
 		if ( map == null ) {
 			map = new HashMap<String, PropertyData>();
 			propertiesAnnotatedWithMapsId.put( entityType, map );
 		}
 		map.put( mapsIdValue, property );
 	}
 
 	@Override
 	public PropertyData getPropertyAnnotatedWithIdAndToOne(XClass entityType, String propertyName) {
 		if ( propertiesAnnotatedWithIdAndToOne == null ) {
 			return null;
 		}
 
 		final Map<String, PropertyData> map = propertiesAnnotatedWithIdAndToOne.get( entityType );
 		return map == null ? null : map.get( propertyName );
 	}
 
 	@Override
 	public void addToOneAndIdProperty(XClass entityType, PropertyData property) {
 		if ( propertiesAnnotatedWithIdAndToOne == null ) {
 			propertiesAnnotatedWithIdAndToOne = new HashMap<XClass, Map<String, PropertyData>>();
 		}
 
 		Map<String, PropertyData> map = propertiesAnnotatedWithIdAndToOne.get( entityType );
 		if ( map == null ) {
 			map = new HashMap<String, PropertyData>();
 			propertiesAnnotatedWithIdAndToOne.put( entityType, map );
 		}
 		map.put( property.getPropertyName(), property );
 	}
 
 	@Override
 	public void addMappedBy(String entityName, String propertyName, String inversePropertyName) {
 		if ( mappedByResolver == null ) {
 			mappedByResolver = new HashMap<String, String>();
 		}
 		mappedByResolver.put( entityName + "." + propertyName, inversePropertyName );
 	}
 
 	@Override
 	public String getFromMappedBy(String entityName, String propertyName) {
 		if ( mappedByResolver == null ) {
 			return null;
 		}
 		return mappedByResolver.get( entityName + "." + propertyName );
 	}
 
 	@Override
 	public void addPropertyReferencedAssociation(String entityName, String propertyName, String propertyRef) {
 		if ( propertyRefResolver == null ) {
 			propertyRefResolver = new HashMap<String, String>();
 		}
 		propertyRefResolver.put( entityName + "." + propertyName, propertyRef );
 	}
 
 	@Override
 	public String getPropertyReferencedAssociation(String entityName, String propertyName) {
 		if ( propertyRefResolver == null ) {
 			return null;
 		}
 		return propertyRefResolver.get( entityName + "." + propertyName );
 	}
 
 	private static class DelayedPropertyReferenceHandlerAnnotationImpl implements DelayedPropertyReferenceHandler {
 		public final String referencedClass;
 		public final String propertyName;
 		public final boolean unique;
 
 		public DelayedPropertyReferenceHandlerAnnotationImpl(String referencedClass, String propertyName, boolean unique) {
 			this.referencedClass = referencedClass;
 			this.propertyName = propertyName;
 			this.unique = unique;
 		}
 
 		@Override
 		public void process(InFlightMetadataCollector metadataCollector) {
 			final PersistentClass clazz = metadataCollector.getEntityBinding( referencedClass );
 			if ( clazz == null ) {
 				throw new MappingException( "property-ref to unmapped class: " + referencedClass );
 			}
 
 			final Property prop = clazz.getReferencedProperty( propertyName );
 			if ( unique ) {
 				( (SimpleValue) prop.getValue() ).setAlternateUniqueKey( true );
 			}
 		}
 	}
 
 	@Override
 	public void addPropertyReference(String referencedClass, String propertyName) {
 		addDelayedPropertyReferenceHandler(
 				new DelayedPropertyReferenceHandlerAnnotationImpl( referencedClass, propertyName, false )
 		);
 	}
 
 	@Override
 	public void addDelayedPropertyReferenceHandler(DelayedPropertyReferenceHandler handler) {
 		if ( delayedPropertyReferenceHandlers == null ) {
 			delayedPropertyReferenceHandlers = new HashSet<DelayedPropertyReferenceHandler>();
 		}
 		delayedPropertyReferenceHandlers.add( handler );
 	}
 
 	@Override
 	public void addUniquePropertyReference(String referencedClass, String propertyName) {
 		addDelayedPropertyReferenceHandler(
 				new DelayedPropertyReferenceHandlerAnnotationImpl( referencedClass, propertyName, true )
 		);
 	}
 
 	@Override
 	@SuppressWarnings({ "unchecked" })
 	public void addUniqueConstraints(Table table, List uniqueConstraints) {
 		List<UniqueConstraintHolder> constraintHolders = new ArrayList<UniqueConstraintHolder>(
 				CollectionHelper.determineProperSizing( uniqueConstraints.size() )
 		);
 
 		int keyNameBase = determineCurrentNumberOfUniqueConstraintHolders( table );
 		for ( String[] columns : ( List<String[]> ) uniqueConstraints ) {
 			final String keyName = "key" + keyNameBase++;
 			constraintHolders.add(
 					new UniqueConstraintHolder().setName( keyName ).setColumns( columns )
 			);
 		}
 		addUniqueConstraintHolders( table, constraintHolders );
 	}
 
 	private int determineCurrentNumberOfUniqueConstraintHolders(Table table) {
 		List currentHolders = uniqueConstraintHoldersByTable == null ? null : uniqueConstraintHoldersByTable.get( table );
 		return currentHolders == null
 				? 0
 				: currentHolders.size();
 	}
 
 	@Override
 	public void addUniqueConstraintHolders(Table table, List<UniqueConstraintHolder> uniqueConstraintHolders) {
 		List<UniqueConstraintHolder> holderList = null;
 
 		if ( uniqueConstraintHoldersByTable == null ) {
 			uniqueConstraintHoldersByTable = new HashMap<Table, List<UniqueConstraintHolder>>();
 		}
 		else {
 			holderList = uniqueConstraintHoldersByTable.get( table );
 		}
 
 		if ( holderList == null ) {
 			holderList = new ArrayList<UniqueConstraintHolder>();
 			uniqueConstraintHoldersByTable.put( table, holderList );
 		}
 
 		holderList.addAll( uniqueConstraintHolders );
 	}
 
 	@Override
 	public void addJpaIndexHolders(Table table, List<JPAIndexHolder> holders) {
 		List<JPAIndexHolder> holderList = null;
 
 		if ( jpaIndexHoldersByTable == null ) {
 			jpaIndexHoldersByTable = new HashMap<Table, List<JPAIndexHolder>>();
 		}
 		else {
 			holderList = jpaIndexHoldersByTable.get( table );
 		}
 
 		if ( holderList == null ) {
 			holderList = new ArrayList<JPAIndexHolder>();
 			jpaIndexHoldersByTable.put( table, holderList );
 		}
 
 		holderList.addAll( holders );
 	}
 
 	private final Map<String,EntityTableXrefImpl> entityTableXrefMap = new HashMap<String, EntityTableXrefImpl>();
 
 	@Override
 	public EntityTableXref getEntityTableXref(String entityName) {
 		return entityTableXrefMap.get( entityName );
 	}
 
 	@Override
 	public EntityTableXref addEntityTableXref(
 			String entityName,
 			Identifier primaryTableLogicalName,
 			Table primaryTable,
 			EntityTableXref superEntityTableXref) {
 		final EntityTableXrefImpl entry = new EntityTableXrefImpl(
 				primaryTableLogicalName,
 				primaryTable,
 				(EntityTableXrefImpl) superEntityTableXref
 		);
 
 		entityTableXrefMap.put( entityName, entry );
 
 		return entry;
 	}
 
 	@Override
 	public Map<String, Join> getJoins(String entityName) {
 		EntityTableXrefImpl xrefEntry = entityTableXrefMap.get( entityName );
 		return xrefEntry == null ? null : xrefEntry.secondaryTableJoinMap;
 	}
 
 	@Override
 	public void addJoins(PersistentClass persistentClass, Map<String, Join> joins) {
 		// this part about resolving the super-EntityTableXref is a best effort.  But
 		// really annotation binding is the only thing calling this, and it does not
 		// directly use the EntityTableXref stuff, so its all good.
 		final EntityTableXrefImpl superEntityTableXref;
 		if ( persistentClass.getSuperclass() == null ) {
 			superEntityTableXref = null;
 		}
 		else {
 			superEntityTableXref = entityTableXrefMap.get( persistentClass.getSuperclass().getEntityName() );
 		}
 
 		final String primaryTableLogicalName = getLogicalTableName( persistentClass.getTable() );
 		final EntityTableXrefImpl xrefEntry = new EntityTableXrefImpl(
 				getDatabase().toIdentifier( primaryTableLogicalName ),
 				persistentClass.getTable(),
 				superEntityTableXref
 		);
 
 		final EntityTableXrefImpl old = entityTableXrefMap.put( persistentClass.getEntityName(), xrefEntry );
 		if ( old != null ) {
 			log.duplicateJoins( persistentClass.getEntityName() );
 		}
 
 		xrefEntry.secondaryTableJoinMap = joins;
 	}
 
 	private final class EntityTableXrefImpl implements EntityTableXref {
 		private final Identifier primaryTableLogicalName;
 		private final Table primaryTable;
 		private EntityTableXrefImpl superEntityTableXref;
 
 		//annotations needs a Map<String,Join>
 		//private Map<Identifier,Join> secondaryTableJoinMap;
 		private Map<String,Join> secondaryTableJoinMap;
 
 		public EntityTableXrefImpl(Identifier primaryTableLogicalName, Table primaryTable, EntityTableXrefImpl superEntityTableXref) {
 			this.primaryTableLogicalName = primaryTableLogicalName;
 			this.primaryTable = primaryTable;
 			this.superEntityTableXref = superEntityTableXref;
 		}
 
 		@Override
 		public void addSecondaryTable(LocalMetadataBuildingContext buildingContext, Identifier logicalName, Join secondaryTableJoin) {
 			if ( Identifier.areEqual( primaryTableLogicalName, logicalName ) ) {
 				throw new org.hibernate.boot.MappingException(
 						String.format(
 								Locale.ENGLISH,
 								"Attempt to add secondary table with same name as primary table [%s]",
 								primaryTableLogicalName
 						),
 						buildingContext.getOrigin()
 				);
 			}
 
 
 			if ( secondaryTableJoinMap == null ) {
 				//secondaryTableJoinMap = new HashMap<Identifier,Join>();
 				//secondaryTableJoinMap.put( logicalName, secondaryTableJoin );
 				secondaryTableJoinMap = new HashMap<String,Join>();
 				secondaryTableJoinMap.put( logicalName.getCanonicalName(), secondaryTableJoin );
 			}
 			else {
 				//final Join existing = secondaryTableJoinMap.put( logicalName, secondaryTableJoin );
 				final Join existing = secondaryTableJoinMap.put( logicalName.getCanonicalName(), secondaryTableJoin );
 
 				if ( existing != null ) {
 					throw new org.hibernate.boot.MappingException(
 							String.format(
 									Locale.ENGLISH,
 									"Added secondary table with same name [%s]",
 									logicalName
 							),
 							buildingContext.getOrigin()
 					);
 				}
 			}
 		}
 
 		@Override
 		public void addSecondaryTable(Identifier logicalName, Join secondaryTableJoin) {
 			if ( Identifier.areEqual( primaryTableLogicalName, logicalName ) ) {
 				throw new DuplicateSecondaryTableException( logicalName );
 			}
 
 
 			if ( secondaryTableJoinMap == null ) {
 				//secondaryTableJoinMap = new HashMap<Identifier,Join>();
 				//secondaryTableJoinMap.put( logicalName, secondaryTableJoin );
 				secondaryTableJoinMap = new HashMap<String,Join>();
 				secondaryTableJoinMap.put( logicalName.getCanonicalName(), secondaryTableJoin );
 			}
 			else {
 				//final Join existing = secondaryTableJoinMap.put( logicalName, secondaryTableJoin );
 				final Join existing = secondaryTableJoinMap.put( logicalName.getCanonicalName(), secondaryTableJoin );
 
 				if ( existing != null ) {
 					throw new DuplicateSecondaryTableException( logicalName );
 				}
 			}
 		}
 
 		@Override
 		public Table getPrimaryTable() {
 			return primaryTable;
 		}
 
 		@Override
 		public Table resolveTable(Identifier tableName) {
 			if ( tableName == null ) {
 				return primaryTable;
 			}
 
 			if ( Identifier.areEqual( primaryTableLogicalName, tableName ) ) {
 				return primaryTable;
 			}
 
 			Join secondaryTableJoin = null;
 			if ( secondaryTableJoinMap != null ) {
 				//secondaryTableJoin = secondaryTableJoinMap.get( tableName );
 				secondaryTableJoin = secondaryTableJoinMap.get( tableName.getCanonicalName() );
 			}
 
 			if ( secondaryTableJoin != null ) {
 				return secondaryTableJoin.getTable();
 			}
 
 			if ( superEntityTableXref != null ) {
 				return superEntityTableXref.resolveTable( tableName );
 			}
 
 			return null;
 		}
 
 		public Join locateJoin(Identifier tableName) {
 			if ( tableName == null ) {
 				return null;
 			}
 
 			Join join = null;
 			if ( secondaryTableJoinMap != null ) {
 				join = secondaryTableJoinMap.get( tableName.getCanonicalName() );
 			}
 
 			if ( join != null ) {
 				return join;
 			}
 
 			if ( superEntityTableXref != null ) {
 				return superEntityTableXref.locateJoin( tableName );
 			}
 
 			return null;
 		}
 	}
 
 	private ArrayList<PkDrivenByDefaultMapsIdSecondPass> pkDrivenByDefaultMapsId_secondPassList;
 	private ArrayList<SetSimpleValueTypeSecondPass> setSimpleValueType_secondPassList;
 	private ArrayList<CopyIdentifierComponentSecondPass> copyIdentifierComponent_secondPasList;
 	private ArrayList<FkSecondPass> fk_secondPassList;
 	private ArrayList<CreateKeySecondPass> createKey_secondPasList;
 	private ArrayList<SecondaryTableSecondPass> secondaryTable_secondPassList;
 	private ArrayList<QuerySecondPass> query_secondPassList;
 	private ArrayList<ConstraintSecondPass> constraint_secondPassList;
 	private ArrayList<ImplicitColumnNamingSecondPass> implicitColumnNaming_secondPassList;
 
 	private ArrayList<SecondPass> general_secondPassList;
 
 	@Override
 	public void addSecondPass(SecondPass secondPass) {
 		addSecondPass( secondPass, false );
 	}
 
 	@Override
 	public void addSecondPass(SecondPass secondPass, boolean onTopOfTheQueue) {
 		if ( secondPass instanceof PkDrivenByDefaultMapsIdSecondPass ) {
 			addPkDrivenByDefaultMapsIdSecondPass( (PkDrivenByDefaultMapsIdSecondPass) secondPass, onTopOfTheQueue );
 		}
 		else if ( secondPass instanceof SetSimpleValueTypeSecondPass ) {
 			addSetSimpleValueTypeSecondPass( (SetSimpleValueTypeSecondPass) secondPass, onTopOfTheQueue );
 		}
 		else if ( secondPass instanceof CopyIdentifierComponentSecondPass ) {
 			addCopyIdentifierComponentSecondPass( (CopyIdentifierComponentSecondPass) secondPass, onTopOfTheQueue );
 		}
 		else if ( secondPass instanceof FkSecondPass ) {
 			addFkSecondPass( (FkSecondPass) secondPass, onTopOfTheQueue );
 		}
 		else if ( secondPass instanceof CreateKeySecondPass ) {
 			addCreateKeySecondPass( (CreateKeySecondPass) secondPass, onTopOfTheQueue );
 		}
 		else if ( secondPass instanceof SecondaryTableSecondPass ) {
 			addSecondaryTableSecondPass( (SecondaryTableSecondPass) secondPass, onTopOfTheQueue );
 		}
 		else if ( secondPass instanceof QuerySecondPass ) {
 			addQuerySecondPass( (QuerySecondPass) secondPass, onTopOfTheQueue );
 		}
 		else if ( secondPass instanceof ConstraintSecondPass ) {
 			addConstraintSecondPass( ( ConstraintSecondPass) secondPass, onTopOfTheQueue );
 		}
 		else if ( secondPass instanceof ImplicitColumnNamingSecondPass ) {
 			addImplicitColumnNamingSecondPass( (ImplicitColumnNamingSecondPass) secondPass );
 		}
 		else {
 			// add to the general SecondPass list
 			if ( general_secondPassList == null ) {
 				general_secondPassList = new ArrayList<SecondPass>();
 			}
 			addSecondPass( secondPass, general_secondPassList, onTopOfTheQueue );
 		}
 	}
 
 	private void addPkDrivenByDefaultMapsIdSecondPass(
 			PkDrivenByDefaultMapsIdSecondPass secondPass,
 			boolean onTopOfTheQueue) {
 		if ( pkDrivenByDefaultMapsId_secondPassList == null ) {
 			pkDrivenByDefaultMapsId_secondPassList = new ArrayList<PkDrivenByDefaultMapsIdSecondPass>();
 		}
 		addSecondPass( secondPass, pkDrivenByDefaultMapsId_secondPassList, onTopOfTheQueue );
 	}
 
 	private <T extends SecondPass> void addSecondPass(T secondPass, ArrayList<T> secondPassList, boolean onTopOfTheQueue) {
 		if ( onTopOfTheQueue ) {
 			secondPassList.add( 0, secondPass );
 		}
 		else {
 			secondPassList.add( secondPass );
 		}
 	}
 
 	private void addSetSimpleValueTypeSecondPass(SetSimpleValueTypeSecondPass secondPass, boolean onTopOfTheQueue) {
 		if ( setSimpleValueType_secondPassList == null ) {
 			setSimpleValueType_secondPassList = new ArrayList<SetSimpleValueTypeSecondPass>();
 		}
 		addSecondPass( secondPass, setSimpleValueType_secondPassList, onTopOfTheQueue );
 	}
 
 	private void addCopyIdentifierComponentSecondPass(
 			CopyIdentifierComponentSecondPass secondPass,
 			boolean onTopOfTheQueue) {
 		if ( copyIdentifierComponent_secondPasList == null ) {
 			copyIdentifierComponent_secondPasList = new ArrayList<CopyIdentifierComponentSecondPass>();
 		}
 		addSecondPass( secondPass, copyIdentifierComponent_secondPasList, onTopOfTheQueue );
 	}
 
 	private void addFkSecondPass(FkSecondPass secondPass, boolean onTopOfTheQueue) {
 		if ( fk_secondPassList == null ) {
 			fk_secondPassList = new ArrayList<FkSecondPass>();
 		}
 		addSecondPass( secondPass, fk_secondPassList, onTopOfTheQueue );
 	}
 
 	private void addCreateKeySecondPass(CreateKeySecondPass secondPass, boolean onTopOfTheQueue) {
 		if ( createKey_secondPasList == null ) {
 			createKey_secondPasList = new ArrayList<CreateKeySecondPass>();
 		}
 		addSecondPass( secondPass, createKey_secondPasList, onTopOfTheQueue );
 	}
 
 	private void addSecondaryTableSecondPass(SecondaryTableSecondPass secondPass, boolean onTopOfTheQueue) {
 		if ( secondaryTable_secondPassList == null ) {
 			secondaryTable_secondPassList = new ArrayList<SecondaryTableSecondPass>();
 		}
 		addSecondPass( secondPass, secondaryTable_secondPassList, onTopOfTheQueue );
 	}
 
 	private void addQuerySecondPass(QuerySecondPass secondPass, boolean onTopOfTheQueue) {
 		if ( query_secondPassList == null ) {
 			query_secondPassList = new ArrayList<QuerySecondPass>();
 		}
 		addSecondPass( secondPass, query_secondPassList, onTopOfTheQueue );
 	}
 
 	private void addConstraintSecondPass(ConstraintSecondPass secondPass, boolean onTopOfTheQueue) {
 		if ( constraint_secondPassList == null ) {
 			constraint_secondPassList = new ArrayList<ConstraintSecondPass>();
 		}
 		addSecondPass( secondPass, constraint_secondPassList, onTopOfTheQueue );
 	}
 
 	private void addImplicitColumnNamingSecondPass(ImplicitColumnNamingSecondPass secondPass) {
 		if ( implicitColumnNaming_secondPassList == null ) {
 			implicitColumnNaming_secondPassList = new ArrayList<ImplicitColumnNamingSecondPass>();
 		}
 		implicitColumnNaming_secondPassList.add( secondPass );
 	}
 
 
 	private boolean inSecondPass = false;
 
-	private void processSecondPasses(MetadataBuildingContext buildingContext) {
+
+	/**
+	 * Ugh!  But we need this done before we ask Envers to produce its entities.
+	 */
+	public void processSecondPasses(MetadataBuildingContext buildingContext) {
 		inSecondPass = true;
 
 		try {
 			processSecondPasses( implicitColumnNaming_secondPassList );
 
 			processSecondPasses( pkDrivenByDefaultMapsId_secondPassList );
 			processSecondPasses( setSimpleValueType_secondPassList );
 			processSecondPasses( copyIdentifierComponent_secondPasList );
 
 			processFkSecondPassesInOrder();
 
 			processSecondPasses( createKey_secondPasList );
 			processSecondPasses( secondaryTable_secondPassList );
 
 			processSecondPasses( query_secondPassList );
 			processSecondPasses( general_secondPassList );
 
 			processPropertyReferences();
 
 			secondPassCompileForeignKeys( buildingContext );
 
 			processSecondPasses( constraint_secondPassList );
 			processUniqueConstraintHolders( buildingContext );
 			processJPAIndexHolders( buildingContext );
 
 			processNaturalIdUniqueKeyBinders();
 
 			processCachingOverrides();
 		}
 		finally {
 			inSecondPass = false;
 		}
 	}
 
 	private void processSecondPasses(ArrayList<? extends SecondPass> secondPasses) {
 		if ( secondPasses == null ) {
 			return;
 		}
 
 		for ( SecondPass secondPass : secondPasses ) {
 			secondPass.doSecondPass( getEntityBindingMap() );
 		}
 
 		secondPasses.clear();
 	}
 
 	private void processFkSecondPassesInOrder() {
 		if ( fk_secondPassList == null || fk_secondPassList.isEmpty() ) {
 			return;
 		}
 
 		// split FkSecondPass instances into primary key and non primary key FKs.
 		// While doing so build a map of class names to FkSecondPass instances depending on this class.
 		Map<String, Set<FkSecondPass>> isADependencyOf = new HashMap<String, Set<FkSecondPass>>();
 		List<FkSecondPass> endOfQueueFkSecondPasses = new ArrayList<FkSecondPass>( fk_secondPassList.size() );
 		for ( FkSecondPass sp : fk_secondPassList ) {
 			if ( sp.isInPrimaryKey() ) {
 				final String referenceEntityName = sp.getReferencedEntityName();
 				final PersistentClass classMapping = getEntityBinding( referenceEntityName );
 				final String dependentTable = classMapping.getTable().getQualifiedTableName().render();
 				if ( !isADependencyOf.containsKey( dependentTable ) ) {
 					isADependencyOf.put( dependentTable, new HashSet<FkSecondPass>() );
 				}
 				isADependencyOf.get( dependentTable ).add( sp );
 			}
 			else {
 				endOfQueueFkSecondPasses.add( sp );
 			}
 		}
 
 		// using the isADependencyOf map we order the FkSecondPass recursively instances into the right order for processing
 		List<FkSecondPass> orderedFkSecondPasses = new ArrayList<FkSecondPass>( fk_secondPassList.size() );
 		for ( String tableName : isADependencyOf.keySet() ) {
 			buildRecursiveOrderedFkSecondPasses( orderedFkSecondPasses, isADependencyOf, tableName, tableName );
 		}
 
 		// process the ordered FkSecondPasses
 		for ( FkSecondPass sp : orderedFkSecondPasses ) {
 			sp.doSecondPass( getEntityBindingMap() );
 		}
 
 		processEndOfQueue( endOfQueueFkSecondPasses );
 
 		fk_secondPassList.clear();
 	}
 
 	/**
 	 * Recursively builds a list of FkSecondPass instances ready to be processed in this order.
 	 * Checking all dependencies recursively seems quite expensive, but the original code just relied
 	 * on some sort of table name sorting which failed in certain circumstances.
 	 * <p/>
 	 * See <tt>ANN-722</tt> and <tt>ANN-730</tt>
 	 *
 	 * @param orderedFkSecondPasses The list containing the <code>FkSecondPass<code> instances ready
 	 * for processing.
 	 * @param isADependencyOf Our lookup data structure to determine dependencies between tables
 	 * @param startTable Table name to start recursive algorithm.
 	 * @param currentTable The current table name used to check for 'new' dependencies.
 	 */
 	private void buildRecursiveOrderedFkSecondPasses(
 			List<FkSecondPass> orderedFkSecondPasses,
 			Map<String, Set<FkSecondPass>> isADependencyOf,
 			String startTable,
 			String currentTable) {
 
 		Set<FkSecondPass> dependencies = isADependencyOf.get( currentTable );
 
 		// bottom out
 		if ( dependencies == null || dependencies.size() == 0 ) {
 			return;
 		}
 
 		for ( FkSecondPass sp : dependencies ) {
 			String dependentTable = sp.getValue().getTable().getQualifiedTableName().render();
 			if ( dependentTable.compareTo( startTable ) == 0 ) {
 				String sb = "Foreign key circularity dependency involving the following tables: ";
 				throw new AnnotationException( sb );
 			}
 			buildRecursiveOrderedFkSecondPasses( orderedFkSecondPasses, isADependencyOf, startTable, dependentTable );
 			if ( !orderedFkSecondPasses.contains( sp ) ) {
 				orderedFkSecondPasses.add( 0, sp );
 			}
 		}
 	}
 
 	private void processEndOfQueue(List<FkSecondPass> endOfQueueFkSecondPasses) {
 		/*
 		 * If a second pass raises a recoverableException, queue it for next round
 		 * stop of no pass has to be processed or if the number of pass to processes
 		 * does not diminish between two rounds.
 		 * If some failing pass remain, raise the original exception
 		 */
 		boolean stopProcess = false;
 		RuntimeException originalException = null;
 		while ( !stopProcess ) {
 			List<FkSecondPass> failingSecondPasses = new ArrayList<FkSecondPass>();
 			for ( FkSecondPass pass : endOfQueueFkSecondPasses ) {
 				try {
 					pass.doSecondPass( getEntityBindingMap() );
 				}
 				catch (RecoverableException e) {
 					failingSecondPasses.add( pass );
 					if ( originalException == null ) {
 						originalException = (RuntimeException) e.getCause();
 					}
 				}
 			}
 			stopProcess = failingSecondPasses.size() == 0 || failingSecondPasses.size() == endOfQueueFkSecondPasses.size();
 			endOfQueueFkSecondPasses = failingSecondPasses;
 		}
 		if ( endOfQueueFkSecondPasses.size() > 0 ) {
 			throw originalException;
 		}
 	}
 
 	private void secondPassCompileForeignKeys(MetadataBuildingContext buildingContext) {
 		int uniqueInteger = 0;
 		Set<ForeignKey> done = new HashSet<ForeignKey>();
 		for ( Table table : collectTableMappings() ) {
 			table.setUniqueInteger( uniqueInteger++ );
 			secondPassCompileForeignKeys( table, done, buildingContext );
 		}
 	}
 
 	protected void secondPassCompileForeignKeys(
 			final Table table,
 			Set<ForeignKey> done,
 			final MetadataBuildingContext buildingContext) throws MappingException {
 		table.createForeignKeys();
 
 		Iterator itr = table.getForeignKeyIterator();
 		while ( itr.hasNext() ) {
 			final ForeignKey fk = (ForeignKey) itr.next();
 			if ( !done.contains( fk ) ) {
 				done.add( fk );
 				final String referencedEntityName = fk.getReferencedEntityName();
 				if ( referencedEntityName == null ) {
 					throw new MappingException(
 							"An association from the table " +
 									fk.getTable().getName() +
 									" does not specify the referenced entity"
 					);
 				}
 
 				log.debugf( "Resolving reference to class: %s", referencedEntityName );
 				final PersistentClass referencedClass = getEntityBinding( referencedEntityName );
 				if ( referencedClass == null ) {
 					throw new MappingException(
 							"An association from the table " +
 									fk.getTable().getName() +
 									" refers to an unmapped class: " +
 									referencedEntityName
 					);
 				}
 				if ( referencedClass.isJoinedSubclass() ) {
 					secondPassCompileForeignKeys( referencedClass.getSuperclass().getTable(), done, buildingContext );
 				}
 
 				fk.setReferencedTable( referencedClass.getTable() );
 
 				// todo : should we apply a physical naming too?
 				if ( fk.getName() == null ) {
 					final Identifier nameIdentifier = getMetadataBuildingOptions().getImplicitNamingStrategy().determineForeignKeyName(
 							new ImplicitForeignKeyNameSource() {
 								final List<Identifier> columnNames = extractColumnNames( fk.getColumns() );
 								List<Identifier> referencedColumnNames = null;
 
 								@Override
 								public Identifier getTableName() {
 									return table.getNameIdentifier();
 								}
 
 								@Override
 								public List<Identifier> getColumnNames() {
 									return columnNames;
 								}
 
 								@Override
 								public Identifier getReferencedTableName() {
 									return fk.getReferencedTable().getNameIdentifier();
 								}
 
 								@Override
 								public List<Identifier> getReferencedColumnNames() {
 									if ( referencedColumnNames == null ) {
 										referencedColumnNames = extractColumnNames( fk.getReferencedColumns() );
 									}
 									return referencedColumnNames;
 								}
 
 								@Override
 								public MetadataBuildingContext getBuildingContext() {
 									return buildingContext;
 								}
 							}
 					);
 
 					fk.setName( nameIdentifier.render( getDatabase().getJdbcEnvironment().getDialect() ) );
 				}
 
 				fk.alignColumns();
 			}
 		}
 	}
 
 	private List<Identifier> toIdentifiers(List<String> names) {
 		if ( names == null || names.isEmpty() ) {
 			return Collections.emptyList();
 		}
 
 		final List<Identifier> columnNames = CollectionHelper.arrayList( names.size() );
 		for ( String name : names ) {
 			columnNames.add( getDatabase().toIdentifier( name ) );
 		}
 		return columnNames;
 	}
 
 	private List<Identifier> toIdentifiers(String[] names) {
 		if ( names == null ) {
 			return Collections.emptyList();
 		}
 
 		final List<Identifier> columnNames = CollectionHelper.arrayList( names.length );
 		for ( String name : names ) {
 			columnNames.add( getDatabase().toIdentifier( name ) );
 		}
 		return columnNames;
 	}
 
 	@SuppressWarnings("unchecked")
 	private List<Identifier> extractColumnNames(List columns) {
 		if ( columns == null || columns.isEmpty() ) {
 			return Collections.emptyList();
 		}
 
 		final List<Identifier> columnNames = CollectionHelper.arrayList( columns.size() );
 		for ( Column column : (List<Column>) columns ) {
 			columnNames.add( getDatabase().toIdentifier( column.getQuotedName() ) );
 		}
 		return columnNames;
 
 	}
 
 	private void processPropertyReferences() {
 		if ( delayedPropertyReferenceHandlers == null ) {
 			return;
 		}
 		log.debug( "Processing association property references" );
 
 		for ( DelayedPropertyReferenceHandler delayedPropertyReferenceHandler : delayedPropertyReferenceHandlers ) {
 			delayedPropertyReferenceHandler.process( this );
 		}
 
 		delayedPropertyReferenceHandlers.clear();
 	}
 
 	private void processUniqueConstraintHolders(MetadataBuildingContext buildingContext) {
 		if ( uniqueConstraintHoldersByTable == null ) {
 			return;
 		}
 
 		for ( Map.Entry<Table, List<UniqueConstraintHolder>> tableListEntry : uniqueConstraintHoldersByTable.entrySet() ) {
 			final Table table = tableListEntry.getKey();
 			final List<UniqueConstraintHolder> uniqueConstraints = tableListEntry.getValue();
 			for ( UniqueConstraintHolder holder : uniqueConstraints ) {
 				buildUniqueKeyFromColumnNames( table, holder.getName(), holder.getColumns(), buildingContext );
 			}
 		}
+
+		uniqueConstraintHoldersByTable.clear();
 	}
 
 	private void buildUniqueKeyFromColumnNames(
 			Table table,
 			String keyName,
 			String[] columnNames,
 			MetadataBuildingContext buildingContext) {
 		buildUniqueKeyFromColumnNames( table, keyName, columnNames, null, true, buildingContext );
 	}
 
 	private void buildUniqueKeyFromColumnNames(
 			final Table table,
 			String keyName,
 			final String[] columnNames,
 			String[] orderings,
 			boolean unique,
 			final MetadataBuildingContext buildingContext) {
 		int size = columnNames.length;
 		Column[] columns = new Column[size];
 		Set<Column> unbound = new HashSet<Column>();
 		Set<Column> unboundNoLogical = new HashSet<Column>();
 		for ( int index = 0; index < size; index++ ) {
 			final String logicalColumnName = columnNames[index];
 			try {
 				final String physicalColumnName = getPhysicalColumnName( table, logicalColumnName );
 				columns[index] = new Column( physicalColumnName );
 				unbound.add( columns[index] );
 				//column equals and hashcode is based on column name
 			}
 			catch ( MappingException e ) {
 				// If at least 1 columnName does exist, 'columns' will contain a mix of Columns and nulls.  In order
 				// to exhaustively report all of the unbound columns at once, w/o an NPE in
 				// Constraint#generateName's array sorting, simply create a fake Column.
 				columns[index] = new Column( logicalColumnName );
 				unboundNoLogical.add( columns[index] );
 			}
 		}
 
 		if ( unique ) {
 			if ( StringHelper.isEmpty( keyName ) ) {
 				final Identifier keyNameIdentifier = getMetadataBuildingOptions().getImplicitNamingStrategy().determineUniqueKeyName(
 						new ImplicitUniqueKeyNameSource() {
 							@Override
 							public MetadataBuildingContext getBuildingContext() {
 								return buildingContext;
 							}
 
 							@Override
 							public Identifier getTableName() {
 								return table.getNameIdentifier();
 							}
 
 							private List<Identifier> columnNameIdentifiers;
 
 							@Override
 							public List<Identifier> getColumnNames() {
 								// be lazy about building these
 								if ( columnNameIdentifiers == null ) {
 									columnNameIdentifiers = toIdentifiers( columnNames );
 								}
 								return columnNameIdentifiers;
 							}
 						}
 				);
 				keyName = keyNameIdentifier.render( getDatabase().getJdbcEnvironment().getDialect() );
 			}
 
 			UniqueKey uk = table.getOrCreateUniqueKey( keyName );
 			for ( int i = 0; i < columns.length; i++ ) {
 				Column column = columns[i];
 				String order = orderings != null ? orderings[i] : null;
 				if ( table.containsColumn( column ) ) {
 					uk.addColumn( column, order );
 					unbound.remove( column );
 				}
 			}
 		}
 		else {
 			if ( StringHelper.isEmpty( keyName ) ) {
 				final Identifier keyNameIdentifier = getMetadataBuildingOptions().getImplicitNamingStrategy().determineIndexName(
 						new ImplicitIndexNameSource() {
 							@Override
 							public MetadataBuildingContext getBuildingContext() {
 								return buildingContext;
 							}
 
 							@Override
 							public Identifier getTableName() {
 								return table.getNameIdentifier();
 							}
 
 							private List<Identifier> columnNameIdentifiers;
 
 							@Override
 							public List<Identifier> getColumnNames() {
 								// be lazy about building these
 								if ( columnNameIdentifiers == null ) {
 									columnNameIdentifiers = toIdentifiers( columnNames );
 								}
 								return columnNameIdentifiers;
 							}
 						}
 				);
 				keyName = keyNameIdentifier.render( getDatabase().getJdbcEnvironment().getDialect() );
 			}
 
 			Index index = table.getOrCreateIndex( keyName );
 			for ( int i = 0; i < columns.length; i++ ) {
 				Column column = columns[i];
 				String order = orderings != null ? orderings[i] : null;
 				if ( table.containsColumn( column ) ) {
 					index.addColumn( column, order );
 					unbound.remove( column );
 				}
 			}
 		}
 
 		if ( unbound.size() > 0 || unboundNoLogical.size() > 0 ) {
 			StringBuilder sb = new StringBuilder( "Unable to create unique key constraint (" );
 			for ( String columnName : columnNames ) {
 				sb.append( columnName ).append( ", " );
 			}
 			sb.setLength( sb.length() - 2 );
 			sb.append( ") on table " ).append( table.getName() ).append( ": database column " );
 			for ( Column column : unbound ) {
 				sb.append("'").append( column.getName() ).append( "', " );
 			}
 			for ( Column column : unboundNoLogical ) {
 				sb.append("'").append( column.getName() ).append( "', " );
 			}
 			sb.setLength( sb.length() - 2 );
 			sb.append( " not found. Make sure that you use the correct column name which depends on the naming strategy in use (it may not be the same as the property name in the entity, especially for relational types)" );
 			throw new AnnotationException( sb.toString() );
 		}
 	}
 
 	private void processJPAIndexHolders(MetadataBuildingContext buildingContext) {
 		if ( jpaIndexHoldersByTable == null ) {
 			return;
 		}
 
 		for ( Table table : jpaIndexHoldersByTable.keySet() ) {
 			final List<JPAIndexHolder> jpaIndexHolders = jpaIndexHoldersByTable.get( table );
 			for ( JPAIndexHolder holder : jpaIndexHolders ) {
 				buildUniqueKeyFromColumnNames(
 						table,
 						holder.getName(),
 						holder.getColumns(),
 						holder.getOrdering(),
 						holder.isUnique(),
 						buildingContext
 				);
 			}
 		}
 	}
 
 	private Map<String,NaturalIdUniqueKeyBinder> naturalIdUniqueKeyBinderMap;
 
 	@Override
 	public NaturalIdUniqueKeyBinder locateNaturalIdUniqueKeyBinder(String entityName) {
 		if ( naturalIdUniqueKeyBinderMap == null ) {
 			return null;
 		}
 		return naturalIdUniqueKeyBinderMap.get( entityName );
 	}
 
 	@Override
 	public void registerNaturalIdUniqueKeyBinder(String entityName, NaturalIdUniqueKeyBinder ukBinder) {
 		if ( naturalIdUniqueKeyBinderMap == null ) {
 			naturalIdUniqueKeyBinderMap = new HashMap<String, NaturalIdUniqueKeyBinder>();
 		}
 		final NaturalIdUniqueKeyBinder previous = naturalIdUniqueKeyBinderMap.put( entityName, ukBinder );
 		if ( previous != null ) {
 			throw new AssertionFailure( "Previous NaturalIdUniqueKeyBinder already registered for entity name : " + entityName );
 		}
 	}
 
 	private void processNaturalIdUniqueKeyBinders() {
 		if ( naturalIdUniqueKeyBinderMap == null ) {
 			return;
 		}
 
 		for ( NaturalIdUniqueKeyBinder naturalIdUniqueKeyBinder : naturalIdUniqueKeyBinderMap.values() ) {
 			naturalIdUniqueKeyBinder.process();
 		}
+
+		naturalIdUniqueKeyBinderMap.clear();
 	}
 
 	private void processCachingOverrides() {
 		if ( options.getCacheRegionDefinitions() == null ) {
 			return;
 		}
 
 		for ( CacheRegionDefinition cacheRegionDefinition : options.getCacheRegionDefinitions() ) {
 			if ( cacheRegionDefinition.getRegionType() == CacheRegionDefinition.CacheRegionType.ENTITY ) {
 				final PersistentClass entityBinding = getEntityBinding( cacheRegionDefinition.getRole() );
 				if ( entityBinding == null ) {
 					throw new HibernateException(
 							"Cache override referenced an unknown entity : " + cacheRegionDefinition.getRole()
 					);
 				}
 				if ( !RootClass.class.isInstance( entityBinding ) ) {
 					throw new HibernateException(
 							"Cache override referenced a non-root entity : " + cacheRegionDefinition.getRole()
 					);
 				}
 				( (RootClass) entityBinding ).setCacheRegionName( cacheRegionDefinition.getRegion() );
 				( (RootClass) entityBinding ).setCacheConcurrencyStrategy( cacheRegionDefinition.getUsage() );
 				( (RootClass) entityBinding ).setLazyPropertiesCacheable( cacheRegionDefinition.isCacheLazy() );
 			}
 			else if ( cacheRegionDefinition.getRegionType() == CacheRegionDefinition.CacheRegionType.COLLECTION ) {
 				final Collection collectionBinding = getCollectionBinding( cacheRegionDefinition.getRole() );
 				if ( collectionBinding == null ) {
 					throw new HibernateException(
 							"Cache override referenced an unknown collection role : " + cacheRegionDefinition.getRole()
 					);
 				}
 				collectionBinding.setCacheRegionName( cacheRegionDefinition.getRegion() );
 				collectionBinding.setCacheConcurrencyStrategy( cacheRegionDefinition.getUsage() );
 			}
 		}
 	}
 
 	@Override
 	public boolean isInSecondPass() {
 		return inSecondPass;
 	}
 
 	/**
 	 * Builds the complete and immutable Metadata instance from the collected info.
 	 *
 	 * @return The complete and immutable Metadata instance
 	 */
 	public MetadataImpl buildMetadataInstance(MetadataBuildingContext buildingContext) {
 		processSecondPasses( buildingContext );
 		processExportableProducers( buildingContext );
 
 		return new MetadataImpl(
 				uuid,
 				options,
 				typeResolver,
 				identifierGeneratorFactory,
 				entityBindingMap,
 				mappedSuperClasses,
 				collectionBindingMap,
 				typeDefinitionMap,
 				filterDefinitionMap,
 				fetchProfileMap,
 				imports,
 				idGeneratorDefinitionMap,
 				namedQueryMap,
 				namedNativeQueryMap,
 				namedProcedureCallMap,
 				sqlResultSetMappingMap,
 				namedEntityGraphMap,
 				sqlFunctionMap,
 				getDatabase()
 		);
 	}
 
 	private void processExportableProducers(MetadataBuildingContext buildingContext) {
 		// for now we only handle id generators as ExportableProducers
 
 		final Dialect dialect = getDatabase().getJdbcEnvironment().getDialect();
 		final String defaultCatalog = extractName( getDatabase().getDefaultSchema().getName().getCatalog(), dialect );
 		final String defaultSchema = extractName( getDatabase().getDefaultSchema().getName().getSchema(), dialect );
 
 		for ( PersistentClass entityBinding : entityBindingMap.values() ) {
 			if ( entityBinding.isInherited() ) {
 				continue;
 			}
 
 			handleIdentifierValueBinding(
 					entityBinding.getIdentifier(),
 					dialect,
 					defaultCatalog,
 					defaultSchema,
 					(RootClass) entityBinding
 			);
 		}
 
 		for ( Collection collection : collectionBindingMap.values() ) {
 			if ( !IdentifierCollection.class.isInstance( collection ) ) {
 				continue;
 			}
 
 			handleIdentifierValueBinding(
 					( (IdentifierCollection) collection ).getIdentifier(),
 					dialect,
 					defaultCatalog,
 					defaultSchema,
 					null
 			);
 		}
 	}
 
 	private void handleIdentifierValueBinding(
 			KeyValue identifierValueBinding,
 			Dialect dialect,
 			String defaultCatalog,
 			String defaultSchema,
 			RootClass entityBinding) {
 		// todo : store this result (back into the entity or into the KeyValue, maybe?)
 		// 		This process of instantiating the id-generator is called multiple times.
 		//		It was done this way in the old code too, so no "regression" here; but
 		//		it could be done better
 		try {
 			final IdentifierGenerator ig = identifierValueBinding.createIdentifierGenerator(
 					getIdentifierGeneratorFactory(),
 					dialect,
 					defaultCatalog,
 					defaultSchema,
 					entityBinding
 			);
 
 			if ( ig instanceof ExportableProducer ) {
 				( (ExportableProducer) ig ).registerExportables( getDatabase() );
 			}
 		}
 		catch (MappingException e) {
 			// ignore this for now.  The reasoning being "non-reflective" binding as needed
 			// by tools.  We want to hold off requiring classes being present until we
 			// try to build a SF.  Here, just building the Metadata, it is "ok" for an
 			// exception to occur, the same exception will happen later as we build the SF.
 			log.debugf( "Ignoring exception thrown when trying to build IdentifierGenerator as part of Metadata building", e );
 		}
 	}
 
 	private String extractName(Identifier identifier, Dialect dialect) {
 		if ( identifier == null ) {
 			return null;
 		}
 		return identifier.render( dialect );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuilderImpl.java b/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuilderImpl.java
index 9afbac5ffe..fdee0b3958 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuilderImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuilderImpl.java
@@ -1,771 +1,776 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2014, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.boot.internal;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 import javax.persistence.SharedCacheMode;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MultiTenancyStrategy;
 import org.hibernate.annotations.CacheConcurrencyStrategy;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.annotations.common.reflection.java.JavaReflectionManager;
 import org.hibernate.boot.CacheRegionDefinition;
 import org.hibernate.boot.MetadataBuilder;
 import org.hibernate.boot.MetadataSources;
 import org.hibernate.boot.archive.scan.internal.StandardScanOptions;
 import org.hibernate.boot.archive.scan.spi.ScanEnvironment;
 import org.hibernate.boot.archive.scan.spi.ScanOptions;
 import org.hibernate.boot.archive.scan.spi.Scanner;
 import org.hibernate.boot.archive.spi.ArchiveDescriptorFactory;
 import org.hibernate.boot.cfgxml.spi.CfgXmlAccessService;
 import org.hibernate.boot.cfgxml.spi.LoadedConfig;
 import org.hibernate.boot.cfgxml.spi.MappingReference;
 import org.hibernate.boot.model.TypeContributions;
 import org.hibernate.boot.model.TypeContributor;
 import org.hibernate.boot.model.naming.ImplicitNamingStrategy;
 import org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl;
 import org.hibernate.boot.model.naming.PhysicalNamingStrategy;
 import org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl;
 import org.hibernate.boot.registry.BootstrapServiceRegistry;
 import org.hibernate.boot.registry.StandardServiceRegistry;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.selector.spi.StrategySelector;
 import org.hibernate.boot.spi.MappingDefaults;
+import org.hibernate.boot.spi.MetadataBuilderContributor;
 import org.hibernate.boot.spi.MetadataBuildingOptions;
 import org.hibernate.boot.spi.MetadataSourcesContributor;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cache.spi.access.AccessType;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.MetadataSourceType;
 import org.hibernate.cfg.annotations.reflection.JPAMetadataProvider;
 import org.hibernate.engine.config.spi.ConfigurationService;
 import org.hibernate.engine.config.spi.StandardConverters;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.BasicType;
 import org.hibernate.type.CompositeCustomType;
 import org.hibernate.type.CustomType;
 import org.hibernate.usertype.CompositeUserType;
 import org.hibernate.usertype.UserType;
 
 import org.jboss.jandex.IndexView;
 
 import static org.hibernate.internal.log.DeprecationLogger.DEPRECATION_LOGGER;
 
 /**
  * @author Steve Ebersole
  */
 public class MetadataBuilderImpl implements MetadataBuilder, TypeContributions {
 	private static final CoreMessageLogger log = CoreLogging.messageLogger( MetadataBuilderImpl.class );
 
 	private final MetadataSources sources;
 	private final MetadataBuildingOptionsImpl options;
 
 	public MetadataBuilderImpl(MetadataSources sources) {
 		this(
 				sources,
 				getStandardServiceRegistry( sources.getServiceRegistry() )
 		);
 	}
 
 	private static StandardServiceRegistry getStandardServiceRegistry(ServiceRegistry serviceRegistry) {
 		if ( serviceRegistry == null ) {
 			throw new HibernateException( "ServiceRegistry passed to MetadataBuilder cannot be null" );
 		}
 
 		if ( StandardServiceRegistry.class.isInstance( serviceRegistry ) ) {
 			return ( StandardServiceRegistry ) serviceRegistry;
 		}
 		else if ( BootstrapServiceRegistry.class.isInstance( serviceRegistry ) ) {
 			log.debugf(
 					"ServiceRegistry passed to MetadataBuilder was a BootstrapServiceRegistry; this likely wont end well" +
 							"if attempt is made to build SessionFactory"
 			);
 			return new StandardServiceRegistryBuilder( (BootstrapServiceRegistry) serviceRegistry ).build();
 		}
 		else {
 			throw new HibernateException(
 					String.format(
 							"Unexpected type of ServiceRegistry [%s] encountered in attempt to build MetadataBuilder",
 							serviceRegistry.getClass().getName()
 					)
 			);
 		}
 	}
 
 	public MetadataBuilderImpl(MetadataSources sources, StandardServiceRegistry serviceRegistry) {
 		this.sources = sources;
+		this.options = new MetadataBuildingOptionsImpl( serviceRegistry );
 
 		for ( MetadataSourcesContributor contributor :
 				sources.getServiceRegistry()
 						.getService( ClassLoaderService.class )
 						.loadJavaServices( MetadataSourcesContributor.class ) ) {
-			contributor.contribute( sources, null );
+			contributor.contribute( sources );
 		}
 
-		this.options = new MetadataBuildingOptionsImpl( serviceRegistry );
-
 		applyCfgXmlValues( serviceRegistry.getService( CfgXmlAccessService.class ) );
+
+		final ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
+		for ( MetadataBuilderContributor contributor : classLoaderService.loadJavaServices( MetadataBuilderContributor.class ) ) {
+			contributor.contribute( this );
+		}
 	}
 
 	private void applyCfgXmlValues(CfgXmlAccessService service) {
 		final LoadedConfig aggregatedConfig = service.getAggregatedConfig();
 		if ( aggregatedConfig == null ) {
 			return;
 		}
 
 		for ( CacheRegionDefinition cacheRegionDefinition : aggregatedConfig.getCacheRegionDefinitions() ) {
 			with( cacheRegionDefinition );
 		}
 	}
 
 	@Override
 	public MetadataBuilder withImplicitSchemaName(String implicitSchemaName) {
 		options.mappingDefaults.implicitSchemaName = implicitSchemaName;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder withImplicitCatalogName(String implicitCatalogName) {
 		options.mappingDefaults.implicitCatalogName = implicitCatalogName;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(ImplicitNamingStrategy namingStrategy) {
 		this.options.implicitNamingStrategy = namingStrategy;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(PhysicalNamingStrategy namingStrategy) {
 		this.options.physicalNamingStrategy = namingStrategy;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(ReflectionManager reflectionManager) {
 		this.options.reflectionManager = reflectionManager;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(SharedCacheMode sharedCacheMode) {
 		this.options.sharedCacheMode = sharedCacheMode;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(AccessType implicitCacheAccessType) {
 		this.options.mappingDefaults.implicitCacheAccessType = implicitCacheAccessType;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(IndexView jandexView) {
 		this.options.jandexView = jandexView;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(ScanOptions scanOptions) {
 		this.options.scanOptions = scanOptions;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(ScanEnvironment scanEnvironment) {
 		this.options.scanEnvironment = scanEnvironment;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(Scanner scanner) {
 		this.options.scannerSetting = scanner;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(ArchiveDescriptorFactory factory) {
 		this.options.archiveDescriptorFactory = factory;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder withNewIdentifierGeneratorsEnabled(boolean enabled) {
 		this.options.useNewIdentifierGenerators = enabled;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder withExplicitDiscriminatorsForJoinedSubclassSupport(boolean supported) {
 		options.explicitDiscriminatorsForJoinedInheritanceSupported = supported;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder withImplicitDiscriminatorsForJoinedSubclassSupport(boolean supported) {
 		options.implicitDiscriminatorsForJoinedInheritanceSupported = supported;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder withImplicitForcingOfDiscriminatorsInSelect(boolean supported) {
 		options.implicitlyForceDiscriminatorInSelect = supported;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder withNationalizedCharacterData(boolean enabled) {
 		options.useNationalizedCharacterData = enabled;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(BasicType type) {
 		options.basicTypeRegistrations.add( type );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(UserType type, String[] keys) {
 		options.basicTypeRegistrations.add( new CustomType( type, keys ) );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(CompositeUserType type, String[] keys) {
 		options.basicTypeRegistrations.add( new CompositeCustomType( type, keys ) );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(TypeContributor typeContributor) {
 		typeContributor.contribute( this, options.serviceRegistry );
 		return this;
 	}
 
 	@Override
 	public void contributeType(BasicType type) {
 		options.basicTypeRegistrations.add( type );
 	}
 
 	@Override
 	public void contributeType(UserType type, String[] keys) {
 		options.basicTypeRegistrations.add( new CustomType( type, keys ) );
 	}
 
 	@Override
 	public void contributeType(CompositeUserType type, String[] keys) {
 		options.basicTypeRegistrations.add( new CompositeCustomType( type, keys ) );
 	}
 
 	@Override
 	public MetadataBuilder with(CacheRegionDefinition cacheRegionDefinition) {
 		if ( options.cacheRegionDefinitions == null ) {
 			options.cacheRegionDefinitions = new ArrayList<CacheRegionDefinition>();
 		}
 		options.cacheRegionDefinitions.add( cacheRegionDefinition );
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(ClassLoader tempClassLoader) {
 		options.tempClassLoader = tempClassLoader;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder setSourceProcessOrdering(List<MetadataSourceType> sourceProcessOrdering) {
 		options.sourceProcessOrdering = sourceProcessOrdering;
 		return this;
 	}
 
 	public MetadataBuilder allowSpecjSyntax() {
 		this.options.specjProprietarySyntaxEnabled = true;
 		return this;
 	}
 
 //	public MetadataBuilder with(PersistentAttributeMemberResolver resolver) {
 //		options.persistentAttributeMemberResolver = resolver;
 //		return this;
 //	}
 
 	@Override
 	public MetadataImpl build() {
 		final CfgXmlAccessService cfgXmlAccessService = options.serviceRegistry.getService( CfgXmlAccessService.class );
 		if ( cfgXmlAccessService.getAggregatedConfig() != null ) {
 			if ( cfgXmlAccessService.getAggregatedConfig().getMappingReferences() != null ) {
 				for ( MappingReference mappingReference : cfgXmlAccessService.getAggregatedConfig().getMappingReferences() ) {
 					mappingReference.apply( sources );
 				}
 			}
 		}
 
 		return MetadataBuildingProcess.build( sources, options );
 	}
 
 	public static class MappingDefaultsImpl implements MappingDefaults {
 		private String implicitSchemaName;
 		private String implicitCatalogName;
 		private boolean implicitlyQuoteIdentifiers;
 
 		private AccessType implicitCacheAccessType;
 
 		public MappingDefaultsImpl(StandardServiceRegistry serviceRegistry) {
 			final ConfigurationService configService = serviceRegistry.getService( ConfigurationService.class );
 
 			this.implicitSchemaName = configService.getSetting(
 					AvailableSettings.DEFAULT_SCHEMA,
 					StandardConverters.STRING,
 					null
 			);
 
 			this.implicitCatalogName = configService.getSetting(
 					AvailableSettings.DEFAULT_CATALOG,
 					StandardConverters.STRING,
 					null
 			);
 
 			this.implicitlyQuoteIdentifiers = configService.getSetting(
 					AvailableSettings.GLOBALLY_QUOTED_IDENTIFIERS,
 					StandardConverters.BOOLEAN,
 					false
 			);
 
 			this.implicitCacheAccessType = configService.getSetting(
 					AvailableSettings.DEFAULT_CACHE_CONCURRENCY_STRATEGY,
 					new ConfigurationService.Converter<AccessType>() {
 						@Override
 						public AccessType convert(Object value) {
 							return AccessType.fromExternalName( value.toString() );
 						}
 					}
 			);
 		}
 
 		@Override
 		public String getImplicitSchemaName() {
 			return implicitSchemaName;
 		}
 
 		@Override
 		public String getImplicitCatalogName() {
 			return implicitCatalogName;
 		}
 
 		@Override
 		public boolean shouldImplicitlyQuoteIdentifiers() {
 			return implicitlyQuoteIdentifiers;
 		}
 
 		@Override
 		public String getImplicitIdColumnName() {
 			return DEFAULT_IDENTIFIER_COLUMN_NAME;
 		}
 
 		@Override
 		public String getImplicitTenantIdColumnName() {
 			return DEFAULT_TENANT_IDENTIFIER_COLUMN_NAME;
 		}
 
 		@Override
 		public String getImplicitDiscriminatorColumnName() {
 			return DEFAULT_DISCRIMINATOR_COLUMN_NAME;
 		}
 
 		@Override
 		public String getImplicitPackageName() {
 			return null;
 		}
 
 		@Override
 		public boolean isAutoImportEnabled() {
 			return true;
 		}
 
 		@Override
 		public String getImplicitCascadeStyleName() {
 			return DEFAULT_CASCADE_NAME;
 		}
 
 		@Override
 		public String getImplicitPropertyAccessorName() {
 			return DEFAULT_PROPERTY_ACCESS_NAME;
 		}
 
 		@Override
 		public boolean areEntitiesImplicitlyLazy() {
 			// for now, just hard-code
 			return false;
 		}
 
 		@Override
 		public boolean areCollectionsImplicitlyLazy() {
 			// for now, just hard-code
 			return true;
 		}
 
 		@Override
 		public AccessType getImplicitCacheAccessType() {
 			return implicitCacheAccessType;
 		}
 	}
 
 	public static class MetadataBuildingOptionsImpl implements MetadataBuildingOptions {
 		private final StandardServiceRegistry serviceRegistry;
 		private final MappingDefaultsImpl mappingDefaults;
 
 		private List<BasicType> basicTypeRegistrations = new ArrayList<BasicType>();
 
 		private IndexView jandexView;
 		private ClassLoader tempClassLoader;
 
 		private ScanOptions scanOptions;
 		private ScanEnvironment scanEnvironment;
 		private Object scannerSetting;
 		private ArchiveDescriptorFactory archiveDescriptorFactory;
 
 		private ImplicitNamingStrategy implicitNamingStrategy;
 		private PhysicalNamingStrategy physicalNamingStrategy;
 
 		private ReflectionManager reflectionManager = generateDefaultReflectionManager();
 
 		private SharedCacheMode sharedCacheMode;
 		private AccessType defaultCacheAccessType;
 		private boolean useNewIdentifierGenerators;
 		private MultiTenancyStrategy multiTenancyStrategy;
 		private List<CacheRegionDefinition> cacheRegionDefinitions;
 		private boolean explicitDiscriminatorsForJoinedInheritanceSupported;
 		private boolean implicitDiscriminatorsForJoinedInheritanceSupported;
 		private boolean implicitlyForceDiscriminatorInSelect;
 		private boolean useNationalizedCharacterData;
 		private boolean specjProprietarySyntaxEnabled;
 		private List<MetadataSourceType> sourceProcessOrdering;
 
 		private static ReflectionManager generateDefaultReflectionManager() {
 			final JavaReflectionManager reflectionManager = new JavaReflectionManager();
 			reflectionManager.setMetadataProvider( new JPAMetadataProvider() );
 			return reflectionManager;
 		}
 //		private PersistentAttributeMemberResolver persistentAttributeMemberResolver =
 //				StandardPersistentAttributeMemberResolver.INSTANCE;
 
 		public MetadataBuildingOptionsImpl(StandardServiceRegistry serviceRegistry) {
 			this.serviceRegistry = serviceRegistry;
 
 			final StrategySelector strategySelector = serviceRegistry.getService( StrategySelector.class );
 			final ConfigurationService configService = serviceRegistry.getService( ConfigurationService.class );
 
 			this.mappingDefaults = new MappingDefaultsImpl( serviceRegistry );
 
 //			jandexView = (IndexView) configService.getSettings().get( AvailableSettings.JANDEX_INDEX );
 
 			scanOptions = new StandardScanOptions(
 					(String) configService.getSettings().get( AvailableSettings.SCANNER_DISCOVERY ),
 					false
 			);
 			// ScanEnvironment must be set explicitly
 			scannerSetting = configService.getSettings().get( AvailableSettings.SCANNER );
 			if ( scannerSetting == null ) {
 				scannerSetting = configService.getSettings().get( AvailableSettings.SCANNER_DEPRECATED );
 				if ( scannerSetting != null ) {
 					DEPRECATION_LOGGER.logDeprecatedScannerSetting();
 				}
 			}
 			archiveDescriptorFactory = strategySelector.resolveStrategy(
 					ArchiveDescriptorFactory.class,
 					configService.getSettings().get( AvailableSettings.SCANNER_ARCHIVE_INTERPRETER )
 			);
 
 			useNewIdentifierGenerators = configService.getSetting(
 					AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS,
 					StandardConverters.BOOLEAN,
 					false
 			);
 
 			multiTenancyStrategy =  MultiTenancyStrategy.determineMultiTenancyStrategy( configService.getSettings() );
 
 			implicitDiscriminatorsForJoinedInheritanceSupported = configService.getSetting(
 					AvailableSettings.IMPLICIT_DISCRIMINATOR_COLUMNS_FOR_JOINED_SUBCLASS,
 					StandardConverters.BOOLEAN,
 					false
 			);
 
 			explicitDiscriminatorsForJoinedInheritanceSupported = !configService.getSetting(
 					AvailableSettings.IGNORE_EXPLICIT_DISCRIMINATOR_COLUMNS_FOR_JOINED_SUBCLASS,
 					StandardConverters.BOOLEAN,
 					false
 			);
 
 			implicitlyForceDiscriminatorInSelect = configService.getSetting(
 					AvailableSettings.FORCE_DISCRIMINATOR_IN_SELECTS_BY_DEFAULT,
 					StandardConverters.BOOLEAN,
 					false
 			);
 
 			sharedCacheMode = configService.getSetting(
 					"javax.persistence.sharedCache.mode",
 					new ConfigurationService.Converter<SharedCacheMode>() {
 						@Override
 						public SharedCacheMode convert(Object value) {
 							if ( value == null ) {
 								return null;
 							}
 
 							if ( SharedCacheMode.class.isInstance( value ) ) {
 								return (SharedCacheMode) value;
 							}
 
 							return SharedCacheMode.valueOf( value.toString() );
 						}
 					},
 					SharedCacheMode.UNSPECIFIED
 			);
 
 			defaultCacheAccessType = configService.getSetting(
 					AvailableSettings.DEFAULT_CACHE_CONCURRENCY_STRATEGY,
 					new ConfigurationService.Converter<AccessType>() {
 						@Override
 						public AccessType convert(Object value) {
 							if ( value == null ) {
 								return null;
 							}
 
 							if ( CacheConcurrencyStrategy.class.isInstance( value ) ) {
 								return ( (CacheConcurrencyStrategy) value ).toAccessType();
 							}
 
 							if ( AccessType.class.isInstance( value ) ) {
 								return (AccessType) value;
 							}
 
 							return AccessType.fromExternalName( value.toString() );
 						}
 					},
 					// by default, see if the defined RegionFactory (if one) defines a default
 					serviceRegistry.getService( RegionFactory.class ) == null
 							? null
 							: serviceRegistry.getService( RegionFactory.class ).getDefaultAccessType()
 			);
 
 			specjProprietarySyntaxEnabled = configService.getSetting(
 					"hibernate.enable_specj_proprietary_syntax",
 					StandardConverters.BOOLEAN,
 					false
 			);
 
 			implicitNamingStrategy = strategySelector.resolveDefaultableStrategy(
 					ImplicitNamingStrategy.class,
 					configService.getSettings().get( AvailableSettings.IMPLICIT_NAMING_STRATEGY ),
 					ImplicitNamingStrategyLegacyJpaImpl.INSTANCE
 			);
 
 			physicalNamingStrategy = strategySelector.resolveDefaultableStrategy(
 					PhysicalNamingStrategy.class,
 					configService.getSettings().get( AvailableSettings.PHYSICAL_NAMING_STRATEGY ),
 					PhysicalNamingStrategyStandardImpl.INSTANCE
 			);
 
 			sourceProcessOrdering = resolveInitialSourceProcessOrdering( configService );
 		}
 
 		private List<MetadataSourceType> resolveInitialSourceProcessOrdering(ConfigurationService configService) {
 			List<MetadataSourceType> initialSelections = null;
 
 			final String sourceProcessOrderingSetting = configService.getSetting(
 					AvailableSettings.ARTIFACT_PROCESSING_ORDER,
 					StandardConverters.STRING
 			);
 			if ( sourceProcessOrderingSetting != null ) {
 				final String[] orderChoices = StringHelper.split( ",; ", sourceProcessOrderingSetting, false );
 				initialSelections = CollectionHelper.arrayList( orderChoices.length );
 				for ( String orderChoice : orderChoices ) {
 					initialSelections.add( MetadataSourceType.parsePrecedence( orderChoice ) );
 				}
 			}
 			if ( initialSelections == null || initialSelections.isEmpty() ) {
 				initialSelections = Arrays.asList(  MetadataSourceType.HBM, MetadataSourceType.CLASS );
 			}
 
 			return initialSelections;
 		}
 
 		@Override
 		public StandardServiceRegistry getServiceRegistry() {
 			return serviceRegistry;
 		}
 
 		@Override
 		public MappingDefaults getMappingDefaults() {
 			return mappingDefaults;
 		}
 
 		@Override
 		public List<BasicType> getBasicTypeRegistrations() {
 			return basicTypeRegistrations;
 		}
 
 		@Override
 		public IndexView getJandexView() {
 			return jandexView;
 		}
 
 		@Override
 		public ScanOptions getScanOptions() {
 			return scanOptions;
 		}
 
 		@Override
 		public ScanEnvironment getScanEnvironment() {
 			return scanEnvironment;
 		}
 
 		@Override
 		public Object getScanner() {
 			return scannerSetting;
 		}
 
 		@Override
 		public ArchiveDescriptorFactory getArchiveDescriptorFactory() {
 			return archiveDescriptorFactory;
 		}
 
 		@Override
 		public ClassLoader getTempClassLoader() {
 			return tempClassLoader;
 		}
 
 		@Override
 		public ImplicitNamingStrategy getImplicitNamingStrategy() {
 			return implicitNamingStrategy;
 		}
 
 		@Override
 		public PhysicalNamingStrategy getPhysicalNamingStrategy() {
 			return physicalNamingStrategy;
 		}
 
 		@Override
 		public ReflectionManager getReflectionManager() {
 			return reflectionManager;
 		}
 
 		@Override
 		public SharedCacheMode getSharedCacheMode() {
 			return sharedCacheMode;
 		}
 
 		@Override
 		public AccessType getImplicitCacheAccessType() {
 			return defaultCacheAccessType;
 		}
 
 		@Override
 		public boolean isUseNewIdentifierGenerators() {
 			return useNewIdentifierGenerators;
 		}
 
 		@Override
 		public MultiTenancyStrategy getMultiTenancyStrategy() {
 			return multiTenancyStrategy;
 		}
 
 		@Override
 		public List<CacheRegionDefinition> getCacheRegionDefinitions() {
 			return cacheRegionDefinitions;
 		}
 
 		@Override
 		public boolean ignoreExplicitDiscriminatorsForJoinedInheritance() {
 			return !explicitDiscriminatorsForJoinedInheritanceSupported;
 		}
 
 		@Override
 		public boolean createImplicitDiscriminatorsForJoinedInheritance() {
 			return implicitDiscriminatorsForJoinedInheritanceSupported;
 		}
 
 		@Override
 		public boolean shouldImplicitlyForceDiscriminatorInSelect() {
 			return implicitlyForceDiscriminatorInSelect;
 		}
 
 		@Override
 		public boolean useNationalizedCharacterData() {
 			return useNationalizedCharacterData;
 		}
 
 		@Override
 		public boolean isSpecjProprietarySyntaxEnabled() {
 			return specjProprietarySyntaxEnabled;
 		}
 
 		@Override
 		public List<MetadataSourceType> getSourceProcessOrdering() {
 			return sourceProcessOrdering;
 		}
 
 		public static interface JpaOrmXmlPersistenceUnitDefaults {
 			public String getDefaultSchemaName();
 			public String getDefaultCatalogName();
 			public boolean shouldImplicitlyQuoteIdentifiers();
 		}
 
 		/**
 		 * Yuck.  This is needed because JPA lets users define "global building options"
 		 * in {@code orm.xml} mappings.  Forget that there are generally multiple
 		 * {@code orm.xml} mappings if using XML approach...  Ugh
 		 */
 		public void apply(JpaOrmXmlPersistenceUnitDefaults jpaOrmXmlPersistenceUnitDefaults) {
 			if ( !mappingDefaults.shouldImplicitlyQuoteIdentifiers() ) {
 				mappingDefaults.implicitlyQuoteIdentifiers = jpaOrmXmlPersistenceUnitDefaults.shouldImplicitlyQuoteIdentifiers();
 			}
 
 			if ( mappingDefaults.getImplicitCatalogName() == null ) {
 				mappingDefaults.implicitCatalogName = StringHelper.nullIfEmpty(
 						jpaOrmXmlPersistenceUnitDefaults.getDefaultCatalogName()
 				);
 			}
 
 			if ( mappingDefaults.getImplicitSchemaName() == null ) {
 				mappingDefaults.implicitSchemaName = StringHelper.nullIfEmpty(
 						jpaOrmXmlPersistenceUnitDefaults.getDefaultSchemaName()
 				);
 			}
 		}
 
 		//		@Override
 //		public PersistentAttributeMemberResolver getPersistentAttributeMemberResolver() {
 //			return persistentAttributeMemberResolver;
 //		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuildingProcess.java b/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuildingProcess.java
index 65f31df79f..2d904393f6 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuildingProcess.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/internal/MetadataBuildingProcess.java
@@ -1,564 +1,526 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2014, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.boot.internal;
 
 import java.lang.reflect.Constructor;
+import java.util.Collection;
 import java.util.HashSet;
+import java.util.LinkedHashSet;
 import java.util.Set;
 import javax.persistence.Converter;
 
 import org.hibernate.boot.MetadataSources;
 import org.hibernate.boot.archive.internal.StandardArchiveDescriptorFactory;
 import org.hibernate.boot.archive.scan.internal.StandardScanner;
 import org.hibernate.boot.archive.scan.spi.ClassDescriptor;
 import org.hibernate.boot.archive.scan.spi.JandexInitializer;
 import org.hibernate.boot.archive.scan.spi.MappingFileDescriptor;
 import org.hibernate.boot.archive.scan.spi.PackageDescriptor;
 import org.hibernate.boot.archive.scan.spi.ScanParameters;
 import org.hibernate.boot.archive.scan.spi.ScanResult;
 import org.hibernate.boot.archive.scan.spi.Scanner;
 import org.hibernate.boot.archive.spi.ArchiveDescriptorFactory;
 import org.hibernate.boot.internal.DeploymentResourcesInterpreter.DeploymentResources;
+import org.hibernate.boot.jaxb.internal.MappingBinder;
 import org.hibernate.boot.model.TypeContributions;
 import org.hibernate.boot.model.TypeContributor;
 import org.hibernate.boot.model.source.internal.annotations.AnnotationMetadataSourceProcessorImpl;
+import org.hibernate.boot.model.source.internal.hbm.EntityHierarchyBuilder;
+import org.hibernate.boot.model.source.internal.hbm.EntityHierarchySourceImpl;
 import org.hibernate.boot.model.source.internal.hbm.HbmMetadataSourceProcessorImpl;
+import org.hibernate.boot.model.source.internal.hbm.MappingDocument;
+import org.hibernate.boot.model.source.internal.hbm.ModelBinder;
 import org.hibernate.boot.model.source.spi.MetadataSourceProcessor;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.spi.AdditionalJaxbMappingProducer;
 import org.hibernate.boot.spi.ClassLoaderAccess;
 import org.hibernate.boot.spi.MetadataBuildingOptions;
+import org.hibernate.boot.spi.MetadataContributor;
 import org.hibernate.cfg.MetadataSourceType;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.type.BasicTypeRegistry;
 import org.hibernate.type.TypeFactory;
 import org.hibernate.type.TypeResolver;
 import org.hibernate.usertype.CompositeUserType;
 import org.hibernate.usertype.UserType;
 
 import org.jboss.jandex.IndexView;
 import org.jboss.logging.Logger;
 
 /**
  * Represents the process of building a Metadata object.  The main entry point is the
  * static {@link #build}
  *
  * @author Steve Ebersole
  */
 public class MetadataBuildingProcess {
 	private static final Logger log = Logger.getLogger( MetadataBuildingProcess.class );
 
 	public static MetadataImpl build(
 			final MetadataSources sources,
 			final MetadataBuildingOptions options) {
 		final ClassLoaderService classLoaderService = options.getServiceRegistry().getService( ClassLoaderService.class );
 
 		final ClassLoaderAccess classLoaderAccess = new ClassLoaderAccessImpl(
 				options.getTempClassLoader(),
 				classLoaderService
 		);
 
 //		final JandexInitManager jandexInitializer = buildJandexInitializer( options, classLoaderAccess );
 		
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// scanning - Jandex initialization and source discovery
 		if ( options.getScanEnvironment() != null ) {
 			final Scanner scanner = buildScanner( options, classLoaderAccess );
 			final ScanResult scanResult = scanner.scan(
 					options.getScanEnvironment(),
 					options.getScanOptions(),
 					new ScanParameters() {
 						@Override
 						public JandexInitializer getJandexInitializer() {
 //							return jandexInitializer;
 							return null;
 						}
 					}
 			);
 
 			// Add to the MetadataSources any classes/packages/mappings discovered during scanning
 			addScanResultsToSources( sources, options, scanResult );
 		}
 
 //		// todo : add options.getScanEnvironment().getExplicitlyListedClassNames() to jandex?
 //		//		^^ - another option is to make sure that they are added to sources
 //
 //		if ( !jandexInitializer.wasIndexSupplied() ) {
 //			// If the Jandex Index(View) was supplied, we consider that supplied
 //			// one "complete".
 //			// Here though we were NOT supplied an index; in this case we want to
 //			// additionally ensure that any-and-all "known" classes are added to
 //			// the index we are building
 //			sources.indexKnownClasses( jandexInitializer );
 //		}
 		
 		// It's necessary to delay the binding of XML resources until now.  ClassLoaderAccess is needed for
 		// reflection, etc.
 //		sources.buildBindResults( classLoaderAccess );
 
 //		final IndexView jandexView = augmentJandexFromMappings( jandexInitializer.buildIndex(), sources, options );
 		final IndexView jandexView = options.getJandexView();
 
 		final BasicTypeRegistry basicTypeRegistry = handleTypes( options );
 
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// prep to start handling binding in earnest
 
 //		final JandexAccessImpl jandexAccess = new JandexAccessImpl(
 //				jandexView,
 //				classLoaderAccess
 //
 //		);
 		final InFlightMetadataCollectorImpl metadataCollector = new InFlightMetadataCollectorImpl(
 				options,
 				sources,
 				new TypeResolver( basicTypeRegistry, new TypeFactory() )
 		);
 
 		final MetadataBuildingContextRootImpl rootMetadataBuildingContext = new MetadataBuildingContextRootImpl(
 				options,
 				classLoaderAccess,
 				metadataCollector
 		);
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// Set up the processors and start binding
 		//		NOTE : this becomes even more simplified after we move purely
 		// 		to unified model
 
 		final MetadataSourceProcessor processor = new MetadataSourceProcessor() {
 			private final HbmMetadataSourceProcessorImpl hbmProcessor = new HbmMetadataSourceProcessorImpl(
 					sources,
 					rootMetadataBuildingContext
 			);
 
 			private final AnnotationMetadataSourceProcessorImpl annotationProcessor = new AnnotationMetadataSourceProcessorImpl(
 					sources,
 					rootMetadataBuildingContext,
 					jandexView
 			);
 
 			@Override
 			public void prepare() {
 				hbmProcessor.prepare();
 				annotationProcessor.prepare();
 			}
 
 			@Override
 			public void processTypeDefinitions() {
 				hbmProcessor.processTypeDefinitions();
 				annotationProcessor.processTypeDefinitions();
 			}
 
 			@Override
 			public void processQueryRenames() {
 				hbmProcessor.processQueryRenames();
 				annotationProcessor.processQueryRenames();
 			}
 
 			@Override
 			public void processNamedQueries() {
 				hbmProcessor.processNamedQueries();
 				annotationProcessor.processNamedQueries();
 			}
 
 			@Override
 			public void processAuxiliaryDatabaseObjectDefinitions() {
 				hbmProcessor.processAuxiliaryDatabaseObjectDefinitions();
 				annotationProcessor.processAuxiliaryDatabaseObjectDefinitions();
 			}
 
 			@Override
 			public void processIdentifierGenerators() {
 				hbmProcessor.processIdentifierGenerators();
 				annotationProcessor.processIdentifierGenerators();
 			}
 
 			@Override
 			public void processFilterDefinitions() {
 				hbmProcessor.processFilterDefinitions();
 				annotationProcessor.processFilterDefinitions();
 			}
 
 			@Override
 			public void processFetchProfiles() {
 				hbmProcessor.processFetchProfiles();
 				annotationProcessor.processFetchProfiles();
 			}
 
 			@Override
 			public void prepareForEntityHierarchyProcessing() {
 				for ( MetadataSourceType metadataSourceType : options.getSourceProcessOrdering() ) {
 					if ( metadataSourceType == MetadataSourceType.HBM ) {
 						hbmProcessor.prepareForEntityHierarchyProcessing();
 					}
 
 					if ( metadataSourceType == MetadataSourceType.CLASS ) {
 						annotationProcessor.prepareForEntityHierarchyProcessing();
 					}
 				}
 			}
 
 			@Override
 			public void processEntityHierarchies(Set<String> processedEntityNames) {
 				for ( MetadataSourceType metadataSourceType : options.getSourceProcessOrdering() ) {
 					if ( metadataSourceType == MetadataSourceType.HBM ) {
 						hbmProcessor.processEntityHierarchies( processedEntityNames );
 					}
 
 					if ( metadataSourceType == MetadataSourceType.CLASS ) {
 						annotationProcessor.processEntityHierarchies( processedEntityNames );
 					}
 				}
 			}
 
 			@Override
 			public void postProcessEntityHierarchies() {
 				for ( MetadataSourceType metadataSourceType : options.getSourceProcessOrdering() ) {
 					if ( metadataSourceType == MetadataSourceType.HBM ) {
 						hbmProcessor.postProcessEntityHierarchies();
 					}
 
 					if ( metadataSourceType == MetadataSourceType.CLASS ) {
 						annotationProcessor.postProcessEntityHierarchies();
 					}
 				}
 			}
 
 			@Override
 			public void processResultSetMappings() {
 				hbmProcessor.processResultSetMappings();
 				annotationProcessor.processResultSetMappings();
 			}
 
 			@Override
 			public void finishUp() {
 				hbmProcessor.finishUp();
 				annotationProcessor.finishUp();
 			}
 		};
 
 		processor.prepare();
 
 		processor.processTypeDefinitions();
 		processor.processQueryRenames();
 		processor.processAuxiliaryDatabaseObjectDefinitions();
 
 		processor.processIdentifierGenerators();
 		processor.processFilterDefinitions();
 		processor.processFetchProfiles();
 
 		final Set<String> processedEntityNames = new HashSet<String>();
 		processor.prepareForEntityHierarchyProcessing();
 		processor.processEntityHierarchies( processedEntityNames );
 		processor.postProcessEntityHierarchies();
 
 		processor.processResultSetMappings();
 		processor.processNamedQueries();
 
 		processor.finishUp();
 
-//		for ( MetadataContributor contributor : classLoaderService.loadJavaServices( MetadataContributor.class ) ) {
-//			contributor.contribute( metadataCollector, jandexView );
-//		}
+		for ( MetadataContributor contributor : classLoaderService.loadJavaServices( MetadataContributor.class ) ) {
+			log.tracef( "Calling MetadataContributor : %s", contributor );
+			contributor.contribute( metadataCollector, jandexView );
+		}
 
-//		final List<BindResult> bindResults = new ArrayList<BindResult>();
-//		final AdditionalJaxbRootProducerContext jaxbRootProducerContext = new AdditionalJaxbRootProducerContext() {
-//			@Override
-//			public IndexView getJandexIndex() {
-//				return jandexView;
-//			}
-//
-//			@Override
-//			public StandardServiceRegistry getServiceRegistry() {
-//				return options.getServiceRegistry();
-//			}
-//		};
-//		for ( AdditionalJaxbRootProducer producer : classLoaderService.loadJavaServices( AdditionalJaxbRootProducer.class ) ) {
-//			bindResults.addAll( producer.produceRoots( metadataCollector, jaxbRootProducerContext ) );
-//		}
+		metadataCollector.processSecondPasses( rootMetadataBuildingContext );
+
+		LinkedHashSet<AdditionalJaxbMappingProducer> producers = classLoaderService.loadJavaServices( AdditionalJaxbMappingProducer.class );
+		if ( producers != null && !producers.isEmpty() ) {
+			final EntityHierarchyBuilder hierarchyBuilder = new EntityHierarchyBuilder();
+//			final MappingBinder mappingBinder = new MappingBinder( true );
+			// We need to disable validation here.  It seems Envers is not producing valid (according to schema) XML
+			final MappingBinder mappingBinder = new MappingBinder( false );
+			for ( AdditionalJaxbMappingProducer producer : producers ) {
+				log.tracef( "Calling AdditionalJaxbMappingProducer : %s", producer );
+				Collection<MappingDocument> additionalMappings = producer.produceAdditionalMappings(
+						metadataCollector,
+						jandexView,
+						mappingBinder,
+						rootMetadataBuildingContext
+				);
+				for ( MappingDocument mappingDocument : additionalMappings ) {
+					hierarchyBuilder.indexMappingDocument( mappingDocument );
+				}
+			}
 
-//		secondPass( rootMetadataBuildingContext );
+			ModelBinder binder = ModelBinder.prepare( rootMetadataBuildingContext );
+			for ( EntityHierarchySourceImpl entityHierarchySource : hierarchyBuilder.buildHierarchies() ) {
+				binder.bindEntityHierarchy( entityHierarchySource );
+			}
+		}
 
 		return metadataCollector.buildMetadataInstance( rootMetadataBuildingContext );
 	}
 
 //	private static JandexInitManager buildJandexInitializer(
 //			MetadataBuildingOptions options,
 //			ClassLoaderAccess classLoaderAccess) {
 //		final boolean autoIndexMembers = ConfigurationHelper.getBoolean(
 //				org.hibernate.cfg.AvailableSettings.ENABLE_AUTO_INDEX_MEMBER_TYPES,
 //				options.getServiceRegistry().getService( ConfigurationService.class ).getSettings(),
 //				false
 //		);
 //
 //		return new JandexInitManager( options.getJandexView(), classLoaderAccess, autoIndexMembers );
 //	}
 
 	private static final Class[] SINGLE_ARG = new Class[] { ArchiveDescriptorFactory.class };
 
 	private static Scanner buildScanner(MetadataBuildingOptions options, ClassLoaderAccess classLoaderAccess) {
 		final Object scannerSetting = options.getScanner();
 		final ArchiveDescriptorFactory archiveDescriptorFactory = options.getArchiveDescriptorFactory();
 
 		if ( scannerSetting == null ) {
 			// No custom Scanner specified, use the StandardScanner
 			if ( archiveDescriptorFactory == null ) {
 				return new StandardScanner();
 			}
 			else {
 				return new StandardScanner( archiveDescriptorFactory );
 			}
 		}
 		else {
 			if ( Scanner.class.isInstance( scannerSetting ) ) {
 				if ( archiveDescriptorFactory != null ) {
 					throw new IllegalStateException(
 							"A Scanner instance and an ArchiveDescriptorFactory were both specified; please " +
 									"specify one or the other, or if you need to supply both, Scanner class to use " +
 									"(assuming it has a constructor accepting a ArchiveDescriptorFactory).  " +
 									"Alternatively, just pass the ArchiveDescriptorFactory during your own " +
 									"Scanner constructor assuming it is statically known."
 					);
 				}
 				return (Scanner) scannerSetting;
 			}
 
 			final Class<? extends  Scanner> scannerImplClass;
 			if ( Class.class.isInstance( scannerSetting ) ) {
 				scannerImplClass = (Class<? extends Scanner>) scannerSetting;
 			}
 			else {
 				scannerImplClass = classLoaderAccess.classForName( scannerSetting.toString() );
 			}
 
 
 			if ( archiveDescriptorFactory != null ) {
 				// find the single-arg constructor - its an error if none exists
 				try {
 					final Constructor<? extends Scanner> constructor = scannerImplClass.getConstructor( SINGLE_ARG );
 					try {
 						return constructor.newInstance( archiveDescriptorFactory );
 					}
 					catch (Exception e) {
 						throw new IllegalStateException(
 								"Error trying to instantiate custom specified Scanner [" +
 										scannerImplClass.getName() + "]",
 								e
 						);
 					}
 				}
 				catch (NoSuchMethodException e) {
 					throw new IllegalArgumentException(
 							"Configuration named a custom Scanner and a custom ArchiveDescriptorFactory, but " +
 									"Scanner impl did not define a constructor accepting ArchiveDescriptorFactory"
 					);
 				}
 			}
 			else {
 				// could be either ctor form...
 				// find the single-arg constructor - its an error if none exists
 				try {
 					final Constructor<? extends Scanner> constructor = scannerImplClass.getConstructor( SINGLE_ARG );
 					try {
 						return constructor.newInstance( StandardArchiveDescriptorFactory.INSTANCE );
 					}
 					catch (Exception e) {
 						throw new IllegalStateException(
 								"Error trying to instantiate custom specified Scanner [" +
 										scannerImplClass.getName() + "]",
 								e
 						);
 					}
 				}
 				catch (NoSuchMethodException e) {
 					try {
 						final Constructor<? extends Scanner> constructor = scannerImplClass.getConstructor();
 						try {
 							return constructor.newInstance();
 						}
 						catch (Exception e2) {
 							throw new IllegalStateException(
 									"Error trying to instantiate custom specified Scanner [" +
 											scannerImplClass.getName() + "]",
 									e2
 							);
 						}
 					}
 					catch (NoSuchMethodException ignore) {
 						throw new IllegalArgumentException(
 								"Configuration named a custom Scanner, but we were unable to locate " +
 										"an appropriate constructor"
 						);
 					}
 				}
 			}
 		}
 	}
 
 	private static void addScanResultsToSources(
 			MetadataSources sources,
 			MetadataBuildingOptions options,
 			ScanResult scanResult) {
 		final ClassLoaderService cls = options.getServiceRegistry().getService( ClassLoaderService.class );
 
 		DeploymentResources deploymentResources = DeploymentResourcesInterpreter.INSTANCE.buildDeploymentResources(
 				options.getScanEnvironment(),
 				scanResult,
 				options.getServiceRegistry()
 		);
 
 		for ( ClassDescriptor classDescriptor : deploymentResources.getClassDescriptors() ) {
 			final String className = classDescriptor.getName();
 
 			// todo : leverage Jandex calls after we fully integrate Jandex...
 			try {
 				final Class classRef = cls.classForName( className );
 
 				// logic here assumes an entity is not also a converter...
 				final Converter converter = (Converter) classRef.getAnnotation( Converter.class );
 				if ( converter != null ) {
 					//noinspection unchecked
 					sources.addAttributeConverter( classRef, converter.autoApply() );
 				}
 				else {
 					sources.addAnnotatedClass( classRef );
 				}
 			}
 			catch (ClassLoadingException e) {
 				// Not really sure what this means...
 				sources.addAnnotatedClassName( className );
 			}
 		}
 
 		for ( PackageDescriptor packageDescriptor : deploymentResources.getPackageDescriptors() ) {
 			sources.addPackage( packageDescriptor.getName() );
 		}
 
 		for ( MappingFileDescriptor mappingFileDescriptor : deploymentResources.getMappingFileDescriptors() ) {
 			sources.addInputStream( mappingFileDescriptor.getStreamAccess() );
 		}
 	}
 
 
 	private static BasicTypeRegistry handleTypes(MetadataBuildingOptions options) {
 		final ClassLoaderService classLoaderService = options.getServiceRegistry().getService( ClassLoaderService.class );
 
 		// ultimately this needs to change a little bit to account for HHH-7792
 		final BasicTypeRegistry basicTypeRegistry = new BasicTypeRegistry();
 
 		final TypeContributions typeContributions = new TypeContributions() {
 			@Override
 			public void contributeType(org.hibernate.type.BasicType type) {
 				basicTypeRegistry.register( type );
 			}
 
 			@Override
 			public void contributeType(UserType type, String[] keys) {
 				basicTypeRegistry.register( type, keys );
 			}
 
 			@Override
 			public void contributeType(CompositeUserType type, String[] keys) {
 				basicTypeRegistry.register( type, keys );
 			}
 		};
 
 		// add Dialect contributed types
 		final Dialect dialect = options.getServiceRegistry().getService( JdbcServices.class ).getDialect();
 		dialect.contributeTypes( typeContributions, options.getServiceRegistry() );
 
 		// add TypeContributor contributed types.
 		for ( TypeContributor contributor : classLoaderService.loadJavaServices( TypeContributor.class ) ) {
 			contributor.contribute( typeContributions, options.getServiceRegistry() );
 		}
 
 		// add explicit application registered types
 		for ( org.hibernate.type.BasicType basicType : options.getBasicTypeRegistrations() ) {
 			basicTypeRegistry.register( basicType );
 		}
 
 		return basicTypeRegistry;
 	}
-//
-//	private static void secondPass(MetadataBuildingContextRootImpl bindingContext) {
-//		// This must be done outside of Table, rather than statically, to ensure
-//		// deterministic alias names.  See HHH-2448.
-//		int uniqueInteger = 0;
-//		for ( Schema schema : bindingContext.getMetadataCollector().getDatabase().getSchemas() ) {
-//			for ( Table table : schema.getTables() ) {
-//				table.setTableNumber( uniqueInteger++ );
-//			}
-//		}
-//
-//
-//		if ( bindingContext.getBuildingOptions().getCacheRegionDefinitions() == null
-//				|| bindingContext.getBuildingOptions().getCacheRegionDefinitions().isEmpty() ) {
-//			return;
-//		}
-//
-//		for ( CacheRegionDefinition override : bindingContext.getBuildingOptions().getCacheRegionDefinitions() ) {
-//			final String role = override.getRole();
-//
-//			// NOTE : entity region overrides are already handled when building the
-//			if ( override.getRegionType() == CacheRegionDefinition.CacheRegionType.ENTITY ) {
-////				final EntityBinding entityBinding = bindingContext.getMetadataCollector().getEntityBinding( role );
-////				if ( entityBinding != null ) {
-////					entityBinding.getHierarchyDetails().getCaching().setRegion( override.getRegion() );
-////					entityBinding.getHierarchyDetails().getCaching().setAccessType( AccessType.fromExternalName( override.getUsage() ) );
-////					entityBinding.getHierarchyDetails().getCaching().setCacheLazyProperties( override.isCacheLazy() );
-////				}
-////				else {
-////					//logging?
-////					throw new MappingException( "Can't find entitybinding for role " + role +" to apply cache configuration" );
-////				}
-//
-//			}
-//			else if ( override.getRegionType() == CacheRegionDefinition.CacheRegionType.COLLECTION ) {
-//				String collectionRole = role;
-//				if ( !role.contains( "#" ) ) {
-//					final int pivotPosition = role.lastIndexOf( '.' );
-//					if ( pivotPosition > 0 ) {
-//						collectionRole = role.substring( 0, pivotPosition ) + '#' + role.substring( pivotPosition + 1 );
-//					}
-//				}
-//				final PluralAttributeBinding pluralAttributeBinding = bindingContext.getMetadataCollector().getCollection(
-//						collectionRole
-//				);
-//				if ( pluralAttributeBinding != null ) {
-//					pluralAttributeBinding.getCaching().overlay( override );
-//				}
-//				else {
-//					//logging?
-//					throw new MappingException( "Can't find entitybinding for role " + role +" to apply cache configuration" );
-//				}
-//			}
-//		}
-//
-//	}
-
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/MappingBinder.java b/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/MappingBinder.java
index 36e96a02f5..1fe6311f49 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/MappingBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/MappingBinder.java
@@ -1,144 +1,117 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2014, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.boot.jaxb.internal;
 
+import javax.xml.stream.XMLEventFactory;
 import javax.xml.stream.XMLEventReader;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.events.StartElement;
 import javax.xml.stream.events.XMLEvent;
 
 import org.hibernate.boot.MappingException;
 import org.hibernate.boot.UnsupportedOrmXsdVersionException;
 import org.hibernate.boot.jaxb.Origin;
 import org.hibernate.boot.jaxb.hbm.spi.JaxbHbmHibernateMapping;
 import org.hibernate.boot.jaxb.internal.stax.HbmEventReader;
 import org.hibernate.boot.jaxb.internal.stax.JpaOrmXmlEventReader;
 import org.hibernate.boot.jaxb.internal.stax.LocalSchema;
 import org.hibernate.boot.jaxb.spi.Binding;
 
 import org.jboss.logging.Logger;
 
 import org.dom4j.Document;
 import org.dom4j.Node;
 import org.dom4j.io.STAXEventReader;
 
 /**
  * @author Steve Ebersole
  */
 public class MappingBinder extends AbstractBinder {
 	private static final Logger log = Logger.getLogger( MappingBinder.class );
 
+	private final XMLEventFactory xmlEventFactory = XMLEventFactory.newInstance();
+
 	public MappingBinder() {
 		super();
 	}
 
 	public MappingBinder(boolean validateXml) {
 		super( validateXml );
 	}
 
 	@Override
 	protected Binding doBind(
 			XMLEventReader staxEventReader,
 			StartElement rootElementStartEvent,
 			Origin origin) {
 		final String rootElementLocalName = rootElementStartEvent.getName().getLocalPart();
 		if ( "hibernate-mapping".equals( rootElementLocalName ) ) {
 			log.debugf( "Performing JAXB binding of hbm.xml document : %s", origin.toString() );
 
-			XMLEventReader hbmReader = new HbmEventReader( staxEventReader );
+			XMLEventReader hbmReader = new HbmEventReader( staxEventReader, xmlEventFactory );
 			JaxbHbmHibernateMapping hbmBindings = jaxb( hbmReader, LocalSchema.HBM.getSchema(), JaxbHbmHibernateMapping.class, origin );
 			return new Binding<JaxbHbmHibernateMapping>( hbmBindings, origin );
 		}
 		else {
 //			final XMLEventReader reader = new JpaOrmXmlEventReader( staxEventReader );
 //			return jaxb( reader, LocalSchema.MAPPING.getSchema(), JaxbEntityMappings.class, origin );
 
 			try {
-				final XMLEventReader reader = new JpaOrmXmlEventReader( staxEventReader );
+				final XMLEventReader reader = new JpaOrmXmlEventReader( staxEventReader, xmlEventFactory );
 				return new Binding<Document>( toDom4jDocument( reader, origin), origin );
 			}
 			catch (JpaOrmXmlEventReader.BadVersionException e) {
 				throw new UnsupportedOrmXsdVersionException( e.getRequestedVersion(), origin );
 			}
 		}
 	}
 
 	private Document toDom4jDocument(XMLEventReader jpaOrmXmlEventReader, Origin origin) {
 		// todo : do we need to build a DocumentFactory instance for use here?
 		//		historically we did that to set TCCL since, iirc, dom4j uses TCCL
 		org.dom4j.io.STAXEventReader staxToDom4jReader = new STAXEventReader() {
 			@Override
 			public Node readNode(XMLEventReader reader) throws XMLStreamException {
 				// dom4j's reader misses handling of XML comments.  So if the document we
 				// are trying to read has comments this process will blow up.  So we
 				// override that to add that support as best we can
 				XMLEvent event = reader.peek();
 				if ( javax.xml.stream.events.Comment.class.isInstance( event ) ) {
 					return super.readComment( reader );
 				}
 				return super.readNode( reader );
 			}
 		};
 		try {
 			return staxToDom4jReader.readDocument( jpaOrmXmlEventReader );
 		}
 		catch (XMLStreamException e) {
 			throw new MappingException(
 					"An error occurred transforming orm.xml document from StAX to dom4j representation ",
 					e,
 					origin
 			);
 		}
 	}
-
-	/**
-	 * Models an {@code orm.xml} file, which is processed in a delayed manner.
-	 */
-	public static class DelayedOrmXmlData {
-		private final XMLEventReader staxEventReader;
-		private final StartElement rootElementStartEvent;
-		private final Origin origin;
-
-		public DelayedOrmXmlData(
-				XMLEventReader staxEventReader,
-				StartElement rootElementStartEvent,
-				Origin origin) {
-			this.staxEventReader = staxEventReader;
-			this.rootElementStartEvent = rootElementStartEvent;
-			this.origin = origin;
-		}
-
-		public XMLEventReader getStaxEventReader() {
-			return staxEventReader;
-		}
-
-		public StartElement getRootElementStartEvent() {
-			return rootElementStartEvent;
-		}
-
-		public Origin getOrigin() {
-			return origin;
-		}
-	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/stax/HbmEventReader.java b/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/stax/HbmEventReader.java
index 14fa0fcfb5..8f97935e0b 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/stax/HbmEventReader.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/stax/HbmEventReader.java
@@ -1,106 +1,109 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2014, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.boot.jaxb.internal.stax;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLEventFactory;
 import javax.xml.stream.XMLEventReader;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.events.Namespace;
 import javax.xml.stream.events.StartElement;
 import javax.xml.stream.events.XMLEvent;
 import javax.xml.stream.util.EventReaderDelegate;
 
 /**
  * A StAX EventReader for {@code hbm.xml} files to add namespaces in documents
  * not containing namespaces.
  *
  * @author Steve Ebersole
  */
 public class HbmEventReader extends EventReaderDelegate {
 	private static final List<String> NAMESPACE_URIS_TO_MAP = Arrays.asList(
 			// we need to recognize the initial, prematurely-chosen hbm.xml xsd namespace
 			"http://www.hibernate.org/xsd/hibernate-mapping"
 	);
 
 	private final XMLEventFactory xmlEventFactory;
 
 	public HbmEventReader(XMLEventReader reader) {
 		this( reader, XMLEventFactory.newInstance() );
 	}
 
 	public HbmEventReader(XMLEventReader reader, XMLEventFactory xmlEventFactory) {
 		super( reader );
 		this.xmlEventFactory = xmlEventFactory;
 	}
 
 	@Override
 	public XMLEvent peek() throws XMLStreamException {
 		return wrap( super.peek() );
 	}
 
 	@Override
 	public XMLEvent nextEvent() throws XMLStreamException {
 		return wrap( super.nextEvent() );
 	}
 
 	private XMLEvent wrap(XMLEvent event) {
 		if ( event != null && event.isStartElement() ) {
 			return applyNamespace( event.asStartElement() );
 		}
 		return event;
 	}
 
 	@SuppressWarnings("unchecked")
 	private StartElement applyNamespace(StartElement startElement) {
 		final List<Namespace> targetNamespaces = new ArrayList<Namespace>();
 
 		if ( "".equals( startElement.getName().getNamespaceURI() ) ) {
 			// add the default namespace mapping
 			targetNamespaces.add( xmlEventFactory.createNamespace( LocalSchema.HBM.getNamespaceUri() ) );
 		}
 
 		// transfer any namespaces directly, unless it is in the "to map" list in which case
 		// we transfer a mapped copy pointing to the new namespace
 		final Iterator<Namespace> originalNamespaces = startElement.getNamespaces();
 		while ( originalNamespaces.hasNext() ) {
 			Namespace namespace = originalNamespaces.next();
 			if ( NAMESPACE_URIS_TO_MAP.contains( namespace.getNamespaceURI() ) ) {
 				// this is a namespace "to map" so map it
 				namespace = xmlEventFactory.createNamespace( namespace.getPrefix(), LocalSchema.HBM.getNamespaceUri() );
 			}
 			targetNamespaces.add( namespace );
 		}
 
+		// Transfer the location info from the incoming event to the event factory
+		// so that the event we ask it to generate for us has the same location info
+		xmlEventFactory.setLocation( startElement.getLocation() );
 		return xmlEventFactory.createStartElement(
 				new QName( LocalSchema.HBM.getNamespaceUri(), startElement.getName().getLocalPart() ),
 				startElement.getAttributes(),
 				targetNamespaces.iterator()
 		);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/stax/JpaOrmXmlEventReader.java b/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/stax/JpaOrmXmlEventReader.java
index c89ab842d2..ec77694917 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/stax/JpaOrmXmlEventReader.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/jaxb/internal/stax/JpaOrmXmlEventReader.java
@@ -1,219 +1,224 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2014, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.boot.jaxb.internal.stax;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLEventFactory;
 import javax.xml.stream.XMLEventReader;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.events.Attribute;
 import javax.xml.stream.events.EndElement;
 import javax.xml.stream.events.Namespace;
 import javax.xml.stream.events.StartElement;
 import javax.xml.stream.events.XMLEvent;
 import javax.xml.stream.util.EventReaderDelegate;
 
 /**
  * A JPA {@code orm.xml} specific StAX EVentReader to handle a few oddities.
  *
  * Mainly we handle the namespace change.
  *
  * Ultimately we should handle "upgrading" the documents as well.  The idea being that
  * we'd always treat all versions as the latest.
  *
  * {@see HHH-8108} for more discussion.
  *
  * @author Strong Liu
  * @author Steve Ebersole
  * @author Hardy Ferentschik
  */
 public class JpaOrmXmlEventReader extends EventReaderDelegate {
 	private static final List<String> NAMESPACE_URIS_TO_MAP = Arrays.asList(
 			// JPA 1.0 and 2.0 namespace uri
 			"http://java.sun.com/xml/ns/persistence/orm"
 	);
 
 	private static final String ROOT_ELEMENT_NAME = "entity-mappings";
 	private static final String VERSION_ATTRIBUTE_NAME = "version";
 
 	private static final String DEFAULT_VERSION = "2.1";
 	private static final List<String> VALID_VERSIONS = Arrays.asList( "1.0", "2.0", "2.1" );
 
 	private final XMLEventFactory xmlEventFactory;
 
 	public JpaOrmXmlEventReader(XMLEventReader reader) {
 		this( reader, XMLEventFactory.newInstance() );
 	}
 
 	public JpaOrmXmlEventReader(XMLEventReader reader, XMLEventFactory xmlEventFactory) {
 		super( reader );
 		this.xmlEventFactory = xmlEventFactory;
 	}
 
 	@Override
 	public XMLEvent peek() throws XMLStreamException {
 		return wrap( super.peek() );
 	}
 
 	@Override
 	public XMLEvent nextEvent() throws XMLStreamException {
 		return wrap( super.nextEvent() );
 	}
 
 	private XMLEvent wrap(XMLEvent event) {
 		if ( event != null ) {
 			if ( event.isStartElement() ) {
 				return wrap( event.asStartElement() );
 			}
 			else if ( event.isEndElement() ) {
 				return wrap( event.asEndElement() );
 			}
 		}
 		return event;
 	}
 
 	private StartElement wrap(StartElement startElement) {
 		List<Attribute> newElementAttributeList = mapAttributes( startElement );
 		List<Namespace> newNamespaceList = mapNamespaces( startElement );
 
-		// create the new element
+		// Transfer the location info from the incoming event to the event factory
+		// so that the event we ask it to generate for us has the same location info
+		xmlEventFactory.setLocation( startElement.getLocation() );
 		return xmlEventFactory.createStartElement(
 				new QName( LocalSchema.ORM.getNamespaceUri(), startElement.getName().getLocalPart() ),
 				newElementAttributeList.iterator(),
 				newNamespaceList.iterator()
 		);
 	}
 
 	private List<Attribute> mapAttributes(StartElement startElement) {
 		final List<Attribute> mappedAttributes = new ArrayList<Attribute>();
 
 		Iterator<Attribute> existingAttributesIterator = existingXmlAttributesIterator( startElement );
 		while ( existingAttributesIterator.hasNext() ) {
 			final Attribute originalAttribute = existingAttributesIterator.next();
 			final Attribute attributeToUse = mapAttribute( startElement, originalAttribute );
 			mappedAttributes.add( attributeToUse );
 		}
 
 		return mappedAttributes;
 	}
 
 	@SuppressWarnings("unchecked")
 	private Iterator<Attribute> existingXmlAttributesIterator(StartElement startElement) {
 		return startElement.getAttributes();
 	}
 
 	private Attribute mapAttribute(StartElement startElement, Attribute originalAttribute) {
 		// Here we look to see if this attribute is the JPA version attribute, and if so do 2 things:
 		//		1) validate its version attribute is valid
 		//		2) update its version attribute to the default version if not already
 		//
 		// NOTE : atm this is a very simple check using just the attribute's local name
 		// rather than checking its qualified name.  It is possibly (though unlikely)
 		// that this could match on "other" version attributes in the same element
 
 		if ( ROOT_ELEMENT_NAME.equals( startElement.getName().getLocalPart() ) ) {
 			if ( VERSION_ATTRIBUTE_NAME.equals( originalAttribute.getName().getLocalPart() ) ) {
 				final String specifiedVersion = originalAttribute.getValue();
 
 				if ( !VALID_VERSIONS.contains( specifiedVersion ) ) {
 					throw new BadVersionException( specifiedVersion );
 				}
 
 				return xmlEventFactory.createAttribute( VERSION_ATTRIBUTE_NAME, DEFAULT_VERSION );
 			}
 		}
 
 		return originalAttribute;
 	}
 
 	private List<Namespace> mapNamespaces(StartElement startElement) {
 		return mapNamespaces( existingXmlNamespacesIterator( startElement ) );
 	}
 
 	private List<Namespace> mapNamespaces(Iterator<Namespace> originalNamespaceIterator ) {
 		final List<Namespace> mappedNamespaces = new ArrayList<Namespace>();
 
 //		final String elementNamespacePrefix = startElement.getName().getPrefix();
 //		if ( EMPTY_NAMESPACE_PREFIX.equals( elementNamespacePrefix ) ) {
 //			// add the default namespace mapping
 //			mappedNamespaces.add( xmlEventFactory.createNamespace( LocalSchema.ORM.getNamespaceUri() ) );
 //		}
 
 		while ( originalNamespaceIterator.hasNext() ) {
 			final Namespace originalNamespace  = originalNamespaceIterator.next();
 			final Namespace mappedNamespace = mapNamespace( originalNamespace );
 			mappedNamespaces.add( mappedNamespace );
 		}
 
 		if ( mappedNamespaces.isEmpty() ) {
 			mappedNamespaces.add( xmlEventFactory.createNamespace( LocalSchema.ORM.getNamespaceUri() ) );
 		}
 
 		return mappedNamespaces;
 	}
 
 	@SuppressWarnings("unchecked")
 	private Iterator<Namespace> existingXmlNamespacesIterator(StartElement startElement) {
 		return startElement.getNamespaces();
 	}
 
 	private Namespace mapNamespace(Namespace originalNamespace) {
 		if ( NAMESPACE_URIS_TO_MAP.contains( originalNamespace.getNamespaceURI() ) ) {
 			// this is a namespace "to map" so map it
 			return xmlEventFactory.createNamespace( originalNamespace.getPrefix(), LocalSchema.ORM.getNamespaceUri() );
 		}
 
 		return originalNamespace;
 	}
 
 	private XMLEvent wrap(EndElement endElement) {
 		final List<Namespace> targetNamespaces = mapNamespaces( existingXmlNamespacesIterator( endElement ) );
 
+		// Transfer the location info from the incoming event to the event factory
+		// so that the event we ask it to generate for us has the same location info
+		xmlEventFactory.setLocation( endElement.getLocation() );
 		return xmlEventFactory.createEndElement(
 				new QName( LocalSchema.ORM.getNamespaceUri(), endElement.getName().getLocalPart() ),
 				targetNamespaces.iterator()
 		);
 	}
 
 	@SuppressWarnings("unchecked")
 	private Iterator<Namespace> existingXmlNamespacesIterator(EndElement endElement) {
 		return endElement.getNamespaces();
 	}
 
 	public static class BadVersionException extends RuntimeException {
 		private final String requestedVersion;
 
 		public BadVersionException(String requestedVersion) {
 			this.requestedVersion = requestedVersion;
 		}
 
 		public String getRequestedVersion() {
 			return requestedVersion;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/model/source/internal/hbm/EntityHierarchySourceImpl.java b/hibernate-core/src/main/java/org/hibernate/boot/model/source/internal/hbm/EntityHierarchySourceImpl.java
index f4c5e492c1..ba21935ffe 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/model/source/internal/hbm/EntityHierarchySourceImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/model/source/internal/hbm/EntityHierarchySourceImpl.java
@@ -1,469 +1,469 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2014, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.boot.model.source.internal.hbm;
 
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
 
 import org.hibernate.EntityMode;
 import org.hibernate.boot.MappingException;
 import org.hibernate.boot.jaxb.hbm.spi.JaxbHbmEntityDiscriminatorType;
 import org.hibernate.boot.jaxb.hbm.spi.JaxbHbmGeneratorSpecificationType;
 import org.hibernate.boot.jaxb.hbm.spi.JaxbHbmMultiTenancyType;
 import org.hibernate.boot.jaxb.hbm.spi.JaxbHbmPolymorphismEnum;
 import org.hibernate.boot.jaxb.hbm.spi.JaxbHbmRootEntityType;
 import org.hibernate.boot.model.Caching;
 import org.hibernate.boot.model.IdentifierGeneratorDefinition;
 import org.hibernate.boot.model.naming.EntityNaming;
 import org.hibernate.boot.model.source.spi.DiscriminatorSource;
 import org.hibernate.boot.model.source.spi.EntityHierarchySource;
 import org.hibernate.boot.model.source.spi.EntityNamingSource;
 import org.hibernate.boot.model.source.spi.IdentifierSource;
 import org.hibernate.boot.model.source.spi.InheritanceType;
 import org.hibernate.boot.model.source.spi.MultiTenancySource;
 import org.hibernate.boot.model.source.spi.RelationalValueSource;
 import org.hibernate.boot.model.source.spi.SizeSource;
 import org.hibernate.boot.model.source.spi.VersionAttributeSource;
 import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.engine.OptimisticLockStyle;
 import org.hibernate.internal.util.StringHelper;
 
 /**
  * Models an entity hierarchy as defined by {@code hbm.xml} documents
  *
  * @author Steve Ebersole
  */
 public class EntityHierarchySourceImpl implements EntityHierarchySource {
 	private final RootEntitySourceImpl rootEntitySource;
 
 	private final IdentifierSource identifierSource;
 	private final VersionAttributeSource versionAttributeSource;
 	private final DiscriminatorSource discriminatorSource;
 	private final MultiTenancySource multiTenancySource;
 
 	private final Caching caching;
 	private final Caching naturalIdCaching;
 
 	private InheritanceType hierarchyInheritanceType = InheritanceType.NO_INHERITANCE;
 
 	private Set<String> collectedEntityNames = new HashSet<String>();
 
 	public EntityHierarchySourceImpl(RootEntitySourceImpl rootEntitySource) {
 		this.rootEntitySource = rootEntitySource;
 		this.rootEntitySource.injectHierarchy( this );
 
 		this.identifierSource = interpretIdentifierSource( rootEntitySource );
 		this.versionAttributeSource = interpretVersionSource( rootEntitySource );
 		this.discriminatorSource = interpretDiscriminatorSource( rootEntitySource );
 		this.multiTenancySource = interpretMultiTenancySource( rootEntitySource );
 
 		this.caching = Helper.createCaching( entityElement().getCache() );
 		this.naturalIdCaching = Helper.createNaturalIdCaching(
 				rootEntitySource.jaxbEntityMapping().getNaturalIdCache()
 		);
 
 		collectedEntityNames.add( rootEntitySource.getEntityNamingSource().getEntityName() );
 	}
 
 	private static IdentifierSource interpretIdentifierSource(RootEntitySourceImpl rootEntitySource) {
 		if ( rootEntitySource.jaxbEntityMapping().getId() == null
 				&& rootEntitySource.jaxbEntityMapping().getCompositeId() == null ) {
 			throw new MappingException(
 					String.format(
 							Locale.ENGLISH,
 							"Entity [%s] did not define an identifier",
 							rootEntitySource.getEntityNamingSource().getEntityName()
 					),
 					rootEntitySource.origin()
 			);
 		}
 
 		if ( rootEntitySource.jaxbEntityMapping().getId() != null ) {
 			return new IdentifierSourceSimpleImpl( rootEntitySource );
 		}
 		else {
 			// if we get here, we should have a composite identifier.  Just need
 			// to determine if it is aggregated, or non-aggregated...
 			if ( StringHelper.isEmpty( rootEntitySource.jaxbEntityMapping().getCompositeId().getName() ) ) {
 				if ( rootEntitySource.jaxbEntityMapping().getCompositeId().isMapped()
 						&& StringHelper.isEmpty( rootEntitySource.jaxbEntityMapping().getCompositeId().getClazz() ) ) {
 					throw new MappingException(
 							"mapped composite identifier must name component class to use.",
 							rootEntitySource.origin()
 					);
 				}
 				return new IdentifierSourceNonAggregatedCompositeImpl( rootEntitySource );
 			}
 			else {
 				if ( rootEntitySource.jaxbEntityMapping().getCompositeId().isMapped() ) {
 					throw new MappingException(
 							"cannot combine mapped=\"true\" with specified name",
 							rootEntitySource.origin()
 					);
 				}
 				return new IdentifierSourceAggregatedCompositeImpl( rootEntitySource );
 			}
 		}
 	}
 
 	private static VersionAttributeSource interpretVersionSource(RootEntitySourceImpl rootEntitySource) {
 		final JaxbHbmRootEntityType entityElement = rootEntitySource.jaxbEntityMapping();
 		if ( entityElement.getVersion() != null ) {
 			return new VersionAttributeSourceImpl(
 					rootEntitySource.sourceMappingDocument(),
 					rootEntitySource,
 					entityElement.getVersion()
 			);
 		}
 		else if ( entityElement.getTimestamp() != null ) {
 			return new TimestampAttributeSourceImpl(
 					rootEntitySource.sourceMappingDocument(),
 					rootEntitySource,
 					entityElement.getTimestamp()
 			);
 		}
 		return null;
 	}
 
 	private static DiscriminatorSource interpretDiscriminatorSource(final RootEntitySourceImpl rootEntitySource) {
 		final JaxbHbmEntityDiscriminatorType jaxbDiscriminatorMapping =
 				rootEntitySource.jaxbEntityMapping().getDiscriminator();
 
 		if ( jaxbDiscriminatorMapping == null ) {
 			return null;
 		}
 
 		final RelationalValueSource relationalValueSource = RelationalValueSourceHelper.buildValueSource(
 				rootEntitySource.sourceMappingDocument(),
 				null,
 				new RelationalValueSourceHelper.AbstractColumnsAndFormulasSource() {
 					@Override
 					public XmlElementMetadata getSourceType() {
 						return XmlElementMetadata.DISCRIMINATOR;
 					}
 
 					@Override
 					public String getSourceName() {
 						return null;
 					}
 
 					@Override
 					public SizeSource getSizeSource() {
 						return Helper.interpretSizeSource(
 								jaxbDiscriminatorMapping.getLength(),
 								(Integer) null,
 								null
 						);
 					}
 
 					@Override
 					public String getFormulaAttribute() {
 						return jaxbDiscriminatorMapping.getFormulaAttribute();
 					}
 
 					@Override
 					public String getColumnAttribute() {
 						return jaxbDiscriminatorMapping.getColumnAttribute();
 					}
 
 					private List columnOrFormulas;
 					@Override
 					public List getColumnOrFormulaElements() {
 						if ( columnOrFormulas == null ) {
 							if ( jaxbDiscriminatorMapping.getColumn() != null ) {
 								if ( jaxbDiscriminatorMapping.getFormula() != null ) {
 									throw new MappingException(
 											String.format(
 													Locale.ENGLISH,
 													"discriminator mapping [%s] named both <column/> and <formula/>, but only one or other allowed",
 													rootEntitySource.getEntityNamingSource().getEntityName()
 											),
 											rootEntitySource.sourceMappingDocument().getOrigin()
 									);
 								}
 								else {
 									columnOrFormulas = Collections.singletonList( jaxbDiscriminatorMapping.getColumn() );
 								}
 							}
 							else {
 								if ( jaxbDiscriminatorMapping.getFormula() != null ) {
-									columnOrFormulas = Collections.singletonList( jaxbDiscriminatorMapping.getColumn() );
+									columnOrFormulas = Collections.singletonList( jaxbDiscriminatorMapping.getFormula() );
 								}
 								else {
 									columnOrFormulas = Collections.emptyList();
 								}
 							}
 						}
 						return columnOrFormulas;
 					}
 
 					@Override
 					public Boolean isNullable() {
 						return !jaxbDiscriminatorMapping.isNotNull();
 					}
 				}
 		);
 
 		return new DiscriminatorSource() {
 			@Override
 			public EntityNaming getEntityNaming() {
 				return rootEntitySource.getEntityNamingSource();
 			}
 
 			@Override
 			public MetadataBuildingContext getBuildingContext() {
 				return rootEntitySource.metadataBuildingContext();
 			}
 
 			@Override
 			public RelationalValueSource getDiscriminatorRelationalValueSource() {
 				return relationalValueSource;
 			}
 
 			@Override
 			public String getExplicitHibernateTypeName() {
 				return jaxbDiscriminatorMapping.getType();
 			}
 
 			@Override
 			public boolean isForced() {
 				return jaxbDiscriminatorMapping.isForce();
 			}
 
 			@Override
 			public boolean isInserted() {
 				return jaxbDiscriminatorMapping.isInsert();
 			}
 		};
 	}
 
 	private static MultiTenancySource interpretMultiTenancySource(final RootEntitySourceImpl rootEntitySource) {
 		final JaxbHbmMultiTenancyType jaxbMultiTenancy = rootEntitySource.jaxbEntityMapping().getMultiTenancy();
 		if ( jaxbMultiTenancy == null ) {
 			return null;
 		}
 
 		final RelationalValueSource relationalValueSource = RelationalValueSourceHelper.buildValueSource(
 				rootEntitySource.sourceMappingDocument(),
 				null,
 				new RelationalValueSourceHelper.AbstractColumnsAndFormulasSource() {
 					@Override
 					public XmlElementMetadata getSourceType() {
 						return XmlElementMetadata.MULTI_TENANCY;
 					}
 
 					@Override
 					public String getSourceName() {
 						return null;
 					}
 
 					@Override
 					public String getFormulaAttribute() {
 						return jaxbMultiTenancy.getFormulaAttribute();
 					}
 
 					@Override
 					public String getColumnAttribute() {
 						return jaxbMultiTenancy.getColumnAttribute();
 					}
 					private List columnOrFormulas;
 					@Override
 					public List getColumnOrFormulaElements() {
 						if ( columnOrFormulas == null ) {
 							if ( jaxbMultiTenancy.getColumn() != null ) {
 								if ( jaxbMultiTenancy.getFormula() != null ) {
 									throw new MappingException(
 											String.format(
 													Locale.ENGLISH,
 													"discriminator mapping [%s] named both <column/> and <formula/>, but only one or other allowed",
 													rootEntitySource.getEntityNamingSource().getEntityName()
 											),
 											rootEntitySource.sourceMappingDocument().getOrigin()
 									);
 								}
 								else {
 									columnOrFormulas = Collections.singletonList( jaxbMultiTenancy.getColumn() );
 								}
 							}
 							else {
 								if ( jaxbMultiTenancy.getFormula() != null ) {
 									columnOrFormulas = Collections.singletonList( jaxbMultiTenancy.getColumn() );
 								}
 								else {
 									columnOrFormulas = Collections.emptyList();
 								}
 							}
 						}
 						return columnOrFormulas;
 					}
 
 					@Override
 					public Boolean isNullable() {
 						return false;
 					}
 				}
 		);
 
 		return new MultiTenancySource() {
 			@Override
 			public RelationalValueSource getRelationalValueSource() {
 				return relationalValueSource;
 			}
 
 			@Override
 			public boolean isShared() {
 				return jaxbMultiTenancy.isShared();
 			}
 
 			@Override
 			public boolean bindAsParameter() {
 				return jaxbMultiTenancy.isBindAsParam();
 			}
 		};
 	}
 
 	@Override
 	public InheritanceType getHierarchyInheritanceType() {
 		return hierarchyInheritanceType;
 	}
 
 	@Override
 	public RootEntitySourceImpl getRoot() {
 		return rootEntitySource;
 	}
 
 	public void processSubclass(SubclassEntitySourceImpl subclassEntitySource) {
 		final InheritanceType inheritanceType = Helper.interpretInheritanceType( subclassEntitySource.jaxbEntityMapping() );
 		if ( hierarchyInheritanceType == InheritanceType.NO_INHERITANCE ) {
 			hierarchyInheritanceType = inheritanceType;
 		}
 		else if ( hierarchyInheritanceType != inheritanceType ) {
 			throw new MappingException( "Mixed inheritance strategies not supported", subclassEntitySource.getOrigin() );
 		}
 
 		collectedEntityNames.add( subclassEntitySource.getEntityNamingSource().getEntityName() );
 	}
 
 
 	protected JaxbHbmRootEntityType entityElement() {
 		return rootEntitySource.jaxbEntityMapping();
 	}
 
 	@Override
 	public IdentifierSource getIdentifierSource() {
 		return identifierSource;
 	}
 
 	@Override
 	public VersionAttributeSource getVersionAttributeSource() {
 		return versionAttributeSource;
 	}
 
 	@Override
 	public EntityMode getEntityMode() {
 		return rootEntitySource.determineEntityMode();
 	}
 
 	@Override
 	public boolean isMutable() {
 		return entityElement().isMutable();
 	}
 
 	@Override
 	public boolean isExplicitPolymorphism() {
 		return JaxbHbmPolymorphismEnum.EXPLICIT == entityElement().getPolymorphism();
 	}
 
 	@Override
 	public String getWhere() {
 		return entityElement().getWhere();
 	}
 
 	@Override
 	public String getRowId() {
 		return entityElement().getRowid();
 	}
 
 	@Override
 	public OptimisticLockStyle getOptimisticLockStyle() {
 		return entityElement().getOptimisticLock();
 	}
 
 	@Override
 	public Caching getCaching() {
 		return caching;
 	}
 
 	@Override
 	public Caching getNaturalIdCaching() {
 		return naturalIdCaching;
 	}
 
 	@Override
 	public DiscriminatorSource getDiscriminatorSource() {
 		return discriminatorSource;
 	}
 
 	@Override
 	public MultiTenancySource getMultiTenancySource() {
 		return multiTenancySource;
 	}
 
 	/**
 	 * Package-protected to allow IdentifierSource implementations to access it.
 	 *
 	 * @param mappingDocument The source mapping document
 	 * @param entityNaming The entity naming
 	 * @param jaxbGeneratorMapping The identifier generator mapping
 	 *
 	 * @return The collected information.
 	 */
 	static IdentifierGeneratorDefinition interpretGeneratorDefinition(
 			MappingDocument mappingDocument,
 			EntityNamingSource entityNaming,
 			JaxbHbmGeneratorSpecificationType jaxbGeneratorMapping) {
 		if ( jaxbGeneratorMapping == null ) {
 			return null;
 		}
 
 		final String generatorName = jaxbGeneratorMapping.getClazz();
 		IdentifierGeneratorDefinition identifierGeneratorDefinition = mappingDocument.getMetadataCollector()
 				.getIdentifierGenerator( generatorName );
 		if ( identifierGeneratorDefinition == null ) {
 			identifierGeneratorDefinition = new IdentifierGeneratorDefinition(
 					entityNaming.getEntityName() + '.' + generatorName,
 					generatorName,
 					Helper.extractParameters( jaxbGeneratorMapping.getConfigParameters() )
 			);
 		}
 		return identifierGeneratorDefinition;
 	}
 
 	public Set<String> getContainedEntityNames() {
 		return collectedEntityNames;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/model/source/internal/hbm/ModelBinder.java b/hibernate-core/src/main/java/org/hibernate/boot/model/source/internal/hbm/ModelBinder.java
index 30eee0229a..74064f7a8d 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/model/source/internal/hbm/ModelBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/model/source/internal/hbm/ModelBinder.java
@@ -1,3541 +1,3562 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2014, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.boot.model.source.internal.hbm;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Properties;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.EntityMode;
 import org.hibernate.FetchMode;
 import org.hibernate.boot.MappingException;
 import org.hibernate.boot.jaxb.Origin;
 import org.hibernate.boot.jaxb.hbm.spi.JaxbHbmNamedNativeQueryType;
 import org.hibernate.boot.jaxb.hbm.spi.JaxbHbmNamedQueryType;
 import org.hibernate.boot.model.Caching;
 import org.hibernate.boot.model.IdentifierGeneratorDefinition;
 import org.hibernate.boot.model.TruthValue;
 import org.hibernate.boot.model.TypeDefinition;
 import org.hibernate.boot.model.naming.EntityNaming;
 import org.hibernate.boot.model.naming.Identifier;
 import org.hibernate.boot.model.naming.ImplicitBasicColumnNameSource;
 import org.hibernate.boot.model.naming.ImplicitCollectionTableNameSource;
 import org.hibernate.boot.model.naming.ImplicitEntityNameSource;
 import org.hibernate.boot.model.naming.ImplicitIdentifierColumnNameSource;
 import org.hibernate.boot.model.naming.ImplicitIndexColumnNameSource;
 import org.hibernate.boot.model.naming.ImplicitJoinColumnNameSource;
 import org.hibernate.boot.model.naming.ImplicitMapKeyColumnNameSource;
 import org.hibernate.boot.model.naming.ImplicitNamingStrategy;
 import org.hibernate.boot.model.naming.ImplicitUniqueKeyNameSource;
 import org.hibernate.boot.model.naming.ObjectNameNormalizer;
 import org.hibernate.boot.model.relational.Database;
 import org.hibernate.boot.model.relational.Schema;
 import org.hibernate.boot.model.source.internal.ConstraintSecondPass;
 import org.hibernate.boot.model.source.internal.ImplicitColumnNamingSecondPass;
 import org.hibernate.boot.model.source.spi.AnyMappingSource;
 import org.hibernate.boot.model.source.spi.AttributePath;
 import org.hibernate.boot.model.source.spi.AttributeRole;
 import org.hibernate.boot.model.source.spi.AttributeSource;
 import org.hibernate.boot.model.source.spi.CascadeStyleSource;
 import org.hibernate.boot.model.source.spi.CollectionIdSource;
 import org.hibernate.boot.model.source.spi.ColumnSource;
 import org.hibernate.boot.model.source.spi.CompositeIdentifierSource;
 import org.hibernate.boot.model.source.spi.ConstraintSource;
 import org.hibernate.boot.model.source.spi.EmbeddableSource;
 import org.hibernate.boot.model.source.spi.EntitySource;
 import org.hibernate.boot.model.source.spi.FilterSource;
 import org.hibernate.boot.model.source.spi.HibernateTypeSource;
 import org.hibernate.boot.model.source.spi.IdentifiableTypeSource;
 import org.hibernate.boot.model.source.spi.IdentifierSourceAggregatedComposite;
 import org.hibernate.boot.model.source.spi.IdentifierSourceNonAggregatedComposite;
 import org.hibernate.boot.model.source.spi.IdentifierSourceSimple;
 import org.hibernate.boot.model.source.spi.InLineViewSource;
 import org.hibernate.boot.model.source.spi.LocalMetadataBuildingContext;
 import org.hibernate.boot.model.source.spi.NaturalIdMutability;
 import org.hibernate.boot.model.source.spi.Orderable;
 import org.hibernate.boot.model.source.spi.PluralAttributeElementSourceBasic;
 import org.hibernate.boot.model.source.spi.PluralAttributeElementSourceEmbedded;
 import org.hibernate.boot.model.source.spi.PluralAttributeElementSourceManyToAny;
 import org.hibernate.boot.model.source.spi.PluralAttributeElementSourceManyToMany;
 import org.hibernate.boot.model.source.spi.PluralAttributeElementSourceOneToMany;
 import org.hibernate.boot.model.source.spi.PluralAttributeMapKeyManyToAnySource;
 import org.hibernate.boot.model.source.spi.PluralAttributeMapKeyManyToManySource;
 import org.hibernate.boot.model.source.spi.PluralAttributeMapKeySourceBasic;
 import org.hibernate.boot.model.source.spi.PluralAttributeMapKeySourceEmbedded;
 import org.hibernate.boot.model.source.spi.PluralAttributeSequentialIndexSource;
 import org.hibernate.boot.model.source.spi.PluralAttributeSource;
 import org.hibernate.boot.model.source.spi.PluralAttributeSourceArray;
 import org.hibernate.boot.model.source.spi.RelationalValueSource;
 import org.hibernate.boot.model.source.spi.RelationalValueSourceContainer;
 import org.hibernate.boot.model.source.spi.SecondaryTableSource;
 import org.hibernate.boot.model.source.spi.SingularAttributeSource;
 import org.hibernate.boot.model.source.spi.SingularAttributeSourceAny;
 import org.hibernate.boot.model.source.spi.SingularAttributeSourceBasic;
 import org.hibernate.boot.model.source.spi.SingularAttributeSourceEmbedded;
 import org.hibernate.boot.model.source.spi.SingularAttributeSourceManyToOne;
 import org.hibernate.boot.model.source.spi.SingularAttributeSourceOneToOne;
 import org.hibernate.boot.model.source.spi.Sortable;
 import org.hibernate.boot.model.source.spi.TableSource;
 import org.hibernate.boot.model.source.spi.TableSpecificationSource;
 import org.hibernate.boot.model.source.spi.VersionAttributeSource;
 import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.boot.spi.InFlightMetadataCollector;
 import org.hibernate.boot.spi.InFlightMetadataCollector.EntityTableXref;
 import org.hibernate.boot.spi.MetadataBuildingContext;
 import org.hibernate.boot.spi.NaturalIdUniqueKeyBinder;
 import org.hibernate.cfg.FkSecondPass;
 import org.hibernate.cfg.SecondPass;
 import org.hibernate.engine.FetchStyle;
 import org.hibernate.engine.FetchTiming;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.id.PersistentIdentifierGenerator;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.log.DeprecationLogger;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.internal.util.compare.EqualsHelper;
 import org.hibernate.loader.PropertyPath;
 import org.hibernate.mapping.Any;
 import org.hibernate.mapping.Array;
 import org.hibernate.mapping.AttributeContainer;
 import org.hibernate.mapping.Backref;
 import org.hibernate.mapping.Bag;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.DenormalizedTable;
 import org.hibernate.mapping.DependantValue;
 import org.hibernate.mapping.IdentifierBag;
 import org.hibernate.mapping.IdentifierCollection;
 import org.hibernate.mapping.IndexBackref;
 import org.hibernate.mapping.IndexedCollection;
 import org.hibernate.mapping.Join;
 import org.hibernate.mapping.JoinedSubclass;
 import org.hibernate.mapping.KeyValue;
 import org.hibernate.mapping.ManyToOne;
 import org.hibernate.mapping.OneToMany;
 import org.hibernate.mapping.OneToOne;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.PrimitiveArray;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.mapping.Selectable;
 import org.hibernate.mapping.Set;
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.mapping.SingleTableSubclass;
 import org.hibernate.mapping.SyntheticProperty;
 import org.hibernate.mapping.Table;
 import org.hibernate.mapping.UnionSubclass;
 import org.hibernate.mapping.UniqueKey;
 import org.hibernate.mapping.Value;
 import org.hibernate.tuple.GeneratedValueGeneration;
 import org.hibernate.tuple.GenerationTiming;
 import org.hibernate.type.DiscriminatorType;
 import org.hibernate.type.ForeignKeyDirection;
 
 /**
  * Responsible for coordinating the binding of all information inside entity tags ({@code <class/>}, etc).
  *
  * @author Steve Ebersole
  */
 public class ModelBinder {
 	private static final CoreMessageLogger log = CoreLogging.messageLogger( ModelBinder.class );
 	private static final boolean debugEnabled = log.isDebugEnabled();
 
 	private final Database database;
 	private final ObjectNameNormalizer objectNameNormalizer;
 	private final ImplicitNamingStrategy implicitNamingStrategy;
 	private final RelationalObjectBinder relationalObjectBinder;
 
 	public static ModelBinder prepare(MetadataBuildingContext context) {
 		return new ModelBinder( context );
 	}
 
 	public ModelBinder(final MetadataBuildingContext context) {
 		this.database = context.getMetadataCollector().getDatabase();
 		this.objectNameNormalizer = new ObjectNameNormalizer() {
 			@Override
 			protected MetadataBuildingContext getBuildingContext() {
 				return context;
 			}
 		};
 		this.implicitNamingStrategy = context.getBuildingOptions().getImplicitNamingStrategy();
 		this.relationalObjectBinder = new RelationalObjectBinder( context );
 	}
 
 	public void finishUp(MetadataBuildingContext context) {
 	}
 
 	public void bindEntityHierarchy(EntityHierarchySourceImpl hierarchySource) {
 		final RootClass rootEntityDescriptor = new RootClass();
 		bindRootEntity( hierarchySource, rootEntityDescriptor );
 		hierarchySource.getRoot()
 				.getLocalMetadataBuildingContext()
 				.getMetadataCollector()
 				.addEntityBinding( rootEntityDescriptor );
 
 		switch ( hierarchySource.getHierarchyInheritanceType() ) {
 			case NO_INHERITANCE: {
 				// nothing to do
 				break;
 			}
 			case DISCRIMINATED: {
 				bindDiscriminatorSubclassEntities( hierarchySource.getRoot(), rootEntityDescriptor );
 				break;
 			}
 			case JOINED: {
 				bindJoinedSubclassEntities( hierarchySource.getRoot(), rootEntityDescriptor );
 				break;
 			}
 			case UNION: {
 				bindUnionSubclassEntities( hierarchySource.getRoot(), rootEntityDescriptor );
 				break;
 			}
 		}
 	}
 
 	private void bindRootEntity(EntityHierarchySourceImpl hierarchySource, RootClass rootEntityDescriptor) {
 		final MappingDocument mappingDocument = hierarchySource.getRoot().sourceMappingDocument();
 
 		bindBasicEntityValues(
 				mappingDocument,
 				hierarchySource.getRoot(),
 				rootEntityDescriptor
 		);
 
 		final Table primaryTable = bindEntityTableSpecification(
 				mappingDocument,
 				hierarchySource.getRoot().getPrimaryTable(),
 				null,
 				hierarchySource.getRoot(),
 				rootEntityDescriptor
 		);
 
 		rootEntityDescriptor.setTable( primaryTable );
 		if ( log.isDebugEnabled() ) {
 			log.debugf( "Mapping class: %s -> %s", rootEntityDescriptor.getEntityName(), primaryTable.getName() );
 		}
 
 		rootEntityDescriptor.setOptimisticLockStyle( hierarchySource.getOptimisticLockStyle() );
 		rootEntityDescriptor.setMutable( hierarchySource.isMutable() );
 		rootEntityDescriptor.setWhere( hierarchySource.getWhere() );
 		rootEntityDescriptor.setExplicitPolymorphism( hierarchySource.isExplicitPolymorphism() );
 
 		bindEntityIdentifier(
 				mappingDocument,
 				hierarchySource,
 				rootEntityDescriptor
 		);
 
 		if ( hierarchySource.getVersionAttributeSource() != null ) {
 			bindEntityVersion(
 					mappingDocument,
 					hierarchySource,
 					rootEntityDescriptor
 			);
 		}
 
 		if ( hierarchySource.getDiscriminatorSource() != null ) {
 			bindEntityDiscriminator(
 					mappingDocument,
 					hierarchySource,
 					rootEntityDescriptor
 			);
 		}
 
 		applyCaching( mappingDocument, hierarchySource.getCaching(), rootEntityDescriptor );
 
 		// Primary key constraint
 		rootEntityDescriptor.createPrimaryKey();
 
 		bindAllEntityAttributes(
 				mappingDocument,
 				hierarchySource.getRoot(),
 				rootEntityDescriptor
 		);
 
 		if ( hierarchySource.getNaturalIdCaching() != null ) {
 			if ( hierarchySource.getNaturalIdCaching().getRequested() == TruthValue.TRUE ) {
 				rootEntityDescriptor.setNaturalIdCacheRegionName( hierarchySource.getNaturalIdCaching().getRegion() );
 			}
 		}
 	}
 
 	private void applyCaching(MappingDocument mappingDocument, Caching caching, RootClass rootEntityDescriptor) {
 		if ( caching == null || caching.getRequested() == TruthValue.UNKNOWN ) {
 			// see if JPA's SharedCacheMode indicates we should implicitly apply caching
 			//
 			// here we only really look for ALL.  Ideally we could look at NONE too as a means
 			// to selectively disable all caching, but historically hbm.xml mappings were processed
 			// outside this concept and whether to cache or not was defined wholly by what
 			// is defined in the mapping document.  So for backwards compatibility we
 			// do not consider ENABLE_SELECTIVE nor DISABLE_SELECTIVE here.
 			//
 			// Granted, ALL was not historically considered either, but I have a practical
 			// reason for wanting to support this... our legacy tests built using
 			// Configuration applied a similar logic but that capability is no longer
 			// accessible from Configuration
 			switch ( mappingDocument.getBuildingOptions().getSharedCacheMode() ) {
 				case ALL: {
 					caching = new Caching(
 							null,
 							mappingDocument.getBuildingOptions().getImplicitCacheAccessType(),
 							false,
 							TruthValue.UNKNOWN
 					);
 				}
 				case NONE: {
 					// Ideally we'd disable all caching...
 					break;
 				}
 				case ENABLE_SELECTIVE: {
 					// this is default behavior for hbm.xml
 					break;
 				}
 				case DISABLE_SELECTIVE: {
 					// really makes no sense for hbm.xml
 					break;
 				}
 				default: {
 					// null or UNSPECIFIED, nothing to do.  IMO for hbm.xml this is equivalent
 					// to ENABLE_SELECTIVE
 					break;
 				}
 			}
 		}
 
 		if ( caching == null || caching.getRequested() == TruthValue.FALSE ) {
 			return;
 		}
 
 		if ( caching.getAccessType() != null ) {
 			rootEntityDescriptor.setCacheConcurrencyStrategy( caching.getAccessType().getExternalName() );
 		}
 		else {
 			rootEntityDescriptor.setCacheConcurrencyStrategy( mappingDocument.getBuildingOptions().getImplicitCacheAccessType().getExternalName() );
 		}
 		rootEntityDescriptor.setCacheRegionName( caching.getRegion() );
 		rootEntityDescriptor.setLazyPropertiesCacheable( caching.isCacheLazyProperties() );
 		rootEntityDescriptor.setCachingExplicitlyRequested( caching.getRequested() != TruthValue.UNKNOWN );
 	}
 
 	private void bindEntityIdentifier(
 			MappingDocument mappingDocument,
 			EntityHierarchySourceImpl hierarchySource,
 			RootClass rootEntityDescriptor) {
 		switch ( hierarchySource.getIdentifierSource().getNature() ) {
 			case SIMPLE: {
 				bindSimpleEntityIdentifier(
 						mappingDocument,
 						hierarchySource,
 						rootEntityDescriptor
 				);
 				break;
 			}
 			case AGGREGATED_COMPOSITE: {
 				bindAggregatedCompositeEntityIdentifier(
 						mappingDocument,
 						hierarchySource,
 						rootEntityDescriptor
 				);
 				break;
 			}
 			case NON_AGGREGATED_COMPOSITE: {
 				bindNonAggregatedCompositeEntityIdentifier(
 						mappingDocument,
 						hierarchySource,
 						rootEntityDescriptor
 				);
 				break;
 			}
 			default: {
 				throw new MappingException(
 						String.format(
 								Locale.ENGLISH,
 								"Unexpected entity identifier nature [%s] for entity %s",
 								hierarchySource.getIdentifierSource().getNature(),
 								hierarchySource.getRoot().getEntityNamingSource().getEntityName()
 						),
 						mappingDocument.getOrigin()
 				);
 			}
 		}
 	}
 
 	private void bindBasicEntityValues(
 			MappingDocument sourceDocument,
 			AbstractEntitySourceImpl entitySource,
 			PersistentClass entityDescriptor) {
 		entityDescriptor.setEntityName( entitySource.getEntityNamingSource().getEntityName() );
 		entityDescriptor.setJpaEntityName( entitySource.getEntityNamingSource().getJpaEntityName() );
 		entityDescriptor.setClassName( entitySource.getEntityNamingSource().getClassName() );
 
 		entityDescriptor.setDiscriminatorValue(
 				entitySource.getDiscriminatorMatchValue() != null
 						? entitySource.getDiscriminatorMatchValue()
 						: entityDescriptor.getEntityName()
 		);
 
 		// NOTE : entitySource#isLazy already accounts for MappingDefaults#areEntitiesImplicitlyLazy
 		if ( StringHelper.isNotEmpty( entitySource.getProxy() ) ) {
 			final String qualifiedProxyName = sourceDocument.qualifyClassName( entitySource.getProxy() );
 			entityDescriptor.setProxyInterfaceName( qualifiedProxyName );
 			entityDescriptor.setLazy( true );
 		}
 		else if ( entitySource.isLazy() ) {
 			entityDescriptor.setProxyInterfaceName( entityDescriptor.getClassName() );
 			entityDescriptor.setLazy( true );
 		}
 		else {
 			entityDescriptor.setProxyInterfaceName( null );
 			entityDescriptor.setLazy( false );
 		}
 
 		entityDescriptor.setAbstract( entitySource.isAbstract() );
 
 		sourceDocument.getMetadataCollector().addImport(
 				entitySource.getEntityNamingSource().getEntityName(),
 				entitySource.getEntityNamingSource().getEntityName()
 		);
 
 		if ( sourceDocument.getMappingDefaults().isAutoImportEnabled() && entitySource.getEntityNamingSource().getEntityName().indexOf( '.' ) > 0 ) {
 			sourceDocument.getMetadataCollector().addImport(
 					StringHelper.unqualify( entitySource.getEntityNamingSource().getEntityName() ),
 					entitySource.getEntityNamingSource().getEntityName()
 			);
 		}
 
 		if ( entitySource.getTuplizerClassMap() != null ) {
 			if ( entitySource.getTuplizerClassMap().size() > 1 ) {
 				DeprecationLogger.DEPRECATION_LOGGER.logDeprecationOfMultipleEntityModeSupport();
 			}
 			for ( Map.Entry<EntityMode,String> tuplizerEntry : entitySource.getTuplizerClassMap().entrySet() ) {
 				entityDescriptor.addTuplizer(
 						tuplizerEntry.getKey(),
 						tuplizerEntry.getValue()
 				);
 			}
 		}
 
 		if ( StringHelper.isNotEmpty( entitySource.getXmlNodeName() ) ) {
 			DeprecationLogger.DEPRECATION_LOGGER.logDeprecationOfDomEntityModeSupport();
 			entityDescriptor.setNodeName( entitySource.getXmlNodeName() );
 		}
 
 		entityDescriptor.setDynamicInsert( entitySource.isDynamicInsert() );
 		entityDescriptor.setDynamicUpdate( entitySource.isDynamicUpdate() );
 		entityDescriptor.setBatchSize( entitySource.getBatchSize() );
 		entityDescriptor.setSelectBeforeUpdate( entitySource.isSelectBeforeUpdate() );
 
 		if ( StringHelper.isNotEmpty( entitySource.getCustomPersisterClassName() ) ) {
 			try {
 				entityDescriptor.setEntityPersisterClass(
 						sourceDocument.getClassLoaderAccess().classForName( entitySource.getCustomPersisterClassName() )
 				);
 			}
 			catch (ClassLoadingException e) {
 				throw new MappingException(
 						String.format(
 								Locale.ENGLISH,
 								"Unable to load specified persister class : %s",
 								entitySource.getCustomPersisterClassName()
 						),
 						e,
 						sourceDocument.getOrigin()
 				);
 			}
 		}
 
 		bindCustomSql( sourceDocument, entitySource, entityDescriptor );
 
 		for ( String tableName : entitySource.getSynchronizedTableNames() ) {
 			entityDescriptor.addSynchronizedTable( tableName );
 		}
 
 		for ( FilterSource filterSource : entitySource.getFilterSources() ) {
 			String condition = filterSource.getCondition();
 			if ( condition == null ) {
 				final FilterDefinition filterDefinition = sourceDocument.getMetadataCollector().getFilterDefinition( filterSource.getName() );
 				if ( filterDefinition != null ) {
 					condition = filterDefinition.getDefaultFilterCondition();
 				}
 			}
 
 			entityDescriptor.addFilter(
 					filterSource.getName(),
 					condition,
 					filterSource.shouldAutoInjectAliases(),
 					filterSource.getAliasToTableMap(),
 					filterSource.getAliasToEntityMap()
 			);
 		}
 
 		for ( JaxbHbmNamedQueryType namedQuery : entitySource.getNamedQueries() ) {
 			NamedQueryBinder.processNamedQuery(
 					sourceDocument,
 					namedQuery,
 					entitySource.getEntityNamingSource().getEntityName() + "."
 			);
 		}
 		for ( JaxbHbmNamedNativeQueryType namedQuery : entitySource.getNamedNativeQueries() ) {
 			NamedQueryBinder.processNamedNativeQuery(
 					sourceDocument,
 					namedQuery,
 					entitySource.getEntityNamingSource().getEntityName() + "."
 			);
 		}
 
 		entityDescriptor.setMetaAttributes( entitySource.getToolingHintContext().getMetaAttributeMap() );
 	}
 
 	private void bindDiscriminatorSubclassEntities(
 			AbstractEntitySourceImpl entitySource,
 			PersistentClass superEntityDescriptor) {
 		for ( IdentifiableTypeSource subType : entitySource.getSubTypes() ) {
 			final SingleTableSubclass subEntityDescriptor = new SingleTableSubclass( superEntityDescriptor );
 			bindDiscriminatorSubclassEntity( (SubclassEntitySourceImpl) subType, subEntityDescriptor );
 			superEntityDescriptor.addSubclass( subEntityDescriptor );
 			entitySource.getLocalMetadataBuildingContext().getMetadataCollector().addEntityBinding( subEntityDescriptor );
 		}
 	}
 
 	private void bindDiscriminatorSubclassEntity(
 			SubclassEntitySourceImpl entitySource,
 			SingleTableSubclass entityDescriptor) {
 
 		bindBasicEntityValues(
 				entitySource.sourceMappingDocument(),
 				entitySource,
 				entityDescriptor
 		);
 
 		final String superEntityName = ( (EntitySource) entitySource.getSuperType() ).getEntityNamingSource()
 				.getEntityName();
 		final EntityTableXref superEntityTableXref = entitySource.getLocalMetadataBuildingContext()
 				.getMetadataCollector()
 				.getEntityTableXref( superEntityName );
 		if ( superEntityTableXref == null ) {
 			throw new MappingException(
 					String.format(
 							Locale.ENGLISH,
 							"Unable to locate entity table xref for entity [%s] super-type [%s]",
 							entityDescriptor.getEntityName(),
 							superEntityName
 					),
 					entitySource.origin()
 			);
 		}
 
 		entitySource.getLocalMetadataBuildingContext().getMetadataCollector().addEntityTableXref(
 				entitySource.getEntityNamingSource().getEntityName(),
 				database.toIdentifier(
 						entitySource.getLocalMetadataBuildingContext().getMetadataCollector().getLogicalTableName(
 								entityDescriptor.getTable()
 						)
 				),
 				entityDescriptor.getTable(),
 				superEntityTableXref
 		);
 
 		bindAllEntityAttributes(
 				entitySource.sourceMappingDocument(),
 				entitySource,
 				entityDescriptor
 		);
 
 		bindDiscriminatorSubclassEntities( entitySource, entityDescriptor );
 	}
 
 	private void bindJoinedSubclassEntities(
 			AbstractEntitySourceImpl entitySource,
 			PersistentClass superEntityDescriptor) {
 		for ( IdentifiableTypeSource subType : entitySource.getSubTypes() ) {
 			final JoinedSubclass subEntityDescriptor = new JoinedSubclass( superEntityDescriptor );
 			bindJoinedSubclassEntity( (JoinedSubclassEntitySourceImpl) subType, subEntityDescriptor );
 			superEntityDescriptor.addSubclass( subEntityDescriptor );
 			entitySource.getLocalMetadataBuildingContext().getMetadataCollector().addEntityBinding( subEntityDescriptor );
 		}
 	}
 
 	private void bindJoinedSubclassEntity(
 			JoinedSubclassEntitySourceImpl entitySource,
 			JoinedSubclass entityDescriptor) {
 		MappingDocument mappingDocument = entitySource.sourceMappingDocument();
 
 		bindBasicEntityValues(
 				mappingDocument,
 				entitySource,
 				entityDescriptor
 		);
 
 		final Table primaryTable = bindEntityTableSpecification(
 				mappingDocument,
 				entitySource.getPrimaryTable(),
 				null,
 				entitySource,
 				entityDescriptor
 		);
 
 		entityDescriptor.setTable( primaryTable );
 		if ( log.isDebugEnabled() ) {
 			log.debugf( "Mapping joined-subclass: %s -> %s", entityDescriptor.getEntityName(), primaryTable.getName() );
 		}
 
 		// KEY
 		final SimpleValue keyBinding = new DependantValue(
 				mappingDocument.getMetadataCollector(),
 				primaryTable,
 				entityDescriptor.getIdentifier()
 		);
 		entityDescriptor.setKey( keyBinding );
 		keyBinding.setCascadeDeleteEnabled( entitySource.isCascadeDeleteEnabled() );
 		relationalObjectBinder.bindColumns(
 				mappingDocument,
 				entitySource.getPrimaryKeyColumnSources(),
 				keyBinding,
 				false,
 				new RelationalObjectBinder.ColumnNamingDelegate() {
 					int count = 0;
 					@Override
 					public Identifier determineImplicitName(LocalMetadataBuildingContext context) {
 						final Column column = primaryTable.getPrimaryKey().getColumn( count++ );
 						return database.toIdentifier( column.getQuotedName() );
 					}
 				}
 		);
 
 		// model.getKey().setType( new Type( model.getIdentifier() ) );
 		entityDescriptor.createPrimaryKey();
 		entityDescriptor.createForeignKey();
 
 		// todo : tooling hints
 
 		bindAllEntityAttributes(
 				entitySource.sourceMappingDocument(),
 				entitySource,
 				entityDescriptor
 		);
 
 		bindJoinedSubclassEntities( entitySource, entityDescriptor );
 	}
 
 	private void bindUnionSubclassEntities(
 			EntitySource entitySource,
 			PersistentClass superEntityDescriptor) {
 		for ( IdentifiableTypeSource subType : entitySource.getSubTypes() ) {
 			final UnionSubclass subEntityDescriptor = new UnionSubclass( superEntityDescriptor );
 			bindUnionSubclassEntity( (SubclassEntitySourceImpl) subType, subEntityDescriptor );
 			superEntityDescriptor.addSubclass( subEntityDescriptor );
 			entitySource.getLocalMetadataBuildingContext().getMetadataCollector().addEntityBinding( subEntityDescriptor );
 		}
 	}
 
 	private void bindUnionSubclassEntity(
 			SubclassEntitySourceImpl entitySource,
 			UnionSubclass entityDescriptor) {
 		MappingDocument mappingDocument = entitySource.sourceMappingDocument();
 
 		bindBasicEntityValues(
 				mappingDocument,
 				entitySource,
 				entityDescriptor
 		);
 
 		final Table primaryTable = bindEntityTableSpecification(
 				mappingDocument,
 				entitySource.getPrimaryTable(),
 				entityDescriptor.getSuperclass().getTable(),
 				entitySource,
 				entityDescriptor
 		);
 		entityDescriptor.setTable( primaryTable );
 
 		if ( log.isDebugEnabled() ) {
 			log.debugf( "Mapping union-subclass: %s -> %s", entityDescriptor.getEntityName(), primaryTable.getName() );
 		}
 
 		// todo : tooling hints
 
 		bindAllEntityAttributes(
 				entitySource.sourceMappingDocument(),
 				entitySource,
 				entityDescriptor
 		);
 
 		bindUnionSubclassEntities( entitySource, entityDescriptor );
 	}
 
 	private void bindSimpleEntityIdentifier(
 			MappingDocument sourceDocument,
 			final EntityHierarchySourceImpl hierarchySource,
 			RootClass rootEntityDescriptor) {
 		final IdentifierSourceSimple idSource = (IdentifierSourceSimple) hierarchySource.getIdentifierSource();
 
 		final SimpleValue idValue = new SimpleValue(
 				sourceDocument.getMetadataCollector(),
 				rootEntityDescriptor.getTable()
 		);
 		rootEntityDescriptor.setIdentifier( idValue );
 
 		bindSimpleValueType(
 				sourceDocument,
 				idSource.getIdentifierAttributeSource().getTypeInformation(),
 				idValue
 		);
 
 		final String propertyName = idSource.getIdentifierAttributeSource().getName();
 		if ( propertyName == null || !rootEntityDescriptor.hasPojoRepresentation() ) {
 			if ( !idValue.isTypeSpecified() ) {
 				throw new MappingException(
 						"must specify an identifier type: " + rootEntityDescriptor.getEntityName(),
 						sourceDocument.getOrigin()
 				);
 			}
 		}
 		else {
 			idValue.setTypeUsingReflection( rootEntityDescriptor.getClassName(), propertyName );
 		}
 
 		relationalObjectBinder.bindColumnsAndFormulas(
 				sourceDocument,
 				( (RelationalValueSourceContainer) idSource.getIdentifierAttributeSource() ).getRelationalValueSources(),
 				idValue,
 				false,
 				new RelationalObjectBinder.ColumnNamingDelegate() {
 					@Override
 					public Identifier determineImplicitName(final LocalMetadataBuildingContext context) {
 						context.getBuildingOptions().getImplicitNamingStrategy().determineIdentifierColumnName(
 								new ImplicitIdentifierColumnNameSource() {
 									@Override
 									public EntityNaming getEntityNaming() {
 										return hierarchySource.getRoot().getEntityNamingSource();
 									}
 
 									@Override
 									public AttributePath getIdentifierAttributePath() {
 										return idSource.getIdentifierAttributeSource().getAttributePath();
 									}
 
 									@Override
 									public MetadataBuildingContext getBuildingContext() {
 										return context;
 									}
 								}
 						);
 						return database.toIdentifier( propertyName );
 					}
 				}
 		);
 
 		if ( propertyName != null ) {
 			Property prop = new Property();
 			prop.setValue( idValue );
 			bindProperty(
 					sourceDocument,
 					idSource.getIdentifierAttributeSource(),
 					prop
 			);
 			rootEntityDescriptor.setIdentifierProperty( prop );
 			rootEntityDescriptor.setDeclaredIdentifierProperty( prop );
 		}
 
 		makeIdentifier(
 				sourceDocument,
 				idSource.getIdentifierGeneratorDescriptor(),
 				idSource.getUnsavedValue(),
 				idValue
 		);
 	}
 
 	private void makeIdentifier(
 			final MappingDocument sourceDocument,
 			IdentifierGeneratorDefinition generator,
 			String unsavedValue,
 			SimpleValue identifierValue) {
 		if ( generator != null ) {
 			String generatorName = generator.getStrategy();
 			Properties params = new Properties();
 
 			// see if the specified generator name matches a registered <identifier-generator/>
 			IdentifierGeneratorDefinition generatorDef = sourceDocument.getMetadataCollector().getIdentifierGenerator( generatorName );
 			if ( generatorDef != null ) {
 				generatorName = generatorDef.getStrategy();
 				params.putAll( generatorDef.getParameters() );
 			}
 
 			identifierValue.setIdentifierGeneratorStrategy( generatorName );
 
 			// YUCK!  but cannot think of a clean way to do this given the string-config based scheme
 			params.put( PersistentIdentifierGenerator.IDENTIFIER_NORMALIZER, objectNameNormalizer);
 
 			if ( database.getDefaultSchema().getPhysicalName().getSchema() != null ) {
 				params.setProperty(
 						PersistentIdentifierGenerator.SCHEMA,
 						database.getDefaultSchema().getPhysicalName().getSchema().render( database.getDialect() )
 				);
 			}
 			if ( database.getDefaultSchema().getPhysicalName().getCatalog() != null ) {
 				params.setProperty(
 						PersistentIdentifierGenerator.CATALOG,
 						database.getDefaultSchema().getPhysicalName().getCatalog().render( database.getDialect() )
 				);
 			}
 
 			params.putAll( generator.getParameters() );
 
 			identifierValue.setIdentifierGeneratorProperties( params );
 		}
 
 		identifierValue.getTable().setIdentifierValue( identifierValue );
 
 		if ( StringHelper.isNotEmpty( unsavedValue ) ) {
 			identifierValue.setNullValue( unsavedValue );
 		}
 		else {
 			if ( "assigned".equals( identifierValue.getIdentifierGeneratorStrategy() ) ) {
 				identifierValue.setNullValue( "undefined" );
 			}
 			else {
 				identifierValue.setNullValue( null );
 			}
 		}
 	}
 
 	private void bindAggregatedCompositeEntityIdentifier(
 			MappingDocument mappingDocument,
 			EntityHierarchySourceImpl hierarchySource,
 			RootClass rootEntityDescriptor) {
 
 		// an aggregated composite-id is a composite-id that defines a singular
 		// (composite) attribute as part of the entity to represent the id.
 
 		final IdentifierSourceAggregatedComposite identifierSource
 				= (IdentifierSourceAggregatedComposite) hierarchySource.getIdentifierSource();
 
 		final Component cid = new Component( mappingDocument.getMetadataCollector(), rootEntityDescriptor );
 		cid.setKey( true );
 		rootEntityDescriptor.setIdentifier( cid );
 
 		final String idClassName = extractIdClassName( identifierSource );
 
 		final String idPropertyName = identifierSource.getIdentifierAttributeSource().getName();
 		final String pathPart = idPropertyName == null ? "<id>" : idPropertyName;
 
 		bindComponent(
 				mappingDocument,
 				hierarchySource.getRoot().getAttributeRoleBase().append( pathPart ).getFullPath(),
 				identifierSource.getEmbeddableSource(),
 				cid,
 				idClassName,
 				rootEntityDescriptor.getClassName(),
 				idPropertyName,
 				idClassName == null && idPropertyName == null,
 				identifierSource.getEmbeddableSource().isDynamic(),
 				identifierSource.getIdentifierAttributeSource().getXmlNodeName()
 		);
 
 		finishBindingCompositeIdentifier(
 				mappingDocument,
 				rootEntityDescriptor,
 				identifierSource,
 				cid,
 				idPropertyName
 		);
 	}
 
 	private String extractIdClassName(IdentifierSourceAggregatedComposite identifierSource) {
 		if ( identifierSource.getEmbeddableSource().getTypeDescriptor() == null ) {
 			return null;
 		}
 
 		return identifierSource.getEmbeddableSource().getTypeDescriptor().getName();
 	}
 
 	private static final String ID_MAPPER_PATH_PART = '<' + PropertyPath.IDENTIFIER_MAPPER_PROPERTY + '>';
 
 	private void bindNonAggregatedCompositeEntityIdentifier(
 			MappingDocument mappingDocument,
 			EntityHierarchySourceImpl hierarchySource,
 			RootClass rootEntityDescriptor) {
 		final IdentifierSourceNonAggregatedComposite identifierSource
 				= (IdentifierSourceNonAggregatedComposite) hierarchySource.getIdentifierSource();
 
 		final Component cid = new Component( mappingDocument.getMetadataCollector(), rootEntityDescriptor );
 		cid.setKey( true );
 		rootEntityDescriptor.setIdentifier( cid );
 
 		final String idClassName = extractIdClassName( identifierSource );
 
 		bindComponent(
 				mappingDocument,
 				hierarchySource.getRoot().getAttributeRoleBase().append( "<id>" ).getFullPath(),
 				identifierSource.getEmbeddableSource(),
 				cid,
 				idClassName,
 				rootEntityDescriptor.getClassName(),
 				null,
 				idClassName == null,
 				false,
 				null
 		);
 
 		if ( idClassName != null ) {
 			// we also need to bind the "id mapper".  ugh, terrible name.  Basically we need to
 			// create a virtual (embedded) composite for the non-aggregated attributes on the entity
 			// itself.
 			final Component mapper = new Component( mappingDocument.getMetadataCollector(), rootEntityDescriptor );
 			bindComponent(
 					mappingDocument,
 					hierarchySource.getRoot().getAttributeRoleBase().append( ID_MAPPER_PATH_PART ).getFullPath(),
 					identifierSource.getEmbeddableSource(),
 					mapper,
 					rootEntityDescriptor.getClassName(),
 					null,
 					null,
 					true,
 					false,
 					null
 			);
 
 			rootEntityDescriptor.setIdentifierMapper(mapper);
 			Property property = new Property();
 			property.setName( PropertyPath.IDENTIFIER_MAPPER_PROPERTY );
 			property.setNodeName( "id" );
 			property.setUpdateable( false );
 			property.setInsertable( false );
 			property.setValue( mapper );
 			property.setPropertyAccessorName( "embedded" );
 			rootEntityDescriptor.addProperty( property );
 		}
 
 		finishBindingCompositeIdentifier( mappingDocument, rootEntityDescriptor, identifierSource, cid, null );
 	}
 
 	private String extractIdClassName(IdentifierSourceNonAggregatedComposite identifierSource) {
 		if ( identifierSource.getIdClassSource() == null ) {
 			return null;
 		}
 
 		if ( identifierSource.getIdClassSource().getTypeDescriptor() == null ) {
 			return null;
 		}
 
 		return identifierSource.getIdClassSource().getTypeDescriptor().getName();
 	}
 
 	private void finishBindingCompositeIdentifier(
 			MappingDocument sourceDocument,
 			RootClass rootEntityDescriptor,
-			CompositeIdentifierSource identifierSource, Component cid, String propertyName) {
+			CompositeIdentifierSource identifierSource,
+			Component cid,
+			String propertyName) {
 		if ( propertyName == null ) {
 			rootEntityDescriptor.setEmbeddedIdentifier( cid.isEmbedded() );
 			if ( cid.isEmbedded() ) {
 				// todo : what is the implication of this?
 				cid.setDynamic( !rootEntityDescriptor.hasPojoRepresentation() );
 				/*
 				 * Property prop = new Property(); prop.setName("id");
 				 * prop.setPropertyAccessorName("embedded"); prop.setValue(id);
 				 * entity.setIdentifierProperty(prop);
 				 */
 			}
 		}
 		else {
 			Property prop = new Property();
 			prop.setValue( cid );
 			bindProperty(
 					sourceDocument,
 					( (IdentifierSourceAggregatedComposite) identifierSource ).getIdentifierAttributeSource(),
 					prop
 			);
 			rootEntityDescriptor.setIdentifierProperty( prop );
 			rootEntityDescriptor.setDeclaredIdentifierProperty( prop );
 		}
 
 		makeIdentifier(
 				sourceDocument,
 				identifierSource.getIdentifierGeneratorDescriptor(),
 				null,
 				cid
 		);
 	}
 
 	private void bindEntityVersion(
 			MappingDocument sourceDocument,
 			EntityHierarchySourceImpl hierarchySource,
 			RootClass rootEntityDescriptor) {
 		final VersionAttributeSource versionAttributeSource = hierarchySource.getVersionAttributeSource();
 
 		final SimpleValue versionValue = new SimpleValue(
 				sourceDocument.getMetadataCollector(),
 				rootEntityDescriptor.getTable()
 		);
 
 		bindSimpleValueType(
 				sourceDocument,
 				versionAttributeSource.getTypeInformation(),
 				versionValue
 		);
 
 		relationalObjectBinder.bindColumnsAndFormulas(
 				sourceDocument,
 				versionAttributeSource.getRelationalValueSources(),
 				versionValue,
 				false,
 				new RelationalObjectBinder.ColumnNamingDelegate() {
 					@Override
 					public Identifier determineImplicitName(LocalMetadataBuildingContext context) {
 						return implicitNamingStrategy.determineBasicColumnName( versionAttributeSource );
 					}
 				}
 		);
 
 		Property prop = new Property();
 		prop.setValue( versionValue );
 		bindProperty(
 				sourceDocument,
 				versionAttributeSource,
 				prop
 		);
 
 		// for version properties marked as being generated, make sure they are "always"
 		// generated; aka, "insert" is invalid; this is dis-allowed by the DTD,
 		// but just to make sure...
 		if ( prop.getValueGenerationStrategy() != null ) {
 			if ( prop.getValueGenerationStrategy().getGenerationTiming() == GenerationTiming.INSERT ) {
 				throw new MappingException(
 						"'generated' attribute cannot be 'insert' for version/timestamp property",
 						sourceDocument.getOrigin()
 				);
 			}
 		}
 
 		if ( versionAttributeSource.getUnsavedValue() != null ) {
 			versionValue.setNullValue( versionAttributeSource.getUnsavedValue() );
 		}
 		else {
 			versionValue.setNullValue( "undefined" );
 		}
 
 		rootEntityDescriptor.setVersion( prop );
 		rootEntityDescriptor.addProperty( prop );
 	}
 
 	private void bindEntityDiscriminator(
 			MappingDocument sourceDocument,
 			final EntityHierarchySourceImpl hierarchySource,
 			RootClass rootEntityDescriptor) {
 		final SimpleValue discriminatorValue = new SimpleValue(
 				sourceDocument.getMetadataCollector(),
 				rootEntityDescriptor.getTable()
 		);
 		rootEntityDescriptor.setDiscriminator( discriminatorValue );
 
 		String typeName = hierarchySource.getDiscriminatorSource().getExplicitHibernateTypeName();
 		if ( typeName == null ) {
 			typeName = "string";
 		}
 		bindSimpleValueType(
 				sourceDocument,
 				new HibernateTypeSourceImpl( typeName ),
 				discriminatorValue
 		);
 
 		relationalObjectBinder.bindColumnOrFormula(
 				sourceDocument,
 				hierarchySource.getDiscriminatorSource().getDiscriminatorRelationalValueSource(),
 				discriminatorValue,
 				false,
 				new RelationalObjectBinder.ColumnNamingDelegate() {
 					@Override
 					public Identifier determineImplicitName(final LocalMetadataBuildingContext context) {
 						return implicitNamingStrategy.determineDiscriminatorColumnName(
 								hierarchySource.getDiscriminatorSource()
 						);
 					}
 				}
 		);
 
 		rootEntityDescriptor.setPolymorphic( true );
 		rootEntityDescriptor.setDiscriminatorInsertable( hierarchySource.getDiscriminatorSource().isInserted() );
 
 		// todo : currently isForced() is defined as boolean, not Boolean
 		//		although it has always been that way (DTD too)
 		final boolean force = hierarchySource.getDiscriminatorSource().isForced()
 				|| sourceDocument.getBuildingOptions().shouldImplicitlyForceDiscriminatorInSelect();
 		rootEntityDescriptor.setForceDiscriminator( force );
 	}
 
 	private void bindAllEntityAttributes(
 			MappingDocument mappingDocument,
 			EntitySource entitySource,
 			PersistentClass entityDescriptor) {
 		final EntityTableXref entityTableXref = mappingDocument.getMetadataCollector().getEntityTableXref(
 				entityDescriptor.getEntityName()
 		);
 		if ( entityTableXref == null ) {
 			throw new AssertionFailure(
 					String.format(
 							Locale.ENGLISH,
 							"Unable to locate EntityTableXref for entity [%s] : %s",
 							entityDescriptor.getEntityName(),
 							mappingDocument.getOrigin()
 					)
 			);
 		}
 
 		// make sure we bind secondary tables first!
 		for ( SecondaryTableSource secondaryTableSource : entitySource.getSecondaryTableMap().values() ) {
 			final Join secondaryTableJoin = new Join();
 			secondaryTableJoin.setPersistentClass( entityDescriptor );
 			bindSecondaryTable(
 					mappingDocument,
 					secondaryTableSource,
 					secondaryTableJoin,
 					entityTableXref
 			);
 			entityDescriptor.addJoin( secondaryTableJoin );
 		}
 
 		for ( AttributeSource attributeSource : entitySource.attributeSources() ) {
 			if ( PluralAttributeSource.class.isInstance( attributeSource ) ) {
 				// plural attribute
 				final Property attribute = createPluralAttribute(
 						mappingDocument,
 						(PluralAttributeSource) attributeSource,
 						entityDescriptor
 				);
 				entityDescriptor.addProperty( attribute );
 			}
 			else {
 				// singular attribute
 				if ( SingularAttributeSourceBasic.class.isInstance( attributeSource ) ) {
 					final SingularAttributeSourceBasic basicAttributeSource = (SingularAttributeSourceBasic) attributeSource;
 					final Identifier tableName = determineTable( mappingDocument, basicAttributeSource.getName(), basicAttributeSource );
 					final AttributeContainer attributeContainer;
 					final Table table;
 					final Join secondaryTableJoin = entityTableXref.locateJoin( tableName );
 					if ( secondaryTableJoin == null ) {
 						table = entityDescriptor.getTable();
 						attributeContainer = entityDescriptor;
 					}
 					else {
 						table = secondaryTableJoin.getTable();
 						attributeContainer = secondaryTableJoin;
 					}
 
 					final Property attribute = createBasicAttribute(
 							mappingDocument,
 							basicAttributeSource,
 							new SimpleValue( mappingDocument.getMetadataCollector(), table ),
 							entityDescriptor.getClassName()
 					);
 
 					if ( secondaryTableJoin != null ) {
 						attribute.setOptional( secondaryTableJoin.isOptional() );
 					}
 
 					attributeContainer.addProperty( attribute );
 
 					handleNaturalIdBinding(
 							mappingDocument,
 							entityDescriptor,
 							attribute,
 							basicAttributeSource.getNaturalIdMutability()
 					);
 				}
 				else if ( SingularAttributeSourceEmbedded.class.isInstance( attributeSource ) ) {
 					final SingularAttributeSourceEmbedded embeddedAttributeSource = (SingularAttributeSourceEmbedded) attributeSource;
 					final Identifier tableName = determineTable( mappingDocument, embeddedAttributeSource );
 					final AttributeContainer attributeContainer;
 					final Table table;
 					final Join secondaryTableJoin = entityTableXref.locateJoin( tableName );
 					if ( secondaryTableJoin == null ) {
 						table = entityDescriptor.getTable();
 						attributeContainer = entityDescriptor;
 					}
 					else {
 						table = secondaryTableJoin.getTable();
 						attributeContainer = secondaryTableJoin;
 					}
 
 					final Property attribute = createEmbeddedAttribute(
 							mappingDocument,
 							(SingularAttributeSourceEmbedded) attributeSource,
 							new Component( mappingDocument.getMetadataCollector(), table, entityDescriptor ),
 							entityDescriptor.getClassName()
 					);
 
 					if ( secondaryTableJoin != null ) {
 						attribute.setOptional( secondaryTableJoin.isOptional() );
 					}
 
 					attributeContainer.addProperty( attribute );
 
 					handleNaturalIdBinding(
 							mappingDocument,
 							entityDescriptor,
 							attribute,
 							embeddedAttributeSource.getNaturalIdMutability()
 					);
 				}
 				else if ( SingularAttributeSourceManyToOne.class.isInstance( attributeSource ) ) {
 					final SingularAttributeSourceManyToOne manyToOneAttributeSource = (SingularAttributeSourceManyToOne) attributeSource;
 					final Identifier tableName = determineTable( mappingDocument, manyToOneAttributeSource.getName(), manyToOneAttributeSource );
 					final AttributeContainer attributeContainer;
 					final Table table;
 					final Join secondaryTableJoin = entityTableXref.locateJoin( tableName );
 					if ( secondaryTableJoin == null ) {
 						table = entityDescriptor.getTable();
 						attributeContainer = entityDescriptor;
 					}
 					else {
 						table = secondaryTableJoin.getTable();
 						attributeContainer = secondaryTableJoin;
 					}
 
 					final Property attribute = createManyToOneAttribute(
 							mappingDocument,
 							manyToOneAttributeSource,
 							new ManyToOne( mappingDocument.getMetadataCollector(), table ),
 							entityDescriptor.getClassName()
 					);
 
 					if ( secondaryTableJoin != null ) {
 						attribute.setOptional( secondaryTableJoin.isOptional() );
 					}
 
 					attributeContainer.addProperty( attribute );
 
 					handleNaturalIdBinding(
 							mappingDocument,
 							entityDescriptor,
 							attribute,
 							manyToOneAttributeSource.getNaturalIdMutability()
 					);
 				}
 				else if ( SingularAttributeSourceOneToOne.class.isInstance( attributeSource ) ) {
 					final SingularAttributeSourceOneToOne oneToOneAttributeSource = (SingularAttributeSourceOneToOne) attributeSource;
 					final Table table = entityDescriptor.getTable();
 					final Property attribute = createOneToOneAttribute(
 							mappingDocument,
 							oneToOneAttributeSource,
 							new OneToOne( mappingDocument.getMetadataCollector(), table, entityDescriptor ),
 							entityDescriptor.getClassName()
 					);
 					entityDescriptor.addProperty( attribute );
 
 					handleNaturalIdBinding(
 							mappingDocument,
 							entityDescriptor,
 							attribute,
 							oneToOneAttributeSource.getNaturalIdMutability()
 					);
 				}
 				else if ( SingularAttributeSourceAny.class.isInstance( attributeSource ) ) {
 					final SingularAttributeSourceAny anyAttributeSource = (SingularAttributeSourceAny) attributeSource;
 					final Identifier tableName = determineTable(
 							mappingDocument,
 							anyAttributeSource.getName(),
 							anyAttributeSource.getKeySource().getRelationalValueSources()
 					);
 					final AttributeContainer attributeContainer;
 					final Table table;
 					final Join secondaryTableJoin = entityTableXref.locateJoin( tableName );
 					if ( secondaryTableJoin == null ) {
 						table = entityDescriptor.getTable();
 						attributeContainer = entityDescriptor;
 					}
 					else {
 						table = secondaryTableJoin.getTable();
 						attributeContainer = secondaryTableJoin;
 					}
 
 					final Property attribute = createAnyAssociationAttribute(
 							mappingDocument,
 							anyAttributeSource,
 							new Any( mappingDocument.getMetadataCollector(), table ),
 							entityDescriptor.getEntityName()
 					);
 
 					if ( secondaryTableJoin != null ) {
 						attribute.setOptional( secondaryTableJoin.isOptional() );
 					}
 
 					attributeContainer.addProperty( attribute );
 
 					handleNaturalIdBinding(
 							mappingDocument,
 							entityDescriptor,
 							attribute,
 							anyAttributeSource.getNaturalIdMutability()
 					);
 				}
 			}
 		}
 
 		registerConstraintSecondPasses( mappingDocument, entitySource, entityTableXref );
 	}
 
 	private void handleNaturalIdBinding(
 			MappingDocument mappingDocument,
 			PersistentClass entityBinding,
 			Property attributeBinding,
 			NaturalIdMutability naturalIdMutability) {
 		if ( naturalIdMutability == NaturalIdMutability.NOT_NATURAL_ID ) {
 			return;
 		}
 
 		attributeBinding.setNaturalIdentifier( true );
 
 		if ( naturalIdMutability == NaturalIdMutability.IMMUTABLE ) {
 			attributeBinding.setUpdateable( false );
 		}
 
 		NaturalIdUniqueKeyBinder ukBinder = mappingDocument.getMetadataCollector().locateNaturalIdUniqueKeyBinder(
 				entityBinding.getEntityName()
 		);
 
 		if ( ukBinder == null ) {
 			ukBinder = new NaturalIdUniqueKeyBinderImpl( mappingDocument, entityBinding );
 			mappingDocument.getMetadataCollector().registerNaturalIdUniqueKeyBinder(
 					entityBinding.getEntityName(),
 					ukBinder
 			);
 		}
 
 		ukBinder.addAttributeBinding( attributeBinding );
 	}
 
 	private void registerConstraintSecondPasses(
 			MappingDocument mappingDocument,
 			EntitySource entitySource,
 			final EntityTableXref entityTableXref) {
 		if ( entitySource.getConstraints() == null ) {
 			return;
 		}
 
 		for ( ConstraintSource constraintSource : entitySource.getConstraints() ) {
 			final String logicalTableName = constraintSource.getTableName();
 			final Table table = entityTableXref.resolveTable( database.toIdentifier( logicalTableName ) );
 
 			mappingDocument.getMetadataCollector().addSecondPass(
 					new ConstraintSecondPass(
 							mappingDocument,
 							table,
 							constraintSource
 					)
 			);
 		}
 	}
 
 	private Property createPluralAttribute(
 			MappingDocument sourceDocument,
 			PluralAttributeSource attributeSource,
 			PersistentClass entityDescriptor) {
 		final Collection collectionBinding;
 
 		if ( attributeSource instanceof PluralAttributeSourceListImpl ) {
 			collectionBinding = new org.hibernate.mapping.List( sourceDocument.getMetadataCollector(), entityDescriptor );
 			bindCollectionMetadata( sourceDocument, attributeSource, collectionBinding );
 
 			registerSecondPass(
 					new PluralAttributeListSecondPass(
 							sourceDocument,
 							(IndexedPluralAttributeSource) attributeSource,
 							(org.hibernate.mapping.List) collectionBinding
 					),
 					sourceDocument
 			);
 		}
 		else if ( attributeSource instanceof PluralAttributeSourceSetImpl ) {
 			collectionBinding = new Set( sourceDocument.getMetadataCollector(), entityDescriptor );
 			bindCollectionMetadata( sourceDocument, attributeSource, collectionBinding );
 
 			registerSecondPass(
 					new PluralAttributeSetSecondPass( sourceDocument, attributeSource, collectionBinding ),
 					sourceDocument
 			);
 		}
 		else if ( attributeSource instanceof PluralAttributeSourceMapImpl ) {
 			collectionBinding = new org.hibernate.mapping.Map( sourceDocument.getMetadataCollector(), entityDescriptor );
 			bindCollectionMetadata( sourceDocument, attributeSource, collectionBinding );
 
 			registerSecondPass(
 					new PluralAttributeMapSecondPass(
 							sourceDocument,
 							(IndexedPluralAttributeSource) attributeSource,
 							(org.hibernate.mapping.Map) collectionBinding
 					),
 					sourceDocument
 			);
 		}
 		else if ( attributeSource instanceof PluralAttributeSourceBagImpl ) {
 			collectionBinding = new Bag( sourceDocument.getMetadataCollector(), entityDescriptor );
 			bindCollectionMetadata( sourceDocument, attributeSource, collectionBinding );
 
 			registerSecondPass(
 					new PluralAttributeBagSecondPass( sourceDocument, attributeSource, collectionBinding ),
 					sourceDocument
 			);
 		}
 		else if ( attributeSource instanceof PluralAttributeSourceIdBagImpl ) {
 			collectionBinding = new IdentifierBag( sourceDocument.getMetadataCollector(), entityDescriptor );
 			bindCollectionMetadata( sourceDocument, attributeSource, collectionBinding );
 
 			registerSecondPass(
 					new PluralAttributeIdBagSecondPass( sourceDocument, attributeSource, collectionBinding ),
 					sourceDocument
 			);
 		}
 		else if ( attributeSource instanceof PluralAttributeSourceArrayImpl ) {
 			final PluralAttributeSourceArray arraySource = (PluralAttributeSourceArray) attributeSource;
 			collectionBinding = new Array( sourceDocument.getMetadataCollector(), entityDescriptor );
 			bindCollectionMetadata( sourceDocument, attributeSource, collectionBinding );
 
 			( (Array) collectionBinding ).setElementClassName(
 					sourceDocument.qualifyClassName( arraySource.getElementClass() )
 			);
 
 			registerSecondPass(
 					new PluralAttributeArraySecondPass(
 							sourceDocument,
 							arraySource,
 							(Array) collectionBinding
 					),
 					sourceDocument
 			);
 		}
 		else if ( attributeSource instanceof PluralAttributeSourcePrimitiveArrayImpl ) {
 			collectionBinding = new PrimitiveArray( sourceDocument.getMetadataCollector(), entityDescriptor );
 			bindCollectionMetadata( sourceDocument, attributeSource, collectionBinding );
 
 			registerSecondPass(
 					new PluralAttributePrimitiveArraySecondPass(
 							sourceDocument,
 							(IndexedPluralAttributeSource) attributeSource,
 							(PrimitiveArray) collectionBinding
 					),
 					sourceDocument
 			);
 		}
 		else {
 			throw new AssertionFailure(
 					"Unexpected PluralAttributeSource type : " + attributeSource.getClass().getName()
 			);
 		}
 
 		sourceDocument.getMetadataCollector().addCollectionBinding( collectionBinding );
 
 		final Property attribute = new Property();
 		attribute.setValue( collectionBinding );
 		bindProperty(
 				sourceDocument,
 				attributeSource,
 				attribute
 		);
 
 		return attribute;
 	}
 
 	private void bindCollectionMetadata(MappingDocument mappingDocument, PluralAttributeSource source, Collection binding) {
 		binding.setRole( source.getAttributeRole().getFullPath() );
 		binding.setInverse( source.isInverse() );
 		binding.setMutable( source.isMutable() );
 		binding.setOptimisticLocked( source.isIncludedInOptimisticLocking() );
 
 		if ( source.getCustomPersisterClassName() != null ) {
 			binding.setCollectionPersisterClass(
 					mappingDocument.getClassLoaderAccess().classForName(
 							mappingDocument.qualifyClassName( source.getCustomPersisterClassName() )
 					)
 			);
 		}
 
 		applyCaching( mappingDocument, source.getCaching(), binding );
 
 		// bind the collection type info
 		String typeName = source.getTypeInformation().getName();
 		Map typeParameters = new HashMap();
 		if ( typeName != null ) {
 			// see if there is a corresponding type-def
 			final TypeDefinition typeDef = mappingDocument.getMetadataCollector().getTypeDefinition( typeName );
 			if ( typeDef != null ) {
 				typeName = typeDef.getTypeImplementorClass().getName();
 				if ( typeDef.getParameters() != null ) {
 					typeParameters.putAll( typeDef.getParameters() );
 				}
 			}
 			else {
 				// it could be a unqualified class name, in which case we should qualify
 				// it with the implicit package name for this context, if one.
 				typeName = mappingDocument.qualifyClassName( typeName );
 			}
 		}
 		if ( source.getTypeInformation().getParameters() != null ) {
 			typeParameters.putAll( source.getTypeInformation().getParameters() );
 		}
 
 		binding.setTypeName( typeName );
 		binding.setTypeParameters( typeParameters );
 
 		if ( source.getFetchCharacteristics().getFetchTiming() == FetchTiming.DELAYED ) {
 			binding.setLazy( true );
 			binding.setExtraLazy( source.getFetchCharacteristics().isExtraLazy() );
 		}
 		else {
 			binding.setLazy( false );
 		}
 
 		switch ( source.getFetchCharacteristics().getFetchStyle() ) {
 			case SELECT: {
 				binding.setFetchMode( FetchMode.SELECT );
 				break;
 			}
 			case JOIN: {
 				binding.setFetchMode( FetchMode.JOIN );
 				break;
 			}
 			case BATCH: {
 				binding.setFetchMode( FetchMode.SELECT );
 				binding.setBatchSize( source.getFetchCharacteristics().getBatchSize() );
 				break;
 			}
 			case SUBSELECT: {
 				binding.setFetchMode( FetchMode.SELECT );
 				binding.setSubselectLoadable( true );
 				// todo : this could totally be done using a "symbol map" approach
 				binding.getOwner().setSubselectLoadableCollections( true );
 				break;
 			}
 			default: {
 				throw new AssertionFailure( "Unexpected FetchStyle : " + source.getFetchCharacteristics().getFetchStyle().name() );
 			}
 		}
 
 		for ( String name : source.getSynchronizedTableNames() ) {
 			binding.getSynchronizedTables().add( name );
 		}
 
 		binding.setWhere( source.getWhere() );
 		binding.setLoaderName( source.getCustomLoaderName() );
 		if ( source.getCustomSqlInsert() != null ) {
 			binding.setCustomSQLInsert(
 					source.getCustomSqlInsert().getSql(),
 					source.getCustomSqlInsert().isCallable(),
 					source.getCustomSqlInsert().getCheckStyle()
 			);
 		}
 		if ( source.getCustomSqlUpdate() != null ) {
 			binding.setCustomSQLUpdate(
 					source.getCustomSqlUpdate().getSql(),
 					source.getCustomSqlUpdate().isCallable(),
 					source.getCustomSqlUpdate().getCheckStyle()
 			);
 		}
 		if ( source.getCustomSqlDelete() != null ) {
 			binding.setCustomSQLDelete(
 					source.getCustomSqlDelete().getSql(),
 					source.getCustomSqlDelete().isCallable(),
 					source.getCustomSqlDelete().getCheckStyle()
 			);
 		}
 		if ( source.getCustomSqlDeleteAll() != null ) {
 			binding.setCustomSQLDeleteAll(
 					source.getCustomSqlDeleteAll().getSql(),
 					source.getCustomSqlDeleteAll().isCallable(),
 					source.getCustomSqlDeleteAll().getCheckStyle()
 			);
 		}
 
 		if ( source instanceof Sortable ) {
 			final Sortable sortable = (Sortable) source;
 			if ( sortable.isSorted() ) {
 				binding.setSorted( true );
 				if ( ! sortable.getComparatorName().equals( "natural" ) ) {
 					binding.setComparatorClassName( sortable.getComparatorName() );
 				}
 			}
 			else {
 				binding.setSorted( false );
 			}
 		}
 
 		if ( source instanceof Orderable ) {
 			if ( ( (Orderable) source ).isOrdered() ) {
 				binding.setOrderBy( ( (Orderable) source ).getOrder() );
 			}
 		}
 
 		final String cascadeStyle = source.getCascadeStyleName();
 		if ( cascadeStyle != null && cascadeStyle.contains( "delete-orphan" ) ) {
 			binding.setOrphanDelete( true );
 		}
 
 		for ( FilterSource filterSource : source.getFilterSources() ) {
 			String condition = filterSource.getCondition();
 			if ( condition == null ) {
 				final FilterDefinition filterDefinition = mappingDocument.getMetadataCollector().getFilterDefinition( filterSource.getName() );
 				if ( filterDefinition != null ) {
 					condition = filterDefinition.getDefaultFilterCondition();
 				}
 			}
 
 			binding.addFilter(
 					filterSource.getName(),
 					condition,
 					filterSource.shouldAutoInjectAliases(),
 					filterSource.getAliasToTableMap(),
 					filterSource.getAliasToEntityMap()
 			);
 		}
 	}
 
 	private void applyCaching(MappingDocument mappingDocument, Caching caching, Collection collection) {
 		if ( caching == null || caching.getRequested() == TruthValue.UNKNOWN ) {
 			// see if JPA's SharedCacheMode indicates we should implicitly apply caching
 			switch ( mappingDocument.getBuildingOptions().getSharedCacheMode() ) {
 				case ALL: {
 					caching = new Caching(
 							null,
 							mappingDocument.getBuildingOptions().getImplicitCacheAccessType(),
 							false,
 							TruthValue.UNKNOWN
 					);
 				}
 				case NONE: {
 					// Ideally we'd disable all caching...
 					break;
 				}
 				case ENABLE_SELECTIVE: {
 					// this is default behavior for hbm.xml
 					break;
 				}
 				case DISABLE_SELECTIVE: {
 					// really makes no sense for hbm.xml
 					break;
 				}
 				default: {
 					// null or UNSPECIFIED, nothing to do.  IMO for hbm.xml this is equivalent
 					// to ENABLE_SELECTIVE
 					break;
 				}
 			}
 		}
 
 		if ( caching == null || caching.getRequested() == TruthValue.FALSE ) {
 			return;
 		}
 
 		if ( caching.getAccessType() != null ) {
 			collection.setCacheConcurrencyStrategy( caching.getAccessType().getExternalName() );
 		}
 		else {
 			collection.setCacheConcurrencyStrategy( mappingDocument.getBuildingOptions().getImplicitCacheAccessType().getExternalName() );
 		}
 		collection.setCacheRegionName( caching.getRegion() );
 //		collection.setCachingExplicitlyRequested( caching.getRequested() != TruthValue.UNKNOWN );
 	}
 
 	private Identifier determineTable(
 			MappingDocument sourceDocument,
 			String attributeName,
 			RelationalValueSourceContainer relationalValueSourceContainer) {
 		return determineTable( sourceDocument, attributeName, relationalValueSourceContainer.getRelationalValueSources() );
 	}
 
 	private Identifier determineTable(
 			MappingDocument mappingDocument,
 			SingularAttributeSourceEmbedded embeddedAttributeSource) {
 		Identifier tableName = null;
 		for ( AttributeSource attributeSource : embeddedAttributeSource.getEmbeddableSource().attributeSources() ) {
 			final Identifier determinedName;
 			if ( RelationalValueSourceContainer.class.isInstance( attributeSource ) ) {
 				determinedName = determineTable(
 						mappingDocument,
 						embeddedAttributeSource.getAttributeRole().getFullPath(),
 						(RelationalValueSourceContainer) attributeSource
 
 				);
 			}
 			else if ( SingularAttributeSourceEmbedded.class.isInstance( attributeSource ) ) {
 				determinedName = determineTable( mappingDocument, (SingularAttributeSourceEmbedded) attributeSource );
 			}
 			else if ( SingularAttributeSourceAny.class.isInstance( attributeSource ) ) {
 				determinedName = determineTable(
 						mappingDocument,
 						attributeSource.getAttributeRole().getFullPath(),
 						( (SingularAttributeSourceAny) attributeSource ).getKeySource().getRelationalValueSources()
 				);
 			}
 			else {
 				continue;
 			}
 
 			if (  EqualsHelper.equals( tableName, determinedName ) ) {
 				continue;
 			}
 
 			if ( tableName != null ) {
 				throw new MappingException(
 						String.format(
 								Locale.ENGLISH,
 								"Attribute [%s] referenced columns from multiple tables: %s, %s",
 								embeddedAttributeSource.getAttributeRole().getFullPath(),
 								tableName,
 								determinedName
 						),
 						mappingDocument.getOrigin()
 				);
 			}
 
 			tableName = determinedName;
 		}
 
 		return tableName;
 	}
 
 	private Identifier determineTable(
 			MappingDocument mappingDocument,
 			String attributeName,
 			List<RelationalValueSource> relationalValueSources) {
 		String tableName = null;
 		for ( RelationalValueSource relationalValueSource : relationalValueSources ) {
 			if ( ColumnSource.class.isInstance( relationalValueSource ) ) {
 				final ColumnSource columnSource = (ColumnSource) relationalValueSource;
 				if ( EqualsHelper.equals( tableName, columnSource.getContainingTableName() ) ) {
 					continue;
 				}
 
 				if ( tableName != null ) {
 					throw new MappingException(
 							String.format(
 									Locale.ENGLISH,
 									"Attribute [%s] referenced columns from multiple tables: %s, %s",
 									attributeName,
 									tableName,
 									columnSource.getContainingTableName()
 							),
 							mappingDocument.getOrigin()
 					);
 				}
 
 				tableName = columnSource.getContainingTableName();
 			}
 		}
 
 		return database.toIdentifier( tableName );
 	}
 
 	private void bindSecondaryTable(
 			MappingDocument mappingDocument,
 			SecondaryTableSource secondaryTableSource,
 			Join secondaryTableJoin,
 			final EntityTableXref entityTableXref) {
 		final PersistentClass persistentClass = secondaryTableJoin.getPersistentClass();
 
 		final Identifier catalogName = determineCatalogName( secondaryTableSource.getTableSource() );
 		final Identifier schemaName = determineSchemaName( secondaryTableSource.getTableSource() );
 		final Schema schema = database.locateSchema( catalogName, schemaName );
 
 		Table secondaryTable;
 		final Identifier logicalTableName;
 
 		if ( TableSource.class.isInstance( secondaryTableSource.getTableSource() ) ) {
 			final TableSource tableSource = (TableSource) secondaryTableSource.getTableSource();
 			logicalTableName = database.toIdentifier( tableSource.getExplicitTableName() );
 			secondaryTable = schema.locateTable( logicalTableName );
 			if ( secondaryTable == null ) {
 				secondaryTable = schema.createTable( logicalTableName, false );
 			}
 			else {
 				secondaryTable.setAbstract( false );
 			}
 
 			secondaryTable.setComment( tableSource.getComment() );
 		}
 		else {
 			final InLineViewSource inLineViewSource = (InLineViewSource) secondaryTableSource.getTableSource();
 			secondaryTable = new Table(
 					schema,
 					inLineViewSource.getSelectStatement(),
 					false
 			);
 			logicalTableName = Identifier.toIdentifier( inLineViewSource.getLogicalName() );
 		}
 
 		secondaryTableJoin.setTable( secondaryTable );
 		entityTableXref.addSecondaryTable( mappingDocument, logicalTableName, secondaryTableJoin );
 
 		bindCustomSql(
 				mappingDocument,
 				secondaryTableSource,
 				secondaryTableJoin
 		);
 
 		secondaryTableJoin.setSequentialSelect( secondaryTableSource.getFetchStyle() == FetchStyle.SELECT );
 		secondaryTableJoin.setInverse( secondaryTableSource.isInverse() );
 		secondaryTableJoin.setOptional( secondaryTableSource.isOptional() );
 
 		if ( log.isDebugEnabled() ) {
 			log.debugf(
 					"Mapping entity secondary-table: %s -> %s",
 					persistentClass.getEntityName(),
 					secondaryTable.getName()
 			);
 		}
 
 		final SimpleValue keyBinding = new DependantValue(
 				mappingDocument.getMetadataCollector(),
 				secondaryTable,
 				persistentClass.getIdentifier()
 		);
 		secondaryTableJoin.setKey( keyBinding );
 
 		keyBinding.setCascadeDeleteEnabled( secondaryTableSource.isCascadeDeleteEnabled() );
 
 		// NOTE : no Type info to bind...
 
 		relationalObjectBinder.bindColumns(
 				mappingDocument,
 				secondaryTableSource.getPrimaryKeyColumnSources(),
 				keyBinding,
 				secondaryTableSource.isOptional(),
 				new RelationalObjectBinder.ColumnNamingDelegate() {
 					int count = 0;
 					@Override
 					public Identifier determineImplicitName(LocalMetadataBuildingContext context) {
 						final Column correspondingColumn = entityTableXref.getPrimaryTable().getPrimaryKey().getColumn( count++ );
 						return database.toIdentifier( correspondingColumn.getQuotedName() );
 					}
 				}
 		);
 
 		keyBinding.setForeignKeyName( secondaryTableSource.getExplicitForeignKeyName() );
 
 		secondaryTableJoin.createPrimaryKey();
 		secondaryTableJoin.createForeignKey();
 	}
 
 	private Property createEmbeddedAttribute(
 			MappingDocument sourceDocument,
 			SingularAttributeSourceEmbedded embeddedSource,
 			Component componentBinding,
 			String containingClassName) {
 		final String attributeName = embeddedSource.getName();
 
 		bindComponent(
 				sourceDocument,
 				embeddedSource.getEmbeddableSource(),
 				componentBinding,
 				containingClassName,
 				attributeName,
 				embeddedSource.getXmlNodeName(),
 				embeddedSource.isVirtualAttribute()
 		);
 
 		prepareValueTypeViaReflection(
 				sourceDocument,
 				componentBinding,
 				componentBinding.getComponentClassName(),
 				attributeName,
 				embeddedSource.getAttributeRole()
 		);
 
 		componentBinding.createForeignKey();
 
 		final Property attribute;
 		if ( embeddedSource.isVirtualAttribute() ) {
 			attribute = new SyntheticProperty() {
 				@Override
 				public String getPropertyAccessorName() {
 					return "embedded";
 				}
 			};
 		}
 		else {
 			attribute = new Property();
 		}
 		attribute.setValue( componentBinding );
 		bindProperty(
 				sourceDocument,
 				embeddedSource,
 				attribute
 		);
 
+		final String xmlNodeName = determineXmlNodeName( embeddedSource, componentBinding.getOwner().getNodeName() );
+		componentBinding.setNodeName( xmlNodeName );
+		attribute.setNodeName( xmlNodeName );
+
 		return attribute;
 	}
 
 	private Property createBasicAttribute(
 			MappingDocument sourceDocument,
 			final SingularAttributeSourceBasic attributeSource,
 			SimpleValue value,
 			String containingClassName) {
 		final String attributeName = attributeSource.getName();
 
 		bindSimpleValueType(
 				sourceDocument,
 				attributeSource.getTypeInformation(),
 				value
 		);
 
 		relationalObjectBinder.bindColumnsAndFormulas(
 				sourceDocument,
 				attributeSource.getRelationalValueSources(),
 				value,
 				true,
 				new RelationalObjectBinder.ColumnNamingDelegate() {
 					@Override
 					public Identifier determineImplicitName(LocalMetadataBuildingContext context) {
 						return implicitNamingStrategy.determineBasicColumnName( attributeSource );
 					}
 				}
 		);
 
 
 		prepareValueTypeViaReflection(
 				sourceDocument,
 				value,
 				containingClassName,
 				attributeName,
 				attributeSource.getAttributeRole()
 		);
 
 //		// this is done here 'cos we might only know the type here (ugly!)
 //		// TODO: improve this a lot:
 //		if ( value instanceof ToOne ) {
 //			ToOne toOne = (ToOne) value;
 //			String propertyRef = toOne.getReferencedEntityAttributeName();
 //			if ( propertyRef != null ) {
 //				mappings.addUniquePropertyReference( toOne.getReferencedEntityName(), propertyRef );
 //			}
 //			toOne.setCascadeDeleteEnabled( "cascade".equals( subnode.attributeValue( "on-delete" ) ) );
 //		}
 //		else if ( value instanceof Collection ) {
 //			Collection coll = (Collection) value;
 //			String propertyRef = coll.getReferencedEntityAttributeName();
 //			// not necessarily a *unique* property reference
 //			if ( propertyRef != null ) {
 //				mappings.addPropertyReference( coll.getOwnerEntityName(), propertyRef );
 //			}
 //		}
 
 		value.createForeignKey();
 
 		Property property = new Property();
 		property.setValue( value );
 		bindProperty(
 				sourceDocument,
 				attributeSource,
 				property
 		);
 
 		return property;
 	}
 
 	private Property createOneToOneAttribute(
 			MappingDocument sourceDocument,
 			SingularAttributeSourceOneToOne oneToOneSource,
 			OneToOne oneToOneBinding,
 			String containingClassName) {
 		bindOneToOne( sourceDocument, oneToOneSource, oneToOneBinding );
 
 		prepareValueTypeViaReflection(
 				sourceDocument,
 				oneToOneBinding,
 				containingClassName,
 				oneToOneSource.getName(),
 				oneToOneSource.getAttributeRole()
 		);
 
 		final String propertyRef = oneToOneBinding.getReferencedPropertyName();
 		if ( propertyRef != null ) {
 			handlePropertyReference(
 					sourceDocument,
 					oneToOneBinding.getReferencedEntityName(),
 					propertyRef,
 					true,
 					"<one-to-one name=\"" + oneToOneSource.getName() + "\"/>"
 			);
 		}
 
 		oneToOneBinding.createForeignKey();
 
 		Property prop = new Property();
 		prop.setValue( oneToOneBinding );
 		bindProperty(
 				sourceDocument,
 				oneToOneSource,
 				prop
 		);
 
 		return prop;
 	}
 
 	private void handlePropertyReference(
 			MappingDocument mappingDocument,
 			String referencedEntityName,
 			String referencedPropertyName,
 			boolean isUnique,
 			String sourceElementSynopsis) {
 		PersistentClass entityBinding = mappingDocument.getMetadataCollector().getEntityBinding( referencedEntityName );
 		if ( entityBinding == null ) {
 			// entity may just not have been processed yet - set up a delayed handler
 			registerDelayedPropertyReferenceHandler(
 					new DelayedPropertyReferenceHandlerImpl(
 							referencedEntityName,
 							referencedPropertyName,
 							isUnique,
 							sourceElementSynopsis,
 							mappingDocument.getOrigin()
 					),
 					mappingDocument
 			);
 		}
 		else {
 			Property propertyBinding = entityBinding.getReferencedProperty( referencedPropertyName );
 			if ( propertyBinding == null ) {
 				// attribute may just not have been processed yet - set up a delayed handler
 				registerDelayedPropertyReferenceHandler(
 						new DelayedPropertyReferenceHandlerImpl(
 								referencedEntityName,
 								referencedPropertyName,
 								isUnique,
 								sourceElementSynopsis,
 								mappingDocument.getOrigin()
 						),
 						mappingDocument
 				);
 			}
 			else {
 				log.tracef(
 						"Property [%s.%s] referenced by property-ref [%s] was available - no need for delayed handling",
 						referencedEntityName,
 						referencedPropertyName,
 						sourceElementSynopsis
 				);
 				if ( isUnique ) {
 					( (SimpleValue) propertyBinding.getValue() ).setAlternateUniqueKey( true );
 				}
 			}
 		}
 	}
 
 	private void registerDelayedPropertyReferenceHandler(
 			DelayedPropertyReferenceHandlerImpl handler,
 			MetadataBuildingContext buildingContext) {
 		log.tracef(
 				"Property [%s.%s] referenced by property-ref [%s] was not yet available - creating delayed handler",
 				handler.referencedEntityName,
 				handler.referencedPropertyName,
 				handler.sourceElementSynopsis
 		);
 		buildingContext.getMetadataCollector().addDelayedPropertyReferenceHandler( handler );
 	}
 
 	public void bindOneToOne(
 			final MappingDocument sourceDocument,
 			final SingularAttributeSourceOneToOne oneToOneSource,
 			final OneToOne oneToOneBinding) {
 		oneToOneBinding.setPropertyName( oneToOneSource.getName() );
 
 		relationalObjectBinder.bindFormulas(
 				sourceDocument,
 				oneToOneSource.getFormulaSources(),
 				oneToOneBinding
 		);
 
 
 		if ( oneToOneSource.isConstrained() ) {
 			if ( oneToOneSource.getCascadeStyleName() != null
 					&& oneToOneSource.getCascadeStyleName().contains( "delete-orphan" ) ) {
 				throw new MappingException(
 						String.format(
 								Locale.ENGLISH,
 								"one-to-one attribute [%s] cannot specify orphan delete cascading as it is constrained",
 								oneToOneSource.getAttributeRole().getFullPath()
 						),
 						sourceDocument.getOrigin()
 				);
 			}
 			oneToOneBinding.setConstrained( true );
 			oneToOneBinding.setForeignKeyType( ForeignKeyDirection.FROM_PARENT );
 		}
 		else {
 			oneToOneBinding.setForeignKeyType( ForeignKeyDirection.TO_PARENT );
 		}
 
 		oneToOneBinding.setLazy( oneToOneSource.getFetchCharacteristics().getFetchTiming() == FetchTiming.DELAYED );
 		oneToOneBinding.setFetchMode(
 				oneToOneSource.getFetchCharacteristics().getFetchStyle() == FetchStyle.SELECT
 						? FetchMode.SELECT
 						: FetchMode.JOIN
 		);
 		oneToOneBinding.setUnwrapProxy( oneToOneSource.getFetchCharacteristics().isUnwrapProxies() );
 
 
 		if ( StringHelper.isNotEmpty( oneToOneSource.getReferencedEntityAttributeName() ) ) {
 			oneToOneBinding.setReferencedPropertyName( oneToOneSource.getReferencedEntityAttributeName() );
 			oneToOneBinding.setReferenceToPrimaryKey( false );
 		}
 		else {
 			oneToOneBinding.setReferenceToPrimaryKey( true );
 		}
 
 		// todo : probably need some reflection here if null
 		oneToOneBinding.setReferencedEntityName( oneToOneSource.getReferencedEntityName() );
 
 		if ( oneToOneSource.isEmbedXml() ) {
 			DeprecationLogger.DEPRECATION_LOGGER.logDeprecationOfEmbedXmlSupport();
 		}
 		oneToOneBinding.setEmbedded( oneToOneSource.isEmbedXml() );
 
 		if ( StringHelper.isNotEmpty( oneToOneSource.getExplicitForeignKeyName() ) ) {
 			oneToOneBinding.setForeignKeyName( oneToOneSource.getExplicitForeignKeyName() );
 		}
 
 		oneToOneBinding.setCascadeDeleteEnabled( oneToOneSource.isCascadeDeleteEnabled() );
 	}
 
 	private Property createManyToOneAttribute(
 			MappingDocument sourceDocument,
 			SingularAttributeSourceManyToOne manyToOneSource,
 			ManyToOne manyToOneBinding,
 			String containingClassName) {
 		final String attributeName = manyToOneSource.getName();
 
 		final String referencedEntityName;
 		if ( manyToOneSource.getReferencedEntityName() != null ) {
 			referencedEntityName = manyToOneSource.getReferencedEntityName();
 		}
 		else {
 			Class reflectedPropertyClass = Helper.reflectedPropertyClass( sourceDocument, containingClassName, attributeName );
 			if ( reflectedPropertyClass != null ) {
 				referencedEntityName = reflectedPropertyClass.getName();
 			}
 			else {
 				prepareValueTypeViaReflection(
 						sourceDocument,
 						manyToOneBinding,
 						containingClassName,
 						attributeName,
 						manyToOneSource.getAttributeRole()
 				);
 				referencedEntityName = manyToOneBinding.getTypeName();
 			}
 		}
 
 		if ( manyToOneSource.isUnique() ) {
 			manyToOneBinding.markAsLogicalOneToOne();
 		}
 
 		bindManyToOneAttribute( sourceDocument, manyToOneSource, manyToOneBinding, referencedEntityName );
 
 		final String propertyRef = manyToOneBinding.getReferencedPropertyName();
 
 		if ( propertyRef != null ) {
 			handlePropertyReference(
 					sourceDocument,
 					manyToOneBinding.getReferencedEntityName(),
 					propertyRef,
 					true,
 					"<many-to-one name=\"" + manyToOneSource.getName() + "\"/>"
 			);
 		}
 
 		Property prop = new Property();
 		prop.setValue( manyToOneBinding );
 		bindProperty(
 				sourceDocument,
 				manyToOneSource,
 				prop
 		);
 
 		if ( StringHelper.isNotEmpty( manyToOneSource.getCascadeStyleName() ) ) {
 			// todo : would be better to delay this the end of binding (second pass, etc)
 			// in order to properly allow for a singular unique column for a many-to-one to
 			// also trigger a "logical one-to-one".  As-is, this can occasionally lead to
 			// false exceptions if the many-to-one column binding is delayed and the
 			// uniqueness is indicated on the <column/> rather than on the <many-to-one/>
 			//
 			// Ideally, would love to see a SimpleValue#validate approach, rather than a
 			// SimpleValue#isValid that is then handled at a higher level (Property, etc).
 			// The reason being that the current approach misses the exact reason
 			// a "validation" fails since it loses "context"
 			if ( manyToOneSource.getCascadeStyleName().contains( "delete-orphan" ) ) {
 				if ( !manyToOneBinding.isLogicalOneToOne() ) {
 					throw new MappingException(
 							String.format(
 									Locale.ENGLISH,
 									"many-to-one attribute [%s] specified delete-orphan but is not specified as unique; " +
 											"remove delete-orphan cascading or specify unique=\"true\"",
 									manyToOneSource.getAttributeRole().getFullPath()
 							),
 							sourceDocument.getOrigin()
 					);
 				}
 			}
 		}
 
 		return prop;
 	}
 
 	private void bindManyToOneAttribute(
 			final MappingDocument sourceDocument,
 			final SingularAttributeSourceManyToOne manyToOneSource,
 			ManyToOne manyToOneBinding,
 			String referencedEntityName) {
 		// NOTE : no type information to bind
 
 		manyToOneBinding.setReferencedEntityName( referencedEntityName );
 		if ( StringHelper.isNotEmpty( manyToOneSource.getReferencedEntityAttributeName() ) ) {
 			manyToOneBinding.setReferencedPropertyName( manyToOneSource.getReferencedEntityAttributeName() );
 			manyToOneBinding.setReferenceToPrimaryKey( false );
 		}
 		else {
 			manyToOneBinding.setReferenceToPrimaryKey( true );
 		}
 
 		manyToOneBinding.setLazy( manyToOneSource.getFetchCharacteristics().getFetchTiming() == FetchTiming.DELAYED );
 		manyToOneBinding.setUnwrapProxy( manyToOneSource.getFetchCharacteristics().isUnwrapProxies() );
 		manyToOneBinding.setFetchMode(
 				manyToOneSource.getFetchCharacteristics().getFetchStyle() == FetchStyle.SELECT
 						? FetchMode.SELECT
 						: FetchMode.JOIN
 		);
 
 		if ( manyToOneSource.isEmbedXml() ) {
 			DeprecationLogger.DEPRECATION_LOGGER.logDeprecationOfEmbedXmlSupport();
 		}
 		manyToOneBinding.setEmbedded( manyToOneSource.isEmbedXml() );
 
 		manyToOneBinding.setIgnoreNotFound( manyToOneSource.isIgnoreNotFound() );
 
 		if ( StringHelper.isNotEmpty( manyToOneSource.getExplicitForeignKeyName() ) ) {
 			manyToOneBinding.setForeignKeyName( manyToOneSource.getExplicitForeignKeyName() );
 		}
 
 		final ManyToOneColumnBinder columnBinder = new ManyToOneColumnBinder(
 				sourceDocument,
 				manyToOneSource,
 				manyToOneBinding,
 				referencedEntityName
 		);
 		final boolean canBindColumnsImmediately = columnBinder.canProcessImmediately();
 		if ( canBindColumnsImmediately ) {
 			columnBinder.doSecondPass( null );
 		}
 		else {
 			sourceDocument.getMetadataCollector().addSecondPass( columnBinder );
 		}
 
 		if ( !manyToOneSource.isIgnoreNotFound() ) {
 			// we skip creating the FK here since this setting tells us there
 			// cannot be a suitable/proper FK
 			final ManyToOneFkSecondPass fkSecondPass = new ManyToOneFkSecondPass(
 					sourceDocument,
 					manyToOneSource,
 					manyToOneBinding,
 					referencedEntityName
 			);
 
 			if ( canBindColumnsImmediately && fkSecondPass.canProcessImmediately() ) {
 				fkSecondPass.doSecondPass( null );
 			}
 			else {
 				sourceDocument.getMetadataCollector().addSecondPass( fkSecondPass );
 			}
 		}
 
 		manyToOneBinding.setCascadeDeleteEnabled( manyToOneSource.isCascadeDeleteEnabled() );
 	}
 
 	private Property createAnyAssociationAttribute(
 			MappingDocument sourceDocument,
 			SingularAttributeSourceAny anyMapping,
 			Any anyBinding,
 			String entityName) {
 		final String attributeName = anyMapping.getName();
 
 		bindAny( sourceDocument, anyMapping, anyBinding, anyMapping.getAttributeRole(), anyMapping.getAttributePath() );
 
 		prepareValueTypeViaReflection( sourceDocument, anyBinding, entityName, attributeName, anyMapping.getAttributeRole() );
 
 		anyBinding.createForeignKey();
 
 		Property prop = new Property();
 		prop.setValue( anyBinding );
 		bindProperty(
 				sourceDocument,
 				anyMapping,
 				prop
 		);
 
 		return prop;
 	}
 
 	private void bindAny(
 			MappingDocument sourceDocument,
 			final AnyMappingSource anyMapping,
 			Any anyBinding,
 			final AttributeRole attributeRole,
 			AttributePath attributePath) {
 		final TypeResolution keyTypeResolution = resolveType(
 				sourceDocument,
 				anyMapping.getKeySource().getTypeSource()
 		);
 		if ( keyTypeResolution != null ) {
 			anyBinding.setIdentifierType( keyTypeResolution.typeName );
 		}
 
 		final TypeResolution discriminatorTypeResolution = resolveType(
 				sourceDocument,
 				anyMapping.getDiscriminatorSource().getTypeSource()
 		);
 
 		if ( discriminatorTypeResolution != null ) {
 			anyBinding.setMetaType( discriminatorTypeResolution.typeName );
 			try {
 				final DiscriminatorType metaType = (DiscriminatorType) sourceDocument.getMetadataCollector()
 						.getTypeResolver()
 						.heuristicType( discriminatorTypeResolution.typeName );
 
 				final HashMap anyValueBindingMap = new HashMap();
 				for ( Map.Entry<String,String> discriminatorValueMappings : anyMapping.getDiscriminatorSource().getValueMappings().entrySet() ) {
 					try {
 						final Object discriminatorValue = metaType.stringToObject( discriminatorValueMappings.getKey() );
 						final String mappedEntityName = sourceDocument.qualifyClassName( discriminatorValueMappings.getValue() );
 
 						//noinspection unchecked
 						anyValueBindingMap.put( discriminatorValue, mappedEntityName );
 					}
 					catch (Exception e) {
 						throw new MappingException(
 								String.format(
 										Locale.ENGLISH,
 										"Unable to interpret <meta-value value=\"%s\" class=\"%s\"/> defined as part of <any/> attribute [%s]",
 										discriminatorValueMappings.getKey(),
 										discriminatorValueMappings.getValue(),
 										attributeRole.getFullPath()
 								),
 								e,
 								sourceDocument.getOrigin()
 						);
 					}
 
 				}
 				anyBinding.setMetaValues( anyValueBindingMap );
 			}
 			catch (ClassCastException e) {
 				throw new MappingException(
 						String.format(
 								Locale.ENGLISH,
 								"Specified meta-type [%s] for <any/> attribute [%s] did not implement DiscriminatorType",
 								discriminatorTypeResolution.typeName,
 								attributeRole.getFullPath()
 						),
 						e,
 						sourceDocument.getOrigin()
 				);
 			}
 		}
 
 		relationalObjectBinder.bindColumnOrFormula(
 				sourceDocument,
 				anyMapping.getDiscriminatorSource().getRelationalValueSource(),
 				anyBinding,
 				true,
 				new RelationalObjectBinder.ColumnNamingDelegate() {
 					@Override
 					public Identifier determineImplicitName(LocalMetadataBuildingContext context) {
 						return implicitNamingStrategy.determineAnyDiscriminatorColumnName(
 								anyMapping.getDiscriminatorSource()
 						);
 					}
 				}
 		);
 
 		relationalObjectBinder.bindColumnsAndFormulas(
 				sourceDocument,
 				anyMapping.getKeySource().getRelationalValueSources(),
 				anyBinding,
 				true,
 				new RelationalObjectBinder.ColumnNamingDelegate() {
 					@Override
 					public Identifier determineImplicitName(LocalMetadataBuildingContext context) {
 						return implicitNamingStrategy.determineAnyKeyColumnName(
 								anyMapping.getKeySource()
 						);
 					}
 				}
 		);
 	}
 
 	private void prepareValueTypeViaReflection(
 			MappingDocument sourceDocument,
 			Value value,
 			String containingClassName,
 			String propertyName,
 			AttributeRole attributeRole) {
 		if ( StringHelper.isEmpty( propertyName ) ) {
 			throw new MappingException(
 					String.format(
 							Locale.ENGLISH,
 							"Attribute mapping must define a name attribute: containingClassName=[%s], propertyName=[%s], role=[%s]",
 							containingClassName,
 							propertyName,
 							attributeRole.getFullPath()
 					),
 					sourceDocument.getOrigin()
 			);
 		}
 
 		try {
 			value.setTypeUsingReflection( containingClassName, propertyName );
 		}
 		catch (org.hibernate.MappingException ome) {
 			throw new MappingException(
 					String.format(
 							Locale.ENGLISH,
 							"Error calling Value#setTypeUsingReflection: containingClassName=[%s], propertyName=[%s], role=[%s]",
 							containingClassName,
 							propertyName,
 							attributeRole.getFullPath()
 					),
 					ome,
 					sourceDocument.getOrigin()
 			);
 		}
 	}
 
 	private void bindProperty(
 			MappingDocument mappingDocument,
 			AttributeSource propertySource,
 			Property property) {
 		property.setName( propertySource.getName() );
-		property.setNodeName( propertySource.getXmlNodeName() );
+		property.setNodeName( determineXmlNodeName( propertySource, null ) );
 
 		property.setPropertyAccessorName(
 				StringHelper.isNotEmpty( propertySource.getPropertyAccessorName() )
 						? propertySource.getPropertyAccessorName()
 						: mappingDocument.getMappingDefaults().getImplicitPropertyAccessorName()
 		);
 
 		if ( propertySource instanceof CascadeStyleSource ) {
 			final CascadeStyleSource cascadeStyleSource = (CascadeStyleSource) propertySource;
 
 			property.setCascade(
 					StringHelper.isNotEmpty( cascadeStyleSource.getCascadeStyleName() )
 							? cascadeStyleSource.getCascadeStyleName()
 							: mappingDocument.getMappingDefaults().getImplicitCascadeStyleName()
 			);
 		}
 
 		property.setOptimisticLocked( propertySource.isIncludedInOptimisticLocking() );
 
 		if ( propertySource.isSingular() ) {
 			final SingularAttributeSource singularAttributeSource = (SingularAttributeSource) propertySource;
 
 			property.setInsertable( singularAttributeSource.isInsertable() );
 			property.setUpdateable( singularAttributeSource.isUpdatable() );
 
 			// NOTE : Property#is refers to whether a property is lazy via bytecode enhancement (not proxies)
 			property.setLazy( singularAttributeSource.isBytecodeLazy() );
 
 			final GenerationTiming generationTiming = singularAttributeSource.getGenerationTiming();
 			if ( generationTiming == GenerationTiming.ALWAYS || generationTiming == GenerationTiming.INSERT ) {
 				// we had generation specified...
 				//   	HBM only supports "database generated values"
 				property.setValueGenerationStrategy( new GeneratedValueGeneration( generationTiming ) );
 
 				// generated properties can *never* be insertable...
 				if ( property.isInsertable() ) {
 					if ( singularAttributeSource.isInsertable() == null ) {
 						// insertable simply because that is the user did not specify
 						// anything; just override it
 						property.setInsertable( false );
 					}
 					else {
 						// the user specifically supplied insert="true",
 						// which constitutes an illegal combo
 						throw new MappingException(
 								String.format(
 										Locale.ENGLISH,
 										"Cannot specify both insert=\"true\" and generated=\"%s\" for property %s",
 										generationTiming.name().toLowerCase(),
 										propertySource.getName()
 								),
 								mappingDocument.getOrigin()
 						);
 					}
 				}
 
 				// properties generated on update can never be updatable...
 				if ( property.isUpdateable() && generationTiming == GenerationTiming.ALWAYS ) {
 					if ( singularAttributeSource.isUpdatable() == null ) {
 						// updatable only because the user did not specify
 						// anything; just override it
 						property.setUpdateable( false );
 					}
 					else {
 						// the user specifically supplied update="true",
 						// which constitutes an illegal combo
 						throw new MappingException(
 								String.format(
 										Locale.ENGLISH,
 										"Cannot specify both update=\"true\" and generated=\"%s\" for property %s",
 										generationTiming.name().toLowerCase(),
 										propertySource.getName()
 								),
 								mappingDocument.getOrigin()
 						);
 					}
 				}
 			}
 		}
 
 		property.setMetaAttributes( propertySource.getToolingHintContext().getMetaAttributeMap() );
 
 		if ( log.isDebugEnabled() ) {
 			final StringBuilder message = new StringBuilder()
 					.append( "Mapped property: " )
 					.append( propertySource.getName() )
 					.append( " -> [" );
 			final Iterator itr = property.getValue().getColumnIterator();
 			while ( itr.hasNext() ) {
 				message.append( ( (Selectable) itr.next() ).getText() );
 				if ( itr.hasNext() ) {
 					message.append( ", " );
 				}
 			}
 			message.append( "]" );
 			log.debug( message.toString() );
 		}
 	}
 
+	private String determineXmlNodeName(AttributeSource propertySource, String fallbackXmlNodeName) {
+		String nodeName = propertySource.getXmlNodeName();
+		if ( StringHelper.isNotEmpty( nodeName ) ) {
+			DeprecationLogger.DEPRECATION_LOGGER.logDeprecationOfDomEntityModeSupport();
+		}
+		else {
+			nodeName = propertySource.getName();
+		}
+		if ( nodeName == null ) {
+			nodeName = fallbackXmlNodeName;
+		}
+
+		return nodeName;
+	}
+
 	private void bindComponent(
 			MappingDocument sourceDocument,
 			EmbeddableSource embeddableSource,
 			Component component,
 			String containingClassName,
 			String propertyName,
 			String xmlNodeName,
 			boolean isVirtual) {
 		final String fullRole = embeddableSource.getAttributeRoleBase().getFullPath();
 		final String explicitComponentClassName = extractExplicitComponentClassName( embeddableSource );
 
 		bindComponent(
 				sourceDocument,
 				fullRole,
 				embeddableSource,
 				component,
 				explicitComponentClassName,
 				containingClassName,
 				propertyName,
 				isVirtual,
 				embeddableSource.isDynamic(),
 				xmlNodeName
 		);
 	}
 
 	private String extractExplicitComponentClassName(EmbeddableSource embeddableSource) {
 		if ( embeddableSource.getTypeDescriptor() == null ) {
 			return null;
 		}
 
 		return embeddableSource.getTypeDescriptor().getName();
 	}
 
 	private void bindComponent(
 			MappingDocument sourceDocument,
 			String role,
 			EmbeddableSource embeddableSource,
 			Component componentBinding,
 			String explicitComponentClassName,
 			String containingClassName,
 			String propertyName,
 			boolean isVirtual,
 			boolean isDynamic,
 			String xmlNodeName) {
 
 		componentBinding.setMetaAttributes( embeddableSource.getToolingHintContext().getMetaAttributeMap() );
 
 		componentBinding.setRoleName( role );
 
 		componentBinding.setEmbedded( isVirtual );
 
 		// todo : better define the conditions in this if/else
 		if ( isDynamic ) {
 			// dynamic is represented as a Map
 			log.debugf( "Binding dynamic-component [%s]", role );
 			componentBinding.setDynamic( true );
 		}
 		else if ( isVirtual ) {
 			// virtual (what used to be called embedded) is just a conceptual composition...
 			// <properties/> for example
 			if ( componentBinding.getOwner().hasPojoRepresentation() ) {
 				log.debugf( "Binding virtual component [%s] to owner class [%s]", role, componentBinding.getOwner().getClassName() );
 				componentBinding.setComponentClassName( componentBinding.getOwner().getClassName() );
 			}
 			else {
 				log.debugf( "Binding virtual component [%s] as dynamic", role );
 				componentBinding.setDynamic( true );
 			}
 		}
 		else {
 			log.debugf( "Binding component [%s]", role );
 			if ( StringHelper.isNotEmpty( explicitComponentClassName ) ) {
 				log.debugf( "Binding component [%s] to explicitly specified class", role, explicitComponentClassName );
 				componentBinding.setComponentClassName( explicitComponentClassName );
 			}
 			else if ( componentBinding.getOwner().hasPojoRepresentation() ) {
 				log.tracef( "Attempting to determine component class by reflection %s", role );
 				final Class reflectedComponentClass;
 				if ( StringHelper.isNotEmpty( containingClassName ) && StringHelper.isNotEmpty( propertyName ) ) {
 					reflectedComponentClass = Helper.reflectedPropertyClass(
 							sourceDocument,
 							containingClassName,
 							propertyName
 					);
 				}
 				else {
 					reflectedComponentClass = null;
 				}
 
 				if ( reflectedComponentClass == null ) {
 					log.debugf(
 							"Unable to determine component class name via reflection, and explicit " +
 									"class name not given; role=[%s]",
 							role
 					);
 				}
 				else {
 					componentBinding.setComponentClassName( reflectedComponentClass.getName() );
 				}
 			}
 			else {
 				componentBinding.setDynamic( true );
 			}
 		}
 
 		String nodeName = xmlNodeName;
 		if ( StringHelper.isNotEmpty( nodeName ) ) {
 			DeprecationLogger.DEPRECATION_LOGGER.logDeprecationOfDomEntityModeSupport();
 		}
 		else {
 			nodeName = propertyName;
 		}
 		if ( nodeName == null ) {
 			nodeName = componentBinding.getOwner().getNodeName();
 		}
 		componentBinding.setNodeName( nodeName );
 
 		// todo : anything else to pass along?
 		bindAllCompositeAttributes(
 				sourceDocument,
 				embeddableSource,
 				componentBinding
 		);
 
 		if ( embeddableSource.getParentReferenceAttributeName() != null ) {
 			componentBinding.setParentProperty( embeddableSource.getParentReferenceAttributeName() );
 		}
 
 		if ( embeddableSource.isUnique() ) {
 			final ArrayList<Column> cols = new ArrayList<Column>();
 			final Iterator itr = componentBinding.getColumnIterator();
 			while ( itr.hasNext() ) {
 				final Object selectable = itr.next();
 				// skip formulas.  ugh, yes terrible naming of these methods :(
 				if ( !Column.class.isInstance( selectable ) ) {
 					continue;
 				}
 				cols.add( (Column) selectable );
 			}
 			// todo : we may need to delay this
 			componentBinding.getOwner().getTable().createUniqueKey( cols );
 		}
 
 		if ( embeddableSource.getTuplizerClassMap() != null ) {
 			if ( embeddableSource.getTuplizerClassMap().size() > 1 ) {
 				DeprecationLogger.DEPRECATION_LOGGER.logDeprecationOfMultipleEntityModeSupport();
 			}
 			for ( Map.Entry<EntityMode,String> tuplizerEntry : embeddableSource.getTuplizerClassMap().entrySet() ) {
 				componentBinding.addTuplizer(
 						tuplizerEntry.getKey(),
 						tuplizerEntry.getValue()
 				);
 			}
 		}
 	}
 
 	private void prepareComponentType(
 			MappingDocument sourceDocument,
 			String fullRole,
 			Component componentBinding,
 			String explicitComponentClassName,
 			String containingClassName,
 			String propertyName,
 			boolean isVirtual,
 			boolean isDynamic) {
 	}
 
 	private void bindAllCompositeAttributes(
 			MappingDocument sourceDocument,
 			EmbeddableSource embeddableSource,
 			Component component) {
 
 		for ( AttributeSource attributeSource : embeddableSource.attributeSources() ) {
 			Property attribute = null;
 
 			if ( SingularAttributeSourceBasic.class.isInstance( attributeSource ) ) {
 				attribute = createBasicAttribute(
 						sourceDocument,
 						(SingularAttributeSourceBasic) attributeSource,
 						new SimpleValue( sourceDocument.getMetadataCollector(), component.getTable() ),
 						component.getComponentClassName()
 				);
 			}
 			else if ( SingularAttributeSourceEmbedded.class.isInstance( attributeSource ) ) {
 				attribute = createEmbeddedAttribute(
 						sourceDocument,
 						(SingularAttributeSourceEmbedded) attributeSource,
 						new Component( sourceDocument.getMetadataCollector(), component ),
 						component.getComponentClassName()
 				);
 			}
 			else if ( SingularAttributeSourceManyToOne.class.isInstance( attributeSource ) ) {
 				attribute = createManyToOneAttribute(
 						sourceDocument,
 						(SingularAttributeSourceManyToOne) attributeSource,
 						new ManyToOne( sourceDocument.getMetadataCollector(), component.getTable() ),
 						component.getComponentClassName()
 				);
 			}
 			else if ( SingularAttributeSourceOneToOne.class.isInstance( attributeSource ) ) {
 				attribute = createOneToOneAttribute(
 						sourceDocument,
 						(SingularAttributeSourceOneToOne) attributeSource,
 						new OneToOne( sourceDocument.getMetadataCollector(), component.getTable(), component.getOwner() ),
 						component.getComponentClassName()
 				);
 			}
 			else if ( SingularAttributeSourceAny.class.isInstance( attributeSource ) ) {
 				attribute = createAnyAssociationAttribute(
 						sourceDocument,
 						(SingularAttributeSourceAny) attributeSource,
 						new Any( sourceDocument.getMetadataCollector(), component.getTable() ),
 						component.getComponentClassName()
 				);
 			}
 			else if ( PluralAttributeSource.class.isInstance( attributeSource ) ) {
 				attribute = createPluralAttribute(
 						sourceDocument,
 						(PluralAttributeSource) attributeSource,
 						component.getOwner()
 				);
 			}
 			else {
 				throw new AssertionFailure(
 						String.format(
 								Locale.ENGLISH,
 								"Unexpected AttributeSource sub-type [%s] as part of composite [%s]",
 								attributeSource.getClass().getName(),
 								attributeSource.getAttributeRole().getFullPath()
 						)
 
 				);
 			}
 
 			component.addProperty( attribute );
 		}
 	}
 
 	private static void bindSimpleValueType(
 			MappingDocument sourceDocument,
 			HibernateTypeSource typeSource,
 			SimpleValue simpleValue) {
 		final TypeResolution typeResolution = resolveType( sourceDocument, typeSource );
 		if ( typeResolution == null ) {
 			// no explicit type info was found
 			return;
 		}
 
 		if ( CollectionHelper.isNotEmpty( typeResolution.parameters ) ) {
 			simpleValue.setTypeParameters( typeResolution.parameters );
 		}
 
 		if ( typeResolution.typeName != null ) {
 			simpleValue.setTypeName( typeResolution.typeName );
 		}
 	}
 
 	private static class TypeResolution {
 		private final String typeName;
 		private final Properties parameters;
 
 		public TypeResolution(String typeName, Properties parameters) {
 			this.typeName = typeName;
 			this.parameters = parameters;
 		}
 	}
 
 	private static TypeResolution resolveType(
 			MappingDocument sourceDocument,
 			HibernateTypeSource typeSource) {
 		if ( StringHelper.isEmpty( typeSource.getName() ) ) {
 			return null;
 		}
 
 		String typeName = typeSource.getName();
 		Properties typeParameters = new Properties();;
 
 		final TypeDefinition typeDefinition = sourceDocument.getMetadataCollector().getTypeDefinition( typeName );
 		if ( typeDefinition != null ) {
 			// the explicit name referred to a type-def
 			typeName = typeDefinition.getTypeImplementorClass().getName();
 			if ( typeDefinition.getParameters() != null ) {
 				typeParameters.putAll( typeDefinition.getParameters() );
 			}
 		}
 //		else {
 //			final BasicType basicType = sourceDocument.getMetadataCollector().getTypeResolver().basic( typeName );
 //			if ( basicType == null ) {
 //				throw new MappingException(
 //						String.format(
 //								Locale.ENGLISH,
 //								"Mapping named an explicit type [%s] which could not be resolved",
 //								typeName
 //						),
 //						sourceDocument.getOrigin()
 //				);
 //			}
 //		}
 
 		// parameters on the property mapping should override parameters in the type-def
 		if ( typeSource.getParameters() != null ) {
 			typeParameters.putAll( typeSource.getParameters() );
 		}
 
 		return new TypeResolution( typeName, typeParameters );
 	}
 
 	private Table bindEntityTableSpecification(
 			final MappingDocument mappingDocument,
 			TableSpecificationSource tableSpecSource,
 			Table denormalizedSuperTable,
 			final EntitySource entitySource,
 			PersistentClass entityDescriptor) {
 		final Schema schema = database.locateSchema(
 				determineCatalogName( tableSpecSource ),
 				determineSchemaName( tableSpecSource )
 		);
 
 		final boolean isTable = TableSource.class.isInstance( tableSpecSource );
 		final boolean isAbstract = entityDescriptor.isAbstract() == null ? false : entityDescriptor.isAbstract();
 		final String subselect;
 		final Identifier logicalTableName;
 		final Table table;
 		if ( isTable ) {
 			final TableSource tableSource = (TableSource) tableSpecSource;
 
 			if ( StringHelper.isNotEmpty( tableSource.getExplicitTableName() ) ) {
 				logicalTableName = database.toIdentifier( tableSource.getExplicitTableName() );
 			}
 			else {
 				final ImplicitEntityNameSource implicitNamingSource = new ImplicitEntityNameSource() {
 					@Override
 					public EntityNaming getEntityNaming() {
 						return entitySource.getEntityNamingSource();
 					}
 
 					@Override
 					public MetadataBuildingContext getBuildingContext() {
 						return mappingDocument;
 					}
 				};
 				logicalTableName = mappingDocument.getBuildingOptions()
 						.getImplicitNamingStrategy()
 						.determinePrimaryTableName( implicitNamingSource );
 			}
 
 			if ( denormalizedSuperTable == null ) {
 				table = schema.createTable( logicalTableName, isAbstract );
 			}
 			else {
 				table = schema.createDenormalizedTable(
 						logicalTableName,
 						isAbstract,
 						denormalizedSuperTable
 				);
 			}
 		}
 		else {
 			final InLineViewSource inLineViewSource = (InLineViewSource) tableSpecSource;
 			subselect = inLineViewSource.getSelectStatement();
 			logicalTableName = database.toIdentifier( inLineViewSource.getLogicalName() );
 			if ( denormalizedSuperTable == null ) {
 				table = new Table( schema, subselect, isAbstract );
 			}
 			else {
 				table = new DenormalizedTable( schema, subselect, isAbstract, denormalizedSuperTable );
 			}
 			table.setName( logicalTableName.render() );
 		}
 
 		EntityTableXref superEntityTableXref = null;
 
 		if ( entitySource.getSuperType() != null ) {
 			//noinspection SuspiciousMethodCalls
 			final String superEntityName = ( (EntitySource) entitySource.getSuperType() ).getEntityNamingSource()
 					.getEntityName();
 			superEntityTableXref = mappingDocument.getMetadataCollector().getEntityTableXref( superEntityName );
 			if ( superEntityTableXref == null ) {
 				throw new MappingException(
 						String.format(
 								Locale.ENGLISH,
 								"Unable to locate entity table xref for entity [%s] super-type [%s]",
 								entityDescriptor.getEntityName(),
 								superEntityName
 						),
 						mappingDocument.getOrigin()
 				);
 			}
 		}
 
 		mappingDocument.getMetadataCollector().addEntityTableXref(
 				entitySource.getEntityNamingSource().getEntityName(),
 				logicalTableName,
 				table,
 				superEntityTableXref
 		);
 
 		if ( isTable ) {
 			final TableSource tableSource = (TableSource) tableSpecSource;
 			table.setRowId( tableSource.getRowId() );
 			table.setComment( tableSource.getComment() );
 			if ( StringHelper.isNotEmpty( tableSource.getCheckConstraint() ) ) {
 				table.addCheckConstraint( tableSource.getCheckConstraint() );
 			}
 		}
 
 		mappingDocument.getMetadataCollector().addTableNameBinding( logicalTableName, table );
 
 		return table;
 	}
 
 	private Identifier determineCatalogName(TableSpecificationSource tableSpecSource) {
 		if ( StringHelper.isNotEmpty( tableSpecSource.getExplicitCatalogName() ) ) {
 			return database.toIdentifier( tableSpecSource.getExplicitCatalogName() );
 		}
 		else {
 			return database.getDefaultSchema().getName().getCatalog();
 		}
 	}
 
 	private Identifier determineSchemaName(TableSpecificationSource tableSpecSource) {
 		if ( StringHelper.isNotEmpty( tableSpecSource.getExplicitSchemaName() ) ) {
 			return database.toIdentifier( tableSpecSource.getExplicitSchemaName() );
 		}
 		else {
 			return database.getDefaultSchema().getName().getSchema();
 		}
 	}
 
 	private static void bindCustomSql(
 			MappingDocument sourceDocument,
 			EntitySource entitySource,
 			PersistentClass entityDescriptor) {
 		if ( entitySource.getCustomSqlInsert() != null ) {
 			entityDescriptor.setCustomSQLInsert(
 					entitySource.getCustomSqlInsert().getSql(),
 					entitySource.getCustomSqlInsert().isCallable(),
 					entitySource.getCustomSqlInsert().getCheckStyle()
 			);
 		}
 
 		if ( entitySource.getCustomSqlUpdate() != null ) {
 			entityDescriptor.setCustomSQLUpdate(
 					entitySource.getCustomSqlUpdate().getSql(),
 					entitySource.getCustomSqlUpdate().isCallable(),
 					entitySource.getCustomSqlUpdate().getCheckStyle()
 			);
 		}
 
 		if ( entitySource.getCustomSqlDelete() != null ) {
 			entityDescriptor.setCustomSQLDelete(
 					entitySource.getCustomSqlDelete().getSql(),
 					entitySource.getCustomSqlDelete().isCallable(),
 					entitySource.getCustomSqlDelete().getCheckStyle()
 			);
 		}
 
 		entityDescriptor.setLoaderName( entitySource.getCustomLoaderName() );
 	}
 
 	private static void bindCustomSql(
 			MappingDocument sourceDocument,
 			SecondaryTableSource secondaryTableSource,
 			Join secondaryTable) {
 		if ( secondaryTableSource.getCustomSqlInsert() != null ) {
 			secondaryTable.setCustomSQLInsert(
 					secondaryTableSource.getCustomSqlInsert().getSql(),
 					secondaryTableSource.getCustomSqlInsert().isCallable(),
 					secondaryTableSource.getCustomSqlInsert().getCheckStyle()
 			);
 		}
 
 		if ( secondaryTableSource.getCustomSqlUpdate() != null ) {
 			secondaryTable.setCustomSQLUpdate(
 					secondaryTableSource.getCustomSqlUpdate().getSql(),
 					secondaryTableSource.getCustomSqlUpdate().isCallable(),
 					secondaryTableSource.getCustomSqlUpdate().getCheckStyle()
 			);
 		}
 
 		if ( secondaryTableSource.getCustomSqlDelete() != null ) {
 			secondaryTable.setCustomSQLDelete(
 					secondaryTableSource.getCustomSqlDelete().getSql(),
 					secondaryTableSource.getCustomSqlDelete().isCallable(),
 					secondaryTableSource.getCustomSqlDelete().getCheckStyle()
 			);
 		}
 	}
 
 	private void registerSecondPass(SecondPass secondPass, MetadataBuildingContext context) {
 		context.getMetadataCollector().addSecondPass( secondPass );
 	}
 
 
 
 	public static final class DelayedPropertyReferenceHandlerImpl implements InFlightMetadataCollector.DelayedPropertyReferenceHandler {
 		public final String referencedEntityName;
 		public final String referencedPropertyName;
 		public final boolean isUnique;
 		private final String sourceElementSynopsis;
 		public final Origin propertyRefOrigin;
 
 		public DelayedPropertyReferenceHandlerImpl(
 				String referencedEntityName,
 				String referencedPropertyName,
 				boolean isUnique,
 				String sourceElementSynopsis,
 				Origin propertyRefOrigin) {
 			this.referencedEntityName = referencedEntityName;
 			this.referencedPropertyName = referencedPropertyName;
 			this.isUnique = isUnique;
 			this.sourceElementSynopsis = sourceElementSynopsis;
 			this.propertyRefOrigin = propertyRefOrigin;
 		}
 
 		public void process(InFlightMetadataCollector metadataCollector) {
 			log.tracef(
 					"Performing delayed property-ref handling [%s, %s, %s]",
 					referencedEntityName,
 					referencedPropertyName,
 					sourceElementSynopsis
 			);
 
 			PersistentClass entityBinding = metadataCollector.getEntityBinding( referencedEntityName );
 			if ( entityBinding == null ) {
 				throw new MappingException(
 						String.format(
 								Locale.ENGLISH,
 								"property-ref [%s] referenced an unmapped entity [%s]",
 								sourceElementSynopsis,
 								referencedEntityName
 						),
 						propertyRefOrigin
 				);
 			}
 
 			Property propertyBinding = entityBinding.getReferencedProperty( referencedPropertyName );
 			if ( propertyBinding == null ) {
 				throw new MappingException(
 						String.format(
 								Locale.ENGLISH,
 								"property-ref [%s] referenced an unknown entity property [%s#%s]",
 								sourceElementSynopsis,
 								referencedEntityName,
 								referencedPropertyName
 						),
 						propertyRefOrigin
 				);
 			}
 
 			if ( isUnique ) {
 				( (SimpleValue) propertyBinding.getValue() ).setAlternateUniqueKey( true );
 			}
 		}
 	}
 
 
 	private abstract class AbstractPluralAttributeSecondPass implements SecondPass {
 		private final MappingDocument mappingDocument;
 		private final PluralAttributeSource pluralAttributeSource;
 		private final Collection collectionBinding;
 
 		protected AbstractPluralAttributeSecondPass(
 				MappingDocument mappingDocument,
 				PluralAttributeSource pluralAttributeSource,
 				Collection collectionBinding) {
 			this.mappingDocument = mappingDocument;
 			this.pluralAttributeSource = pluralAttributeSource;
 			this.collectionBinding = collectionBinding;
 		}
 
 		public MappingDocument getMappingDocument() {
 			return mappingDocument;
 		}
 
 		public PluralAttributeSource getPluralAttributeSource() {
 			return pluralAttributeSource;
 		}
 
 		public Collection getCollectionBinding() {
 			return collectionBinding;
 		}
 
 		@Override
 		public void doSecondPass(Map persistentClasses) throws org.hibernate.MappingException {
 			bindCollectionTable();
 
 			bindCollectionKey();
 			bindCollectionIdentifier();
 			bindCollectionIndex();
 			bindCollectionElement();
 
 			createBackReferences();
 
 			collectionBinding.createAllKeys();
 
 			if ( debugEnabled ) {
 				log.debugf( "Mapped collection : " + getPluralAttributeSource().getAttributeRole().getFullPath() );
 				log.debugf( "   + table -> " + getCollectionBinding().getTable().getName() );
 				log.debugf( "   + key -> " + columns( getCollectionBinding().getKey() ) );
 				if ( getCollectionBinding().isIndexed() ) {
 					log.debugf( "   + index -> " + columns( ( (IndexedCollection) getCollectionBinding() ).getIndex() ) );
 				}
 				if ( getCollectionBinding().isOneToMany() ) {
 					log.debugf( "   + one-to-many -> " + ( (OneToMany) getCollectionBinding().getElement() ).getReferencedEntityName() );
 				}
 				else {
 					log.debugf( "   + element -> " + columns( getCollectionBinding().getElement() ) );
 				}
 			}
 		}
 
 		private String columns(Value value) {
 			final StringBuilder builder = new StringBuilder();
 			final Iterator<Selectable> selectableItr = value.getColumnIterator();
 			while ( selectableItr.hasNext() ) {
 				builder.append( selectableItr.next().getText() );
 				if ( selectableItr.hasNext() ) {
 					builder.append( ", " );
 				}
 			}
 			return builder.toString();
 		}
 
 		private void bindCollectionTable() {
 			// 2 main branches here:
 			//		1) one-to-many
 			//		2) everything else
 
 			if ( pluralAttributeSource.getElementSource() instanceof PluralAttributeElementSourceOneToMany ) {
 				// For one-to-many mappings, the "collection table" is the same as the table
 				// of the associated entity (the entity making up the collection elements).
 				// So lookup the associated entity and use its table here
 
 				final PluralAttributeElementSourceOneToMany elementSource =
 						(PluralAttributeElementSourceOneToMany) pluralAttributeSource.getElementSource();
 
 				final PersistentClass persistentClass = mappingDocument.getMetadataCollector()
 						.getEntityBinding( elementSource.getReferencedEntityName() );
 				if ( persistentClass == null ) {
 					throw new MappingException(
 							String.format(
 									Locale.ENGLISH,
 									"Association [%s] references an unmapped entity [%s]",
 									pluralAttributeSource.getAttributeRole().getFullPath(),
 									pluralAttributeSource.getAttributeRole().getFullPath()
 							),
 							mappingDocument.getOrigin()
 					);
 				}
 
 				// even though <key/> defines a property-ref I do not see where legacy
 				// code ever attempts to use that to "adjust" the table in its use to
 				// the actual table the referenced property belongs to.
 				// todo : for correctness, though, we should look into that ^^
 				collectionBinding.setCollectionTable( persistentClass.getTable() );
 			}
 			else {
 				final TableSpecificationSource tableSpecSource = pluralAttributeSource.getCollectionTableSpecificationSource();
 				final Identifier logicalCatalogName = determineCatalogName( tableSpecSource );
 				final Identifier logicalSchemaName = determineSchemaName( tableSpecSource );
 				final Schema schema = database.locateSchema( logicalCatalogName, logicalSchemaName );
 
 				final Table collectionTable;
 
 				if ( tableSpecSource instanceof TableSource ) {
 					final TableSource tableSource = (TableSource) tableSpecSource;
 					Identifier logicalName;
 
 					if ( StringHelper.isNotEmpty( tableSource.getExplicitTableName() ) ) {
 						logicalName = Identifier.toIdentifier(
 								tableSource.getExplicitTableName(),
 								mappingDocument.getMappingDefaults().shouldImplicitlyQuoteIdentifiers()
 						);
 					}
 					else {
 						final EntityNaming ownerEntityNaming = new EntityNamingSourceImpl(
 								collectionBinding.getOwner().getEntityName(),
 								collectionBinding.getOwner().getClassName(),
 								collectionBinding.getOwner().getJpaEntityName()
 						);
 						final ImplicitCollectionTableNameSource implicitNamingSource = new ImplicitCollectionTableNameSource() {
 							@Override
 							public Identifier getOwningPhysicalTableName() {
 								return collectionBinding.getOwner().getTable().getNameIdentifier();
 							}
 
 							@Override
 							public EntityNaming getOwningEntityNaming() {
 								return ownerEntityNaming;
 							}
 
 							@Override
 							public AttributePath getOwningAttributePath() {
 								return pluralAttributeSource.getAttributePath();
 							}
 
 							@Override
 							public MetadataBuildingContext getBuildingContext() {
 								return mappingDocument;
 							}
 						};
 						logicalName = mappingDocument.getBuildingOptions()
 								.getImplicitNamingStrategy()
 								.determineCollectionTableName( implicitNamingSource );
 					}
 
 					collectionTable = schema.createTable( logicalName, false );
 				}
 				else {
 					collectionTable = new Table(
 							schema,
 							( (InLineViewSource) tableSpecSource ).getSelectStatement(),
 							false
 					);
 				}
 
 				collectionBinding.setCollectionTable( collectionTable );
 			}
 
 
 			if ( debugEnabled ) {
 				log.debugf( "Mapping collection: %s -> %s", collectionBinding.getRole(), collectionBinding.getCollectionTable().getName() );
 			}
 
 			if ( pluralAttributeSource.getCollectionTableComment() != null ) {
 				collectionBinding.getCollectionTable().setComment( pluralAttributeSource.getCollectionTableComment() );
 			}
 			if ( pluralAttributeSource.getCollectionTableCheck() != null ) {
 				collectionBinding.getCollectionTable().addCheckConstraint( pluralAttributeSource.getCollectionTableCheck() );
 			}
 		}
 
 		protected void createBackReferences() {
 			if ( collectionBinding.isOneToMany()
 					&& !collectionBinding.isInverse()
 					&& !collectionBinding.getKey().isNullable() ) {
 				// for non-inverse one-to-many, with a not-null fk, add a backref!
 				String entityName = ( (OneToMany) collectionBinding.getElement() ).getReferencedEntityName();
 				PersistentClass referenced = mappingDocument.getMetadataCollector().getEntityBinding( entityName );
 				Backref prop = new Backref();
 				prop.setName( '_' + collectionBinding.getOwnerEntityName() + "." + pluralAttributeSource.getName() + "Backref" );
 				prop.setUpdateable( false );
 				prop.setSelectable( false );
 				prop.setCollectionRole( collectionBinding.getRole() );
 				prop.setEntityName( collectionBinding.getOwner().getEntityName() );
 				prop.setValue( collectionBinding.getKey() );
 				referenced.addProperty( prop );
 
 				log.debugf(
 						"Added virtual backref property [%s] : %s",
 						prop.getName(),
 						pluralAttributeSource.getAttributeRole().getFullPath()
 				);
 			}
 		}
 
 		protected void bindCollectionKey() {
 			final String propRef = getPluralAttributeSource().getKeySource().getReferencedPropertyName();
 			getCollectionBinding().setReferencedPropertyName( propRef );
 
 			final KeyValue keyVal;
 			if ( propRef == null ) {
 				keyVal = getCollectionBinding().getOwner().getIdentifier();
 			}
 			else {
 				keyVal = (KeyValue) getCollectionBinding().getOwner().getRecursiveProperty( propRef ).getValue();
 			}
 			final DependantValue key = new DependantValue(
 					mappingDocument.getMetadataCollector(),
 					getCollectionBinding().getCollectionTable(),
 					keyVal
 			);
 			key.setCascadeDeleteEnabled( getPluralAttributeSource().getKeySource().isCascadeDeleteEnabled() );
 
 			final ImplicitJoinColumnNameSource.Nature implicitNamingNature;
 			if ( getPluralAttributeSource().getElementSource() instanceof PluralAttributeElementSourceManyToMany
 					|| getPluralAttributeSource().getElementSource() instanceof PluralAttributeElementSourceOneToMany ) {
 				implicitNamingNature = ImplicitJoinColumnNameSource.Nature.ENTITY_COLLECTION;
 			}
 			else {
 				implicitNamingNature = ImplicitJoinColumnNameSource.Nature.ELEMENT_COLLECTION;
 			}
 
 			relationalObjectBinder.bindColumnsAndFormulas(
 					mappingDocument,
 					getPluralAttributeSource().getKeySource().getRelationalValueSources(),
 					key,
 					getPluralAttributeSource().getKeySource().areValuesNullableByDefault(),
 					new RelationalObjectBinder.ColumnNamingDelegate() {
 						@Override
 						public Identifier determineImplicitName(final LocalMetadataBuildingContext context) {
 							// another case where HbmBinder was not adjusted to make use of NamingStrategy#foreignKeyColumnName
 							// when that was added in developing annotation binding :(
 //							return implicitNamingStrategy.determineJoinColumnName(
 //									new ImplicitJoinColumnNameSource() {
 //										private EntityNamingSourceImpl entityNamingSource;
 //										private Identifier referencedColumnName;
 //
 //										@Override
 //										public Nature getNature() {
 //											return implicitNamingNature;
 //										}
 //
 //										@Override
 //										public EntityNaming getEntityNaming() {
 //											if ( entityNamingSource == null ) {
 //												entityNamingSource = new EntityNamingSourceImpl(
 //														getCollectionBinding().getOwner().getEntityName(),
 //														getCollectionBinding().getOwner().getClassName(),
 //														getCollectionBinding().getOwner().getJpaEntityName()
 //												);
 //											}
 //											return entityNamingSource;
 //										}
 //
 //										@Override
 //										public AttributePath getAttributePath() {
 //											return getPluralAttributeSource().getAttributePath();
 //										}
 //
 //										@Override
 //										public Identifier getReferencedTableName() {
 //											return getCollectionBinding().getCollectionTable().getNameIdentifier();
 //										}
 //
 //										@Override
 //										public Identifier getReferencedColumnName() {
 //											if ( referencedColumnName == null ) {
 //												final Iterator<Selectable> selectableItr = keyVal.getColumnIterator();
 //												// assume there is just one, and that its a column...
 //												final Column column = (Column) selectableItr.next();
 //												referencedColumnName = getMappingDocument().getMetadataCollector()
 //														.getDatabase()
 //														.toIdentifier( column.getQuotedName() );
 //											}
 //											return referencedColumnName;
 //										}
 //
 //										@Override
 //										public MetadataBuildingContext getBuildingContext() {
 //											return context;
 //										}
 //									}
 //							);
 							return context.getMetadataCollector().getDatabase().toIdentifier( Collection.DEFAULT_KEY_COLUMN_NAME );
 						}
 					}
 			);
 
 			key.createForeignKey();
 			getCollectionBinding().setKey( key );
 
 			key.setNullable( getPluralAttributeSource().getKeySource().areValuesNullableByDefault() );
 			key.setUpdateable( getPluralAttributeSource().getKeySource().areValuesIncludedInUpdateByDefault() );
 		}
 
 		protected void bindCollectionIdentifier() {
 			final CollectionIdSource idSource = getPluralAttributeSource().getCollectionIdSource();
 			if ( idSource != null ) {
 				final IdentifierCollection idBagBinding = (IdentifierCollection) getCollectionBinding();
 				final SimpleValue idBinding = new SimpleValue(
 						mappingDocument.getMetadataCollector(),
 						idBagBinding.getCollectionTable()
 				);
 
 				bindSimpleValueType(
 						mappingDocument,
 						idSource.getTypeInformation(),
 						idBinding
 				);
 
 				relationalObjectBinder.bindColumn(
 						mappingDocument,
 						idSource.getColumnSource(),
 						idBinding,
 						false,
 						new RelationalObjectBinder.ColumnNamingDelegate() {
 							@Override
 							public Identifier determineImplicitName(LocalMetadataBuildingContext context) {
 								return database.toIdentifier( IdentifierCollection.DEFAULT_IDENTIFIER_COLUMN_NAME );
 							}
 						}
 				);
 
 				idBagBinding.setIdentifier( idBinding );
 
 				makeIdentifier(
 						mappingDocument,
 						new IdentifierGeneratorDefinition( idSource.getGeneratorName() ),
 						null,
 						idBinding
 				);
 			}
 		}
 
 		protected void bindCollectionIndex() {
 		}
 
 		protected void bindCollectionElement() {
 			if ( getPluralAttributeSource().getElementSource() instanceof PluralAttributeElementSourceBasic ) {
 				final PluralAttributeElementSourceBasic elementSource =
 						(PluralAttributeElementSourceBasic) getPluralAttributeSource().getElementSource();
 				final SimpleValue elementBinding = new SimpleValue(
 						getMappingDocument().getMetadataCollector(),
 						getCollectionBinding().getCollectionTable()
 				);
 
 				bindSimpleValueType(
 						getMappingDocument(),
 						elementSource.getExplicitHibernateTypeSource(),
 						elementBinding
 				);
 
 				relationalObjectBinder.bindColumnsAndFormulas(
 						mappingDocument,
 						elementSource.getRelationalValueSources(),
 						elementBinding,
 						elementSource.areValuesNullableByDefault(),
 						new RelationalObjectBinder.ColumnNamingDelegate() {
 							@Override
 							public Identifier determineImplicitName(LocalMetadataBuildingContext context) {
 //								return implicitNamingStrategy.determineBasicColumnName(
 //										elementSource
 //								);
 								return context.getMetadataCollector().getDatabase().toIdentifier( Collection.DEFAULT_ELEMENT_COLUMN_NAME );
 							}
 						}
 				);
 
 				getCollectionBinding().setElement( elementBinding );
 			}
 			else if ( getPluralAttributeSource().getElementSource() instanceof PluralAttributeElementSourceEmbedded ) {
 				final PluralAttributeElementSourceEmbedded elementSource =
 						(PluralAttributeElementSourceEmbedded) getPluralAttributeSource().getElementSource();
 				final Component elementBinding = new Component(
 						getMappingDocument().getMetadataCollector(),
 						getCollectionBinding()
 				);
 
 				final EmbeddableSource embeddableSource = elementSource.getEmbeddableSource();
 				bindComponent(
 						mappingDocument,
 						embeddableSource,
 						elementBinding,
 						null,
 						embeddableSource.getAttributePathBase().getProperty(),
 						getPluralAttributeSource().getXmlNodeName(),
 						false
 				);
 
 				getCollectionBinding().setElement( elementBinding );
 			}
 			else if ( getPluralAttributeSource().getElementSource() instanceof PluralAttributeElementSourceOneToMany ) {
 				final PluralAttributeElementSourceOneToMany elementSource =
 						(PluralAttributeElementSourceOneToMany) getPluralAttributeSource().getElementSource();
 				final OneToMany elementBinding = new OneToMany(
 						getMappingDocument().getMetadataCollector(),
 						getCollectionBinding().getOwner()
 				);
 				collectionBinding.setElement( elementBinding );
 
 				final PersistentClass referencedEntityBinding = mappingDocument.getMetadataCollector()
 						.getEntityBinding( elementSource.getReferencedEntityName() );
 				elementBinding.setReferencedEntityName( referencedEntityBinding.getEntityName() );
 				elementBinding.setAssociatedClass( referencedEntityBinding );
 
 				String embed = elementSource.getXmlNodeName();
 				// sometimes embed is set to the default value when not specified in the mapping,
 				// so can't seem to determine if an attribute was explicitly set;
 				// log a warning if embed has a value different from the default.
 				if ( !StringHelper.isEmpty( embed ) &&  !"true".equals( embed ) ) {
 					DeprecationLogger.DEPRECATION_LOGGER.logDeprecationOfEmbedXmlSupport();
 				}
 				elementBinding.setEmbedded( embed == null || "true".equals( embed ) );
 
 				elementBinding.setIgnoreNotFound( elementSource.isIgnoreNotFound() );
 			}
 			else if ( getPluralAttributeSource().getElementSource() instanceof PluralAttributeElementSourceManyToMany ) {
 				final PluralAttributeElementSourceManyToMany elementSource =
 						(PluralAttributeElementSourceManyToMany) getPluralAttributeSource().getElementSource();
 				final ManyToOne elementBinding = new ManyToOne(
 						getMappingDocument().getMetadataCollector(),
 						getCollectionBinding().getCollectionTable()
 				);
 
 				relationalObjectBinder.bindColumnsAndFormulas(
 						getMappingDocument(),
 						elementSource.getRelationalValueSources(),
 						elementBinding,
 						false,
 						new RelationalObjectBinder.ColumnNamingDelegate() {
 							@Override
 							public Identifier determineImplicitName(final LocalMetadataBuildingContext context) {
 //								return implicitNamingStrategy.determineJoinColumnName(
 //										new ImplicitJoinColumnNameSource() {
 //											private final PersistentClass pc = mappingDocument.getMetadataCollector()
 //													.getEntityBinding( elementSource.getReferencedEntityName() );
 //											private final EntityNaming referencedEntityNaming = new EntityNamingSourceImpl(
 //													pc
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/internal/ClassLoaderServiceImpl.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/internal/ClassLoaderServiceImpl.java
index 9fb95e3b6b..57689f73d7 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/internal/ClassLoaderServiceImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/internal/ClassLoaderServiceImpl.java
@@ -1,433 +1,420 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.boot.registry.classloading.internal;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.ServiceLoader;
 
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.util.ClassLoaderHelper;
 import org.jboss.logging.Logger;
 
 /**
  * Standard implementation of the service for interacting with class loaders
  *
  * @author Steve Ebersole
  */
 public class ClassLoaderServiceImpl implements ClassLoaderService {
 	private static final Logger log = CoreLogging.logger( ClassLoaderServiceImpl.class );
 
 	private final Map<Class, ServiceLoader> serviceLoaders = new HashMap<Class, ServiceLoader>();
 	private AggregatedClassLoader aggregatedClassLoader;
 
 	/**
 	 * Constructs a ClassLoaderServiceImpl with standard set-up
 	 */
 	public ClassLoaderServiceImpl() {
 		this( ClassLoaderServiceImpl.class.getClassLoader() );
 	}
 
 	/**
 	 * Constructs a ClassLoaderServiceImpl with the given ClassLoader
 	 *
 	 * @param classLoader The ClassLoader to use
 	 */
 	public ClassLoaderServiceImpl(ClassLoader classLoader) {
 		this( Collections.singletonList( classLoader ) );
 	}
 
 	/**
 	 * Constructs a ClassLoaderServiceImpl with the given ClassLoader instances
 	 *
 	 * @param providedClassLoaders The ClassLoader instances to use
 	 */
 	public ClassLoaderServiceImpl(Collection<ClassLoader> providedClassLoaders) {
 		final LinkedHashSet<ClassLoader> orderedClassLoaderSet = new LinkedHashSet<ClassLoader>();
 
 		// first, add all provided class loaders, if any
 		if ( providedClassLoaders != null ) {
 			for ( ClassLoader classLoader : providedClassLoaders ) {
 				if ( classLoader != null ) {
 					orderedClassLoaderSet.add( classLoader );
 				}
 			}
 		}
 
 		// normalize adding known class-loaders...
 		// then the Hibernate class loader
 		orderedClassLoaderSet.add( ClassLoaderServiceImpl.class.getClassLoader() );
 
 		// then the TCCL, if one...
 		final ClassLoader tccl = locateTCCL();
 		if ( tccl != null ) {
 			orderedClassLoaderSet.add( tccl );
 		}
 		// finally the system classloader
 		final ClassLoader sysClassLoader = locateSystemClassLoader();
 		if ( sysClassLoader != null ) {
 			orderedClassLoaderSet.add( sysClassLoader );
 		}
 
 		// now build the aggregated class loader...
 		this.aggregatedClassLoader = new AggregatedClassLoader( orderedClassLoaderSet );
 	}
 
 	/**
 	 * No longer used/supported!
 	 *
 	 * @param configValues The config values
 	 *
 	 * @return The built service
 	 *
 	 * @deprecated No longer used/supported!
 	 */
 	@Deprecated
 	@SuppressWarnings({"UnusedDeclaration", "unchecked", "deprecation"})
 	public static ClassLoaderServiceImpl fromConfigSettings(Map configValues) {
 		final List<ClassLoader> providedClassLoaders = new ArrayList<ClassLoader>();
 
 		final Collection<ClassLoader> classLoaders = (Collection<ClassLoader>) configValues.get( AvailableSettings.CLASSLOADERS );
 		if ( classLoaders != null ) {
 			for ( ClassLoader classLoader : classLoaders ) {
 				providedClassLoaders.add( classLoader );
 			}
 		}
 
 		addIfSet( providedClassLoaders, AvailableSettings.APP_CLASSLOADER, configValues );
 		addIfSet( providedClassLoaders, AvailableSettings.RESOURCES_CLASSLOADER, configValues );
 		addIfSet( providedClassLoaders, AvailableSettings.HIBERNATE_CLASSLOADER, configValues );
 		addIfSet( providedClassLoaders, AvailableSettings.ENVIRONMENT_CLASSLOADER, configValues );
 
 		if ( providedClassLoaders.isEmpty() ) {
 			log.debugf( "Incoming config yielded no classloaders; adding standard SE ones" );
 			final ClassLoader tccl = locateTCCL();
 			if ( tccl != null ) {
 				providedClassLoaders.add( tccl );
 			}
 			providedClassLoaders.add( ClassLoaderServiceImpl.class.getClassLoader() );
 		}
 
 		return new ClassLoaderServiceImpl( providedClassLoaders );
 	}
 
 	private static void addIfSet(List<ClassLoader> providedClassLoaders, String name, Map configVales) {
 		final ClassLoader providedClassLoader = (ClassLoader) configVales.get( name );
 		if ( providedClassLoader != null ) {
 			providedClassLoaders.add( providedClassLoader );
 		}
 	}
 
 	private static ClassLoader locateSystemClassLoader() {
 		try {
 			return ClassLoader.getSystemClassLoader();
 		}
 		catch (Exception e) {
 			return null;
 		}
 	}
 
 	private static ClassLoader locateTCCL() {
 		try {
 			return ClassLoaderHelper.getContextClassLoader();
 		}
 		catch (Exception e) {
 			return null;
 		}
 	}
 
 	private static class AggregatedClassLoader extends ClassLoader {
 		private ClassLoader[] individualClassLoaders;
 
 		private AggregatedClassLoader(final LinkedHashSet<ClassLoader> orderedClassLoaderSet) {
 			super( null );
 			individualClassLoaders = orderedClassLoaderSet.toArray( new ClassLoader[orderedClassLoaderSet.size()] );
 		}
 
 		@Override
 		public Enumeration<URL> getResources(String name) throws IOException {
 			final LinkedHashSet<URL> resourceUrls = new LinkedHashSet<URL>();
 
 			for ( ClassLoader classLoader : individualClassLoaders ) {
 				final Enumeration<URL> urls = classLoader.getResources( name );
 				while ( urls.hasMoreElements() ) {
 					resourceUrls.add( urls.nextElement() );
 				}
 			}
 
 			return new Enumeration<URL>() {
 				final Iterator<URL> resourceUrlIterator = resourceUrls.iterator();
 
 				@Override
 				public boolean hasMoreElements() {
 					return resourceUrlIterator.hasNext();
 				}
 
 				@Override
 				public URL nextElement() {
 					return resourceUrlIterator.next();
 				}
 			};
 		}
 
 		@Override
 		protected URL findResource(String name) {
 			for ( ClassLoader classLoader : individualClassLoaders ) {
 				final URL resource = classLoader.getResource( name );
 				if ( resource != null ) {
 					return resource;
 				}
 			}
 			return super.findResource( name );
 		}
 
 		@Override
 		protected Class<?> findClass(String name) throws ClassNotFoundException {
 			for ( ClassLoader classLoader : individualClassLoaders ) {
 				try {
 					return classLoader.loadClass( name );
 				}
 				catch (Exception ignore) {
 				}
 			}
 
 			throw new ClassNotFoundException( "Could not load requested class : " + name );
 		}
 
 		public void destroy() {
 			individualClassLoaders = null;
 		}
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public <T> Class<T> classForName(String className) {
 		try {
 			return (Class<T>) Class.forName( className, true, aggregatedClassLoader );
 		}
 		catch (Exception e) {
 			throw new ClassLoadingException( "Unable to load class [" + className + "]", e );
 		}
 	}
 
 	@Override
 	public URL locateResource(String name) {
 		// first we try name as a URL
 		try {
 			return new URL( name );
 		}
 		catch (Exception ignore) {
 		}
 
 		try {
 			return aggregatedClassLoader.getResource( name );
 		}
 		catch (Exception ignore) {
 		}
 
 		return null;
 	}
 
 	@Override
 	public InputStream locateResourceStream(String name) {
 		// first we try name as a URL
 		try {
 			log.tracef( "trying via [new URL(\"%s\")]", name );
 			return new URL( name ).openStream();
 		}
 		catch (Exception ignore) {
 		}
 
 		try {
 			log.tracef( "trying via [ClassLoader.getResourceAsStream(\"%s\")]", name );
 			final InputStream stream = aggregatedClassLoader.getResourceAsStream( name );
 			if ( stream != null ) {
 				return stream;
 			}
 		}
 		catch (Exception ignore) {
 		}
 
 		final String stripped = name.startsWith( "/" ) ? name.substring( 1 ) : null;
 
 		if ( stripped != null ) {
 			try {
 				log.tracef( "trying via [new URL(\"%s\")]", stripped );
 				return new URL( stripped ).openStream();
 			}
 			catch (Exception ignore) {
 			}
 
 			try {
 				log.tracef( "trying via [ClassLoader.getResourceAsStream(\"%s\")]", stripped );
 				final InputStream stream = aggregatedClassLoader.getResourceAsStream( stripped );
 				if ( stream != null ) {
 					return stream;
 				}
 			}
 			catch (Exception ignore) {
 			}
 		}
 
 		return null;
 	}
 
 	@Override
 	public List<URL> locateResources(String name) {
 		final ArrayList<URL> urls = new ArrayList<URL>();
 		try {
 			final Enumeration<URL> urlEnumeration = aggregatedClassLoader.getResources( name );
 			if ( urlEnumeration != null && urlEnumeration.hasMoreElements() ) {
 				while ( urlEnumeration.hasMoreElements() ) {
 					urls.add( urlEnumeration.nextElement() );
 				}
 			}
 		}
 		catch (Exception ignore) {
 		}
 
 		return urls;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public <S> LinkedHashSet<S> loadJavaServices(Class<S> serviceContract) {
 		ServiceLoader<S> serviceLoader;
 		if ( serviceLoaders.containsKey( serviceContract ) ) {
 			serviceLoader = serviceLoaders.get( serviceContract );
 		}
 		else {
 			serviceLoader = ServiceLoader.load( serviceContract, aggregatedClassLoader );
 			serviceLoaders.put( serviceContract, serviceLoader );
 		}
 
 		final LinkedHashSet<S> services = new LinkedHashSet<S>();
 		for ( S service : serviceLoader ) {
 			services.add( service );
 		}
 		return services;
 	}
 
 	@Override
 	public void stop() {
 		for ( ServiceLoader serviceLoader : serviceLoaders.values() ) {
 			serviceLoader.reload(); // clear service loader providers
 		}
 		serviceLoaders.clear();
 
 		if ( aggregatedClassLoader != null ) {
 			aggregatedClassLoader.destroy();
 			aggregatedClassLoader = null;
 		}
 	}
 
 	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 	// completely temporary !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
 	/**
-	 * Hack around continued (temporary) need to sometimes set the TCCL for code we call that expects it.
-	 *
-	 * @param <T> The result type
-	 */
-	public static interface Work<T> {
-		/**
-		 * The work to be performed with the TCCL set
-		 *
-		 * @return The result of the work
-		 */
-		public T perform();
-	}
-
-	/**
 	 * Perform some discrete work with with the TCCL set to our aggregated ClassLoader
 	 *
 	 * @param work The discrete work to be done
 	 * @param <T> The type of the work result
 	 *
 	 * @return The work result.
 	 */
+	@Override
 	public <T> T withTccl(Work<T> work) {
 		final ClassLoader tccl = Thread.currentThread().getContextClassLoader();
 
 		boolean set = false;
 
 		try {
 			Thread.currentThread().setContextClassLoader(
 					new TcclSafeAggregatedClassLoader( aggregatedClassLoader, tccl ) );
 			set = true;
 		}
 		catch (Exception ignore) {
 		}
 
 		try {
 			return work.perform();
 		}
 		finally {
 			if ( set ) {
 				Thread.currentThread().setContextClassLoader( tccl );
 			}
 		}
 
 	}
 	
 	// TODO: Remove in ORM 5!  See HHH-8818
 	private class TcclSafeAggregatedClassLoader extends ClassLoader {
 		private final AggregatedClassLoader aggregatedClassLoader;
 		
 		private TcclSafeAggregatedClassLoader(AggregatedClassLoader aggregatedClassLoader, ClassLoader tccl) {
 			super(tccl);
 			this.aggregatedClassLoader = aggregatedClassLoader;
 		}
 		
 		@Override
 		public Enumeration<URL> getResources(String name) throws IOException {
 			return aggregatedClassLoader.getResources( name );
 		}
 
 		@Override
 		protected URL findResource(String name) {
 			return aggregatedClassLoader.findResource( name );
 		}
 
 		@Override
 		protected Class<?> findClass(String name) throws ClassNotFoundException {
 			return aggregatedClassLoader.findClass( name );
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/spi/ClassLoaderService.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/spi/ClassLoaderService.java
index 87a8a2dd9c..4d679c5656 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/spi/ClassLoaderService.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/spi/ClassLoaderService.java
@@ -1,91 +1,118 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.boot.registry.classloading.spi;
 
 import java.io.InputStream;
 import java.net.URL;
 import java.util.LinkedHashSet;
 import java.util.List;
 
 import org.hibernate.service.Service;
 import org.hibernate.service.spi.Stoppable;
 
 /**
  * A service for interacting with class loaders.
  *
  * @author Steve Ebersole
  */
 public interface ClassLoaderService extends Service, Stoppable {
 	/**
 	 * Locate a class by name.
 	 *
 	 * @param className The name of the class to locate
 	 * @param <T> The returned class type.
 	 *
 	 * @return The class reference
 	 *
 	 * @throws ClassLoadingException Indicates the class could not be found
 	 */
 	public <T> Class<T> classForName(String className);
 
 	/**
 	 * Locate a resource by name (classpath lookup).
 	 *
 	 * @param name The resource name.
 	 *
 	 * @return The located URL; may return {@code null} to indicate the resource was not found
 	 */
 	public URL locateResource(String name);
 
 	/**
 	 * Locate a resource by name (classpath lookup) and gets its stream.
 	 *
 	 * @param name The resource name.
 	 *
 	 * @return The stream of the located resource; may return {@code null} to indicate the resource was not found
 	 */
 	public InputStream locateResourceStream(String name);
 
 	/**
 	 * Locate a series of resource by name (classpath lookup).
 	 *
 	 * @param name The resource name.
 	 *
 	 * @return The list of URL matching; may return {@code null} to indicate the resource was not found
 	 */
 	public List<URL> locateResources(String name);
 
 	/**
 	 * Discovers and instantiates implementations of the named service contract.
 	 * <p/>
 	 * NOTE : the terms service here is used differently than {@link Service}.  Instead here we are talking about
 	 * services as defined by {@link java.util.ServiceLoader}.
 	 *
 	 * @param serviceContract The java type defining the service contract
 	 * @param <S> The type of the service contract
 	 *     
 	 * @return The ordered set of discovered services.
 	 */
 	public <S> LinkedHashSet<S> loadJavaServices(Class<S> serviceContract);
+
+
+	/**
+	 * Hack around continued (temporary) need to sometimes set the TCCL for code we call that expects it.
+	 *
+	 * @param <T> The result type
+	 */
+	@Deprecated
+	public static interface Work<T> {
+		/**
+		 * The work to be performed with the TCCL set
+		 *
+		 * @return The result of the work
+		 */
+		public T perform();
+	}
+
+	/**
+	 * Perform some discrete work with with the TCCL set to our aggregated ClassLoader
+	 *
+	 * @param work The discrete work to be done
+	 * @param <T> The type of the work result
+	 *
+	 * @return The work result.
+	 */
+	@Deprecated
+	public <T> T withTccl(Work<T> work);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/spi/AdditionalJaxbMappingProducer.java b/hibernate-core/src/main/java/org/hibernate/boot/spi/AdditionalJaxbMappingProducer.java
new file mode 100644
index 0000000000..c6661ae5e2
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/boot/spi/AdditionalJaxbMappingProducer.java
@@ -0,0 +1,46 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2015, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.boot.spi;
+
+import java.util.Collection;
+
+import org.hibernate.boot.jaxb.internal.MappingBinder;
+import org.hibernate.boot.model.source.internal.hbm.MappingDocument;
+
+import org.jboss.jandex.IndexView;
+
+/**
+ * @author Steve Ebersole
+ *
+ * @deprecated Intended for Envers integration until we can migrate Envers away from XML generation
+ * for building its model.
+ */
+@Deprecated
+public interface AdditionalJaxbMappingProducer {
+	Collection<MappingDocument> produceAdditionalMappings(
+			MetadataImplementor metadata,
+			IndexView jandexIndex,
+			MappingBinder mappingBinder,
+			MetadataBuildingContext buildingContext);
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/spi/MetadataBuilderContributor.java b/hibernate-core/src/main/java/org/hibernate/boot/spi/MetadataBuilderContributor.java
new file mode 100644
index 0000000000..1dcfa966a8
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/boot/spi/MetadataBuilderContributor.java
@@ -0,0 +1,35 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2015, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.boot.spi;
+
+import org.hibernate.boot.MetadataBuilder;
+
+/**
+ * Contract for contributing to the initialization of MetadataBuilder
+ *
+ * @author Steve Ebersole
+ */
+public interface MetadataBuilderContributor {
+	public void contribute(MetadataBuilder metadataBuilder);
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/spi/MetadataContributor.java b/hibernate-core/src/main/java/org/hibernate/boot/spi/MetadataContributor.java
new file mode 100644
index 0000000000..ecc395ef3b
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/boot/spi/MetadataContributor.java
@@ -0,0 +1,44 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2015, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.boot.spi;
+
+import org.jboss.jandex.IndexView;
+
+/**
+ * Contract for contributing to Metadata (InFlightMetadataCollector).
+ *
+ * This hook occurs just after all processing of all {@link org.hibernate.boot.MetadataSources},
+ * and just before {@link AdditionalJaxbRootProducer}.
+ *
+ * @author Steve Ebersole
+ */
+public interface MetadataContributor {
+	/**
+	 * Perform the contributions.
+	 *
+	 * @param metadataCollector The metadata collector, representing the in-flight metadata being built
+	 * @param jandexIndex The Jandex index
+	 */
+	public void contribute(InFlightMetadataCollector metadataCollector, IndexView jandexIndex);
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/spi/MetadataSourcesContributor.java b/hibernate-core/src/main/java/org/hibernate/boot/spi/MetadataSourcesContributor.java
index b0655b5d70..5002646295 100644
--- a/hibernate-core/src/main/java/org/hibernate/boot/spi/MetadataSourcesContributor.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/spi/MetadataSourcesContributor.java
@@ -1,43 +1,40 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2014, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.boot.spi;
 
 import org.hibernate.boot.MetadataSources;
 
-import org.jboss.jandex.IndexView;
-
 /**
  * A bootstrap process hook for contributing sources to MetadataSources.
  *
  * @author Steve Ebersole
  */
 public interface MetadataSourcesContributor {
 	/**
 	 * Perform the process of contributing to MetadataSources.
 	 *
-	 * @param metadataSources
-	 * @param jandexIndex The Jandex index
+	 * @param metadataSources The MetadataSources, to which to contribute.
 	 */
-	public void contribute(MetadataSources metadataSources, IndexView jandexIndex);
+	public void contribute(MetadataSources metadataSources);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java b/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
index e9ebb1621b..0e7f48d3bc 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
@@ -1,910 +1,913 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.InputStream;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import javax.persistence.AttributeConverter;
 import javax.persistence.SharedCacheMode;
 
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.MappingException;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.boot.Metadata;
 import org.hibernate.boot.MetadataBuilder;
 import org.hibernate.boot.MetadataSources;
 import org.hibernate.boot.SessionFactoryBuilder;
 import org.hibernate.boot.model.TypeContributor;
 import org.hibernate.boot.model.naming.ImplicitNamingStrategy;
 import org.hibernate.boot.model.naming.ImplicitNamingStrategyJpaCompliantImpl;
 import org.hibernate.boot.model.naming.PhysicalNamingStrategy;
 import org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl;
 import org.hibernate.boot.model.relational.AuxiliaryDatabaseObject;
 import org.hibernate.boot.registry.BootstrapServiceRegistry;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.boot.registry.StandardServiceRegistry;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.annotations.NamedEntityGraphDefinition;
 import org.hibernate.cfg.annotations.NamedProcedureCallDefinition;
 import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.xml.XmlDocument;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.tuple.entity.EntityTuplizerFactory;
 import org.hibernate.type.BasicType;
 import org.hibernate.type.CompositeCustomType;
 import org.hibernate.type.CustomType;
 import org.hibernate.type.SerializationException;
 import org.hibernate.usertype.CompositeUserType;
 import org.hibernate.usertype.UserType;
 
 /**
  * Represents one approach for bootstrapping Hibernate.  In fact, historically this was
  * <b>the</b> way to bootstrap Hibernate.
  * <p/>
  * The approach here is to define all configuration and mapping sources in one API
  * and to then build the {@link org.hibernate.SessionFactory} in one-shot.  The configuration
  * and mapping sources defined here are just held here until the SessionFactory is built.  This
  * is an important distinction from the legacy behavior of this class, where we would try to
  * incrementally build the mappings from sources as they were added.  The ramification of this
  * change in behavior is that users can add configuration and mapping sources here, but they can
  * no longer query the in-flight state of mappings ({@link org.hibernate.mapping.PersistentClass},
  * {@link org.hibernate.mapping.Collection}, etc) here.
  * <p/>
  * Note: Internally this class uses the new bootstrapping approach when asked to build the
  * SessionFactory.
  *
  * @author Gavin King
  * @author Steve Ebersole
  *
  * @see org.hibernate.SessionFactory
  */
 @SuppressWarnings( {"UnusedDeclaration"})
 public class Configuration {
     private static final CoreMessageLogger log = CoreLogging.messageLogger( Configuration.class );
 
 	public static final String ARTEFACT_PROCESSING_ORDER = AvailableSettings.ARTIFACT_PROCESSING_ORDER;
 
 	private final BootstrapServiceRegistry bootstrapServiceRegistry;
 	private final MetadataSources metadataSources;
 
 	// used during processing mappings
 	private ImplicitNamingStrategy implicitNamingStrategy;
 	private PhysicalNamingStrategy physicalNamingStrategy;
 	private List<BasicType> basicTypes = new ArrayList<BasicType>();
 	private List<TypeContributor> typeContributorRegistrations = new ArrayList<TypeContributor>();
 	private Map<String, NamedQueryDefinition> namedQueries;
 	private Map<String, NamedSQLQueryDefinition> namedSqlQueries;
 	private Map<String, NamedProcedureCallDefinition> namedProcedureCallMap;
 	private Map<String, ResultSetMappingDefinition> sqlResultSetMappings;
 	private Map<String, NamedEntityGraphDefinition> namedEntityGraphMap;
 
 	// used to build SF
 	private StandardServiceRegistryBuilder standardServiceRegistryBuilder;
 	private EntityNotFoundDelegate entityNotFoundDelegate;
 	private EntityTuplizerFactory entityTuplizerFactory;
 	private Interceptor interceptor;
 	private SessionFactoryObserver sessionFactoryObserver;
 	private CurrentTenantIdentifierResolver currentTenantIdentifierResolver;
 	private Properties properties;
 	private SharedCacheMode sharedCacheMode;
 
 	public Configuration() {
 		this( new BootstrapServiceRegistryBuilder().build() );
 	}
 
 	public Configuration(BootstrapServiceRegistry serviceRegistry) {
 		this.bootstrapServiceRegistry = serviceRegistry;
 		this.metadataSources = new MetadataSources( serviceRegistry );
 		reset();
 	}
 
 	public Configuration(MetadataSources metadataSources) {
 		this.bootstrapServiceRegistry = getBootstrapRegistry( metadataSources.getServiceRegistry() );
 		this.metadataSources = metadataSources;
 		reset();
 	}
 
 	private static BootstrapServiceRegistry getBootstrapRegistry(ServiceRegistry serviceRegistry) {
 		if ( BootstrapServiceRegistry.class.isInstance( serviceRegistry ) ) {
 			return (BootstrapServiceRegistry) serviceRegistry;
 		}
 		else if ( StandardServiceRegistry.class.isInstance( serviceRegistry ) ) {
 			final StandardServiceRegistry ssr = (StandardServiceRegistry) serviceRegistry;
 			return (BootstrapServiceRegistry) ssr.getParentServiceRegistry();
 		}
 
 		throw new HibernateException(
 				"No ServiceRegistry was passed to Configuration#buildSessionFactory " +
 						"and could not determine how to locate BootstrapServiceRegistry " +
 						"from Configuration instantiation"
 		);
 	}
 
 	protected void reset() {
 		implicitNamingStrategy = ImplicitNamingStrategyJpaCompliantImpl.INSTANCE;
 		physicalNamingStrategy = PhysicalNamingStrategyStandardImpl.INSTANCE;
 		namedQueries = new HashMap<String,NamedQueryDefinition>();
 		namedSqlQueries = new HashMap<String,NamedSQLQueryDefinition>();
 		sqlResultSetMappings = new HashMap<String, ResultSetMappingDefinition>();
 		namedEntityGraphMap = new HashMap<String, NamedEntityGraphDefinition>();
 		namedProcedureCallMap = new HashMap<String, NamedProcedureCallDefinition>(  );
 
 		standardServiceRegistryBuilder = new StandardServiceRegistryBuilder( bootstrapServiceRegistry );
 		entityTuplizerFactory = new EntityTuplizerFactory();
 		interceptor = EmptyInterceptor.INSTANCE;
 		properties = new Properties(  );
 		properties.putAll( standardServiceRegistryBuilder.getSettings());
 	}
 
 
 	// properties/settings ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Get all properties
 	 *
 	 * @return all properties
 	 */
 	public Properties getProperties() {
 		return properties;
 	}
 
 	/**
 	 * Specify a completely new set of properties
 	 *
 	 * @param properties The new set of properties
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setProperties(Properties properties) {
 		this.properties = properties;
 		return this;
 	}
 
 	/**
 	 * Get a property value by name
 	 *
 	 * @param propertyName The name of the property
 	 *
 	 * @return The value currently associated with that property name; may be null.
 	 */
 	public String getProperty(String propertyName) {
 		Object o = properties.get( propertyName );
 		return o instanceof String ? (String) o : null;
 	}
 
 	/**
 	 * Set a property value by name
 	 *
 	 * @param propertyName The name of the property to set
 	 * @param value The new property value
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setProperty(String propertyName, String value) {
 		properties.setProperty( propertyName, value );
 		return this;
 	}
 
 	/**
 	 * Add the given properties to ours.
 	 *
 	 * @param properties The properties to add.
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration addProperties(Properties properties) {
 		this.properties.putAll( properties );
 		return this;
 	}
 
 	public void setImplicitNamingStrategy(ImplicitNamingStrategy implicitNamingStrategy) {
 		this.implicitNamingStrategy = implicitNamingStrategy;
 	}
 
 	public void setPhysicalNamingStrategy(PhysicalNamingStrategy physicalNamingStrategy) {
 		this.physicalNamingStrategy = physicalNamingStrategy;
 	}
 
 	/**
 	 * Use the mappings and properties specified in an application resource named <tt>hibernate.cfg.xml</tt>.
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates we cannot find <tt>hibernate.cfg.xml</tt>
 	 *
 	 * @see #configure(String)
 	 */
 	public Configuration configure() throws HibernateException {
 		return configure( StandardServiceRegistryBuilder.DEFAULT_CFG_RESOURCE_NAME );
 	}
 
 	/**
 	 * Use the mappings and properties specified in the given application resource. The format of the resource is
 	 * defined in <tt>hibernate-configuration-3.0.dtd</tt>.
 	 *
 	 * @param resource The resource to use
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates we cannot find the named resource
 	 */
 	public Configuration configure(String resource) throws HibernateException {
 		standardServiceRegistryBuilder.configure( resource );
 		// todo : still need to have StandardServiceRegistryBuilder handle the "other cfg.xml" elements.
 		//		currently it just reads the config properties
+		properties.putAll( standardServiceRegistryBuilder.getSettings() );
 		return this;
 	}
 
 	/**
 	 * Intended for internal testing use only!!!
 	 */
 	public StandardServiceRegistryBuilder getStandardServiceRegistryBuilder() {
 		return standardServiceRegistryBuilder;
 	}
 
 	//	private void doConfigure(JaxbHibernateConfiguration jaxbHibernateConfiguration) {
 //		standardServiceRegistryBuilder.configure( jaxbHibernateConfiguration );
 //
 //		for ( JaxbMapping jaxbMapping : jaxbHibernateConfiguration.getSessionFactory().getMapping() ) {
 //			if ( StringHelper.isNotEmpty( jaxbMapping.getClazz() ) ) {
 //				addResource( jaxbMapping.getClazz().replace( '.', '/' ) + ".hbm.xml" );
 //			}
 //			else if ( StringHelper.isNotEmpty( jaxbMapping.getFile() ) ) {
 //				addFile( jaxbMapping.getFile() );
 //			}
 //			else if ( StringHelper.isNotEmpty( jaxbMapping.getJar() ) ) {
 //				addJar( new File( jaxbMapping.getJar() ) );
 //			}
 //			else if ( StringHelper.isNotEmpty( jaxbMapping.getPackage() ) ) {
 //				addPackage( jaxbMapping.getPackage() );
 //			}
 //			else if ( StringHelper.isNotEmpty( jaxbMapping.getResource() ) ) {
 //				addResource( jaxbMapping.getResource() );
 //			}
 //		}
 //	}
 
 	/**
 	 * Use the mappings and properties specified in the given document. The format of the document is defined in
 	 * <tt>hibernate-configuration-3.0.dtd</tt>.
 	 *
 	 * @param url URL from which you wish to load the configuration
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates a problem access the url
 	 */
 	public Configuration configure(URL url) throws HibernateException {
 		standardServiceRegistryBuilder.configure( url );
+		properties.putAll( standardServiceRegistryBuilder.getSettings() );
 		return this;
 	}
 
 	/**
 	 * Use the mappings and properties specified in the given application file. The format of the file is defined in
 	 * <tt>hibernate-configuration-3.0.dtd</tt>.
 	 *
 	 * @param configFile File from which you wish to load the configuration
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates a problem access the file
 	 */
 	public Configuration configure(File configFile) throws HibernateException {
 		standardServiceRegistryBuilder.configure( configFile );
+		properties.putAll( standardServiceRegistryBuilder.getSettings() );
 		return this;
 	}
 
 	/**
 	 * @deprecated No longer supported.
 	 */
 	@Deprecated
 	public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
 		return this;
 	}
 
 
 	// MetadataSources ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public Configuration registerTypeContributor(TypeContributor typeContributor) {
 		typeContributorRegistrations.add( typeContributor );
 		return this;
 	}
 
 	/**
 	 * Allows registration of a type into the type registry.  The phrase 'override' in the method name simply
 	 * reminds that registration *potentially* replaces a previously registered type .
 	 *
 	 * @param type The type to register.
 	 */
 	public Configuration registerTypeOverride(BasicType type) {
 		basicTypes.add( type );
 		return this;
 	}
 
 
 	public Configuration registerTypeOverride(UserType type, String[] keys) {
 		basicTypes.add( new CustomType( type, keys ) );
 		return this;
 	}
 
 	public Configuration registerTypeOverride(CompositeUserType type, String[] keys) {
 		basicTypes.add( new CompositeCustomType( type, keys ) );
 		return this;
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param xmlFile a path to a file
 	 * @return this (for method chaining purposes)
 	 * @throws org.hibernate.MappingException Indicates inability to locate or parse
 	 * the specified mapping file.
 	 * @see #addFile(java.io.File)
 	 */
 	public Configuration addFile(String xmlFile) throws MappingException {
 		metadataSources.addFile( xmlFile );
 		return this;
 	}
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param xmlFile a path to a file
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates inability to locate the specified mapping file.
 	 */
 	public Configuration addFile(File xmlFile) throws MappingException {
 		metadataSources.addFile( xmlFile );
 		return this;
 	}
 
 	/**
 	 * @deprecated No longer supported.
 	 */
 	@Deprecated
 	public void add(XmlDocument metadataXml) {
 	}
 
 	/**
 	 * Add a cached mapping file.  A cached file is a serialized representation
 	 * of the DOM structure of a particular mapping.  It is saved from a previous
 	 * call as a file with the name <tt>xmlFile + ".bin"</tt> where xmlFile is
 	 * the name of the original mapping file.
 	 * </p>
 	 * If a cached <tt>xmlFile + ".bin"</tt> exists and is newer than
 	 * <tt>xmlFile</tt> the <tt>".bin"</tt> file will be read directly. Otherwise
 	 * xmlFile is read and then serialized to <tt>xmlFile + ".bin"</tt> for use
 	 * the next time.
 	 *
 	 * @param xmlFile The cacheable mapping file to be added.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the cached file or processing
 	 * the non-cached file.
 	 */
 	public Configuration addCacheableFile(File xmlFile) throws MappingException {
 		metadataSources.addCacheableFile( xmlFile );
 		return this;
 	}
 
 	/**
 	 * <b>INTENDED FOR TESTSUITE USE ONLY!</b>
 	 * <p/>
 	 * Much like {@link #addCacheableFile(File)} except that here we will fail immediately if
 	 * the cache version cannot be found or used for whatever reason
 	 *
 	 * @param xmlFile The xml file, not the bin!
 	 *
 	 * @return The dom "deserialized" from the cached file.
 	 *
 	 * @throws SerializationException Indicates a problem deserializing the cached dom tree
 	 * @throws FileNotFoundException Indicates that the cached file was not found or was not usable.
 	 */
 	public Configuration addCacheableFileStrictly(File xmlFile) throws SerializationException, FileNotFoundException {
 		metadataSources.addCacheableFileStrictly( xmlFile );
 		return this;
 	}
 
 	/**
 	 * Add a cacheable mapping file.
 	 *
 	 * @param xmlFile The name of the file to be added.  This must be in a form
 	 * useable to simply construct a {@link java.io.File} instance.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the cached file or processing
 	 * the non-cached file.
 	 * @see #addCacheableFile(java.io.File)
 	 */
 	public Configuration addCacheableFile(String xmlFile) throws MappingException {
 		metadataSources.addCacheableFile( xmlFile );
 		return this;
 	}
 
 
 	/**
 	 * @deprecated No longer supported
 	 */
 	@Deprecated
 	public Configuration addXML(String xml) throws MappingException {
 		return this;
 	}
 
 	/**
 	 * Read mappings from a <tt>URL</tt>
 	 *
 	 * @param url The url for the mapping document to be read.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the URL or processing
 	 * the mapping document.
 	 */
 	public Configuration addURL(URL url) throws MappingException {
 		metadataSources.addURL( url );
 		return this;
 	}
 
 	/**
 	 * Read mappings from a DOM <tt>Document</tt>
 	 *
 	 * @param doc The DOM document
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the DOM or processing
 	 * the mapping document.
 	 *
 	 * @deprecated Use addURL, addResource, addFile, etc. instead
 	 */
 	@Deprecated
 	public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
 		metadataSources.addDocument( doc );
 		return this;
 	}
 
 	/**
 	 * Read mappings from an {@link java.io.InputStream}.
 	 *
 	 * @param xmlInputStream The input stream containing a DOM.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the stream, or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addInputStream(InputStream xmlInputStream) throws MappingException {
 		metadataSources.addInputStream( xmlInputStream );
 		return this;
 	}
 
 	/**
 	 * @deprecated This form (accepting a ClassLoader) is no longer supported.  Instead, add the ClassLoader
 	 * to the ClassLoaderService on the ServiceRegistry associated with this Configuration
 	 */
 	@Deprecated
 	public Configuration addResource(String resourceName, ClassLoader classLoader) throws MappingException {
 		return addResource( resourceName );
 	}
 
 	/**
 	 * Read mappings as a application resourceName (i.e. classpath lookup)
 	 * trying different class loaders.
 	 *
 	 * @param resourceName The resource name
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems locating the resource or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addResource(String resourceName) throws MappingException {
 		metadataSources.addResource( resourceName );
 		return this;
 	}
 
 	/**
 	 * Read a mapping as an application resource using the convention that a class
 	 * named <tt>foo.bar.Foo</tt> is mapped by a file <tt>foo/bar/Foo.hbm.xml</tt>
 	 * which can be resolved as a classpath resource.
 	 *
 	 * @param persistentClass The mapped class
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems locating the resource or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addClass(Class persistentClass) throws MappingException {
 		metadataSources.addClass( persistentClass );
 		return this;
 	}
 
 	/**
 	 * Read metadata from the annotations associated with this class.
 	 *
 	 * @param annotatedClass The class containing annotations
 	 *
 	 * @return this (for method chaining)
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public Configuration addAnnotatedClass(Class annotatedClass) {
 		metadataSources.addAnnotatedClass( annotatedClass );
 		return this;
 	}
 
 	/**
 	 * Read package-level metadata.
 	 *
 	 * @param packageName java package name
 	 *
 	 * @return this (for method chaining)
 	 *
 	 * @throws MappingException in case there is an error in the mapping data
 	 */
 	public Configuration addPackage(String packageName) throws MappingException {
 		metadataSources.addPackage( packageName );
 		return this;
 	}
 
 	/**
 	 * Read all mappings from a jar file
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param jar a jar file
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the jar file or
 	 * processing the contained mapping documents.
 	 */
 	public Configuration addJar(File jar) throws MappingException {
 		metadataSources.addJar( jar );
 		return this;
 	}
 
 	/**
 	 * Read all mapping documents from a directory tree.
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param dir The directory
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the jar file or
 	 * processing the contained mapping documents.
 	 */
 	public Configuration addDirectory(File dir) throws MappingException {
 		metadataSources.addDirectory( dir );
 		return this;
 	}
 
 
 	// SessionFactory building ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Retrieve the configured {@link Interceptor}.
 	 *
 	 * @return The current {@link Interceptor}
 	 */
 	public Interceptor getInterceptor() {
 		return interceptor;
 	}
 
 	/**
 	 * Set the current {@link Interceptor}
 	 *
 	 * @param interceptor The {@link Interceptor} to use for the {@link #buildSessionFactory built}
 	 * {@link SessionFactory}.
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setInterceptor(Interceptor interceptor) {
 		this.interceptor = interceptor;
 		return this;
 	}
 
 	public EntityTuplizerFactory getEntityTuplizerFactory() {
 		return entityTuplizerFactory;
 	}
 
 	/**
 	 * Retrieve the user-supplied delegate to handle non-existent entity
 	 * scenarios.  May be null.
 	 *
 	 * @return The user-supplied delegate
 	 */
 	public EntityNotFoundDelegate getEntityNotFoundDelegate() {
 		return entityNotFoundDelegate;
 	}
 
 	/**
 	 * Specify a user-supplied delegate to be used to handle scenarios where an entity could not be
 	 * located by specified id.  This is mainly intended for EJB3 implementations to be able to
 	 * control how proxy initialization errors should be handled...
 	 *
 	 * @param entityNotFoundDelegate The delegate to use
 	 */
 	public void setEntityNotFoundDelegate(EntityNotFoundDelegate entityNotFoundDelegate) {
 		this.entityNotFoundDelegate = entityNotFoundDelegate;
 	}
 
 	public SessionFactoryObserver getSessionFactoryObserver() {
 		return sessionFactoryObserver;
 	}
 
 	public void setSessionFactoryObserver(SessionFactoryObserver sessionFactoryObserver) {
 		this.sessionFactoryObserver = sessionFactoryObserver;
 	}
 
 	public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver() {
 		return currentTenantIdentifierResolver;
 	}
 
 	public void setCurrentTenantIdentifierResolver(CurrentTenantIdentifierResolver currentTenantIdentifierResolver) {
 		this.currentTenantIdentifierResolver = currentTenantIdentifierResolver;
 	}
 
 	/**
 	 * Create a {@link SessionFactory} using the properties and mappings in this configuration. The
 	 * SessionFactory will be immutable, so changes made to this Configuration after building the
 	 * SessionFactory will not affect it.
 	 *
 	 * @param serviceRegistry The registry of services to be used in creating this session factory.
 	 *
 	 * @return The built {@link SessionFactory}
 	 *
 	 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 	 */
 	public SessionFactory buildSessionFactory(ServiceRegistry serviceRegistry) throws HibernateException {
 		log.debug( "Building session factory using provided StandardServiceRegistry" );
 
 		final MetadataBuilder metadataBuilder = metadataSources.getMetadataBuilder( (StandardServiceRegistry) serviceRegistry );
 		if ( implicitNamingStrategy != null ) {
 			metadataBuilder.with( implicitNamingStrategy );
 		}
 		if ( physicalNamingStrategy != null ) {
 			metadataBuilder.with( physicalNamingStrategy );
 		}
 		if ( sharedCacheMode != null ) {
 			metadataBuilder.with( sharedCacheMode );
 		}
 		if ( !typeContributorRegistrations.isEmpty() ) {
 			for ( TypeContributor typeContributor : typeContributorRegistrations ) {
 				metadataBuilder.with( typeContributor );
 			}
 		}
 		if ( !basicTypes.isEmpty() ) {
 			for ( BasicType basicType : basicTypes ) {
 				metadataBuilder.with( basicType );
 			}
 		}
 
 		final Metadata metadata = metadataBuilder.build();
 
 		final SessionFactoryBuilder sessionFactoryBuilder = metadata.getSessionFactoryBuilder();
 		if ( interceptor != null && interceptor != EmptyInterceptor.INSTANCE ) {
 			sessionFactoryBuilder.with( interceptor );
 		}
 		if ( getSessionFactoryObserver() != null ) {
 			sessionFactoryBuilder.add( getSessionFactoryObserver() );
 		}
 		if ( entityNotFoundDelegate != null ) {
 			sessionFactoryBuilder.with( entityNotFoundDelegate );
 		}
 		if ( entityTuplizerFactory != null ) {
 			sessionFactoryBuilder.with( entityTuplizerFactory );
 		}
 
 		return sessionFactoryBuilder.build();
 	}
 
 
 	/**
 	 * Create a {@link SessionFactory} using the properties and mappings in this configuration. The
 	 * {@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} after
 	 * building the {@link SessionFactory} will not affect it.
 	 *
 	 * @return The build {@link SessionFactory}
 	 *
 	 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 	 */
 	public SessionFactory buildSessionFactory() throws HibernateException {
 		log.debug( "Building session factory using internal StandardServiceRegistryBuilder" );
 		standardServiceRegistryBuilder.applySettings( properties );
 		return buildSessionFactory( standardServiceRegistryBuilder.build() );
 	}
 
 
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// these just "pass through" to MetadataSources
 
 	public void addAuxiliaryDatabaseObject(AuxiliaryDatabaseObject object) {
 		metadataSources.addAuxiliaryDatabaseObject( object );
 	}
 
 	public Map getSqlFunctions() {
 		return metadataSources.getSqlFunctions();
 	}
 
 	public void addSqlFunction(String functionName, SQLFunction function) {
 		metadataSources.addSqlFunction( functionName, function );
 	}
 
 	/**
 	 * Adds the AttributeConverter Class to this Configuration.
 	 *
 	 * @param attributeConverterClass The AttributeConverter class.
 	 * @param autoApply Should the AttributeConverter be auto applied to property types as specified
 	 * by its "entity attribute" parameterized type?
 	 */
 	public void addAttributeConverter(Class<? extends AttributeConverter> attributeConverterClass, boolean autoApply) {
 		metadataSources.addAttributeConverter( attributeConverterClass, autoApply );
 	}
 
 	/**
 	 * Adds the AttributeConverter Class to this Configuration.
 	 *
 	 * @param attributeConverterClass The AttributeConverter class.
 	 */
 	public void addAttributeConverter(Class<? extends AttributeConverter> attributeConverterClass) {
 		metadataSources.addAttributeConverter( attributeConverterClass );
 	}
 
 	/**
 	 * Adds the AttributeConverter instance to this Configuration.  This form is mainly intended for developers
 	 * to programatically add their own AttributeConverter instance.  HEM, instead, uses the
 	 * {@link #addAttributeConverter(Class, boolean)} form
 	 *
 	 * @param attributeConverter The AttributeConverter instance.
 	 */
 	public void addAttributeConverter(AttributeConverter attributeConverter) {
 		metadataSources.addAttributeConverter( attributeConverter );
 	}
 
 	/**
 	 * Adds the AttributeConverter instance to this Configuration.  This form is mainly intended for developers
 	 * to programatically add their own AttributeConverter instance.  HEM, instead, uses the
 	 * {@link #addAttributeConverter(Class, boolean)} form
 	 *
 	 * @param attributeConverter The AttributeConverter instance.
 	 * @param autoApply Should the AttributeConverter be auto applied to property types as specified
 	 * by its "entity attribute" parameterized type?
 	 */
 	public void addAttributeConverter(AttributeConverter attributeConverter, boolean autoApply) {
 		metadataSources.addAttributeConverter( attributeConverter, autoApply );
 	}
 
 	public void addAttributeConverter(AttributeConverterDefinition definition) {
 		metadataSources.addAttributeConverter( definition );
 	}
 
 	/**
 	 * Sets the SharedCacheMode to use.
 	 *
 	 * Note that at the moment, only {@link javax.persistence.SharedCacheMode#ALL} has
 	 * any effect in terms of {@code hbm.xml} binding.
 	 *
 	 * @param sharedCacheMode The SharedCacheMode to use
 	 */
 	public void setSharedCacheMode(SharedCacheMode sharedCacheMode) {
 		this.sharedCacheMode = sharedCacheMode;
 	}
 
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// todo : decide about these
 
 	public Map getNamedSQLQueries() {
 		return namedSqlQueries;
 	}
 
 	public Map getSqlResultSetMappings() {
 		return sqlResultSetMappings;
 	}
 
 	public java.util.Collection<NamedEntityGraphDefinition> getNamedEntityGraphs() {
 		return namedEntityGraphMap == null
 				? Collections.<NamedEntityGraphDefinition>emptyList()
 				: namedEntityGraphMap.values();
 	}
 
 
 	public Map<String, NamedQueryDefinition> getNamedQueries() {
 		return namedQueries;
 	}
 
 	public Map<String, NamedProcedureCallDefinition> getNamedProcedureCallMap() {
 		return namedProcedureCallMap;
 	}
 
 	/**
 	 * @deprecated Does nothing
 	 */
 	@Deprecated
 	public void buildMappings() {
 	}
 
 
 
 
 
 
 
 
 
 
 
 	/**
 	 * Generate DDL for dropping tables
 	 *
 	 * @param dialect The dialect for which to generate the drop script
 
 	 * @return The sequence of DDL commands to drop the schema objects
 
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	public String[] generateDropSchemaScript(Dialect dialect) throws HibernateException {
 		return new String[0];
 	}
 
 	/**
 	 * @param dialect The dialect for which to generate the creation script
 	 *
 	 * @return The sequence of DDL commands to create the schema objects
 	 *
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 	 *
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public String[] generateSchemaCreationScript(Dialect dialect) throws HibernateException {
 		return new String[0];
 	}
 
 	/**
 	 * Adds the incoming properties to the internal properties structure, as long as the internal structure does not
 	 * already contain an entry for the given key.
 	 *
 	 * @param properties The properties to merge
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration mergeProperties(Properties properties) {
 		for ( Map.Entry entry : properties.entrySet() ) {
 			if ( this.properties.containsKey( entry.getKey() ) ) {
 				continue;
 			}
 			this.properties.setProperty( (String) entry.getKey(), (String) entry.getValue() );
 		}
 		return this;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/AuditReaderFactory.java b/hibernate-envers/src/main/java/org/hibernate/envers/AuditReaderFactory.java
index c19facf355..3e483410d2 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/AuditReaderFactory.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/AuditReaderFactory.java
@@ -1,106 +1,89 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers;
 
 import javax.persistence.EntityManager;
 
 import org.hibernate.Session;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.envers.event.spi.EnversListener;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.reader.AuditReaderImpl;
-import org.hibernate.event.service.spi.EventListenerRegistry;
-import org.hibernate.event.spi.EventType;
-import org.hibernate.event.spi.PostInsertEventListener;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class AuditReaderFactory {
 	private AuditReaderFactory() {
 	}
 
 	/**
 	 * Create an audit reader associated with an open session.
 	 *
 	 * @param session An open session.
 	 *
 	 * @return An audit reader associated with the given sesison. It shouldn't be used
 	 *         after the session is closed.
 	 *
 	 * @throws AuditException When the given required listeners aren't installed.
 	 */
 	public static AuditReader get(Session session) throws AuditException {
 		SessionImplementor sessionImpl;
 		if ( !(session instanceof SessionImplementor) ) {
 			sessionImpl = (SessionImplementor) session.getSessionFactory().getCurrentSession();
 		}
 		else {
 			sessionImpl = (SessionImplementor) session;
 		}
 
-		// todo : I wonder if there is a better means to do this via "named lookup" based on the session factory name/uuid
-		final EventListenerRegistry listenerRegistry = sessionImpl
-				.getFactory()
-				.getServiceRegistry()
-				.getService( EventListenerRegistry.class );
+		final ServiceRegistry serviceRegistry = sessionImpl.getFactory().getServiceRegistry();
+		final EnversService enversService = serviceRegistry.getService( EnversService.class );
 
-		for ( PostInsertEventListener listener : listenerRegistry.getEventListenerGroup( EventType.POST_INSERT )
-				.listeners() ) {
-			if ( listener instanceof EnversListener ) {
-				// todo : slightly different from original code in that I am not checking the other listener groups...
-				return new AuditReaderImpl(
-						((EnversListener) listener).getAuditConfiguration(),
-						session,
-						sessionImpl
-				);
-			}
-		}
-
-		throw new AuditException( "Envers listeners were not properly registered" );
+		return new AuditReaderImpl( enversService, session, sessionImpl );
 	}
 
 	/**
 	 * Create an audit reader associated with an open entity manager.
 	 *
 	 * @param entityManager An open entity manager.
 	 *
 	 * @return An audit reader associated with the given entity manager. It shouldn't be used
 	 *         after the entity manager is closed.
 	 *
 	 * @throws AuditException When the given entity manager is not based on Hibernate, or if the required
 	 * listeners aren't installed.
 	 */
 	public static AuditReader get(EntityManager entityManager) throws AuditException {
 		if ( entityManager.getDelegate() instanceof Session ) {
 			return get( (Session) entityManager.getDelegate() );
 		}
 
 		if ( entityManager.getDelegate() instanceof EntityManager ) {
 			return get( (EntityManager) entityManager.getDelegate() );
 		}
 
 		throw new AuditException( "Hibernate EntityManager not present!" );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/AdditionalJaxbMappingProducerImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/AdditionalJaxbMappingProducerImpl.java
new file mode 100644
index 0000000000..10eaffdb4e
--- /dev/null
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/AdditionalJaxbMappingProducerImpl.java
@@ -0,0 +1,144 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2015, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.envers.boot.internal;
+
+import java.io.BufferedInputStream;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.PrintWriter;
+import java.io.Writer;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import javax.xml.transform.dom.DOMSource;
+
+import org.hibernate.HibernateException;
+import org.hibernate.boot.archive.internal.ByteArrayInputStreamAccess;
+import org.hibernate.boot.jaxb.Origin;
+import org.hibernate.boot.jaxb.SourceType;
+import org.hibernate.boot.jaxb.hbm.spi.JaxbHbmHibernateMapping;
+import org.hibernate.boot.jaxb.internal.MappingBinder;
+import org.hibernate.boot.jaxb.spi.Binding;
+import org.hibernate.boot.model.source.internal.hbm.MappingDocument;
+import org.hibernate.boot.spi.AdditionalJaxbMappingProducer;
+import org.hibernate.boot.spi.MetadataBuildingContext;
+import org.hibernate.boot.spi.MetadataImplementor;
+import org.hibernate.envers.configuration.internal.MappingCollector;
+import org.hibernate.service.ServiceRegistry;
+
+import org.jboss.jandex.IndexView;
+import org.jboss.logging.Logger;
+
+import org.dom4j.DocumentException;
+import org.dom4j.io.DOMWriter;
+import org.dom4j.io.OutputFormat;
+import org.dom4j.io.XMLWriter;
+import org.dom4j.Document;
+
+/**
+ * @author Steve Ebersole
+ */
+public class AdditionalJaxbMappingProducerImpl implements AdditionalJaxbMappingProducer {
+	private static final Logger log = Logger.getLogger( AdditionalJaxbMappingProducerImpl.class );
+
+	@Override
+	public Collection<MappingDocument> produceAdditionalMappings(
+			final MetadataImplementor metadata,
+			IndexView jandexIndex,
+			final MappingBinder mappingBinder,
+			final MetadataBuildingContext buildingContext) {
+		final ServiceRegistry serviceRegistry = metadata.getMetadataBuildingOptions().getServiceRegistry();
+		final EnversService enversService = serviceRegistry.getService( EnversService.class );
+
+		if ( !enversService.isEnabled() ) {
+			// short-circuit if envers integration has been disabled.
+			return Collections.emptyList();
+		}
+
+		final ArrayList<MappingDocument> additionalMappingDocuments = new ArrayList<MappingDocument>();
+
+		// atm we do not have distinct origin info for envers
+		final Origin origin = new Origin( SourceType.OTHER, "envers" );
+//		final DOMWriter writer = new DOMWriter();
+
+		final MappingCollector mappingCollector = new MappingCollector() {
+			@Override
+			public void addDocument(Document document) throws DocumentException {
+				dump( document );
+
+				// while the commented-out code here is more efficient (well, understanding that
+				// this whole process is un-efficient)  it leads to un-decipherable messages when
+				// we get mapping mapping errors from envers output.
+//				final DOMSource domSource = new DOMSource( writer.write( document ) );
+//				domSource.setSystemId( "envers" );
+//				final Binding jaxbBinding = mappingBinder.bind( domSource, origin );
+
+				// this form at least allows us to get better error messages
+				final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+				final Writer w = new PrintWriter( baos );
+				try {
+					final XMLWriter xw = new XMLWriter( w, new OutputFormat( " ", true ) );
+					xw.write( document );
+					w.flush();
+				}
+				catch (IOException e) {
+					throw new HibernateException( "Unable to bind Envers-generated XML", e );
+				}
+
+				ByteArrayInputStream bais = new ByteArrayInputStream( baos.toByteArray() );
+				BufferedInputStream bis = new BufferedInputStream( bais );
+				final Binding jaxbBinding = mappingBinder.bind( bis, origin );
+
+				final JaxbHbmHibernateMapping jaxbRoot = (JaxbHbmHibernateMapping) jaxbBinding.getRoot();
+				additionalMappingDocuments.add( new MappingDocument( jaxbRoot, origin, buildingContext ) );
+			}
+		};
+
+		enversService.initialize( metadata, mappingCollector );
+
+		return additionalMappingDocuments;
+	}
+
+	private static void dump(Document document) {
+		if ( !log.isTraceEnabled() ) {
+			return;
+		}
+
+		final ByteArrayOutputStream baos = new ByteArrayOutputStream();
+		final Writer w = new PrintWriter( baos );
+
+		try {
+			final XMLWriter xw = new XMLWriter( w, new OutputFormat( " ", true ) );
+			xw.write( document );
+			w.flush();
+		}
+		catch (IOException e1) {
+			e1.printStackTrace();
+		}
+
+		log.tracef( "Envers-generate entity mapping -----------------------------\n%s", baos.toString() );
+		log.trace( "------------------------------------------------------------" );
+	}
+}
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversIntegrator.java b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversIntegrator.java
similarity index 53%
rename from hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversIntegrator.java
rename to hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversIntegrator.java
index 30b7d619ed..6f7ddd8ac9 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversIntegrator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversIntegrator.java
@@ -1,119 +1,99 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.envers.event.spi;
+package org.hibernate.envers.boot.internal;
 
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.cfg.Configuration;
+import org.hibernate.HibernateException;
+import org.hibernate.boot.Metadata;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.event.spi.EnversListenerDuplicationStrategy;
+import org.hibernate.envers.event.spi.EnversPostCollectionRecreateEventListenerImpl;
+import org.hibernate.envers.event.spi.EnversPostDeleteEventListenerImpl;
+import org.hibernate.envers.event.spi.EnversPostInsertEventListenerImpl;
+import org.hibernate.envers.event.spi.EnversPostUpdateEventListenerImpl;
+import org.hibernate.envers.event.spi.EnversPreCollectionRemoveEventListenerImpl;
+import org.hibernate.envers.event.spi.EnversPreCollectionUpdateEventListenerImpl;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
-import org.jboss.logging.Logger;
-
 /**
- * Provides integration for Envers into Hibernate, which mainly means registering the proper event listeners.
+ * Hooks up Envers event listeners.
  *
  * @author Steve Ebersole
  */
 public class EnversIntegrator implements Integrator {
-	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
-			CoreMessageLogger.class,
-			EnversIntegrator.class.getName()
-	);
-
-	/**
-	 * The name of a configuration setting that can be used to control whether auto registration of envers listeners
-	 * should happen or not.  Default is true
-	 */
-	public static final String AUTO_REGISTER = "hibernate.listeners.envers.autoRegister";
-    private AuditConfiguration enversConfiguration;
+	public static final String AUTO_REGISTER = EnversService.LEGACY_AUTO_REGISTER;
 
-	@Override
 	public void integrate(
-			Configuration configuration,
+			Metadata metadata,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
-		final boolean autoRegister = ConfigurationHelper.getBoolean(
-				AUTO_REGISTER,
-				configuration.getProperties(),
-				true
-		);
-		if ( !autoRegister ) {
-			LOG.debug( "Skipping Envers listener auto registration" );
+		final EnversService enversService = serviceRegistry.getService( EnversService.class );
+		if ( !enversService.isEnabled() ) {
 			return;
 		}
 
+		if ( !enversService.isInitialized() ) {
+			throw new HibernateException(
+					"Expecting EnversService to have been initialized prior to call to EnversIntegrator#integrate"
+			);
+		}
+
 		final EventListenerRegistry listenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 		listenerRegistry.addDuplicationStrategy( EnversListenerDuplicationStrategy.INSTANCE );
 
-        enversConfiguration = AuditConfiguration.getFor(
-				configuration,
-				serviceRegistry.getService(
-						ClassLoaderService.class
-				)
-		);
-
-		if ( enversConfiguration.getEntCfg().hasAuditedEntities() ) {
+		if ( enversService.getEntitiesConfigurations().hasAuditedEntities() ) {
 			listenerRegistry.appendListeners(
-					EventType.POST_DELETE, new EnversPostDeleteEventListenerImpl(
-					enversConfiguration
-			)
+					EventType.POST_DELETE,
+					new EnversPostDeleteEventListenerImpl( enversService )
 			);
 			listenerRegistry.appendListeners(
-					EventType.POST_INSERT, new EnversPostInsertEventListenerImpl(
-					enversConfiguration
-			)
+					EventType.POST_INSERT,
+					new EnversPostInsertEventListenerImpl( enversService )
 			);
 			listenerRegistry.appendListeners(
-					EventType.POST_UPDATE, new EnversPostUpdateEventListenerImpl(
-					enversConfiguration
-			)
+					EventType.POST_UPDATE,
+					new EnversPostUpdateEventListenerImpl( enversService )
 			);
 			listenerRegistry.appendListeners(
 					EventType.POST_COLLECTION_RECREATE,
-					new EnversPostCollectionRecreateEventListenerImpl( enversConfiguration )
+					new EnversPostCollectionRecreateEventListenerImpl( enversService )
 			);
 			listenerRegistry.appendListeners(
 					EventType.PRE_COLLECTION_REMOVE,
-					new EnversPreCollectionRemoveEventListenerImpl( enversConfiguration )
+					new EnversPreCollectionRemoveEventListenerImpl( enversService )
 			);
 			listenerRegistry.appendListeners(
 					EventType.PRE_COLLECTION_UPDATE,
-					new EnversPreCollectionUpdateEventListenerImpl( enversConfiguration )
+					new EnversPreCollectionUpdateEventListenerImpl( enversService )
 			);
 		}
 	}
 
 	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
-		if ( enversConfiguration != null ) {
-			enversConfiguration.destroy();
-		}
+		// nothing to do
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversService.java b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversService.java
new file mode 100644
index 0000000000..9f1be77c97
--- /dev/null
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversService.java
@@ -0,0 +1,97 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2015, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.envers.boot.internal;
+
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.spi.MetadataImplementor;
+import org.hibernate.envers.configuration.internal.AuditEntitiesConfiguration;
+import org.hibernate.envers.configuration.internal.GlobalConfiguration;
+import org.hibernate.envers.configuration.internal.MappingCollector;
+import org.hibernate.envers.internal.entities.EntitiesConfigurations;
+import org.hibernate.envers.internal.revisioninfo.ModifiedEntityNamesReader;
+import org.hibernate.envers.internal.revisioninfo.RevisionInfoNumberReader;
+import org.hibernate.envers.internal.revisioninfo.RevisionInfoQueryCreator;
+import org.hibernate.envers.internal.synchronization.AuditProcessManager;
+import org.hibernate.envers.strategy.AuditStrategy;
+import org.hibernate.service.Service;
+
+/**
+ * Provides central access to Envers' configuration.
+ *
+ * In many ways, this replaces the legacy static map Envers used originally as
+ * a means to share the old AuditConfiguration.
+ *
+ * @author Steve Ebersole
+ */
+public interface EnversService extends Service {
+	/**
+	 * The name of the configuration setting used to control whether the Envers integration
+	 * is enabled.  Default is true
+	 */
+	public static final String INTEGRATION_ENABLED = "hibernate.integration.envers.enabled";
+
+	/**
+	 * The name of the legacy configuration setting used to control whether auto registration
+	 * of envers listeners should happen or not.  Default is true
+	 */
+	public static final String LEGACY_AUTO_REGISTER = "hibernate.listeners.envers.autoRegister";
+
+	/**
+	 * Is the Envers integration enabled?  This is generally used as a
+	 * protection for other Envers services (in the ServiceLoader sense)
+	 * determine whether they should do their work.
+	 *
+	 * @return {@code true} If the integration is enabled; {@code false} otherwise.
+	 */
+	boolean isEnabled();
+
+	/**
+	 * Assuming {@link #isEnabled()} is {@code true}, has {@link #initialize}
+	 * been called yet?
+	 *
+	 * @return {@code true} indicates {@link #initialize} has been called; {@code false}
+	 * indicates that {@link #initialize} has not (yet) been called.
+	 */
+	boolean isInitialized();
+
+	void initialize(MetadataImplementor metadata, MappingCollector mappingCollector);
+
+	GlobalConfiguration getGlobalConfiguration();
+
+	AuditEntitiesConfiguration getAuditEntitiesConfiguration();
+
+	AuditProcessManager getAuditProcessManager();
+
+	AuditStrategy getAuditStrategy();
+
+	EntitiesConfigurations getEntitiesConfigurations();
+
+	RevisionInfoQueryCreator getRevisionInfoQueryCreator();
+
+	RevisionInfoNumberReader getRevisionInfoNumberReader();
+
+	ModifiedEntityNamesReader getModifiedEntityNamesReader();
+
+	ClassLoaderService getClassLoaderService();
+}
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversServiceContributor.java b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversServiceContributor.java
new file mode 100644
index 0000000000..0359668e4a
--- /dev/null
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversServiceContributor.java
@@ -0,0 +1,40 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2015, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.envers.boot.internal;
+
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
+import org.hibernate.service.spi.ServiceContributor;
+
+/**
+ * ServiceContributor implementation pushing the EnversService into
+ * the registry
+ *
+ * @author Steve Ebersole
+ */
+public class EnversServiceContributor implements ServiceContributor {
+	@Override
+	public void contribute(StandardServiceRegistryBuilder serviceRegistryBuilder) {
+		serviceRegistryBuilder.addInitiator( EnversServiceInitiator.INSTANCE );
+	}
+}
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversServiceImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversServiceImpl.java
new file mode 100644
index 0000000000..27f46ce0ae
--- /dev/null
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversServiceImpl.java
@@ -0,0 +1,304 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2015, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.envers.boot.internal;
+
+import java.util.Map;
+import java.util.Properties;
+
+import org.hibernate.MappingException;
+import org.hibernate.annotations.common.reflection.ReflectionManager;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.spi.MetadataImplementor;
+import org.hibernate.engine.config.spi.ConfigurationService;
+import org.hibernate.envers.configuration.internal.AuditEntitiesConfiguration;
+import org.hibernate.envers.configuration.internal.EntitiesConfigurator;
+import org.hibernate.envers.configuration.internal.GlobalConfiguration;
+import org.hibernate.envers.configuration.internal.MappingCollector;
+import org.hibernate.envers.configuration.internal.RevisionInfoConfiguration;
+import org.hibernate.envers.configuration.internal.RevisionInfoConfigurationResult;
+import org.hibernate.envers.internal.entities.EntitiesConfigurations;
+import org.hibernate.envers.internal.entities.PropertyData;
+import org.hibernate.envers.internal.revisioninfo.ModifiedEntityNamesReader;
+import org.hibernate.envers.internal.revisioninfo.RevisionInfoNumberReader;
+import org.hibernate.envers.internal.revisioninfo.RevisionInfoQueryCreator;
+import org.hibernate.envers.internal.synchronization.AuditProcessManager;
+import org.hibernate.envers.internal.tools.ReflectionTools;
+import org.hibernate.envers.strategy.AuditStrategy;
+import org.hibernate.envers.strategy.ValidityAuditStrategy;
+import org.hibernate.internal.util.ReflectHelper;
+import org.hibernate.internal.util.config.ConfigurationHelper;
+import org.hibernate.property.Getter;
+import org.hibernate.service.ServiceRegistry;
+import org.hibernate.service.spi.Configurable;
+import org.hibernate.service.spi.Stoppable;
+
+import org.jboss.logging.Logger;
+
+/**
+ * Provides central access to Envers' configuration.
+ *
+ * In many ways, this replaces the legacy static map Envers used originally as
+ * a means to share the old AuditConfiguration.
+ *
+ * @author Steve Ebersole
+ */
+public class EnversServiceImpl implements EnversService, Configurable, Stoppable {
+	private static final Logger log = Logger.getLogger( EnversServiceImpl.class );
+
+	private boolean integrationEnabled;
+	private boolean initialized;
+
+	private ServiceRegistry serviceRegistry;
+	private ClassLoaderService classLoaderService;
+
+	// todo : not at all a fan of all these...
+	//		1) GlobalConfiguration, AuditEntitiesConfiguration and AuditStrategy are
+	// 			all "configuration" objects.  They seem unnecessarily split apart from
+	//			each other.  Why 3?  Why not just one?
+	//		2) AuditProcessManager is a glorified Map of AuditProcess instances (BeforeTransactionCompletionProcess)
+	//			keyed by Transaction (Session)
+	//		3) Make sure that the info kept here is all really needed at run time, and not just at
+	//			"mapping time"
+	private GlobalConfiguration globalConfiguration;
+	private AuditEntitiesConfiguration auditEntitiesConfiguration;
+	private AuditProcessManager auditProcessManager;
+	private AuditStrategy auditStrategy;
+	private EntitiesConfigurations entitiesConfigurations;
+	private RevisionInfoQueryCreator revisionInfoQueryCreator;
+	private RevisionInfoNumberReader revisionInfoNumberReader;
+	private ModifiedEntityNamesReader modifiedEntityNamesReader;
+
+	@Override
+	public void configure(Map configurationValues) {
+		final boolean legacySetting = ConfigurationHelper.getBoolean( LEGACY_AUTO_REGISTER, configurationValues, true );
+		this.integrationEnabled = ConfigurationHelper.getBoolean( INTEGRATION_ENABLED, configurationValues, legacySetting );
+
+		log.infof( "Envers integration enabled? : %s", integrationEnabled );
+	}
+
+	@Override
+	public boolean isEnabled() {
+		return integrationEnabled;
+	}
+
+	@Override
+	public boolean isInitialized() {
+		return initialized;
+	}
+
+	@Override
+	public void initialize(final MetadataImplementor metadata, final MappingCollector mappingCollector) {
+		if ( initialized ) {
+			throw new UnsupportedOperationException( "EnversService#initialize should be called only once" );
+		}
+
+		initialized = true;
+
+
+		this.serviceRegistry = metadata.getMetadataBuildingOptions().getServiceRegistry();
+
+		this.classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
+
+		// NOTE : we use the TCCL here for hibernate-commons-annotations
+		classLoaderService.withTccl(
+				new ClassLoaderService.Work<Void>() {
+					@Override
+					public Void perform() {
+						doInitialize( metadata, mappingCollector, serviceRegistry, classLoaderService );
+						return null;
+					}
+				}
+		);
+	}
+
+	private void doInitialize(
+			final MetadataImplementor metadata,
+			final MappingCollector mappingCollector,
+			ServiceRegistry serviceRegistry,
+			ClassLoaderService classLoaderService) {
+		final ConfigurationService cfgService = serviceRegistry.getService( ConfigurationService.class );
+		final Properties properties = new Properties();
+		properties.putAll( cfgService.getSettings() );
+
+		this.globalConfiguration = new GlobalConfiguration( properties, classLoaderService );
+
+		final ReflectionManager reflectionManager = metadata.getMetadataBuildingOptions()
+				.getReflectionManager();
+		final RevisionInfoConfiguration revInfoCfg = new RevisionInfoConfiguration( globalConfiguration );
+		final RevisionInfoConfigurationResult revInfoCfgResult = revInfoCfg.configure(
+				metadata,
+				reflectionManager
+		);
+
+		EnversServiceImpl.this.auditEntitiesConfiguration = new AuditEntitiesConfiguration(
+				properties,
+				revInfoCfgResult.getRevisionInfoEntityName()
+		);
+		EnversServiceImpl.this.auditProcessManager = new AuditProcessManager( revInfoCfgResult.getRevisionInfoGenerator() );
+		EnversServiceImpl.this.revisionInfoQueryCreator = revInfoCfgResult.getRevisionInfoQueryCreator();
+		EnversServiceImpl.this.revisionInfoNumberReader = revInfoCfgResult.getRevisionInfoNumberReader();
+		EnversServiceImpl.this.modifiedEntityNamesReader = revInfoCfgResult.getModifiedEntityNamesReader();
+		EnversServiceImpl.this.auditStrategy = initializeAuditStrategy(
+				auditEntitiesConfiguration.getAuditStrategyName(),
+				revInfoCfgResult.getRevisionInfoClass(),
+				revInfoCfgResult.getRevisionInfoTimestampData(),
+				classLoaderService
+		);
+		EnversServiceImpl.this.entitiesConfigurations = new EntitiesConfigurator().configure(
+				metadata,
+				serviceRegistry,
+				reflectionManager,
+				mappingCollector,
+				globalConfiguration,
+				auditEntitiesConfiguration,
+				auditStrategy,
+				revInfoCfgResult.getRevisionInfoXmlMapping(),
+				revInfoCfgResult.getRevisionInfoRelationMapping()
+		);
+	}
+
+	private static AuditStrategy initializeAuditStrategy(
+			String auditStrategyName,
+			Class<?> revisionInfoClass,
+			PropertyData revisionInfoTimestampData,
+			ClassLoaderService classLoaderService) {
+		AuditStrategy strategy;
+
+		try {
+			Class<?> auditStrategyClass = loadClass( auditStrategyName, classLoaderService );
+			strategy = (AuditStrategy) ReflectHelper.getDefaultConstructor( auditStrategyClass ).newInstance();
+		}
+		catch (Exception e) {
+			throw new MappingException(
+					String.format( "Unable to create AuditStrategy [%s] instance.", auditStrategyName ),
+					e
+			);
+		}
+
+		if ( strategy instanceof ValidityAuditStrategy ) {
+			// further initialization required
+			final Getter revisionTimestampGetter = ReflectionTools.getGetter(
+					revisionInfoClass,
+					revisionInfoTimestampData
+			);
+			( (ValidityAuditStrategy) strategy ).setRevisionTimestampGetter( revisionTimestampGetter );
+		}
+
+		return strategy;
+	}
+
+	/**
+	 * Load a class by name, preferring our ClassLoader and then the ClassLoaderService.
+	 *
+	 * @param auditStrategyName The name of the class to load
+	 * @param classLoaderService The ClassLoaderService
+	 *
+	 * @return The loaded class.
+	 */
+	private static Class<?> loadClass(String auditStrategyName, ClassLoaderService classLoaderService) {
+		try {
+			return EnversServiceImpl.class.getClassLoader().loadClass( auditStrategyName );
+		}
+		catch (Exception e) {
+			return ReflectionTools.loadClass( auditStrategyName, classLoaderService );
+		}
+	}
+
+	@Override
+	public GlobalConfiguration getGlobalConfiguration() {
+		if ( !initialized ) {
+			throw new IllegalStateException( "Service is not yet initialized" );
+		}
+		return globalConfiguration;
+	}
+
+	@Override
+	public AuditEntitiesConfiguration getAuditEntitiesConfiguration() {
+		if ( !initialized ) {
+			throw new IllegalStateException( "Service is not yet initialized" );
+		}
+		return auditEntitiesConfiguration;
+	}
+
+	@Override
+	public AuditProcessManager getAuditProcessManager() {
+		if ( !initialized ) {
+			throw new IllegalStateException( "Service is not yet initialized" );
+		}
+		return auditProcessManager;
+	}
+
+	@Override
+	public AuditStrategy getAuditStrategy() {
+		if ( !initialized ) {
+			throw new IllegalStateException( "Service is not yet initialized" );
+		}
+		return auditStrategy;
+	}
+
+	@Override
+	public EntitiesConfigurations getEntitiesConfigurations() {
+		if ( !initialized ) {
+			throw new IllegalStateException( "Service is not yet initialized" );
+		}
+		return entitiesConfigurations;
+	}
+
+	@Override
+	public RevisionInfoQueryCreator getRevisionInfoQueryCreator() {
+		if ( !initialized ) {
+			throw new IllegalStateException( "Service is not yet initialized" );
+		}
+		return revisionInfoQueryCreator;
+	}
+
+	@Override
+	public RevisionInfoNumberReader getRevisionInfoNumberReader() {
+		if ( !initialized ) {
+			throw new IllegalStateException( "Service is not yet initialized" );
+		}
+		return revisionInfoNumberReader;
+	}
+
+	@Override
+	public ModifiedEntityNamesReader getModifiedEntityNamesReader() {
+		if ( !initialized ) {
+			throw new IllegalStateException( "Service is not yet initialized" );
+		}
+		return modifiedEntityNamesReader;
+	}
+
+	@Override
+	public ClassLoaderService getClassLoaderService() {
+		if ( !initialized ) {
+			throw new IllegalStateException( "Service is not yet initialized" );
+		}
+		return classLoaderService;
+	}
+
+	@Override
+	public void stop() {
+		// anything to release?
+	}
+}
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversServiceInitiator.java b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversServiceInitiator.java
new file mode 100644
index 0000000000..ccd67ccda1
--- /dev/null
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/EnversServiceInitiator.java
@@ -0,0 +1,51 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2015, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.envers.boot.internal;
+
+import java.util.Map;
+
+import org.hibernate.boot.registry.StandardServiceInitiator;
+import org.hibernate.service.spi.ServiceRegistryImplementor;
+
+/**
+ * @author Steve Ebersole
+ */
+public class EnversServiceInitiator implements StandardServiceInitiator<EnversService> {
+	/**
+	 * Singleton access
+	 */
+	public static final EnversServiceInitiator INSTANCE = new EnversServiceInitiator();
+
+	@Override
+	public EnversService initiateService(
+			Map configurationValues,
+			ServiceRegistryImplementor registry) {
+		return new EnversServiceImpl();
+	}
+
+	@Override
+	public Class<EnversService> getServiceInitiated() {
+		return EnversService.class;
+	}
+}
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/TypeContributorImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/TypeContributorImpl.java
similarity index 86%
rename from hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/TypeContributorImpl.java
rename to hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/TypeContributorImpl.java
index c60751a7d1..786f1121aa 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/TypeContributorImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/boot/internal/TypeContributorImpl.java
@@ -1,44 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.envers.internal.entities;
+package org.hibernate.envers.boot.internal;
 
 import org.hibernate.boot.model.TypeContributions;
 import org.hibernate.boot.model.TypeContributor;
+import org.hibernate.envers.internal.entities.RevisionTypeType;
 import org.hibernate.service.ServiceRegistry;
 
 /**
  * Envers specific TypeContributor
  *
  * @author Brett Meyer
  */
 public class TypeContributorImpl implements TypeContributor {
 	@Override
 	public void contribute(TypeContributions typeContributions, ServiceRegistry serviceRegistry) {
+		final EnversService enversService = serviceRegistry.getService( EnversService.class );
+		if ( !enversService.isEnabled() ) {
+			return;
+		}
+
 		typeContributions.contributeType(
 				new RevisionTypeType(),
 				new String[] { RevisionTypeType.class.getName() }
 		);
 	}
 
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/AuditEntitiesConfiguration.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/AuditEntitiesConfiguration.java
index ae0a63010a..fe4338b9ef 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/AuditEntitiesConfiguration.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/AuditEntitiesConfiguration.java
@@ -1,180 +1,180 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.configuration.internal;
 
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Properties;
 
 import org.hibernate.envers.configuration.EnversSettings;
 import org.hibernate.envers.strategy.DefaultAuditStrategy;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 
 /**
  * Configuration of versions entities - names of fields, entities and tables created to store versioning information.
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Stephanie Pau at Markit Group Plc
  */
-public class AuditEntitiesConfiguration {
+public class  AuditEntitiesConfiguration {
 	private final String auditTablePrefix;
 	private final String auditTableSuffix;
 
 	private final String auditStrategyName;
 	private final String originalIdPropName;
 
 	private final String revisionFieldName;
 	private final String revisionNumberPath;
 	private final String revisionPropBasePath;
 
 	private final String revisionTypePropName;
 	private final String revisionTypePropType;
 
 	private final String revisionInfoEntityName;
 
 	private final Map<String, String> customAuditTablesNames;
 
 	private final String revisionEndFieldName;
 
 	private final boolean revisionEndTimestampEnabled;
 	private final String revisionEndTimestampFieldName;
 
 	private final String embeddableSetOrdinalPropertyName;
 
 	public AuditEntitiesConfiguration(Properties properties, String revisionInfoEntityName) {
 		this.revisionInfoEntityName = revisionInfoEntityName;
 
 		auditTablePrefix = ConfigurationHelper.getString( EnversSettings.AUDIT_TABLE_PREFIX, properties, "" );
 		auditTableSuffix = ConfigurationHelper.getString( EnversSettings.AUDIT_TABLE_SUFFIX, properties, "_AUD" );
 
 		auditStrategyName = ConfigurationHelper.getString(
 				EnversSettings.AUDIT_STRATEGY, properties, DefaultAuditStrategy.class.getName()
 		);
 
 		originalIdPropName = "originalId";
 
 		revisionFieldName = ConfigurationHelper.getString( EnversSettings.REVISION_FIELD_NAME, properties, "REV" );
 
 		revisionTypePropName = ConfigurationHelper.getString(
 				EnversSettings.REVISION_TYPE_FIELD_NAME, properties, "REVTYPE"
 		);
 		revisionTypePropType = "byte";
 
 		revisionEndFieldName = ConfigurationHelper.getString(
 				EnversSettings.AUDIT_STRATEGY_VALIDITY_END_REV_FIELD_NAME, properties, "REVEND"
 		);
 
 		revisionEndTimestampEnabled = ConfigurationHelper.getBoolean(
 				EnversSettings.AUDIT_STRATEGY_VALIDITY_STORE_REVEND_TIMESTAMP, properties, false
 		);
 
 		if ( revisionEndTimestampEnabled ) {
 			revisionEndTimestampFieldName = ConfigurationHelper.getString(
 					EnversSettings.AUDIT_STRATEGY_VALIDITY_REVEND_TIMESTAMP_FIELD_NAME, properties, "REVEND_TSTMP"
 			);
 		}
 		else {
 			revisionEndTimestampFieldName = null;
 		}
 
 		customAuditTablesNames = new HashMap<String, String>();
 
 		revisionNumberPath = originalIdPropName + "." + revisionFieldName + ".id";
 		revisionPropBasePath = originalIdPropName + "." + revisionFieldName + ".";
 
 		embeddableSetOrdinalPropertyName = ConfigurationHelper.getString(
 				EnversSettings.EMBEDDABLE_SET_ORDINAL_FIELD_NAME, properties, "SETORDINAL"
 		);
 	}
 
 	public String getOriginalIdPropName() {
 		return originalIdPropName;
 	}
 
 	public String getRevisionFieldName() {
 		return revisionFieldName;
 	}
 
 	public boolean isRevisionEndTimestampEnabled() {
 		return revisionEndTimestampEnabled;
 	}
 
 	public String getRevisionEndTimestampFieldName() {
 		return revisionEndTimestampFieldName;
 	}
 
 	public String getRevisionNumberPath() {
 		return revisionNumberPath;
 	}
 
 	/**
 	 * @param propertyName Property of the revision entity.
 	 *
 	 * @return A path to the given property of the revision entity associated with an audit entity.
 	 */
 	public String getRevisionPropPath(String propertyName) {
 		return revisionPropBasePath + propertyName;
 	}
 
 	public String getRevisionTypePropName() {
 		return revisionTypePropName;
 	}
 
 	public String getRevisionTypePropType() {
 		return revisionTypePropType;
 	}
 
 	public String getRevisionInfoEntityName() {
 		return revisionInfoEntityName;
 	}
 
 	public void addCustomAuditTableName(String entityName, String tableName) {
 		customAuditTablesNames.put( entityName, tableName );
 	}
 
 	public String getAuditEntityName(String entityName) {
 		return auditTablePrefix + entityName + auditTableSuffix;
 	}
 
 	public String getAuditTableName(String entityName, String tableName) {
 		final String customHistoryTableName = customAuditTablesNames.get( entityName );
 		if ( customHistoryTableName == null ) {
 			return auditTablePrefix + tableName + auditTableSuffix;
 		}
 
 		return customHistoryTableName;
 	}
 
 	public String getAuditStrategyName() {
 		return auditStrategyName;
 	}
 
 	public String getRevisionEndFieldName() {
 		return revisionEndFieldName;
 	}
 
 	public String getEmbeddableSetOrdinalPropertyName() {
 		return embeddableSetOrdinalPropertyName;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/EntitiesConfigurator.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/EntitiesConfigurator.java
index 2884f40a1b..7f56c19a4d 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/EntitiesConfigurator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/EntitiesConfigurator.java
@@ -1,174 +1,154 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.configuration.internal;
 
-import java.io.ByteArrayOutputStream;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.Writer;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 
 import org.hibernate.MappingException;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
-import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.cfg.Configuration;
+import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.envers.configuration.internal.metadata.AuditEntityNameRegister;
 import org.hibernate.envers.configuration.internal.metadata.AuditMetadataGenerator;
 import org.hibernate.envers.configuration.internal.metadata.EntityXmlMappingData;
 import org.hibernate.envers.configuration.internal.metadata.reader.AnnotationsMetadataReader;
 import org.hibernate.envers.configuration.internal.metadata.reader.ClassAuditingData;
 import org.hibernate.envers.internal.entities.EntitiesConfigurations;
 import org.hibernate.envers.internal.tools.StringTools;
 import org.hibernate.envers.internal.tools.graph.GraphTopologicalSort;
 import org.hibernate.envers.strategy.AuditStrategy;
 import org.hibernate.mapping.PersistentClass;
+import org.hibernate.service.ServiceRegistry;
 
 import org.dom4j.Document;
 import org.dom4j.DocumentException;
 import org.dom4j.Element;
-import org.dom4j.io.DOMWriter;
-import org.dom4j.io.OutputFormat;
-import org.dom4j.io.XMLWriter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class EntitiesConfigurator {
 	public EntitiesConfigurations configure(
-			Configuration cfg, ReflectionManager reflectionManager,
-			GlobalConfiguration globalCfg, AuditEntitiesConfiguration verEntCfg,
-			AuditStrategy auditStrategy, ClassLoaderService classLoaderService,
-			Document revisionInfoXmlMapping, Element revisionInfoRelationMapping) {
+			MetadataImplementor metadata,
+			ServiceRegistry serviceRegistry,
+			ReflectionManager reflectionManager,
+			MappingCollector mappingCollector,
+			GlobalConfiguration globalConfiguration,
+			AuditEntitiesConfiguration auditEntitiesConfiguration,
+			AuditStrategy auditStrategy,
+			Document revisionInfoXmlMapping,
+			Element revisionInfoRelationMapping) {
 		// Creating a name register to capture all audit entity names created.
 		final AuditEntityNameRegister auditEntityNameRegister = new AuditEntityNameRegister();
-		final DOMWriter writer = new DOMWriter();
 
 		// Sorting the persistent class topologically - superclass always before subclass
-		final Iterator<PersistentClass> classes = GraphTopologicalSort.sort( new PersistentClassGraphDefiner( cfg ) )
+		final Iterator<PersistentClass> classes = GraphTopologicalSort.sort( new PersistentClassGraphDefiner( metadata ) )
 				.iterator();
 
 		final ClassesAuditingData classesAuditingData = new ClassesAuditingData();
 		final Map<PersistentClass, EntityXmlMappingData> xmlMappings = new HashMap<PersistentClass, EntityXmlMappingData>();
 
 		// Reading metadata from annotations
 		while ( classes.hasNext() ) {
 			final PersistentClass pc = classes.next();
 
 			// Collecting information from annotations on the persistent class pc
 			final AnnotationsMetadataReader annotationsMetadataReader =
-					new AnnotationsMetadataReader( globalCfg, reflectionManager, pc );
+					new AnnotationsMetadataReader( globalConfiguration, reflectionManager, pc );
 			final ClassAuditingData auditData = annotationsMetadataReader.getAuditData();
 
 			classesAuditingData.addClassAuditingData( pc, auditData );
 		}
 
 		// Now that all information is read we can update the calculated fields.
 		classesAuditingData.updateCalculatedFields();
 
 		final AuditMetadataGenerator auditMetaGen = new AuditMetadataGenerator(
-				cfg, globalCfg, verEntCfg, auditStrategy,
-				classLoaderService, revisionInfoRelationMapping, auditEntityNameRegister
+				metadata,
+				serviceRegistry,
+				globalConfiguration,
+				auditEntitiesConfiguration,
+				auditStrategy,
+				revisionInfoRelationMapping,
+				auditEntityNameRegister
 		);
 
 		// First pass
 		for ( Map.Entry<PersistentClass, ClassAuditingData> pcDatasEntry : classesAuditingData.getAllClassAuditedData() ) {
 			final PersistentClass pc = pcDatasEntry.getKey();
 			final ClassAuditingData auditData = pcDatasEntry.getValue();
 
 			final EntityXmlMappingData xmlMappingData = new EntityXmlMappingData();
 			if ( auditData.isAudited() ) {
 				if ( !StringTools.isEmpty( auditData.getAuditTable().value() ) ) {
-					verEntCfg.addCustomAuditTableName( pc.getEntityName(), auditData.getAuditTable().value() );
+					auditEntitiesConfiguration.addCustomAuditTableName( pc.getEntityName(), auditData.getAuditTable().value() );
 				}
 
 				auditMetaGen.generateFirstPass( pc, auditData, xmlMappingData, true );
 			}
 			else {
 				auditMetaGen.generateFirstPass( pc, auditData, xmlMappingData, false );
 			}
 
 			xmlMappings.put( pc, xmlMappingData );
 		}
 
 		// Second pass
 		for ( Map.Entry<PersistentClass, ClassAuditingData> pcDatasEntry : classesAuditingData.getAllClassAuditedData() ) {
 			final EntityXmlMappingData xmlMappingData = xmlMappings.get( pcDatasEntry.getKey() );
 
 			if ( pcDatasEntry.getValue().isAudited() ) {
 				auditMetaGen.generateSecondPass( pcDatasEntry.getKey(), pcDatasEntry.getValue(), xmlMappingData );
 				try {
-					cfg.addDocument( writer.write( xmlMappingData.getMainXmlMapping() ) );
-					//writeDocument(xmlMappingData.getMainXmlMapping());
+					mappingCollector.addDocument( xmlMappingData.getMainXmlMapping() );
 
 					for ( Document additionalMapping : xmlMappingData.getAdditionalXmlMappings() ) {
-						cfg.addDocument( writer.write( additionalMapping ) );
-						//writeDocument(additionalMapping);
+						mappingCollector.addDocument( additionalMapping );
 					}
 				}
 				catch (DocumentException e) {
 					throw new MappingException( e );
 				}
 			}
 		}
 
 		// Only if there are any versioned classes
 		if ( auditMetaGen.getEntitiesConfigurations().size() > 0 ) {
 			try {
 				if ( revisionInfoXmlMapping != null ) {
-					//writeDocument(revisionInfoXmlMapping);
-					cfg.addDocument( writer.write( revisionInfoXmlMapping ) );
+					mappingCollector.addDocument( revisionInfoXmlMapping );
 				}
 			}
 			catch (DocumentException e) {
 				throw new MappingException( e );
 			}
 		}
 
 		return new EntitiesConfigurations(
 				auditMetaGen.getEntitiesConfigurations(),
 				auditMetaGen.getNotAuditedEntitiesConfigurations()
 		);
 	}
-
-	@SuppressWarnings({"UnusedDeclaration"})
-	private void writeDocument(Document e) {
-		final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-		final Writer w = new PrintWriter( baos );
-
-		try {
-			final XMLWriter xw = new XMLWriter( w, new OutputFormat( " ", true ) );
-			xw.write( e );
-			w.flush();
-		}
-		catch (IOException e1) {
-			e1.printStackTrace();
-		}
-
-		System.out.println( "-----------" );
-		System.out.println( baos.toString() );
-		System.out.println( "-----------" );
-	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/GlobalConfiguration.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/GlobalConfiguration.java
index 61516f9b71..5a00a8c018 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/GlobalConfiguration.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/GlobalConfiguration.java
@@ -1,208 +1,228 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.configuration.internal;
 
-import java.util.Properties;
+import java.util.Map;
 
 import org.hibernate.MappingException;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.envers.RevisionListener;
 import org.hibernate.envers.configuration.EnversSettings;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Nicolas Doroskevich
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public class GlobalConfiguration {
 	// Should a revision be generated when a not-owned relation field changes
 	private final boolean generateRevisionsForCollections;
 
 	// Should the optimistic locking property of an entity be considered unversioned
 	private final boolean doNotAuditOptimisticLockingField;
 
 	// Should entity data be stored when it is deleted
 	private final boolean storeDataAtDelete;
 
 	// The default name of the schema of audit tables.
 	private final String defaultSchemaName;
 
 	// The default name of the catalog of the audit tables.
 	private final String defaultCatalogName;
 
 	// Should Envers track (persist) entity names that have been changed during each revision.
 	private boolean trackEntitiesChangedInRevision;
 
 	// Revision listener class name.
 	private final Class<? extends RevisionListener> revisionListenerClass;
 
 	// Should Envers use modified property flags by default
 	private boolean globalWithModifiedFlag;
 
 	// Indicates that user defined global behavior for modified flags feature
 	private boolean hasGlobalSettingForWithModifiedFlag;
 
 	// Suffix to be used for modified flags columns
 	private String modifiedFlagSuffix;
 
 	// Use revision entity with native id generator
 	private final boolean useRevisionEntityWithNativeId;
 	
 	// While deleting revision entry, remove data of associated audited entities
 	private final boolean cascadeDeleteRevision;
 
 	// Support reused identifiers of previously deleted entities
 	private final boolean allowIdentifierReuse;
 
 	/*
 		 Which operator to use in correlated subqueries (when we want a property to be equal to the result of
 		 a correlated subquery, for example: e.p <operator> (select max(e2.p) where e2.p2 = e.p2 ...).
 		 Normally, this should be "=". However, HSQLDB has an issue related to that, so as a workaround,
 		 "in" is used. See {@link org.hibernate.envers.test.various.HsqlTest}.
 	*/
 	private final String correlatedSubqueryOperator;
 
-	public GlobalConfiguration(Properties properties, ClassLoaderService classLoaderService) {
+	public GlobalConfiguration(Map properties, ClassLoaderService classLoaderService) {
 		generateRevisionsForCollections = ConfigurationHelper.getBoolean(
-				EnversSettings.REVISION_ON_COLLECTION_CHANGE, properties, true
+				EnversSettings.REVISION_ON_COLLECTION_CHANGE,
+				properties,
+				true
 		);
 
 		doNotAuditOptimisticLockingField = ConfigurationHelper.getBoolean(
-				EnversSettings.DO_NOT_AUDIT_OPTIMISTIC_LOCKING_FIELD, properties, true
+				EnversSettings.DO_NOT_AUDIT_OPTIMISTIC_LOCKING_FIELD,
+				properties,
+				true
 		);
 
-		storeDataAtDelete = ConfigurationHelper.getBoolean( EnversSettings.STORE_DATA_AT_DELETE, properties, false );
+		storeDataAtDelete = ConfigurationHelper.getBoolean(
+				EnversSettings.STORE_DATA_AT_DELETE,
+				properties,
+				false
+		);
 
-		defaultSchemaName = properties.getProperty( EnversSettings.DEFAULT_SCHEMA, null );
-		defaultCatalogName = properties.getProperty( EnversSettings.DEFAULT_CATALOG, null );
+		defaultSchemaName = (String) properties.get( EnversSettings.DEFAULT_SCHEMA );
+		defaultCatalogName = (String) properties.get( EnversSettings.DEFAULT_CATALOG );
 
-		correlatedSubqueryOperator = HSQLDialect.class.getName()
-				.equals( properties.get( Environment.DIALECT ) ) ? "in" : "=";
+		correlatedSubqueryOperator = HSQLDialect.class.getName().equals( properties.get( Environment.DIALECT ) )
+				? "in"
+				: "=";
 
 		trackEntitiesChangedInRevision = ConfigurationHelper.getBoolean(
-				EnversSettings.TRACK_ENTITIES_CHANGED_IN_REVISION, properties, false
+				EnversSettings.TRACK_ENTITIES_CHANGED_IN_REVISION,
+				properties,
+				false
 		);
 		
 		cascadeDeleteRevision = ConfigurationHelper.getBoolean(
-				"org.hibernate.envers.cascade_delete_revision", properties, false );
+				"org.hibernate.envers.cascade_delete_revision",
+				properties,
+				false
+		);
 
 		useRevisionEntityWithNativeId = ConfigurationHelper.getBoolean(
-				EnversSettings.USE_REVISION_ENTITY_WITH_NATIVE_ID, properties, true
+				EnversSettings.USE_REVISION_ENTITY_WITH_NATIVE_ID,
+				properties,
+				true
 		);
 
 		hasGlobalSettingForWithModifiedFlag = properties.get( EnversSettings.GLOBAL_WITH_MODIFIED_FLAG ) != null;
 		globalWithModifiedFlag = ConfigurationHelper.getBoolean(
-				EnversSettings.GLOBAL_WITH_MODIFIED_FLAG, properties, false
+				EnversSettings.GLOBAL_WITH_MODIFIED_FLAG,
+				properties,
+				false
 		);
 		modifiedFlagSuffix = ConfigurationHelper.getString(
-				EnversSettings.MODIFIED_FLAG_SUFFIX, properties, "_MOD"
+				EnversSettings.MODIFIED_FLAG_SUFFIX,
+				properties,
+				"_MOD"
 		);
 
-		final String revisionListenerClassName = properties.getProperty( EnversSettings.REVISION_LISTENER, null );
+		final String revisionListenerClassName = (String) properties.get( EnversSettings.REVISION_LISTENER );
 		if ( revisionListenerClassName != null ) {
 			try {
 				revisionListenerClass = ReflectionTools.loadClass( revisionListenerClassName, classLoaderService );
 			}
 			catch (ClassLoadingException e) {
 				throw new MappingException(
 						"Revision listener class not found: " + revisionListenerClassName + ".",
 						e
 				);
 			}
 		}
 		else {
 			revisionListenerClass = null;
 		}
 
 		allowIdentifierReuse = ConfigurationHelper.getBoolean(
 				EnversSettings.ALLOW_IDENTIFIER_REUSE, properties, false
 		);
 	}
 
 	public boolean isGenerateRevisionsForCollections() {
 		return generateRevisionsForCollections;
 	}
 
 	public boolean isDoNotAuditOptimisticLockingField() {
 		return doNotAuditOptimisticLockingField;
 	}
 
 	public String getCorrelatedSubqueryOperator() {
 		return correlatedSubqueryOperator;
 	}
 
 	public boolean isStoreDataAtDelete() {
 		return storeDataAtDelete;
 	}
 
 	public String getDefaultSchemaName() {
 		return defaultSchemaName;
 	}
 
 	public String getDefaultCatalogName() {
 		return defaultCatalogName;
 	}
 
 	public boolean isTrackEntitiesChangedInRevision() {
 		return trackEntitiesChangedInRevision;
 	}
 
 	public void setTrackEntitiesChangedInRevision(boolean trackEntitiesChangedInRevision) {
 		this.trackEntitiesChangedInRevision = trackEntitiesChangedInRevision;
 	}
 
 	public Class<? extends RevisionListener> getRevisionListenerClass() {
 		return revisionListenerClass;
 	}
 
 	public boolean hasSettingForUsingModifiedFlag() {
 		return hasGlobalSettingForWithModifiedFlag;
 	}
 
 	public boolean isGlobalWithModifiedFlag() {
 		return globalWithModifiedFlag;
 	}
 
 	public String getModifiedFlagSuffix() {
 		return modifiedFlagSuffix;
 	}
 
 	public boolean isUseRevisionEntityWithNativeId() {
 		return useRevisionEntityWithNativeId;
 	}
 	
 	public boolean isCascadeDeleteRevision() {
 		return cascadeDeleteRevision;
 	}
 
 	public boolean isAllowIdentifierReuse() {
 		return allowIdentifierReuse;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/MappingCollector.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/MappingCollector.java
new file mode 100644
index 0000000000..466ce9f7f5
--- /dev/null
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/MappingCollector.java
@@ -0,0 +1,38 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2015, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.envers.configuration.internal;
+
+import org.dom4j.Document;
+import org.dom4j.DocumentException;
+
+/**
+ * Used in building the AuditConfiguration to allow callbacks for generated audit entities.
+ *
+ * The idea here is to allow a Envers to "callback" with any
+ *
+ * @author Steve Ebersole
+ */
+public interface MappingCollector {
+	void addDocument(Document document) throws DocumentException;
+}
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/PersistentClassGraphDefiner.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/PersistentClassGraphDefiner.java
index c26a22474a..10621d187d 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/PersistentClassGraphDefiner.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/PersistentClassGraphDefiner.java
@@ -1,82 +1,82 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.configuration.internal;
 
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
-import org.hibernate.cfg.Configuration;
+import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.envers.internal.tools.Tools;
 import org.hibernate.envers.internal.tools.graph.GraphDefiner;
 import org.hibernate.mapping.PersistentClass;
 
 /**
  * Defines a graph, where the vertexes are all persistent classes, and there is an edge from
  * p.c. A to p.c. B iff A is a superclass of B.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public class PersistentClassGraphDefiner implements GraphDefiner<PersistentClass, String> {
-	private Configuration cfg;
+	private final MetadataImplementor metadata;
 
-	public PersistentClassGraphDefiner(Configuration cfg) {
-		this.cfg = cfg;
+	public PersistentClassGraphDefiner(MetadataImplementor metadata) {
+		this.metadata = metadata;
 	}
 
 	@Override
 	public String getRepresentation(PersistentClass pc) {
 		return pc.getEntityName();
 	}
 
 	@Override
 	public PersistentClass getValue(String entityName) {
-		return cfg.getClassMapping( entityName );
+		return metadata.getEntityBinding( entityName );
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private void addNeighbours(List<PersistentClass> neighbours, Iterator<PersistentClass> subclassIterator) {
 		while ( subclassIterator.hasNext() ) {
 			final PersistentClass subclass = subclassIterator.next();
 			neighbours.add( subclass );
 			addNeighbours( neighbours, (Iterator<PersistentClass>) subclass.getSubclassIterator() );
 		}
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public List<PersistentClass> getNeighbours(PersistentClass pc) {
 		final List<PersistentClass> neighbours = new ArrayList<PersistentClass>();
 
 		addNeighbours( neighbours, (Iterator<PersistentClass>) pc.getSubclassIterator() );
 
 		return neighbours;
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public List<PersistentClass> getValues() {
-		return Tools.iteratorToList( cfg.getClassMappings() );
+		return Tools.collectionToList( metadata.getEntityBindings() );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java
index 57831e7f3d..933db43187 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/RevisionInfoConfiguration.java
@@ -1,459 +1,456 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.configuration.internal;
 
 import java.util.Date;
-import java.util.Iterator;
 import java.util.Set;
 import javax.persistence.Column;
 
 import org.hibernate.MappingException;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.annotations.common.reflection.XClass;
 import org.hibernate.annotations.common.reflection.XProperty;
-import org.hibernate.cfg.Configuration;
+import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.envers.Audited;
 import org.hibernate.envers.DefaultRevisionEntity;
 import org.hibernate.envers.DefaultTrackingModifiedEntitiesRevisionEntity;
 import org.hibernate.envers.ModifiedEntityNames;
 import org.hibernate.envers.RevisionEntity;
 import org.hibernate.envers.RevisionListener;
 import org.hibernate.envers.RevisionNumber;
 import org.hibernate.envers.RevisionTimestamp;
 import org.hibernate.envers.configuration.internal.metadata.AuditTableData;
 import org.hibernate.envers.configuration.internal.metadata.MetadataTools;
 import org.hibernate.envers.enhanced.SequenceIdRevisionEntity;
 import org.hibernate.envers.enhanced.SequenceIdTrackingModifiedEntitiesRevisionEntity;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.revisioninfo.DefaultRevisionInfoGenerator;
 import org.hibernate.envers.internal.revisioninfo.DefaultTrackingModifiedEntitiesRevisionInfoGenerator;
 import org.hibernate.envers.internal.revisioninfo.ModifiedEntityNamesReader;
 import org.hibernate.envers.internal.revisioninfo.RevisionInfoGenerator;
 import org.hibernate.envers.internal.revisioninfo.RevisionInfoNumberReader;
 import org.hibernate.envers.internal.revisioninfo.RevisionInfoQueryCreator;
 import org.hibernate.envers.internal.tools.MutableBoolean;
 import org.hibernate.internal.util.xml.XMLHelper;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.type.LongType;
 import org.hibernate.type.Type;
 
 import org.dom4j.Document;
 import org.dom4j.Element;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class RevisionInfoConfiguration {
 	private String revisionInfoEntityName;
 	private PropertyData revisionInfoIdData;
 	private PropertyData revisionInfoTimestampData;
 	private PropertyData modifiedEntityNamesData;
 	private Type revisionInfoTimestampType;
 	private GlobalConfiguration globalCfg;
 
 	private String revisionPropType;
 	private String revisionPropSqlType;
 
 	public RevisionInfoConfiguration(GlobalConfiguration globalCfg) {
 		this.globalCfg = globalCfg;
 		if ( globalCfg.isUseRevisionEntityWithNativeId() ) {
 			revisionInfoEntityName = "org.hibernate.envers.DefaultRevisionEntity";
 		}
 		else {
 			revisionInfoEntityName = "org.hibernate.envers.enhanced.SequenceIdRevisionEntity";
 		}
 		revisionInfoIdData = new PropertyData( "id", "id", "field", null );
 		revisionInfoTimestampData = new PropertyData( "timestamp", "timestamp", "field", null );
 		modifiedEntityNamesData = new PropertyData( "modifiedEntityNames", "modifiedEntityNames", "field", null );
 		revisionInfoTimestampType = new LongType();
 
 		revisionPropType = "integer";
 	}
 
 	private Document generateDefaultRevisionInfoXmlMapping() {
 		final Document document = XMLHelper.getDocumentFactory().createDocument();
 
 		final Element classMapping = MetadataTools.createEntity(
 				document,
 				new AuditTableData( null, null, globalCfg.getDefaultSchemaName(), globalCfg.getDefaultCatalogName() ),
 				null,
 				null
 		);
 
 		classMapping.addAttribute( "name", revisionInfoEntityName );
 		classMapping.addAttribute( "table", "REVINFO" );
 
 		final Element idProperty = MetadataTools.addNativelyGeneratedId(
 				classMapping,
 				revisionInfoIdData.getName(),
 				revisionPropType,
 				globalCfg.isUseRevisionEntityWithNativeId()
 		);
 		MetadataTools.addColumn( idProperty, "REV", null, null, null, null, null, null, false );
 
 		final Element timestampProperty = MetadataTools.addProperty(
 				classMapping,
 				revisionInfoTimestampData.getName(),
 				revisionInfoTimestampType.getName(),
 				true,
 				false
 		);
 		MetadataTools.addColumn( timestampProperty, "REVTSTMP", null, null, null, null, null, null, false );
 
 		if ( globalCfg.isTrackEntitiesChangedInRevision() ) {
 			generateEntityNamesTrackingTableMapping(
 					classMapping,
 					"modifiedEntityNames",
 					globalCfg.getDefaultSchemaName(),
 					globalCfg.getDefaultCatalogName(),
 					"REVCHANGES",
 					"REV",
 					"ENTITYNAME",
 					"string"
 			);
 		}
 
 		return document;
 	}
 
 	/**
 	 * Generates mapping that represents a set of primitive types.<br />
 	 * <code>
 	 * &lt;set name="propertyName" table="joinTableName" schema="joinTableSchema" catalog="joinTableCatalog"
 	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cascade="persist, delete" lazy="false" fetch="join"&gt;<br />
 	 * &nbsp;&nbsp;&nbsp;&lt;key column="joinTablePrimaryKeyColumnName" /&gt;<br />
 	 * &nbsp;&nbsp;&nbsp;&lt;element type="joinTableValueColumnType"&gt;<br />
 	 * &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;column name="joinTableValueColumnName" /&gt;<br />
 	 * &nbsp;&nbsp;&nbsp;&lt;/element&gt;<br />
 	 * &lt;/set&gt;
 	 * </code>
 	 */
 	private void generateEntityNamesTrackingTableMapping(
 			Element classMapping,
 			String propertyName,
 			String joinTableSchema,
 			String joinTableCatalog,
 			String joinTableName,
 			String joinTablePrimaryKeyColumnName,
 			String joinTableValueColumnName,
 			String joinTableValueColumnType) {
 		final Element set = classMapping.addElement( "set" );
 		set.addAttribute( "name", propertyName );
 		set.addAttribute( "table", joinTableName );
 		set.addAttribute( "schema", joinTableSchema );
 		set.addAttribute( "catalog", joinTableCatalog );
 		set.addAttribute( "cascade", "persist, delete" );
 		set.addAttribute( "fetch", "join" );
 		set.addAttribute( "lazy", "false" );
 		final Element key = set.addElement( "key" );
 		key.addAttribute( "column", joinTablePrimaryKeyColumnName );
 		final Element element = set.addElement( "element" );
 		element.addAttribute( "type", joinTableValueColumnType );
 		final Element column = element.addElement( "column" );
 		column.addAttribute( "name", joinTableValueColumnName );
 	}
 
 	private Element generateRevisionInfoRelationMapping() {
 		final Document document = XMLHelper.getDocumentFactory().createDocument();
 		final Element revRelMapping = document.addElement( "key-many-to-one" );
 		revRelMapping.addAttribute( "type", revisionPropType );
 		revRelMapping.addAttribute( "class", revisionInfoEntityName );
 
 		if ( revisionPropSqlType != null ) {
 			// Putting a fake name to make Hibernate happy. It will be replaced later anyway.
 			MetadataTools.addColumn( revRelMapping, "*", null, null, null, revisionPropSqlType, null, null, false );
 		}
 
 		return revRelMapping;
 	}
 
 	private void searchForRevisionInfoCfgInProperties(
 			XClass clazz,
 			ReflectionManager reflectionManager,
 			MutableBoolean revisionNumberFound,
 			MutableBoolean revisionTimestampFound,
 			MutableBoolean modifiedEntityNamesFound,
 			String accessType) {
 		for ( XProperty property : clazz.getDeclaredProperties( accessType ) ) {
 			final RevisionNumber revisionNumber = property.getAnnotation( RevisionNumber.class );
 			final RevisionTimestamp revisionTimestamp = property.getAnnotation( RevisionTimestamp.class );
 			final ModifiedEntityNames modifiedEntityNames = property.getAnnotation( ModifiedEntityNames.class );
 
 			if ( revisionNumber != null ) {
 				if ( revisionNumberFound.isSet() ) {
 					throw new MappingException( "Only one property may be annotated with @RevisionNumber!" );
 				}
 
 				final XClass revisionNumberClass = property.getType();
 				if ( reflectionManager.equals( revisionNumberClass, Integer.class ) ||
 						reflectionManager.equals( revisionNumberClass, Integer.TYPE ) ) {
 					revisionInfoIdData = new PropertyData( property.getName(), property.getName(), accessType, null );
 					revisionNumberFound.set();
 				}
 				else if ( reflectionManager.equals( revisionNumberClass, Long.class ) ||
 						reflectionManager.equals( revisionNumberClass, Long.TYPE ) ) {
 					revisionInfoIdData = new PropertyData( property.getName(), property.getName(), accessType, null );
 					revisionNumberFound.set();
 
 					// The default is integer
 					revisionPropType = "long";
 				}
 				else {
 					throw new MappingException(
 							"The field annotated with @RevisionNumber must be of type " +
 									"int, Integer, long or Long"
 					);
 				}
 
 				// Getting the @Column definition of the revision number property, to later use that info to
 				// generate the same mapping for the relation from an audit table's revision number to the
 				// revision entity revision number.
 				final Column revisionPropColumn = property.getAnnotation( Column.class );
 				if ( revisionPropColumn != null ) {
 					revisionPropSqlType = revisionPropColumn.columnDefinition();
 				}
 			}
 
 			if ( revisionTimestamp != null ) {
 				if ( revisionTimestampFound.isSet() ) {
 					throw new MappingException( "Only one property may be annotated with @RevisionTimestamp!" );
 				}
 
 				final XClass revisionTimestampClass = property.getType();
 				if ( reflectionManager.equals( revisionTimestampClass, Long.class ) ||
 						reflectionManager.equals( revisionTimestampClass, Long.TYPE ) ||
 						reflectionManager.equals( revisionTimestampClass, Date.class ) ||
 						reflectionManager.equals( revisionTimestampClass, java.sql.Date.class ) ) {
 					revisionInfoTimestampData = new PropertyData(
 							property.getName(),
 							property.getName(),
 							accessType,
 							null
 					);
 					revisionTimestampFound.set();
 				}
 				else {
 					throw new MappingException(
 							"The field annotated with @RevisionTimestamp must be of type " +
 									"long, Long, java.util.Date or java.sql.Date"
 					);
 				}
 			}
 
 			if ( modifiedEntityNames != null ) {
 				if ( modifiedEntityNamesFound.isSet() ) {
 					throw new MappingException( "Only one property may be annotated with @ModifiedEntityNames!" );
 				}
 				final XClass modifiedEntityNamesClass = property.getType();
 				if ( reflectionManager.equals( modifiedEntityNamesClass, Set.class ) &&
 						reflectionManager.equals( property.getElementClass(), String.class ) ) {
 					modifiedEntityNamesData = new PropertyData(
 							property.getName(),
 							property.getName(),
 							accessType,
 							null
 					);
 					modifiedEntityNamesFound.set();
 				}
 				else {
 					throw new MappingException(
 							"The field annotated with @ModifiedEntityNames must be of Set<String> type."
 					);
 				}
 			}
 		}
 	}
 
 	private void searchForRevisionInfoCfg(
 			XClass clazz, ReflectionManager reflectionManager,
 			MutableBoolean revisionNumberFound, MutableBoolean revisionTimestampFound,
 			MutableBoolean modifiedEntityNamesFound) {
 		final XClass superclazz = clazz.getSuperclass();
 		if ( !"java.lang.Object".equals( superclazz.getName() ) ) {
 			searchForRevisionInfoCfg(
 					superclazz,
 					reflectionManager,
 					revisionNumberFound,
 					revisionTimestampFound,
 					modifiedEntityNamesFound
 			);
 		}
 
 		searchForRevisionInfoCfgInProperties(
 				clazz, reflectionManager, revisionNumberFound, revisionTimestampFound,
 				modifiedEntityNamesFound, "field"
 		);
 		searchForRevisionInfoCfgInProperties(
 				clazz, reflectionManager, revisionNumberFound, revisionTimestampFound,
 				modifiedEntityNamesFound, "property"
 		);
 	}
 
-	public RevisionInfoConfigurationResult configure(Configuration cfg, ReflectionManager reflectionManager) {
+	public RevisionInfoConfigurationResult configure(MetadataImplementor metadata, ReflectionManager reflectionManager) {
 		boolean revisionEntityFound = false;
 		RevisionInfoGenerator revisionInfoGenerator = null;
 		Class<?> revisionInfoClass = null;
 
-		final Iterator<PersistentClass> classes = cfg.getClassMappings();
-		while ( classes.hasNext() ) {
-			PersistentClass pc = classes.next();
+		for ( PersistentClass persistentClass : metadata.getEntityBindings() ) {
 			XClass clazz;
 			try {
-				clazz = reflectionManager.classForName( pc.getClassName(), this.getClass() );
+				clazz = reflectionManager.classForName( persistentClass.getClassName(), this.getClass() );
 			}
 			catch (ClassNotFoundException e) {
 				throw new MappingException( e );
 			}
 
 			final RevisionEntity revisionEntity = clazz.getAnnotation( RevisionEntity.class );
 			if ( revisionEntity != null ) {
 				if ( revisionEntityFound ) {
 					throw new MappingException( "Only one entity may be annotated with @RevisionEntity!" );
 				}
 
 				// Checking if custom revision entity isn't audited
 				if ( clazz.getAnnotation( Audited.class ) != null ) {
 					throw new MappingException( "An entity annotated with @RevisionEntity cannot be audited!" );
 				}
 
 				revisionEntityFound = true;
 
 				final MutableBoolean revisionNumberFound = new MutableBoolean();
 				final MutableBoolean revisionTimestampFound = new MutableBoolean();
 				final MutableBoolean modifiedEntityNamesFound = new MutableBoolean();
 
 				searchForRevisionInfoCfg(
 						clazz,
 						reflectionManager,
 						revisionNumberFound,
 						revisionTimestampFound,
 						modifiedEntityNamesFound
 				);
 
 				if ( !revisionNumberFound.isSet() ) {
 					throw new MappingException(
 							"An entity annotated with @RevisionEntity must have a field annotated " +
 									"with @RevisionNumber!"
 					);
 				}
 
 				if ( !revisionTimestampFound.isSet() ) {
 					throw new MappingException(
 							"An entity annotated with @RevisionEntity must have a field annotated " +
 									"with @RevisionTimestamp!"
 					);
 				}
 
-				revisionInfoEntityName = pc.getEntityName();
-				revisionInfoClass = pc.getMappedClass();
+				revisionInfoEntityName = persistentClass.getEntityName();
+				revisionInfoClass = persistentClass.getMappedClass();
 				final Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass( revisionEntity.value() );
-				revisionInfoTimestampType = pc.getProperty( revisionInfoTimestampData.getName() ).getType();
+				revisionInfoTimestampType = persistentClass.getProperty( revisionInfoTimestampData.getName() ).getType();
 				if ( globalCfg.isTrackEntitiesChangedInRevision()
 						|| (globalCfg.isUseRevisionEntityWithNativeId() && DefaultTrackingModifiedEntitiesRevisionEntity.class
 						.isAssignableFrom( revisionInfoClass ))
 						|| (!globalCfg.isUseRevisionEntityWithNativeId() && SequenceIdTrackingModifiedEntitiesRevisionEntity.class
 						.isAssignableFrom( revisionInfoClass ))
 						|| modifiedEntityNamesFound.isSet() ) {
 					// If tracking modified entities parameter is enabled, custom revision info entity is a subtype
 					// of DefaultTrackingModifiedEntitiesRevisionEntity class, or @ModifiedEntityNames annotation is used.
 					revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(
 							revisionInfoEntityName,
 							revisionInfoClass, revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(),
 							modifiedEntityNamesData
 					);
 					globalCfg.setTrackEntitiesChangedInRevision( true );
 				}
 				else {
 					revisionInfoGenerator = new DefaultRevisionInfoGenerator(
 							revisionInfoEntityName, revisionInfoClass,
 							revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()
 					);
 				}
 			}
 		}
 
 		// In case of a custom revision info generator, the mapping will be null.
 		Document revisionInfoXmlMapping = null;
 
 		final Class<? extends RevisionListener> revisionListenerClass = getRevisionListenerClass( RevisionListener.class );
 
 		if ( revisionInfoGenerator == null ) {
 			if ( globalCfg.isTrackEntitiesChangedInRevision() ) {
 				revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ?
 						DefaultTrackingModifiedEntitiesRevisionEntity.class
 						:
 						SequenceIdTrackingModifiedEntitiesRevisionEntity.class;
 				revisionInfoEntityName = revisionInfoClass.getName();
 				revisionInfoGenerator = new DefaultTrackingModifiedEntitiesRevisionInfoGenerator(
 						revisionInfoEntityName, revisionInfoClass,
 						revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate(), modifiedEntityNamesData
 				);
 			}
 			else {
 				revisionInfoClass = globalCfg.isUseRevisionEntityWithNativeId() ? DefaultRevisionEntity.class
 						: SequenceIdRevisionEntity.class;
 				revisionInfoGenerator = new DefaultRevisionInfoGenerator(
 						revisionInfoEntityName, revisionInfoClass,
 						revisionListenerClass, revisionInfoTimestampData, isTimestampAsDate()
 				);
 			}
 			revisionInfoXmlMapping = generateDefaultRevisionInfoXmlMapping();
 		}
 
 		return new RevisionInfoConfigurationResult(
 				revisionInfoGenerator, revisionInfoXmlMapping,
 				new RevisionInfoQueryCreator(
 						revisionInfoEntityName, revisionInfoIdData.getName(),
 						revisionInfoTimestampData.getName(), isTimestampAsDate()
 				),
 				generateRevisionInfoRelationMapping(),
 				new RevisionInfoNumberReader( revisionInfoClass, revisionInfoIdData ),
 				globalCfg.isTrackEntitiesChangedInRevision() ? new ModifiedEntityNamesReader(
 						revisionInfoClass,
 						modifiedEntityNamesData
 				)
 						: null,
 				revisionInfoEntityName, revisionInfoClass, revisionInfoTimestampData
 		);
 	}
 
 	private boolean isTimestampAsDate() {
 		final String typename = revisionInfoTimestampType.getName();
 		return "date".equals( typename ) || "time".equals( typename ) || "timestamp".equals( typename );
 	}
 
 	/**
 	 * @param defaultListener Revision listener that shall be applied if {@code org.hibernate.envers.revision_listener}
 	 * parameter has not been set.
 	 *
 	 * @return Revision listener.
 	 */
 	private Class<? extends RevisionListener> getRevisionListenerClass(Class<? extends RevisionListener> defaultListener) {
 		if ( globalCfg.getRevisionListenerClass() != null ) {
 			return globalCfg.getRevisionListenerClass();
 		}
 		return defaultListener;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/AuditMetadataGenerator.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/AuditMetadataGenerator.java
index f24f214390..1e561a0c7a 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/AuditMetadataGenerator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/AuditMetadataGenerator.java
@@ -1,781 +1,796 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.configuration.internal.metadata;
 
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.Map;
 
 import org.hibernate.MappingException;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.cfg.Configuration;
+import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.envers.RelationTargetAuditMode;
 import org.hibernate.envers.configuration.internal.AuditEntitiesConfiguration;
 import org.hibernate.envers.configuration.internal.GlobalConfiguration;
 import org.hibernate.envers.configuration.internal.metadata.reader.ClassAuditingData;
 import org.hibernate.envers.configuration.internal.metadata.reader.PropertyAuditingData;
 import org.hibernate.envers.internal.EnversMessageLogger;
 import org.hibernate.envers.internal.entities.EntityConfiguration;
 import org.hibernate.envers.internal.entities.IdMappingData;
 import org.hibernate.envers.internal.entities.mapper.CompositeMapperBuilder;
 import org.hibernate.envers.internal.entities.mapper.ExtendedPropertyMapper;
 import org.hibernate.envers.internal.entities.mapper.MultiPropertyMapper;
 import org.hibernate.envers.internal.entities.mapper.SubclassPropertyMapper;
 import org.hibernate.envers.internal.tools.StringTools;
 import org.hibernate.envers.internal.tools.Triple;
 import org.hibernate.envers.strategy.AuditStrategy;
 import org.hibernate.envers.strategy.ValidityAuditStrategy;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.Join;
 import org.hibernate.mapping.OneToOne;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Table;
 import org.hibernate.mapping.Value;
+import org.hibernate.service.ServiceRegistry;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.ComponentType;
 import org.hibernate.type.ManyToOneType;
 import org.hibernate.type.OneToOneType;
 import org.hibernate.type.TimestampType;
 import org.hibernate.type.Type;
 
 import org.jboss.logging.Logger;
 
 import org.dom4j.Element;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Sebastian Komander
  * @author Tomasz Bech
  * @author Stephanie Pau at Markit Group Plc
  * @author Hern&aacute;n Chanfreau
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public final class AuditMetadataGenerator {
 	private static final EnversMessageLogger LOG = Logger.getMessageLogger(
 			EnversMessageLogger.class,
 			AuditMetadataGenerator.class.getName()
 	);
 
-	private final Configuration cfg;
+	private final MetadataImplementor metadata;
+	private final ServiceRegistry serviceRegistry;
 	private final GlobalConfiguration globalCfg;
 	private final AuditEntitiesConfiguration verEntCfg;
 	private final AuditStrategy auditStrategy;
-	private final ClassLoaderService classLoaderService;
 	private final Element revisionInfoRelationMapping;
 
+	private final ClassLoaderService classLoaderService;
+
 	/*
 	 * Generators for different kinds of property values/types.
 	 */
 	private final BasicMetadataGenerator basicMetadataGenerator;
 	private final ComponentMetadataGenerator componentMetadataGenerator;
 	private final IdMetadataGenerator idMetadataGenerator;
 	private final ToOneRelationMetadataGenerator toOneRelationMetadataGenerator;
 
 	/*
 	 * Here information about already generated mappings will be accumulated.
 	 */
 	private final Map<String, EntityConfiguration> entitiesConfigurations;
 	private final Map<String, EntityConfiguration> notAuditedEntitiesConfigurations;
 
 	private final AuditEntityNameRegister auditEntityNameRegister;
 
 	// Map entity name -> (join descriptor -> element describing the "versioned" join)
 	private final Map<String, Map<Join, Element>> entitiesJoins;
 
 	public AuditMetadataGenerator(
-			Configuration cfg, GlobalConfiguration globalCfg,
+			MetadataImplementor metadata,
+			ServiceRegistry serviceRegistry,
+			GlobalConfiguration globalCfg,
 			AuditEntitiesConfiguration verEntCfg,
-			AuditStrategy auditStrategy, ClassLoaderService classLoaderService,
+			AuditStrategy auditStrategy,
 			Element revisionInfoRelationMapping,
 			AuditEntityNameRegister auditEntityNameRegister) {
-		this.cfg = cfg;
+		this.metadata = metadata;
+		this.serviceRegistry = serviceRegistry;
 		this.globalCfg = globalCfg;
 		this.verEntCfg = verEntCfg;
 		this.auditStrategy = auditStrategy;
-		this.classLoaderService = classLoaderService;
 		this.revisionInfoRelationMapping = revisionInfoRelationMapping;
 
 		this.basicMetadataGenerator = new BasicMetadataGenerator();
 		this.componentMetadataGenerator = new ComponentMetadataGenerator( this );
 		this.idMetadataGenerator = new IdMetadataGenerator( this );
 		this.toOneRelationMetadataGenerator = new ToOneRelationMetadataGenerator( this );
 
 		this.auditEntityNameRegister = auditEntityNameRegister;
 
 		entitiesConfigurations = new HashMap<String, EntityConfiguration>();
 		notAuditedEntitiesConfigurations = new HashMap<String, EntityConfiguration>();
 		entitiesJoins = new HashMap<String, Map<Join, Element>>();
+
+		classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
+	}
+
+	public MetadataImplementor getMetadata() {
+		return metadata;
+	}
+
+	public ServiceRegistry getServiceRegistry() {
+		return serviceRegistry;
+	}
+
+	public ClassLoaderService getClassLoaderService() {
+		return classLoaderService;
 	}
 
 	/**
 	 * Clones the revision info relation mapping, so that it can be added to other mappings. Also, the name of
 	 * the property and the column are set properly.
 	 *
 	 * @return A revision info mapping, which can be added to other mappings (has no parent).
 	 */
 	private Element cloneAndSetupRevisionInfoRelationMapping() {
 		final Element revMapping = (Element) revisionInfoRelationMapping.clone();
 		revMapping.addAttribute( "name", verEntCfg.getRevisionFieldName() );
 		if ( globalCfg.isCascadeDeleteRevision() ) {
 			revMapping.addAttribute( "on-delete", "cascade" );
 	    }
 
 		MetadataTools.addOrModifyColumn( revMapping, verEntCfg.getRevisionFieldName() );
 
 		return revMapping;
 	}
 
 	void addRevisionInfoRelation(Element anyMapping) {
 		anyMapping.add( cloneAndSetupRevisionInfoRelationMapping() );
 	}
 
 	void addRevisionType(Element anyMapping, Element anyMappingEnd) {
+		addRevisionType( anyMapping, anyMappingEnd, false );
+	}
+
+	void addRevisionType(Element anyMapping, Element anyMappingEnd, boolean isKey) {
 		final Element revTypeProperty = MetadataTools.addProperty(
 				anyMapping,
 				verEntCfg.getRevisionTypePropName(),
 				verEntCfg.getRevisionTypePropType(),
 				true,
-				false
+				isKey
 		);
 		revTypeProperty.addAttribute( "type", "org.hibernate.envers.internal.entities.RevisionTypeType" );
 
 		// Adding the end revision, if appropriate
 		addEndRevision( anyMappingEnd );
 	}
 
 	private void addEndRevision(Element anyMapping) {
 		// Add the end-revision field, if the appropriate strategy is used.
 		if ( auditStrategy instanceof ValidityAuditStrategy ) {
 			final Element endRevMapping = (Element) revisionInfoRelationMapping.clone();
 			endRevMapping.setName( "many-to-one" );
 			endRevMapping.addAttribute( "name", verEntCfg.getRevisionEndFieldName() );
 			MetadataTools.addOrModifyColumn( endRevMapping, verEntCfg.getRevisionEndFieldName() );
 
 			anyMapping.add( endRevMapping );
 
 			if ( verEntCfg.isRevisionEndTimestampEnabled() ) {
 				// add a column for the timestamp of the end revision
 				final String revisionInfoTimestampSqlType = TimestampType.INSTANCE.getName();
 				final Element timestampProperty = MetadataTools.addProperty(
 						anyMapping,
 						verEntCfg.getRevisionEndTimestampFieldName(),
 						revisionInfoTimestampSqlType,
 						true,
 						true,
 						false
 				);
 				MetadataTools.addColumn(
 						timestampProperty,
 						verEntCfg.getRevisionEndTimestampFieldName(),
 						null,
 						null,
 						null,
 						null,
 						null,
 						null
 				);
 			}
 		}
 	}
 
 	private void addValueInFirstPass(
 			Element parent,
 			Value value,
 			CompositeMapperBuilder currentMapper,
 			String entityName,
 			EntityXmlMappingData xmlMappingData,
 			PropertyAuditingData propertyAuditingData,
 			boolean insertable,
 			boolean processModifiedFlag) {
 		final Type type = value.getType();
 		final boolean isBasic = basicMetadataGenerator.addBasic(
 				parent,
 				propertyAuditingData,
 				value,
 				currentMapper,
 				insertable,
 				false
 		);
 
 		if ( isBasic ) {
 			// The property was mapped by the basic generator.
 		}
 		else if ( type instanceof ComponentType ) {
 			componentMetadataGenerator.addComponent(
 					parent, propertyAuditingData, value, currentMapper,
 					entityName, xmlMappingData, true
 			);
 		}
 		else {
 			if ( !processedInSecondPass( type ) ) {
 				// If we got here in the first pass, it means the basic mapper didn't map it, and none of the
 				// above branches either.
 				throwUnsupportedTypeException( type, entityName, propertyAuditingData.getName() );
 			}
 			return;
 		}
 		addModifiedFlagIfNeeded( parent, propertyAuditingData, processModifiedFlag );
 	}
 
 	private boolean processedInSecondPass(Type type) {
 		return type instanceof ComponentType || type instanceof ManyToOneType ||
 				type instanceof OneToOneType || type instanceof CollectionType;
 	}
 
 	private void addValueInSecondPass(
 			Element parent,
 			Value value,
 			CompositeMapperBuilder currentMapper,
 			String entityName,
 			EntityXmlMappingData xmlMappingData,
 			PropertyAuditingData propertyAuditingData,
 			boolean insertable,
 			boolean processModifiedFlag) {
 		final Type type = value.getType();
 
 		if ( type instanceof ComponentType ) {
 			componentMetadataGenerator.addComponent(
 					parent,
 					propertyAuditingData,
 					value,
 					currentMapper,
 					entityName,
 					xmlMappingData,
 					false
 			);
 			// mod flag field has been already generated in first pass
 			return;
 		}
 		else if ( type instanceof ManyToOneType ) {
 			toOneRelationMetadataGenerator.addToOne(
 					parent,
 					propertyAuditingData,
 					value,
 					currentMapper,
 					entityName,
 					insertable
 			);
 		}
 		else if ( type instanceof OneToOneType ) {
 			final OneToOne oneToOne = (OneToOne) value;
 			if ( oneToOne.getReferencedPropertyName() != null ) {
 				toOneRelationMetadataGenerator.addOneToOneNotOwning(
 						propertyAuditingData,
 						value,
 						currentMapper,
 						entityName
 				);
 			}
 			else {
 				// @OneToOne relation marked with @PrimaryKeyJoinColumn
 				toOneRelationMetadataGenerator.addOneToOnePrimaryKeyJoinColumn(
 						propertyAuditingData,
 						value,
 						currentMapper,
 						entityName,
 						insertable
 				);
 			}
 		}
 		else if ( type instanceof CollectionType ) {
 			final CollectionMetadataGenerator collectionMetadataGenerator = new CollectionMetadataGenerator(
 					this,
 					(Collection) value,
 					currentMapper,
 					entityName,
 					xmlMappingData,
 					propertyAuditingData
 			);
 			collectionMetadataGenerator.addCollection();
 		}
 		else {
 			return;
 		}
 		addModifiedFlagIfNeeded( parent, propertyAuditingData, processModifiedFlag );
 	}
 
 	private void addModifiedFlagIfNeeded(
 			Element parent,
 			PropertyAuditingData propertyAuditingData,
 			boolean processModifiedFlag) {
 		if ( processModifiedFlag && propertyAuditingData.isUsingModifiedFlag() ) {
 			MetadataTools.addModifiedFlagProperty(
 					parent,
 					propertyAuditingData.getName(),
 					globalCfg.getModifiedFlagSuffix(),
 					propertyAuditingData.getModifiedFlagName()
 			);
 		}
 	}
 
 	void addValue(
 			Element parent, Value value, CompositeMapperBuilder currentMapper, String entityName,
 			EntityXmlMappingData xmlMappingData, PropertyAuditingData propertyAuditingData,
 			boolean insertable, boolean firstPass, boolean processModifiedFlag) {
 		if ( firstPass ) {
 			addValueInFirstPass(
 					parent, value, currentMapper, entityName,
 					xmlMappingData, propertyAuditingData, insertable, processModifiedFlag
 			);
 		}
 		else {
 			addValueInSecondPass(
 					parent, value, currentMapper, entityName,
 					xmlMappingData, propertyAuditingData, insertable, processModifiedFlag
 			);
 		}
 	}
 
 	private void addProperties(
 			Element parent,
 			Iterator<Property> properties,
 			CompositeMapperBuilder currentMapper,
 			ClassAuditingData auditingData,
 			String entityName,
 			EntityXmlMappingData xmlMappingData,
 			boolean firstPass) {
 		while ( properties.hasNext() ) {
 			final Property property = properties.next();
 			final String propertyName = property.getName();
 			final PropertyAuditingData propertyAuditingData = auditingData.getPropertyAuditingData( propertyName );
 			if ( propertyAuditingData != null ) {
 				addValue(
 						parent,
 						property.getValue(),
 						currentMapper,
 						entityName,
 						xmlMappingData,
 						propertyAuditingData,
 						property.isInsertable(),
 						firstPass,
 						true
 				);
 			}
 		}
 	}
 
 	private boolean checkPropertiesAudited(Iterator<Property> properties, ClassAuditingData auditingData) {
 		while ( properties.hasNext() ) {
 			final Property property = properties.next();
 			final String propertyName = property.getName();
 			final PropertyAuditingData propertyAuditingData = auditingData.getPropertyAuditingData( propertyName );
 			if ( propertyAuditingData == null ) {
 				return false;
 			}
 		}
 
 		return true;
 	}
 
 	protected String getSchema(String schemaFromAnnotation, Table table) {
 		// Get the schema from the annotation ...
 		String schema = schemaFromAnnotation;
 		// ... if empty, try using the default ...
 		if ( StringTools.isEmpty( schema ) ) {
 			schema = globalCfg.getDefaultSchemaName();
 
 			// ... if still empty, use the same as the normal table.
 			if ( StringTools.isEmpty( schema ) ) {
 				schema = table.getSchema();
 			}
 		}
 
 		return schema;
 	}
 
 	protected String getCatalog(String catalogFromAnnotation, Table table) {
 		// Get the catalog from the annotation ...
 		String catalog = catalogFromAnnotation;
 		// ... if empty, try using the default ...
 		if ( StringTools.isEmpty( catalog ) ) {
 			catalog = globalCfg.getDefaultCatalogName();
 
 			// ... if still empty, use the same as the normal table.
 			if ( StringTools.isEmpty( catalog ) ) {
 				catalog = table.getCatalog();
 			}
 		}
 
 		return catalog;
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private void createJoins(PersistentClass pc, Element parent, ClassAuditingData auditingData) {
 		final Iterator<Join> joins = pc.getJoinIterator();
 		final Map<Join, Element> joinElements = new HashMap<Join, Element>();
 		entitiesJoins.put( pc.getEntityName(), joinElements );
 
 		while ( joins.hasNext() ) {
 			Join join = joins.next();
 
 			// Checking if all of the join properties are audited
 			if ( !checkPropertiesAudited( join.getPropertyIterator(), auditingData ) ) {
 				continue;
 			}
 
 			// Determining the table name. If there is no entry in the dictionary, just constructing the table name
 			// as if it was an entity (by appending/prepending configured strings).
 			final String originalTableName = join.getTable().getName();
 			String auditTableName = auditingData.getSecondaryTableDictionary().get( originalTableName );
 			if ( auditTableName == null ) {
 				auditTableName = verEntCfg.getAuditEntityName( originalTableName );
 			}
 
 			final String schema = getSchema( auditingData.getAuditTable().schema(), join.getTable() );
 			final String catalog = getCatalog( auditingData.getAuditTable().catalog(), join.getTable() );
 
 			final Element joinElement = MetadataTools.createJoin( parent, auditTableName, schema, catalog );
 			joinElements.put( join, joinElement );
 
 			final Element joinKey = joinElement.addElement( "key" );
 			MetadataTools.addColumns( joinKey, join.getKey().getColumnIterator() );
 			MetadataTools.addColumn( joinKey, verEntCfg.getRevisionFieldName(), null, null, null, null, null, null );
 		}
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private void addJoins(
 			PersistentClass pc,
 			CompositeMapperBuilder currentMapper,
 			ClassAuditingData auditingData,
 			String entityName,
 			EntityXmlMappingData xmlMappingData,
 			boolean firstPass) {
 		final Iterator<Join> joins = pc.getJoinIterator();
 
 		while ( joins.hasNext() ) {
 			final Join join = joins.next();
 			final Element joinElement = entitiesJoins.get( entityName ).get( join );
 
 			if ( joinElement != null ) {
 				addProperties(
 						joinElement,
 						join.getPropertyIterator(),
 						currentMapper,
 						auditingData,
 						entityName,
 						xmlMappingData,
 						firstPass
 				);
 			}
 		}
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private Triple<Element, ExtendedPropertyMapper, String> generateMappingData(
 			PersistentClass pc, EntityXmlMappingData xmlMappingData, AuditTableData auditTableData,
 			IdMappingData idMapper) {
 		final Element classMapping = MetadataTools.createEntity(
 				xmlMappingData.getMainXmlMapping(),
 				auditTableData,
 				pc.getDiscriminatorValue(),
 				pc.isAbstract()
 		);
 		final ExtendedPropertyMapper propertyMapper = new MultiPropertyMapper();
 
 		// Checking if there is a discriminator column
 		if ( pc.getDiscriminator() != null ) {
 			final Element discriminatorElement = classMapping.addElement( "discriminator" );
 			// Database column or SQL formula allowed to distinguish entity types
 			MetadataTools.addColumnsOrFormulas( discriminatorElement, pc.getDiscriminator().getColumnIterator() );
 			discriminatorElement.addAttribute( "type", pc.getDiscriminator().getType().getName() );
 		}
 
 		// Adding the id mapping
 		classMapping.add( (Element) idMapper.getXmlMapping().clone() );
 
 		// Adding the "revision type" property
 		addRevisionType( classMapping, classMapping );
 
 		return Triple.make( classMapping, propertyMapper, null );
 	}
 
 	private Triple<Element, ExtendedPropertyMapper, String> generateInheritanceMappingData(
 			PersistentClass pc, EntityXmlMappingData xmlMappingData, AuditTableData auditTableData,
 			String inheritanceMappingType) {
 		final String extendsEntityName = verEntCfg.getAuditEntityName( pc.getSuperclass().getEntityName() );
 		final Element classMapping = MetadataTools.createSubclassEntity(
 				xmlMappingData.getMainXmlMapping(),
 				inheritanceMappingType,
 				auditTableData,
 				extendsEntityName,
 				pc.getDiscriminatorValue(),
 				pc.isAbstract()
 		);
 
 		// The id and revision type is already mapped in the parent
 
 		// Getting the property mapper of the parent - when mapping properties, they need to be included
 		final String parentEntityName = pc.getSuperclass().getEntityName();
 
 		final EntityConfiguration parentConfiguration = entitiesConfigurations.get( parentEntityName );
 		if ( parentConfiguration == null ) {
 			throw new MappingException(
 					"Entity '" + pc.getEntityName() + "' is audited, but its superclass: '" +
 							parentEntityName + "' is not."
 			);
 		}
 
 		final ExtendedPropertyMapper parentPropertyMapper = parentConfiguration.getPropertyMapper();
 		final ExtendedPropertyMapper propertyMapper = new SubclassPropertyMapper(
 				new MultiPropertyMapper(),
 				parentPropertyMapper
 		);
 
 		return Triple.make( classMapping, propertyMapper, parentEntityName );
 	}
 
 	@SuppressWarnings({"unchecked"})
 	public void generateFirstPass(
 			PersistentClass pc,
 			ClassAuditingData auditingData,
 			EntityXmlMappingData xmlMappingData,
 			boolean isAudited) {
 		final String schema = getSchema( auditingData.getAuditTable().schema(), pc.getTable() );
 		final String catalog = getCatalog( auditingData.getAuditTable().catalog(), pc.getTable() );
 
 		if ( !isAudited ) {
 			final String entityName = pc.getEntityName();
 			final IdMappingData idMapper = idMetadataGenerator.addId( pc, false );
 
 			if ( idMapper == null ) {
 				// Unsupported id mapping, e.g. key-many-to-one. If the entity is used in auditing, an exception
 				// will be thrown later on.
 				LOG.debugf(
 						"Unable to create auditing id mapping for entity %s, because of an unsupported Hibernate id mapping (e.g. key-many-to-one)",
 						entityName
 				);
 				return;
 			}
 
 			final ExtendedPropertyMapper propertyMapper = null;
 			final String parentEntityName = null;
 			final EntityConfiguration entityCfg = new EntityConfiguration(
 					entityName,
 					pc.getClassName(),
 					idMapper,
 					propertyMapper,
 					parentEntityName
 			);
 			notAuditedEntitiesConfigurations.put( entityName, entityCfg );
 			return;
 		}
 
 		final String entityName = pc.getEntityName();
 		LOG.debugf( "Generating first-pass auditing mapping for entity %s", entityName );
 
 		final String auditEntityName = verEntCfg.getAuditEntityName( entityName );
 		final String auditTableName = verEntCfg.getAuditTableName( entityName, pc.getTable().getName() );
 
 		// Registering the audit entity name, now that it is known
 		auditEntityNameRegister.register( auditEntityName );
 
 		final AuditTableData auditTableData = new AuditTableData( auditEntityName, auditTableName, schema, catalog );
 
 		// Generating a mapping for the id
 		final IdMappingData idMapper = idMetadataGenerator.addId( pc, true );
 
 		final InheritanceType inheritanceType = InheritanceType.get( pc );
 
 		// These properties will be read from the mapping data
 		final Element classMapping;
 		final ExtendedPropertyMapper propertyMapper;
 		final String parentEntityName;
 
 		final Triple<Element, ExtendedPropertyMapper, String> mappingData;
 
 		// Reading the mapping data depending on inheritance type (if any)
 		switch ( inheritanceType ) {
 			case NONE:
 				mappingData = generateMappingData( pc, xmlMappingData, auditTableData, idMapper );
 				break;
 
 			case SINGLE:
 				mappingData = generateInheritanceMappingData( pc, xmlMappingData, auditTableData, "subclass" );
 				break;
 
 			case JOINED:
 				mappingData = generateInheritanceMappingData( pc, xmlMappingData, auditTableData, "joined-subclass" );
 
 				// Adding the "key" element with all id columns...
 				final Element keyMapping = mappingData.getFirst().addElement( "key" );
 				MetadataTools.addColumns( keyMapping, pc.getTable().getPrimaryKey().columnIterator() );
 
 				// ... and the revision number column, read from the revision info relation mapping.
 				keyMapping.add( (Element) cloneAndSetupRevisionInfoRelationMapping().element( "column" ).clone() );
 				break;
 
 			case TABLE_PER_CLASS:
 				mappingData = generateInheritanceMappingData( pc, xmlMappingData, auditTableData, "union-subclass" );
 				break;
 
 			default:
 				throw new AssertionError( "Impossible enum value." );
 		}
 
 		classMapping = mappingData.getFirst();
 		propertyMapper = mappingData.getSecond();
 		parentEntityName = mappingData.getThird();
 
 		xmlMappingData.setClassMapping( classMapping );
 
 		// Mapping unjoined properties
 		addProperties(
 				classMapping, pc.getUnjoinedPropertyIterator(), propertyMapper,
 				auditingData, pc.getEntityName(), xmlMappingData,
 				true
 		);
 
 		// Creating and mapping joins (first pass)
 		createJoins( pc, classMapping, auditingData );
 		addJoins( pc, propertyMapper, auditingData, pc.getEntityName(), xmlMappingData, true );
 
 		// Storing the generated configuration
 		final EntityConfiguration entityCfg = new EntityConfiguration(
 				auditEntityName,
 				pc.getClassName(),
 				idMapper,
 				propertyMapper,
 				parentEntityName
 		);
 		entitiesConfigurations.put( pc.getEntityName(), entityCfg );
 	}
 
 	@SuppressWarnings({"unchecked"})
 	public void generateSecondPass(
 			PersistentClass pc,
 			ClassAuditingData auditingData,
 			EntityXmlMappingData xmlMappingData) {
 		final String entityName = pc.getEntityName();
 		LOG.debugf( "Generating second-pass auditing mapping for entity %s", entityName );
 
 		final CompositeMapperBuilder propertyMapper = entitiesConfigurations.get( entityName ).getPropertyMapper();
 
 		// Mapping unjoined properties
 		final Element parent = xmlMappingData.getClassMapping();
 
 		addProperties(
 				parent,
 				pc.getUnjoinedPropertyIterator(),
 				propertyMapper,
 				auditingData,
 				entityName,
 				xmlMappingData,
 				false
 		);
 
 		// Mapping joins (second pass)
 		addJoins( pc, propertyMapper, auditingData, entityName, xmlMappingData, false );
 	}
 
 	public Map<String, EntityConfiguration> getEntitiesConfigurations() {
 		return entitiesConfigurations;
 	}
 
 	// Getters for generators and configuration
 
 	BasicMetadataGenerator getBasicMetadataGenerator() {
 		return basicMetadataGenerator;
 	}
 
-	Configuration getCfg() {
-		return cfg;
-	}
-
 	GlobalConfiguration getGlobalCfg() {
 		return globalCfg;
 	}
 
 	AuditEntitiesConfiguration getVerEntCfg() {
 		return verEntCfg;
 	}
 
 	AuditStrategy getAuditStrategy() {
 		return auditStrategy;
 	}
 
-	ClassLoaderService getClassLoaderService() {
-		return classLoaderService;
-	}
-
 	AuditEntityNameRegister getAuditEntityNameRegister() {
 		return auditEntityNameRegister;
 	}
 
 	void throwUnsupportedTypeException(Type type, String entityName, String propertyName) {
 		final String message = "Type not supported for auditing: " + type.getClass().getName() +
 				", on entity " + entityName + ", property '" + propertyName + "'.";
 
 		throw new MappingException( message );
 	}
 
 	/**
 	 * Reads the id mapping data of a referenced entity.
 	 *
 	 * @param entityName Name of the entity which is the source of the relation.
 	 * @param referencedEntityName Name of the entity which is the target of the relation.
 	 * @param propertyAuditingData Auditing data of the property that is the source of the relation.
 	 * @param allowNotAuditedTarget Are not-audited target entities allowed.
 	 *
 	 * @return The id mapping data of the related entity.
 	 *
 	 * @throws MappingException If a relation from an audited to a non-audited entity is detected, which is not
 	 * mapped using {@link RelationTargetAuditMode#NOT_AUDITED}.
 	 */
 	IdMappingData getReferencedIdMappingData(
 			String entityName, String referencedEntityName,
 			PropertyAuditingData propertyAuditingData,
 			boolean allowNotAuditedTarget) {
 		EntityConfiguration configuration = getEntitiesConfigurations().get( referencedEntityName );
 		if ( configuration == null ) {
 			final RelationTargetAuditMode relationTargetAuditMode = propertyAuditingData.getRelationTargetAuditMode();
 			configuration = getNotAuditedEntitiesConfigurations().get( referencedEntityName );
 
 			if ( configuration == null || !allowNotAuditedTarget || !RelationTargetAuditMode.NOT_AUDITED.equals(
 					relationTargetAuditMode
 			) ) {
 				throw new MappingException(
 						"An audited relation from " + entityName + "."
 								+ propertyAuditingData.getName() + " to a not audited entity " + referencedEntityName + "!"
 								+ (allowNotAuditedTarget ?
 								" Such mapping is possible, but has to be explicitly defined using @Audited(targetAuditMode = NOT_AUDITED)." :
 								"")
 				);
 			}
 		}
 
 		return configuration.getIdMappingData();
 	}
 
 	/**
 	 * Get the notAuditedEntitiesConfigurations property.
 	 *
 	 * @return the notAuditedEntitiesConfigurations property value
 	 */
 	public Map<String, EntityConfiguration> getNotAuditedEntitiesConfigurations() {
 		return notAuditedEntitiesConfigurations;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/BasicMetadataGenerator.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/BasicMetadataGenerator.java
index 3e6f69e776..8ccf74da73 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/BasicMetadataGenerator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/BasicMetadataGenerator.java
@@ -1,159 +1,160 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.configuration.internal.metadata;
 
 import java.util.Properties;
 
 import org.hibernate.envers.configuration.internal.metadata.reader.PropertyAuditingData;
 import org.hibernate.envers.internal.entities.mapper.SimpleMapperBuilder;
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.mapping.Value;
 import org.hibernate.type.BasicType;
 import org.hibernate.type.CustomType;
 import org.hibernate.type.EnumType;
 import org.hibernate.type.SerializableToBlobType;
 import org.hibernate.type.Type;
 import org.hibernate.usertype.DynamicParameterizedType;
 
 import org.dom4j.Element;
 
 /**
  * Generates metadata for basic properties: immutable types (including enums).
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public final class BasicMetadataGenerator {
+
 	@SuppressWarnings({"unchecked"})
 	boolean addBasic(
 			Element parent, PropertyAuditingData propertyAuditingData,
 			Value value, SimpleMapperBuilder mapper, boolean insertable, boolean key) {
 		final Type type = value.getType();
 
 		if ( type instanceof BasicType
 				|| type instanceof SerializableToBlobType
 				|| "org.hibernate.type.PrimitiveByteArrayBlobType".equals( type.getClass().getName() ) ) {
 			if ( parent != null ) {
 				final boolean addNestedType = (value instanceof SimpleValue)
 						&& ((SimpleValue) value).getTypeParameters() != null;
 
 				String typeName = type.getName();
 				if ( typeName == null ) {
 					typeName = type.getClass().getName();
 				}
 
 				final Element propMapping = MetadataTools.addProperty(
 						parent,
 						propertyAuditingData.getName(),
 						addNestedType ? null : typeName,
 						propertyAuditingData.isForceInsertable() || insertable,
 						key
 				);
 				MetadataTools.addColumns( propMapping, value.getColumnIterator() );
 
 				if ( addNestedType ) {
 					final Properties typeParameters = ((SimpleValue) value).getTypeParameters();
 					final Element typeMapping = propMapping.addElement( "type" );
 					typeMapping.addAttribute( "name", typeName );
 
 					if ( "org.hibernate.type.EnumType".equals( typeName ) ) {
 						// Proper handling of enumeration type
 						mapEnumerationType( typeMapping, type, typeParameters );
 					}
 					else {
 						// By default copying all Hibernate properties
 						for ( Object object : typeParameters.keySet() ) {
 							final String keyType = (String) object;
 							final String property = typeParameters.getProperty( keyType );
 
 							if ( property != null ) {
 								typeMapping.addElement( "param" ).addAttribute( "name", keyType ).setText( property );
 							}
 						}
 					}
 				}
 			}
 
 			// A null mapper means that we only want to add xml mappings
 			if ( mapper != null ) {
 				mapper.add( propertyAuditingData.getPropertyData() );
 			}
 		}
 		else {
 			return false;
 		}
 
 		return true;
 	}
 
 	private void mapEnumerationType(Element parent, Type type, Properties parameters) {
 		if ( parameters.getProperty( EnumType.ENUM ) != null ) {
 			parent.addElement( "param" )
 					.addAttribute( "name", EnumType.ENUM )
 					.setText( parameters.getProperty( EnumType.ENUM ) );
 		}
 		else {
 			parent.addElement( "param" ).addAttribute( "name", EnumType.ENUM ).setText(
 					type.getReturnedClass()
 							.getName()
 			);
 		}
 		if ( parameters.getProperty( EnumType.NAMED ) != null ) {
 			parent.addElement( "param" ).addAttribute( "name", EnumType.NAMED ).setText(
 					parameters.getProperty(
 							EnumType.NAMED
 					)
 			);
 		}
 		else if ( parameters.get( DynamicParameterizedType.XPROPERTY ) != null ) {
 			// Case of annotations.
 			parent.addElement( "param" ).addAttribute( "name", EnumType.NAMED )
 					.setText( "" + !((EnumType) ((CustomType) type).getUserType()).isOrdinal() );
 		}
 		// Otherwise we assume that the choice between ordinal and named representation has been omitted.
 		// Call to EnumType#isOrdinal() would always return the default Types.INTEGER. We let Hibernate
 		// to choose the proper strategy during runtime.
 	}
 
 	@SuppressWarnings({"unchecked"})
 	boolean addManyToOne(
 			Element parent,
 			PropertyAuditingData propertyAuditingData,
 			Value value,
 			SimpleMapperBuilder mapper) {
 		final Type type = value.getType();
 
 		// A null mapper occurs when adding to composite-id element
 		final Element manyToOneElement = parent.addElement( mapper != null ? "many-to-one" : "key-many-to-one" );
 		manyToOneElement.addAttribute( "name", propertyAuditingData.getName() );
 		manyToOneElement.addAttribute( "class", type.getName() );
 		MetadataTools.addColumns( manyToOneElement, value.getColumnIterator() );
 
 		// A null mapper means that we only want to add xml mappings
 		if ( mapper != null ) {
 			mapper.add( propertyAuditingData.getPropertyData() );
 		}
 
 		return true;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/CollectionMetadataGenerator.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/CollectionMetadataGenerator.java
index a333b1ae0a..1fdf9d4caf 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/CollectionMetadataGenerator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/CollectionMetadataGenerator.java
@@ -1,959 +1,960 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.configuration.internal.metadata;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
 import java.util.TreeSet;
 import javax.persistence.JoinColumn;
 
 import org.hibernate.MappingException;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.envers.ModificationStore;
 import org.hibernate.envers.RelationTargetAuditMode;
 import org.hibernate.envers.configuration.internal.metadata.reader.AuditedPropertiesReader;
 import org.hibernate.envers.configuration.internal.metadata.reader.ComponentAuditedPropertiesReader;
 import org.hibernate.envers.configuration.internal.metadata.reader.ComponentAuditingData;
 import org.hibernate.envers.configuration.internal.metadata.reader.PropertyAuditingData;
 import org.hibernate.envers.internal.EnversMessageLogger;
 import org.hibernate.envers.internal.entities.EntityConfiguration;
 import org.hibernate.envers.internal.entities.IdMappingData;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.entities.mapper.CompositeMapperBuilder;
 import org.hibernate.envers.internal.entities.mapper.MultiPropertyMapper;
 import org.hibernate.envers.internal.entities.mapper.PropertyMapper;
 import org.hibernate.envers.internal.entities.mapper.SinglePropertyMapper;
 import org.hibernate.envers.internal.entities.mapper.id.IdMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.BasicCollectionMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.CommonCollectionMapperData;
 import org.hibernate.envers.internal.entities.mapper.relation.ListCollectionMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.MapCollectionMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleComponentData;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleIdData;
 import org.hibernate.envers.internal.entities.mapper.relation.SortedMapCollectionMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.SortedSetCollectionMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.ToOneIdMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.component.MiddleDummyComponentMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.component.MiddleEmbeddableComponentMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.component.MiddleMapKeyIdComponentMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.component.MiddleMapKeyPropertyComponentMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.component.MiddleRelatedComponentMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.component.MiddleSimpleComponentMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.component.MiddleStraightComponentMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.proxy.ListProxy;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.proxy.MapProxy;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.proxy.SetProxy;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.proxy.SortedMapProxy;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.proxy.SortedSetProxy;
 import org.hibernate.envers.internal.entities.mapper.relation.query.OneAuditEntityQueryGenerator;
 import org.hibernate.envers.internal.entities.mapper.relation.query.RelationQueryGenerator;
 import org.hibernate.envers.internal.tools.MappingTools;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.envers.internal.tools.StringTools;
 import org.hibernate.envers.internal.tools.Tools;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.IndexedCollection;
 import org.hibernate.mapping.ManyToOne;
 import org.hibernate.mapping.OneToMany;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Table;
 import org.hibernate.mapping.Value;
 import org.hibernate.type.BagType;
 import org.hibernate.type.ComponentType;
 import org.hibernate.type.ListType;
 import org.hibernate.type.ManyToOneType;
 import org.hibernate.type.MapType;
 import org.hibernate.type.SetType;
 import org.hibernate.type.SortedMapType;
 import org.hibernate.type.SortedSetType;
 import org.hibernate.type.Type;
 
 import org.jboss.logging.Logger;
 
 import org.dom4j.Element;
 
 /**
  * Generates metadata for a collection-valued property.
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  */
 public final class CollectionMetadataGenerator {
 	private static final EnversMessageLogger LOG = Logger.getMessageLogger(
 			EnversMessageLogger.class,
 			CollectionMetadataGenerator.class.getName()
 	);
 
 	private final AuditMetadataGenerator mainGenerator;
 	private final String propertyName;
 	private final Collection propertyValue;
 	private final CompositeMapperBuilder currentMapper;
 	private final String referencingEntityName;
 	private final EntityXmlMappingData xmlMappingData;
 	private final PropertyAuditingData propertyAuditingData;
 
 	private final EntityConfiguration referencingEntityConfiguration;
 	/**
 	 * Null if this collection isn't a relation to another entity.
 	 */
 	private final String referencedEntityName;
 
 	/**
 	 * @param mainGenerator Main generator, giving access to configuration and the basic mapper.
 	 * @param propertyValue Value of the collection, as mapped by Hibernate.
 	 * @param currentMapper Mapper, to which the appropriate {@link PropertyMapper} will be added.
 	 * @param referencingEntityName Name of the entity that owns this collection.
 	 * @param xmlMappingData In case this collection requires a middle table, additional mapping documents will
 	 * be created using this object.
 	 * @param propertyAuditingData Property auditing (meta-)data. Among other things, holds the name of the
 	 * property that references the collection in the referencing entity, the user data for middle (join)
 	 * table and the value of the <code>@MapKey</code> annotation, if there was one.
 	 */
 	public CollectionMetadataGenerator(
 			AuditMetadataGenerator mainGenerator,
 			Collection propertyValue, CompositeMapperBuilder currentMapper,
 			String referencingEntityName, EntityXmlMappingData xmlMappingData,
 			PropertyAuditingData propertyAuditingData) {
 		this.mainGenerator = mainGenerator;
 		this.propertyValue = propertyValue;
 		this.currentMapper = currentMapper;
 		this.referencingEntityName = referencingEntityName;
 		this.xmlMappingData = xmlMappingData;
 		this.propertyAuditingData = propertyAuditingData;
 
 		this.propertyName = propertyAuditingData.getName();
 
 		referencingEntityConfiguration = mainGenerator.getEntitiesConfigurations().get( referencingEntityName );
 		if ( referencingEntityConfiguration == null ) {
 			throw new MappingException( "Unable to read auditing configuration for " + referencingEntityName + "!" );
 		}
 
 		referencedEntityName = MappingTools.getReferencedEntityName( propertyValue.getElement() );
 	}
 
 	void addCollection() {
 		final Type type = propertyValue.getType();
 		final Value value = propertyValue.getElement();
 
 		final boolean oneToManyAttachedType = type instanceof BagType || type instanceof SetType || type instanceof MapType || type instanceof ListType;
 		final boolean inverseOneToMany = (value instanceof OneToMany) && (propertyValue.isInverse());
 		final boolean owningManyToOneWithJoinTableBidirectional = (value instanceof ManyToOne) && (propertyAuditingData.getRelationMappedBy() != null);
 		final boolean fakeOneToManyBidirectional = (value instanceof OneToMany) && (propertyAuditingData.getAuditMappedBy() != null);
 
 		if ( oneToManyAttachedType && (inverseOneToMany || fakeOneToManyBidirectional || owningManyToOneWithJoinTableBidirectional) ) {
 			// A one-to-many relation mapped using @ManyToOne and @OneToMany(mappedBy="...")
 			addOneToManyAttached( fakeOneToManyBidirectional );
 		}
 		else {
 			// All other kinds of relations require a middle (join) table.
 			addWithMiddleTable();
 		}
 	}
 
 	private MiddleIdData createMiddleIdData(IdMappingData idMappingData, String prefix, String entityName) {
 		return new MiddleIdData(
 				mainGenerator.getVerEntCfg(), idMappingData, prefix, entityName,
 				mainGenerator.getEntitiesConfigurations().containsKey( entityName )
 		);
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private void addOneToManyAttached(boolean fakeOneToManyBidirectional) {
 		LOG.debugf(
 				"Adding audit mapping for property %s.%s: one-to-many collection, using a join column on the referenced entity",
 				referencingEntityName,
 				propertyName
 		);
 
 		final String mappedBy = getMappedBy( propertyValue );
 
 		final IdMappingData referencedIdMapping = mainGenerator.getReferencedIdMappingData(
 				referencingEntityName,
 				referencedEntityName,
 				propertyAuditingData,
 				false
 		);
 		final IdMappingData referencingIdMapping = referencingEntityConfiguration.getIdMappingData();
 
 		// Generating the id mappers data for the referencing side of the relation.
 		final MiddleIdData referencingIdData = createMiddleIdData(
 				referencingIdMapping,
 				mappedBy + "_",
 				referencingEntityName
 		);
 
 		// And for the referenced side. The prefixed mapper won't be used (as this collection isn't persisted
 		// in a join table, so the prefix value is arbitrary).
 		final MiddleIdData referencedIdData = createMiddleIdData(
 				referencedIdMapping,
 				null, referencedEntityName
 		);
 
 		// Generating the element mapping.
 		final MiddleComponentData elementComponentData = new MiddleComponentData(
 				new MiddleRelatedComponentMapper( referencedIdData ), 0
 		);
 
 		// Generating the index mapping, if an index exists. It can only exists in case a javax.persistence.MapKey
 		// annotation is present on the entity. So the middleEntityXml will be not be used. The queryGeneratorBuilder
 		// will only be checked for nullnes.
 		MiddleComponentData indexComponentData = addIndex( null, null );
 
 		// Generating the query generator - it should read directly from the related entity.
 		final RelationQueryGenerator queryGenerator = new OneAuditEntityQueryGenerator(
 				mainGenerator.getGlobalCfg(),
 				mainGenerator.getVerEntCfg(),
 				mainGenerator.getAuditStrategy(),
 				referencingIdData,
 				referencedEntityName,
 				referencedIdData,
 				isEmbeddableElementType()
 		);
 
 		// Creating common mapper data.
 		final CommonCollectionMapperData commonCollectionMapperData = new CommonCollectionMapperData(
 				mainGenerator.getVerEntCfg(), referencedEntityName,
 				propertyAuditingData.getPropertyData(),
 				referencingIdData, queryGenerator
 		);
 
 		PropertyMapper fakeBidirectionalRelationMapper;
 		PropertyMapper fakeBidirectionalRelationIndexMapper;
 		if ( fakeOneToManyBidirectional ) {
 			// In case of a fake many-to-one bidirectional relation, we have to generate a mapper which maps
 			// the mapped-by property name to the id of the related entity (which is the owner of the collection).
 			final String auditMappedBy = propertyAuditingData.getAuditMappedBy();
 
 			// Creating a prefixed relation mapper.
 			final IdMapper relMapper = referencingIdMapping.getIdMapper().prefixMappedProperties(
 					MappingTools.createToOneRelationPrefix( auditMappedBy )
 			);
 
 			fakeBidirectionalRelationMapper = new ToOneIdMapper(
 					relMapper,
 					// The mapper will only be used to map from entity to map, so no need to provide other details
 					// when constructing the PropertyData.
 					new PropertyData( auditMappedBy, null, null, null ),
 					referencingEntityName, false
 			);
 
 			// Checking if there's an index defined. If so, adding a mapper for it.
 			if ( propertyAuditingData.getPositionMappedBy() != null ) {
 				final String positionMappedBy = propertyAuditingData.getPositionMappedBy();
 				fakeBidirectionalRelationIndexMapper = new SinglePropertyMapper(
 						new PropertyData(
 								positionMappedBy,
 								null,
 								null,
 								null
 						)
 				);
 
 				// Also, overwriting the index component data to properly read the index.
 				indexComponentData = new MiddleComponentData(
 						new MiddleStraightComponentMapper( positionMappedBy ),
 						0
 				);
 			}
 			else {
 				fakeBidirectionalRelationIndexMapper = null;
 			}
 		}
 		else {
 			fakeBidirectionalRelationMapper = null;
 			fakeBidirectionalRelationIndexMapper = null;
 		}
 
 		// Checking the type of the collection and adding an appropriate mapper.
 		addMapper( commonCollectionMapperData, elementComponentData, indexComponentData );
 
 		// Storing information about this relation.
 		referencingEntityConfiguration.addToManyNotOwningRelation(
 				propertyName,
 				mappedBy,
 				referencedEntityName,
 				referencingIdData.getPrefixedMapper(),
 				fakeBidirectionalRelationMapper,
 				fakeBidirectionalRelationIndexMapper
 		);
 	}
 
 	/**
 	 * Adds mapping of the id of a related entity to the given xml mapping, prefixing the id with the given prefix.
 	 *
 	 * @param xmlMapping Mapping, to which to add the xml.
 	 * @param prefix Prefix for the names of properties which will be prepended to properties that form the id.
 	 * @param columnNameIterator Iterator over the column names that will be used for properties that form the id.
 	 * @param relatedIdMapping Id mapping data of the related entity.
 	 */
 	@SuppressWarnings({"unchecked"})
 	private void addRelatedToXmlMapping(
 			Element xmlMapping, String prefix,
 			MetadataTools.ColumnNameIterator columnNameIterator,
 			IdMappingData relatedIdMapping) {
 		final Element properties = (Element) relatedIdMapping.getXmlRelationMapping().clone();
 		MetadataTools.prefixNamesInPropertyElement( properties, prefix, columnNameIterator, true, true );
 		for ( Element idProperty : (java.util.List<Element>) properties.elements() ) {
 			xmlMapping.add( (Element) idProperty.clone() );
 		}
 	}
 
 	private String getMiddleTableName(Collection value, String entityName) {
 		// We check how Hibernate maps the collection.
 		if ( value.getElement() instanceof OneToMany && !value.isInverse() ) {
 			// This must be a @JoinColumn+@OneToMany mapping. Generating the table name, as Hibernate doesn't use a
 			// middle table for mapping this relation.
 			return StringTools.getLastComponent( entityName ) + "_" + StringTools.getLastComponent(
 					MappingTools.getReferencedEntityName(
 							value.getElement()
 					)
 			);
 		}
 		// Hibernate uses a middle table for mapping this relation, so we get it's name directly.
 		return value.getCollectionTable().getName();
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private void addWithMiddleTable() {
 
 		LOG.debugf(
 				"Adding audit mapping for property %s.%s: collection with a join table",
 				referencingEntityName,
 				propertyName
 		);
 
 		// Generating the name of the middle table
 		String auditMiddleTableName;
 		String auditMiddleEntityName;
 		if ( !StringTools.isEmpty( propertyAuditingData.getJoinTable().name() ) ) {
 			auditMiddleTableName = propertyAuditingData.getJoinTable().name();
 			auditMiddleEntityName = propertyAuditingData.getJoinTable().name();
 		}
 		else {
 			final String middleTableName = getMiddleTableName( propertyValue, referencingEntityName );
 			auditMiddleTableName = mainGenerator.getVerEntCfg().getAuditTableName( null, middleTableName );
 			auditMiddleEntityName = mainGenerator.getVerEntCfg().getAuditEntityName( middleTableName );
 		}
 
 		LOG.debugf( "Using join table name: %s", auditMiddleTableName );
 
 		// Generating the XML mapping for the middle entity, only if the relation isn't inverse.
 		// If the relation is inverse, will be later checked by comparing middleEntityXml with null.
 		Element middleEntityXml;
 		if ( !propertyValue.isInverse() ) {
 			// Generating a unique middle entity name
 			auditMiddleEntityName = mainGenerator.getAuditEntityNameRegister().createUnique( auditMiddleEntityName );
 
 			// Registering the generated name
 			mainGenerator.getAuditEntityNameRegister().register( auditMiddleEntityName );
 
 			middleEntityXml = createMiddleEntityXml(
 					auditMiddleTableName,
 					auditMiddleEntityName,
 					propertyValue.getWhere()
 			);
 		}
 		else {
 			middleEntityXml = null;
 		}
 
 		// ******
 		// Generating the mapping for the referencing entity (it must be an entity).
 		// ******
 		// Getting the id-mapping data of the referencing entity (the entity that "owns" this collection).
 		final IdMappingData referencingIdMapping = referencingEntityConfiguration.getIdMappingData();
 
 		// Only valid for an inverse relation; null otherwise.
 		String mappedBy;
 
 		// The referencing prefix is always for a related entity. So it has always the "_" at the end added.
 		String referencingPrefixRelated;
 		String referencedPrefix;
 
 		if ( propertyValue.isInverse() ) {
 			// If the relation is inverse, then referencedEntityName is not null.
 			mappedBy = getMappedBy(
 					propertyValue.getCollectionTable(),
-					mainGenerator.getCfg().getClassMapping( referencedEntityName )
+					mainGenerator.getMetadata().getEntityBinding( referencedEntityName )
 			);
 
 			referencingPrefixRelated = mappedBy + "_";
 			referencedPrefix = StringTools.getLastComponent( referencedEntityName );
 		}
 		else {
 			mappedBy = null;
 
 			referencingPrefixRelated = StringTools.getLastComponent( referencingEntityName ) + "_";
 			referencedPrefix = referencedEntityName == null ? "element" : propertyName;
 		}
 
 		// Storing the id data of the referencing entity: original mapper, prefixed mapper and entity name.
 		final MiddleIdData referencingIdData = createMiddleIdData(
 				referencingIdMapping,
 				referencingPrefixRelated,
 				referencingEntityName
 		);
 
 		// Creating a query generator builder, to which additional id data will be added, in case this collection
 		// references some entities (either from the element or index). At the end, this will be used to build
 		// a query generator to read the raw data collection from the middle table.
 		final QueryGeneratorBuilder queryGeneratorBuilder = new QueryGeneratorBuilder(
 				mainGenerator.getGlobalCfg(),
 				mainGenerator.getVerEntCfg(),
 				mainGenerator.getAuditStrategy(),
 				referencingIdData,
 				auditMiddleEntityName,
 				isEmbeddableElementType()
 		);
 
 		// Adding the XML mapping for the referencing entity, if the relation isn't inverse.
 		if ( middleEntityXml != null ) {
 			// Adding related-entity (in this case: the referencing's entity id) id mapping to the xml.
 			addRelatedToXmlMapping(
 					middleEntityXml, referencingPrefixRelated,
 					MetadataTools.getColumnNameIterator( propertyValue.getKey().getColumnIterator() ),
 					referencingIdMapping
 			);
 		}
 
 		// ******
 		// Generating the element mapping.
 		// ******
 		final MiddleComponentData elementComponentData = addValueToMiddleTable(
 				propertyValue.getElement(),
 				middleEntityXml,
 				queryGeneratorBuilder,
 				referencedPrefix,
 				propertyAuditingData.getJoinTable().inverseJoinColumns()
 		);
 
 		// ******
 		// Generating the index mapping, if an index exists.
 		// ******
 		final MiddleComponentData indexComponentData = addIndex( middleEntityXml, queryGeneratorBuilder );
 
 		// ******
 		// Generating the property mapper.
 		// ******
 		// Building the query generator.
 		final RelationQueryGenerator queryGenerator = queryGeneratorBuilder.build( elementComponentData, indexComponentData );
 
 		// Creating common data
 		final CommonCollectionMapperData commonCollectionMapperData = new CommonCollectionMapperData(
 				mainGenerator.getVerEntCfg(),
 				auditMiddleEntityName,
 				propertyAuditingData.getPropertyData(),
 				referencingIdData,
 				queryGenerator
 		);
 
 		// Checking the type of the collection and adding an appropriate mapper.
 		addMapper( commonCollectionMapperData, elementComponentData, indexComponentData );
 
 		// ******
 		// Storing information about this relation.
 		// ******
 		storeMiddleEntityRelationInformation( mappedBy );
 	}
 
 	private MiddleComponentData addIndex(Element middleEntityXml, QueryGeneratorBuilder queryGeneratorBuilder) {
 		if ( propertyValue instanceof IndexedCollection ) {
 			final IndexedCollection indexedValue = (IndexedCollection) propertyValue;
 			final String mapKey = propertyAuditingData.getMapKey();
 			if ( mapKey == null ) {
 				// This entity doesn't specify a javax.persistence.MapKey. Mapping it to the middle entity.
 				return addValueToMiddleTable(
 						indexedValue.getIndex(),
 						middleEntityXml,
 						queryGeneratorBuilder,
 						"mapkey",
 						null
 				);
 			}
 			else {
 				final IdMappingData referencedIdMapping = mainGenerator.getEntitiesConfigurations()
 						.get( referencedEntityName ).getIdMappingData();
 				final int currentIndex = queryGeneratorBuilder == null ? 0 : queryGeneratorBuilder.getCurrentIndex();
 				if ( "".equals( mapKey ) ) {
 					// The key of the map is the id of the entity.
 					return new MiddleComponentData(
 							new MiddleMapKeyIdComponentMapper(
 									mainGenerator.getVerEntCfg(),
 									referencedIdMapping.getIdMapper()
 							),
 							currentIndex
 					);
 				}
 				else {
 					// The key of the map is a property of the entity.
 					return new MiddleComponentData(
 							new MiddleMapKeyPropertyComponentMapper(
 									mapKey,
 									propertyAuditingData.getAccessType()
 							),
 							currentIndex
 					);
 				}
 			}
 		}
 		else {
 			// No index - creating a dummy mapper.
 			return new MiddleComponentData( new MiddleDummyComponentMapper(), 0 );
 		}
 	}
 
 	/**
 	 * @param value Value, which should be mapped to the middle-table, either as a relation to another entity,
 	 * or as a simple value.
 	 * @param xmlMapping If not <code>null</code>, xml mapping for this value is added to this element.
 	 * @param queryGeneratorBuilder In case <code>value</code> is a relation to another entity, information about it
 	 * should be added to the given.
 	 * @param prefix Prefix for proeprty names of related entities identifiers.
 	 * @param joinColumns Names of columns to use in the xml mapping, if this array isn't null and has any elements.
 	 *
 	 * @return Data for mapping this component.
 	 */
 	@SuppressWarnings({"unchecked"})
 	private MiddleComponentData addValueToMiddleTable(
 			Value value,
 			Element xmlMapping,
 			QueryGeneratorBuilder queryGeneratorBuilder,
 			String prefix,
 			JoinColumn[] joinColumns) {
 		final Type type = value.getType();
 		if ( type instanceof ManyToOneType ) {
 			final String prefixRelated = prefix + "_";
 
 			final String referencedEntityName = MappingTools.getReferencedEntityName( value );
 
 			final IdMappingData referencedIdMapping = mainGenerator.getReferencedIdMappingData(
 					referencingEntityName,
 					referencedEntityName,
 					propertyAuditingData,
 					true
 			);
 
 			// Adding related-entity (in this case: the referenced entities id) id mapping to the xml only if the
 			// relation isn't inverse (so when <code>xmlMapping</code> is not null).
 			if ( xmlMapping != null ) {
 				addRelatedToXmlMapping(
 						xmlMapping, prefixRelated,
 						joinColumns != null && joinColumns.length > 0
 								? MetadataTools.getColumnNameIterator( joinColumns )
 								: MetadataTools.getColumnNameIterator( value.getColumnIterator() ),
 						referencedIdMapping
 				);
 			}
 
 			// Storing the id data of the referenced entity: original mapper, prefixed mapper and entity name.
 			final MiddleIdData referencedIdData = createMiddleIdData(
 					referencedIdMapping,
 					prefixRelated,
 					referencedEntityName
 			);
 			// And adding it to the generator builder.
 			queryGeneratorBuilder.addRelation( referencedIdData );
 
 			return new MiddleComponentData(
 					new MiddleRelatedComponentMapper( referencedIdData ),
 					queryGeneratorBuilder.getCurrentIndex()
 			);
 		}
 		else if ( type instanceof ComponentType ) {
 			// Collection of embeddable elements.
 			final Component component = (Component) value;
 			final Class componentClass = ReflectionTools.loadClass(
 					component.getComponentClassName(),
 					mainGenerator.getClassLoaderService()
 			);
 			final MiddleEmbeddableComponentMapper componentMapper = new MiddleEmbeddableComponentMapper(
 					new MultiPropertyMapper(),
 					componentClass
 			);
 
 			final Element parentXmlMapping = xmlMapping.getParent();
 			final ComponentAuditingData auditData = new ComponentAuditingData();
-			final ReflectionManager reflectionManager = mainGenerator.getCfg().getReflectionManager();
+			final ReflectionManager reflectionManager = mainGenerator.getMetadata().getMetadataBuildingOptions().getReflectionManager();
 
 			new ComponentAuditedPropertiesReader(
 					ModificationStore.FULL,
 					new AuditedPropertiesReader.ComponentPropertiesSource( reflectionManager, component ),
 					auditData, mainGenerator.getGlobalCfg(), reflectionManager, ""
 			).read();
 
 			// Emulating first pass.
 			for ( String auditedPropertyName : auditData.getPropertyNames() ) {
 				final PropertyAuditingData nestedAuditingData = auditData.getPropertyAuditingData( auditedPropertyName );
 				mainGenerator.addValue(
 						parentXmlMapping,
 						component.getProperty( auditedPropertyName ).getValue(),
 						componentMapper,
 						prefix, xmlMappingData,
 						nestedAuditingData,
 						true,
 						true,
 						true
 				);
 			}
 
 			// Emulating second pass so that the relations can be mapped too.
 			for ( String auditedPropertyName : auditData.getPropertyNames() ) {
 				final PropertyAuditingData nestedAuditingData = auditData.getPropertyAuditingData( auditedPropertyName );
 				mainGenerator.addValue(
 						parentXmlMapping,
 						component.getProperty( auditedPropertyName ).getValue(),
 						componentMapper,
 						referencingEntityName,
 						xmlMappingData,
 						nestedAuditingData,
 						true,
 						false,
 						true
 				);
 			}
 
 			// Add an additional column holding a number to make each entry unique within the set.
 			// Embeddable properties may contain null values, so cannot be stored within composite primary key.
 			if ( propertyValue.isSet() ) {
 				final String setOrdinalPropertyName = mainGenerator.getVerEntCfg()
 						.getEmbeddableSetOrdinalPropertyName();
 				final Element ordinalProperty = MetadataTools.addProperty(
 						xmlMapping, setOrdinalPropertyName, "integer", true, true
 				);
 				MetadataTools.addColumn(
 						ordinalProperty, setOrdinalPropertyName, null, null, null, null, null, null, false
 				);
 			}
 
 			return new MiddleComponentData( componentMapper, 0 );
 		}
 		else {
 			// Last but one parameter: collection components are always insertable
 			final boolean mapped = mainGenerator.getBasicMetadataGenerator().addBasic(
 					xmlMapping,
 					new PropertyAuditingData(
 							prefix,
 							"field",
 							ModificationStore.FULL,
 							RelationTargetAuditMode.AUDITED,
 							null,
 							null,
 							false
 					),
 					value,
 					null,
 					true,
 					true
 			);
 
 			if ( mapped ) {
 				// Simple values are always stored in the first item of the array returned by the query generator.
 				return new MiddleComponentData(
 						new MiddleSimpleComponentMapper( mainGenerator.getVerEntCfg(), prefix ),
 						0
 				);
 			}
 			else {
 				mainGenerator.throwUnsupportedTypeException( type, referencingEntityName, propertyName );
 				// Impossible to get here.
 				throw new AssertionError();
 			}
 		}
 	}
 
 	private void addMapper(
 			CommonCollectionMapperData commonCollectionMapperData,
 			MiddleComponentData elementComponentData,
 			MiddleComponentData indexComponentData) {
 		final Type type = propertyValue.getType();
 		final boolean embeddableElementType = isEmbeddableElementType();
 		if ( type instanceof SortedSetType ) {
 			currentMapper.addComposite(
 					propertyAuditingData.getPropertyData(),
 					new SortedSetCollectionMapper(
 							commonCollectionMapperData,
 							TreeSet.class,
 							SortedSetProxy.class,
 							elementComponentData,
 							propertyValue.getComparator(),
 							embeddableElementType,
 							embeddableElementType
 					)
 			);
 		}
 		else if ( type instanceof SetType ) {
 			currentMapper.addComposite(
 					propertyAuditingData.getPropertyData(),
 					new BasicCollectionMapper<Set>(
 							commonCollectionMapperData,
 							HashSet.class,
 							SetProxy.class,
 							elementComponentData,
 							embeddableElementType,
 							embeddableElementType
 					)
 			);
 		}
 		else if ( type instanceof SortedMapType ) {
 			// Indexed collection, so <code>indexComponentData</code> is not null.
 			currentMapper.addComposite(
 					propertyAuditingData.getPropertyData(),
 					new SortedMapCollectionMapper(
 							commonCollectionMapperData,
 							TreeMap.class,
 							SortedMapProxy.class,
 							elementComponentData,
 							indexComponentData,
 							propertyValue.getComparator(),
 							embeddableElementType
 					)
 			);
 		}
 		else if ( type instanceof MapType ) {
 			// Indexed collection, so <code>indexComponentData</code> is not null.
 			currentMapper.addComposite(
 					propertyAuditingData.getPropertyData(),
 					new MapCollectionMapper<Map>(
 							commonCollectionMapperData,
 							HashMap.class,
 							MapProxy.class,
 							elementComponentData,
 							indexComponentData,
 							embeddableElementType
 					)
 			);
 		}
 		else if ( type instanceof BagType ) {
 			currentMapper.addComposite(
 					propertyAuditingData.getPropertyData(),
 					new BasicCollectionMapper<List>(
 							commonCollectionMapperData,
 							ArrayList.class,
 							ListProxy.class,
 							elementComponentData,
 							embeddableElementType,
 							embeddableElementType
 					)
 			);
 		}
 		else if ( type instanceof ListType ) {
 			// Indexed collection, so <code>indexComponentData</code> is not null.
 			currentMapper.addComposite(
 					propertyAuditingData.getPropertyData(),
 					new ListCollectionMapper(
 							commonCollectionMapperData,
 							elementComponentData,
 							indexComponentData,
 							embeddableElementType
 					)
 			);
 		}
 		else {
 			mainGenerator.throwUnsupportedTypeException( type, referencingEntityName, propertyName );
 		}
 	}
 
 	private void storeMiddleEntityRelationInformation(String mappedBy) {
 		// Only if this is a relation (when there is a referenced entity).
 		if ( referencedEntityName != null ) {
 			if ( propertyValue.isInverse() ) {
 				referencingEntityConfiguration.addToManyMiddleNotOwningRelation(
 						propertyName,
 						mappedBy,
 						referencedEntityName
 				);
 			}
 			else {
 				referencingEntityConfiguration.addToManyMiddleRelation( propertyName, referencedEntityName );
 			}
 		}
 	}
 
 	private Element createMiddleEntityXml(String auditMiddleTableName, String auditMiddleEntityName, String where) {
 		final String schema = mainGenerator.getSchema(
 				propertyAuditingData.getJoinTable().schema(),
 				propertyValue.getCollectionTable()
 		);
 		final String catalog = mainGenerator.getCatalog(
 				propertyAuditingData.getJoinTable().catalog(),
 				propertyValue.getCollectionTable()
 		);
 
 		final Element middleEntityXml = MetadataTools.createEntity(
 				xmlMappingData.newAdditionalMapping(),
 				new AuditTableData( auditMiddleEntityName, auditMiddleTableName, schema, catalog ), null, null
 		);
 		final Element middleEntityXmlId = middleEntityXml.addElement( "composite-id" );
 
 		// If there is a where clause on the relation, adding it to the middle entity.
 		if ( where != null ) {
 			middleEntityXml.addAttribute( "where", where );
 		}
 
 		middleEntityXmlId.addAttribute( "name", mainGenerator.getVerEntCfg().getOriginalIdPropName() );
 
 		// Adding the revision number as a foreign key to the revision info entity to the composite id of the
 		// middle table.
 		mainGenerator.addRevisionInfoRelation( middleEntityXmlId );
 
 		// Adding the revision type property to the entity xml.
 		mainGenerator.addRevisionType(
 				isEmbeddableElementType() ? middleEntityXmlId : middleEntityXml,
-				middleEntityXml
+				middleEntityXml,
+				isEmbeddableElementType()
 		);
 
 		// All other properties should also be part of the primary key of the middle entity.
 		return middleEntityXmlId;
 	}
 
 	/**
 	 * Checks if the collection element is of {@link ComponentType} type.
 	 */
 	private boolean isEmbeddableElementType() {
 		return propertyValue.getElement().getType() instanceof ComponentType;
 	}
 
 	private String getMappedBy(Collection collectionValue) {
 		PersistentClass referencedClass = null;
 		if ( collectionValue.getElement() instanceof OneToMany ) {
 			final OneToMany oneToManyValue = (OneToMany) collectionValue.getElement();
 			referencedClass = oneToManyValue.getAssociatedClass();
 		}
 		else if ( collectionValue.getElement() instanceof ManyToOne ) {
 			// Case for bi-directional relation with @JoinTable on the owning @ManyToOne side.
 			final ManyToOne manyToOneValue = (ManyToOne) collectionValue.getElement();
-			referencedClass = manyToOneValue.getMetadata().getClass( manyToOneValue.getReferencedEntityName() );
+			referencedClass = manyToOneValue.getMetadata().getEntityBinding( manyToOneValue.getReferencedEntityName() );
 		}
 
 		// If there's an @AuditMappedBy specified, returning it directly.
 		final String auditMappedBy = propertyAuditingData.getAuditMappedBy();
 		if ( auditMappedBy != null ) {
 			return auditMappedBy;
 		}
 
 		// searching in referenced class
 		String mappedBy = this.searchMappedBy( referencedClass, collectionValue );
 
 		if ( mappedBy == null ) {
 			LOG.debugf(
 					"Going to search the mapped by attribute for %s in superclasses of entity: %s",
 					propertyName,
 					referencedClass.getClassName()
 			);
 
 			PersistentClass tempClass = referencedClass;
 			while ( (mappedBy == null) && (tempClass.getSuperclass() != null) ) {
 				LOG.debugf( "Searching in superclass: %s", tempClass.getSuperclass().getClassName() );
 				mappedBy = this.searchMappedBy( tempClass.getSuperclass(), collectionValue );
 				tempClass = tempClass.getSuperclass();
 			}
 		}
 
 		if ( mappedBy == null ) {
 			throw new MappingException(
 					"Unable to read the mapped by attribute for " + propertyName + " in "
 							+ referencedClass.getClassName() + "!"
 			);
 		}
 
 		return mappedBy;
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private String searchMappedBy(PersistentClass referencedClass, Collection collectionValue) {
 		final Iterator<Property> assocClassProps = referencedClass.getPropertyIterator();
 		while ( assocClassProps.hasNext() ) {
 			final Property property = assocClassProps.next();
 
 			if ( Tools.iteratorsContentEqual(
 					property.getValue().getColumnIterator(),
 					collectionValue.getKey().getColumnIterator()
 			) ) {
 				return property.getName();
 			}
 		}
 		return null;
 	}
 
 	private String getMappedBy(Table collectionTable, PersistentClass referencedClass) {
 		// If there's an @AuditMappedBy specified, returning it directly.
 		final String auditMappedBy = propertyAuditingData.getAuditMappedBy();
 		if ( auditMappedBy != null ) {
 			return auditMappedBy;
 		}
 
 		// searching in referenced class
 		String mappedBy = this.searchMappedBy( referencedClass, collectionTable );
 
 		// not found on referenced class, searching on superclasses
 		if ( mappedBy == null ) {
 			LOG.debugf(
 					"Going to search the mapped by attribute for %s in superclasses of entity: %s",
 					propertyName,
 					referencedClass.getClassName()
 			);
 
 			PersistentClass tempClass = referencedClass;
 			while ( (mappedBy == null) && (tempClass.getSuperclass() != null) ) {
 				LOG.debugf( "Searching in superclass: %s", tempClass.getSuperclass().getClassName() );
 				mappedBy = this.searchMappedBy( tempClass.getSuperclass(), collectionTable );
 				tempClass = tempClass.getSuperclass();
 			}
 		}
 
 		if ( mappedBy == null ) {
 			throw new MappingException(
 					"Unable to read the mapped by attribute for " + propertyName + " in "
 							+ referencedClass.getClassName() + "!"
 			);
 		}
 
 		return mappedBy;
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private String searchMappedBy(PersistentClass referencedClass, Table collectionTable) {
 		final Iterator<Property> properties = referencedClass.getPropertyIterator();
 		while ( properties.hasNext() ) {
 			final Property property = properties.next();
 			if ( property.getValue() instanceof Collection ) {
 				// The equality is intentional. We want to find a collection property with the same collection table.
 				//noinspection ObjectEquality
 				if ( ((Collection) property.getValue()).getCollectionTable() == collectionTable ) {
 					return property.getName();
 				}
 			}
 		}
 		return null;
 	}
 
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/ComponentMetadataGenerator.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/ComponentMetadataGenerator.java
index 5dad4f4a0d..5e2f7fd063 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/ComponentMetadataGenerator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/ComponentMetadataGenerator.java
@@ -1,96 +1,97 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.configuration.internal.metadata;
 
 import java.util.Iterator;
 import java.util.Map;
 
 import org.hibernate.envers.configuration.internal.metadata.reader.ComponentAuditingData;
 import org.hibernate.envers.configuration.internal.metadata.reader.PropertyAuditingData;
 import org.hibernate.envers.internal.entities.mapper.CompositeMapperBuilder;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Value;
 
 import org.dom4j.Element;
 
 /**
  * Generates metadata for components.
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Zuchowski (author at zuchos dot com)
  */
 public final class ComponentMetadataGenerator {
     private final AuditMetadataGenerator mainGenerator;
 
     ComponentMetadataGenerator(AuditMetadataGenerator auditMetadataGenerator) {
         mainGenerator = auditMetadataGenerator;
     }
 
     @SuppressWarnings({"unchecked"})
     public void addComponent(
             Element parent, PropertyAuditingData propertyAuditingData,
             Value value, CompositeMapperBuilder mapper, String entityName,
             EntityXmlMappingData xmlMappingData, boolean firstPass) {
         final Component propComponent = (Component) value;
 
         final Class componentClass;
         if (propComponent.isDynamic()) {
             componentClass = ReflectionTools.loadClass(
                     Map.class.getCanonicalName(),
-                    mainGenerator.getClassLoaderService());
+                    mainGenerator.getClassLoaderService()
+            );
 
         } else {
             componentClass = ReflectionTools.loadClass(
                     propComponent.getComponentClassName(),
                     mainGenerator.getClassLoaderService()
             );
         }
         final CompositeMapperBuilder componentMapper = mapper.addComponent(
                 propertyAuditingData.getPropertyData(),
                 componentClass
         );
 
         // The property auditing data must be for a component.
         final ComponentAuditingData componentAuditingData = (ComponentAuditingData) propertyAuditingData;
 
         // Adding all properties of the component
         final Iterator<Property> properties = (Iterator<Property>) propComponent.getPropertyIterator();
         while (properties.hasNext()) {
             final Property property = properties.next();
 
             final PropertyAuditingData componentPropertyAuditingData =
                     componentAuditingData.getPropertyAuditingData(property.getName());
 
             // Checking if that property is audited
             if (componentPropertyAuditingData != null) {
                 mainGenerator.addValue(
                         parent, property.getValue(), componentMapper, entityName, xmlMappingData,
                         componentPropertyAuditingData, property.isInsertable(), firstPass, false
                 );
             }
         }
     }
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/MetadataTools.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/MetadataTools.java
index 87f4972648..887e156515 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/MetadataTools.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/MetadataTools.java
@@ -1,435 +1,435 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.configuration.internal.metadata;
 
 import java.util.Iterator;
 import javax.persistence.JoinColumn;
 
 import org.hibernate.envers.internal.tools.StringTools;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Formula;
 import org.hibernate.mapping.Selectable;
 
 import org.dom4j.Attribute;
 import org.dom4j.Document;
 import org.dom4j.Element;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public final class MetadataTools {
 	private MetadataTools() {
 	}
 
 	public static Element addNativelyGeneratedId(
 			Element parent, String name, String type,
 			boolean useRevisionEntityWithNativeId) {
 		final Element idMapping = parent.addElement( "id" );
 		idMapping.addAttribute( "name", name ).addAttribute( "type", type );
 
 		final Element generatorMapping = idMapping.addElement( "generator" );
 		if ( useRevisionEntityWithNativeId ) {
 			generatorMapping.addAttribute( "class", "native" );
 		}
 		else {
 			generatorMapping.addAttribute( "class", "org.hibernate.envers.enhanced.OrderedSequenceGenerator" );
 			generatorMapping.addElement( "param" ).addAttribute( "name", "sequence_name" ).setText(
 					"REVISION_GENERATOR"
 			);
 			generatorMapping.addElement( "param" )
 					.addAttribute( "name", "table_name" )
 					.setText( "REVISION_GENERATOR" );
 			generatorMapping.addElement( "param" ).addAttribute( "name", "initial_value" ).setText( "1" );
 			generatorMapping.addElement( "param" ).addAttribute( "name", "increment_size" ).setText( "1" );
 		}
 //        generatorMapping.addAttribute("class", "sequence");
 //        generatorMapping.addElement("param").addAttribute("name", "sequence").setText("custom");
 
 		return idMapping;
 	}
 
 	public static Element addProperty(
 			Element parent,
 			String name,
 			String type,
 			boolean insertable,
 			boolean updateable,
 			boolean key) {
 		final Element propMapping;
 		if ( key ) {
 			propMapping = parent.addElement( "key-property" );
 		}
 		else {
 			propMapping = parent.addElement( "property" );
+			propMapping.addAttribute( "insert", Boolean.toString( insertable ) );
+			propMapping.addAttribute( "update", Boolean.toString( updateable ) );
 		}
 
 		propMapping.addAttribute( "name", name );
-		propMapping.addAttribute( "insert", Boolean.toString( insertable ) );
-		propMapping.addAttribute( "update", Boolean.toString( updateable ) );
 
 		if ( type != null ) {
 			propMapping.addAttribute( "type", type );
 		}
 
 		return propMapping;
 	}
 
 	public static Element addProperty(Element parent, String name, String type, boolean insertable, boolean key) {
 		return addProperty( parent, name, type, insertable, false, key );
 	}
 
 	public static Element addModifiedFlagProperty(Element parent, String propertyName, String suffix, String modifiedFlagName) {
 		return addProperty(
 				parent,
 				(modifiedFlagName != null) ? modifiedFlagName : getModifiedFlagPropertyName( propertyName, suffix ),
 				"boolean",
 				true,
 				false,
 				false
 		);
 	}
 
 	public static String getModifiedFlagPropertyName(String propertyName, String suffix) {
 		return propertyName + suffix;
 	}
 
 	private static void addOrModifyAttribute(Element parent, String name, String value) {
 		final Attribute attribute = parent.attribute( name );
 		if ( attribute == null ) {
 			parent.addAttribute( name, value );
 		}
 		else {
 			attribute.setValue( value );
 		}
 	}
 
 	/**
 	 * Column name shall be wrapped with '`' signs if quotation required.
 	 */
 	public static Element addOrModifyColumn(Element parent, String name) {
 		final Element columnMapping = parent.element( "column" );
 
 		if ( columnMapping == null ) {
 			return addColumn( parent, name, null, null, null, null, null, null );
 		}
 
 		if ( !StringTools.isEmpty( name ) ) {
 			addOrModifyAttribute( columnMapping, "name", name );
 		}
 
 		return columnMapping;
 	}
 
 	/**
 	 * Adds new <code>column</code> element. Method assumes that the value of <code>name</code> attribute is already
 	 * wrapped with '`' signs if quotation required. It shall be invoked when column name is taken directly from configuration
 	 * file and not from {@link org.hibernate.mapping.PersistentClass} descriptor.
 	 */
 	public static Element addColumn(
 			Element parent,
 			String name,
 			Integer length,
 			Integer scale,
 			Integer precision,
 			String sqlType,
 			String customRead,
 			String customWrite) {
 		return addColumn( parent, name, length, scale, precision, sqlType, customRead, customWrite, false );
 	}
 
 	public static Element addColumn(
 			Element parent,
 			String name,
 			Integer length,
 			Integer scale,
 			Integer precision,
 			String sqlType,
 			String customRead,
 			String customWrite,
 			boolean quoted) {
 		final Element columnMapping = parent.addElement( "column" );
 
 		columnMapping.addAttribute( "name", quoted ? "`" + name + "`" : name );
 		if ( length != null ) {
 			columnMapping.addAttribute( "length", length.toString() );
 		}
 		if ( scale != null ) {
 			columnMapping.addAttribute( "scale", Integer.toString( scale ) );
 		}
 		if ( precision != null ) {
 			columnMapping.addAttribute( "precision", Integer.toString( precision ) );
 		}
 		if ( !StringTools.isEmpty( sqlType ) ) {
 			columnMapping.addAttribute( "sql-type", sqlType );
 		}
 
 		if ( !StringTools.isEmpty( customRead ) ) {
 			columnMapping.addAttribute( "read", customRead );
 		}
 		if ( !StringTools.isEmpty( customWrite ) ) {
 			columnMapping.addAttribute( "write", customWrite );
 		}
 
 		return columnMapping;
 	}
 
 	private static Element createEntityCommon(
 			Document document,
 			String type,
 			AuditTableData auditTableData,
 			String discriminatorValue,
 			Boolean isAbstract) {
 		final Element hibernateMapping = document.addElement( "hibernate-mapping" );
 		hibernateMapping.addAttribute( "auto-import", "false" );
 
 		final Element classMapping = hibernateMapping.addElement( type );
 
 		if ( auditTableData.getAuditEntityName() != null ) {
 			classMapping.addAttribute( "entity-name", auditTableData.getAuditEntityName() );
 		}
 
 		if ( discriminatorValue != null ) {
 			classMapping.addAttribute( "discriminator-value", discriminatorValue );
 		}
 
 		if ( !StringTools.isEmpty( auditTableData.getAuditTableName() ) ) {
 			classMapping.addAttribute( "table", auditTableData.getAuditTableName() );
 		}
 
 		if ( !StringTools.isEmpty( auditTableData.getSchema() ) ) {
 			classMapping.addAttribute( "schema", auditTableData.getSchema() );
 		}
 
 		if ( !StringTools.isEmpty( auditTableData.getCatalog() ) ) {
 			classMapping.addAttribute( "catalog", auditTableData.getCatalog() );
 		}
 
 		if ( isAbstract != null ) {
 			classMapping.addAttribute( "abstract", isAbstract.toString() );
 		}
 
 		return classMapping;
 	}
 
 	public static Element createEntity(
 			Document document,
 			AuditTableData auditTableData,
 			String discriminatorValue,
 			Boolean isAbstract) {
 		return createEntityCommon( document, "class", auditTableData, discriminatorValue, isAbstract );
 	}
 
 	public static Element createSubclassEntity(
 			Document document,
 			String subclassType,
 			AuditTableData auditTableData,
 			String extendsEntityName,
 			String discriminatorValue,
 			Boolean isAbstract) {
 		final Element classMapping = createEntityCommon(
 				document,
 				subclassType,
 				auditTableData,
 				discriminatorValue,
 				isAbstract
 		);
 
 		classMapping.addAttribute( "extends", extendsEntityName );
 
 		return classMapping;
 	}
 
 	public static Element createJoin(
 			Element parent,
 			String tableName,
 			String schema,
 			String catalog) {
 		final Element joinMapping = parent.addElement( "join" );
 
 		joinMapping.addAttribute( "table", tableName );
 
 		if ( !StringTools.isEmpty( schema ) ) {
 			joinMapping.addAttribute( "schema", schema );
 		}
 
 		if ( !StringTools.isEmpty( catalog ) ) {
 			joinMapping.addAttribute( "catalog", catalog );
 		}
 
 		return joinMapping;
 	}
 
 	public static void addColumns(Element anyMapping, Iterator selectables) {
 		while ( selectables.hasNext() ) {
 			final Selectable selectable = (Selectable) selectables.next();
 			if ( selectable.isFormula() ) {
 				throw new FormulaNotSupportedException();
 			}
 			addColumn( anyMapping, (Column) selectable );
 		}
 	}
 
 	/**
 	 * Adds <code>column</code> element with the following attributes (unless empty): <code>name</code>,
 	 * <code>length</code>, <code>scale</code>, <code>precision</code>, <code>sql-type</code>, <code>read</code>
 	 * and <code>write</code>.
 	 *
 	 * @param anyMapping Parent element.
 	 * @param column Column descriptor.
 	 */
 	public static void addColumn(Element anyMapping, Column column) {
 		addColumn(
 				anyMapping,
 				column.getName(),
 				column.getLength(),
 				column.getScale(),
 				column.getPrecision(),
 				column.getSqlType(),
 				column.getCustomRead(),
 				column.getCustomWrite(),
 				column.isQuoted()
 		);
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private static void changeNamesInColumnElement(Element element, ColumnNameIterator columnNameIterator) {
 		final Iterator<Element> properties = element.elementIterator();
 		while ( properties.hasNext() ) {
 			final Element property = properties.next();
 
 			if ( "column".equals( property.getName() ) ) {
 				final Attribute nameAttr = property.attribute( "name" );
 				if ( nameAttr != null ) {
 					nameAttr.setText( columnNameIterator.next() );
 				}
 			}
 		}
 	}
 
 	@SuppressWarnings({"unchecked"})
 	public static void prefixNamesInPropertyElement(
 			Element element,
 			String prefix,
 			ColumnNameIterator columnNameIterator,
 			boolean changeToKey,
 			boolean insertable) {
 		final Iterator<Element> properties = element.elementIterator();
 		while ( properties.hasNext() ) {
 			final Element property = properties.next();
 
 			if ( "property".equals( property.getName() ) || "many-to-one".equals( property.getName() ) ) {
 				final Attribute nameAttr = property.attribute( "name" );
 				if ( nameAttr != null ) {
 					nameAttr.setText( prefix + nameAttr.getText() );
 				}
 
 				changeNamesInColumnElement( property, columnNameIterator );
 
 				if ( changeToKey ) {
 					property.setName( "key-" + property.getName() );
 				}
 
 				if ( "property".equals( property.getName() ) ) {
 					final Attribute insert = property.attribute( "insert" );
 					insert.setText( Boolean.toString( insertable ) );
 				}
 			}
 		}
 	}
 
 	/**
 	 * Adds <code>formula</code> element.
 	 *
 	 * @param element Parent element.
 	 * @param formula Formula descriptor.
 	 */
 	public static void addFormula(Element element, Formula formula) {
 		element.addElement( "formula" ).setText( formula.getText() );
 	}
 
 	/**
 	 * Adds all <code>column</code> or <code>formula</code> elements.
 	 *
 	 * @param element Parent element.
 	 * @param columnIterator Iterator pointing at {@link org.hibernate.mapping.Column} and/or
 	 * {@link org.hibernate.mapping.Formula} objects.
 	 */
 	public static void addColumnsOrFormulas(Element element, Iterator columnIterator) {
 		while ( columnIterator.hasNext() ) {
 			final Object o = columnIterator.next();
 			if ( o instanceof Column ) {
 				addColumn( element, (Column) o );
 			}
 			else if ( o instanceof Formula ) {
 				addFormula( element, (Formula) o );
 			}
 		}
 	}
 
 	/**
 	 * An iterator over column names.
 	 */
 	public static abstract class ColumnNameIterator implements Iterator<String> {
 	}
 
 	public static ColumnNameIterator getColumnNameIterator(final Iterator<Selectable> selectableIterator) {
 		return new ColumnNameIterator() {
 			public boolean hasNext() {
 				return selectableIterator.hasNext();
 			}
 
 			public String next() {
 				final Selectable next = selectableIterator.next();
 				if ( next.isFormula() ) {
 					throw new FormulaNotSupportedException();
 				}
 				return ((Column) next).getName();
 			}
 
 			public void remove() {
 				selectableIterator.remove();
 			}
 		};
 	}
 
 	public static ColumnNameIterator getColumnNameIterator(final JoinColumn[] joinColumns) {
 		return new ColumnNameIterator() {
 			int counter;
 
 			public boolean hasNext() {
 				return counter < joinColumns.length;
 			}
 
 			public String next() {
 				return joinColumns[counter++].name();
 			}
 
 			public void remove() {
 				throw new UnsupportedOperationException();
 			}
 		};
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/reader/AuditedPropertiesReader.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/reader/AuditedPropertiesReader.java
index 5b4c7f59ea..ba7fd9802c 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/reader/AuditedPropertiesReader.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/internal/metadata/reader/AuditedPropertiesReader.java
@@ -1,771 +1,771 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.configuration.internal.metadata.reader;
 
 import java.lang.annotation.Annotation;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.persistence.JoinColumn;
 import javax.persistence.MapKey;
 import javax.persistence.OneToMany;
 import javax.persistence.Version;
 
 import org.hibernate.MappingException;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.annotations.common.reflection.XClass;
 import org.hibernate.annotations.common.reflection.XProperty;
 import org.hibernate.cfg.AccessType;
 import org.hibernate.envers.AuditJoinTable;
 import org.hibernate.envers.AuditMappedBy;
 import org.hibernate.envers.AuditOverride;
 import org.hibernate.envers.AuditOverrides;
 import org.hibernate.envers.Audited;
 import org.hibernate.envers.ModificationStore;
 import org.hibernate.envers.NotAudited;
 import org.hibernate.envers.RelationTargetAuditMode;
 import org.hibernate.envers.configuration.internal.GlobalConfiguration;
 import org.hibernate.envers.configuration.internal.metadata.MetadataTools;
 import org.hibernate.envers.internal.tools.MappingTools;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.envers.internal.tools.StringTools;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Value;
 
 import static org.hibernate.envers.internal.tools.Tools.newHashMap;
 import static org.hibernate.envers.internal.tools.Tools.newHashSet;
 
 /**
  * Reads persistent properties form a {@link PersistentPropertiesSource} and adds the ones that are audited to a
  * {@link AuditedPropertiesHolder}, filling all the auditing data.
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Erik-Berndt Scheper
  * @author Hern&aacut;n Chanfreau
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  * @author Lukasz Zuchowski (author at zuchos dot com)
  */
 public class AuditedPropertiesReader {
 	protected final ModificationStore defaultStore;
 	private final PersistentPropertiesSource persistentPropertiesSource;
 	private final AuditedPropertiesHolder auditedPropertiesHolder;
 	private final GlobalConfiguration globalCfg;
 	private final ReflectionManager reflectionManager;
 	private final String propertyNamePrefix;
 
 	private final Set<String> propertyAccessedPersistentProperties;
 	private final Set<String> fieldAccessedPersistentProperties;
 	// Mapping class field to corresponding <properties> element.
 	private final Map<String, String> propertiesGroupMapping;
 
 	private final Set<XProperty> overriddenAuditedProperties;
 	private final Set<XProperty> overriddenNotAuditedProperties;
 
 	private final Set<XClass> overriddenAuditedClasses;
 	private final Set<XClass> overriddenNotAuditedClasses;
 
 	public AuditedPropertiesReader(
 			ModificationStore defaultStore,
 			PersistentPropertiesSource persistentPropertiesSource,
 			AuditedPropertiesHolder auditedPropertiesHolder,
 			GlobalConfiguration globalCfg,
 			ReflectionManager reflectionManager,
 			String propertyNamePrefix) {
 		this.defaultStore = defaultStore;
 		this.persistentPropertiesSource = persistentPropertiesSource;
 		this.auditedPropertiesHolder = auditedPropertiesHolder;
 		this.globalCfg = globalCfg;
 		this.reflectionManager = reflectionManager;
 		this.propertyNamePrefix = propertyNamePrefix;
 
 		propertyAccessedPersistentProperties = newHashSet();
 		fieldAccessedPersistentProperties = newHashSet();
 		propertiesGroupMapping = newHashMap();
 
 		overriddenAuditedProperties = newHashSet();
 		overriddenNotAuditedProperties = newHashSet();
 
 		overriddenAuditedClasses = newHashSet();
 		overriddenNotAuditedClasses = newHashSet();
 	}
 
 	public void read() {
 		// First reading the access types for the persistent properties.
 		readPersistentPropertiesAccess();
 
 		if ( persistentPropertiesSource instanceof DynamicComponentSource ) {
 			addPropertiesFromDynamicComponent( (DynamicComponentSource) persistentPropertiesSource );
 		}
 		else {
 			// Retrieve classes and properties that are explicitly marked for auditing process by any superclass
 			// of currently mapped entity or itself.
 			final XClass clazz = persistentPropertiesSource.getXClass();
 			readAuditOverrides( clazz );
 
 			// Adding all properties from the given class.
 			addPropertiesFromClass( clazz );
 		}
 	}
 
 	/**
 	 * Recursively constructs sets of audited and not audited properties and classes which behavior has been overridden
 	 * using {@link AuditOverride} annotation.
 	 *
 	 * @param clazz Class that is being processed. Currently mapped entity shall be passed during first invocation.
 	 */
 	private void readAuditOverrides(XClass clazz) {
 		/* TODO: Code to remove with @Audited.auditParents - start. */
 		final Audited allClassAudited = clazz.getAnnotation( Audited.class );
 		if ( allClassAudited != null && allClassAudited.auditParents().length > 0 ) {
 			for ( Class c : allClassAudited.auditParents() ) {
 				final XClass parentClass = reflectionManager.toXClass( c );
 				checkSuperclass( clazz, parentClass );
 				if ( !overriddenNotAuditedClasses.contains( parentClass ) ) {
 					// If the class has not been marked as not audited by the subclass.
 					overriddenAuditedClasses.add( parentClass );
 				}
 			}
 		}
 		/* TODO: Code to remove with @Audited.auditParents - finish. */
 		final List<AuditOverride> auditOverrides = computeAuditOverrides( clazz );
 		for ( AuditOverride auditOverride : auditOverrides ) {
 			if ( auditOverride.forClass() != void.class ) {
 				final XClass overrideClass = reflectionManager.toXClass( auditOverride.forClass() );
 				checkSuperclass( clazz, overrideClass );
 				final String propertyName = auditOverride.name();
 				if ( !StringTools.isEmpty( propertyName ) ) {
 					// Override @Audited annotation on property level.
 					final XProperty property = getProperty( overrideClass, propertyName );
 					if ( auditOverride.isAudited() ) {
 						if ( !overriddenNotAuditedProperties.contains( property ) ) {
 							// If the property has not been marked as not audited by the subclass.
 							overriddenAuditedProperties.add( property );
 						}
 					}
 					else {
 						if ( !overriddenAuditedProperties.contains( property ) ) {
 							// If the property has not been marked as audited by the subclass.
 							overriddenNotAuditedProperties.add( property );
 						}
 					}
 				}
 				else {
 					// Override @Audited annotation on class level.
 					if ( auditOverride.isAudited() ) {
 						if ( !overriddenNotAuditedClasses.contains( overrideClass ) ) {
 							// If the class has not been marked as not audited by the subclass.
 							overriddenAuditedClasses.add( overrideClass );
 						}
 					}
 					else {
 						if ( !overriddenAuditedClasses.contains( overrideClass ) ) {
 							// If the class has not been marked as audited by the subclass.
 							overriddenNotAuditedClasses.add( overrideClass );
 						}
 					}
 				}
 			}
 		}
 		final XClass superclass = clazz.getSuperclass();
 		if ( !clazz.isInterface() && !Object.class.getName().equals( superclass.getName() ) ) {
 			readAuditOverrides( superclass );
 		}
 	}
 
 	/**
 	 * @param clazz Source class.
 	 *
 	 * @return List of @AuditOverride annotations applied at class level.
 	 */
 	private List<AuditOverride> computeAuditOverrides(XClass clazz) {
 		final AuditOverrides auditOverrides = clazz.getAnnotation( AuditOverrides.class );
 		final AuditOverride auditOverride = clazz.getAnnotation( AuditOverride.class );
 		if ( auditOverrides == null && auditOverride != null ) {
 			return Arrays.asList( auditOverride );
 		}
 		else if ( auditOverrides != null && auditOverride == null ) {
 			return Arrays.asList( auditOverrides.value() );
 		}
 		else if ( auditOverrides != null && auditOverride != null ) {
 			throw new MappingException(
 					"@AuditOverrides annotation should encapsulate all @AuditOverride declarations. " +
 							"Please revise Envers annotations applied to class " + clazz.getName() + "."
 			);
 		}
 		return Collections.emptyList();
 	}
 
 	/**
 	 * Checks whether one class is assignable from another. If not {@link MappingException} is thrown.
 	 *
 	 * @param child Subclass.
 	 * @param parent Superclass.
 	 */
 	private void checkSuperclass(XClass child, XClass parent) {
 		if ( !parent.isAssignableFrom( child ) ) {
 			throw new MappingException(
 					"Class " + parent.getName() + " is not assignable from " + child.getName() + ". " +
 							"Please revise Envers annotations applied to " + child.getName() + " type."
 			);
 		}
 	}
 
 	/**
 	 * Checks whether class contains property with a given name. If not {@link MappingException} is thrown.
 	 *
 	 * @param clazz Class.
 	 * @param propertyName Property name.
 	 *
 	 * @return Property object.
 	 */
 	private XProperty getProperty(XClass clazz, String propertyName) {
 		final XProperty property = ReflectionTools.getProperty( clazz, propertyName );
 		if ( property == null ) {
 			throw new MappingException(
 					"Property '" + propertyName + "' not found in class " + clazz.getName() + ". " +
 							"Please revise Envers annotations applied to class " + persistentPropertiesSource.getXClass() + "."
 			);
 		}
 		return property;
 	}
 
 	private void readPersistentPropertiesAccess() {
 		final Iterator<Property> propertyIter = persistentPropertiesSource.getPropertyIterator();
 		while ( propertyIter.hasNext() ) {
 			final Property property = propertyIter.next();
 			addPersistentProperty( property );
-			if ( "embedded".equals( property.getPropertyAccessorName() ) && property.getName()
-					.equals( property.getNodeName() ) ) {
+			if ( "embedded".equals( property.getPropertyAccessorName() )
+					&& property.getName().equals( property.getNodeName() ) ) {
 				// If property name equals node name and embedded accessor type is used, processing component
 				// has been defined with <properties> tag. See HHH-6636 JIRA issue.
 				createPropertiesGroupMapping( property );
 			}
 		}
 	}
 
 	private void addPersistentProperty(Property property) {
 		if ( "field".equals( property.getPropertyAccessorName() ) ) {
 			fieldAccessedPersistentProperties.add( property.getName() );
 		}
 		else {
 			propertyAccessedPersistentProperties.add( property.getName() );
 		}
 	}
 
 	@SuppressWarnings("unchecked")
 	private void createPropertiesGroupMapping(Property property) {
 		final Component component = (Component) property.getValue();
 		final Iterator<Property> componentProperties = component.getPropertyIterator();
 		while ( componentProperties.hasNext() ) {
 			final Property componentProperty = componentProperties.next();
 			propertiesGroupMapping.put( componentProperty.getName(), component.getNodeName() );
 		}
 	}
 
 	/**
 	 * @param clazz Class which properties are currently being added.
 	 *
 	 * @return {@link Audited} annotation of specified class. If processed type hasn't been explicitly marked, method
 	 *         checks whether given class exists in {@link AuditedPropertiesReader#overriddenAuditedClasses} collection.
 	 *         In case of success, {@link Audited} configuration of currently mapped entity is returned, otherwise
 	 *         {@code null}. If processed type exists in {@link AuditedPropertiesReader#overriddenNotAuditedClasses}
 	 *         collection, the result is also {@code null}.
 	 */
 	private Audited computeAuditConfiguration(XClass clazz) {
 		Audited allClassAudited = clazz.getAnnotation( Audited.class );
 		// If processed class is not explicitly marked with @Audited annotation, check whether auditing is
 		// forced by any of its child entities configuration (@AuditedOverride.forClass).
 		if ( allClassAudited == null && overriddenAuditedClasses.contains( clazz ) ) {
 			// Declared audited parent copies @Audited.modStore and @Audited.targetAuditMode configuration from
 			// currently mapped entity.
 			allClassAudited = persistentPropertiesSource.getXClass().getAnnotation( Audited.class );
 			if ( allClassAudited == null ) {
 				// If parent class declares @Audited on the field/property level.
 				allClassAudited = DEFAULT_AUDITED;
 			}
 		}
 		else if ( allClassAudited != null && overriddenNotAuditedClasses.contains( clazz ) ) {
 			return null;
 		}
 		return allClassAudited;
 	}
 
 	private void addPropertiesFromDynamicComponent(DynamicComponentSource dynamicComponentSource) {
 		Audited audited = computeAuditConfiguration( dynamicComponentSource.getXClass() );
 		if ( !fieldAccessedPersistentProperties.isEmpty() ) {
 			throw new MappingException(
 					"Audited dynamic component cannot have properties with access=\"field\" for properties: " + fieldAccessedPersistentProperties + ". \n Change properties access=\"property\", to make it work)"
 			);
 		}
 		for ( String property : propertyAccessedPersistentProperties ) {
 			String accessType = AccessType.PROPERTY.getType();
 			if ( !auditedPropertiesHolder.contains( property ) ) {
 				final Value propertyValue = persistentPropertiesSource.getProperty( property ).getValue();
 				if ( propertyValue instanceof Component ) {
 					this.addFromComponentProperty(
 							new DynamicProperty( dynamicComponentSource, property ),
 							accessType,
 							(Component) propertyValue,
 							audited
 					);
 				}
 				else {
 					this.addFromNotComponentProperty(
 							new DynamicProperty( dynamicComponentSource, property ),
 							accessType,
 							audited
 					);
 				}
 			}
 		}
 	}
 
 	/**
 	 * Recursively adds all audited properties of entity class and its superclasses.
 	 *
 	 * @param clazz Currently processed class.
 	 */
 	private void addPropertiesFromClass(XClass clazz) {
 		final Audited allClassAudited = computeAuditConfiguration( clazz );
 
 		//look in the class
 		addFromProperties(
 				clazz.getDeclaredProperties( "field" ),
 				"field",
 				fieldAccessedPersistentProperties,
 				allClassAudited
 		);
 		addFromProperties(
 				clazz.getDeclaredProperties( "property" ),
 				"property",
 				propertyAccessedPersistentProperties,
 				allClassAudited
 		);
 
 		if ( allClassAudited != null || !auditedPropertiesHolder.isEmpty() ) {
 			final XClass superclazz = clazz.getSuperclass();
 			if ( !clazz.isInterface() && !"java.lang.Object".equals( superclazz.getName() ) ) {
 				addPropertiesFromClass( superclazz );
 			}
 		}
 	}
 
 	private void addFromProperties(
 			Iterable<XProperty> properties,
 			String accessType,
 			Set<String> persistentProperties,
 			Audited allClassAudited) {
 		for ( XProperty property : properties ) {
 			// If this is not a persistent property, with the same access type as currently checked,
 			// it's not audited as well.
 			// If the property was already defined by the subclass, is ignored by superclasses
 			if ( persistentProperties.contains( property.getName() )
 					&& !auditedPropertiesHolder.contains( property.getName() ) ) {
 				final Value propertyValue = persistentPropertiesSource.getProperty( property.getName() ).getValue();
 				if ( propertyValue instanceof Component ) {
 					this.addFromComponentProperty( property, accessType, (Component) propertyValue, allClassAudited );
 				}
 				else {
 					this.addFromNotComponentProperty( property, accessType, allClassAudited );
 				}
 			}
 			else if ( propertiesGroupMapping.containsKey( property.getName() ) ) {
 				// Retrieve embedded component name based on class field.
 				final String embeddedName = propertiesGroupMapping.get( property.getName() );
 				if ( !auditedPropertiesHolder.contains( embeddedName ) ) {
 					// Manage properties mapped within <properties> tag.
 					final Value propertyValue = persistentPropertiesSource.getProperty( embeddedName ).getValue();
 					this.addFromPropertiesGroup(
 							embeddedName,
 							property,
 							accessType,
 							(Component) propertyValue,
 							allClassAudited
 					);
 				}
 			}
 		}
 	}
 
 	private void addFromPropertiesGroup(
 			String embeddedName,
 			XProperty property,
 			String accessType,
 			Component propertyValue,
 			Audited allClassAudited) {
 		final ComponentAuditingData componentData = new ComponentAuditingData();
 		final boolean isAudited = fillPropertyData( property, componentData, accessType, allClassAudited );
 		if ( isAudited ) {
 			// EntityPersister.getPropertyNames() returns name of embedded component instead of class field.
 			componentData.setName( embeddedName );
 			// Marking component properties as placed directly in class (not inside another component).
 			componentData.setBeanName( null );
 
 			final PersistentPropertiesSource componentPropertiesSource = new ComponentPropertiesSource(
 					reflectionManager,
 					propertyValue
 			);
 			final AuditedPropertiesReader audPropReader = new AuditedPropertiesReader(
 					ModificationStore.FULL, componentPropertiesSource, componentData, globalCfg, reflectionManager,
 					propertyNamePrefix + MappingTools.createComponentPrefix( embeddedName )
 			);
 			audPropReader.read();
 
 			auditedPropertiesHolder.addPropertyAuditingData( embeddedName, componentData );
 		}
 	}
 
 	private void addFromComponentProperty(
 			XProperty property,
 			String accessType,
 			Component propertyValue,
 			Audited allClassAudited) {
 		final ComponentAuditingData componentData = new ComponentAuditingData();
 		final boolean isAudited = fillPropertyData( property, componentData, accessType, allClassAudited );
 
 		final PersistentPropertiesSource componentPropertiesSource;
 		if ( propertyValue.isDynamic() ) {
 			componentPropertiesSource = new DynamicComponentSource( reflectionManager, propertyValue, property );
 		}
 		else {
 			componentPropertiesSource = new ComponentPropertiesSource( reflectionManager, propertyValue );
 		}
 
 		final ComponentAuditedPropertiesReader audPropReader = new ComponentAuditedPropertiesReader(
 				ModificationStore.FULL,
 				componentPropertiesSource,
 				componentData,
 				globalCfg,
 				reflectionManager,
 				propertyNamePrefix + MappingTools.createComponentPrefix( property.getName() )
 		);
 		audPropReader.read();
 
 		if ( isAudited ) {
 			// Now we know that the property is audited
 			auditedPropertiesHolder.addPropertyAuditingData( property.getName(), componentData );
 		}
 	}
 
 	private void addFromNotComponentProperty(XProperty property, String accessType, Audited allClassAudited) {
 		final PropertyAuditingData propertyData = new PropertyAuditingData();
 		final boolean isAudited = fillPropertyData( property, propertyData, accessType, allClassAudited );
 
 		if ( isAudited ) {
 			// Now we know that the property is audited
 			auditedPropertiesHolder.addPropertyAuditingData( property.getName(), propertyData );
 		}
 	}
 
 
 	/**
 	 * Checks if a property is audited and if yes, fills all of its data.
 	 *
 	 * @param property Property to check.
 	 * @param propertyData Property data, on which to set this property's modification store.
 	 * @param accessType Access type for the property.
 	 *
 	 * @return False if this property is not audited.
 	 */
 	private boolean fillPropertyData(
 			XProperty property,
 			PropertyAuditingData propertyData,
 			String accessType,
 			Audited allClassAudited) {
 
 		// check if a property is declared as not audited to exclude it
 		// useful if a class is audited but some properties should be excluded
 		final NotAudited unVer = property.getAnnotation( NotAudited.class );
 		if ( ( unVer != null
 				&& !overriddenAuditedProperties.contains( property ) )
 				|| overriddenNotAuditedProperties.contains( property ) ) {
 			return false;
 		}
 		else {
 			// if the optimistic locking field has to be unversioned and the current property
 			// is the optimistic locking field, don't audit it
 			if ( globalCfg.isDoNotAuditOptimisticLockingField() ) {
 				final Version jpaVer = property.getAnnotation( Version.class );
 				if ( jpaVer != null ) {
 					return false;
 				}
 			}
 		}
 
 		final String propertyName = propertyNamePrefix + property.getName();
 		if ( !this.checkAudited( property, propertyData,propertyName, allClassAudited, globalCfg.getModifiedFlagSuffix() ) ) {
 			return false;
 		}
 
 		propertyData.setName( propertyName );
 		propertyData.setBeanName( property.getName() );
 		propertyData.setAccessType( accessType );
 
 		addPropertyJoinTables( property, propertyData );
 		addPropertyAuditingOverrides( property, propertyData );
 		if ( !processPropertyAuditingOverrides( property, propertyData ) ) {
 			// not audited due to AuditOverride annotation
 			return false;
 		}
 		addPropertyMapKey( property, propertyData );
 		setPropertyAuditMappedBy( property, propertyData );
 		setPropertyRelationMappedBy( property, propertyData );
 
 		return true;
 	}
 
 
 	protected boolean checkAudited(
 			XProperty property,
 			PropertyAuditingData propertyData, String propertyName,
 			Audited allClassAudited, String modifiedFlagSuffix) {
 		// Checking if this property is explicitly audited or if all properties are.
 		Audited aud = ( property.isAnnotationPresent( Audited.class ) )
 				? property.getAnnotation( Audited.class )
 				: allClassAudited;
 		if ( aud == null
 				&& overriddenAuditedProperties.contains( property )
 				&& !overriddenNotAuditedProperties.contains( property ) ) {
 			// Assigning @Audited defaults. If anyone needs to customize those values in the future,
 			// appropriate fields shall be added to @AuditOverride annotation.
 			aud = DEFAULT_AUDITED;
 		}
 		if ( aud != null ) {
 			propertyData.setStore( aud.modStore() );
 			propertyData.setRelationTargetAuditMode( aud.targetAuditMode() );
 			propertyData.setUsingModifiedFlag( checkUsingModifiedFlag( aud ) );
 			if(aud.modifiedColumnName() != null && !"".equals(aud.modifiedColumnName())) {
 				propertyData.setModifiedFlagName(aud.modifiedColumnName());
 			} else {
 				propertyData.setModifiedFlagName(
 						MetadataTools.getModifiedFlagPropertyName(propertyName, modifiedFlagSuffix)
 				);
 			}
 			return true;
 		}
 		else {
 			return false;
 		}
 	}
 
 	protected boolean checkUsingModifiedFlag(Audited aud) {
 		return globalCfg.hasSettingForUsingModifiedFlag() ?
 				globalCfg.isGlobalWithModifiedFlag() : aud.withModifiedFlag();
 	}
 
 	private void setPropertyRelationMappedBy(XProperty property, PropertyAuditingData propertyData) {
 		final OneToMany oneToMany = property.getAnnotation( OneToMany.class );
 		if ( oneToMany != null && !"".equals( oneToMany.mappedBy() ) ) {
 			propertyData.setRelationMappedBy( oneToMany.mappedBy() );
 		}
 	}
 
 	private void setPropertyAuditMappedBy(XProperty property, PropertyAuditingData propertyData) {
 		final AuditMappedBy auditMappedBy = property.getAnnotation( AuditMappedBy.class );
 		if ( auditMappedBy != null ) {
 			propertyData.setAuditMappedBy( auditMappedBy.mappedBy() );
 			if ( !"".equals( auditMappedBy.positionMappedBy() ) ) {
 				propertyData.setPositionMappedBy( auditMappedBy.positionMappedBy() );
 			}
 		}
 	}
 
 	private void addPropertyMapKey(XProperty property, PropertyAuditingData propertyData) {
 		final MapKey mapKey = property.getAnnotation( MapKey.class );
 		if ( mapKey != null ) {
 			propertyData.setMapKey( mapKey.name() );
 		}
 	}
 
 	private void addPropertyJoinTables(XProperty property, PropertyAuditingData propertyData) {
 		// first set the join table based on the AuditJoinTable annotation
 		final AuditJoinTable joinTable = property.getAnnotation( AuditJoinTable.class );
 		if ( joinTable != null ) {
 			propertyData.setJoinTable( joinTable );
 		}
 		else {
 			propertyData.setJoinTable( DEFAULT_AUDIT_JOIN_TABLE );
 		}
 	}
 
 	/**
 	 * Add the {@link AuditOverride} annotations.
 	 *
 	 * @param property the property being processed
 	 * @param propertyData the Envers auditing data for this property
 	 */
 	private void addPropertyAuditingOverrides(XProperty property, PropertyAuditingData propertyData) {
 		final AuditOverride annotationOverride = property.getAnnotation( AuditOverride.class );
 		if ( annotationOverride != null ) {
 			propertyData.addAuditingOverride( annotationOverride );
 		}
 		final AuditOverrides annotationOverrides = property.getAnnotation( AuditOverrides.class );
 		if ( annotationOverrides != null ) {
 			propertyData.addAuditingOverrides( annotationOverrides );
 		}
 	}
 
 	/**
 	 * Process the {@link AuditOverride} annotations for this property.
 	 *
 	 * @param property the property for which the {@link AuditOverride}
 	 * annotations are being processed
 	 * @param propertyData the Envers auditing data for this property
 	 *
 	 * @return {@code false} if isAudited() of the override annotation was set to
 	 */
 	private boolean processPropertyAuditingOverrides(XProperty property, PropertyAuditingData propertyData) {
 		// if this property is part of a component, process all override annotations
 		if ( this.auditedPropertiesHolder instanceof ComponentAuditingData ) {
 			final List<AuditOverride> overrides = ( (ComponentAuditingData) this.auditedPropertiesHolder ).getAuditingOverrides();
 			for ( AuditOverride override : overrides ) {
 				if ( property.getName().equals( override.name() ) ) {
 					// the override applies to this property
 					if ( !override.isAudited() ) {
 						return false;
 					}
 					else {
 						if ( override.auditJoinTable() != null ) {
 							propertyData.setJoinTable( override.auditJoinTable() );
 						}
 					}
 				}
 			}
 
 		}
 		return true;
 	}
 
 	private static final Audited DEFAULT_AUDITED = new Audited() {
 		@Override
 		public ModificationStore modStore() {
 			return ModificationStore.FULL;
 		}
 
 		@Override
 		public RelationTargetAuditMode targetAuditMode() {
 			return RelationTargetAuditMode.AUDITED;
 		}
 
 		@Override
 		public Class[] auditParents() {
 			return new Class[0];
 		}
 
 		@Override
 		public boolean withModifiedFlag() {
 			return false;
 		}
 
 		@Override
 		public String modifiedColumnName() {
 			return "";
 		}
 
 		@Override
 		public Class<? extends Annotation> annotationType() {
 			return this.getClass();
 		}
 	};
 
 	private static final AuditJoinTable DEFAULT_AUDIT_JOIN_TABLE = new AuditJoinTable() {
 		@Override
 		public String name() {
 			return "";
 		}
 
 		@Override
 		public String schema() {
 			return "";
 		}
 
 		@Override
 		public String catalog() {
 			return "";
 		}
 
 		@Override
 		public JoinColumn[] inverseJoinColumns() {
 			return new JoinColumn[0];
 		}
 
 		@Override
 		public Class<? extends Annotation> annotationType() {
 			return this.getClass();
 		}
 	};
 
 	public static class ComponentPropertiesSource implements PersistentPropertiesSource {
 		private final XClass xclass;
 		private final Component component;
 
 		protected ComponentPropertiesSource(XClass xClazz, Component component) {
 			this.xclass = xClazz;
 			this.component = component;
 		}
 
 		public ComponentPropertiesSource(ReflectionManager reflectionManager, Component component) {
 			try {
 				this.xclass = reflectionManager.classForName( component.getComponentClassName(), this.getClass() );
 			}
 			catch ( ClassNotFoundException e ) {
 				throw new MappingException( e );
 			}
 
 			this.component = component;
 		}
 
 		@Override
 		@SuppressWarnings({ "unchecked" })
 		public Iterator<Property> getPropertyIterator() {
 			return component.getPropertyIterator();
 		}
 
 		@Override
 		public Property getProperty(String propertyName) {
 			return component.getProperty( propertyName );
 		}
 
 		@Override
 		public XClass getXClass() {
 			return xclass;
 		}
 	}
 
 	public static class DynamicComponentSource extends ComponentPropertiesSource {
 
 		private XProperty baseProperty;
 
 		public DynamicComponentSource(ReflectionManager reflectionManager, Component component, XProperty baseProperty) {
 			super( reflectionManager.toXClass( Map.class ), component );
 			this.baseProperty = baseProperty;
 		}
 	}
 
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/spi/AuditConfiguration.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/spi/AuditConfiguration.java
index 1c2024b401..b6ccaed6b0 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/spi/AuditConfiguration.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/spi/AuditConfiguration.java
@@ -1,200 +1,189 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.configuration.spi;
 
-import java.util.HashSet;
-import java.util.Map;
 import java.util.Properties;
-import java.util.WeakHashMap;
 
 import org.hibernate.MappingException;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
-import org.hibernate.cfg.Configuration;
+import org.hibernate.boot.spi.MetadataImplementor;
+import org.hibernate.engine.config.spi.ConfigurationService;
 import org.hibernate.envers.configuration.internal.AuditEntitiesConfiguration;
 import org.hibernate.envers.configuration.internal.EntitiesConfigurator;
 import org.hibernate.envers.configuration.internal.GlobalConfiguration;
+import org.hibernate.envers.configuration.internal.MappingCollector;
 import org.hibernate.envers.configuration.internal.RevisionInfoConfiguration;
 import org.hibernate.envers.configuration.internal.RevisionInfoConfigurationResult;
 import org.hibernate.envers.internal.entities.EntitiesConfigurations;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.revisioninfo.ModifiedEntityNamesReader;
 import org.hibernate.envers.internal.revisioninfo.RevisionInfoNumberReader;
 import org.hibernate.envers.internal.revisioninfo.RevisionInfoQueryCreator;
 import org.hibernate.envers.internal.synchronization.AuditProcessManager;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.envers.strategy.AuditStrategy;
 import org.hibernate.envers.strategy.ValidityAuditStrategy;
-import org.hibernate.internal.util.ClassLoaderHelper;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.property.Getter;
+import org.hibernate.service.ServiceRegistry;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Stephanie Pau at Markit Group Plc
+ * @author Steve Ebersole
  */
 public class AuditConfiguration {
+	private final ServiceRegistry serviceRegistry;
+
 	private final GlobalConfiguration globalCfg;
 	private final AuditEntitiesConfiguration auditEntCfg;
 	private final AuditProcessManager auditProcessManager;
 	private final AuditStrategy auditStrategy;
 	private final EntitiesConfigurations entCfg;
 	private final RevisionInfoQueryCreator revisionInfoQueryCreator;
 	private final RevisionInfoNumberReader revisionInfoNumberReader;
 	private final ModifiedEntityNamesReader modifiedEntityNamesReader;
-	private ClassLoaderService classLoaderService;
+
+	public AuditConfiguration(MetadataImplementor metadata, MappingCollector mappingCollector) {
+		this.serviceRegistry = metadata.getMetadataBuildingOptions().getServiceRegistry();
+
+		final ConfigurationService cfgService = serviceRegistry.getService( ConfigurationService.class );
+		final Properties properties = new Properties();
+		properties.putAll( cfgService.getSettings() );
+
+		final ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
+
+		this.globalCfg = new GlobalConfiguration( properties, classLoaderService );
+
+		final ReflectionManager reflectionManager = metadata.getMetadataBuildingOptions().getReflectionManager();
+		final RevisionInfoConfiguration revInfoCfg = new RevisionInfoConfiguration( globalCfg );
+		final RevisionInfoConfigurationResult revInfoCfgResult = revInfoCfg.configure( metadata, reflectionManager );
+
+		this.auditEntCfg = new AuditEntitiesConfiguration( properties, revInfoCfgResult.getRevisionInfoEntityName() );
+		this.auditProcessManager = new AuditProcessManager( revInfoCfgResult.getRevisionInfoGenerator() );
+		this.revisionInfoQueryCreator = revInfoCfgResult.getRevisionInfoQueryCreator();
+		this.revisionInfoNumberReader = revInfoCfgResult.getRevisionInfoNumberReader();
+		this.modifiedEntityNamesReader = revInfoCfgResult.getModifiedEntityNamesReader();
+		this.auditStrategy = initializeAuditStrategy(
+				auditEntCfg.getAuditStrategyName(),
+				revInfoCfgResult.getRevisionInfoClass(),
+				revInfoCfgResult.getRevisionInfoTimestampData(),
+				classLoaderService
+		);
+		this.entCfg = new EntitiesConfigurator().configure(
+				metadata,
+				serviceRegistry,
+				reflectionManager,
+				mappingCollector,
+				globalCfg,
+				auditEntCfg,
+				auditStrategy,
+				revInfoCfgResult.getRevisionInfoXmlMapping(),
+				revInfoCfgResult.getRevisionInfoRelationMapping()
+		);
+
+	}
+
 
 	public AuditEntitiesConfiguration getAuditEntCfg() {
 		return auditEntCfg;
 	}
 
 	public AuditProcessManager getSyncManager() {
 		return auditProcessManager;
 	}
 
 	public GlobalConfiguration getGlobalCfg() {
 		return globalCfg;
 	}
 
 	public EntitiesConfigurations getEntCfg() {
 		return entCfg;
 	}
 
 	public RevisionInfoQueryCreator getRevisionInfoQueryCreator() {
 		return revisionInfoQueryCreator;
 	}
 
 	public RevisionInfoNumberReader getRevisionInfoNumberReader() {
 		return revisionInfoNumberReader;
 	}
 
 	public ModifiedEntityNamesReader getModifiedEntityNamesReader() {
 		return modifiedEntityNamesReader;
 	}
 
 	public AuditStrategy getAuditStrategy() {
 		return auditStrategy;
 	}
 
-	public ClassLoaderService getClassLoaderService() {
-		return classLoaderService;
-	}
-
-	public AuditConfiguration(Configuration cfg) {
-		this( cfg, null );
-	}
-
-	public AuditConfiguration(Configuration cfg, ClassLoaderService classLoaderService) {
-		// TODO: Temporarily allow Envers to continuing using
-		// hibernate-commons-annotations' for reflection and class loading.
-		final ClassLoader tccl = Thread.currentThread().getContextClassLoader();
-		Thread.currentThread().setContextClassLoader( ClassLoaderHelper.getContextClassLoader() );
-
-		final Properties properties = cfg.getProperties();
-
-		final ReflectionManager reflectionManager = cfg.getReflectionManager();
-		this.globalCfg = new GlobalConfiguration( properties, classLoaderService );
-		final RevisionInfoConfiguration revInfoCfg = new RevisionInfoConfiguration( globalCfg );
-		final RevisionInfoConfigurationResult revInfoCfgResult = revInfoCfg.configure( cfg, reflectionManager );
-		this.auditEntCfg = new AuditEntitiesConfiguration( properties, revInfoCfgResult.getRevisionInfoEntityName() );
-		this.auditProcessManager = new AuditProcessManager( revInfoCfgResult.getRevisionInfoGenerator() );
-		this.revisionInfoQueryCreator = revInfoCfgResult.getRevisionInfoQueryCreator();
-		this.revisionInfoNumberReader = revInfoCfgResult.getRevisionInfoNumberReader();
-		this.modifiedEntityNamesReader = revInfoCfgResult.getModifiedEntityNamesReader();
-		this.classLoaderService = classLoaderService;
-		this.auditStrategy = initializeAuditStrategy(
-				revInfoCfgResult.getRevisionInfoClass(),
-				revInfoCfgResult.getRevisionInfoTimestampData()
-		);
-		this.entCfg = new EntitiesConfigurator().configure(
-				cfg, reflectionManager, globalCfg, auditEntCfg, auditStrategy, classLoaderService,
-				revInfoCfgResult.getRevisionInfoXmlMapping(), revInfoCfgResult.getRevisionInfoRelationMapping()
-		);
-
-		Thread.currentThread().setContextClassLoader( tccl );
-	}
-
-	private AuditStrategy initializeAuditStrategy(Class<?> revisionInfoClass, PropertyData revisionInfoTimestampData) {
+	private static AuditStrategy initializeAuditStrategy(
+			String auditStrategyName,
+			Class<?> revisionInfoClass,
+			PropertyData revisionInfoTimestampData,
+			ClassLoaderService classLoaderService) {
 		AuditStrategy strategy;
 
 		try {
-			Class<?> auditStrategyClass = null;
-			try {
-				auditStrategyClass = this.getClass().getClassLoader().loadClass( auditEntCfg.getAuditStrategyName() );
-			}
-			catch (Exception e) {
-				auditStrategyClass = ReflectionTools.loadClass(
-						auditEntCfg.getAuditStrategyName(),
-						classLoaderService
-				);
-			}
+			Class<?> auditStrategyClass = loadClass( auditStrategyName, classLoaderService );
 			strategy = (AuditStrategy) ReflectHelper.getDefaultConstructor( auditStrategyClass ).newInstance();
 		}
 		catch (Exception e) {
 			throw new MappingException(
-					String.format( "Unable to create AuditStrategy[%s] instance.", auditEntCfg.getAuditStrategyName() ),
+					String.format( "Unable to create AuditStrategy [%s] instance.", auditStrategyName ),
 					e
 			);
 		}
 
 		if ( strategy instanceof ValidityAuditStrategy ) {
 			// further initialization required
 			final Getter revisionTimestampGetter = ReflectionTools.getGetter( revisionInfoClass, revisionInfoTimestampData );
 			( (ValidityAuditStrategy) strategy ).setRevisionTimestampGetter( revisionTimestampGetter );
 		}
 
 		return strategy;
 	}
 
-	private static final Map<Configuration, AuditConfiguration> CFGS = new WeakHashMap<Configuration, AuditConfiguration>();
-
-	public synchronized static AuditConfiguration getFor(Configuration cfg) {
-		return getFor( cfg, null );
-	}
-
-	public synchronized static AuditConfiguration getFor(Configuration cfg, ClassLoaderService classLoaderService) {
-		AuditConfiguration verCfg = CFGS.get( cfg );
-
-		if ( verCfg == null ) {
-			verCfg = new AuditConfiguration( cfg, classLoaderService );
-			CFGS.put( cfg, verCfg );
-
-			cfg.buildMappings();
+	/**
+	 * Load a class by name, preferring our ClassLoader and then the ClassLoaderService.
+	 *
+	 * @param auditStrategyName The name of the class to load
+	 * @param classLoaderService The ClassLoaderService
+	 *
+	 * @return The loaded class.
+	 */
+	private static Class<?> loadClass(String auditStrategyName, ClassLoaderService classLoaderService) {
+		try {
+			return AuditConfiguration.class.getClassLoader().loadClass( auditStrategyName );
+		}
+		catch (Exception e) {
+			return ReflectionTools.loadClass( auditStrategyName, classLoaderService );
 		}
-
-		return verCfg;
 	}
 
 	public void destroy() {
-		synchronized (AuditConfiguration.class) {
-			for ( Map.Entry<Configuration, AuditConfiguration> c : new HashSet<Map.Entry<Configuration, AuditConfiguration>>(
-					CFGS.entrySet() ) ) {
-				if ( c.getValue() == this ) { // this is nasty cleanup fix, whole static CFGS should be reworked
-					CFGS.remove( c.getKey() );
-				}
-			}
-		}
-		classLoaderService = null;
+		// Anything we need to release in here?
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/BaseEnversCollectionEventListener.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/BaseEnversCollectionEventListener.java
index ab7a00547a..28925c144c 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/BaseEnversCollectionEventListener.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/BaseEnversCollectionEventListener.java
@@ -1,287 +1,287 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event.spi;
 
 import java.io.Serializable;
 import java.util.List;
 import java.util.Set;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.CollectionEntry;
 import org.hibernate.envers.RevisionType;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.EntityConfiguration;
 import org.hibernate.envers.internal.entities.RelationDescription;
 import org.hibernate.envers.internal.entities.mapper.PersistentCollectionChangeData;
 import org.hibernate.envers.internal.entities.mapper.id.IdMapper;
 import org.hibernate.envers.internal.synchronization.AuditProcess;
 import org.hibernate.envers.internal.synchronization.work.AuditWorkUnit;
 import org.hibernate.envers.internal.synchronization.work.CollectionChangeWorkUnit;
 import org.hibernate.envers.internal.synchronization.work.FakeBidirectionalRelationWorkUnit;
 import org.hibernate.envers.internal.synchronization.work.PersistentCollectionChangeWorkUnit;
 import org.hibernate.event.spi.AbstractCollectionEvent;
 import org.hibernate.persister.collection.AbstractCollectionPersister;
 
 /**
  * Base class for Envers' collection event related listeners
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  * @author Steve Ebersole
  * @author Michal Skowronek (mskowr at o2 dot pl)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public abstract class BaseEnversCollectionEventListener extends BaseEnversEventListener {
-	protected BaseEnversCollectionEventListener(AuditConfiguration enversConfiguration) {
-		super( enversConfiguration );
+	protected BaseEnversCollectionEventListener(EnversService enversService) {
+		super( enversService );
 	}
 
 	protected final CollectionEntry getCollectionEntry(AbstractCollectionEvent event) {
 		return event.getSession().getPersistenceContext().getCollectionEntry( event.getCollection() );
 	}
 
 	protected final void onCollectionAction(
 			AbstractCollectionEvent event,
 			PersistentCollection newColl,
 			Serializable oldColl,
 			CollectionEntry collectionEntry) {
 		if ( shouldGenerateRevision( event ) ) {
 			checkIfTransactionInProgress( event.getSession() );
 
-			final AuditProcess auditProcess = getAuditConfiguration().getSyncManager().get( event.getSession() );
+			final AuditProcess auditProcess = getEnversService().getAuditProcessManager().get( event.getSession() );
 
 			final String entityName = event.getAffectedOwnerEntityName();
 			final String ownerEntityName = ((AbstractCollectionPersister) collectionEntry.getLoadedPersister()).getOwnerEntityName();
 			final String referencingPropertyName = collectionEntry.getRole().substring( ownerEntityName.length() + 1 );
 
 			// Checking if this is not a "fake" many-to-one bidirectional relation. The relation description may be
 			// null in case of collections of non-entities.
 			final RelationDescription rd = searchForRelationDescription( entityName, referencingPropertyName );
 			if ( rd != null && rd.getMappedByPropertyName() != null ) {
 				generateFakeBidirecationalRelationWorkUnits(
 						auditProcess,
 						newColl,
 						oldColl,
 						entityName,
 						referencingPropertyName,
 						event,
 						rd
 				);
 			}
 			else {
 				final PersistentCollectionChangeWorkUnit workUnit = new PersistentCollectionChangeWorkUnit(
 						event.getSession(),
 						entityName,
-						getAuditConfiguration(),
+						getEnversService(),
 						newColl,
 						collectionEntry,
 						oldColl,
 						event.getAffectedOwnerIdOrNull(),
 						referencingPropertyName
 				);
 				auditProcess.addWorkUnit( workUnit );
 
 				if ( workUnit.containsWork() ) {
 					// There are some changes: a revision needs also be generated for the collection owner
 					auditProcess.addWorkUnit(
 							new CollectionChangeWorkUnit(
 									event.getSession(),
 									event.getAffectedOwnerEntityName(),
 									referencingPropertyName,
-									getAuditConfiguration(),
+									getEnversService(),
 									event.getAffectedOwnerIdOrNull(),
 									event.getAffectedOwnerOrNull()
 							)
 					);
 
 					generateBidirectionalCollectionChangeWorkUnits( auditProcess, event, workUnit, rd );
 				}
 			}
 		}
 	}
 
 	/**
 	 * Forces persistent collection initialization.
 	 *
 	 * @param event Collection event.
 	 *
 	 * @return Stored snapshot.
 	 */
 	protected Serializable initializeCollection(AbstractCollectionEvent event) {
 		event.getCollection().forceInitialization();
 		return event.getCollection().getStoredSnapshot();
 	}
 
 	/**
 	 * Checks whether modification of not-owned relation field triggers new revision and owner entity is versioned.
 	 *
 	 * @param event Collection event.
 	 *
 	 * @return {@code true} if revision based on given event should be generated, {@code false} otherwise.
 	 */
 	protected boolean shouldGenerateRevision(AbstractCollectionEvent event) {
 		final String entityName = event.getAffectedOwnerEntityName();
-		return getAuditConfiguration().getGlobalCfg().isGenerateRevisionsForCollections()
-				&& getAuditConfiguration().getEntCfg().isVersioned( entityName );
+		return getEnversService().getGlobalConfiguration().isGenerateRevisionsForCollections()
+				&& getEnversService().getEntitiesConfigurations().isVersioned( entityName );
 	}
 
 	/**
 	 * Looks up a relation description corresponding to the given property in the given entity. If no description is
 	 * found in the given entity, the parent entity is checked (so that inherited relations work).
 	 *
 	 * @param entityName Name of the entity, in which to start looking.
 	 * @param referencingPropertyName The name of the property.
 	 *
 	 * @return A found relation description corresponding to the given entity or {@code null}, if no description can
 	 *         be found.
 	 */
 	private RelationDescription searchForRelationDescription(String entityName, String referencingPropertyName) {
-		final EntityConfiguration configuration = getAuditConfiguration().getEntCfg().get( entityName );
+		final EntityConfiguration configuration = getEnversService().getEntitiesConfigurations().get( entityName );
 		final RelationDescription rd = configuration.getRelationDescription( referencingPropertyName );
 		if ( rd == null && configuration.getParentEntityName() != null ) {
 			return searchForRelationDescription( configuration.getParentEntityName(), referencingPropertyName );
 		}
 
 		return rd;
 	}
 
 	private void generateFakeBidirecationalRelationWorkUnits(
 			AuditProcess auditProcess,
 			PersistentCollection newColl,
 			Serializable oldColl,
 			String collectionEntityName,
 			String referencingPropertyName,
 			AbstractCollectionEvent event,
 			RelationDescription rd) {
 		// First computing the relation changes
-		final List<PersistentCollectionChangeData> collectionChanges = getAuditConfiguration()
-				.getEntCfg()
+		final List<PersistentCollectionChangeData> collectionChanges = getEnversService()
+				.getEntitiesConfigurations()
 				.get( collectionEntityName )
 				.getPropertyMapper()
 				.mapCollectionChanges(
 						event.getSession(),
 						referencingPropertyName,
 						newColl,
 						oldColl,
 						event.getAffectedOwnerIdOrNull()
 				);
 
 		// Getting the id mapper for the related entity, as the work units generated will correspond to the related
 		// entities.
 		final String relatedEntityName = rd.getToEntityName();
-		final IdMapper relatedIdMapper = getAuditConfiguration().getEntCfg().get( relatedEntityName ).getIdMapper();
+		final IdMapper relatedIdMapper = getEnversService().getEntitiesConfigurations().get( relatedEntityName ).getIdMapper();
 
 		// For each collection change, generating the bidirectional work unit.
 		for ( PersistentCollectionChangeData changeData : collectionChanges ) {
 			final Object relatedObj = changeData.getChangedElement();
 			final Serializable relatedId = (Serializable) relatedIdMapper.mapToIdFromEntity( relatedObj );
 			final RevisionType revType = (RevisionType) changeData.getData().get(
-					getAuditConfiguration().getAuditEntCfg().getRevisionTypePropName()
+					getEnversService().getAuditEntitiesConfiguration().getRevisionTypePropName()
 			);
 
 			// This can be different from relatedEntityName, in case of inheritance (the real entity may be a subclass
 			// of relatedEntityName).
 			final String realRelatedEntityName = event.getSession().bestGuessEntityName( relatedObj );
 
 			// By default, the nested work unit is a collection change work unit.
 			final AuditWorkUnit nestedWorkUnit = new CollectionChangeWorkUnit(
 					event.getSession(),
 					realRelatedEntityName,
 					rd.getMappedByPropertyName(),
-					getAuditConfiguration(),
+					getEnversService(),
 					relatedId,
 					relatedObj
 			);
 
 			auditProcess.addWorkUnit(
 					new FakeBidirectionalRelationWorkUnit(
 							event.getSession(),
 							realRelatedEntityName,
-							getAuditConfiguration(),
+							getEnversService(),
 							relatedId,
 							referencingPropertyName,
 							event.getAffectedOwnerOrNull(),
 							rd,
 							revType,
 							changeData.getChangedElementIndex(),
 							nestedWorkUnit
 					)
 			);
 		}
 
 		// We also have to generate a collection change work unit for the owning entity.
 		auditProcess.addWorkUnit(
 				new CollectionChangeWorkUnit(
 						event.getSession(),
 						collectionEntityName,
 						referencingPropertyName,
-						getAuditConfiguration(),
+						getEnversService(),
 						event.getAffectedOwnerIdOrNull(),
 						event.getAffectedOwnerOrNull()
 				)
 		);
 	}
 
 	private void generateBidirectionalCollectionChangeWorkUnits(
 			AuditProcess auditProcess,
 			AbstractCollectionEvent event,
 			PersistentCollectionChangeWorkUnit workUnit,
 			RelationDescription rd) {
 		// Checking if this is enabled in configuration ...
-		if ( !getAuditConfiguration().getGlobalCfg().isGenerateRevisionsForCollections() ) {
+		if ( !getEnversService().getGlobalConfiguration().isGenerateRevisionsForCollections() ) {
 			return;
 		}
 
 		// Checking if this is not a bidirectional relation - then, a revision needs also be generated for
 		// the other side of the relation.
 		// relDesc can be null if this is a collection of simple values (not a relation).
 		if ( rd != null && rd.isBidirectional() ) {
 			final String relatedEntityName = rd.getToEntityName();
-			final IdMapper relatedIdMapper = getAuditConfiguration().getEntCfg().get( relatedEntityName ).getIdMapper();
+			final IdMapper relatedIdMapper = getEnversService().getEntitiesConfigurations().get( relatedEntityName ).getIdMapper();
 
-			final Set<String> toPropertyNames = getAuditConfiguration().getEntCfg().getToPropertyNames(
+			final Set<String> toPropertyNames = getEnversService().getEntitiesConfigurations().getToPropertyNames(
 					event.getAffectedOwnerEntityName(),
 					rd.getFromPropertyName(),
 					relatedEntityName
 			);
 			final String toPropertyName = toPropertyNames.iterator().next();
 
 			for ( PersistentCollectionChangeData changeData : workUnit.getCollectionChanges() ) {
 				final Object relatedObj = changeData.getChangedElement();
 				final Serializable relatedId = (Serializable) relatedIdMapper.mapToIdFromEntity( relatedObj );
 
 				auditProcess.addWorkUnit(
 						new CollectionChangeWorkUnit(
 								event.getSession(),
 								event.getSession().bestGuessEntityName( relatedObj ),
 								toPropertyName,
-								getAuditConfiguration(),
+								getEnversService(),
 								relatedId,
 								relatedObj
 						)
 				);
 			}
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/BaseEnversEventListener.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/BaseEnversEventListener.java
index f65fcef4a9..890ed80503 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/BaseEnversEventListener.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/BaseEnversEventListener.java
@@ -1,149 +1,152 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event.spi;
 
 import java.io.Serializable;
 import java.util.Set;
 
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.RelationDescription;
 import org.hibernate.envers.internal.entities.RelationType;
 import org.hibernate.envers.internal.entities.mapper.id.IdMapper;
 import org.hibernate.envers.internal.synchronization.AuditProcess;
 import org.hibernate.envers.internal.synchronization.work.CollectionChangeWorkUnit;
 import org.hibernate.envers.internal.tools.EntityTools;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.proxy.HibernateProxy;
 
 /**
  * Base class for all Envers event listeners
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  * @author Steve Ebersole
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public abstract class BaseEnversEventListener implements EnversListener {
-	private AuditConfiguration enversConfiguration;
+	private final EnversService enversService;
 
-	protected BaseEnversEventListener(AuditConfiguration enversConfiguration) {
-		this.enversConfiguration = enversConfiguration;
+	protected BaseEnversEventListener(EnversService enversService) {
+		this.enversService = enversService;
 	}
 
-	@Override
-	public AuditConfiguration getAuditConfiguration() {
-		return enversConfiguration;
+	protected EnversService getEnversService() {
+		return enversService;
 	}
 
 	protected final void generateBidirectionalCollectionChangeWorkUnits(
 			AuditProcess auditProcess,
 			EntityPersister entityPersister,
 			String entityName,
 			Object[] newState,
 			Object[] oldState,
 			SessionImplementor session) {
 		// Checking if this is enabled in configuration ...
-		if ( !enversConfiguration.getGlobalCfg().isGenerateRevisionsForCollections() ) {
+		if ( !enversService.getGlobalConfiguration().isGenerateRevisionsForCollections() ) {
 			return;
 		}
 
 		// Checks every property of the entity, if it is an "owned" to-one relation to another entity.
 		// If the value of that property changed, and the relation is bi-directional, a new revision
 		// for the related entity is generated.
 		final String[] propertyNames = entityPersister.getPropertyNames();
 
 		for ( int i = 0; i < propertyNames.length; i++ ) {
 			final String propertyName = propertyNames[i];
-			final RelationDescription relDesc = enversConfiguration.getEntCfg().getRelationDescription(
+			final RelationDescription relDesc = enversService.getEntitiesConfigurations().getRelationDescription(
 					entityName,
 					propertyName
 			);
 			if ( relDesc != null && relDesc.isBidirectional() && relDesc.getRelationType() == RelationType.TO_ONE &&
 					relDesc.isInsertable() ) {
 				// Checking for changes
 				final Object oldValue = oldState == null ? null : oldState[i];
 				final Object newValue = newState == null ? null : newState[i];
 
 				if ( !EntityTools.entitiesEqual( session, relDesc.getToEntityName(), oldValue, newValue ) ) {
 					// We have to generate changes both in the old collection (size decreses) and new collection
 					// (size increases).
 					if ( newValue != null ) {
 						addCollectionChangeWorkUnit( auditProcess, session, entityName, relDesc, newValue );
 					}
 
 					if ( oldValue != null ) {
 						addCollectionChangeWorkUnit( auditProcess, session, entityName, relDesc, oldValue );
 					}
 				}
 			}
 		}
 	}
 
 	private void addCollectionChangeWorkUnit(
 			AuditProcess auditProcess, SessionImplementor session,
 			String fromEntityName, RelationDescription relDesc, Object value) {
 		// relDesc.getToEntityName() doesn't always return the entity name of the value - in case
 		// of subclasses, this will be root class, no the actual class. So it can't be used here.
 		String toEntityName;
 		Serializable id;
 
 		if ( value instanceof HibernateProxy ) {
 			final HibernateProxy hibernateProxy = (HibernateProxy) value;
 			toEntityName = session.bestGuessEntityName( value );
 			id = hibernateProxy.getHibernateLazyInitializer().getIdentifier();
 			// We've got to initialize the object from the proxy to later read its state.
 			value = EntityTools.getTargetFromProxy( session.getFactory(), hibernateProxy );
 		}
 		else {
 			toEntityName = session.guessEntityName( value );
 
-			final IdMapper idMapper = enversConfiguration.getEntCfg().get( toEntityName ).getIdMapper();
+			final IdMapper idMapper = enversService.getEntitiesConfigurations().get( toEntityName ).getIdMapper();
 			id = (Serializable) idMapper.mapToIdFromEntity( value );
 		}
 
-		final Set<String> toPropertyNames = enversConfiguration.getEntCfg().getToPropertyNames(
+		final Set<String> toPropertyNames = enversService.getEntitiesConfigurations().getToPropertyNames(
 				fromEntityName,
 				relDesc.getFromPropertyName(),
 				toEntityName
 		);
 		final String toPropertyName = toPropertyNames.iterator().next();
 
 		auditProcess.addWorkUnit(
 				new CollectionChangeWorkUnit(
-						session, toEntityName,
-						toPropertyName, enversConfiguration, id, value
+						session,
+						toEntityName,
+						toPropertyName,
+						enversService,
+						id,
+						value
 				)
 		);
 	}
 
 	protected void checkIfTransactionInProgress(SessionImplementor session) {
 		if ( !session.isTransactionInProgress() ) {
 			// Historical data would not be flushed to audit tables if outside of active transaction
 			// (AuditProcess#doBeforeTransactionCompletion(SessionImplementor) not executed).
 			throw new AuditException( "Unable to create revision because of non-active transaction" );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversListener.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversListener.java
index cd8f36ef90..95ec768f38 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversListener.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversListener.java
@@ -1,40 +1,32 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event.spi;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
-
 /**
  * Marker interface for Envers listeners for duplication handling.
  *
  * @author Steve Ebersole
  */
 public interface EnversListener {
-	/**
-	 * Get the Envers AuditConfiguration
-	 *
-	 * @return The Envers AuditConfiguration
-	 */
-	public AuditConfiguration getAuditConfiguration();
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostCollectionRecreateEventListenerImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostCollectionRecreateEventListenerImpl.java
index 0a88a50a05..8ec95867c8 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostCollectionRecreateEventListenerImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostCollectionRecreateEventListenerImpl.java
@@ -1,53 +1,53 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event.spi;
 
 import org.hibernate.engine.spi.CollectionEntry;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.event.spi.PostCollectionRecreateEvent;
 import org.hibernate.event.spi.PostCollectionRecreateEventListener;
 
 /**
  * Envers-specific collection recreation event listener
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  * @author Steve Ebersole
  */
 public class EnversPostCollectionRecreateEventListenerImpl
 		extends BaseEnversCollectionEventListener
 		implements PostCollectionRecreateEventListener {
 
-	protected EnversPostCollectionRecreateEventListenerImpl(AuditConfiguration enversConfiguration) {
-		super( enversConfiguration );
+	public EnversPostCollectionRecreateEventListenerImpl(EnversService enversService) {
+		super( enversService );
 	}
 
 	@Override
 	public void onPostRecreateCollection(PostCollectionRecreateEvent event) {
 		final CollectionEntry collectionEntry = getCollectionEntry( event );
 		if ( !collectionEntry.getLoadedPersister().isInverse() ) {
 			onCollectionAction( event, event.getCollection(), null, collectionEntry );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostDeleteEventListenerImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostDeleteEventListenerImpl.java
index 79cacd10e3..ec18f5c6ff 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostDeleteEventListenerImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostDeleteEventListenerImpl.java
@@ -1,82 +1,82 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event.spi;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.synchronization.AuditProcess;
 import org.hibernate.envers.internal.synchronization.work.AuditWorkUnit;
 import org.hibernate.envers.internal.synchronization.work.DelWorkUnit;
 import org.hibernate.event.spi.PostDeleteEvent;
 import org.hibernate.event.spi.PostDeleteEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Envers-specific entity (post) deletion event listener
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  * @author Steve Ebersole
  */
 public class EnversPostDeleteEventListenerImpl extends BaseEnversEventListener implements PostDeleteEventListener {
-	protected EnversPostDeleteEventListenerImpl(AuditConfiguration enversConfiguration) {
-		super( enversConfiguration );
+	public EnversPostDeleteEventListenerImpl(EnversService enversService) {
+		super( enversService );
 	}
 
 	@Override
 	public void onPostDelete(PostDeleteEvent event) {
 		final String entityName = event.getPersister().getEntityName();
 
-		if ( getAuditConfiguration().getEntCfg().isVersioned( entityName ) ) {
+		if ( getEnversService().getEntitiesConfigurations().isVersioned( entityName ) ) {
 			checkIfTransactionInProgress( event.getSession() );
 
-			final AuditProcess auditProcess = getAuditConfiguration().getSyncManager().get( event.getSession() );
+			final AuditProcess auditProcess = getEnversService().getAuditProcessManager().get( event.getSession() );
 
 			final AuditWorkUnit workUnit = new DelWorkUnit(
 					event.getSession(),
 					event.getPersister().getEntityName(),
-					getAuditConfiguration(),
+					getEnversService(),
 					event.getId(),
 					event.getPersister(),
 					event.getDeletedState()
 			);
 			auditProcess.addWorkUnit( workUnit );
 
 			if ( workUnit.containsWork() ) {
 				generateBidirectionalCollectionChangeWorkUnits(
 						auditProcess,
 						event.getPersister(),
 						entityName,
 						null,
 						event.getDeletedState(),
 						event.getSession()
 				);
 			}
 		}
 	}
 
 	@Override
 	public boolean requiresPostCommitHanding(EntityPersister persister) {
-		return getAuditConfiguration().getEntCfg().isVersioned( persister.getEntityName() );
+		return getEnversService().getEntitiesConfigurations().isVersioned( persister.getEntityName() );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostInsertEventListenerImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostInsertEventListenerImpl.java
index db3c1d1853..b7f8b18b93 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostInsertEventListenerImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostInsertEventListenerImpl.java
@@ -1,82 +1,82 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event.spi;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.synchronization.AuditProcess;
 import org.hibernate.envers.internal.synchronization.work.AddWorkUnit;
 import org.hibernate.envers.internal.synchronization.work.AuditWorkUnit;
 import org.hibernate.event.spi.PostInsertEvent;
 import org.hibernate.event.spi.PostInsertEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Envers-specific entity (post) insertion event listener
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  * @author Steve Ebersole
  */
 public class EnversPostInsertEventListenerImpl extends BaseEnversEventListener implements PostInsertEventListener {
-	protected EnversPostInsertEventListenerImpl(AuditConfiguration enversConfiguration) {
-		super( enversConfiguration );
+	public EnversPostInsertEventListenerImpl(EnversService enversService) {
+		super( enversService );
 	}
 
 	@Override
 	public void onPostInsert(PostInsertEvent event) {
 		final String entityName = event.getPersister().getEntityName();
 
-		if ( getAuditConfiguration().getEntCfg().isVersioned( entityName ) ) {
+		if ( getEnversService().getEntitiesConfigurations().isVersioned( entityName ) ) {
 			checkIfTransactionInProgress( event.getSession() );
 
-			final AuditProcess auditProcess = getAuditConfiguration().getSyncManager().get( event.getSession() );
+			final AuditProcess auditProcess = getEnversService().getAuditProcessManager().get( event.getSession() );
 
 			final AuditWorkUnit workUnit = new AddWorkUnit(
 					event.getSession(),
 					event.getPersister().getEntityName(),
-					getAuditConfiguration(),
+					getEnversService(),
 					event.getId(),
 					event.getPersister(),
 					event.getState()
 			);
 			auditProcess.addWorkUnit( workUnit );
 
 			if ( workUnit.containsWork() ) {
 				generateBidirectionalCollectionChangeWorkUnits(
 						auditProcess,
 						event.getPersister(),
 						entityName,
 						event.getState(),
 						null,
 						event.getSession()
 				);
 			}
 		}
 	}
 
 	@Override
 	public boolean requiresPostCommitHanding(EntityPersister persister) {
-		return getAuditConfiguration().getEntCfg().isVersioned( persister.getEntityName() );
+		return getEnversService().getEntitiesConfigurations().isVersioned( persister.getEntityName() );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostUpdateEventListenerImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostUpdateEventListenerImpl.java
index 956bf01a38..33114b7639 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostUpdateEventListenerImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPostUpdateEventListenerImpl.java
@@ -1,98 +1,98 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event.spi;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.synchronization.AuditProcess;
 import org.hibernate.envers.internal.synchronization.work.AuditWorkUnit;
 import org.hibernate.envers.internal.synchronization.work.ModWorkUnit;
 import org.hibernate.event.spi.PostUpdateEvent;
 import org.hibernate.event.spi.PostUpdateEventListener;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Envers-specific entity (post) update event listener
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  * @author Steve Ebersole
  */
 public class EnversPostUpdateEventListenerImpl extends BaseEnversEventListener implements PostUpdateEventListener {
-	protected EnversPostUpdateEventListenerImpl(AuditConfiguration enversConfiguration) {
-		super( enversConfiguration );
+	public EnversPostUpdateEventListenerImpl(EnversService enversService) {
+		super( enversService );
 	}
 
 	@Override
 	public void onPostUpdate(PostUpdateEvent event) {
 		final String entityName = event.getPersister().getEntityName();
 
-		if ( getAuditConfiguration().getEntCfg().isVersioned( entityName ) ) {
+		if ( getEnversService().getEntitiesConfigurations().isVersioned( entityName ) ) {
 			checkIfTransactionInProgress( event.getSession() );
 
-			final AuditProcess auditProcess = getAuditConfiguration().getSyncManager().get( event.getSession() );
+			final AuditProcess auditProcess = getEnversService().getAuditProcessManager().get( event.getSession() );
 			final Object[] newDbState = postUpdateDBState( event );
 			final AuditWorkUnit workUnit = new ModWorkUnit(
 					event.getSession(),
 					event.getPersister().getEntityName(),
-					getAuditConfiguration(),
+					getEnversService(),
 					event.getId(),
 					event.getPersister(),
 					newDbState,
 					event.getOldState()
 			);
 			auditProcess.addWorkUnit( workUnit );
 
 			if ( workUnit.containsWork() ) {
 				generateBidirectionalCollectionChangeWorkUnits(
 						auditProcess,
 						event.getPersister(),
 						entityName,
 						newDbState,
 						event.getOldState(),
 						event.getSession()
 				);
 			}
 		}
 	}
 
 	private Object[] postUpdateDBState(PostUpdateEvent event) {
 		final Object[] newDbState = event.getState().clone();
 		if ( event.getOldState() != null ) {
 			final EntityPersister entityPersister = event.getPersister();
 			for ( int i = 0; i < entityPersister.getPropertyNames().length; ++i ) {
 				if ( !entityPersister.getPropertyUpdateability()[i] ) {
 					// Assuming that PostUpdateEvent#getOldState() returns database state of the record before modification.
 					// Otherwise, we would have to execute SQL query to be sure of @Column(updatable = false) column value.
 					newDbState[i] = event.getOldState()[i];
 				}
 			}
 		}
 		return newDbState;
 	}
 
 	@Override
 	public boolean requiresPostCommitHanding(EntityPersister persister) {
-		return getAuditConfiguration().getEntCfg().isVersioned( persister.getEntityName() );
+		return getEnversService().getEntitiesConfigurations().isVersioned( persister.getEntityName() );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPreCollectionRemoveEventListenerImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPreCollectionRemoveEventListenerImpl.java
index 61a3c1a5ca..e352efa8fe 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPreCollectionRemoveEventListenerImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPreCollectionRemoveEventListenerImpl.java
@@ -1,61 +1,61 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event.spi;
 
 import java.io.Serializable;
 
 import org.hibernate.engine.spi.CollectionEntry;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.event.spi.PreCollectionRemoveEvent;
 import org.hibernate.event.spi.PreCollectionRemoveEventListener;
 
 /**
  * Envers-specific collection removal event listener
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  * @author Steve Ebersole
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class EnversPreCollectionRemoveEventListenerImpl
 		extends BaseEnversCollectionEventListener
 		implements PreCollectionRemoveEventListener {
 
-	protected EnversPreCollectionRemoveEventListenerImpl(AuditConfiguration enversConfiguration) {
-		super( enversConfiguration );
+	public EnversPreCollectionRemoveEventListenerImpl(EnversService enversService) {
+		super( enversService );
 	}
 
 	@Override
 	public void onPreRemoveCollection(PreCollectionRemoveEvent event) {
 		final CollectionEntry collectionEntry = getCollectionEntry( event );
 		if ( collectionEntry != null && !collectionEntry.getLoadedPersister().isInverse() ) {
 			Serializable oldColl = collectionEntry.getSnapshot();
 			if ( !event.getCollection().wasInitialized() && shouldGenerateRevision( event ) ) {
 				// In case of uninitialized collection we need a fresh snapshot to properly calculate audit data.
 				oldColl = initializeCollection( event );
 			}
 			onCollectionAction( event, null, oldColl, collectionEntry );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPreCollectionUpdateEventListenerImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPreCollectionUpdateEventListenerImpl.java
index b416349ce6..daa5748d31 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPreCollectionUpdateEventListenerImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/spi/EnversPreCollectionUpdateEventListenerImpl.java
@@ -1,53 +1,53 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event.spi;
 
 import org.hibernate.engine.spi.CollectionEntry;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.event.spi.PreCollectionUpdateEvent;
 import org.hibernate.event.spi.PreCollectionUpdateEventListener;
 
 /**
  * Envers-specific collection update event listener
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  * @author Steve Ebersole
  */
 public class EnversPreCollectionUpdateEventListenerImpl
 		extends BaseEnversCollectionEventListener
 		implements PreCollectionUpdateEventListener {
 
-	protected EnversPreCollectionUpdateEventListenerImpl(AuditConfiguration enversConfiguration) {
-		super( enversConfiguration );
+	public EnversPreCollectionUpdateEventListenerImpl(EnversService enversService) {
+		super( enversService );
 	}
 
 	@Override
 	public void onPreUpdateCollection(PreCollectionUpdateEvent event) {
 		final CollectionEntry collectionEntry = getCollectionEntry( event );
 		if ( !collectionEntry.getLoadedPersister().isInverse() ) {
 			onCollectionAction( event, event.getCollection(), collectionEntry.getSnapshot(), collectionEntry );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/EnversMessageLogger.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/EnversMessageLogger.java
index 3f3a39936c..2540d9f36a 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/EnversMessageLogger.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/EnversMessageLogger.java
@@ -1,49 +1,48 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal;
 
 import org.hibernate.internal.CoreMessageLogger;
 
 import org.jboss.logging.annotations.LogMessage;
 import org.jboss.logging.annotations.Message;
 import org.jboss.logging.annotations.MessageLogger;
 
 import static org.jboss.logging.Logger.Level.WARN;
 
 /**
  * The jboss-logging {@link MessageLogger} for the hibernate-envers module.  It reserves message ids ranging from
  * 25001 to 30000 inclusively.
  * <p/>
  * New messages must be added after the last message defined to ensure message codes are unique.
  */
 @MessageLogger(projectCode = "HHH")
 public interface EnversMessageLogger extends CoreMessageLogger {
-
 	/**
 	 * Message indicating that user attempted to use the deprecated ValidTimeAuditStrategy
 	 */
 	@LogMessage(level = WARN)
 	@Message(value = "ValidTimeAuditStrategy is deprecated, please use ValidityAuditStrategy instead", id = 25001)
 	void validTimeAuditStrategyDeprecated();
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/EntityInstantiator.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/EntityInstantiator.java
index acac9babe8..be5a166cb4 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/EntityInstantiator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/EntityInstantiator.java
@@ -1,185 +1,191 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities;
 
 import java.io.Serializable;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.envers.RevisionType;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.mapper.id.IdMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.ToOneDelegateSessionImplementor;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.LazyInitializer;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hern&aacute;n Chanfreau
  */
 public class EntityInstantiator {
-	private final AuditConfiguration verCfg;
+	private final EnversService enversService;
 	private final AuditReaderImplementor versionsReader;
 
-	public EntityInstantiator(AuditConfiguration verCfg, AuditReaderImplementor versionsReader) {
-		this.verCfg = verCfg;
+	public EntityInstantiator(EnversService enversService, AuditReaderImplementor versionsReader) {
+		this.enversService = enversService;
 		this.versionsReader = versionsReader;
 	}
 
 	/**
 	 * Creates an entity instance based on an entry from the versions table.
 	 *
 	 * @param entityName Name of the entity, which instances should be read
 	 * @param versionsEntity An entry in the versions table, from which data should be mapped.
 	 * @param revision Revision at which this entity was read.
 	 *
 	 * @return An entity instance, with versioned properties set as in the versionsEntity map, and proxies
 	 *         created for collections.
 	 */
 	public Object createInstanceFromVersionsEntity(String entityName, Map versionsEntity, Number revision) {
 		if ( versionsEntity == null ) {
 			return null;
 		}
 
 		// The $type$ property holds the name of the (versions) entity
-		final String type = verCfg.getEntCfg().getEntityNameForVersionsEntityName( (String) versionsEntity.get( "$type$" ) );
+		final String type = enversService.getEntitiesConfigurations()
+				.getEntityNameForVersionsEntityName( (String) versionsEntity.get( "$type$" ) );
 
 		if ( type != null ) {
 			entityName = type;
 		}
 
 		// First mapping the primary key
-		final IdMapper idMapper = verCfg.getEntCfg().get( entityName ).getIdMapper();
-		final Map originalId = (Map) versionsEntity.get( verCfg.getAuditEntCfg().getOriginalIdPropName() );
+		final IdMapper idMapper = enversService.getEntitiesConfigurations().get( entityName ).getIdMapper();
+		final Map originalId = (Map) versionsEntity.get(
+				enversService.getAuditEntitiesConfiguration()
+						.getOriginalIdPropName()
+		);
 
 		// Fixes HHH-4751 issue (@IdClass with @ManyToOne relation mapping inside)
 		// Note that identifiers are always audited
 		// Replace identifier proxies if do not point to audit tables
 		replaceNonAuditIdProxies( versionsEntity, revision );
 
 		final Object primaryKey = idMapper.mapToIdFromMap( originalId );
 
 		// Checking if the entity is in cache
 		if ( versionsReader.getFirstLevelCache().contains( entityName, revision, primaryKey ) ) {
 			return versionsReader.getFirstLevelCache().get( entityName, revision, primaryKey );
 		}
 
 		// If it is not in the cache, creating a new entity instance
 		Object ret;
 		try {
-			EntityConfiguration entCfg = verCfg.getEntCfg().get( entityName );
+			EntityConfiguration entCfg = enversService.getEntitiesConfigurations().get( entityName );
 			if ( entCfg == null ) {
 				// a relation marked as RelationTargetAuditMode.NOT_AUDITED
-				entCfg = verCfg.getEntCfg().getNotVersionEntityConfiguration( entityName );
+				entCfg = enversService.getEntitiesConfigurations().getNotVersionEntityConfiguration( entityName );
 			}
 
-			final Class<?> cls = ReflectionTools.loadClass( entCfg.getEntityClassName(), verCfg.getClassLoaderService() );
+			final Class<?> cls = ReflectionTools.loadClass( entCfg.getEntityClassName(), enversService.getClassLoaderService() );
 			ret = ReflectHelper.getDefaultConstructor( cls ).newInstance();
 		}
 		catch (Exception e) {
 			throw new AuditException( e );
 		}
 
 		// Putting the newly created entity instance into the first level cache, in case a one-to-one bidirectional
 		// relation is present (which is eagerly loaded).
 		versionsReader.getFirstLevelCache().put( entityName, revision, primaryKey, ret );
 
-		verCfg.getEntCfg().get( entityName ).getPropertyMapper().mapToEntityFromMap(
-				verCfg,
+		enversService.getEntitiesConfigurations().get( entityName ).getPropertyMapper().mapToEntityFromMap(
+				enversService,
 				ret,
 				versionsEntity,
 				primaryKey,
 				versionsReader,
 				revision
 		);
 		idMapper.mapToEntityFromMap( ret, originalId );
 
 		// Put entity on entityName cache after mapping it from the map representation
 		versionsReader.getFirstLevelCache().putOnEntityNameCache( primaryKey, revision, ret, entityName );
 
 		return ret;
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private void replaceNonAuditIdProxies(Map versionsEntity, Number revision) {
-		final Map originalId = (Map) versionsEntity.get( verCfg.getAuditEntCfg().getOriginalIdPropName() );
+		final Map originalId = (Map) versionsEntity.get( enversService.getAuditEntitiesConfiguration().getOriginalIdPropName() );
 		for ( Object key : originalId.keySet() ) {
 			final Object value = originalId.get( key );
 			if ( value instanceof HibernateProxy ) {
 				final HibernateProxy hibernateProxy = (HibernateProxy) value;
 				final LazyInitializer initializer = hibernateProxy.getHibernateLazyInitializer();
 				final String entityName = initializer.getEntityName();
 				final Serializable entityId = initializer.getIdentifier();
-				if ( verCfg.getEntCfg().isVersioned( entityName ) ) {
-					final String entityClassName = verCfg.getEntCfg().get( entityName ).getEntityClassName();
+				if ( enversService.getEntitiesConfigurations().isVersioned( entityName ) ) {
+					final String entityClassName = enversService.getEntitiesConfigurations().get( entityName ).getEntityClassName();
 					final Class entityClass = ReflectionTools.loadClass(
 							entityClassName,
-							verCfg.getClassLoaderService()
+							enversService.getClassLoaderService()
 					);
 					final ToOneDelegateSessionImplementor delegate = new ToOneDelegateSessionImplementor(
-							versionsReader, entityClass, entityId, revision,
+							versionsReader,
+							entityClass,
+							entityId,
+							revision,
 							RevisionType.DEL.equals(
 									versionsEntity.get(
-											verCfg.getAuditEntCfg()
-													.getRevisionTypePropName()
+											enversService.getAuditEntitiesConfiguration().getRevisionTypePropName()
 									)
 							),
-							verCfg
+							enversService
 					);
 					originalId.put(
 							key,
 							versionsReader.getSessionImplementor()
 									.getFactory()
 									.getEntityPersister( entityName )
 									.createProxy( entityId, delegate )
 					);
 				}
 			}
 		}
 	}
 
 	@SuppressWarnings({"unchecked"})
 	public void addInstancesFromVersionsEntities(
 			String entityName,
 			Collection addTo,
 			List<Map> versionsEntities,
 			Number revision) {
 		for ( Map versionsEntity : versionsEntities ) {
 			addTo.add( createInstanceFromVersionsEntity( entityName, versionsEntity, revision ) );
 		}
 	}
 
-	public AuditConfiguration getAuditConfiguration() {
-		return verCfg;
+	public EnversService getEnversService() {
+		return enversService;
 	}
 
 	public AuditReaderImplementor getAuditReaderImplementor() {
 		return versionsReader;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/ComponentPropertyMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/ComponentPropertyMapper.java
index a648efba17..e0482f2af0 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/ComponentPropertyMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/ComponentPropertyMapper.java
@@ -1,178 +1,178 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper;
 
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.property.Setter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  * @author Lukasz Zuchowski (author at zuchos dot com)
  */
 public class ComponentPropertyMapper implements PropertyMapper, CompositeMapperBuilder {
 	private final PropertyData propertyData;
 	private final MultiPropertyMapper delegate;
 	private final Class componentClass;
 
 	public ComponentPropertyMapper(PropertyData propertyData, Class componentClass) {
 		this.propertyData = propertyData;
 		//if class is a map it means that this is dynamic component
 		if ( Map.class.isAssignableFrom( componentClass ) ) {
 			this.delegate = new MultiDynamicComponentMapper( propertyData );
 			this.componentClass = HashMap.class;
 		}
 		else {
 			this.delegate = new MultiPropertyMapper();
 			this.componentClass = componentClass;
 		}
 	}
 
 	@Override
 	public void add(PropertyData propertyData) {
 		delegate.add( propertyData );
 	}
 
 	@Override
 	public CompositeMapperBuilder addComponent(PropertyData propertyData, Class componentClass) {
 		return delegate.addComponent( propertyData, componentClass );
 	}
 
 	@Override
 	public void addComposite(PropertyData propertyData, PropertyMapper propertyMapper) {
 		delegate.addComposite( propertyData, propertyMapper );
 	}
 
 	@Override
 	public boolean mapToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		return delegate.mapToMapFromEntity( session, data, newObj, oldObj );
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		if ( propertyData.isUsingModifiedFlag() ) {
 			data.put(
 					propertyData.getModifiedFlagPropertyName(),
 					delegate.mapToMapFromEntity( session, new HashMap<String, Object>(), newObj, oldObj )
 			);
 		}
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapForCollectionChange(String collectionPropertyName, Map<String, Object> data) {
 		if ( propertyData.isUsingModifiedFlag() ) {
 			boolean hasModifiedCollection = false;
 			for ( PropertyData propData : delegate.getProperties().keySet() ) {
 				if ( collectionPropertyName.equals( propData.getName() ) ) {
 					hasModifiedCollection = true;
 					break;
 				}
 			}
 			data.put( propertyData.getModifiedFlagPropertyName(), hasModifiedCollection );
 		}
 	}
 
 	@Override
 	public void mapToEntityFromMap(
-			AuditConfiguration verCfg,
+			EnversService enversService,
 			Object obj,
 			Map data,
 			Object primaryKey,
 			AuditReaderImplementor versionsReader,
 			Number revision) {
 		if ( data == null || obj == null ) {
 			return;
 		}
 
 		if ( propertyData.getBeanName() == null ) {
 			// If properties are not encapsulated in a component but placed directly in a class
 			// (e.g. by applying <properties> tag).
-			delegate.mapToEntityFromMap( verCfg, obj, data, primaryKey, versionsReader, revision );
+			delegate.mapToEntityFromMap( enversService, obj, data, primaryKey, versionsReader, revision );
 			return;
 		}
 
 		final Setter setter = ReflectionTools.getSetter( obj.getClass(), propertyData );
 
 		// If all properties are null and single, then the component has to be null also.
 		boolean allNullAndSingle = true;
 		for ( Map.Entry<PropertyData, PropertyMapper> property : delegate.getProperties().entrySet() ) {
 			if ( data.get(
 					property.getKey()
 							.getName()
 			) != null || !( property.getValue() instanceof SinglePropertyMapper ) ) {
 				allNullAndSingle = false;
 				break;
 			}
 		}
 
 		if ( allNullAndSingle ) {
 			// single property, but default value need not be null, so we'll set it to null anyway
 			setter.set( obj, null, null );
 		}
 		else {
 			// set the component
 			try {
 				final Object subObj = ReflectHelper.getDefaultConstructor( componentClass ).newInstance();
 				setter.set( obj, subObj, null );
-				delegate.mapToEntityFromMap( verCfg, subObj, data, primaryKey, versionsReader, revision );
+				delegate.mapToEntityFromMap( enversService, subObj, data, primaryKey, versionsReader, revision );
 			}
 			catch ( Exception e ) {
 				throw new AuditException( e );
 			}
 		}
 	}
 
 	@Override
 	public List<PersistentCollectionChangeData> mapCollectionChanges(
 			SessionImplementor session, String referencingPropertyName,
 			PersistentCollection newColl,
 			Serializable oldColl, Serializable id) {
 		return delegate.mapCollectionChanges( session, referencingPropertyName, newColl, oldColl, id );
 	}
 
 	@Override
 	public Map<PropertyData, PropertyMapper> getProperties() {
 		return delegate.getProperties();
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/MultiDynamicComponentMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/MultiDynamicComponentMapper.java
index ca82beb849..f26acd55cb 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/MultiDynamicComponentMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/MultiDynamicComponentMapper.java
@@ -1,111 +1,116 @@
 package org.hibernate.envers.internal.entities.mapper;
 
 import java.util.Map;
 
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.MapProxyTool;
 import org.hibernate.envers.internal.tools.StringTools;
 
 /**
  * Multi mapper for dynamic components (it knows that component is a map, not a class)
  *
  * @author Lukasz Zuchowski (author at zuchos dot com)
  */
 public class MultiDynamicComponentMapper extends MultiPropertyMapper {
 
 	private PropertyData dynamicComponentData;
 
 	public MultiDynamicComponentMapper(PropertyData dynamicComponentData) {
 		this.dynamicComponentData = dynamicComponentData;
 	}
 
 	@Override
 	public boolean mapToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		boolean ret = false;
 		for ( PropertyData propertyData : properties.keySet() ) {
 			if ( newObj == null && oldObj == null ) {
 				return false;
 			}
 			Object newValue = newObj == null ? null : getValue( newObj, propertyData );
 			Object oldValue = oldObj == null ? null : getValue( oldObj, propertyData );
 
 			ret |= properties.get( propertyData ).mapToMapFromEntity( session, data, newValue, oldValue );
 		}
 
 		return ret;
 	}
 
 	private Object getValue(Object newObj, PropertyData propertyData) {
 		return ( (Map) newObj ).get( propertyData.getBeanName() );
 	}
 
 	@Override
 	public boolean map(
 			SessionImplementor session,
 			Map<String, Object> data,
 			String[] propertyNames,
 			Object[] newState,
 			Object[] oldState) {
 		boolean ret = false;
 		for ( int i = 0; i < propertyNames.length; i++ ) {
 			final String propertyName = propertyNames[i];
 			Map<String, PropertyData> propertyDatas = getPropertyDatas();
 			if ( propertyDatas.containsKey( propertyName ) ) {
 				final PropertyMapper propertyMapper = properties.get( propertyDatas.get( propertyName ) );
 				final Object newObj = getAtIndexOrNull( newState, i );
 				final Object oldObj = getAtIndexOrNull( oldState, i );
 				ret |= propertyMapper.mapToMapFromEntity( session, data, newObj, oldObj );
 				propertyMapper.mapModifiedFlagsToMapFromEntity( session, data, newObj, oldObj );
 			}
 		}
 
 		return ret;
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		for ( PropertyData propertyData : properties.keySet() ) {
 			if ( newObj == null && oldObj == null ) {
 				return;
 			}
 			Object newValue = newObj == null ? null : getValue( newObj, propertyData );
 			Object oldValue = oldObj == null ? null : getValue( oldObj, propertyData );
 			properties.get( propertyData ).mapModifiedFlagsToMapFromEntity( session, data, newValue, oldValue );
 		}
 	}
 
 	@Override
+	@SuppressWarnings("unchecked")
 	public void mapToEntityFromMap(
-			AuditConfiguration verCfg, Object obj, Map data, Object primaryKey,
-			AuditReaderImplementor versionsReader, Number revision) {
+			EnversService enversService,
+			Object obj,
+			Map data,
+			Object primaryKey,
+			AuditReaderImplementor versionsReader,
+			Number revision) {
 		Object mapProxy = MapProxyTool.newInstanceOfBeanProxyForMap(
-				generateClassName(
-						data,
-						dynamicComponentData.getBeanName()
-				), (Map) obj, properties.keySet(), verCfg.getClassLoaderService()
+				generateClassName( data, dynamicComponentData.getBeanName() ),
+				(Map) obj,
+				properties.keySet(),
+				enversService.getClassLoaderService()
 		);
 		for ( PropertyData propertyData : properties.keySet() ) {
 			PropertyMapper mapper = properties.get( propertyData );
-			mapper.mapToEntityFromMap( verCfg, mapProxy, data, primaryKey, versionsReader, revision );
+			mapper.mapToEntityFromMap( enversService, mapProxy, data, primaryKey, versionsReader, revision );
 		}
 	}
 
 	private String generateClassName(Map data, String dynamicComponentPropertyName) {
 		return ( data.get( "$type$" ) + StringTools.capitalizeFirst( dynamicComponentPropertyName ) ).replaceAll(
 				"_",
 				""
 		);
 	}
 
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/MultiPropertyMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/MultiPropertyMapper.java
index 96c39c24e0..81295a9df1 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/MultiPropertyMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/MultiPropertyMapper.java
@@ -1,234 +1,238 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper;
 
 import java.io.Serializable;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.MappingTools;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.envers.internal.tools.Tools;
 import org.hibernate.envers.tools.Pair;
 import org.hibernate.property.Getter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  * @author Lukasz Zuchowski (author at zuchos dot com)
  */
 public class MultiPropertyMapper implements ExtendedPropertyMapper {
 	protected final Map<PropertyData, PropertyMapper> properties;
 	private final Map<String, PropertyData> propertyDatas;
 
 	public MultiPropertyMapper() {
 		properties = Tools.newHashMap();
 		propertyDatas = Tools.newHashMap();
 	}
 
 	@Override
 	public void add(PropertyData propertyData) {
 		final SinglePropertyMapper single = new SinglePropertyMapper();
 		single.add( propertyData );
 		properties.put( propertyData, single );
 		propertyDatas.put( propertyData.getName(), propertyData );
 	}
 
 	@Override
 	public CompositeMapperBuilder addComponent(PropertyData propertyData, Class componentClass) {
 		if ( properties.get( propertyData ) != null ) {
 			// This is needed for second pass to work properly in the components mapper
 			return (CompositeMapperBuilder) properties.get( propertyData );
 		}
 
 		final ComponentPropertyMapper componentMapperBuilder = new ComponentPropertyMapper(
 				propertyData,
 				componentClass
 		);
 		addComposite( propertyData, componentMapperBuilder );
 
 		return componentMapperBuilder;
 	}
 
 	@Override
 	public void addComposite(PropertyData propertyData, PropertyMapper propertyMapper) {
 		properties.put( propertyData, propertyMapper );
 		propertyDatas.put( propertyData.getName(), propertyData );
 	}
 
 	protected Object getAtIndexOrNull(Object[] array, int index) {
 		return array == null ? null : array[index];
 	}
 
 	@Override
 	public boolean map(
 			SessionImplementor session,
 			Map<String, Object> data,
 			String[] propertyNames,
 			Object[] newState,
 			Object[] oldState) {
 		boolean ret = false;
 		for ( int i = 0; i < propertyNames.length; i++ ) {
 			final String propertyName = propertyNames[i];
 
 			if ( propertyDatas.containsKey( propertyName ) ) {
 				final PropertyMapper propertyMapper = properties.get( propertyDatas.get( propertyName ) );
 				final Object newObj = getAtIndexOrNull( newState, i );
 				final Object oldObj = getAtIndexOrNull( oldState, i );
 				ret |= propertyMapper.mapToMapFromEntity( session, data, newObj, oldObj );
 				propertyMapper.mapModifiedFlagsToMapFromEntity( session, data, newObj, oldObj );
 			}
 		}
 
 		return ret;
 	}
 
 	@Override
 	public boolean mapToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		boolean ret = false;
 		for ( PropertyData propertyData : properties.keySet() ) {
 			Getter getter;
 			if ( newObj != null ) {
 				getter = ReflectionTools.getGetter( newObj.getClass(), propertyData );
 			}
 			else if ( oldObj != null ) {
 				getter = ReflectionTools.getGetter( oldObj.getClass(), propertyData );
 			}
 			else {
 				return false;
 			}
 
 			ret |= properties.get( propertyData ).mapToMapFromEntity(
 					session, data,
 					newObj == null ? null : getter.get( newObj ),
 					oldObj == null ? null : getter.get( oldObj )
 			);
 		}
 
 		return ret;
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		for ( PropertyData propertyData : properties.keySet() ) {
 			Getter getter;
 			if ( newObj != null ) {
 				getter = ReflectionTools.getGetter( newObj.getClass(), propertyData );
 			}
 			else if ( oldObj != null ) {
 				getter = ReflectionTools.getGetter( oldObj.getClass(), propertyData );
 			}
 			else {
 				return;
 			}
 
 			properties.get( propertyData ).mapModifiedFlagsToMapFromEntity(
 					session, data,
 					newObj == null ? null : getter.get( newObj ),
 					oldObj == null ? null : getter.get( oldObj )
 			);
 		}
 	}
 
 	@Override
 	public void mapToEntityFromMap(
-			AuditConfiguration verCfg, Object obj, Map data, Object primaryKey,
-			AuditReaderImplementor versionsReader, Number revision) {
+			EnversService enversService,
+			Object obj,
+			Map data,
+			Object primaryKey,
+			AuditReaderImplementor versionsReader,
+			Number revision) {
 		for ( PropertyMapper mapper : properties.values() ) {
-			mapper.mapToEntityFromMap( verCfg, obj, data, primaryKey, versionsReader, revision );
+			mapper.mapToEntityFromMap( enversService, obj, data, primaryKey, versionsReader, revision );
 		}
 	}
 
 	private Pair<PropertyMapper, String> getMapperAndDelegatePropName(String referencingPropertyName) {
 		// Name of the property, to which we will delegate the mapping.
 		String delegatePropertyName;
 
 		// Checking if the property name doesn't reference a collection in a component - then the name will containa a .
 		final int dotIndex = referencingPropertyName.indexOf( '.' );
 		if ( dotIndex != -1 ) {
 			// Computing the name of the component
 			final String componentName = referencingPropertyName.substring( 0, dotIndex );
 			// And the name of the property in the component
 			final String propertyInComponentName = MappingTools.createComponentPrefix( componentName )
 					+ referencingPropertyName.substring( dotIndex + 1 );
 
 			// We need to get the mapper for the component.
 			referencingPropertyName = componentName;
 			// As this is a component, we delegate to the property in the component.
 			delegatePropertyName = propertyInComponentName;
 		}
 		else {
 			// If this is not a component, we delegate to the same property.
 			delegatePropertyName = referencingPropertyName;
 		}
 		return Pair.make( properties.get( propertyDatas.get( referencingPropertyName ) ), delegatePropertyName );
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapForCollectionChange(String collectionPropertyName, Map<String, Object> data) {
 		final Pair<PropertyMapper, String> pair = getMapperAndDelegatePropName( collectionPropertyName );
 		final PropertyMapper mapper = pair.getFirst();
 		if ( mapper != null ) {
 			mapper.mapModifiedFlagsToMapForCollectionChange( pair.getSecond(), data );
 		}
 	}
 
 	@Override
 	public List<PersistentCollectionChangeData> mapCollectionChanges(
 			SessionImplementor session,
 			String referencingPropertyName,
 			PersistentCollection newColl,
 			Serializable oldColl, Serializable id) {
 		final Pair<PropertyMapper, String> pair = getMapperAndDelegatePropName( referencingPropertyName );
 		final PropertyMapper mapper = pair.getFirst();
 		if ( mapper != null ) {
 			return mapper.mapCollectionChanges( session, pair.getSecond(), newColl, oldColl, id );
 		}
 		else {
 			return null;
 		}
 	}
 
 	@Override
 	public Map<PropertyData, PropertyMapper> getProperties() {
 		return properties;
 	}
 
 	public Map<String, PropertyData> getPropertyDatas() {
 		return propertyDatas;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/PropertyMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/PropertyMapper.java
index 43d6acaa14..8bf316a2d1 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/PropertyMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/PropertyMapper.java
@@ -1,89 +1,93 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper;
 
 import java.io.Serializable;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public interface PropertyMapper {
 	/**
 	 * Maps properties to the given map, basing on differences between properties of new and old objects.
 	 *
 	 * @param session The current session.
 	 * @param data Data to map to.
 	 * @param newObj New state of the entity.
 	 * @param oldObj Old state of the entity.
 	 *
 	 * @return True if there are any differences between the states represented by newObj and oldObj.
 	 */
 	boolean mapToMapFromEntity(SessionImplementor session, Map<String, Object> data, Object newObj, Object oldObj);
 
 	/**
 	 * Maps properties from the given map to the given object.
 	 *
-	 * @param verCfg Versions configuration.
+	 * @param enversService The EnversService.
 	 * @param obj Object to map to.
 	 * @param data Data to map from.
 	 * @param primaryKey Primary key of the object to which we map (for relations)
 	 * @param versionsReader VersionsReader for reading relations
 	 * @param revision Revision at which the object is read, for reading relations
 	 */
 	void mapToEntityFromMap(
-			AuditConfiguration verCfg, Object obj, Map data, Object primaryKey,
-			AuditReaderImplementor versionsReader, Number revision);
+			EnversService enversService,
+			Object obj,
+			Map data,
+			Object primaryKey,
+			AuditReaderImplementor versionsReader,
+			Number revision);
 
 	/**
 	 * Maps collection changes.
 	 *
 	 * @param session The current session.
 	 * @param referencingPropertyName Name of the field, which holds the collection in the entity.
 	 * @param newColl New collection, after updates.
 	 * @param oldColl Old collection, before updates.
 	 * @param id Id of the object owning the collection.
 	 *
 	 * @return List of changes that need to be performed on the persistent store.
 	 */
 	List<PersistentCollectionChangeData> mapCollectionChanges(
 			SessionImplementor session, String referencingPropertyName,
 			PersistentCollection newColl,
 			Serializable oldColl, Serializable id);
 
 	void mapModifiedFlagsToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj);
 
 	void mapModifiedFlagsToMapForCollectionChange(String collectionPropertyName, Map<String, Object> data);
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/SinglePropertyMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/SinglePropertyMapper.java
index f45f026640..ef1eb1d992 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/SinglePropertyMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/SinglePropertyMapper.java
@@ -1,146 +1,150 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper;
 
 import java.io.Serializable;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.dialect.Oracle8iDialect;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.envers.internal.tools.StringTools;
 import org.hibernate.envers.internal.tools.Tools;
 import org.hibernate.property.DirectPropertyAccessor;
 import org.hibernate.property.Setter;
 
 /**
  * TODO: diff
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public class SinglePropertyMapper implements PropertyMapper, SimpleMapperBuilder {
 	private PropertyData propertyData;
 
 	public SinglePropertyMapper(PropertyData propertyData) {
 		this.propertyData = propertyData;
 	}
 
 	public SinglePropertyMapper() {
 	}
 
 	@Override
 	public void add(PropertyData propertyData) {
 		if ( this.propertyData != null ) {
 			throw new AuditException( "Only one property can be added!" );
 		}
 
 		this.propertyData = propertyData;
 	}
 
 	@Override
 	public boolean mapToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		data.put( propertyData.getName(), newObj );
 		boolean dbLogicallyDifferent = true;
 		if ( (session.getFactory()
 				.getDialect() instanceof Oracle8iDialect) && (newObj instanceof String || oldObj instanceof String) ) {
 			// Don't generate new revision when database replaces empty string with NULL during INSERT or UPDATE statements.
 			dbLogicallyDifferent = !(StringTools.isEmpty( newObj ) && StringTools.isEmpty( oldObj ));
 		}
 		return dbLogicallyDifferent && !Tools.objectsEqual( newObj, oldObj );
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		if ( propertyData.isUsingModifiedFlag() ) {
 			data.put( propertyData.getModifiedFlagPropertyName(), !Tools.objectsEqual( newObj, oldObj ) );
 		}
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapForCollectionChange(String collectionPropertyName, Map<String, Object> data) {
 	}
 
 	@Override
 	public void mapToEntityFromMap(
-			AuditConfiguration verCfg, Object obj, Map data, Object primaryKey,
-			AuditReaderImplementor versionsReader, Number revision) {
+			EnversService enversService,
+			Object obj,
+			Map data,
+			Object primaryKey,
+			AuditReaderImplementor versionsReader,
+			Number revision) {
 		if ( data == null || obj == null ) {
 			return;
 		}
 
 		final Setter setter = ReflectionTools.getSetter( obj.getClass(), propertyData );
 		final Object value = data.get( propertyData.getName() );
 		// We only set a null value if the field is not primite. Otherwise, we leave it intact.
 		if ( value != null || !isPrimitive( setter, propertyData, obj.getClass() ) ) {
 			setter.set( obj, value, null );
 		}
 	}
 
 	private boolean isPrimitive(Setter setter, PropertyData propertyData, Class<?> cls) {
 		if ( cls == null ) {
 			throw new HibernateException( "No field found for property: " + propertyData.getName() );
 		}
 
 		if ( setter instanceof DirectPropertyAccessor.DirectSetter ) {
 			// In a direct setter, getMethod() returns null
 			// Trying to look up the field
 			try {
 				return cls.getDeclaredField( propertyData.getBeanName() ).getType().isPrimitive();
 			}
 			catch (NoSuchFieldException e) {
 				return isPrimitive( setter, propertyData, cls.getSuperclass() );
 			}
 		}
 		else {
 			return setter.getMethod().getParameterTypes()[0].isPrimitive();
 		}
 	}
 
 	@Override
 	public List<PersistentCollectionChangeData> mapCollectionChanges(
 			SessionImplementor sessionImplementor,
 			String referencingPropertyName,
 			PersistentCollection newColl,
 			Serializable oldColl,
 			Serializable id) {
 		return null;
 	}
 
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/SubclassPropertyMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/SubclassPropertyMapper.java
index 3696a30dd6..280845ff0f 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/SubclassPropertyMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/SubclassPropertyMapper.java
@@ -1,160 +1,160 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper;
 
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 
 /**
  * A mapper which maps from a parent mapper and a "main" one, but adds only to the "main". The "main" mapper
  * should be the mapper of the subclass.
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public class SubclassPropertyMapper implements ExtendedPropertyMapper {
 	private ExtendedPropertyMapper main;
 	private ExtendedPropertyMapper parentMapper;
 
 	public SubclassPropertyMapper(ExtendedPropertyMapper main, ExtendedPropertyMapper parentMapper) {
 		this.main = main;
 		this.parentMapper = parentMapper;
 	}
 
 	@Override
 	public boolean map(
 			SessionImplementor session,
 			Map<String, Object> data,
 			String[] propertyNames,
 			Object[] newState,
 			Object[] oldState) {
 		final boolean parentDiffs = parentMapper.map( session, data, propertyNames, newState, oldState );
 		final boolean mainDiffs = main.map( session, data, propertyNames, newState, oldState );
 
 		return parentDiffs || mainDiffs;
 	}
 
 	@Override
 	public boolean mapToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		final boolean parentDiffs = parentMapper.mapToMapFromEntity( session, data, newObj, oldObj );
 		final boolean mainDiffs = main.mapToMapFromEntity( session, data, newObj, oldObj );
 
 		return parentDiffs || mainDiffs;
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		parentMapper.mapModifiedFlagsToMapFromEntity( session, data, newObj, oldObj );
 		main.mapModifiedFlagsToMapFromEntity( session, data, newObj, oldObj );
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapForCollectionChange(String collectionPropertyName, Map<String, Object> data) {
 		parentMapper.mapModifiedFlagsToMapForCollectionChange( collectionPropertyName, data );
 		main.mapModifiedFlagsToMapForCollectionChange( collectionPropertyName, data );
 	}
 
 	@Override
 	public void mapToEntityFromMap(
-			AuditConfiguration verCfg,
+			EnversService enversService,
 			Object obj,
 			Map data,
 			Object primaryKey,
 			AuditReaderImplementor versionsReader,
 			Number revision) {
-		parentMapper.mapToEntityFromMap( verCfg, obj, data, primaryKey, versionsReader, revision );
-		main.mapToEntityFromMap( verCfg, obj, data, primaryKey, versionsReader, revision );
+		parentMapper.mapToEntityFromMap( enversService, obj, data, primaryKey, versionsReader, revision );
+		main.mapToEntityFromMap( enversService, obj, data, primaryKey, versionsReader, revision );
 	}
 
 	@Override
 	public List<PersistentCollectionChangeData> mapCollectionChanges(
 			SessionImplementor session, String referencingPropertyName,
 			PersistentCollection newColl,
 			Serializable oldColl, Serializable id) {
 		final List<PersistentCollectionChangeData> parentCollectionChanges = parentMapper.mapCollectionChanges(
 				session,
 				referencingPropertyName,
 				newColl,
 				oldColl,
 				id
 		);
 
 		final List<PersistentCollectionChangeData> mainCollectionChanges = main.mapCollectionChanges(
 				session,
 				referencingPropertyName,
 				newColl,
 				oldColl,
 				id
 		);
 
 		if ( parentCollectionChanges == null ) {
 			return mainCollectionChanges;
 		}
 		else {
 			if ( mainCollectionChanges != null ) {
 				parentCollectionChanges.addAll( mainCollectionChanges );
 			}
 			return parentCollectionChanges;
 		}
 	}
 
 	@Override
 	public CompositeMapperBuilder addComponent(PropertyData propertyData, Class componentClass) {
 		return main.addComponent( propertyData, componentClass );
 	}
 
 	@Override
 	public void addComposite(PropertyData propertyData, PropertyMapper propertyMapper) {
 		main.addComposite( propertyData, propertyMapper );
 	}
 
 	@Override
 	public void add(PropertyData propertyData) {
 		main.add( propertyData );
 	}
 
 	@Override
 	public Map<PropertyData, PropertyMapper> getProperties() {
 		final Map<PropertyData, PropertyMapper> joinedProperties = new HashMap<PropertyData, PropertyMapper>();
 		joinedProperties.putAll( parentMapper.getProperties() );
 		joinedProperties.putAll( main.getProperties() );
 		return joinedProperties;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractCollectionMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractCollectionMapper.java
index dbf7443853..ee578a0c21 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractCollectionMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractCollectionMapper.java
@@ -1,288 +1,296 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.RevisionType;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.entities.mapper.PersistentCollectionChangeData;
 import org.hibernate.envers.internal.entities.mapper.PropertyMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor.Initializor;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.envers.internal.tools.Tools;
 import org.hibernate.property.Setter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public abstract class AbstractCollectionMapper<T> implements PropertyMapper {
 	protected final CommonCollectionMapperData commonCollectionMapperData;
 	protected final Class<? extends T> collectionClass;
 	protected final boolean ordinalInId;
 	protected final boolean revisionTypeInId;
 
 	private final Constructor<? extends T> proxyConstructor;
 
 	protected AbstractCollectionMapper(
 			CommonCollectionMapperData commonCollectionMapperData,
 			Class<? extends T> collectionClass, Class<? extends T> proxyClass, boolean ordinalInId,
 			boolean revisionTypeInId) {
 		this.commonCollectionMapperData = commonCollectionMapperData;
 		this.collectionClass = collectionClass;
 		this.ordinalInId = ordinalInId;
 		this.revisionTypeInId = revisionTypeInId;
 
 		try {
 			proxyConstructor = proxyClass.getConstructor( Initializor.class );
 		}
 		catch (NoSuchMethodException e) {
 			throw new AuditException( e );
 		}
 	}
 
 	protected abstract Collection getNewCollectionContent(PersistentCollection newCollection);
 
 	protected abstract Collection getOldCollectionContent(Serializable oldCollection);
 
 	/**
 	 * Maps the changed collection element to the given map.
 	 *
 	 * @param idData Map to which composite-id data should be added.
 	 * @param data Where to map the data.
 	 * @param changed The changed collection element to map.
 	 */
 	protected abstract void mapToMapFromObject(
 			SessionImplementor session,
 			Map<String, Object> idData,
 			Map<String, Object> data,
 			Object changed);
 
 	/**
 	 * Creates map for storing identifier data. Ordinal parameter guarantees uniqueness of primary key.
 	 * Composite primary key cannot contain embeddable properties since they might be nullable.
 	 *
 	 * @param ordinal Iteration ordinal.
 	 *
 	 * @return Map for holding identifier data.
 	 */
 	protected Map<String, Object> createIdMap(int ordinal) {
 		final Map<String, Object> idMap = new HashMap<String, Object>();
 		if ( ordinalInId ) {
 			idMap.put( commonCollectionMapperData.getVerEntCfg().getEmbeddableSetOrdinalPropertyName(), ordinal );
 		}
 		return idMap;
 	}
 
 	private void addCollectionChanges(
 			SessionImplementor session, List<PersistentCollectionChangeData> collectionChanges,
 			Set<Object> changed, RevisionType revisionType, Serializable id) {
 		int ordinal = 0;
 
 		for ( Object changedObj : changed ) {
 			final Map<String, Object> entityData = new HashMap<String, Object>();
 			final Map<String, Object> originalId = createIdMap( ordinal++ );
 			entityData.put( commonCollectionMapperData.getVerEntCfg().getOriginalIdPropName(), originalId );
 
 			collectionChanges.add(
 					new PersistentCollectionChangeData(
 							commonCollectionMapperData.getVersionsMiddleEntityName(), entityData, changedObj
 					)
 			);
 			// Mapping the collection owner's id.
 			commonCollectionMapperData.getReferencingIdData().getPrefixedMapper().mapToMapFromId( originalId, id );
 
 			// Mapping collection element and index (if present).
 			mapToMapFromObject( session, originalId, entityData, changedObj );
 
 			(revisionTypeInId ? originalId : entityData).put(
 					commonCollectionMapperData.getVerEntCfg()
 							.getRevisionTypePropName(), revisionType
 			);
 		}
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public List<PersistentCollectionChangeData> mapCollectionChanges(
 			SessionImplementor session,
 			String referencingPropertyName,
 			PersistentCollection newColl,
 			Serializable oldColl, Serializable id) {
 		if ( !commonCollectionMapperData.getCollectionReferencingPropertyData().getName().equals(
 				referencingPropertyName
 		) ) {
 			return null;
 		}
 
 		final List<PersistentCollectionChangeData> collectionChanges = new ArrayList<PersistentCollectionChangeData>();
 
 		// Comparing new and old collection content.
 		final Collection newCollection = getNewCollectionContent( newColl );
 		final Collection oldCollection = getOldCollectionContent( oldColl );
 
 		final Set<Object> added = new HashSet<Object>();
 		if ( newColl != null ) {
 			added.addAll( newCollection );
 		}
 		// Re-hashing the old collection as the hash codes of the elements there may have changed, and the
 		// removeAll in AbstractSet has an implementation that is hashcode-change sensitive (as opposed to addAll).
 		if ( oldColl != null ) {
 			added.removeAll( new HashSet( oldCollection ) );
 		}
 
 		addCollectionChanges( session, collectionChanges, added, RevisionType.ADD, id );
 
 		final Set<Object> deleted = new HashSet<Object>();
 		if ( oldColl != null ) {
 			deleted.addAll( oldCollection );
 		}
 		// The same as above - re-hashing new collection.
 		if ( newColl != null ) {
 			deleted.removeAll( new HashSet( newCollection ) );
 		}
 
 		addCollectionChanges( session, collectionChanges, deleted, RevisionType.DEL, id );
 
 		return collectionChanges;
 	}
 
 	@Override
 	public boolean mapToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		// Changes are mapped in the "mapCollectionChanges" method.
 		return false;
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		final PropertyData propertyData = commonCollectionMapperData.getCollectionReferencingPropertyData();
 		if ( propertyData.isUsingModifiedFlag() ) {
 			if ( isNotPersistentCollection( newObj ) || isNotPersistentCollection( oldObj ) ) {
 				// Compare POJOs.
 				data.put( propertyData.getModifiedFlagPropertyName(), !Tools.objectsEqual( newObj, oldObj ) );
 			}
 			else if ( isFromNullToEmptyOrFromEmptyToNull( (PersistentCollection) newObj, (Serializable) oldObj ) ) {
 				data.put( propertyData.getModifiedFlagPropertyName(), true );
 			}
 			else {
 				final List<PersistentCollectionChangeData> changes = mapCollectionChanges(
 						session,
 						commonCollectionMapperData.getCollectionReferencingPropertyData().getName(),
 						(PersistentCollection) newObj,
 						(Serializable) oldObj,
 						null
 				);
 				data.put( propertyData.getModifiedFlagPropertyName(), !changes.isEmpty() );
 			}
 		}
 	}
 
 	private boolean isNotPersistentCollection(Object obj) {
 		return obj != null && !(obj instanceof PersistentCollection);
 	}
 
 	private boolean isFromNullToEmptyOrFromEmptyToNull(PersistentCollection newColl, Serializable oldColl) {
 		// Comparing new and old collection content.
 		final Collection newCollection = getNewCollectionContent( newColl );
 		final Collection oldCollection = getOldCollectionContent( oldColl );
 
 		return oldCollection == null && newCollection != null && newCollection.isEmpty()
 				|| newCollection == null && oldCollection != null && oldCollection.isEmpty();
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapForCollectionChange(String collectionPropertyName, Map<String, Object> data) {
 		final PropertyData propertyData = commonCollectionMapperData.getCollectionReferencingPropertyData();
 		if ( propertyData.isUsingModifiedFlag() ) {
 			data.put(
 					propertyData.getModifiedFlagPropertyName(),
 					propertyData.getName().equals( collectionPropertyName )
 			);
 		}
 	}
 
 	protected abstract Initializor<T> getInitializor(
-			AuditConfiguration verCfg,
-			AuditReaderImplementor versionsReader, Object primaryKey,
-			Number revision, boolean removed);
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			Object primaryKey,
+			Number revision,
+			boolean removed);
 
 	@Override
 	public void mapToEntityFromMap(
-			AuditConfiguration verCfg, Object obj, Map data, Object primaryKey,
-			AuditReaderImplementor versionsReader, Number revision) {
+			EnversService enversService,
+			Object obj,
+			Map data,
+			Object primaryKey,
+			AuditReaderImplementor versionsReader,
+			Number revision) {
 		final Setter setter = ReflectionTools.getSetter(
 				obj.getClass(),
 				commonCollectionMapperData.getCollectionReferencingPropertyData()
 		);
 		try {
 			setter.set(
 					obj,
 					proxyConstructor.newInstance(
 							getInitializor(
-									verCfg, versionsReader, primaryKey, revision,
+									enversService,
+									versionsReader,
+									primaryKey,
+									revision,
 									RevisionType.DEL.equals(
 											data.get(
-													verCfg.getAuditEntCfg()
-															.getRevisionTypePropName()
+													enversService.getAuditEntitiesConfiguration().getRevisionTypePropName()
 											)
 									)
 							)
 					),
 					null
 			);
 		}
 		catch (InstantiationException e) {
 			throw new AuditException( e );
 		}
 		catch (IllegalAccessException e) {
 			throw new AuditException( e );
 		}
 		catch (InvocationTargetException e) {
 			throw new AuditException( e );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractOneToOneMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractOneToOneMapper.java
index b39fe53495..61701638b5 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractOneToOneMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractOneToOneMapper.java
@@ -1,104 +1,108 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.io.Serializable;
 import java.util.Map;
 import javax.persistence.NoResultException;
 
 import org.hibernate.NonUniqueResultException;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 
 /**
  * Template class for property mappers that manage one-to-one relation.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public abstract class AbstractOneToOneMapper extends AbstractToOneMapper {
 	private final String entityName;
 	private final String referencedEntityName;
 
 	protected AbstractOneToOneMapper(String entityName, String referencedEntityName, PropertyData propertyData) {
 		super( propertyData );
 		this.entityName = entityName;
 		this.referencedEntityName = referencedEntityName;
 	}
 
 	@Override
 	public void nullSafeMapToEntityFromMap(
-			AuditConfiguration verCfg, Object obj, Map data, Object primaryKey,
-			AuditReaderImplementor versionsReader, Number revision) {
-		final EntityInfo referencedEntity = getEntityInfo( verCfg, referencedEntityName );
+			EnversService enversService,
+			Object obj,
+			Map data,
+			Object primaryKey,
+			AuditReaderImplementor versionsReader,
+			Number revision) {
+		final EntityInfo referencedEntity = getEntityInfo( enversService, referencedEntityName );
 
 		Object value;
 		try {
 			value = queryForReferencedEntity( versionsReader, referencedEntity, (Serializable) primaryKey, revision );
 		}
 		catch (NoResultException e) {
 			value = null;
 		}
 		catch (NonUniqueResultException e) {
 			throw new AuditException(
 					"Many versions results for one-to-one relationship " + entityName +
 							"." + getPropertyData().getBeanName() + ".", e
 			);
 		}
 
 		setPropertyValue( obj, value );
 	}
 
 	/**
 	 * @param versionsReader Audit reader.
 	 * @param referencedEntity Referenced entity descriptor.
 	 * @param primaryKey Referenced entity identifier.
 	 * @param revision Revision number.
 	 *
 	 * @return Referenced object or proxy of one-to-one relation.
 	 */
 	protected abstract Object queryForReferencedEntity(
 			AuditReaderImplementor versionsReader, EntityInfo referencedEntity,
 			Serializable primaryKey, Number revision);
 
 	@Override
 	public void mapModifiedFlagsToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapForCollectionChange(String collectionPropertyName, Map<String, Object> data) {
 		if ( getPropertyData().isUsingModifiedFlag() ) {
 			data.put(
 					getPropertyData().getModifiedFlagPropertyName(),
 					collectionPropertyName.equals( getPropertyData().getName() )
 			);
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractToOneMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractToOneMapper.java
index ef292e3280..3352d46c11 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractToOneMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/AbstractToOneMapper.java
@@ -1,148 +1,152 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.io.Serializable;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.EntityConfiguration;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.entities.mapper.PersistentCollectionChangeData;
 import org.hibernate.envers.internal.entities.mapper.PropertyMapper;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.ReflectionTools;
 import org.hibernate.property.Setter;
 
 /**
  * Base class for property mappers that manage to-one relation.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public abstract class AbstractToOneMapper implements PropertyMapper {
 	private final PropertyData propertyData;
 
 	protected AbstractToOneMapper(PropertyData propertyData) {
 		this.propertyData = propertyData;
 	}
 
 	@Override
 	public boolean mapToMapFromEntity(
 			SessionImplementor session,
 			Map<String, Object> data,
 			Object newObj,
 			Object oldObj) {
 		return false;
 	}
 
 	@Override
 	public void mapToEntityFromMap(
-			AuditConfiguration verCfg, Object obj, Map data, Object primaryKey,
-			AuditReaderImplementor versionsReader, Number revision) {
+			EnversService enversService,
+			Object obj,
+			Map data,
+			Object primaryKey,
+			AuditReaderImplementor versionsReader,
+			Number revision) {
 		if ( obj != null ) {
-			nullSafeMapToEntityFromMap( verCfg, obj, data, primaryKey, versionsReader, revision );
+			nullSafeMapToEntityFromMap( enversService, obj, data, primaryKey, versionsReader, revision );
 		}
 	}
 
 	@Override
 	public List<PersistentCollectionChangeData> mapCollectionChanges(
-			SessionImplementor session, String referencingPropertyName,
-			PersistentCollection newColl, Serializable oldColl,
+			SessionImplementor session,
+			String referencingPropertyName,
+			PersistentCollection newColl,
+			Serializable oldColl,
 			Serializable id) {
 		return null;
 	}
 
 	/**
-	 * @param verCfg Audit configuration.
+	 * @param enversService The EnversService
 	 * @param entityName Entity name.
 	 *
 	 * @return Entity class, name and information whether it is audited or not.
 	 */
-	protected EntityInfo getEntityInfo(AuditConfiguration verCfg, String entityName) {
-		EntityConfiguration entCfg = verCfg.getEntCfg().get( entityName );
+	protected EntityInfo getEntityInfo(EnversService enversService, String entityName) {
+		EntityConfiguration entCfg = enversService.getEntitiesConfigurations().get( entityName );
 		boolean isRelationAudited = true;
 		if ( entCfg == null ) {
 			// a relation marked as RelationTargetAuditMode.NOT_AUDITED
-			entCfg = verCfg.getEntCfg().getNotVersionEntityConfiguration( entityName );
+			entCfg = enversService.getEntitiesConfigurations().getNotVersionEntityConfiguration( entityName );
 			isRelationAudited = false;
 		}
-		final Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), verCfg.getClassLoaderService() );
+		final Class entityClass = ReflectionTools.loadClass( entCfg.getEntityClassName(), enversService.getClassLoaderService() );
 		return new EntityInfo( entityClass, entityName, isRelationAudited );
 	}
 
 	protected void setPropertyValue(Object targetObject, Object value) {
 		final Setter setter = ReflectionTools.getSetter( targetObject.getClass(), propertyData );
 		setter.set( targetObject, value, null );
 	}
 
 	/**
 	 * @return Bean property that represents the relation.
 	 */
 	protected PropertyData getPropertyData() {
 		return propertyData;
 	}
 
 	/**
 	 * Parameter {@code obj} is never {@code null}.
-	 *
-	 * @see PropertyMapper#mapToEntityFromMap(AuditConfiguration, Object, Map, Object, AuditReaderImplementor, Number)
 	 */
 	public abstract void nullSafeMapToEntityFromMap(
-			AuditConfiguration verCfg,
+			EnversService enversService,
 			Object obj,
 			Map data,
 			Object primaryKey,
 			AuditReaderImplementor versionsReader,
 			Number revision);
 
 	/**
 	 * Simple descriptor of an entity.
 	 */
 	protected class EntityInfo {
 		private final Class entityClass;
 		private final String entityName;
 		private final boolean audited;
 
 		public EntityInfo(Class entityClass, String entityName, boolean audited) {
 			this.entityClass = entityClass;
 			this.entityName = entityName;
 			this.audited = audited;
 		}
 
 		public Class getEntityClass() {
 			return entityClass;
 		}
 
 		public String getEntityName() {
 			return entityName;
 		}
 
 		public boolean isAudited() {
 			return audited;
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/BasicCollectionMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/BasicCollectionMapper.java
index 2b11620037..fee6b9ef35 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/BasicCollectionMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/BasicCollectionMapper.java
@@ -1,88 +1,100 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.io.Serializable;
 import java.util.Collection;
 import java.util.Map;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.mapper.PropertyMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor.BasicCollectionInitializor;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor.Initializor;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class BasicCollectionMapper<T extends Collection> extends AbstractCollectionMapper<T> implements PropertyMapper {
 	protected final MiddleComponentData elementComponentData;
 
 	public BasicCollectionMapper(
 			CommonCollectionMapperData commonCollectionMapperData,
-			Class<? extends T> collectionClass, Class<? extends T> proxyClass,
-			MiddleComponentData elementComponentData, boolean ordinalInId, boolean revisionTypeInId) {
+			Class<? extends T> collectionClass,
+			Class<? extends T> proxyClass,
+			MiddleComponentData elementComponentData,
+			boolean ordinalInId,
+			boolean revisionTypeInId) {
 		super( commonCollectionMapperData, collectionClass, proxyClass, ordinalInId, revisionTypeInId );
 		this.elementComponentData = elementComponentData;
 	}
 
 	@Override
 	protected Initializor<T> getInitializor(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader,
-			Object primaryKey, Number revision, boolean removed) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			Object primaryKey,
+			Number revision,
+			boolean removed) {
 		return new BasicCollectionInitializor<T>(
-				verCfg, versionsReader, commonCollectionMapperData.getQueryGenerator(),
-				primaryKey, revision, removed, collectionClass, elementComponentData
+				enversService,
+				versionsReader,
+				commonCollectionMapperData.getQueryGenerator(),
+				primaryKey,
+				revision,
+				removed,
+				collectionClass,
+				elementComponentData
 		);
 	}
 
 	@Override
 	protected Collection getNewCollectionContent(PersistentCollection newCollection) {
 		return (Collection) newCollection;
 	}
 
 	@Override
 	protected Collection getOldCollectionContent(Serializable oldCollection) {
 		if ( oldCollection == null ) {
 			return null;
 		}
 		else if ( oldCollection instanceof Map ) {
 			return ((Map) oldCollection).keySet();
 		}
 		else {
 			return (Collection) oldCollection;
 		}
 	}
 
 	@Override
 	protected void mapToMapFromObject(
 			SessionImplementor session,
 			Map<String, Object> idData,
 			Map<String, Object> data,
 			Object changed) {
 		elementComponentData.getComponentMapper().mapToMapFromObject( session, idData, data, changed );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ListCollectionMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ListCollectionMapper.java
index 8468c0628b..e96cf3a315 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ListCollectionMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ListCollectionMapper.java
@@ -1,106 +1,115 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.io.Serializable;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.mapper.PropertyMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor.Initializor;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor.ListCollectionInitializor;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.proxy.ListProxy;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.Tools;
 import org.hibernate.envers.tools.Pair;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public final class ListCollectionMapper extends AbstractCollectionMapper<List> implements PropertyMapper {
 	private final MiddleComponentData elementComponentData;
 	private final MiddleComponentData indexComponentData;
 
 	public ListCollectionMapper(
 			CommonCollectionMapperData commonCollectionMapperData,
 			MiddleComponentData elementComponentData, MiddleComponentData indexComponentData,
 			boolean revisionTypeInId) {
 		super( commonCollectionMapperData, List.class, ListProxy.class, false, revisionTypeInId );
 		this.elementComponentData = elementComponentData;
 		this.indexComponentData = indexComponentData;
 	}
 
 	@Override
 	protected Initializor<List> getInitializor(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader,
-			Object primaryKey, Number revision, boolean removed) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			Object primaryKey,
+			Number revision,
+			boolean removed) {
 		return new ListCollectionInitializor(
-				verCfg, versionsReader, commonCollectionMapperData.getQueryGenerator(),
-				primaryKey, revision, removed, elementComponentData, indexComponentData
+				enversService,
+				versionsReader,
+				commonCollectionMapperData.getQueryGenerator(),
+				primaryKey,
+				revision,
+				removed,
+				elementComponentData,
+				indexComponentData
 		);
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	protected Collection getNewCollectionContent(PersistentCollection newCollection) {
 		if ( newCollection == null ) {
 			return null;
 		}
 		else {
 			return Tools.listToIndexElementPairList( (List<Object>) newCollection );
 		}
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	protected Collection getOldCollectionContent(Serializable oldCollection) {
 		if ( oldCollection == null ) {
 			return null;
 		}
 		else {
 			return Tools.listToIndexElementPairList( (List<Object>) oldCollection );
 		}
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	protected void mapToMapFromObject(
 			SessionImplementor session,
 			Map<String, Object> idData,
 			Map<String, Object> data,
 			Object changed) {
 		final Pair<Integer, Object> indexValuePair = (Pair<Integer, Object>) changed;
 		elementComponentData.getComponentMapper().mapToMapFromObject(
 				session,
 				idData,
 				data,
 				indexValuePair.getSecond()
 		);
 		indexComponentData.getComponentMapper().mapToMapFromObject( session, idData, data, indexValuePair.getFirst() );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/MapCollectionMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/MapCollectionMapper.java
index e6323e9c15..07fc8b5d32 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/MapCollectionMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/MapCollectionMapper.java
@@ -1,104 +1,114 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.io.Serializable;
 import java.util.Collection;
 import java.util.Map;
 
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.SessionImplementor;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.mapper.PropertyMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor.Initializor;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor.MapCollectionInitializor;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class MapCollectionMapper<T extends Map> extends AbstractCollectionMapper<T> implements PropertyMapper {
 	protected final MiddleComponentData elementComponentData;
 	protected final MiddleComponentData indexComponentData;
 
 	public MapCollectionMapper(
 			CommonCollectionMapperData commonCollectionMapperData,
 			Class<? extends T> collectionClass, Class<? extends T> proxyClass,
 			MiddleComponentData elementComponentData, MiddleComponentData indexComponentData,
 			boolean revisionTypeInId) {
 		super( commonCollectionMapperData, collectionClass, proxyClass, false, revisionTypeInId );
 		this.elementComponentData = elementComponentData;
 		this.indexComponentData = indexComponentData;
 	}
 
 	@Override
 	protected Initializor<T> getInitializor(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader,
-			Object primaryKey, Number revision, boolean removed) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			Object primaryKey,
+			Number revision,
+			boolean removed) {
 		return new MapCollectionInitializor<T>(
-				verCfg, versionsReader, commonCollectionMapperData.getQueryGenerator(),
-				primaryKey, revision, removed, collectionClass, elementComponentData, indexComponentData
+				enversService,
+				versionsReader,
+				commonCollectionMapperData.getQueryGenerator(),
+				primaryKey,
+				revision,
+				removed,
+				collectionClass,
+				elementComponentData,
+				indexComponentData
 		);
 	}
 
 	@Override
 	protected Collection getNewCollectionContent(PersistentCollection newCollection) {
 		if ( newCollection == null ) {
 			return null;
 		}
 		else {
 			return ((Map) newCollection).entrySet();
 		}
 	}
 
 	@Override
 	protected Collection getOldCollectionContent(Serializable oldCollection) {
 		if ( oldCollection == null ) {
 			return null;
 		}
 		else {
 			return ((Map) oldCollection).entrySet();
 		}
 	}
 
 	@Override
 	protected void mapToMapFromObject(
 			SessionImplementor session,
 			Map<String, Object> idData,
 			Map<String, Object> data,
 			Object changed) {
 		elementComponentData.getComponentMapper().mapToMapFromObject(
 				session,
 				idData,
 				data,
 				((Map.Entry) changed).getValue()
 		);
 		indexComponentData.getComponentMapper().mapToMapFromObject(
 				session,
 				idData,
 				data,
 				((Map.Entry) changed).getKey()
 		);
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/SortedMapCollectionMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/SortedMapCollectionMapper.java
index 5b04d239d5..d7e8aed9d6 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/SortedMapCollectionMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/SortedMapCollectionMapper.java
@@ -1,66 +1,77 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.util.Comparator;
 import java.util.SortedMap;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor.Initializor;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor.SortedMapCollectionInitializor;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 
 /**
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public final class SortedMapCollectionMapper extends MapCollectionMapper<SortedMap> {
 	private final Comparator comparator;
 
 	public SortedMapCollectionMapper(
 			CommonCollectionMapperData commonCollectionMapperData,
 			Class<? extends SortedMap> collectionClass, Class<? extends SortedMap> proxyClass,
 			MiddleComponentData elementComponentData, MiddleComponentData indexComponentData, Comparator comparator,
 			boolean revisionTypeInId) {
 		super(
 				commonCollectionMapperData,
 				collectionClass,
 				proxyClass,
 				elementComponentData,
 				indexComponentData,
 				revisionTypeInId
 		);
 		this.comparator = comparator;
 	}
 
 	@Override
 	protected Initializor<SortedMap> getInitializor(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader,
-			Object primaryKey, Number revision, boolean removed) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			Object primaryKey,
+			Number revision,
+			boolean removed) {
 		return new SortedMapCollectionInitializor(
-				verCfg, versionsReader, commonCollectionMapperData.getQueryGenerator(),
-				primaryKey, revision, removed, collectionClass, elementComponentData, indexComponentData, comparator
+				enversService,
+				versionsReader,
+				commonCollectionMapperData.getQueryGenerator(),
+				primaryKey,
+				revision,
+				removed,
+				collectionClass,
+				elementComponentData,
+				indexComponentData,
+				comparator
 		);
 	}
 
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/SortedSetCollectionMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/SortedSetCollectionMapper.java
index fd275143e2..a28a1ba059 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/SortedSetCollectionMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/SortedSetCollectionMapper.java
@@ -1,65 +1,75 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.util.Comparator;
 import java.util.SortedSet;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor.Initializor;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor.SortedSetCollectionInitializor;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 
 /**
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public final class SortedSetCollectionMapper extends BasicCollectionMapper<SortedSet> {
 	private final Comparator comparator;
 
 	public SortedSetCollectionMapper(
 			CommonCollectionMapperData commonCollectionMapperData,
 			Class<? extends SortedSet> collectionClass, Class<? extends SortedSet> proxyClass,
 			MiddleComponentData elementComponentData, Comparator comparator, boolean ordinalInId,
 			boolean revisionTypeInId) {
 		super(
 				commonCollectionMapperData,
 				collectionClass,
 				proxyClass,
 				elementComponentData,
 				ordinalInId,
 				revisionTypeInId
 		);
 		this.comparator = comparator;
 	}
 
 	@Override
 	protected Initializor<SortedSet> getInitializor(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader,
-			Object primaryKey, Number revision, boolean removed) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			Object primaryKey,
+			Number revision,
+			boolean removed) {
 		return new SortedSetCollectionInitializor(
-				verCfg, versionsReader, commonCollectionMapperData.getQueryGenerator(),
-				primaryKey, revision, removed, collectionClass, elementComponentData, comparator
+				enversService,
+				versionsReader,
+				commonCollectionMapperData.getQueryGenerator(),
+				primaryKey,
+				revision,
+				removed,
+				collectionClass,
+				elementComponentData,
+				comparator
 		);
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ToOneEntityLoader.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ToOneEntityLoader.java
index d26d43e3f8..2f70bd6fc6 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ToOneEntityLoader.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ToOneEntityLoader.java
@@ -1,104 +1,104 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.io.Serializable;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.mapper.relation.lazy.ToOneDelegateSessionImplementor;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public final class ToOneEntityLoader {
 	private ToOneEntityLoader() {
 	}
 
 	/**
 	 * Immediately loads historical entity or its current state when excluded from audit process. Returns {@code null}
 	 * reference if entity has not been found in the database.
 	 */
 	public static Object loadImmediate(
 			AuditReaderImplementor versionsReader,
 			Class<?> entityClass,
 			String entityName,
 			Object entityId,
 			Number revision,
 			boolean removed,
-			AuditConfiguration verCfg) {
-		if ( verCfg.getEntCfg().getNotVersionEntityConfiguration( entityName ) == null ) {
+			EnversService enversService) {
+		if ( enversService.getEntitiesConfigurations().getNotVersionEntityConfiguration( entityName ) == null ) {
 			// Audited relation, look up entity with Envers.
 			// When user traverses removed entities graph, do not restrict revision type of referencing objects
 			// to ADD or MOD (DEL possible). See HHH-5845.
 			return versionsReader.find( entityClass, entityName, entityId, revision, removed );
 		}
 		else {
 			// Not audited relation, look up entity with Hibernate.
 			return versionsReader.getSessionImplementor().immediateLoad( entityName, (Serializable) entityId );
 		}
 	}
 
 	/**
 	 * Creates proxy of referenced *-to-one entity.
 	 */
 	public static Object createProxy(
 			AuditReaderImplementor versionsReader,
 			Class<?> entityClass,
 			String entityName,
 			Object entityId,
 			Number revision,
 			boolean removed,
-			AuditConfiguration verCfg) {
+			EnversService enversService) {
 		final EntityPersister persister = versionsReader.getSessionImplementor()
 				.getFactory()
 				.getEntityPersister( entityName );
 		return persister.createProxy(
 				(Serializable) entityId,
-				new ToOneDelegateSessionImplementor( versionsReader, entityClass, entityId, revision, removed, verCfg )
+				new ToOneDelegateSessionImplementor( versionsReader, entityClass, entityId, revision, removed, enversService )
 		);
 	}
 
 	/**
 	 * Creates Hibernate proxy or retrieves the complete object of an entity if proxy is not
 	 * allowed (e.g. @Proxy(lazy=false), final class).
 	 */
 	public static Object createProxyOrLoadImmediate(
 			AuditReaderImplementor versionsReader,
 			Class<?> entityClass,
 			String entityName,
 			Object entityId,
 			Number revision,
 			boolean removed,
-			AuditConfiguration verCfg) {
+			EnversService enversService) {
 		final EntityPersister persister = versionsReader.getSessionImplementor()
 				.getFactory()
 				.getEntityPersister( entityName );
 		if ( persister.hasProxy() ) {
-			return createProxy( versionsReader, entityClass, entityName, entityId, revision, removed, verCfg );
+			return createProxy( versionsReader, entityClass, entityName, entityId, revision, removed, enversService );
 		}
-		return loadImmediate( versionsReader, entityClass, entityName, entityId, revision, removed, verCfg );
+		return loadImmediate( versionsReader, entityClass, entityName, entityId, revision, removed, enversService );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ToOneIdMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ToOneIdMapper.java
index 2f5b85c24f..a49f39a771 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ToOneIdMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/ToOneIdMapper.java
@@ -1,138 +1,164 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation;
 
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.RevisionType;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.entities.mapper.id.IdMapper;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.EntityTools;
 import org.hibernate.envers.internal.tools.query.Parameters;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public class ToOneIdMapper extends AbstractToOneMapper {
 	private final IdMapper delegate;
 	private final String referencedEntityName;
 	private final boolean nonInsertableFake;
 
-	public ToOneIdMapper(IdMapper delegate, PropertyData propertyData, String referencedEntityName,
-						 boolean nonInsertableFake) {
+	public ToOneIdMapper(
+			IdMapper delegate,
+			PropertyData propertyData,
+			String referencedEntityName,
+			boolean nonInsertableFake) {
 		super( propertyData );
 		this.delegate = delegate;
 		this.referencedEntityName = referencedEntityName;
 		this.nonInsertableFake = nonInsertableFake;
 	}
 
 	@Override
-	public boolean mapToMapFromEntity(SessionImplementor session, Map<String, Object> data, Object newObj,
-									  Object oldObj) {
+	public boolean mapToMapFromEntity(
+			SessionImplementor session,
+			Map<String, Object> data,
+			Object newObj,
+			Object oldObj) {
 		final HashMap<String, Object> newData = new HashMap<String, Object>();
 
 		// If this property is originally non-insertable, but made insertable because it is in a many-to-one "fake"
 		// bi-directional relation, we always store the "old", unchaged data, to prevent storing changes made
 		// to this field. It is the responsibility of the collection to properly update it if it really changed.
 		delegate.mapToMapFromEntity( newData, nonInsertableFake ? oldObj : newObj );
 
 		for ( Map.Entry<String, Object> entry : newData.entrySet() ) {
 			data.put( entry.getKey(), entry.getValue() );
 		}
 
 		return checkModified( session, newObj, oldObj );
 	}
 
 	@Override
-	public void mapModifiedFlagsToMapFromEntity(SessionImplementor session, Map<String, Object> data, Object newObj,
-												Object oldObj) {
+	public void mapModifiedFlagsToMapFromEntity(
+			SessionImplementor session,
+			Map<String, Object> data,
+			Object newObj,
+			Object oldObj) {
 		if ( getPropertyData().isUsingModifiedFlag() ) {
 			data.put( getPropertyData().getModifiedFlagPropertyName(), checkModified( session, newObj, oldObj ) );
 		}
 	}
 
 	@Override
 	public void mapModifiedFlagsToMapForCollectionChange(String collectionPropertyName, Map<String, Object> data) {
 		if ( getPropertyData().isUsingModifiedFlag() ) {
 			data.put(
 					getPropertyData().getModifiedFlagPropertyName(),
 					collectionPropertyName.equals( getPropertyData().getName() )
 			);
 		}
 	}
 
 	protected boolean checkModified(SessionImplementor session, Object newObj, Object oldObj) {
 		//noinspection SimplifiableConditionalExpression
 		return nonInsertableFake ? false : !EntityTools.entitiesEqual( session, referencedEntityName, newObj, oldObj );
 	}
 
 	@Override
-	public void nullSafeMapToEntityFromMap(AuditConfiguration verCfg, Object obj, Map data, Object primaryKey,
-										   AuditReaderImplementor versionsReader, Number revision) {
+	public void nullSafeMapToEntityFromMap(
+			EnversService enversService,
+			Object obj,
+			Map data,
+			Object primaryKey,
+			AuditReaderImplementor versionsReader,
+			Number revision) {
 		final Object entityId = delegate.mapToIdFromMap( data );
 		Object value = null;
 		if ( entityId != null ) {
 			if ( versionsReader.getFirstLevelCache().contains( referencedEntityName, revision, entityId ) ) {
 				value = versionsReader.getFirstLevelCache().get( referencedEntityName, revision, entityId );
 			}
 			else {
-				final EntityInfo referencedEntity = getEntityInfo( verCfg, referencedEntityName );
+				final EntityInfo referencedEntity = getEntityInfo( enversService, referencedEntityName );
 				boolean ignoreNotFound = false;
 				if ( !referencedEntity.isAudited() ) {
-					final String referencingEntityName = verCfg.getEntCfg().getEntityNameForVersionsEntityName( (String) data.get( "$type$" ) );
-					ignoreNotFound = verCfg.getEntCfg().getRelationDescription( referencingEntityName, getPropertyData().getName() ).isIgnoreNotFound();
+					final String referencingEntityName = enversService.getEntitiesConfigurations().getEntityNameForVersionsEntityName( (String) data.get( "$type$" ) );
+					ignoreNotFound = enversService.getEntitiesConfigurations().getRelationDescription( referencingEntityName, getPropertyData().getName() ).isIgnoreNotFound();
 				}
 				if ( ignoreNotFound ) {
 					// Eagerly loading referenced entity to silence potential (in case of proxy)
 					// EntityNotFoundException or ObjectNotFoundException. Assigning null reference.
 					value = ToOneEntityLoader.loadImmediate(
-							versionsReader, referencedEntity.getEntityClass(), referencedEntityName,
-							entityId, revision, RevisionType.DEL.equals( data.get( verCfg.getAuditEntCfg().getRevisionTypePropName() ) ),
-							verCfg
+							versionsReader,
+							referencedEntity.getEntityClass(),
+							referencedEntityName,
+							entityId,
+							revision,
+							RevisionType.DEL.equals( data.get( enversService.getAuditEntitiesConfiguration().getRevisionTypePropName() ) ),
+							enversService
 					);
 				}
 				else {
 					value = ToOneEntityLoader.createProxyOrLoadImmediate(
-							versionsReader, referencedEntity.getEntityClass(), referencedEntityName,
-							entityId, revision, RevisionType.DEL.equals( data.get( verCfg.getAuditEntCfg().getRevisionTypePropName() ) ),
-							verCfg
+							versionsReader,
+							referencedEntity.getEntityClass(),
+							referencedEntityName,
+							entityId,
+							revision,
+							RevisionType.DEL.equals( data.get( enversService.getAuditEntitiesConfiguration().getRevisionTypePropName() ) ),
+							enversService
 					);
 				}
 			}
 		}
 
 		setPropertyValue( obj, value );
 	}
 
-	public void addMiddleEqualToQuery(Parameters parameters, String idPrefix1, String prefix1,
-									  String idPrefix2, String prefix2) {
+	public void addMiddleEqualToQuery(
+			Parameters parameters,
+			String idPrefix1,
+			String prefix1,
+			String idPrefix2,
+			String prefix2) {
 		delegate.addIdsEqualToQuery( parameters, prefix1, delegate, prefix2 );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/component/MiddleEmbeddableComponentMapper.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/component/MiddleEmbeddableComponentMapper.java
index 402a42d917..c5297a92ab 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/component/MiddleEmbeddableComponentMapper.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/component/MiddleEmbeddableComponentMapper.java
@@ -1,149 +1,153 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation.component;
 
 import java.util.Map;
 
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.EntityInstantiator;
 import org.hibernate.envers.internal.entities.PropertyData;
 import org.hibernate.envers.internal.entities.mapper.CompositeMapperBuilder;
 import org.hibernate.envers.internal.entities.mapper.MultiPropertyMapper;
 import org.hibernate.envers.internal.entities.mapper.PropertyMapper;
 import org.hibernate.envers.internal.entities.mapper.relation.ToOneIdMapper;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.internal.util.ReflectHelper;
 
 /**
  * @author Kristoffer Lundberg (kristoffer at cambio dot se)
  */
 public class MiddleEmbeddableComponentMapper implements MiddleComponentMapper, CompositeMapperBuilder {
 	private final MultiPropertyMapper delegate;
 	private final Class componentClass;
 
 	public MiddleEmbeddableComponentMapper(MultiPropertyMapper delegate, Class componentClass) {
 		this.delegate = delegate;
 		this.componentClass = componentClass;
 	}
 
 	@Override
 	public Object mapToObjectFromFullMap(
 			EntityInstantiator entityInstantiator,
 			Map<String, Object> data,
 			Object dataObject,
 			Number revision) {
 		try {
-			final Object componentInstance = dataObject != null ? dataObject : ReflectHelper.getDefaultConstructor(
-					componentClass
-			).newInstance();
+			final Object componentInstance = dataObject != null
+					? dataObject
+					: ReflectHelper.getDefaultConstructor( componentClass ).newInstance();
 			delegate.mapToEntityFromMap(
-					entityInstantiator.getAuditConfiguration(), componentInstance, data, null,
-					entityInstantiator.getAuditReaderImplementor(), revision
+					entityInstantiator.getEnversService(),
+					componentInstance,
+					data,
+					null,
+					entityInstantiator.getAuditReaderImplementor(),
+					revision
 			);
 			return componentInstance;
 		}
 		catch (Exception e) {
 			throw new AuditException( e );
 		}
 	}
 
 	@Override
 	public void mapToMapFromObject(
 			SessionImplementor session,
 			Map<String, Object> idData,
 			Map<String, Object> data,
 			Object obj) {
 		delegate.mapToMapFromEntity( session, data, obj, obj );
 	}
 
 	@Override
 	public void addMiddleEqualToQuery(
 			Parameters parameters,
 			String idPrefix1,
 			String prefix1,
 			String idPrefix2,
 			String prefix2) {
 		addMiddleEqualToQuery( delegate, parameters, idPrefix1, prefix1, idPrefix2, prefix2 );
 	}
 
 	protected void addMiddleEqualToQuery(
 			CompositeMapperBuilder compositeMapper,
 			Parameters parameters,
 			String idPrefix1,
 			String prefix1,
 			String idPrefix2,
 			String prefix2) {
 		for ( final Map.Entry<PropertyData, PropertyMapper> entry : compositeMapper.getProperties().entrySet() ) {
 			final String propertyName = entry.getKey().getName();
 			final PropertyMapper nestedMapper = entry.getValue();
 			if ( nestedMapper instanceof CompositeMapperBuilder ) {
 				addMiddleEqualToQuery(
 						(CompositeMapperBuilder) nestedMapper,
 						parameters,
 						idPrefix1,
 						prefix1,
 						idPrefix2,
 						prefix2
 				);
 			}
 			else if ( nestedMapper instanceof ToOneIdMapper ) {
 				((ToOneIdMapper) nestedMapper).addMiddleEqualToQuery(
 						parameters,
 						idPrefix1,
 						prefix1,
 						idPrefix2,
 						prefix2
 				);
 			}
 			else {
 				// (p1.prop = p2.prop or (p1.prop is null and p2.prop is null))
 				Parameters sub1 = parameters.addSubParameters( "or" );
 				sub1.addWhere( prefix1 + '.' + propertyName, false, "=", prefix2 + '.' + propertyName, false );
 				Parameters sub2 = sub1.addSubParameters( "and" );
 				sub2.addNullRestriction( prefix1 + '.' + propertyName, false );
 				sub2.addNullRestriction( prefix2 + '.' + propertyName, false );
 			}
 		}
 	}
 
 	@Override
 	public CompositeMapperBuilder addComponent(PropertyData propertyData, Class componentClass) {
 		return delegate.addComponent( propertyData, componentClass );
 	}
 
 	@Override
 	public void addComposite(PropertyData propertyData, PropertyMapper propertyMapper) {
 		delegate.addComposite( propertyData, propertyMapper );
 	}
 
 	@Override
 	public void add(PropertyData propertyData) {
 		delegate.add( propertyData );
 	}
 
 	public Map<PropertyData, PropertyMapper> getProperties() {
 		return delegate.getProperties();
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/ToOneDelegateSessionImplementor.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/ToOneDelegateSessionImplementor.java
index 23f1855490..8c9dd83ecc 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/ToOneDelegateSessionImplementor.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/ToOneDelegateSessionImplementor.java
@@ -1,71 +1,74 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation.lazy;
 
 import org.hibernate.HibernateException;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.mapper.relation.ToOneEntityLoader;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Tomasz Bech
  * @author Hernn Chanfreau
  */
 public class ToOneDelegateSessionImplementor extends AbstractDelegateSessionImplementor {
 	private static final long serialVersionUID = 4770438372940785488L;
 
 	private final AuditReaderImplementor versionsReader;
 	private final Class<?> entityClass;
 	private final Object entityId;
 	private final Number revision;
 	private final boolean removed;
-	private final AuditConfiguration verCfg;
+	private final EnversService enversService;
 
 	public ToOneDelegateSessionImplementor(
 			AuditReaderImplementor versionsReader,
-			Class<?> entityClass, Object entityId, Number revision, boolean removed,
-			AuditConfiguration verCfg) {
+			Class<?> entityClass,
+			Object entityId,
+			Number revision,
+			boolean removed,
+			EnversService enversService) {
 		super( versionsReader.getSessionImplementor() );
 		this.versionsReader = versionsReader;
 		this.entityClass = entityClass;
 		this.entityId = entityId;
 		this.revision = revision;
 		this.removed = removed;
-		this.verCfg = verCfg;
+		this.enversService = enversService;
 	}
 
 	@Override
 	public Object doImmediateLoad(String entityName) throws HibernateException {
 		return ToOneEntityLoader.loadImmediate(
 				versionsReader,
 				entityClass,
 				entityName,
 				entityId,
 				revision,
 				removed,
-				verCfg
+				enversService
 		);
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/AbstractCollectionInitializor.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/AbstractCollectionInitializor.java
index 55f91f2542..b82e24b2e7 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/AbstractCollectionInitializor.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/AbstractCollectionInitializor.java
@@ -1,76 +1,76 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor;
 
 import java.util.List;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.EntityInstantiator;
 import org.hibernate.envers.internal.entities.mapper.relation.query.RelationQueryGenerator;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 
 /**
  * Initializes a persistent collection.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public abstract class AbstractCollectionInitializor<T> implements Initializor<T> {
 	private final AuditReaderImplementor versionsReader;
 	private final RelationQueryGenerator queryGenerator;
 	private final Object primaryKey;
 	protected final Number revision;
 	protected final boolean removed;
 	protected final EntityInstantiator entityInstantiator;
 
 	public AbstractCollectionInitializor(
-			AuditConfiguration verCfg,
+			EnversService enversService,
 			AuditReaderImplementor versionsReader,
 			RelationQueryGenerator queryGenerator,
 			Object primaryKey, Number revision, boolean removed) {
 		this.versionsReader = versionsReader;
 		this.queryGenerator = queryGenerator;
 		this.primaryKey = primaryKey;
 		this.revision = revision;
 		this.removed = removed;
 
-		entityInstantiator = new EntityInstantiator( verCfg, versionsReader );
+		entityInstantiator = new EntityInstantiator( enversService, versionsReader );
 	}
 
 	protected abstract T initializeCollection(int size);
 
 	protected abstract void addToCollection(T collection, Object collectionRow);
 
 	@Override
 	public T initialize() {
 		final List<?> collectionContent = queryGenerator.getQuery( versionsReader, primaryKey, revision, removed ).list();
 
 		final T collection = initializeCollection( collectionContent.size() );
 
 		for ( Object collectionRow : collectionContent ) {
 			addToCollection( collection, collectionRow );
 		}
 
 		return collection;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/ArrayCollectionInitializor.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/ArrayCollectionInitializor.java
index 4923f4250d..94511ee3d1 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/ArrayCollectionInitializor.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/ArrayCollectionInitializor.java
@@ -1,79 +1,79 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor;
 
 import java.util.List;
 import java.util.Map;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleComponentData;
 import org.hibernate.envers.internal.entities.mapper.relation.query.RelationQueryGenerator;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 
 /**
  * Initializes a map.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public class ArrayCollectionInitializor extends AbstractCollectionInitializor<Object[]> {
 	private final MiddleComponentData elementComponentData;
 	private final MiddleComponentData indexComponentData;
 
 	public ArrayCollectionInitializor(
-			AuditConfiguration verCfg,
+			EnversService enversService,
 			AuditReaderImplementor versionsReader,
 			RelationQueryGenerator queryGenerator,
 			Object primaryKey, Number revision, boolean removed,
 			MiddleComponentData elementComponentData,
 			MiddleComponentData indexComponentData) {
-		super( verCfg, versionsReader, queryGenerator, primaryKey, revision, removed );
+		super( enversService, versionsReader, queryGenerator, primaryKey, revision, removed );
 
 		this.elementComponentData = elementComponentData;
 		this.indexComponentData = indexComponentData;
 	}
 
 	@Override
 	protected Object[] initializeCollection(int size) {
 		return new Object[size];
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	protected void addToCollection(Object[] collection, Object collectionRow) {
 		final Object elementData = ((List) collectionRow).get( elementComponentData.getComponentIndex() );
 		final Object element = elementComponentData.getComponentMapper().mapToObjectFromFullMap(
 				entityInstantiator,
 				(Map<String, Object>) elementData, null, revision
 		);
 
 		final Object indexData = ((List) collectionRow).get( indexComponentData.getComponentIndex() );
 		final Object indexObj = indexComponentData.getComponentMapper().mapToObjectFromFullMap(
 				entityInstantiator,
 				(Map<String, Object>) indexData, element, revision
 		);
 		final int index = ((Number) indexObj).intValue();
 
 		collection[index] = element;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/BasicCollectionInitializor.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/BasicCollectionInitializor.java
index 754b918099..c50f0b594b 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/BasicCollectionInitializor.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/BasicCollectionInitializor.java
@@ -1,101 +1,101 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor;
 
 import java.lang.reflect.InvocationTargetException;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleComponentData;
 import org.hibernate.envers.internal.entities.mapper.relation.query.RelationQueryGenerator;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.internal.util.ReflectHelper;
 
 /**
  * Initializes a non-indexed java collection (set or list, eventually sorted).
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public class BasicCollectionInitializor<T extends Collection> extends AbstractCollectionInitializor<T> {
 	protected final Class<? extends T> collectionClass;
 	private final MiddleComponentData elementComponentData;
 
 	public BasicCollectionInitializor(
-			AuditConfiguration verCfg,
+			EnversService enversService,
 			AuditReaderImplementor versionsReader,
 			RelationQueryGenerator queryGenerator,
 			Object primaryKey, Number revision, boolean removed,
 			Class<? extends T> collectionClass,
 			MiddleComponentData elementComponentData) {
-		super( verCfg, versionsReader, queryGenerator, primaryKey, revision, removed );
+		super( enversService, versionsReader, queryGenerator, primaryKey, revision, removed );
 
 		this.collectionClass = collectionClass;
 		this.elementComponentData = elementComponentData;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	protected T initializeCollection(int size) {
 		try {
 			return (T) ReflectHelper.getDefaultConstructor( collectionClass ).newInstance();
 		}
 		catch (InstantiationException e) {
 			throw new AuditException( e );
 		}
 		catch (IllegalAccessException e) {
 			throw new AuditException( e );
 		}
 		catch (InvocationTargetException e) {
 			throw new AuditException( e );
 		}
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	protected void addToCollection(T collection, Object collectionRow) {
 		// collectionRow will be the actual object if retrieved from audit relation or middle table
 		// otherwise it will be a List
 		Object elementData = collectionRow;
 		if ( collectionRow instanceof java.util.List ) {
 			elementData = ((List) collectionRow).get( elementComponentData.getComponentIndex() );
 		}
 
 		// If the target entity is not audited, the elements may be the entities already, so we have to check
 		// if they are maps or not.
 		Object element;
 		if ( elementData instanceof Map ) {
 			element = elementComponentData.getComponentMapper().mapToObjectFromFullMap(
 					entityInstantiator,
 					(Map<String, Object>) elementData, null, revision
 			);
 		}
 		else {
 			element = elementData;
 		}
 		collection.add( element );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/ListCollectionInitializor.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/ListCollectionInitializor.java
index 851254631d..3205a5edb8 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/ListCollectionInitializor.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/ListCollectionInitializor.java
@@ -1,95 +1,97 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleComponentData;
 import org.hibernate.envers.internal.entities.mapper.relation.query.RelationQueryGenerator;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 
 /**
  * Initializes a map.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public class ListCollectionInitializor extends AbstractCollectionInitializor<List> {
 	private final MiddleComponentData elementComponentData;
 	private final MiddleComponentData indexComponentData;
 
 	public ListCollectionInitializor(
-			AuditConfiguration verCfg,
+			EnversService enversService,
 			AuditReaderImplementor versionsReader,
 			RelationQueryGenerator queryGenerator,
-			Object primaryKey, Number revision, boolean removed,
+			Object primaryKey,
+			Number revision,
+			boolean removed,
 			MiddleComponentData elementComponentData,
 			MiddleComponentData indexComponentData) {
-		super( verCfg, versionsReader, queryGenerator, primaryKey, revision, removed );
+		super( enversService, versionsReader, queryGenerator, primaryKey, revision, removed );
 
 		this.elementComponentData = elementComponentData;
 		this.indexComponentData = indexComponentData;
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	protected List initializeCollection(int size) {
 		// Creating a list of the given capacity with all elements null initially. This ensures that we can then
 		// fill the elements safely using the <code>List.set</code> method.
 		final List list = new ArrayList( size );
 		for ( int i = 0; i < size; i++ ) {
 			list.add( null );
 		}
 		return list;
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	protected void addToCollection(List collection, Object collectionRow) {
 		// collectionRow will be the actual object if retrieved from audit relation or middle table
 		// otherwise it will be a List
 		Object elementData = collectionRow;
 		Object indexData = collectionRow;
 		if ( collectionRow instanceof java.util.List ) {
 			elementData = ((List) collectionRow).get( elementComponentData.getComponentIndex() );
 			indexData = ((List) collectionRow).get( indexComponentData.getComponentIndex() );
 		}
 		final Object element = elementData instanceof Map
 				? elementComponentData.getComponentMapper().mapToObjectFromFullMap(
 						entityInstantiator,
 						(Map<String, Object>) elementData, null, revision
 				)
 				: elementData;
 
 		final Object indexObj = indexComponentData.getComponentMapper().mapToObjectFromFullMap(
 				entityInstantiator,
 				(Map<String, Object>) indexData, element, revision
 		);
 		final int index = ((Number) indexObj).intValue();
 
 		collection.set( index, element );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/MapCollectionInitializor.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/MapCollectionInitializor.java
index f6d1c34104..be0ed1ac57 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/MapCollectionInitializor.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/MapCollectionInitializor.java
@@ -1,102 +1,102 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor;
 
 import java.lang.reflect.InvocationTargetException;
 import java.util.List;
 import java.util.Map;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleComponentData;
 import org.hibernate.envers.internal.entities.mapper.relation.query.RelationQueryGenerator;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.internal.util.ReflectHelper;
 
 /**
  * Initializes a map.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public class MapCollectionInitializor<T extends Map> extends AbstractCollectionInitializor<T> {
 	protected final Class<? extends T> collectionClass;
 	private final MiddleComponentData elementComponentData;
 	private final MiddleComponentData indexComponentData;
 
 	public MapCollectionInitializor(
-			AuditConfiguration verCfg,
+			EnversService enversService,
 			AuditReaderImplementor versionsReader,
 			RelationQueryGenerator queryGenerator,
 			Object primaryKey, Number revision, boolean removed,
 			Class<? extends T> collectionClass,
 			MiddleComponentData elementComponentData,
 			MiddleComponentData indexComponentData) {
-		super( verCfg, versionsReader, queryGenerator, primaryKey, revision, removed );
+		super( enversService, versionsReader, queryGenerator, primaryKey, revision, removed );
 
 		this.collectionClass = collectionClass;
 		this.elementComponentData = elementComponentData;
 		this.indexComponentData = indexComponentData;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	protected T initializeCollection(int size) {
 		try {
 			return (T) ReflectHelper.getDefaultConstructor( collectionClass ).newInstance();
 		}
 		catch (InstantiationException e) {
 			throw new AuditException( e );
 		}
 		catch (IllegalAccessException e) {
 			throw new AuditException( e );
 		}
 		catch (InvocationTargetException e) {
 			throw new AuditException( e );
 		}
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	protected void addToCollection(T collection, Object collectionRow) {
 		// collectionRow will be the actual object if retrieved from audit relation or middle table
 		// otherwise it will be a List
 		Object elementData = collectionRow;
 		Object indexData = collectionRow;
 		if ( collectionRow instanceof java.util.List ) {
 			elementData = ((List) collectionRow).get( elementComponentData.getComponentIndex() );
 			indexData = ((List) collectionRow).get( indexComponentData.getComponentIndex() );
 		}
 		final Object element = elementComponentData.getComponentMapper().mapToObjectFromFullMap(
 				entityInstantiator,
 				(Map<String, Object>) elementData, null, revision
 		);
 
 		final Object index = indexComponentData.getComponentMapper().mapToObjectFromFullMap(
 				entityInstantiator,
 				(Map<String, Object>) indexData, element, revision
 		);
 
 		collection.put( index, element );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/SortedMapCollectionInitializor.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/SortedMapCollectionInitializor.java
index 562d4f3546..a2ce9fd807 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/SortedMapCollectionInitializor.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/SortedMapCollectionInitializor.java
@@ -1,88 +1,88 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor;
 
 import java.lang.reflect.InvocationTargetException;
 import java.util.Comparator;
 import java.util.SortedMap;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleComponentData;
 import org.hibernate.envers.internal.entities.mapper.relation.query.RelationQueryGenerator;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 
 /**
  * Initializes SortedMap collection with proper Comparator
  *
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public class SortedMapCollectionInitializor extends MapCollectionInitializor<SortedMap> {
 	private final Comparator comparator;
 
 	public SortedMapCollectionInitializor(
-			AuditConfiguration verCfg,
+			EnversService enversService,
 			AuditReaderImplementor versionsReader,
 			RelationQueryGenerator queryGenerator,
 			Object primaryKey, Number revision, boolean removed,
 			Class<? extends SortedMap> collectionClass,
 			MiddleComponentData elementComponentData,
 			MiddleComponentData indexComponentData, Comparator comparator) {
 		super(
-				verCfg,
+				enversService,
 				versionsReader,
 				queryGenerator,
 				primaryKey,
 				revision,
 				removed,
 				collectionClass,
 				elementComponentData,
 				indexComponentData
 		);
 		this.comparator = comparator;
 	}
 
 	@Override
 	protected SortedMap initializeCollection(int size) {
 		if ( comparator == null ) {
 			return super.initializeCollection( size );
 		}
 		try {
 			return collectionClass.getConstructor( Comparator.class ).newInstance( comparator );
 		}
 		catch (InstantiationException e) {
 			throw new AuditException( e );
 		}
 		catch (IllegalAccessException e) {
 			throw new AuditException( e );
 		}
 		catch (NoSuchMethodException e) {
 			throw new AuditException( e );
 		}
 		catch (InvocationTargetException e) {
 			throw new AuditException( e );
 		}
 	}
 
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/SortedSetCollectionInitializor.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/SortedSetCollectionInitializor.java
index f171e5f68b..0973b435ba 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/SortedSetCollectionInitializor.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/entities/mapper/relation/lazy/initializor/SortedSetCollectionInitializor.java
@@ -1,83 +1,88 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.entities.mapper.relation.lazy.initializor;
 
 import java.lang.reflect.InvocationTargetException;
 import java.util.Comparator;
 import java.util.SortedSet;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleComponentData;
 import org.hibernate.envers.internal.entities.mapper.relation.query.RelationQueryGenerator;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 
 /**
  * Initializes SortedSet collection with proper Comparator
  *
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public class SortedSetCollectionInitializor extends BasicCollectionInitializor<SortedSet> {
 	private final Comparator comparator;
 
 	public SortedSetCollectionInitializor(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader,
-			RelationQueryGenerator queryGenerator, Object primaryKey, Number revision, boolean removed,
-			Class<? extends SortedSet> collectionClass, MiddleComponentData elementComponentData,
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			RelationQueryGenerator queryGenerator,
+			Object primaryKey,
+			Number revision,
+			boolean removed,
+			Class<? extends SortedSet> collectionClass,
+			MiddleComponentData elementComponentData,
 			Comparator comparator) {
 		super(
-				verCfg,
+				enversService,
 				versionsReader,
 				queryGenerator,
 				primaryKey,
 				revision,
 				removed,
 				collectionClass,
 				elementComponentData
 		);
 		this.comparator = comparator;
 	}
 
 	@Override
 	protected SortedSet initializeCollection(int size) {
 		if ( comparator == null ) {
 			return super.initializeCollection( size );
 		}
 		try {
 			return collectionClass.getConstructor( Comparator.class ).newInstance( comparator );
 		}
 		catch (InstantiationException e) {
 			throw new AuditException( e );
 		}
 		catch (IllegalAccessException e) {
 			throw new AuditException( e );
 		}
 		catch (NoSuchMethodException e) {
 			throw new AuditException( e );
 		}
 		catch (InvocationTargetException e) {
 			throw new AuditException( e );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/reader/AuditReaderImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/reader/AuditReaderImpl.java
index 1e49360dfd..30d99203a1 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/reader/AuditReaderImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/reader/AuditReaderImpl.java
@@ -1,348 +1,349 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.reader;
 
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.persistence.NoResultException;
 
 import org.hibernate.Criteria;
 import org.hibernate.HibernateException;
 import org.hibernate.NonUniqueResultException;
 import org.hibernate.Session;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.CrossTypeRevisionChangesReader;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.exception.NotAuditedException;
 import org.hibernate.envers.exception.RevisionDoesNotExistException;
 import org.hibernate.envers.internal.synchronization.AuditProcess;
 import org.hibernate.envers.query.AuditEntity;
 import org.hibernate.envers.query.AuditQueryCreator;
 import org.hibernate.event.spi.EventSource;
 import org.hibernate.proxy.HibernateProxy;
 
 import static org.hibernate.envers.internal.tools.ArgumentsTools.checkNotNull;
 import static org.hibernate.envers.internal.tools.ArgumentsTools.checkPositive;
 import static org.hibernate.envers.internal.tools.EntityTools.getTargetClassIfProxied;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hern&aacute;n Chanfreau
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class AuditReaderImpl implements AuditReaderImplementor {
-	private final AuditConfiguration verCfg;
+	private final EnversService enversService;
 	private final SessionImplementor sessionImplementor;
 	private final Session session;
 	private final FirstLevelCache firstLevelCache;
 	private final CrossTypeRevisionChangesReader crossTypeRevisionChangesReader;
 
 	public AuditReaderImpl(
-			AuditConfiguration verCfg, Session session,
+			EnversService enversService,
+			Session session,
 			SessionImplementor sessionImplementor) {
-		this.verCfg = verCfg;
+		this.enversService = enversService;
 		this.sessionImplementor = sessionImplementor;
 		this.session = session;
 
 		firstLevelCache = new FirstLevelCache();
-		crossTypeRevisionChangesReader = new CrossTypeRevisionChangesReaderImpl( this, verCfg );
+		crossTypeRevisionChangesReader = new CrossTypeRevisionChangesReaderImpl( this, enversService );
 	}
 
 	private void checkSession() {
 		if ( !session.isOpen() ) {
 			throw new IllegalStateException( "The associated entity manager is closed!" );
 		}
 	}
 
 	@Override
 	public SessionImplementor getSessionImplementor() {
 		return sessionImplementor;
 	}
 
 	@Override
 	public Session getSession() {
 		return session;
 	}
 
 	@Override
 	public FirstLevelCache getFirstLevelCache() {
 		return firstLevelCache;
 	}
 
 	@Override
 	public <T> T find(Class<T> cls, Object primaryKey, Number revision) throws
 			IllegalArgumentException, NotAuditedException, IllegalStateException {
 		cls = getTargetClassIfProxied( cls );
 		return this.find( cls, cls.getName(), primaryKey, revision );
 	}
 
 	@Override
 	public <T> T find(Class<T> cls, String entityName, Object primaryKey, Number revision)
 			throws IllegalArgumentException, NotAuditedException, IllegalStateException {
 		return this.find( cls, entityName, primaryKey, revision, false );
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public <T> T find(
 			Class<T> cls,
 			String entityName,
 			Object primaryKey,
 			Number revision,
 			boolean includeDeletions) throws IllegalArgumentException, NotAuditedException, IllegalStateException {
 		cls = getTargetClassIfProxied( cls );
 		checkNotNull( cls, "Entity class" );
 		checkNotNull( entityName, "Entity name" );
 		checkNotNull( primaryKey, "Primary key" );
 		checkNotNull( revision, "Entity revision" );
 		checkPositive( revision, "Entity revision" );
 		checkSession();
 
-		if ( !verCfg.getEntCfg().isVersioned( entityName ) ) {
+		if ( !enversService.getEntitiesConfigurations().isVersioned( entityName ) ) {
 			throw new NotAuditedException( entityName, entityName + " is not versioned!" );
 		}
 
 		if ( firstLevelCache.contains( entityName, revision, primaryKey ) ) {
 			return (T) firstLevelCache.get( entityName, revision, primaryKey );
 		}
 
 		Object result;
 		try {
 			// The result is put into the cache by the entity instantiator called from the query
 			result = createQuery().forEntitiesAtRevision( cls, entityName, revision, includeDeletions )
 					.add( AuditEntity.id().eq( primaryKey ) ).getSingleResult();
 		}
 		catch (NoResultException e) {
 			result = null;
 		}
 		catch (NonUniqueResultException e) {
 			throw new AuditException( e );
 		}
 
 		return (T) result;
 	}
 
 	@Override
 	public List<Number> getRevisions(Class<?> cls, Object primaryKey)
 			throws IllegalArgumentException, NotAuditedException, IllegalStateException {
 		cls = getTargetClassIfProxied( cls );
 		return this.getRevisions( cls, cls.getName(), primaryKey );
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public List<Number> getRevisions(Class<?> cls, String entityName, Object primaryKey)
 			throws IllegalArgumentException, NotAuditedException, IllegalStateException {
 		// todo: if a class is not versioned from the beginning, there's a missing ADD rev - what then?
 		cls = getTargetClassIfProxied( cls );
 		checkNotNull( cls, "Entity class" );
 		checkNotNull( entityName, "Entity name" );
 		checkNotNull( primaryKey, "Primary key" );
 		checkSession();
 
-		if ( !verCfg.getEntCfg().isVersioned( entityName ) ) {
+		if ( !enversService.getEntitiesConfigurations().isVersioned( entityName ) ) {
 			throw new NotAuditedException( entityName, entityName + " is not versioned!" );
 		}
 
 		return createQuery().forRevisionsOfEntity( cls, entityName, false, true )
 				.addProjection( AuditEntity.revisionNumber() )
 				.addOrder( AuditEntity.revisionNumber().asc() )
 				.add( AuditEntity.id().eq( primaryKey ) )
 				.getResultList();
 	}
 
 	@Override
 	public Date getRevisionDate(Number revision)
 			throws IllegalArgumentException, RevisionDoesNotExistException, IllegalStateException {
 		checkNotNull( revision, "Entity revision" );
 		checkPositive( revision, "Entity revision" );
 		checkSession();
 
-		final Criteria query = verCfg.getRevisionInfoQueryCreator().getRevisionDateQuery( session, revision );
+		final Criteria query = enversService.getRevisionInfoQueryCreator().getRevisionDateQuery( session, revision );
 
 		try {
 			final Object timestampObject = query.uniqueResult();
 			if ( timestampObject == null ) {
 				throw new RevisionDoesNotExistException( revision );
 			}
 
 			// The timestamp object is either a date or a long
 			return timestampObject instanceof Date ? (Date) timestampObject : new Date( (Long) timestampObject );
 		}
 		catch (NonUniqueResultException e) {
 			throw new AuditException( e );
 		}
 	}
 
 	@Override
 	public Number getRevisionNumberForDate(Date date) {
 		checkNotNull( date, "Date of revision" );
 		checkSession();
 
-		final Criteria query = verCfg.getRevisionInfoQueryCreator().getRevisionNumberForDateQuery( session, date );
+		final Criteria query = enversService.getRevisionInfoQueryCreator().getRevisionNumberForDateQuery( session, date );
 
 		try {
 			final Number res = (Number) query.uniqueResult();
 			if ( res == null ) {
 				throw new RevisionDoesNotExistException( date );
 			}
 
 			return res;
 		}
 		catch (NonUniqueResultException e) {
 			throw new AuditException( e );
 		}
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public <T> T findRevision(Class<T> revisionEntityClass, Number revision)
 			throws IllegalArgumentException, RevisionDoesNotExistException, IllegalStateException {
 		revisionEntityClass = getTargetClassIfProxied( revisionEntityClass );
 		checkNotNull( revision, "Entity revision" );
 		checkPositive( revision, "Entity revision" );
 		checkSession();
 
 		final Set<Number> revisions = new HashSet<Number>( 1 );
 		revisions.add( revision );
-		final Criteria query = verCfg.getRevisionInfoQueryCreator().getRevisionsQuery( session, revisions );
+		final Criteria query = enversService.getRevisionInfoQueryCreator().getRevisionsQuery( session, revisions );
 
 		try {
 			final T revisionData = (T) query.uniqueResult();
 
 			if ( revisionData == null ) {
 				throw new RevisionDoesNotExistException( revision );
 			}
 
 			return revisionData;
 		}
 		catch (NonUniqueResultException e) {
 			throw new AuditException( e );
 		}
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public <T> Map<Number, T> findRevisions(Class<T> revisionEntityClass, Set<Number> revisions)
 			throws IllegalArgumentException,
 			IllegalStateException {
 		revisionEntityClass = getTargetClassIfProxied( revisionEntityClass );
 		final Map<Number, T> result = new HashMap<Number, T>( revisions.size() );
 
 		for ( Number revision : revisions ) {
 			checkNotNull( revision, "Entity revision" );
 			checkPositive( revision, "Entity revision" );
 		}
 		checkSession();
 
-		final Criteria query = verCfg.getRevisionInfoQueryCreator().getRevisionsQuery( session, revisions );
+		final Criteria query = enversService.getRevisionInfoQueryCreator().getRevisionsQuery( session, revisions );
 
 		try {
 			final List<T> revisionList = query.list();
 			for ( T revision : revisionList ) {
-				final Number revNo = verCfg.getRevisionInfoNumberReader().getRevisionNumber( revision );
+				final Number revNo = enversService.getRevisionInfoNumberReader().getRevisionNumber( revision );
 				result.put( revNo, revision );
 			}
 
 			return result;
 		}
 		catch (HibernateException e) {
 			throw new AuditException( e );
 		}
 	}
 
 	@Override
 	public CrossTypeRevisionChangesReader getCrossTypeRevisionChangesReader() throws AuditException {
-		if ( !verCfg.getGlobalCfg().isTrackEntitiesChangedInRevision() ) {
+		if ( !enversService.getGlobalConfiguration().isTrackEntitiesChangedInRevision() ) {
 			throw new AuditException(
 					"This API is designed for Envers default mechanism of tracking entities modified in a given revision."
 							+ " Extend DefaultTrackingModifiedEntitiesRevisionEntity, utilize @ModifiedEntityNames annotation or set "
 							+ "'org.hibernate.envers.track_entities_changed_in_revision' parameter to true."
 			);
 		}
 		return crossTypeRevisionChangesReader;
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public <T> T getCurrentRevision(Class<T> revisionEntityClass, boolean persist) {
 		revisionEntityClass = getTargetClassIfProxied( revisionEntityClass );
 		if ( !(session instanceof EventSource) ) {
 			throw new IllegalArgumentException( "The provided session is not an EventSource!" );
 		}
 
 		// Obtaining the current audit sync
-		final AuditProcess auditProcess = verCfg.getSyncManager().get( (EventSource) session );
+		final AuditProcess auditProcess = enversService.getAuditProcessManager().get( (EventSource) session );
 
 		// And getting the current revision data
 		return (T) auditProcess.getCurrentRevisionData( session, persist );
 	}
 
 	@Override
 	public AuditQueryCreator createQuery() {
-		return new AuditQueryCreator( verCfg, this );
+		return new AuditQueryCreator( enversService, this );
 	}
 
 	@Override
 	public boolean isEntityClassAudited(Class<?> entityClass) {
 		entityClass = getTargetClassIfProxied( entityClass );
 		return this.isEntityNameAudited( entityClass.getName() );
 	}
 
 
 	@Override
 	public boolean isEntityNameAudited(String entityName) {
 		checkNotNull( entityName, "Entity name" );
 		checkSession();
-		return (verCfg.getEntCfg().isVersioned( entityName ));
+		return enversService.getEntitiesConfigurations().isVersioned( entityName );
 	}
 
 	@Override
 	public String getEntityName(Object primaryKey, Number revision, Object entity) throws HibernateException {
 		checkNotNull( primaryKey, "Primary key" );
 		checkNotNull( revision, "Entity revision" );
 		checkPositive( revision, "Entity revision" );
 		checkNotNull( entity, "Entity" );
 		checkSession();
 
 		// Unwrap if necessary
 		if ( entity instanceof HibernateProxy ) {
 			entity = ((HibernateProxy) entity).getHibernateLazyInitializer().getImplementation();
 		}
 		if ( firstLevelCache.containsEntityName( primaryKey, revision, entity ) ) {
 			// it's on envers FLC!
 			return firstLevelCache.getFromEntityNameCache( primaryKey, revision, entity );
 		}
 		else {
 			throw new HibernateException(
 					"Envers can't resolve entityName for historic entity. The id, revision and entity is not on envers first level cache."
 			);
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/reader/CrossTypeRevisionChangesReaderImpl.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/reader/CrossTypeRevisionChangesReaderImpl.java
index 6b4ab9619b..d0ebd01993 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/reader/CrossTypeRevisionChangesReaderImpl.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/reader/CrossTypeRevisionChangesReaderImpl.java
@@ -1,162 +1,162 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.reader;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.Criteria;
 import org.hibernate.Session;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.CrossTypeRevisionChangesReader;
 import org.hibernate.envers.RevisionType;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.tools.EntityTools;
 import org.hibernate.envers.query.criteria.internal.RevisionTypeAuditExpression;
 import org.hibernate.envers.tools.Pair;
 
 import static org.hibernate.envers.internal.tools.ArgumentsTools.checkNotNull;
 import static org.hibernate.envers.internal.tools.ArgumentsTools.checkPositive;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class CrossTypeRevisionChangesReaderImpl implements CrossTypeRevisionChangesReader {
 	private final AuditReaderImplementor auditReaderImplementor;
-	private final AuditConfiguration verCfg;
+	private final EnversService enversService;
 
 	public CrossTypeRevisionChangesReaderImpl(
 			AuditReaderImplementor auditReaderImplementor,
-			AuditConfiguration verCfg) {
+			EnversService enversService) {
 		this.auditReaderImplementor = auditReaderImplementor;
-		this.verCfg = verCfg;
+		this.enversService = enversService;
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public List<Object> findEntities(Number revision) throws IllegalStateException, IllegalArgumentException {
 		final Set<Pair<String, Class>> entityTypes = findEntityTypes( revision );
 		final List<Object> result = new ArrayList<Object>();
 		for ( Pair<String, Class> type : entityTypes ) {
 			result.addAll(
 					auditReaderImplementor.createQuery().forEntitiesModifiedAtRevision(
 							type.getSecond(),
 							type.getFirst(),
 							revision
 					)
 							.getResultList()
 			);
 		}
 		return result;
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public List<Object> findEntities(Number revision, RevisionType revisionType)
 			throws IllegalStateException, IllegalArgumentException {
 		final Set<Pair<String, Class>> entityTypes = findEntityTypes( revision );
 		final List<Object> result = new ArrayList<Object>();
 		for ( Pair<String, Class> type : entityTypes ) {
 			result.addAll(
 					auditReaderImplementor.createQuery().forEntitiesModifiedAtRevision(
 							type.getSecond(),
 							type.getFirst(),
 							revision
 					)
 							.add( new RevisionTypeAuditExpression( revisionType, "=" ) ).getResultList()
 			);
 		}
 		return result;
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public Map<RevisionType, List<Object>> findEntitiesGroupByRevisionType(Number revision)
 			throws IllegalStateException, IllegalArgumentException {
 		final Set<Pair<String, Class>> entityTypes = findEntityTypes( revision );
 		final Map<RevisionType, List<Object>> result = new HashMap<RevisionType, List<Object>>();
 		for ( RevisionType revisionType : RevisionType.values() ) {
 			result.put( revisionType, new ArrayList<Object>() );
 			for ( Pair<String, Class> type : entityTypes ) {
 				final List<Object> list = auditReaderImplementor.createQuery()
 						.forEntitiesModifiedAtRevision( type.getSecond(), type.getFirst(), revision )
 						.add( new RevisionTypeAuditExpression( revisionType, "=" ) )
 						.getResultList();
 				result.get( revisionType ).addAll( list );
 			}
 		}
 		return result;
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public Set<Pair<String, Class>> findEntityTypes(Number revision)
 			throws IllegalStateException, IllegalArgumentException {
 		checkNotNull( revision, "Entity revision" );
 		checkPositive( revision, "Entity revision" );
 		checkSession();
 
 		final Session session = auditReaderImplementor.getSession();
 		final SessionImplementor sessionImplementor = auditReaderImplementor.getSessionImplementor();
 
 		final Set<Number> revisions = new HashSet<Number>( 1 );
 		revisions.add( revision );
-		final Criteria query = verCfg.getRevisionInfoQueryCreator().getRevisionsQuery( session, revisions );
+		final Criteria query = enversService.getRevisionInfoQueryCreator().getRevisionsQuery( session, revisions );
 		final Object revisionInfo = query.uniqueResult();
 
 		if ( revisionInfo != null ) {
 			// If revision exists.
-			final Set<String> entityNames = verCfg.getModifiedEntityNamesReader().getModifiedEntityNames( revisionInfo );
+			final Set<String> entityNames = enversService.getModifiedEntityNamesReader().getModifiedEntityNames( revisionInfo );
 			if ( entityNames != null ) {
 				// Generate result that contains entity names and corresponding Java classes.
 				final Set<Pair<String, Class>> result = new HashSet<Pair<String, Class>>();
 				for ( String entityName : entityNames ) {
 					result.add(
 							Pair.make(
 									entityName, EntityTools.getEntityClass(
 									sessionImplementor,
 									session,
 									entityName
 							)
 							)
 					);
 				}
 				return result;
 			}
 		}
 
 		return Collections.EMPTY_SET;
 	}
 
 	private void checkSession() {
 		if ( !auditReaderImplementor.getSession().isOpen() ) {
 			throw new IllegalStateException( "The associated entity manager is closed!" );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/AbstractAuditWorkUnit.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/AbstractAuditWorkUnit.java
index 4c58b34f46..698c1760e2 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/AbstractAuditWorkUnit.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/AbstractAuditWorkUnit.java
@@ -1,113 +1,119 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.synchronization.work;
 
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hibernate.Session;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.RevisionType;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.configuration.internal.AuditEntitiesConfiguration;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
 import org.hibernate.envers.strategy.AuditStrategy;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Stephanie Pau at Markit Group Plc
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public abstract class AbstractAuditWorkUnit implements AuditWorkUnit {
 	protected final SessionImplementor sessionImplementor;
-	protected final AuditConfiguration verCfg;
+	protected final EnversService enversService;
 	protected final Serializable id;
 	protected final String entityName;
 	protected final AuditStrategy auditStrategy;
 	protected final RevisionType revisionType;
 
 	private Object performedData;
 
 	protected AbstractAuditWorkUnit(
-			SessionImplementor sessionImplementor, String entityName, AuditConfiguration verCfg,
-			Serializable id, RevisionType revisionType) {
+			SessionImplementor sessionImplementor,
+			String entityName,
+			EnversService enversService,
+			Serializable id,
+			RevisionType revisionType) {
 		this.sessionImplementor = sessionImplementor;
-		this.verCfg = verCfg;
+		this.enversService = enversService;
 		this.id = id;
 		this.entityName = entityName;
 		this.revisionType = revisionType;
-		this.auditStrategy = verCfg.getAuditStrategy();
+		this.auditStrategy = enversService.getAuditStrategy();
 	}
 
 	protected void fillDataWithId(Map<String, Object> data, Object revision) {
-		final AuditEntitiesConfiguration entitiesCfg = verCfg.getAuditEntCfg();
+		final AuditEntitiesConfiguration entitiesCfg = enversService.getAuditEntitiesConfiguration();
 
 		final Map<String, Object> originalId = new HashMap<String, Object>();
 		originalId.put( entitiesCfg.getRevisionFieldName(), revision );
 
-		verCfg.getEntCfg().get( getEntityName() ).getIdMapper().mapToMapFromId( originalId, id );
+		enversService.getEntitiesConfigurations().get( getEntityName() ).getIdMapper().mapToMapFromId( originalId, id );
 		data.put( entitiesCfg.getRevisionTypePropName(), revisionType );
 		data.put( entitiesCfg.getOriginalIdPropName(), originalId );
 	}
 
 	@Override
 	public void perform(Session session, Object revisionData) {
 		final Map<String, Object> data = generateData( revisionData );
 
-		auditStrategy.perform( session, getEntityName(), verCfg, id, data, revisionData );
+		auditStrategy.perform( session, getEntityName(), enversService, id, data, revisionData );
 
 		setPerformed( data );
 	}
 
 	@Override
 	public Serializable getEntityId() {
 		return id;
 	}
 
 	@Override
 	public boolean isPerformed() {
 		return performedData != null;
 	}
 
 	@Override
 	public String getEntityName() {
 		return entityName;
 	}
 
 	protected void setPerformed(Object performedData) {
 		this.performedData = performedData;
 	}
 
 	public void undo(Session session) {
 		if ( isPerformed() ) {
-			session.delete( verCfg.getAuditEntCfg().getAuditEntityName( getEntityName() ), performedData );
+			session.delete(
+					enversService.getAuditEntitiesConfiguration().getAuditEntityName( getEntityName() ),
+					performedData
+			);
 			session.flush();
 		}
 	}
 
 	@Override
 	public RevisionType getRevisionType() {
 		return revisionType;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/AddWorkUnit.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/AddWorkUnit.java
index e36a021665..20e5a0a06f 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/AddWorkUnit.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/AddWorkUnit.java
@@ -1,114 +1,122 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.synchronization.work;
 
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.RevisionType;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.tools.ArraysTools;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class AddWorkUnit extends AbstractAuditWorkUnit implements AuditWorkUnit {
 	private final Object[] state;
 	private final Map<String, Object> data;
 
 	public AddWorkUnit(
-			SessionImplementor sessionImplementor, String entityName, AuditConfiguration verCfg,
+			SessionImplementor sessionImplementor,
+			String entityName,
+			EnversService enversService,
 			Serializable id, EntityPersister entityPersister, Object[] state) {
-		super( sessionImplementor, entityName, verCfg, id, RevisionType.ADD );
+		super( sessionImplementor, entityName, enversService, id, RevisionType.ADD );
 
 		this.data = new HashMap<String, Object>();
 		this.state = state;
-		this.verCfg.getEntCfg().get( getEntityName() ).getPropertyMapper().map(
-				sessionImplementor, data,
-				entityPersister.getPropertyNames(), state, null
+		this.enversService.getEntitiesConfigurations().get( getEntityName() ).getPropertyMapper().map(
+				sessionImplementor,
+				data,
+				entityPersister.getPropertyNames(),
+				state,
+				null
 		);
 	}
 
 	public AddWorkUnit(
-			SessionImplementor sessionImplementor, String entityName, AuditConfiguration verCfg,
-			Serializable id, Map<String, Object> data) {
-		super( sessionImplementor, entityName, verCfg, id, RevisionType.ADD );
+			SessionImplementor sessionImplementor,
+			String entityName,
+			EnversService enversService,
+			Serializable id,
+			Map<String, Object> data) {
+		super( sessionImplementor, entityName, enversService, id, RevisionType.ADD );
 
 		this.data = data;
 		final String[] propertyNames = sessionImplementor.getFactory()
 				.getEntityPersister( getEntityName() )
 				.getPropertyNames();
 		this.state = ArraysTools.mapToArray( data, propertyNames );
 	}
 
 	@Override
 	public boolean containsWork() {
 		return true;
 	}
 
 	@Override
 	public Map<String, Object> generateData(Object revisionData) {
 		fillDataWithId( data, revisionData );
 		return data;
 	}
 
 	public Object[] getState() {
 		return state;
 	}
 
 	@Override
 	public AuditWorkUnit merge(AddWorkUnit second) {
 		return second;
 	}
 
 	@Override
 	public AuditWorkUnit merge(ModWorkUnit second) {
-		return new AddWorkUnit( sessionImplementor, entityName, verCfg, id, second.getData() );
+		return new AddWorkUnit( sessionImplementor, entityName, enversService, id, second.getData() );
 	}
 
 	@Override
 	public AuditWorkUnit merge(DelWorkUnit second) {
 		return null;
 	}
 
 	@Override
 	public AuditWorkUnit merge(CollectionChangeWorkUnit second) {
 		second.mergeCollectionModifiedData( data );
 		return this;
 	}
 
 	@Override
 	public AuditWorkUnit merge(FakeBidirectionalRelationWorkUnit second) {
 		return FakeBidirectionalRelationWorkUnit.merge( second, this, second.getNestedWorkUnit() );
 	}
 
 	@Override
 	public AuditWorkUnit dispatch(WorkUnitMergeVisitor first) {
 		return first.merge( this );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/CollectionChangeWorkUnit.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/CollectionChangeWorkUnit.java
index 3bc9cb0aed..c5a4bda8b2 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/CollectionChangeWorkUnit.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/CollectionChangeWorkUnit.java
@@ -1,109 +1,123 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.synchronization.work;
 
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.RevisionType;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public class CollectionChangeWorkUnit extends AbstractAuditWorkUnit implements AuditWorkUnit {
 	private Object entity;
 	private final String collectionPropertyName;
 	private final Map<String, Object> data = new HashMap<String, Object>();
 
 	public CollectionChangeWorkUnit(
-			SessionImplementor session, String entityName, String collectionPropertyName,
-			AuditConfiguration verCfg, Serializable id, Object entity) {
-		super( session, entityName, verCfg, id, RevisionType.MOD );
+			SessionImplementor session,
+			String entityName,
+			String collectionPropertyName,
+			EnversService enversService,
+			Serializable id,
+			Object entity) {
+		super( session, entityName, enversService, id, RevisionType.MOD );
 
 		this.entity = entity;
 		this.collectionPropertyName = collectionPropertyName;
 	}
 
 	@Override
 	public boolean containsWork() {
 		return true;
 	}
 
 	@Override
 	public Map<String, Object> generateData(Object revisionData) {
 		fillDataWithId( data, revisionData );
 		final Map<String, Object> preGenerateData = new HashMap<String, Object>( data );
-		verCfg.getEntCfg().get( getEntityName() ).getPropertyMapper()
-				.mapToMapFromEntity( sessionImplementor, data, entity, null );
-		verCfg.getEntCfg().get( getEntityName() ).getPropertyMapper()
-				.mapModifiedFlagsToMapFromEntity( sessionImplementor, data, entity, entity );
-		verCfg.getEntCfg().get( getEntityName() ).getPropertyMapper()
-				.mapModifiedFlagsToMapForCollectionChange( collectionPropertyName, data );
+		enversService.getEntitiesConfigurations().get( getEntityName() ).getPropertyMapper().mapToMapFromEntity(
+				sessionImplementor,
+				data,
+				entity,
+				null
+		);
+		enversService.getEntitiesConfigurations().get( getEntityName() ).getPropertyMapper().mapModifiedFlagsToMapFromEntity(
+				sessionImplementor,
+				data,
+				entity,
+				entity
+		);
+		enversService.getEntitiesConfigurations().get( getEntityName() ).getPropertyMapper().mapModifiedFlagsToMapForCollectionChange(
+				collectionPropertyName,
+				data
+		);
 		data.putAll( preGenerateData );
 		return data;
 	}
 
 	public void mergeCollectionModifiedData(Map<String, Object> data) {
-		verCfg.getEntCfg().get( getEntityName() ).getPropertyMapper().mapModifiedFlagsToMapForCollectionChange(
+		enversService.getEntitiesConfigurations().get( getEntityName() ).getPropertyMapper().mapModifiedFlagsToMapForCollectionChange(
 				collectionPropertyName,
 				data
 		);
 	}
 
 	@Override
 	public AuditWorkUnit merge(AddWorkUnit second) {
 		return second;
 	}
 
 	@Override
 	public AuditWorkUnit merge(ModWorkUnit second) {
 		mergeCollectionModifiedData( second.getData() );
 		return second;
 	}
 
 	@Override
 	public AuditWorkUnit merge(DelWorkUnit second) {
 		return second;
 	}
 
 	@Override
 	public AuditWorkUnit merge(CollectionChangeWorkUnit second) {
 		second.mergeCollectionModifiedData( data );
 		return this;
 	}
 
 	@Override
 	public AuditWorkUnit merge(FakeBidirectionalRelationWorkUnit second) {
 		return second;
 	}
 
 	@Override
 	public AuditWorkUnit dispatch(WorkUnitMergeVisitor first) {
 		return first.merge( this );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/DelWorkUnit.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/DelWorkUnit.java
index 56d8a8ed2e..d94dd80c81 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/DelWorkUnit.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/DelWorkUnit.java
@@ -1,120 +1,124 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.synchronization.work;
 
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.RevisionType;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.tools.ArraysTools;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class DelWorkUnit extends AbstractAuditWorkUnit implements AuditWorkUnit {
 	private final Object[] state;
 	private final EntityPersister entityPersister;
 	private final String[] propertyNames;
 
 	public DelWorkUnit(
-			SessionImplementor sessionImplementor, String entityName, AuditConfiguration verCfg,
-			Serializable id, EntityPersister entityPersister, Object[] state) {
-		super( sessionImplementor, entityName, verCfg, id, RevisionType.DEL );
+			SessionImplementor sessionImplementor,
+			String entityName,
+			EnversService enversService,
+			Serializable id,
+			EntityPersister entityPersister,
+			Object[] state) {
+		super( sessionImplementor, entityName, enversService, id, RevisionType.DEL );
 
 		this.state = state;
 		this.entityPersister = entityPersister;
 		this.propertyNames = entityPersister.getPropertyNames();
 	}
 
 	@Override
 	public boolean containsWork() {
 		return true;
 	}
 
 	@Override
 	public Map<String, Object> generateData(Object revisionData) {
 		final Map<String, Object> data = new HashMap<String, Object>();
 		fillDataWithId( data, revisionData );
 
-		if ( verCfg.getGlobalCfg().isStoreDataAtDelete() ) {
-			verCfg.getEntCfg().get( getEntityName() ).getPropertyMapper().map(
+		if ( enversService.getGlobalConfiguration().isStoreDataAtDelete() ) {
+			enversService.getEntitiesConfigurations().get( getEntityName() ).getPropertyMapper().map(
 					sessionImplementor,
 					data,
 					propertyNames,
 					state,
 					state
 			);
 		}
 		else {
-			verCfg.getEntCfg().get( getEntityName() ).getPropertyMapper().map(
+			enversService.getEntitiesConfigurations().get( getEntityName() ).getPropertyMapper().map(
 					sessionImplementor,
 					data,
 					propertyNames,
 					null,
 					state
 			);
 		}
 
 		return data;
 	}
 
 	@Override
 	public AuditWorkUnit merge(AddWorkUnit second) {
 		if ( ArraysTools.arraysEqual( second.getState(), state ) ) {
 			// Return null if object's state has not changed.
 			return null;
 		}
-		return new ModWorkUnit( sessionImplementor, entityName, verCfg, id, entityPersister, second.getState(), state );
+		return new ModWorkUnit( sessionImplementor, entityName, enversService, id, entityPersister, second.getState(), state );
 	}
 
 	@Override
 	public AuditWorkUnit merge(ModWorkUnit second) {
 		return null;
 	}
 
 	@Override
 	public AuditWorkUnit merge(DelWorkUnit second) {
 		return this;
 	}
 
 	@Override
 	public AuditWorkUnit merge(CollectionChangeWorkUnit second) {
 		return this;
 	}
 
 	@Override
 	public AuditWorkUnit merge(FakeBidirectionalRelationWorkUnit second) {
 		return this;
 	}
 
 	@Override
 	public AuditWorkUnit dispatch(WorkUnitMergeVisitor first) {
 		return first.merge( this );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/FakeBidirectionalRelationWorkUnit.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/FakeBidirectionalRelationWorkUnit.java
index 2a915c8bbf..429d815ffd 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/FakeBidirectionalRelationWorkUnit.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/FakeBidirectionalRelationWorkUnit.java
@@ -1,247 +1,251 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.synchronization.work;
 
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.RevisionType;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.RelationDescription;
 
 /**
  * A work unit that handles "fake" bidirectional one-to-many relations (mapped with {@code @OneToMany+@JoinColumn} and
  * {@code @ManyToOne+@Column(insertable=false, updatable=false)}.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public class FakeBidirectionalRelationWorkUnit extends AbstractAuditWorkUnit implements AuditWorkUnit {
 	private final Map<String, FakeRelationChange> fakeRelationChanges;
 
 	/*
 	 * The work unit responsible for generating the "raw" entity data to be saved.
 	 */
 	private final AuditWorkUnit nestedWorkUnit;
 
 	public FakeBidirectionalRelationWorkUnit(
-			SessionImplementor sessionImplementor, String entityName,
-			AuditConfiguration verCfg, Serializable id,
-			String referencingPropertyName, Object owningEntity,
-			RelationDescription rd, RevisionType revisionType,
+			SessionImplementor sessionImplementor,
+			String entityName,
+			EnversService enversService,
+			Serializable id,
+			String referencingPropertyName,
+			Object owningEntity,
+			RelationDescription rd,
+			RevisionType revisionType,
 			Object index,
 			AuditWorkUnit nestedWorkUnit) {
-		super( sessionImplementor, entityName, verCfg, id, revisionType );
+		super( sessionImplementor, entityName, enversService, id, revisionType );
 		this.nestedWorkUnit = nestedWorkUnit;
 
 		// Adding the change for the relation.
 		fakeRelationChanges = new HashMap<String, FakeRelationChange>();
 		fakeRelationChanges.put(
 				referencingPropertyName, new FakeRelationChange(
 				owningEntity,
 				rd,
 				revisionType,
 				index
 		)
 		);
 	}
 
 	public FakeBidirectionalRelationWorkUnit(
 			FakeBidirectionalRelationWorkUnit original,
 			Map<String, FakeRelationChange> fakeRelationChanges,
 			AuditWorkUnit nestedWorkUnit) {
-		super( original.sessionImplementor, original.entityName, original.verCfg, original.id, original.revisionType );
+		super( original.sessionImplementor, original.entityName, original.enversService, original.id, original.revisionType );
 
 		this.fakeRelationChanges = fakeRelationChanges;
 		this.nestedWorkUnit = nestedWorkUnit;
 	}
 
 	public FakeBidirectionalRelationWorkUnit(FakeBidirectionalRelationWorkUnit original, AuditWorkUnit nestedWorkUnit) {
-		super( original.sessionImplementor, original.entityName, original.verCfg, original.id, original.revisionType );
+		super( original.sessionImplementor, original.entityName, original.enversService, original.id, original.revisionType );
 
 		this.nestedWorkUnit = nestedWorkUnit;
 
 		fakeRelationChanges = new HashMap<String, FakeRelationChange>( original.getFakeRelationChanges() );
 	}
 
 	public AuditWorkUnit getNestedWorkUnit() {
 		return nestedWorkUnit;
 	}
 
 	public Map<String, FakeRelationChange> getFakeRelationChanges() {
 		return fakeRelationChanges;
 	}
 
 	@Override
 	public boolean containsWork() {
 		return true;
 	}
 
 	@Override
 	public Map<String, Object> generateData(Object revisionData) {
 		// Generating data with the nested work unit. This data contains all data except the fake relation.
 		// Making a defensive copy not to modify the data held by the nested work unit.
 		final Map<String, Object> nestedData = new HashMap<String, Object>( nestedWorkUnit.generateData( revisionData ) );
 
 		// Now adding data for all fake relations.
 		for ( FakeRelationChange fakeRelationChange : fakeRelationChanges.values() ) {
 			fakeRelationChange.generateData( sessionImplementor, nestedData );
 		}
 
 		return nestedData;
 	}
 
 	@Override
 	public AuditWorkUnit merge(AddWorkUnit second) {
 		return merge( this, nestedWorkUnit, second );
 	}
 
 	@Override
 	public AuditWorkUnit merge(ModWorkUnit second) {
 		return merge( this, nestedWorkUnit, second );
 	}
 
 	@Override
 	public AuditWorkUnit merge(DelWorkUnit second) {
 		return second;
 	}
 
 	@Override
 	public AuditWorkUnit merge(CollectionChangeWorkUnit second) {
 		return this;
 	}
 
 	@Override
 	public AuditWorkUnit merge(FakeBidirectionalRelationWorkUnit second) {
 		// First merging the nested work units.
 		final AuditWorkUnit mergedNested = second.getNestedWorkUnit().dispatch( nestedWorkUnit );
 
 		// Now merging the fake relation changes from both work units.
 		final Map<String, FakeRelationChange> secondFakeRelationChanges = second.getFakeRelationChanges();
 		final Map<String, FakeRelationChange> mergedFakeRelationChanges = new HashMap<String, FakeRelationChange>();
 		final Set<String> allPropertyNames = new HashSet<String>( fakeRelationChanges.keySet() );
 		allPropertyNames.addAll( secondFakeRelationChanges.keySet() );
 
 		for ( String propertyName : allPropertyNames ) {
 			mergedFakeRelationChanges.put(
 					propertyName,
 					FakeRelationChange.merge(
 							fakeRelationChanges.get( propertyName ),
 							secondFakeRelationChanges.get( propertyName )
 					)
 			);
 		}
 
 		return new FakeBidirectionalRelationWorkUnit( this, mergedFakeRelationChanges, mergedNested );
 	}
 
 	@Override
 	public AuditWorkUnit dispatch(WorkUnitMergeVisitor first) {
 		return first.merge( this );
 	}
 
 	public static AuditWorkUnit merge(
 			FakeBidirectionalRelationWorkUnit frwu,
 			AuditWorkUnit nestedFirst,
 			AuditWorkUnit nestedSecond) {
 		final AuditWorkUnit nestedMerged = nestedSecond.dispatch( nestedFirst );
 
 		// Creating a new fake relation work unit with the nested merged data
 		return new FakeBidirectionalRelationWorkUnit( frwu, nestedMerged );
 	}
 
 	/**
 	 * Describes a change to a single fake bidirectional relation.
 	 */
 	private static class FakeRelationChange {
 		private final Object owningEntity;
 		private final RelationDescription rd;
 		private final RevisionType revisionType;
 		private final Object index;
 
 		public FakeRelationChange(
 				Object owningEntity, RelationDescription rd, RevisionType revisionType,
 				Object index) {
 			this.owningEntity = owningEntity;
 			this.rd = rd;
 			this.revisionType = revisionType;
 			this.index = index;
 		}
 
 		public RevisionType getRevisionType() {
 			return revisionType;
 		}
 
 		public void generateData(SessionImplementor sessionImplementor, Map<String, Object> data) {
 			// If the revision type is "DEL", it means that the object is removed from the collection. Then the
 			// new owner will in fact be null.
 			rd.getFakeBidirectionalRelationMapper().mapToMapFromEntity(
 					sessionImplementor, data,
 					revisionType == RevisionType.DEL ? null : owningEntity, null
 			);
 			rd.getFakeBidirectionalRelationMapper().mapModifiedFlagsToMapFromEntity(
 					sessionImplementor, data,
 					revisionType == RevisionType.DEL ? null : owningEntity, null
 			);
 
 			// Also mapping the index, if the collection is indexed.
 			if ( rd.getFakeBidirectionalRelationIndexMapper() != null ) {
 				rd.getFakeBidirectionalRelationIndexMapper().mapToMapFromEntity(
 						sessionImplementor, data,
 						revisionType == RevisionType.DEL ? null : index, null
 				);
 				rd.getFakeBidirectionalRelationIndexMapper().mapModifiedFlagsToMapFromEntity(
 						sessionImplementor, data,
 						revisionType == RevisionType.DEL ? null : index, null
 				);
 			}
 		}
 
 		public static FakeRelationChange merge(FakeRelationChange first, FakeRelationChange second) {
 			if ( first == null ) {
 				return second;
 			}
 			if ( second == null ) {
 				return first;
 			}
 
             /*
 			 * The merging rules are the following (revision types of the first and second changes):
              * - DEL, DEL - return any (the work units are the same)
              * - DEL, ADD - return ADD (points to new owner)
              * - ADD, DEL - return ADD (points to new owner)
              * - ADD, ADD - return second (points to newer owner)
              */
 			if ( first.getRevisionType() == RevisionType.DEL || second.getRevisionType() == RevisionType.ADD ) {
 				return second;
 			}
 			else {
 				return first;
 			}
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/ModWorkUnit.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/ModWorkUnit.java
index cf71adc1b8..d7065770d3 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/ModWorkUnit.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/ModWorkUnit.java
@@ -1,112 +1,125 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.synchronization.work;
 
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.RevisionType;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class ModWorkUnit extends AbstractAuditWorkUnit implements AuditWorkUnit {
 	private final Map<String, Object> data;
 	private final boolean changes;
 
 	private final EntityPersister entityPersister;
 	private final Object[] oldState;
 	private final Object[] newState;
 
 	public ModWorkUnit(
-			SessionImplementor sessionImplementor, String entityName, AuditConfiguration verCfg,
-			Serializable id, EntityPersister entityPersister, Object[] newState, Object[] oldState) {
-		super( sessionImplementor, entityName, verCfg, id, RevisionType.MOD );
+			SessionImplementor sessionImplementor,
+			String entityName,
+			EnversService enversService,
+			Serializable id,
+			EntityPersister entityPersister,
+			Object[] newState,
+			Object[] oldState) {
+		super( sessionImplementor, entityName, enversService, id, RevisionType.MOD );
 
 		this.entityPersister = entityPersister;
 		this.oldState = oldState;
 		this.newState = newState;
-		data = new HashMap<String, Object>();
-		changes = verCfg.getEntCfg().get( getEntityName() ).getPropertyMapper().map(
-				sessionImplementor, data,
-				entityPersister.getPropertyNames(), newState, oldState
+		this.data = new HashMap<String, Object>();
+		this.changes = enversService.getEntitiesConfigurations().get( getEntityName() ).getPropertyMapper().map(
+				sessionImplementor,
+				data,
+				entityPersister.getPropertyNames(),
+				newState,
+				oldState
 		);
 	}
 
 	public Map<String, Object> getData() {
 		return data;
 	}
 
 	@Override
 	public boolean containsWork() {
 		return changes;
 	}
 
 	@Override
 	public Map<String, Object> generateData(Object revisionData) {
 		fillDataWithId( data, revisionData );
 
 		return data;
 	}
 
 	@Override
 	public AuditWorkUnit merge(AddWorkUnit second) {
 		return this;
 	}
 
 	@Override
 	public AuditWorkUnit merge(ModWorkUnit second) {
 		// In case of multiple subsequent flushes within single transaction, modification flags need to be
 		// recalculated against initial and final state of the given entity.
 		return new ModWorkUnit(
-				second.sessionImplementor, second.getEntityName(), second.verCfg, second.id,
-				second.entityPersister, second.newState, this.oldState
+				second.sessionImplementor,
+				second.getEntityName(),
+				second.enversService,
+				second.id,
+				second.entityPersister,
+				second.newState,
+				this.oldState
 		);
 	}
 
 	@Override
 	public AuditWorkUnit merge(DelWorkUnit second) {
 		return second;
 	}
 
 	@Override
 	public AuditWorkUnit merge(CollectionChangeWorkUnit second) {
 		second.mergeCollectionModifiedData( data );
 		return this;
 	}
 
 	@Override
 	public AuditWorkUnit merge(FakeBidirectionalRelationWorkUnit second) {
 		return FakeBidirectionalRelationWorkUnit.merge( second, this, second.getNestedWorkUnit() );
 	}
 
 	@Override
 	public AuditWorkUnit dispatch(WorkUnitMergeVisitor first) {
 		return first.merge( this );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/PersistentCollectionChangeWorkUnit.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/PersistentCollectionChangeWorkUnit.java
index 73a9125c72..b8feb11a50 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/PersistentCollectionChangeWorkUnit.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/synchronization/work/PersistentCollectionChangeWorkUnit.java
@@ -1,253 +1,260 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.synchronization.work;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.Session;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.engine.spi.CollectionEntry;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.RevisionType;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.configuration.internal.AuditEntitiesConfiguration;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
 import org.hibernate.envers.internal.entities.mapper.PersistentCollectionChangeData;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class PersistentCollectionChangeWorkUnit extends AbstractAuditWorkUnit implements AuditWorkUnit {
 	private final List<PersistentCollectionChangeData> collectionChanges;
 	private final String referencingPropertyName;
 
 	public PersistentCollectionChangeWorkUnit(
-			SessionImplementor sessionImplementor, String entityName,
-			AuditConfiguration auditCfg, PersistentCollection collection,
-			CollectionEntry collectionEntry, Serializable snapshot, Serializable id,
+			SessionImplementor sessionImplementor,
+			String entityName,
+			EnversService enversService,
+			PersistentCollection collection,
+			CollectionEntry collectionEntry,
+			Serializable snapshot,
+			Serializable id,
 			String referencingPropertyName) {
 		super(
-				sessionImplementor, entityName, auditCfg, new PersistentCollectionChangeWorkUnitId(
-				id,
-				collectionEntry.getRole()
-		), RevisionType.MOD
+				sessionImplementor,
+				entityName,
+				enversService,
+				new PersistentCollectionChangeWorkUnitId( id, collectionEntry.getRole() ),
+				RevisionType.MOD
 		);
 
 		this.referencingPropertyName = referencingPropertyName;
 
-		collectionChanges = auditCfg.getEntCfg().get( getEntityName() ).getPropertyMapper()
+		collectionChanges = enversService.getEntitiesConfigurations().get( getEntityName() ).getPropertyMapper()
 				.mapCollectionChanges( sessionImplementor, referencingPropertyName, collection, snapshot, id );
 	}
 
 	public PersistentCollectionChangeWorkUnit(
-			SessionImplementor sessionImplementor, String entityName,
-			AuditConfiguration verCfg, Serializable id,
+			SessionImplementor sessionImplementor,
+			String entityName,
+			EnversService enversService,
+			Serializable id,
 			List<PersistentCollectionChangeData> collectionChanges,
 			String referencingPropertyName) {
-		super( sessionImplementor, entityName, verCfg, id, RevisionType.MOD );
+		super( sessionImplementor, entityName, enversService, id, RevisionType.MOD );
 
 		this.collectionChanges = collectionChanges;
 		this.referencingPropertyName = referencingPropertyName;
 	}
 
 	@Override
 	public boolean containsWork() {
 		return collectionChanges != null && collectionChanges.size() != 0;
 	}
 
 	@Override
 	public Map<String, Object> generateData(Object revisionData) {
 		throw new UnsupportedOperationException( "Cannot generate data for a collection change work unit!" );
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public void perform(Session session, Object revisionData) {
-		final AuditEntitiesConfiguration entitiesCfg = verCfg.getAuditEntCfg();
+		final AuditEntitiesConfiguration entitiesCfg = enversService.getAuditEntitiesConfiguration();
 
 		for ( PersistentCollectionChangeData persistentCollectionChangeData : collectionChanges ) {
 			// Setting the revision number
 			((Map<String, Object>) persistentCollectionChangeData.getData().get( entitiesCfg.getOriginalIdPropName() ))
 					.put( entitiesCfg.getRevisionFieldName(), revisionData );
 
 			auditStrategy.performCollectionChange(
 					session,
 					getEntityName(),
 					referencingPropertyName,
-					verCfg,
+					enversService,
 					persistentCollectionChangeData,
 					revisionData
 			);
 		}
 	}
 
 	public String getReferencingPropertyName() {
 		return referencingPropertyName;
 	}
 
 	public List<PersistentCollectionChangeData> getCollectionChanges() {
 		return collectionChanges;
 	}
 
 	@Override
 	public AuditWorkUnit merge(AddWorkUnit second) {
 		return null;
 	}
 
 	@Override
 	public AuditWorkUnit merge(ModWorkUnit second) {
 		return null;
 	}
 
 	@Override
 	public AuditWorkUnit merge(DelWorkUnit second) {
 		return null;
 	}
 
 	@Override
 	public AuditWorkUnit merge(CollectionChangeWorkUnit second) {
 		return null;
 	}
 
 	@Override
 	public AuditWorkUnit merge(FakeBidirectionalRelationWorkUnit second) {
 		return null;
 	}
 
 	@Override
 	public AuditWorkUnit dispatch(WorkUnitMergeVisitor first) {
 		if ( first instanceof PersistentCollectionChangeWorkUnit ) {
 			final PersistentCollectionChangeWorkUnit original = (PersistentCollectionChangeWorkUnit) first;
 
 			// Merging the collection changes in both work units.
 
 			// First building a map from the ids of the collection-entry-entities from the "second" collection changes,
 			// to the PCCD objects. That way, we will be later able to check if an "original" collection change
 			// should be added, or if it is overshadowed by a new one.
 			final Map<Object, PersistentCollectionChangeData> newChangesIdMap = new HashMap<Object, PersistentCollectionChangeData>();
 			for ( PersistentCollectionChangeData persistentCollectionChangeData : getCollectionChanges() ) {
 				newChangesIdMap.put(
 						getOriginalId( persistentCollectionChangeData ),
 						persistentCollectionChangeData
 				);
 			}
 
 			// This will be the list with the resulting (merged) changes.
 			final List<PersistentCollectionChangeData> mergedChanges = new ArrayList<PersistentCollectionChangeData>();
 
 			// Including only those original changes, which are not overshadowed by new ones.
 			for ( PersistentCollectionChangeData originalCollectionChangeData : original.getCollectionChanges() ) {
 				final Object originalOriginalId = getOriginalId( originalCollectionChangeData );
 				if ( !newChangesIdMap.containsKey( originalOriginalId ) ) {
 					mergedChanges.add( originalCollectionChangeData );
 				}
 				else {
 					// If the changes collide, checking if the first one isn't a DEL, and the second a subsequent ADD
 					// If so, removing the change alltogether.
-					final String revTypePropName = verCfg.getAuditEntCfg().getRevisionTypePropName();
+					final String revTypePropName = enversService.getAuditEntitiesConfiguration().getRevisionTypePropName();
 					if ( RevisionType.ADD.equals( newChangesIdMap.get( originalOriginalId ).getData().get( revTypePropName ) )
 							&& RevisionType.DEL.equals( originalCollectionChangeData.getData().get( revTypePropName ) ) ) {
 						newChangesIdMap.remove( originalOriginalId );
 					}
 				}
 			}
 
 			// Finally adding all of the new changes to the end of the list (the map values may differ from
 			// getCollectionChanges() because of the last operation above).
 			mergedChanges.addAll( newChangesIdMap.values() );
 
 			return new PersistentCollectionChangeWorkUnit(
 					sessionImplementor,
 					entityName,
-					verCfg,
+					enversService,
 					id,
 					mergedChanges,
 					referencingPropertyName
 			);
 		}
 		else {
 			throw new RuntimeException(
 					"Trying to merge a " + first + " with a PersitentCollectionChangeWorkUnit. " +
 							"This is not really possible."
 			);
 		}
 	}
 
 	private Object getOriginalId(PersistentCollectionChangeData persistentCollectionChangeData) {
-		return persistentCollectionChangeData.getData().get( verCfg.getAuditEntCfg().getOriginalIdPropName() );
+		return persistentCollectionChangeData.getData().get( enversService.getAuditEntitiesConfiguration().getOriginalIdPropName() );
 	}
 
 	/**
 	 * A unique identifier for a collection work unit. Consists of an id of the owning entity and the name of
 	 * the entity plus the name of the field (the role). This is needed because such collections aren't entities
 	 * in the "normal" mapping, but they are entities for Envers.
 	 */
 	public static class PersistentCollectionChangeWorkUnitId implements Serializable {
 		private static final long serialVersionUID = -8007831518629167537L;
 
 		private final Serializable ownerId;
 		private final String role;
 
 		public PersistentCollectionChangeWorkUnitId(Serializable ownerId, String role) {
 			this.ownerId = ownerId;
 			this.role = role;
 		}
 
 		@Override
 		public boolean equals(Object o) {
 			if ( this == o ) {
 				return true;
 			}
 			if ( o == null || getClass() != o.getClass() ) {
 				return false;
 			}
 
 			final PersistentCollectionChangeWorkUnitId that = (PersistentCollectionChangeWorkUnitId) o;
 
 			if ( ownerId != null ? !ownerId.equals( that.ownerId ) : that.ownerId != null ) {
 				return false;
 			}
 			//noinspection RedundantIfStatement
 			if ( role != null ? !role.equals( that.role ) : that.role != null ) {
 				return false;
 			}
 
 			return true;
 		}
 
 		@Override
 		public int hashCode() {
 			int result = ownerId != null ? ownerId.hashCode() : 0;
 			result = 31 * result + (role != null ? role.hashCode() : 0);
 			return result;
 		}
 
 		public Serializable getOwnerId() {
 			return ownerId;
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/internal/tools/Tools.java b/hibernate-envers/src/main/java/org/hibernate/envers/internal/tools/Tools.java
index 0fafa83c1d..2fb86dc746 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/internal/tools/Tools.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/internal/tools/Tools.java
@@ -1,103 +1,115 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.internal.tools;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.envers.tools.Pair;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public abstract class Tools {
 	public static <K, V> Map<K, V> newHashMap() {
 		return new HashMap<K, V>();
 	}
 
 	public static <E> Set<E> newHashSet() {
 		return new HashSet<E>();
 	}
 
 	public static <K, V> Map<K, V> newLinkedHashMap() {
 		return new LinkedHashMap<K, V>();
 	}
 
 	public static boolean objectsEqual(Object obj1, Object obj2) {
 		if ( obj1 == null ) {
 			return obj2 == null;
 		}
 
 		return obj1.equals( obj2 );
 	}
 
 	public static <T> List<T> iteratorToList(Iterator<T> iter) {
 		final List<T> ret = new ArrayList<T>();
 		while ( iter.hasNext() ) {
 			ret.add( iter.next() );
 		}
 
 		return ret;
 	}
 
+	public static <X> List<X> collectionToList(Collection<X> collection) {
+		if ( collection instanceof List ) {
+			return (List<X>) collection;
+		}
+		else {
+			List<X> list = new ArrayList<X>();
+			list.addAll( collection );
+			return list;
+		}
+	}
+
 	public static boolean iteratorsContentEqual(Iterator iter1, Iterator iter2) {
 		while ( iter1.hasNext() && iter2.hasNext() ) {
 			if ( !iter1.next().equals( iter2.next() ) ) {
 				return false;
 			}
 		}
 
 		//noinspection RedundantIfStatement
 		if ( iter1.hasNext() || iter2.hasNext() ) {
 			return false;
 		}
 
 		return true;
 	}
 
 	/**
 	 * Transforms a list of arbitrary elements to a list of index-element pairs.
 	 *
 	 * @param list List to transform.
 	 *
 	 * @return A list of pairs: ((0, element_at_index_0), (1, element_at_index_1), ...)
 	 */
 	public static <T> List<Pair<Integer, T>> listToIndexElementPairList(List<T> list) {
 		final List<Pair<Integer, T>> ret = new ArrayList<Pair<Integer, T>>();
 		final Iterator<T> listIter = list.iterator();
 		for ( int i = 0; i < list.size(); i++ ) {
 			ret.add( Pair.make( i, listIter.next() ) );
 		}
 
 		return ret;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/AuditQueryCreator.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/AuditQueryCreator.java
index 958be1e6cf..93739461fa 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/AuditQueryCreator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/AuditQueryCreator.java
@@ -1,226 +1,226 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.query.internal.impl.EntitiesAtRevisionQuery;
 import org.hibernate.envers.query.internal.impl.EntitiesModifiedAtRevisionQuery;
 import org.hibernate.envers.query.internal.impl.RevisionsOfEntityQuery;
 
 import static org.hibernate.envers.internal.tools.ArgumentsTools.checkNotNull;
 import static org.hibernate.envers.internal.tools.ArgumentsTools.checkPositive;
 import static org.hibernate.envers.internal.tools.EntityTools.getTargetClassIfProxied;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class AuditQueryCreator {
-	private final AuditConfiguration auditCfg;
+	private final EnversService enversService;
 	private final AuditReaderImplementor auditReaderImplementor;
 
-	public AuditQueryCreator(AuditConfiguration auditCfg, AuditReaderImplementor auditReaderImplementor) {
-		this.auditCfg = auditCfg;
+	public AuditQueryCreator(EnversService enversService, AuditReaderImplementor auditReaderImplementor) {
+		this.enversService = enversService;
 		this.auditReaderImplementor = auditReaderImplementor;
 	}
 
 	/**
 	 * Creates a query, which will return entities satisfying some conditions (specified later),
 	 * at a given revision. Deleted entities are not included.
 	 *
 	 * @param c Class of the entities for which to query.
 	 * @param revision Revision number at which to execute the query.
 	 *
 	 * @return A query for entities at a given revision, to which conditions can be added and which
 	 *         can then be executed. The result of the query will be a list of entities (beans), unless a
 	 *         projection is added.
 	 */
 	public AuditQuery forEntitiesAtRevision(Class<?> c, Number revision) {
 		checkNotNull( revision, "Entity revision" );
 		checkPositive( revision, "Entity revision" );
 		c = getTargetClassIfProxied( c );
-		return new EntitiesAtRevisionQuery( auditCfg, auditReaderImplementor, c, revision, false );
+		return new EntitiesAtRevisionQuery( enversService, auditReaderImplementor, c, revision, false );
 	}
 
 	/**
 	 * Creates a query, which will return entities satisfying some conditions (specified later),
 	 * at a given revision and a given entityName. Deleted entities are not included.
 	 *
 	 * @param c Class of the entities for which to query.
 	 * @param entityName Name of the entity (if can't be guessed basing on the {@code c}).
 	 * @param revision Revision number at which to execute the query.
 	 *
 	 * @return A query for entities at a given revision, to which conditions can be added and which
 	 *         can then be executed. The result of the query will be a list of entities (beans), unless a
 	 *         projection is added.
 	 */
 	public AuditQuery forEntitiesAtRevision(Class<?> c, String entityName, Number revision) {
 		return forEntitiesAtRevision( c, entityName, revision, false );
 	}
 
 	/**
 	 * Creates a query, which will return entities satisfying some conditions (specified later),
 	 * at a given revision and a given entityName. Deleted entities may be optionally
 	 * included.
 	 *
 	 * @param c Class of the entities for which to query.
 	 * @param entityName Name of the entity (if can't be guessed basing on the {@code c}).
 	 * @param revision Revision number at which to execute the query.
 	 * @param includeDeletions Whether to include deleted entities in the search.
 	 *
 	 * @return A query for entities at a given revision, to which conditions can be added and which
 	 *         can then be executed. The result of the query will be a list of entities (beans), unless a
 	 *         projection is added.
 	 */
 	public AuditQuery forEntitiesAtRevision(Class<?> c, String entityName, Number revision, boolean includeDeletions) {
 		checkNotNull( revision, "Entity revision" );
 		checkPositive( revision, "Entity revision" );
 		c = getTargetClassIfProxied( c );
 		return new EntitiesAtRevisionQuery(
-				auditCfg,
+				enversService,
 				auditReaderImplementor,
 				c,
 				entityName,
 				revision,
 				includeDeletions
 		);
 	}
 
 	/**
 	 * Creates a query, which will return entities modified at the specified revision.
 	 * <p/>
 	 * In comparison, the {@link #forEntitiesAtRevision(Class, String, Number)} query takes into all entities
 	 * which were present at a given revision, even if they were not modified.
 	 *
 	 * @param c Class of the entities for which to query.
 	 * @param entityName Name of the entity (if can't be guessed basing on the {@code c}).
 	 * @param revision Revision number at which to execute the query.
 	 *
 	 * @return A query for entities changed at a given revision, to which conditions can be added and which
 	 *         can then be executed.
 	 *
 	 * @see #forEntitiesAtRevision(Class, String, Number)
 	 */
 	public AuditQuery forEntitiesModifiedAtRevision(Class<?> c, String entityName, Number revision) {
 		checkNotNull( revision, "Entity revision" );
 		checkPositive( revision, "Entity revision" );
 		c = getTargetClassIfProxied( c );
-		return new EntitiesModifiedAtRevisionQuery( auditCfg, auditReaderImplementor, c, entityName, revision );
+		return new EntitiesModifiedAtRevisionQuery( enversService, auditReaderImplementor, c, entityName, revision );
 	}
 
 	/**
 	 * Creates a query, which will return entities modified at the specified revision.
 	 * <p/>
 	 * In comparison, the {@link #forEntitiesAtRevision(Class, String, Number)} query takes into all entities
 	 * which were present at a given revision, even if they were not modified.
 	 *
 	 * @param c Class of the entities for which to query.
 	 * @param revision Revision number at which to execute the query.
 	 *
 	 * @return A query for entities changed at a given revision, to which conditions can be added and which
 	 *         can then be executed.
 	 *
 	 * @see #forEntitiesAtRevision(Class, Number)
 	 */
 	public AuditQuery forEntitiesModifiedAtRevision(Class<?> c, Number revision) {
 		checkNotNull( revision, "Entity revision" );
 		checkPositive( revision, "Entity revision" );
 		c = getTargetClassIfProxied( c );
-		return new EntitiesModifiedAtRevisionQuery( auditCfg, auditReaderImplementor, c, revision );
+		return new EntitiesModifiedAtRevisionQuery( enversService, auditReaderImplementor, c, revision );
 	}
 
 	/**
 	 * Creates a query, which selects the revisions, at which the given entity was modified.
 	 * Unless an explicit projection is set, the result will be a list of three-element arrays, containing:
 	 * <ol>
 	 * <li>the entity instance</li>
 	 * <li>revision entity, corresponding to the revision at which the entity was modified. If no custom
 	 * revision entity is used, this will be an instance of {@link org.hibernate.envers.DefaultRevisionEntity}</li>
 	 * <li>type of the revision (an enum instance of class {@link org.hibernate.envers.RevisionType})</li>.
 	 * </ol>
 	 * Additional conditions that the results must satisfy may be specified.
 	 *
 	 * @param c Class of the entities for which to query.
 	 * @param selectEntitiesOnly If true, instead of a list of three-element arrays, a list of entites will be
 	 * returned as a result of executing this query.
 	 * @param selectDeletedEntities If true, also revisions where entities were deleted will be returned. The additional
 	 * entities will have revision type "delete", and contain no data (all fields null), except for the id field.
 	 *
 	 * @return A query for revisions at which instances of the given entity were modified, to which
 	 *         conditions can be added (for example - a specific id of an entity of class <code>c</code>), and which
 	 *         can then be executed. The results of the query will be sorted in ascending order by the revision number,
 	 *         unless an order or projection is added.
 	 */
 	public AuditQuery forRevisionsOfEntity(Class<?> c, boolean selectEntitiesOnly, boolean selectDeletedEntities) {
 		c = getTargetClassIfProxied( c );
 		return new RevisionsOfEntityQuery(
-				auditCfg,
+				enversService,
 				auditReaderImplementor,
 				c,
 				selectEntitiesOnly,
 				selectDeletedEntities
 		);
 	}
 
 	/**
 	 * Creates a query, which selects the revisions, at which the given entity was modified and with a given entityName.
 	 * Unless an explicit projection is set, the result will be a list of three-element arrays, containing:
 	 * <ol>
 	 * <li>the entity instance</li>
 	 * <li>revision entity, corresponding to the revision at which the entity was modified. If no custom
 	 * revision entity is used, this will be an instance of {@link org.hibernate.envers.DefaultRevisionEntity}</li>
 	 * <li>type of the revision (an enum instance of class {@link org.hibernate.envers.RevisionType})</li>.
 	 * </ol>
 	 * Additional conditions that the results must satisfy may be specified.
 	 *
 	 * @param c Class of the entities for which to query.
 	 * @param entityName Name of the entity (if can't be guessed basing on the {@code c}).
 	 * @param selectEntitiesOnly If true, instead of a list of three-element arrays, a list of entites will be
 	 * returned as a result of executing this query.
 	 * @param selectDeletedEntities If true, also revisions where entities were deleted will be returned. The additional
 	 * entities will have revision type "delete", and contain no data (all fields null), except for the id field.
 	 *
 	 * @return A query for revisions at which instances of the given entity were modified, to which
 	 *         conditions can be added (for example - a specific id of an entity of class <code>c</code>), and which
 	 *         can then be executed. The results of the query will be sorted in ascending order by the revision number,
 	 *         unless an order or projection is added.
 	 */
 	public AuditQuery forRevisionsOfEntity(
 			Class<?> c,
 			String entityName,
 			boolean selectEntitiesOnly,
 			boolean selectDeletedEntities) {
 		c = getTargetClassIfProxied( c );
 		return new RevisionsOfEntityQuery(
-				auditCfg,
+				enversService,
 				auditReaderImplementor,
 				c,
 				entityName,
 				selectEntitiesOnly,
 				selectDeletedEntities
 		);
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AggregatedAuditExpression.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AggregatedAuditExpression.java
index b5911bc245..8d842b83c2 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AggregatedAuditExpression.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AggregatedAuditExpression.java
@@ -1,123 +1,126 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.envers.query.criteria.internal.CriteriaTools;
 import org.hibernate.envers.query.internal.property.PropertyNameGetter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class AggregatedAuditExpression implements AuditCriterion, ExtendableCriterion {
 	private PropertyNameGetter propertyNameGetter;
 	private AggregatedMode mode;
 	// Correlate subquery with outer query by entity id.
 	private boolean correlate;
 	private List<AuditCriterion> criterions;
 
 	public AggregatedAuditExpression(PropertyNameGetter propertyNameGetter, AggregatedMode mode) {
 		this.propertyNameGetter = propertyNameGetter;
 		this.mode = mode;
 		criterions = new ArrayList<AuditCriterion>();
 	}
 
 	public static enum AggregatedMode {
 		MAX,
 		MIN
 	}
 
 	@Override
 	public AggregatedAuditExpression add(AuditCriterion criterion) {
 		criterions.add( criterion );
 		return this;
 	}
 
 	@Override
 	public void addToQuery(
-			AuditConfiguration auditCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters) {
 		String propertyName = CriteriaTools.determinePropertyName(
-				auditCfg,
+				enversService,
 				versionsReader,
 				entityName,
 				propertyNameGetter
 		);
 
-		CriteriaTools.checkPropertyNotARelation( auditCfg, entityName, propertyName );
+		CriteriaTools.checkPropertyNotARelation( enversService, entityName, propertyName );
 
 		// Make sure our conditions are ANDed together even if the parent Parameters have a different connective
 		Parameters subParams = parameters.addSubParameters( Parameters.AND );
 		// This will be the aggregated query, containing all the specified conditions
 		QueryBuilder subQb = qb.newSubQueryBuilder();
 
 		// Adding all specified conditions both to the main query, as well as to the
 		// aggregated one.
 		for ( AuditCriterion versionsCriteria : criterions ) {
-			versionsCriteria.addToQuery( auditCfg, versionsReader, entityName, qb, subParams );
-			versionsCriteria.addToQuery( auditCfg, versionsReader, entityName, subQb, subQb.getRootParameters() );
+			versionsCriteria.addToQuery( enversService, versionsReader, entityName, qb, subParams );
+			versionsCriteria.addToQuery( enversService, versionsReader, entityName, subQb, subQb.getRootParameters() );
 		}
 
 		// Setting the desired projection of the aggregated query
 		switch ( mode ) {
 			case MIN:
 				subQb.addProjection( "min", propertyName, false );
 				break;
 			case MAX:
 				subQb.addProjection( "max", propertyName, false );
 		}
 
 		// Correlating subquery with the outer query by entity id. See JIRA HHH-7827.
 		if ( correlate ) {
-			final String originalIdPropertyName = auditCfg.getAuditEntCfg().getOriginalIdPropName();
-			auditCfg.getEntCfg().get( entityName ).getIdMapper().addIdsEqualToQuery(
+			final String originalIdPropertyName = enversService.getAuditEntitiesConfiguration().getOriginalIdPropName();
+			enversService.getEntitiesConfigurations().get( entityName ).getIdMapper().addIdsEqualToQuery(
 					subQb.getRootParameters(),
 					subQb.getRootAlias() + "." + originalIdPropertyName,
 					qb.getRootAlias() + "." + originalIdPropertyName
 			);
 		}
 
 		// Adding the constrain on the result of the aggregated criteria
 		subParams.addWhere( propertyName, "=", subQb );
 	}
 
 	/**
 	 * Compute aggregated expression in the context of each entity instance separately. Useful for retrieving latest
 	 * revisions of all entities of a particular type.<br/>
 	 * Implementation note: Correlates subquery with the outer query by entity id.
 	 *
 	 * @return this (for method chaining).
 	 */
 	public AggregatedAuditExpression computeAggregationInInstanceContext() {
 		correlate = true;
 		return this;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditConjunction.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditConjunction.java
index 4caa107934..59588e7974 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditConjunction.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditConjunction.java
@@ -1,63 +1,68 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class AuditConjunction implements AuditCriterion, ExtendableCriterion {
 	private List<AuditCriterion> criterions;
 
 	public AuditConjunction() {
 		criterions = new ArrayList<AuditCriterion>();
 	}
 
+	@Override
 	public AuditConjunction add(AuditCriterion criterion) {
 		criterions.add( criterion );
 		return this;
 	}
 
+	@Override
 	public void addToQuery(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters) {
 		Parameters andParameters = parameters.addSubParameters( Parameters.AND );
 
 		if ( criterions.size() == 0 ) {
 			andParameters.addWhere( "1", false, "=", "1", false );
 		}
 		else {
 			for ( AuditCriterion criterion : criterions ) {
-				criterion.addToQuery( verCfg, versionsReader, entityName, qb, andParameters );
+				criterion.addToQuery( enversService, versionsReader, entityName, qb, andParameters );
 			}
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditCriterion.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditCriterion.java
index e71e099c6c..8c47755b21 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditCriterion.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditCriterion.java
@@ -1,38 +1,41 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public interface AuditCriterion {
 	void addToQuery(
-			AuditConfiguration auditCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters);
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters);
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditDisjunction.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditDisjunction.java
index 1423b5078c..f634576a0d 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditDisjunction.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditDisjunction.java
@@ -1,65 +1,68 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class AuditDisjunction implements AuditCriterion, ExtendableCriterion {
 	private List<AuditCriterion> criterions;
 
 	public AuditDisjunction() {
 		criterions = new ArrayList<AuditCriterion>();
 	}
 
 	@Override
 	public AuditDisjunction add(AuditCriterion criterion) {
 		criterions.add( criterion );
 		return this;
 	}
 
 	@Override
 	public void addToQuery(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters) {
 		Parameters orParameters = parameters.addSubParameters( Parameters.OR );
 
 		if ( criterions.size() == 0 ) {
 			orParameters.addWhere( "0", false, "=", "1", false );
 		}
 		else {
 			for ( AuditCriterion criterion : criterions ) {
-				criterion.addToQuery( verCfg, versionsReader, entityName, qb, orParameters );
+				criterion.addToQuery( enversService, versionsReader, entityName, qb, orParameters );
 			}
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditProperty.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditProperty.java
index 4a6c7d5d0d..48106c1ecf 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditProperty.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/AuditProperty.java
@@ -1,295 +1,295 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria;
 
 import java.util.Collection;
 
 import org.hibernate.criterion.MatchMode;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.tools.Triple;
 import org.hibernate.envers.query.criteria.internal.BetweenAuditExpression;
 import org.hibernate.envers.query.criteria.internal.IlikeAuditExpression;
 import org.hibernate.envers.query.criteria.internal.InAuditExpression;
 import org.hibernate.envers.query.criteria.internal.NotNullAuditExpression;
 import org.hibernate.envers.query.criteria.internal.NullAuditExpression;
 import org.hibernate.envers.query.criteria.internal.PropertyAuditExpression;
 import org.hibernate.envers.query.criteria.internal.SimpleAuditExpression;
 import org.hibernate.envers.query.internal.property.ModifiedFlagPropertyName;
 import org.hibernate.envers.query.internal.property.PropertyNameGetter;
 import org.hibernate.envers.query.order.AuditOrder;
 import org.hibernate.envers.query.order.internal.PropertyAuditOrder;
 import org.hibernate.envers.query.projection.AuditProjection;
 import org.hibernate.envers.query.projection.internal.PropertyAuditProjection;
 
 /**
  * Create restrictions, projections and specify order for a property of an audited entity.
  *
  * @author Adam Warski (adam at warski dot org)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 @SuppressWarnings({"JavaDoc"})
 public class AuditProperty<T> implements AuditProjection {
 	private final PropertyNameGetter propertyNameGetter;
 
 	public AuditProperty(PropertyNameGetter propertyNameGetter) {
 		this.propertyNameGetter = propertyNameGetter;
 	}
 
 	public AuditCriterion hasChanged() {
 		return new SimpleAuditExpression( new ModifiedFlagPropertyName( propertyNameGetter ), true, "=" );
 	}
 
 	public AuditCriterion hasNotChanged() {
 		return new SimpleAuditExpression( new ModifiedFlagPropertyName( propertyNameGetter ), false, "=" );
 	}
 
 	/**
 	 * Apply an "equal" constraint
 	 */
 	public AuditCriterion eq(T value) {
 		return new SimpleAuditExpression( propertyNameGetter, value, "=" );
 	}
 
 	/**
 	 * Apply a "not equal" constraint
 	 */
 	public AuditCriterion ne(T value) {
 		return new SimpleAuditExpression( propertyNameGetter, value, "<>" );
 	}
 
 	/**
 	 * Apply a "like" constraint
 	 */
 	public AuditCriterion like(T value) {
 		return new SimpleAuditExpression( propertyNameGetter, value, " like " );
 	}
 
 	/**
 	 * Apply a "like" constraint
 	 */
 	public AuditCriterion like(String value, MatchMode matchMode) {
 		return new SimpleAuditExpression( propertyNameGetter, matchMode.toMatchString( value ), " like " );
 	}
 
     /**
      *  Apply an "ilike" constraint
      */
     public AuditCriterion ilike(T value) {
         return new IlikeAuditExpression(propertyNameGetter, value.toString());
     }
 
     /**
      *  Apply an "ilike" constraint
      */
     public AuditCriterion ilike(String value, MatchMode matchMode) {
         return new IlikeAuditExpression( propertyNameGetter, matchMode.toMatchString( value ));
     }
 
 	/**
 	 * Apply a "greater than" constraint
 	 */
 	public AuditCriterion gt(T value) {
 		return new SimpleAuditExpression( propertyNameGetter, value, ">" );
 	}
 
 	/**
 	 * Apply a "less than" constraint
 	 */
 	public AuditCriterion lt(T value) {
 		return new SimpleAuditExpression( propertyNameGetter, value, "<" );
 	}
 
 	/**
 	 * Apply a "less than or equal" constraint
 	 */
 	public AuditCriterion le(T value) {
 		return new SimpleAuditExpression( propertyNameGetter, value, "<=" );
 	}
 
 	/**
 	 * Apply a "greater than or equal" constraint
 	 */
 	public AuditCriterion ge(T value) {
 		return new SimpleAuditExpression( propertyNameGetter, value, ">=" );
 	}
 
 	/**
 	 * Apply a "between" constraint
 	 */
 	public AuditCriterion between(T lo, T hi) {
 		return new BetweenAuditExpression( propertyNameGetter, lo, hi );
 	}
 
 	/**
 	 * Apply an "in" constraint
 	 */
 	public AuditCriterion in(T[] values) {
 		return new InAuditExpression( propertyNameGetter, values );
 	}
 
 	/**
 	 * Apply an "in" constraint
 	 */
 	public AuditCriterion in(Collection values) {
 		return new InAuditExpression( propertyNameGetter, values.toArray() );
 	}
 
 	/**
 	 * Apply an "is null" constraint
 	 */
 	public AuditCriterion isNull() {
 		return new NullAuditExpression( propertyNameGetter );
 	}
 
 	/**
 	 * Apply an "equal" constraint to another property
 	 */
 	public AuditCriterion eqProperty(String otherPropertyName) {
 		return new PropertyAuditExpression( propertyNameGetter, otherPropertyName, "=" );
 	}
 
 	/**
 	 * Apply a "not equal" constraint to another property
 	 */
 	public AuditCriterion neProperty(String otherPropertyName) {
 		return new PropertyAuditExpression( propertyNameGetter, otherPropertyName, "<>" );
 	}
 
 	/**
 	 * Apply a "less than" constraint to another property
 	 */
 	public AuditCriterion ltProperty(String otherPropertyName) {
 		return new PropertyAuditExpression( propertyNameGetter, otherPropertyName, "<" );
 	}
 
 	/**
 	 * Apply a "less than or equal" constraint to another property
 	 */
 	public AuditCriterion leProperty(String otherPropertyName) {
 		return new PropertyAuditExpression( propertyNameGetter, otherPropertyName, "<=" );
 	}
 
 	/**
 	 * Apply a "greater than" constraint to another property
 	 */
 	public AuditCriterion gtProperty(String otherPropertyName) {
 		return new PropertyAuditExpression( propertyNameGetter, otherPropertyName, ">" );
 	}
 
 	/**
 	 * Apply a "greater than or equal" constraint to another property
 	 */
 	public AuditCriterion geProperty(String otherPropertyName) {
 		return new PropertyAuditExpression( propertyNameGetter, otherPropertyName, ">=" );
 	}
 
 	/**
 	 * Apply an "is not null" constraint to the another property
 	 */
 	public AuditCriterion isNotNull() {
 		return new NotNullAuditExpression( propertyNameGetter );
 	}
 
 	/**
 	 * Apply a "maximalize" constraint, with the ability to specify further constraints on the maximized
 	 * property
 	 */
 	public AggregatedAuditExpression maximize() {
 		return new AggregatedAuditExpression( propertyNameGetter, AggregatedAuditExpression.AggregatedMode.MAX );
 	}
 
 	/**
 	 * Apply a "minimize" constraint, with the ability to specify further constraints on the minimized
 	 * property
 	 */
 	public AggregatedAuditExpression minimize() {
 		return new AggregatedAuditExpression( propertyNameGetter, AggregatedAuditExpression.AggregatedMode.MIN );
 	}
 
 	// Projections
 
 	/**
 	 * Projection on the maximum value
 	 */
 	public AuditProjection max() {
 		return new PropertyAuditProjection( propertyNameGetter, "max", false );
 	}
 
 	/**
 	 * Projection on the minimum value
 	 */
 	public AuditProjection min() {
 		return new PropertyAuditProjection( propertyNameGetter, "min", false );
 	}
 
 	/**
 	 * Projection counting the values
 	 */
 	public AuditProjection count() {
 		return new PropertyAuditProjection( propertyNameGetter, "count", false );
 	}
 
 	/**
 	 * Projection counting distinct values
 	 */
 	public AuditProjection countDistinct() {
 		return new PropertyAuditProjection( propertyNameGetter, "count", true );
 	}
 
 	/**
 	 * Projection on distinct values
 	 */
 	public AuditProjection distinct() {
 		return new PropertyAuditProjection( propertyNameGetter, null, true );
 	}
 
 	/**
 	 * Projection using a custom function
 	 */
 	public AuditProjection function(String functionName) {
 		return new PropertyAuditProjection( propertyNameGetter, functionName, false );
 	}
 
 	// Projection on this property
 
-	public Triple<String, String, Boolean> getData(AuditConfiguration auditCfg) {
-		return Triple.make( null, propertyNameGetter.get( auditCfg ), false );
+	public Triple<String, String, Boolean> getData(EnversService enversService) {
+		return Triple.make( null, propertyNameGetter.get( enversService ), false );
 	}
 
 	// Order
 
 	/**
 	 * Sort the results by the property in ascending order
 	 */
 	public AuditOrder asc() {
 		return new PropertyAuditOrder( propertyNameGetter, true );
 	}
 
 	/**
 	 * Sort the results by the property in descending order
 	 */
 	public AuditOrder desc() {
 		return new PropertyAuditOrder( propertyNameGetter, false );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/BetweenAuditExpression.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/BetweenAuditExpression.java
index 90a2a95a97..c491c1477d 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/BetweenAuditExpression.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/BetweenAuditExpression.java
@@ -1,62 +1,65 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria.internal;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 import org.hibernate.envers.query.internal.property.PropertyNameGetter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class BetweenAuditExpression implements AuditCriterion {
 	private PropertyNameGetter propertyNameGetter;
 	private Object lo;
 	private Object hi;
 
 	public BetweenAuditExpression(PropertyNameGetter propertyNameGetter, Object lo, Object hi) {
 		this.propertyNameGetter = propertyNameGetter;
 		this.lo = lo;
 		this.hi = hi;
 	}
 
 	public void addToQuery(
-			AuditConfiguration auditCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters) {
 		String propertyName = CriteriaTools.determinePropertyName(
-				auditCfg,
+				enversService,
 				versionsReader,
 				entityName,
 				propertyNameGetter
 		);
-		CriteriaTools.checkPropertyNotARelation( auditCfg, entityName, propertyName );
+		CriteriaTools.checkPropertyNotARelation( enversService, entityName, propertyName );
 
 		Parameters subParams = parameters.addSubParameters( Parameters.AND );
 		subParams.addWhereWithParam( propertyName, ">=", lo );
 		subParams.addWhereWithParam( propertyName, "<=", hi );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/CriteriaTools.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/CriteriaTools.java
index 466c47dd96..aa388d0397 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/CriteriaTools.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/CriteriaTools.java
@@ -1,131 +1,134 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria.internal;
 
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.RelationDescription;
 import org.hibernate.envers.internal.entities.RelationType;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.query.criteria.AuditId;
 import org.hibernate.envers.query.internal.property.PropertyNameGetter;
 import org.hibernate.type.EmbeddedComponentType;
 import org.hibernate.type.Type;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public abstract class CriteriaTools {
 	public static void checkPropertyNotARelation(
-			AuditConfiguration verCfg, String entityName,
+			EnversService enversService,
+			String entityName,
 			String propertyName) throws AuditException {
-		if ( verCfg.getEntCfg().get( entityName ).isRelation( propertyName ) ) {
+		if ( enversService.getEntitiesConfigurations().get( entityName ).isRelation( propertyName ) ) {
 			throw new AuditException(
 					"This criterion cannot be used on a property that is " +
 							"a relation to another property."
 			);
 		}
 	}
 
 	public static RelationDescription getRelatedEntity(
-			AuditConfiguration verCfg, String entityName,
+			EnversService enversService,
+			String entityName,
 			String propertyName) throws AuditException {
-		RelationDescription relationDesc = verCfg.getEntCfg().getRelationDescription( entityName, propertyName );
+		RelationDescription relationDesc = enversService.getEntitiesConfigurations().getRelationDescription( entityName, propertyName );
 
 		if ( relationDesc == null ) {
 			return null;
 		}
 
 		if ( relationDesc.getRelationType() == RelationType.TO_ONE ) {
 			return relationDesc;
 		}
 
 		throw new AuditException(
 				"This type of relation (" + entityName + "." + propertyName +
 						") isn't supported and can't be used in queries."
 		);
 	}
 
-	/**
-	 * @see #determinePropertyName(AuditConfiguration, AuditReaderImplementor, String, String)
-	 */
 	public static String determinePropertyName(
-			AuditConfiguration auditCfg, AuditReaderImplementor versionsReader,
-			String entityName, PropertyNameGetter propertyNameGetter) {
-		return determinePropertyName( auditCfg, versionsReader, entityName, propertyNameGetter.get( auditCfg ) );
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			PropertyNameGetter propertyNameGetter) {
+		return determinePropertyName( enversService, versionsReader, entityName, propertyNameGetter.get( enversService ) );
 	}
 
 	/**
-	 * @param auditCfg Audit configuration.
+	 * @param enversService The EnversService
 	 * @param versionsReader Versions reader.
 	 * @param entityName Original entity name (not audited).
 	 * @param propertyName Property name or placeholder.
 	 *
 	 * @return Path to property. Handles identifier placeholder used by {@link org.hibernate.envers.query.criteria.AuditId}.
 	 */
 	public static String determinePropertyName(
-			AuditConfiguration auditCfg, AuditReaderImplementor versionsReader,
-			String entityName, String propertyName) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			String propertyName) {
 		final SessionFactoryImplementor sessionFactory = versionsReader.getSessionImplementor().getFactory();
 
 		if ( AuditId.IDENTIFIER_PLACEHOLDER.equals( propertyName ) ) {
 			final String identifierPropertyName = sessionFactory.getEntityPersister( entityName ).getIdentifierPropertyName();
-			propertyName = auditCfg.getAuditEntCfg().getOriginalIdPropName() + "." + identifierPropertyName;
+			propertyName = enversService.getAuditEntitiesConfiguration().getOriginalIdPropName() + "." + identifierPropertyName;
 		}
 		else {
 			final List<String> identifierPropertyNames = identifierPropertyNames( sessionFactory, entityName );
 			if ( identifierPropertyNames.contains( propertyName ) ) {
-				propertyName = auditCfg.getAuditEntCfg().getOriginalIdPropName() + "." + propertyName;
+				propertyName = enversService.getAuditEntitiesConfiguration().getOriginalIdPropName() + "." + propertyName;
 			}
 		}
 
 		return propertyName;
 	}
 
 	/**
 	 * @param sessionFactory Session factory.
 	 * @param entityName Entity name.
 	 *
 	 * @return List of property names representing entity identifier.
 	 */
 	private static List<String> identifierPropertyNames(SessionFactoryImplementor sessionFactory, String entityName) {
 		final String identifierPropertyName = sessionFactory.getEntityPersister( entityName ).getIdentifierPropertyName();
 		if ( identifierPropertyName != null ) {
 			// Single id.
 			return Arrays.asList( identifierPropertyName );
 		}
 		final Type identifierType = sessionFactory.getEntityPersister( entityName ).getIdentifierType();
 		if ( identifierType instanceof EmbeddedComponentType ) {
 			// Multiple ids.
 			final EmbeddedComponentType embeddedComponentType = (EmbeddedComponentType) identifierType;
 			return Arrays.asList( embeddedComponentType.getPropertyNames() );
 		}
-		return Collections.EMPTY_LIST;
+		return Collections.emptyList();
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/IdentifierEqAuditExpression.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/IdentifierEqAuditExpression.java
index 6f81d26b01..0ee9495503 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/IdentifierEqAuditExpression.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/IdentifierEqAuditExpression.java
@@ -1,52 +1,57 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria.internal;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 
 /**
  * A criterion that expresses that the id of an entity is equal or not equal to some specified value.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public class IdentifierEqAuditExpression implements AuditCriterion {
 	private final Object id;
 	private final boolean equals;
 
 	public IdentifierEqAuditExpression(Object id, boolean equals) {
 		this.id = id;
 		this.equals = equals;
 	}
 
+	@Override
 	public void addToQuery(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters) {
-		verCfg.getEntCfg().get( entityName ).getIdMapper()
-				.addIdEqualsToQuery( parameters, id, verCfg.getAuditEntCfg().getOriginalIdPropName(), equals );
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters) {
+		enversService.getEntitiesConfigurations().get( entityName )
+				.getIdMapper()
+				.addIdEqualsToQuery( parameters, id, enversService.getAuditEntitiesConfiguration().getOriginalIdPropName(), equals );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/IlikeAuditExpression.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/IlikeAuditExpression.java
index a2647a6132..a188e1f14b 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/IlikeAuditExpression.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/IlikeAuditExpression.java
@@ -1,34 +1,36 @@
 package org.hibernate.envers.query.criteria.internal;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 import org.hibernate.envers.query.internal.property.PropertyNameGetter;
 
 public class IlikeAuditExpression implements AuditCriterion {
 
 	private PropertyNameGetter propertyNameGetter;
 	private String value;
 
 	public IlikeAuditExpression(PropertyNameGetter propertyNameGetter, String value) {
 		this.propertyNameGetter = propertyNameGetter;
 		this.value = value;
 	}
 
-	public void addToQuery(AuditConfiguration auditCfg,
+	public void addToQuery(
+			EnversService enversService,
 			AuditReaderImplementor versionsReader, String entityName,
 			QueryBuilder qb, Parameters parameters) {
 
 		String propertyName = CriteriaTools.determinePropertyName(
-				auditCfg,
+				enversService,
 				versionsReader,
 				entityName,
-				propertyNameGetter);
-		CriteriaTools.checkPropertyNotARelation( auditCfg, entityName, propertyName );
+				propertyNameGetter
+		);
+		CriteriaTools.checkPropertyNotARelation( enversService, entityName, propertyName );
 
 		parameters.addWhereWithFunction( propertyName, " lower ", " like ", value.toLowerCase() );
 	}
 
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/InAuditExpression.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/InAuditExpression.java
index 8e9aca71a9..425ba5ad36 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/InAuditExpression.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/InAuditExpression.java
@@ -1,57 +1,60 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria.internal;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 import org.hibernate.envers.query.internal.property.PropertyNameGetter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class InAuditExpression implements AuditCriterion {
 	private PropertyNameGetter propertyNameGetter;
 	private Object[] values;
 
 	public InAuditExpression(PropertyNameGetter propertyNameGetter, Object[] values) {
 		this.propertyNameGetter = propertyNameGetter;
 		this.values = values;
 	}
 
 	public void addToQuery(
-			AuditConfiguration auditCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters) {
 		String propertyName = CriteriaTools.determinePropertyName(
-				auditCfg,
+				enversService,
 				versionsReader,
 				entityName,
 				propertyNameGetter
 		);
-		CriteriaTools.checkPropertyNotARelation( auditCfg, entityName, propertyName );
+		CriteriaTools.checkPropertyNotARelation( enversService, entityName, propertyName );
 		parameters.addWhereWithParams( propertyName, "in (", values, ")" );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/LogicalAuditExpression.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/LogicalAuditExpression.java
index 3888ac120d..c49c77e456 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/LogicalAuditExpression.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/LogicalAuditExpression.java
@@ -1,54 +1,57 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria.internal;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class LogicalAuditExpression implements AuditCriterion {
 	private AuditCriterion lhs;
 	private AuditCriterion rhs;
 	private String op;
 
 	public LogicalAuditExpression(AuditCriterion lhs, AuditCriterion rhs, String op) {
 		this.lhs = lhs;
 		this.rhs = rhs;
 		this.op = op;
 	}
 
 	public void addToQuery(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters) {
 		Parameters opParameters = parameters.addSubParameters( op );
 
-		lhs.addToQuery( verCfg, versionsReader, entityName, qb, opParameters.addSubParameters( "and" ) );
-		rhs.addToQuery( verCfg, versionsReader, entityName, qb, opParameters.addSubParameters( "and" ) );
+		lhs.addToQuery( enversService, versionsReader, entityName, qb, opParameters.addSubParameters( "and" ) );
+		rhs.addToQuery( enversService, versionsReader, entityName, qb, opParameters.addSubParameters( "and" ) );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/NotAuditExpression.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/NotAuditExpression.java
index 95075d29c5..1c1366c8a7 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/NotAuditExpression.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/NotAuditExpression.java
@@ -1,47 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria.internal;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class NotAuditExpression implements AuditCriterion {
 	private AuditCriterion criterion;
 
 	public NotAuditExpression(AuditCriterion criterion) {
 		this.criterion = criterion;
 	}
 
 	public void addToQuery(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters) {
-		criterion.addToQuery( verCfg, versionsReader, entityName, qb, parameters.addNegatedParameters() );
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters) {
+		criterion.addToQuery( enversService, versionsReader, entityName, qb, parameters.addNegatedParameters() );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/NotNullAuditExpression.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/NotNullAuditExpression.java
index b0d3c1f87b..d26c6276af 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/NotNullAuditExpression.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/NotNullAuditExpression.java
@@ -1,62 +1,65 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria.internal;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.RelationDescription;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 import org.hibernate.envers.query.internal.property.PropertyNameGetter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class NotNullAuditExpression implements AuditCriterion {
 	private PropertyNameGetter propertyNameGetter;
 
 	public NotNullAuditExpression(PropertyNameGetter propertyNameGetter) {
 		this.propertyNameGetter = propertyNameGetter;
 	}
 
 	public void addToQuery(
-			AuditConfiguration auditCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters) {
 		String propertyName = CriteriaTools.determinePropertyName(
-				auditCfg,
+				enversService,
 				versionsReader,
 				entityName,
 				propertyNameGetter
 		);
-		RelationDescription relatedEntity = CriteriaTools.getRelatedEntity( auditCfg, entityName, propertyName );
+		RelationDescription relatedEntity = CriteriaTools.getRelatedEntity( enversService, entityName, propertyName );
 
 		if ( relatedEntity == null ) {
 			parameters.addNotNullRestriction( propertyName, true );
 		}
 		else {
 			relatedEntity.getIdMapper().addIdEqualsToQuery( parameters, null, null, false );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/NullAuditExpression.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/NullAuditExpression.java
index 5caa070226..b49a10eaa2 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/NullAuditExpression.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/NullAuditExpression.java
@@ -1,62 +1,65 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria.internal;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.entities.RelationDescription;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 import org.hibernate.envers.query.internal.property.PropertyNameGetter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class NullAuditExpression implements AuditCriterion {
 	private PropertyNameGetter propertyNameGetter;
 
 	public NullAuditExpression(PropertyNameGetter propertyNameGetter) {
 		this.propertyNameGetter = propertyNameGetter;
 	}
 
 	public void addToQuery(
-			AuditConfiguration auditCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters) {
 		String propertyName = CriteriaTools.determinePropertyName(
-				auditCfg,
+				enversService,
 				versionsReader,
 				entityName,
 				propertyNameGetter
 		);
-		RelationDescription relatedEntity = CriteriaTools.getRelatedEntity( auditCfg, entityName, propertyName );
+		RelationDescription relatedEntity = CriteriaTools.getRelatedEntity( enversService, entityName, propertyName );
 
 		if ( relatedEntity == null ) {
 			parameters.addNullRestriction( propertyName, true );
 		}
 		else {
 			relatedEntity.getIdMapper().addIdEqualsToQuery( parameters, null, null, true );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/PropertyAuditExpression.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/PropertyAuditExpression.java
index 71f0402336..b3547413da 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/PropertyAuditExpression.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/PropertyAuditExpression.java
@@ -1,60 +1,62 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria.internal;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 import org.hibernate.envers.query.internal.property.PropertyNameGetter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class PropertyAuditExpression implements AuditCriterion {
 	private PropertyNameGetter propertyNameGetter;
 	private String otherPropertyName;
 	private String op;
 
 	public PropertyAuditExpression(PropertyNameGetter propertyNameGetter, String otherPropertyName, String op) {
 		this.propertyNameGetter = propertyNameGetter;
 		this.otherPropertyName = otherPropertyName;
 		this.op = op;
 	}
 
 	public void addToQuery(
-			AuditConfiguration auditCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters) {
+			EnversService enversService, AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters) {
 		String propertyName = CriteriaTools.determinePropertyName(
-				auditCfg,
+				enversService,
 				versionsReader,
 				entityName,
 				propertyNameGetter
 		);
-		CriteriaTools.checkPropertyNotARelation( auditCfg, entityName, propertyName );
-		CriteriaTools.checkPropertyNotARelation( auditCfg, entityName, otherPropertyName );
+		CriteriaTools.checkPropertyNotARelation( enversService, entityName, propertyName );
+		CriteriaTools.checkPropertyNotARelation( enversService, entityName, otherPropertyName );
 		parameters.addWhere( propertyName, op, otherPropertyName );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/RelatedAuditExpression.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/RelatedAuditExpression.java
index ea7aac824a..6109ebbb95 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/RelatedAuditExpression.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/RelatedAuditExpression.java
@@ -1,72 +1,75 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria.internal;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.RelationDescription;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 import org.hibernate.envers.query.internal.property.PropertyNameGetter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class RelatedAuditExpression implements AuditCriterion {
 	private final PropertyNameGetter propertyNameGetter;
 	private final Object id;
 	private final boolean equals;
 
 	public RelatedAuditExpression(PropertyNameGetter propertyNameGetter, Object id, boolean equals) {
 		this.propertyNameGetter = propertyNameGetter;
 		this.id = id;
 		this.equals = equals;
 	}
 
 	@Override
 	public void addToQuery(
-			AuditConfiguration auditCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters) {
 		String propertyName = CriteriaTools.determinePropertyName(
-				auditCfg,
+				enversService,
 				versionsReader,
 				entityName,
 				propertyNameGetter
 		);
 
-		RelationDescription relatedEntity = CriteriaTools.getRelatedEntity( auditCfg, entityName, propertyName );
+		RelationDescription relatedEntity = CriteriaTools.getRelatedEntity( enversService, entityName, propertyName );
 
 		if ( relatedEntity == null ) {
 			throw new AuditException(
 					"This criterion can only be used on a property that is " +
 							"a relation to another property."
 			);
 		}
 		else {
 			relatedEntity.getIdMapper().addIdEqualsToQuery( parameters, id, null, equals );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/RevisionTypeAuditExpression.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/RevisionTypeAuditExpression.java
index cf66aa30f6..ec378eecbc 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/RevisionTypeAuditExpression.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/RevisionTypeAuditExpression.java
@@ -1,50 +1,53 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria.internal;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class RevisionTypeAuditExpression implements AuditCriterion {
 	private Object value;
 	private String op;
 
 	public RevisionTypeAuditExpression(Object value, String op) {
 		this.value = value;
 		this.op = op;
 	}
 
 	@Override
 	public void addToQuery(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters) {
-		parameters.addWhereWithParam( verCfg.getAuditEntCfg().getRevisionTypePropName(), op, value );
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters) {
+		parameters.addWhereWithParam( enversService.getAuditEntitiesConfiguration().getRevisionTypePropName(), op, value );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/SimpleAuditExpression.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/SimpleAuditExpression.java
index 4fa8a076d3..f2517d50f9 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/SimpleAuditExpression.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/criteria/internal/SimpleAuditExpression.java
@@ -1,77 +1,80 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.criteria.internal;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.RelationDescription;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 import org.hibernate.envers.query.internal.property.PropertyNameGetter;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class SimpleAuditExpression implements AuditCriterion {
 	private PropertyNameGetter propertyNameGetter;
 	private Object value;
 	private String op;
 
 	public SimpleAuditExpression(PropertyNameGetter propertyNameGetter, Object value, String op) {
 		this.propertyNameGetter = propertyNameGetter;
 		this.value = value;
 		this.op = op;
 	}
 
 	public void addToQuery(
-			AuditConfiguration auditCfg, AuditReaderImplementor versionsReader, String entityName,
-			QueryBuilder qb, Parameters parameters) {
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			String entityName,
+			QueryBuilder qb,
+			Parameters parameters) {
 		String propertyName = CriteriaTools.determinePropertyName(
-				auditCfg,
+				enversService,
 				versionsReader,
 				entityName,
 				propertyNameGetter
 		);
 
-		RelationDescription relatedEntity = CriteriaTools.getRelatedEntity( auditCfg, entityName, propertyName );
+		RelationDescription relatedEntity = CriteriaTools.getRelatedEntity( enversService, entityName, propertyName );
 
 		if ( relatedEntity == null ) {
 			parameters.addWhereWithParam( propertyName, op, value );
 		}
 		else {
 			if ( !"=".equals( op ) && !"<>".equals( op ) ) {
 				throw new AuditException(
 						"This type of operation: " + op + " (" + entityName + "." + propertyName +
 								") isn't supported and can't be used in queries."
 				);
 			}
 
 			Object id = relatedEntity.getIdMapper().mapToIdFromEntity( value );
 
 			relatedEntity.getIdMapper().addIdEqualsToQuery( parameters, id, null, "=".equals( op ) );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/AbstractAuditQuery.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/AbstractAuditQuery.java
index 272d37da94..8dcc536e3d 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/AbstractAuditQuery.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/AbstractAuditQuery.java
@@ -1,266 +1,267 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.internal.impl;
 
 import java.util.ArrayList;
 import java.util.List;
 import javax.persistence.NoResultException;
 import javax.persistence.NonUniqueResultException;
 
 import org.hibernate.CacheMode;
 import org.hibernate.FlushMode;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.Query;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.entities.EntityInstantiator;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.internal.tools.Triple;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 import org.hibernate.envers.query.AuditQuery;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 import org.hibernate.envers.query.criteria.internal.CriteriaTools;
 import org.hibernate.envers.query.order.AuditOrder;
 import org.hibernate.envers.query.projection.AuditProjection;
 import org.hibernate.envers.tools.Pair;
 
 import static org.hibernate.envers.internal.entities.mapper.relation.query.QueryConstants.REFERENCED_ENTITY_ALIAS;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  */
 public abstract class AbstractAuditQuery implements AuditQuery {
 	protected EntityInstantiator entityInstantiator;
 	protected List<AuditCriterion> criterions;
 
 	protected String entityName;
 	protected String entityClassName;
 	protected String versionsEntityName;
 	protected QueryBuilder qb;
 
 	protected boolean hasProjection;
 	protected boolean hasOrder;
 
-	protected final AuditConfiguration verCfg;
+	protected final EnversService enversService;
 	protected final AuditReaderImplementor versionsReader;
 
 	protected AbstractAuditQuery(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader,
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
 			Class<?> cls) {
-		this( verCfg, versionsReader, cls, cls.getName() );
+		this( enversService, versionsReader, cls, cls.getName() );
 	}
 
 	protected AbstractAuditQuery(
-			AuditConfiguration verCfg,
-			AuditReaderImplementor versionsReader, Class<?> cls, String entityName) {
-		this.verCfg = verCfg;
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			Class<?> cls,
+			String entityName) {
+		this.enversService = enversService;
 		this.versionsReader = versionsReader;
 
 		criterions = new ArrayList<AuditCriterion>();
-		entityInstantiator = new EntityInstantiator( verCfg, versionsReader );
+		entityInstantiator = new EntityInstantiator( enversService, versionsReader );
 
 		entityClassName = cls.getName();
 		this.entityName = entityName;
-		versionsEntityName = verCfg.getAuditEntCfg().getAuditEntityName(
-				entityName
-		);
+		versionsEntityName = enversService.getAuditEntitiesConfiguration().getAuditEntityName( entityName );
 
 		qb = new QueryBuilder( versionsEntityName, REFERENCED_ENTITY_ALIAS );
 	}
 
 	protected Query buildQuery() {
 		Query query = qb.toQuery( versionsReader.getSession() );
 		setQueryProperties( query );
 		return query;
 	}
 
 	protected List buildAndExecuteQuery() {
 		Query query = buildQuery();
 
 		return query.list();
 	}
 
 	public abstract List list() throws AuditException;
 
 	public List getResultList() throws AuditException {
 		return list();
 	}
 
 	public Object getSingleResult() throws AuditException, NonUniqueResultException, NoResultException {
 		List result = list();
 
 		if ( result == null || result.size() == 0 ) {
 			throw new NoResultException();
 		}
 
 		if ( result.size() > 1 ) {
 			throw new NonUniqueResultException();
 		}
 
 		return result.get( 0 );
 	}
 
 	public AuditQuery add(AuditCriterion criterion) {
 		criterions.add( criterion );
 		return this;
 	}
 
 	// Projection and order
 
 	public AuditQuery addProjection(AuditProjection projection) {
-		Triple<String, String, Boolean> projectionData = projection.getData( verCfg );
+		Triple<String, String, Boolean> projectionData = projection.getData( enversService );
 		hasProjection = true;
 		String propertyName = CriteriaTools.determinePropertyName(
-				verCfg,
+				enversService,
 				versionsReader,
 				entityName,
 				projectionData.getSecond()
 		);
 		qb.addProjection( projectionData.getFirst(), propertyName, projectionData.getThird() );
 		return this;
 	}
 
 	public AuditQuery addOrder(AuditOrder order) {
 		hasOrder = true;
-		Pair<String, Boolean> orderData = order.getData( verCfg );
+		Pair<String, Boolean> orderData = order.getData( enversService );
 		String propertyName = CriteriaTools.determinePropertyName(
-				verCfg,
+				enversService,
 				versionsReader,
 				entityName,
 				orderData.getFirst()
 		);
 		qb.addOrder( propertyName, orderData.getSecond() );
 		return this;
 	}
 
 	// Query properties
 
 	private Integer maxResults;
 	private Integer firstResult;
 	private Boolean cacheable;
 	private String cacheRegion;
 	private String comment;
 	private FlushMode flushMode;
 	private CacheMode cacheMode;
 	private Integer timeout;
 	private LockOptions lockOptions = new LockOptions( LockMode.NONE );
 
 	public AuditQuery setMaxResults(int maxResults) {
 		this.maxResults = maxResults;
 		return this;
 	}
 
 	public AuditQuery setFirstResult(int firstResult) {
 		this.firstResult = firstResult;
 		return this;
 	}
 
 	public AuditQuery setCacheable(boolean cacheable) {
 		this.cacheable = cacheable;
 		return this;
 	}
 
 	public AuditQuery setCacheRegion(String cacheRegion) {
 		this.cacheRegion = cacheRegion;
 		return this;
 	}
 
 	public AuditQuery setComment(String comment) {
 		this.comment = comment;
 		return this;
 	}
 
 	public AuditQuery setFlushMode(FlushMode flushMode) {
 		this.flushMode = flushMode;
 		return this;
 	}
 
 	public AuditQuery setCacheMode(CacheMode cacheMode) {
 		this.cacheMode = cacheMode;
 		return this;
 	}
 
 	public AuditQuery setTimeout(int timeout) {
 		this.timeout = timeout;
 		return this;
 	}
 
 	/**
 	 * Set lock mode
 	 *
 	 * @param lockMode The {@link LockMode} used for this query.
 	 *
 	 * @return this object
 	 *
 	 * @deprecated Instead use setLockOptions
 	 */
 	public AuditQuery setLockMode(LockMode lockMode) {
 		lockOptions.setLockMode( lockMode );
 		return this;
 	}
 
 	/**
 	 * Set lock options
 	 *
 	 * @param lockOptions The @{link LockOptions} used for this query.
 	 *
 	 * @return this object
 	 */
 	public AuditQuery setLockOptions(LockOptions lockOptions) {
 		LockOptions.copy( lockOptions, this.lockOptions );
 		return this;
 	}
 
 	protected void setQueryProperties(Query query) {
 		if ( maxResults != null ) {
 			query.setMaxResults( maxResults );
 		}
 		if ( firstResult != null ) {
 			query.setFirstResult( firstResult );
 		}
 		if ( cacheable != null ) {
 			query.setCacheable( cacheable );
 		}
 		if ( cacheRegion != null ) {
 			query.setCacheRegion( cacheRegion );
 		}
 		if ( comment != null ) {
 			query.setComment( comment );
 		}
 		if ( flushMode != null ) {
 			query.setFlushMode( flushMode );
 		}
 		if ( cacheMode != null ) {
 			query.setCacheMode( cacheMode );
 		}
 		if ( timeout != null ) {
 			query.setTimeout( timeout );
 		}
 		if ( lockOptions != null && lockOptions.getLockMode() != LockMode.NONE ) {
 			query.setLockMode( REFERENCED_ENTITY_ALIAS, lockOptions.getLockMode() );
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/EntitiesAtRevisionQuery.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/EntitiesAtRevisionQuery.java
index 2bdbd2a7eb..73bad06290 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/EntitiesAtRevisionQuery.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/EntitiesAtRevisionQuery.java
@@ -1,141 +1,146 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.internal.impl;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
 import org.hibernate.Query;
 import org.hibernate.envers.RevisionType;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.configuration.internal.AuditEntitiesConfiguration;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleIdData;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 
 import static org.hibernate.envers.internal.entities.mapper.relation.query.QueryConstants.REFERENCED_ENTITY_ALIAS;
 import static org.hibernate.envers.internal.entities.mapper.relation.query.QueryConstants.REFERENCED_ENTITY_ALIAS_DEF_AUD_STR;
 import static org.hibernate.envers.internal.entities.mapper.relation.query.QueryConstants.REVISION_PARAMETER;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  */
 public class EntitiesAtRevisionQuery extends AbstractAuditQuery {
 	private final Number revision;
 	private final boolean includeDeletions;
 
 	public EntitiesAtRevisionQuery(
-			AuditConfiguration verCfg,
-			AuditReaderImplementor versionsReader, Class<?> cls,
-			Number revision, boolean includeDeletions) {
-		super( verCfg, versionsReader, cls );
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			Class<?> cls,
+			Number revision,
+			boolean includeDeletions) {
+		super( enversService, versionsReader, cls );
 		this.revision = revision;
 		this.includeDeletions = includeDeletions;
 	}
 
 	public EntitiesAtRevisionQuery(
-			AuditConfiguration verCfg,
+			EnversService enversService,
 			AuditReaderImplementor versionsReader, Class<?> cls,
 			String entityName, Number revision, boolean includeDeletions) {
-		super( verCfg, versionsReader, cls, entityName );
+		super( enversService, versionsReader, cls, entityName );
 		this.revision = revision;
 		this.includeDeletions = includeDeletions;
 	}
 
 	@SuppressWarnings({"unchecked"})
 	public List list() {
 		/*
          * The query that we need to create:
          *   SELECT new list(e) FROM versionsReferencedEntity e
          *   WHERE
          * (all specified conditions, transformed, on the "e" entity) AND
          * (selecting e entities at revision :revision)
          *   --> for DefaultAuditStrategy:
          *     e.revision = (SELECT max(e2.revision) FROM versionsReferencedEntity e2
          *       WHERE e2.revision <= :revision AND e2.id = e.id) 
          *     
          *   --> for ValidityAuditStrategy:
          *     e.revision <= :revision and (e.endRevision > :revision or e.endRevision is null)
          *     
          *     AND
          * (only non-deleted entities)
          *     e.revision_type != DEL
          */
-		AuditEntitiesConfiguration verEntCfg = verCfg.getAuditEntCfg();
+		AuditEntitiesConfiguration verEntCfg = enversService.getAuditEntitiesConfiguration();
 		String revisionPropertyPath = verEntCfg.getRevisionNumberPath();
 		String originalIdPropertyName = verEntCfg.getOriginalIdPropName();
 
 		MiddleIdData referencedIdData = new MiddleIdData(
-				verEntCfg, verCfg.getEntCfg().get( entityName ).getIdMappingData(),
-				null, entityName, verCfg.getEntCfg().isVersioned( entityName )
+				verEntCfg,
+				enversService.getEntitiesConfigurations().get( entityName ).getIdMappingData(),
+				null,
+				entityName,
+				enversService.getEntitiesConfigurations().isVersioned( entityName )
 		);
 
 		// (selecting e entities at revision :revision)
 		// --> based on auditStrategy (see above)
-		verCfg.getAuditStrategy().addEntityAtRevisionRestriction(
-				verCfg.getGlobalCfg(),
+		enversService.getAuditStrategy().addEntityAtRevisionRestriction(
+				enversService.getGlobalConfiguration(),
 				qb,
 				qb.getRootParameters(),
 				revisionPropertyPath,
 				verEntCfg.getRevisionEndFieldName(),
 				true,
 				referencedIdData,
 				revisionPropertyPath,
 				originalIdPropertyName,
 				REFERENCED_ENTITY_ALIAS,
 				REFERENCED_ENTITY_ALIAS_DEF_AUD_STR,
 				true
 		);
 
 		if ( !includeDeletions ) {
 			// e.revision_type != DEL
 			qb.getRootParameters().addWhereWithParam( verEntCfg.getRevisionTypePropName(), "<>", RevisionType.DEL );
 		}
 
 		// all specified conditions
 		for ( AuditCriterion criterion : criterions ) {
-			criterion.addToQuery( verCfg, versionsReader, entityName, qb, qb.getRootParameters() );
+			criterion.addToQuery( enversService, versionsReader, entityName, qb, qb.getRootParameters() );
 		}
 
 		Query query = buildQuery();
 		// add named parameter (only used for ValidAuditTimeStrategy)
 		List<String> params = Arrays.asList( query.getNamedParameters() );
 		if ( params.contains( REVISION_PARAMETER ) ) {
 			query.setParameter( REVISION_PARAMETER, revision );
 		}
 		List queryResult = query.list();
 
 		if ( hasProjection ) {
 			return queryResult;
 		}
 		else {
 			List result = new ArrayList();
 			entityInstantiator.addInstancesFromVersionsEntities( entityName, result, queryResult, revision );
 
 			return result;
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/EntitiesModifiedAtRevisionQuery.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/EntitiesModifiedAtRevisionQuery.java
index 6045bc2dc2..036363a527 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/EntitiesModifiedAtRevisionQuery.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/EntitiesModifiedAtRevisionQuery.java
@@ -1,68 +1,73 @@
 package org.hibernate.envers.query.internal.impl;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.hibernate.Query;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.configuration.internal.AuditEntitiesConfiguration;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 
 /**
  * In comparison to {@link EntitiesAtRevisionQuery} this query returns an empty collection if an entity
  * of a certain type has not been changed in a given revision.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  * @see EntitiesAtRevisionQuery
  */
 public class EntitiesModifiedAtRevisionQuery extends AbstractAuditQuery {
 	private final Number revision;
 
 	public EntitiesModifiedAtRevisionQuery(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader,
-			Class<?> cls, Number revision) {
-		super( verCfg, versionsReader, cls );
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			Class<?> cls,
+			Number revision) {
+		super( enversService, versionsReader, cls );
 		this.revision = revision;
 	}
 
 	public EntitiesModifiedAtRevisionQuery(
-			AuditConfiguration verCfg, AuditReaderImplementor versionsReader,
-			Class<?> cls, String entityName, Number revision) {
-		super( verCfg, versionsReader, cls, entityName );
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			Class<?> cls,
+			String entityName,
+			Number revision) {
+		super( enversService, versionsReader, cls, entityName );
 		this.revision = revision;
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked"})
 	public List list() {
 		/*
          * The query that we need to create:
          *   SELECT new list(e) FROM versionsReferencedEntity e
          *   WHERE
          * (all specified conditions, transformed, on the "e" entity) AND
          * e.revision = :revision
          */
-		AuditEntitiesConfiguration verEntCfg = verCfg.getAuditEntCfg();
+		AuditEntitiesConfiguration verEntCfg = enversService.getAuditEntitiesConfiguration();
 		String revisionPropertyPath = verEntCfg.getRevisionNumberPath();
 		qb.getRootParameters().addWhereWithParam( revisionPropertyPath, "=", revision );
 
 		// all specified conditions
 		for ( AuditCriterion criterion : criterions ) {
-			criterion.addToQuery( verCfg, versionsReader, entityName, qb, qb.getRootParameters() );
+			criterion.addToQuery( enversService, versionsReader, entityName, qb, qb.getRootParameters() );
 		}
 
 		Query query = buildQuery();
 		List queryResult = query.list();
 
 		if ( hasProjection ) {
 			return queryResult;
 		}
 		else {
 			List result = new ArrayList();
 			entityInstantiator.addInstancesFromVersionsEntities( entityName, result, queryResult, revision );
 
 			return result;
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/RevisionsOfEntityQuery.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/RevisionsOfEntityQuery.java
index b60bff02c5..60886a79d1 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/RevisionsOfEntityQuery.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/impl/RevisionsOfEntityQuery.java
@@ -1,163 +1,166 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.internal.impl;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.envers.RevisionType;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.configuration.internal.AuditEntitiesConfiguration;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.internal.reader.AuditReaderImplementor;
 import org.hibernate.envers.query.criteria.AuditCriterion;
 import org.hibernate.proxy.HibernateProxy;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Hernn Chanfreau
  */
 public class RevisionsOfEntityQuery extends AbstractAuditQuery {
 	private final boolean selectEntitiesOnly;
 	private final boolean selectDeletedEntities;
 
 	public RevisionsOfEntityQuery(
-			AuditConfiguration verCfg,
+			EnversService enversService,
 			AuditReaderImplementor versionsReader,
-			Class<?> cls, boolean selectEntitiesOnly,
+			Class<?> cls,
+			boolean selectEntitiesOnly,
 			boolean selectDeletedEntities) {
-		super( verCfg, versionsReader, cls );
+		super( enversService, versionsReader, cls );
 
 		this.selectEntitiesOnly = selectEntitiesOnly;
 		this.selectDeletedEntities = selectDeletedEntities;
 	}
 
 	public RevisionsOfEntityQuery(
-			AuditConfiguration verCfg,
-			AuditReaderImplementor versionsReader, Class<?> cls, String entityName,
-			boolean selectEntitiesOnly, boolean selectDeletedEntities) {
-		super( verCfg, versionsReader, cls, entityName );
+			EnversService enversService,
+			AuditReaderImplementor versionsReader,
+			Class<?> cls, String entityName,
+			boolean selectEntitiesOnly,
+			boolean selectDeletedEntities) {
+		super( enversService, versionsReader, cls, entityName );
 
 		this.selectEntitiesOnly = selectEntitiesOnly;
 		this.selectDeletedEntities = selectDeletedEntities;
 	}
 
 	private Number getRevisionNumber(Map versionsEntity) {
-		AuditEntitiesConfiguration verEntCfg = verCfg.getAuditEntCfg();
+		AuditEntitiesConfiguration verEntCfg = enversService.getAuditEntitiesConfiguration();
 
 		String originalId = verEntCfg.getOriginalIdPropName();
 		String revisionPropertyName = verEntCfg.getRevisionFieldName();
 
 		Object revisionInfoObject = ((Map) versionsEntity.get( originalId )).get( revisionPropertyName );
 
 		if ( revisionInfoObject instanceof HibernateProxy ) {
 			return (Number) ((HibernateProxy) revisionInfoObject).getHibernateLazyInitializer().getIdentifier();
 		}
 		else {
 			// Not a proxy - must be read from cache or with a join
-			return verCfg.getRevisionInfoNumberReader().getRevisionNumber( revisionInfoObject );
+			return enversService.getRevisionInfoNumberReader().getRevisionNumber( revisionInfoObject );
 		}
 	}
 
 	@SuppressWarnings({"unchecked"})
 	public List list() throws AuditException {
-		AuditEntitiesConfiguration verEntCfg = verCfg.getAuditEntCfg();
+		AuditEntitiesConfiguration verEntCfg = enversService.getAuditEntitiesConfiguration();
 
         /*
 		The query that should be executed in the versions table:
         SELECT e (unless another projection is specified) FROM ent_ver e, rev_entity r WHERE
           e.revision_type != DEL (if selectDeletedEntities == false) AND
           e.revision = r.revision AND
           (all specified conditions, transformed, on the "e" entity)
           ORDER BY e.revision ASC (unless another order or projection is specified)
          */
 		if ( !selectDeletedEntities ) {
 			// e.revision_type != DEL AND
 			qb.getRootParameters().addWhereWithParam( verEntCfg.getRevisionTypePropName(), "<>", RevisionType.DEL );
 		}
 
 		// all specified conditions, transformed
 		for ( AuditCriterion criterion : criterions ) {
-			criterion.addToQuery( verCfg, versionsReader, entityName, qb, qb.getRootParameters() );
+			criterion.addToQuery( enversService, versionsReader, entityName, qb, qb.getRootParameters() );
 		}
 
 		if ( !hasProjection && !hasOrder ) {
 			String revisionPropertyPath = verEntCfg.getRevisionNumberPath();
 			qb.addOrder( revisionPropertyPath, true );
 		}
 
 		if ( !selectEntitiesOnly ) {
-			qb.addFrom( verCfg.getAuditEntCfg().getRevisionInfoEntityName(), "r" );
+			qb.addFrom( enversService.getAuditEntitiesConfiguration().getRevisionInfoEntityName(), "r" );
 			qb.getRootParameters().addWhere(
-					verCfg.getAuditEntCfg().getRevisionNumberPath(),
+					enversService.getAuditEntitiesConfiguration().getRevisionNumberPath(),
 					true,
 					"=",
 					"r.id",
 					false
 			);
 		}
 
 		List<Object> queryResult = buildAndExecuteQuery();
 		if ( hasProjection ) {
 			return queryResult;
 		}
 		else {
 			List entities = new ArrayList();
 			String revisionTypePropertyName = verEntCfg.getRevisionTypePropName();
 
 			for ( Object resultRow : queryResult ) {
 				Map versionsEntity;
 				Object revisionData;
 
 				if ( selectEntitiesOnly ) {
 					versionsEntity = (Map) resultRow;
 					revisionData = null;
 				}
 				else {
 					Object[] arrayResultRow = (Object[]) resultRow;
 					versionsEntity = (Map) arrayResultRow[0];
 					revisionData = arrayResultRow[1];
 				}
 
 				Number revision = getRevisionNumber( versionsEntity );
 
 				Object entity = entityInstantiator.createInstanceFromVersionsEntity(
 						entityName,
 						versionsEntity,
 						revision
 				);
 
 				if ( !selectEntitiesOnly ) {
 					entities.add( new Object[] {entity, revisionData, versionsEntity.get( revisionTypePropertyName )} );
 				}
 				else {
 					entities.add( entity );
 				}
 			}
 
 			return entities;
 		}
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/EntityPropertyName.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/EntityPropertyName.java
index daa6d925bf..c002f769e1 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/EntityPropertyName.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/EntityPropertyName.java
@@ -1,43 +1,43 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.internal.property;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 
 /**
  * Used for specifying restrictions on a property of an audited entity.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public class EntityPropertyName implements PropertyNameGetter {
 	private final String propertyName;
 
 	public EntityPropertyName(String propertyName) {
 		this.propertyName = propertyName;
 	}
 
-	public String get(AuditConfiguration auditCfg) {
+	public String get(EnversService enversService) {
 		return propertyName;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/ModifiedFlagPropertyName.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/ModifiedFlagPropertyName.java
index 902ddeebcb..bf9fe018fc 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/ModifiedFlagPropertyName.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/ModifiedFlagPropertyName.java
@@ -1,47 +1,47 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.internal.property;
 
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.configuration.internal.metadata.MetadataTools;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
 
 /**
  * PropertyNameGetter for modified flags
  *
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public class ModifiedFlagPropertyName implements PropertyNameGetter {
 	private final PropertyNameGetter propertyNameGetter;
 
 	public ModifiedFlagPropertyName(PropertyNameGetter propertyNameGetter) {
 		this.propertyNameGetter = propertyNameGetter;
 	}
 
-	public String get(AuditConfiguration auditCfg) {
+	public String get(EnversService enversService) {
 		return MetadataTools.getModifiedFlagPropertyName(
-				propertyNameGetter.get( auditCfg ),
-				auditCfg.getGlobalCfg().getModifiedFlagSuffix()
+				propertyNameGetter.get( enversService ),
+				enversService.getGlobalConfiguration().getModifiedFlagSuffix()
 		);
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/OriginalIdPropertyName.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/OriginalIdPropertyName.java
index a25d8300d4..fad9d8c77d 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/OriginalIdPropertyName.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/OriginalIdPropertyName.java
@@ -1,46 +1,46 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.internal.property;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.query.criteria.AuditId;
 
 /**
  * Used for specifying restrictions on the identifier.
  *
  * @author Adam Warski (adam at warski dot org)
  * @deprecated To be removed together with {@link AuditId#count(String)} in version 5.0.
  */
 public class OriginalIdPropertyName implements PropertyNameGetter {
 	private final String idPropertyName;
 
 	public OriginalIdPropertyName(String idPropertyName) {
 		this.idPropertyName = idPropertyName;
 	}
 
 	@Override
-	public String get(AuditConfiguration auditCfg) {
-		return auditCfg.getAuditEntCfg().getOriginalIdPropName() + "." + idPropertyName;
+	public String get(EnversService enversService) {
+		return enversService.getAuditEntitiesConfiguration().getOriginalIdPropName() + "." + idPropertyName;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/PropertyNameGetter.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/PropertyNameGetter.java
index b8ce13b04a..9234919aa3 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/PropertyNameGetter.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/PropertyNameGetter.java
@@ -1,40 +1,40 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.internal.property;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 
 /**
  * Provides a function to get the name of a property, which is used in a query, to apply some restrictions on it.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public interface PropertyNameGetter {
 	/**
-	 * @param auditCfg Audit configuration.
+	 * @param enversService The EnversService
 	 *
 	 * @return Name of the property, to be used in a query.
 	 */
-	public String get(AuditConfiguration auditCfg);
+	public String get(EnversService enversService);
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/RevisionNumberPropertyName.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/RevisionNumberPropertyName.java
index 6aec37975d..6554dfa9a9 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/RevisionNumberPropertyName.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/RevisionNumberPropertyName.java
@@ -1,38 +1,38 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.internal.property;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 
 /**
  * Used for specifying restrictions on the revision number, corresponding to an audit entity.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public class RevisionNumberPropertyName implements PropertyNameGetter {
 	@Override
-	public String get(AuditConfiguration auditCfg) {
-		return auditCfg.getAuditEntCfg().getRevisionNumberPath();
+	public String get(EnversService enversService) {
+		return enversService.getAuditEntitiesConfiguration().getRevisionNumberPath();
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/RevisionPropertyPropertyName.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/RevisionPropertyPropertyName.java
index 4d95a5d228..ec6ce33457 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/RevisionPropertyPropertyName.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/RevisionPropertyPropertyName.java
@@ -1,44 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.internal.property;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 
 /**
  * Used for specifying restrictions on a property of the revision entity, which is associated with an audit entity.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public class RevisionPropertyPropertyName implements PropertyNameGetter {
 	private final String propertyName;
 
 	public RevisionPropertyPropertyName(String propertyName) {
 		this.propertyName = propertyName;
 	}
 
 	@Override
-	public String get(AuditConfiguration auditCfg) {
-		return auditCfg.getAuditEntCfg().getRevisionPropPath( propertyName );
+	public String get(EnversService enversService) {
+		return enversService.getAuditEntitiesConfiguration().getRevisionPropPath( propertyName );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/RevisionTypePropertyName.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/RevisionTypePropertyName.java
index f88d456c64..c35a1aa8e8 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/RevisionTypePropertyName.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/internal/property/RevisionTypePropertyName.java
@@ -1,38 +1,38 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.internal.property;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 
 /**
  * Used for specifying restrictions on the revision number, corresponding to an audit entity.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public class RevisionTypePropertyName implements PropertyNameGetter {
 	@Override
-	public String get(AuditConfiguration auditCfg) {
-		return auditCfg.getAuditEntCfg().getRevisionTypePropName();
+	public String get(EnversService enversService) {
+		return enversService.getAuditEntitiesConfiguration().getRevisionTypePropName();
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/order/AuditOrder.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/order/AuditOrder.java
index d7c00b5eeb..e580bc0625 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/order/AuditOrder.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/order/AuditOrder.java
@@ -1,39 +1,39 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.order;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.tools.Pair;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public interface AuditOrder {
 	/**
-	 * @param auditCfg Configuration.
+	 * @param enversService The EnversService
 	 *
 	 * @return A pair: (property name, ascending?).
 	 */
-	Pair<String, Boolean> getData(AuditConfiguration auditCfg);
+	Pair<String, Boolean> getData(EnversService enversService);
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/order/internal/PropertyAuditOrder.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/order/internal/PropertyAuditOrder.java
index 1a0898e2ec..2bb4704d4b 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/order/internal/PropertyAuditOrder.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/order/internal/PropertyAuditOrder.java
@@ -1,47 +1,47 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.order.internal;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.query.internal.property.PropertyNameGetter;
 import org.hibernate.envers.query.order.AuditOrder;
 import org.hibernate.envers.tools.Pair;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class PropertyAuditOrder implements AuditOrder {
 	private final PropertyNameGetter propertyNameGetter;
 	private final boolean asc;
 
 	public PropertyAuditOrder(PropertyNameGetter propertyNameGetter, boolean asc) {
 		this.propertyNameGetter = propertyNameGetter;
 		this.asc = asc;
 	}
 
 	@Override
-	public Pair<String, Boolean> getData(AuditConfiguration auditCfg) {
-		return Pair.make( propertyNameGetter.get( auditCfg ), asc );
+	public Pair<String, Boolean> getData(EnversService enversService) {
+		return Pair.make( propertyNameGetter.get( enversService ), asc );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/projection/AuditProjection.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/projection/AuditProjection.java
index a1be2c6a63..3b95b6425d 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/projection/AuditProjection.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/projection/AuditProjection.java
@@ -1,39 +1,39 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.projection;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.tools.Triple;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public interface AuditProjection {
 	/**
-	 * @param auditCfg Configuration.
+	 * @param enversService The EnversService
 	 *
 	 * @return A triple: (function name - possibly null, property name, add distinct?).
 	 */
-	Triple<String, String, Boolean> getData(AuditConfiguration auditCfg);
+	Triple<String, String, Boolean> getData(EnversService enversService);
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/query/projection/internal/PropertyAuditProjection.java b/hibernate-envers/src/main/java/org/hibernate/envers/query/projection/internal/PropertyAuditProjection.java
index 60b0b2507a..fd60e4159b 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/query/projection/internal/PropertyAuditProjection.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/query/projection/internal/PropertyAuditProjection.java
@@ -1,51 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.query.projection.internal;
 
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.internal.tools.Triple;
 import org.hibernate.envers.query.internal.property.PropertyNameGetter;
 import org.hibernate.envers.query.projection.AuditProjection;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class PropertyAuditProjection implements AuditProjection {
 	private final PropertyNameGetter propertyNameGetter;
 	private final String function;
 	private final boolean distinct;
 
 	public PropertyAuditProjection(PropertyNameGetter propertyNameGetter, String function, boolean distinct) {
 		this.propertyNameGetter = propertyNameGetter;
 		this.function = function;
 		this.distinct = distinct;
 	}
 
 	@Override
-	public Triple<String, String, Boolean> getData(AuditConfiguration auditCfg) {
-		String propertyName = propertyNameGetter.get( auditCfg );
+	public Triple<String, String, Boolean> getData(EnversService enversService) {
+		String propertyName = propertyNameGetter.get( enversService );
 
 		return Triple.make( function, propertyName, distinct );
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/strategy/AuditStrategy.java b/hibernate-envers/src/main/java/org/hibernate/envers/strategy/AuditStrategy.java
index 7dedd7eb78..87e6f354e1 100755
--- a/hibernate-envers/src/main/java/org/hibernate/envers/strategy/AuditStrategy.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/strategy/AuditStrategy.java
@@ -1,121 +1,139 @@
 package org.hibernate.envers.strategy;
 
 import java.io.Serializable;
 
 import org.hibernate.Session;
 import org.hibernate.collection.spi.PersistentCollection;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.configuration.internal.GlobalConfiguration;
 import org.hibernate.envers.configuration.spi.AuditConfiguration;
 import org.hibernate.envers.internal.entities.mapper.PersistentCollectionChangeData;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleComponentData;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleIdData;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 
 /**
  * Behaviours of different audit strategy for populating audit data.
  *
  * @author Stephanie Pau
  * @author Adam Warski (adam at warski dot org)
  */
 public interface AuditStrategy {
 	/**
 	 * Perform the persistence of audited data for regular entities.
 	 *
 	 * @param session Session, which can be used to persist the data.
 	 * @param entityName Name of the entity, in which the audited change happens
-	 * @param auditCfg Audit configuration
+	 * @param enversService The EnversService
 	 * @param id Id of the entity.
 	 * @param data Audit data to persist
 	 * @param revision Current revision data
 	 */
 	void perform(
-			Session session, String entityName, AuditConfiguration auditCfg, Serializable id, Object data,
+			Session session,
+			String entityName,
+			EnversService enversService,
+			Serializable id,
+			Object data,
 			Object revision);
 
 	/**
 	 * Perform the persistence of audited data for collection ("middle") entities.
 	 *
 	 * @param session Session, which can be used to persist the data.
 	 * @param entityName Name of the entity, in which the audited change happens.
 	 * @param propertyName The name of the property holding the {@link PersistentCollection}.
-	 * @param auditCfg Audit configuration
+	 * @param enversService The EnversService
 	 * @param persistentCollectionChangeData Collection change data to be persisted.
 	 * @param revision Current revision data
 	 */
 	void performCollectionChange(
-			Session session, String entityName, String propertyName, AuditConfiguration auditCfg,
-			PersistentCollectionChangeData persistentCollectionChangeData, Object revision);
+			Session session,
+			String entityName,
+			String propertyName,
+			EnversService enversService,
+			PersistentCollectionChangeData persistentCollectionChangeData,
+			Object revision);
 
 
 	/**
 	 * Update the rootQueryBuilder with an extra WHERE clause to restrict the revision for a two-entity relation.
 	 * This WHERE clause depends on the AuditStrategy, as follows:
 	 * <ul>
 	 * <li>For {@link DefaultAuditStrategy} a subquery is created:
 	 * <p><code>e.revision = (SELECT max(...) ...)</code></p>
 	 * </li>
 	 * <li>for {@link ValidityAuditStrategy} the revision-end column is used:
 	 * <p><code>e.revision <= :revision and (e.endRevision > :revision or e.endRevision is null)</code></p>
 	 * </li>
 	 * </ul>
 	 *
 	 * @param globalCfg the {@link GlobalConfiguration}
 	 * @param rootQueryBuilder the {@link QueryBuilder} that will be updated
 	 * @param parameters root parameters to which restrictions shall be added
 	 * @param revisionProperty property of the revision column
 	 * @param revisionEndProperty property of the revisionEnd column (only used for {@link ValidityAuditStrategy})
 	 * @param addAlias {@code boolean} indicator if a left alias is needed
 	 * @param idData id-information for the two-entity relation (only used for {@link DefaultAuditStrategy})
 	 * @param revisionPropertyPath path of the revision property (only used for {@link ValidityAuditStrategy})
 	 * @param originalIdPropertyName name of the id property (only used for {@link ValidityAuditStrategy})
 	 * @param alias1 an alias used for subquery (only used for {@link ValidityAuditStrategy})
 	 * @param alias2 an alias used for subquery (only used for {@link ValidityAuditStrategy})
 	 * @param inclusive indicates whether revision number shall be treated as inclusive or exclusive
 	 */
 	void addEntityAtRevisionRestriction(
 			GlobalConfiguration globalCfg,
 			QueryBuilder rootQueryBuilder,
 			Parameters parameters,
 			String revisionProperty,
 			String revisionEndProperty,
 			boolean addAlias,
 			MiddleIdData idData,
 			String revisionPropertyPath,
 			String originalIdPropertyName,
 			String alias1,
 			String alias2,
 			boolean inclusive);
 
 	/**
 	 * Update the rootQueryBuilder with an extra WHERE clause to restrict the revision for a middle-entity
 	 * association. This WHERE clause depends on the AuditStrategy, as follows:
 	 * <ul>
 	 * <li>For {@link DefaultAuditStrategy} a subquery is created:
 	 * <p><code>e.revision = (SELECT max(...) ...)</code></p>
 	 * </li>
 	 * <li>for {@link ValidityAuditStrategy} the revision-end column is used:
 	 * <p><code>e.revision <= :revision and (e.endRevision > :revision or e.endRevision is null)</code></p>
 	 * </li>
 	 * </ul>
 	 *
 	 * @param rootQueryBuilder the {@link QueryBuilder} that will be updated
 	 * @param parameters root parameters to which restrictions shall be added
 	 * @param revisionProperty property of the revision column
 	 * @param revisionEndProperty property of the revisionEnd column (only used for {@link ValidityAuditStrategy})
 	 * @param addAlias {@code boolean} indicator if a left alias is needed
 	 * @param referencingIdData id-information for the middle-entity association (only used for {@link DefaultAuditStrategy})
 	 * @param versionsMiddleEntityName name of the middle-entity
 	 * @param eeOriginalIdPropertyPath name of the id property (only used for {@link ValidityAuditStrategy})
 	 * @param revisionPropertyPath path of the revision property (only used for {@link ValidityAuditStrategy})
 	 * @param originalIdPropertyName name of the id property (only used for {@link ValidityAuditStrategy})
 	 * @param alias1 an alias used for subqueries (only used for {@link DefaultAuditStrategy})
 	 * @param inclusive indicates whether revision number shall be treated as inclusive or exclusive
 	 * @param componentDatas information about the middle-entity relation
 	 */
 	void addAssociationAtRevisionRestriction(
-			QueryBuilder rootQueryBuilder, Parameters parameters, String revisionProperty,
-			String revisionEndProperty, boolean addAlias, MiddleIdData referencingIdData,
-			String versionsMiddleEntityName, String eeOriginalIdPropertyPath, String revisionPropertyPath,
-			String originalIdPropertyName, String alias1, boolean inclusive, MiddleComponentData... componentDatas);
+			QueryBuilder rootQueryBuilder,
+			Parameters parameters,
+			String revisionProperty,
+			String revisionEndProperty,
+			boolean addAlias,
+			MiddleIdData referencingIdData,
+			String versionsMiddleEntityName,
+			String eeOriginalIdPropertyPath,
+			String revisionPropertyPath,
+			String originalIdPropertyName,
+			String alias1,
+			boolean inclusive,
+			MiddleComponentData... componentDatas);
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/strategy/DefaultAuditStrategy.java b/hibernate-envers/src/main/java/org/hibernate/envers/strategy/DefaultAuditStrategy.java
index 139fa7e3a3..22c5c24b5a 100755
--- a/hibernate-envers/src/main/java/org/hibernate/envers/strategy/DefaultAuditStrategy.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/strategy/DefaultAuditStrategy.java
@@ -1,123 +1,133 @@
 package org.hibernate.envers.strategy;
 
 import java.io.Serializable;
 
 import org.hibernate.Session;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.configuration.internal.GlobalConfiguration;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
 import org.hibernate.envers.internal.entities.mapper.PersistentCollectionChangeData;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleComponentData;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleIdData;
 import org.hibernate.envers.internal.synchronization.SessionCacheCleaner;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
 
 import static org.hibernate.envers.internal.entities.mapper.relation.query.QueryConstants.MIDDLE_ENTITY_ALIAS_DEF_AUD_STR;
 import static org.hibernate.envers.internal.entities.mapper.relation.query.QueryConstants.REVISION_PARAMETER;
 
 /**
  * Default strategy is to simply persist the audit data.
  *
  * @author Adam Warski
  * @author Stephanie Pau
  */
 public class DefaultAuditStrategy implements AuditStrategy {
 	private final SessionCacheCleaner sessionCacheCleaner;
 
 	public DefaultAuditStrategy() {
 		sessionCacheCleaner = new SessionCacheCleaner();
 	}
 
+	@Override
 	public void perform(
-			Session session, String entityName, AuditConfiguration auditCfg, Serializable id, Object data,
+			Session session,
+			String entityName,
+			EnversService enversService,
+			Serializable id,
+			Object data,
 			Object revision) {
-		session.save( auditCfg.getAuditEntCfg().getAuditEntityName( entityName ), data );
+		session.save( enversService.getAuditEntitiesConfiguration().getAuditEntityName( entityName ), data );
 		sessionCacheCleaner.scheduleAuditDataRemoval( session, data );
 	}
 
+	@Override
 	public void performCollectionChange(
-			Session session, String entityName, String propertyName, AuditConfiguration auditCfg,
-			PersistentCollectionChangeData persistentCollectionChangeData, Object revision) {
+			Session session,
+			String entityName,
+			String propertyName,
+			EnversService enversService,
+			PersistentCollectionChangeData persistentCollectionChangeData,
+			Object revision) {
 		session.save( persistentCollectionChangeData.getEntityName(), persistentCollectionChangeData.getData() );
 		sessionCacheCleaner.scheduleAuditDataRemoval( session, persistentCollectionChangeData.getData() );
 	}
 
 
 	public void addEntityAtRevisionRestriction(
 			GlobalConfiguration globalCfg,
 			QueryBuilder rootQueryBuilder,
 			Parameters parameters,
 			String revisionProperty,
 			String revisionEndProperty,
 			boolean addAlias,
 			MiddleIdData idData,
 			String revisionPropertyPath,
 			String originalIdPropertyName,
 			String alias1,
 			String alias2,
 			boolean inclusive) {
 		// create a subquery builder
 		// SELECT max(e.revision) FROM versionsReferencedEntity e2
 		QueryBuilder maxERevQb = rootQueryBuilder.newSubQueryBuilder( idData.getAuditEntityName(), alias2 );
 		maxERevQb.addProjection( "max", revisionPropertyPath, false );
 		// WHERE
 		Parameters maxERevQbParameters = maxERevQb.getRootParameters();
 		// e2.revision <= :revision
 		maxERevQbParameters.addWhereWithNamedParam( revisionPropertyPath, inclusive ? "<=" : "<", REVISION_PARAMETER );
 		// e2.id_ref_ed = e.id_ref_ed
 		idData.getOriginalMapper().addIdsEqualToQuery(
 				maxERevQbParameters,
 				alias1 + "." + originalIdPropertyName, alias2 + "." + originalIdPropertyName
 		);
 
 		// add subquery to rootParameters
 		String subqueryOperator = globalCfg.getCorrelatedSubqueryOperator();
 		parameters.addWhere( revisionProperty, addAlias, subqueryOperator, maxERevQb );
 	}
 
 	public void addAssociationAtRevisionRestriction(
 			QueryBuilder rootQueryBuilder,
 			Parameters parameters,
 			String revisionProperty,
 			String revisionEndProperty,
 			boolean addAlias,
 			MiddleIdData referencingIdData,
 			String versionsMiddleEntityName,
 			String eeOriginalIdPropertyPath,
 			String revisionPropertyPath,
 			String originalIdPropertyName,
 			String alias1,
 			boolean inclusive,
 			MiddleComponentData... componentDatas) {
 		// SELECT max(ee2.revision) FROM middleEntity ee2
 		QueryBuilder maxEeRevQb = rootQueryBuilder.newSubQueryBuilder(
 				versionsMiddleEntityName,
 				MIDDLE_ENTITY_ALIAS_DEF_AUD_STR
 		);
 		maxEeRevQb.addProjection( "max", revisionPropertyPath, false );
 		// WHERE
 		Parameters maxEeRevQbParameters = maxEeRevQb.getRootParameters();
 		// ee2.revision <= :revision
 		maxEeRevQbParameters.addWhereWithNamedParam( revisionPropertyPath, inclusive ? "<=" : "<", REVISION_PARAMETER );
 		// ee2.originalId.* = ee.originalId.*
 		String ee2OriginalIdPropertyPath = MIDDLE_ENTITY_ALIAS_DEF_AUD_STR + "." + originalIdPropertyName;
 		referencingIdData.getPrefixedMapper().addIdsEqualToQuery(
 				maxEeRevQbParameters,
 				eeOriginalIdPropertyPath,
 				ee2OriginalIdPropertyPath
 		);
 		for ( MiddleComponentData componentData : componentDatas ) {
 			componentData.getComponentMapper().addMiddleEqualToQuery(
 					maxEeRevQbParameters,
 					eeOriginalIdPropertyPath,
 					alias1,
 					ee2OriginalIdPropertyPath,
 					MIDDLE_ENTITY_ALIAS_DEF_AUD_STR
 			);
 		}
 
 		// add subquery to rootParameters
 		parameters.addWhere( revisionProperty, addAlias, "=", maxEeRevQb );
 	}
 
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/strategy/ValidityAuditStrategy.java b/hibernate-envers/src/main/java/org/hibernate/envers/strategy/ValidityAuditStrategy.java
index 2558340004..ede6f3dd0c 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/strategy/ValidityAuditStrategy.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/strategy/ValidityAuditStrategy.java
@@ -1,371 +1,368 @@
 package org.hibernate.envers.strategy;
 
 import java.io.Serializable;
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.util.Date;
-import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
-import java.util.Set;
-
-import org.jboss.logging.Logger;
 
 import org.hibernate.LockOptions;
 import org.hibernate.Session;
-import org.hibernate.action.spi.AfterTransactionCompletionProcess;
 import org.hibernate.action.spi.BeforeTransactionCompletionProcess;
-import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.envers.RevisionType;
+import org.hibernate.envers.boot.internal.EnversService;
 import org.hibernate.envers.configuration.internal.AuditEntitiesConfiguration;
 import org.hibernate.envers.configuration.internal.GlobalConfiguration;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
 import org.hibernate.envers.internal.entities.mapper.PersistentCollectionChangeData;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleComponentData;
 import org.hibernate.envers.internal.entities.mapper.relation.MiddleIdData;
 import org.hibernate.envers.internal.synchronization.SessionCacheCleaner;
 import org.hibernate.envers.internal.tools.query.Parameters;
 import org.hibernate.envers.internal.tools.query.QueryBuilder;
-import org.hibernate.event.service.spi.EventListenerRegistry;
-import org.hibernate.event.spi.AutoFlushEvent;
-import org.hibernate.event.spi.AutoFlushEventListener;
 import org.hibernate.event.spi.EventSource;
-import org.hibernate.event.spi.EventType;
 import org.hibernate.jdbc.ReturningWork;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.persister.entity.UnionSubclassEntityPersister;
 import org.hibernate.property.Getter;
 import org.hibernate.sql.Update;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.ComponentType;
 import org.hibernate.type.Type;
 
 import static org.hibernate.envers.internal.entities.mapper.relation.query.QueryConstants.MIDDLE_ENTITY_ALIAS;
 import static org.hibernate.envers.internal.entities.mapper.relation.query.QueryConstants.REVISION_PARAMETER;
 
 /**
  * Audit strategy which persists and retrieves audit information using a validity algorithm, based on the
  * start-revision and end-revision of a row in the audit tables.
  * <p>This algorithm works as follows:
  * <ul>
  * <li>For a <strong>new row</strong> that is persisted in an audit table, only the <strong>start-revision</strong> column of that row is set</li>
  * <li>At the same time the <strong>end-revision</strong> field of the <strong>previous</strong> audit row is set to this revision</li>
  * <li>Queries are retrieved using 'between start and end revision', instead of a subquery.</li>
  * </ul>
  * </p>
  * <p/>
  * <p>
  * This has a few important consequences that need to be judged against against each other:
  * <ul>
  * <li>Persisting audit information is a bit slower, because an extra row is updated</li>
  * <li>Retrieving audit information is a lot faster</li>
  * </ul>
  * </p>
  *
  * @author Stephanie Pau
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class ValidityAuditStrategy implements AuditStrategy {
-	private static final Logger log = Logger.getLogger( ValidityAuditStrategy.class );
-
 	/**
 	 * getter for the revision entity field annotated with @RevisionTimestamp
 	 */
 	private Getter revisionTimestampGetter = null;
 
 	private final SessionCacheCleaner sessionCacheCleaner;
 
 	public ValidityAuditStrategy() {
 		sessionCacheCleaner = new SessionCacheCleaner();
 	}
 
+	@Override
 	public void perform(
 			final Session session,
 			final String entityName,
-			final AuditConfiguration auditCfg,
+			final EnversService enversService,
 			final Serializable id,
 			final Object data,
 			final Object revision) {
-		final AuditEntitiesConfiguration audEntitiesCfg = auditCfg.getAuditEntCfg();
+		final AuditEntitiesConfiguration audEntitiesCfg = enversService.getAuditEntitiesConfiguration();
 		final String auditedEntityName = audEntitiesCfg.getAuditEntityName( entityName );
-		final String revisionInfoEntityName = auditCfg.getAuditEntCfg().getRevisionInfoEntityName();
+		final String revisionInfoEntityName = enversService.getAuditEntitiesConfiguration().getRevisionInfoEntityName();
 
 		// Save the audit data
 		session.save( auditedEntityName, data );
 
 		// Update the end date of the previous row.
 		//
 		// When application reuses identifiers of previously removed entities:
 		// The UPDATE statement will no-op if an entity with a given identifier has been
 		// inserted for the first time. But in case a deleted primary key value was
 		// reused, this guarantees correct strategy behavior: exactly one row with
 		// null end date exists for each identifier.
-		final boolean reuseEntityIdentifier = auditCfg.getGlobalCfg().isAllowIdentifierReuse();
-		if ( reuseEntityIdentifier || getRevisionType( auditCfg, data ) != RevisionType.ADD ) {
+		final boolean reuseEntityIdentifier = enversService.getGlobalConfiguration().isAllowIdentifierReuse();
+		if ( reuseEntityIdentifier || getRevisionType( enversService, data ) != RevisionType.ADD ) {
 			// Register transaction completion process to guarantee execution of UPDATE statement after INSERT.
 			( (EventSource) session ).getActionQueue().registerProcess( new BeforeTransactionCompletionProcess() {
 				@Override
 				public void doBeforeTransactionCompletion(final SessionImplementor sessionImplementor) {
 					final Queryable productionEntityQueryable = getQueryable( entityName, sessionImplementor );
 					final Queryable rootProductionEntityQueryable = getQueryable(
 							productionEntityQueryable.getRootEntityName(), sessionImplementor
 					);
 					final Queryable auditedEntityQueryable = getQueryable( auditedEntityName, sessionImplementor );
 					final Queryable rootAuditedEntityQueryable = getQueryable(
 							auditedEntityQueryable.getRootEntityName(), sessionImplementor
 					);
 
 					final String updateTableName;
 					if ( UnionSubclassEntityPersister.class.isInstance( rootProductionEntityQueryable ) ) {
 						// this is the condition causing all the problems in terms of the generated SQL UPDATE
 						// the problem being that we currently try to update the in-line view made up of the union query
 						//
 						// this is extremely hacky means to get the root table name for the union subclass style entities.
 						// hacky because it relies on internal behavior of UnionSubclassEntityPersister
 						// !!!!!! NOTICE - using subclass persister, not root !!!!!!
 						updateTableName = auditedEntityQueryable.getSubclassTableName( 0 );
 					}
 					else {
 						updateTableName = rootAuditedEntityQueryable.getTableName();
 					}
 
 					final Type revisionInfoIdType = sessionImplementor.getFactory().getEntityPersister( revisionInfoEntityName ).getIdentifierType();
-					final String revEndColumnName = rootAuditedEntityQueryable.toColumns( auditCfg.getAuditEntCfg().getRevisionEndFieldName() )[0];
+					final String revEndColumnName = rootAuditedEntityQueryable.toColumns( enversService.getAuditEntitiesConfiguration().getRevisionEndFieldName() )[0];
 
-					final boolean isRevisionEndTimestampEnabled = auditCfg.getAuditEntCfg().isRevisionEndTimestampEnabled();
+					final boolean isRevisionEndTimestampEnabled = enversService.getAuditEntitiesConfiguration().isRevisionEndTimestampEnabled();
 
 					// update audit_ent set REVEND = ? [, REVEND_TSTMP = ?] where (prod_ent_id) = ? and REV <> ? and REVEND is null
 					final Update update = new Update( sessionImplementor.getFactory().getDialect() ).setTableName( updateTableName );
 					// set REVEND = ?
 					update.addColumn( revEndColumnName );
 					// set [, REVEND_TSTMP = ?]
 					if ( isRevisionEndTimestampEnabled ) {
 						update.addColumn(
-								rootAuditedEntityQueryable.toColumns( auditCfg.getAuditEntCfg().getRevisionEndTimestampFieldName() )[0]
+								rootAuditedEntityQueryable.toColumns( enversService.getAuditEntitiesConfiguration().getRevisionEndTimestampFieldName() )[0]
 						);
 					}
 
 					// where (prod_ent_id) = ?
 					update.addPrimaryKeyColumns( rootProductionEntityQueryable.getIdentifierColumnNames() );
 					// where REV <> ?
 					update.addWhereColumn(
-							rootAuditedEntityQueryable.toColumns( auditCfg.getAuditEntCfg().getRevisionNumberPath() )[0], "<> ?"
+							rootAuditedEntityQueryable.toColumns( enversService.getAuditEntitiesConfiguration().getRevisionNumberPath() )[0], "<> ?"
 					);
 					// where REVEND is null
 					update.addWhereColumn( revEndColumnName, " is null" );
 
 					// Now lets execute the sql...
 					final String updateSql = update.toStatementString();
 
 					int rowCount = ( (Session) sessionImplementor ).doReturningWork(
 							new ReturningWork<Integer>() {
 								@Override
 								public Integer execute(Connection connection) throws SQLException {
 									PreparedStatement preparedStatement = sessionImplementor.getTransactionCoordinator()
 											.getJdbcCoordinator().getStatementPreparer().prepareStatement( updateSql );
 
 									try {
 										int index = 1;
 
 										// set REVEND = ?
-										final Number revisionNumber = auditCfg.getRevisionInfoNumberReader().getRevisionNumber(
+										final Number revisionNumber = enversService.getRevisionInfoNumberReader().getRevisionNumber(
 												revision
 										);
 										revisionInfoIdType.nullSafeSet(
 												preparedStatement, revisionNumber, index, sessionImplementor
 										);
 										index += revisionInfoIdType.getColumnSpan( sessionImplementor.getFactory() );
 
 										// set [, REVEND_TSTMP = ?]
 										if ( isRevisionEndTimestampEnabled ) {
 											final Object revEndTimestampObj = revisionTimestampGetter.get( revision );
 											final Date revisionEndTimestamp = convertRevEndTimestampToDate( revEndTimestampObj );
 											final Type revEndTsType = rootAuditedEntityQueryable.getPropertyType(
-													auditCfg.getAuditEntCfg().getRevisionEndTimestampFieldName()
+													enversService.getAuditEntitiesConfiguration().getRevisionEndTimestampFieldName()
 											);
 											revEndTsType.nullSafeSet(
 													preparedStatement, revisionEndTimestamp, index, sessionImplementor
 											);
 											index += revEndTsType.getColumnSpan( sessionImplementor.getFactory() );
 										}
 
 										// where (prod_ent_id) = ?
 										final Type idType = rootProductionEntityQueryable.getIdentifierType();
 										idType.nullSafeSet( preparedStatement, id, index, sessionImplementor );
 										index += idType.getColumnSpan( sessionImplementor.getFactory() );
 
 										// where REV <> ?
 										final Type revType = rootAuditedEntityQueryable.getPropertyType(
-												auditCfg.getAuditEntCfg().getRevisionNumberPath()
+												enversService.getAuditEntitiesConfiguration().getRevisionNumberPath()
 										);
 										revType.nullSafeSet( preparedStatement, revisionNumber, index, sessionImplementor );
 
 										// where REVEND is null
 										// 		nothing to bind....
 
 										return sessionImplementor.getTransactionCoordinator()
 												.getJdbcCoordinator().getResultSetReturn().executeUpdate( preparedStatement );
 									}
 									finally {
 										sessionImplementor.getTransactionCoordinator().getJdbcCoordinator().release(
 												preparedStatement
 										);
 									}
 								}
 							}
 					);
 
-					if ( rowCount != 1 && ( !reuseEntityIdentifier || ( getRevisionType( auditCfg, data ) != RevisionType.ADD ) ) ) {
+					if ( rowCount != 1 && ( !reuseEntityIdentifier || ( getRevisionType( enversService, data ) != RevisionType.ADD ) ) ) {
 						throw new RuntimeException(
 								"Cannot update previous revision for entity " + auditedEntityName + " and id " + id
 						);
 					}
 				}
 			});
 		}
 		sessionCacheCleaner.scheduleAuditDataRemoval( session, data );
 	}
 
 	private Queryable getQueryable(String entityName, SessionImplementor sessionImplementor) {
 		return (Queryable) sessionImplementor.getFactory().getEntityPersister( entityName );
 	}
 
+	@Override
 	@SuppressWarnings({"unchecked"})
 	public void performCollectionChange(
-			Session session, String entityName, String propertyName, AuditConfiguration auditCfg,
+			Session session,
+			String entityName,
+			String propertyName,
+			EnversService enversService,
 			PersistentCollectionChangeData persistentCollectionChangeData, Object revision) {
 		final QueryBuilder qb = new QueryBuilder( persistentCollectionChangeData.getEntityName(), MIDDLE_ENTITY_ALIAS );
 
-		final String originalIdPropName = auditCfg.getAuditEntCfg().getOriginalIdPropName();
+		final String originalIdPropName = enversService.getAuditEntitiesConfiguration().getOriginalIdPropName();
 		final Map<String, Object> originalId = (Map<String, Object>) persistentCollectionChangeData.getData().get(
 				originalIdPropName
 		);
-		final String revisionFieldName = auditCfg.getAuditEntCfg().getRevisionFieldName();
-		final String revisionTypePropName = auditCfg.getAuditEntCfg().getRevisionTypePropName();
+		final String revisionFieldName = enversService.getAuditEntitiesConfiguration().getRevisionFieldName();
+		final String revisionTypePropName = enversService.getAuditEntitiesConfiguration().getRevisionTypePropName();
 
 		// Adding a parameter for each id component, except the rev number and type.
 		for ( Map.Entry<String, Object> originalIdEntry : originalId.entrySet() ) {
 			if ( !revisionFieldName.equals( originalIdEntry.getKey() ) && !revisionTypePropName.equals( originalIdEntry.getKey() ) ) {
 				qb.getRootParameters().addWhereWithParam(
 						originalIdPropName + "." + originalIdEntry.getKey(),
 						true, "=", originalIdEntry.getValue()
 				);
 			}
 		}
 
 		final SessionFactoryImplementor sessionFactory = ((SessionImplementor) session).getFactory();
 		final Type propertyType = sessionFactory.getEntityPersister( entityName ).getPropertyType( propertyName );
 		if ( propertyType.isCollectionType() ) {
 			CollectionType collectionPropertyType = (CollectionType) propertyType;
 			// Handling collection of components.
 			if ( collectionPropertyType.getElementType( sessionFactory ) instanceof ComponentType ) {
 				// Adding restrictions to compare data outside of primary key.
 				for ( Map.Entry<String, Object> dataEntry : persistentCollectionChangeData.getData().entrySet() ) {
 					if ( !originalIdPropName.equals( dataEntry.getKey() ) ) {
 						qb.getRootParameters().addWhereWithParam( dataEntry.getKey(), true, "=", dataEntry.getValue() );
 					}
 				}
 			}
 		}
 
-		addEndRevisionNullRestriction( auditCfg, qb.getRootParameters() );
+		addEndRevisionNullRestriction( enversService, qb.getRootParameters() );
 
 		final List<Object> l = qb.toQuery( session ).setLockOptions( LockOptions.UPGRADE ).list();
 
 		// Update the last revision if one exists.
 		// HHH-5967: with collections, the same element can be added and removed multiple times. So even if it's an
 		// ADD, we may need to update the last revision.
 		if ( l.size() > 0 ) {
 			updateLastRevision(
-					session, auditCfg, l, originalId, persistentCollectionChangeData.getEntityName(), revision
+					session, enversService, l, originalId, persistentCollectionChangeData.getEntityName(), revision
 			);
 		}
 
 		// Save the audit data
 		session.save( persistentCollectionChangeData.getEntityName(), persistentCollectionChangeData.getData() );
 		sessionCacheCleaner.scheduleAuditDataRemoval( session, persistentCollectionChangeData.getData() );
 	}
 
-	private void addEndRevisionNullRestriction(AuditConfiguration auditCfg, Parameters rootParameters) {
-		rootParameters.addWhere( auditCfg.getAuditEntCfg().getRevisionEndFieldName(), true, "is", "null", false );
+	private void addEndRevisionNullRestriction(EnversService enversService, Parameters rootParameters) {
+		rootParameters.addWhere( enversService.getAuditEntitiesConfiguration().getRevisionEndFieldName(), true, "is", "null", false );
 	}
 
 	public void addEntityAtRevisionRestriction(
 			GlobalConfiguration globalCfg, QueryBuilder rootQueryBuilder,
 			Parameters parameters, String revisionProperty, String revisionEndProperty, boolean addAlias,
 			MiddleIdData idData, String revisionPropertyPath, String originalIdPropertyName,
 			String alias1, String alias2, boolean inclusive) {
 		addRevisionRestriction( parameters, revisionProperty, revisionEndProperty, addAlias, inclusive );
 	}
 
 	public void addAssociationAtRevisionRestriction(
 			QueryBuilder rootQueryBuilder, Parameters parameters, String revisionProperty,
 			String revisionEndProperty, boolean addAlias, MiddleIdData referencingIdData,
 			String versionsMiddleEntityName, String eeOriginalIdPropertyPath, String revisionPropertyPath,
 			String originalIdPropertyName, String alias1, boolean inclusive, MiddleComponentData... componentDatas) {
 		addRevisionRestriction( parameters, revisionProperty, revisionEndProperty, addAlias, inclusive );
 	}
 
 	public void setRevisionTimestampGetter(Getter revisionTimestampGetter) {
 		this.revisionTimestampGetter = revisionTimestampGetter;
 	}
 
 	private void addRevisionRestriction(
 			Parameters rootParameters, String revisionProperty, String revisionEndProperty,
 			boolean addAlias, boolean inclusive) {
 		// e.revision <= _revision and (e.endRevision > _revision or e.endRevision is null)
 		Parameters subParm = rootParameters.addSubParameters( "or" );
 		rootParameters.addWhereWithNamedParam( revisionProperty, addAlias, inclusive ? "<=" : "<", REVISION_PARAMETER );
 		subParm.addWhereWithNamedParam(
 				revisionEndProperty + ".id", addAlias, inclusive ? ">" : ">=", REVISION_PARAMETER
 		);
 		subParm.addWhere( revisionEndProperty, addAlias, "is", "null", false );
 	}
 
 	@SuppressWarnings({"unchecked"})
-	private RevisionType getRevisionType(AuditConfiguration auditCfg, Object data) {
-		return (RevisionType) ((Map<String, Object>) data).get( auditCfg.getAuditEntCfg().getRevisionTypePropName() );
+	private RevisionType getRevisionType(EnversService enversService, Object data) {
+		return (RevisionType) ((Map<String, Object>) data).get( enversService.getAuditEntitiesConfiguration().getRevisionTypePropName() );
 	}
 
 	@SuppressWarnings({"unchecked"})
 	private void updateLastRevision(
-			Session session, AuditConfiguration auditCfg, List<Object> l,
-			Object id, String auditedEntityName, Object revision) {
+			Session session,
+			EnversService enversService,
+			List<Object> l,
+			Object id,
+			String auditedEntityName,
+			Object revision) {
 		// There should be one entry
 		if ( l.size() == 1 ) {
 			// Setting the end revision to be the current rev
 			Object previousData = l.get( 0 );
-			String revisionEndFieldName = auditCfg.getAuditEntCfg().getRevisionEndFieldName();
+			String revisionEndFieldName = enversService.getAuditEntitiesConfiguration().getRevisionEndFieldName();
 			((Map<String, Object>) previousData).put( revisionEndFieldName, revision );
 
-			if ( auditCfg.getAuditEntCfg().isRevisionEndTimestampEnabled() ) {
+			if ( enversService.getAuditEntitiesConfiguration().isRevisionEndTimestampEnabled() ) {
 				// Determine the value of the revision property annotated with @RevisionTimestamp
-				String revEndTimestampFieldName = auditCfg.getAuditEntCfg().getRevisionEndTimestampFieldName();
+				String revEndTimestampFieldName = enversService.getAuditEntitiesConfiguration().getRevisionEndTimestampFieldName();
 				Object revEndTimestampObj = this.revisionTimestampGetter.get( revision );
 				Date revisionEndTimestamp = convertRevEndTimestampToDate( revEndTimestampObj );
 
 				// Setting the end revision timestamp
 				((Map<String, Object>) previousData).put( revEndTimestampFieldName, revisionEndTimestamp );
 			}
 
 			// Saving the previous version
 			session.save( auditedEntityName, previousData );
 			sessionCacheCleaner.scheduleAuditDataRemoval( session, previousData );
 		}
 		else {
 			throw new RuntimeException( "Cannot find previous revision for entity " + auditedEntityName + " and id " + id );
 		}
 	}
 
 	private Date convertRevEndTimestampToDate(Object revEndTimestampObj) {
 		// convert to a java.util.Date
 		if ( revEndTimestampObj instanceof Date ) {
 			return (Date) revEndTimestampObj;
 		}
 		return new Date( (Long) revEndTimestampObj );
 	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/tools/hbm2ddl/EnversSchemaGenerator.java b/hibernate-envers/src/main/java/org/hibernate/envers/tools/hbm2ddl/EnversSchemaGenerator.java
deleted file mode 100644
index 4d68a1b554..0000000000
--- a/hibernate-envers/src/main/java/org/hibernate/envers/tools/hbm2ddl/EnversSchemaGenerator.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.envers.tools.hbm2ddl;
-
-import java.sql.Connection;
-import java.util.Properties;
-
-import org.hibernate.HibernateException;
-import org.hibernate.boot.spi.MetadataImplementor;
-import org.hibernate.cfg.Configuration;
-import org.hibernate.envers.configuration.spi.AuditConfiguration;
-import org.hibernate.service.ServiceRegistry;
-import org.hibernate.tool.hbm2ddl.SchemaExport;
-
-/**
- * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
- */
-public class EnversSchemaGenerator {
-	private final SchemaExport export;
-
-	public EnversSchemaGenerator(MetadataImplementor metadata) {
-		this( metadata.getMetadataBuildingOptions().getServiceRegistry(), metadata );
-	}
-
-	public EnversSchemaGenerator(ServiceRegistry serviceRegistry, MetadataImplementor metadata) {
-		this.export = new SchemaExport( serviceRegistry, metadata );
-	}
-
-	public EnversSchemaGenerator(Configuration configuration) {
-		configuration = configureAuditing( configuration );
-		export = new SchemaExport( configuration );
-	}
-
-	public EnversSchemaGenerator(Configuration configuration, Properties properties) throws HibernateException {
-		configuration = configureAuditing( configuration );
-		export = new SchemaExport( configuration, properties );
-	}
-
-	public EnversSchemaGenerator(Configuration configuration, Connection connection) throws HibernateException {
-		configuration = configureAuditing( configuration );
-		export = new SchemaExport( configuration, connection );
-	}
-
-	public SchemaExport export() {
-		return export;
-	}
-
-	private Configuration configureAuditing(Configuration configuration) {
-		configuration.buildMappings();
-		AuditConfiguration.getFor( configuration );
-		return configuration;
-	}
-}
diff --git a/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.boot.model.TypeContributor b/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.boot.model.TypeContributor
index 5eeaedd30c..4a66fe2ae9 100644
--- a/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.boot.model.TypeContributor
+++ b/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.boot.model.TypeContributor
@@ -1 +1 @@
-org.hibernate.envers.internal.entities.TypeContributorImpl
\ No newline at end of file
+org.hibernate.envers.boot.internal.TypeContributorImpl
\ No newline at end of file
diff --git a/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.boot.spi.AdditionalJaxbMappingProducer b/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.boot.spi.AdditionalJaxbMappingProducer
new file mode 100644
index 0000000000..f510dc2f55
--- /dev/null
+++ b/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.boot.spi.AdditionalJaxbMappingProducer
@@ -0,0 +1 @@
+org.hibernate.envers.boot.internal.AdditionalJaxbMappingProducerImpl
\ No newline at end of file
diff --git a/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.integrator.spi.Integrator b/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.integrator.spi.Integrator
index 4155dd7232..4448597db5 100644
--- a/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.integrator.spi.Integrator
+++ b/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.integrator.spi.Integrator
@@ -1 +1 @@
-org.hibernate.envers.event.spi.EnversIntegrator
\ No newline at end of file
+org.hibernate.envers.boot.internal.EnversIntegrator
\ No newline at end of file
diff --git a/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.service.spi.ServiceContributor b/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.service.spi.ServiceContributor
new file mode 100644
index 0000000000..e7bf4c4097
--- /dev/null
+++ b/hibernate-envers/src/main/resources/META-INF/services/org.hibernate.service.spi.ServiceContributor
@@ -0,0 +1 @@
+org.hibernate.envers.boot.internal.EnversServiceContributor
\ No newline at end of file
diff --git a/hibernate-envers/src/main/resources/OSGI-INF/blueprint/blueprint.xml b/hibernate-envers/src/main/resources/OSGI-INF/blueprint/blueprint.xml
index 93892568ed..fdc7cbe106 100644
--- a/hibernate-envers/src/main/resources/OSGI-INF/blueprint/blueprint.xml
+++ b/hibernate-envers/src/main/resources/OSGI-INF/blueprint/blueprint.xml
@@ -1,13 +1,13 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
 <blueprint  default-activation="eager" 
             xmlns="http://www.osgi.org/xmlns/blueprint/v1.0.0"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
 
-  <bean id="integrator" class="org.hibernate.envers.event.spi.EnversIntegrator"/>
+  <bean id="integrator" class="org.hibernate.envers.boot.internal.EnversIntegrator"/>
   <service ref="integrator" interface="org.hibernate.integrator.spi.Integrator"/>
 
-  <bean id="typeContributor" class="org.hibernate.envers.internal.entities.TypeContributorImpl"/>
+  <bean id="typeContributor" class="org.hibernate.envers.boot.internal.TypeContributorImpl"/>
   <service ref="typeContributor" interface="org.hibernate.boot.model.TypeContributor"/>
   
 </blueprint>
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/BaseEnversFunctionalTestCase.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/BaseEnversFunctionalTestCase.java
index 4a703064a5..0d2d675bca 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/BaseEnversFunctionalTestCase.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/BaseEnversFunctionalTestCase.java
@@ -1,61 +1,63 @@
 package org.hibernate.envers.test;
 
 import java.util.Arrays;
 import java.util.List;
+import java.util.Map;
 
 import org.hibernate.Session;
-import org.hibernate.cfg.Configuration;
 import org.hibernate.envers.AuditReader;
 import org.hibernate.envers.AuditReaderFactory;
 import org.hibernate.envers.configuration.EnversSettings;
 
-import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
+import org.hibernate.testing.junit4.BaseNonConfigCoreFunctionalTestCase;
 import org.junit.runner.RunWith;
 import org.junit.runners.Parameterized;
 
 /**
  * @author Strong Liu (stliu@hibernate.org)
  */
 @RunWith(EnversRunner.class)
-public abstract class BaseEnversFunctionalTestCase extends BaseCoreFunctionalTestCase {
+public abstract class BaseEnversFunctionalTestCase extends BaseNonConfigCoreFunctionalTestCase {
 	private String auditStrategy;
 
 	@Parameterized.Parameters
 	public static List<Object[]> data() {
 		return Arrays.asList(
 				new Object[] {null},
 				new Object[] {"org.hibernate.envers.strategy.ValidityAuditStrategy"}
 		);
 	}
 
 	public void setTestData(Object[] data) {
 		auditStrategy = (String) data[0];
 	}
 
 	public String getAuditStrategy() {
 		return auditStrategy;
 	}
 
+	@Override
 	protected Session getSession() {
+		Session session = super.getSession();
 		if ( session == null || !session.isOpen() ) {
 			return openSession();
 		}
 		return session;
 	}
 
 	protected AuditReader getAuditReader() {
 		return AuditReaderFactory.get( getSession() );
 	}
 
 	@Override
-	protected Configuration constructConfiguration() {
-		Configuration configuration = super.constructConfiguration();
-		configuration.setProperty( EnversSettings.USE_REVISION_ENTITY_WITH_NATIVE_ID, "false" );
-		return configuration;
+	protected void addSettings(Map settings) {
+		super.addSettings( settings );
+
+		settings.put( EnversSettings.USE_REVISION_ENTITY_WITH_NATIVE_ID, "false" );
 	}
 
 	@Override
 	protected String getBaseForMappings() {
 		return "";
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/BaseEnversJPAFunctionalTestCase.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/BaseEnversJPAFunctionalTestCase.java
index 6cb7c20e3d..bdbf153748 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/BaseEnversJPAFunctionalTestCase.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/BaseEnversJPAFunctionalTestCase.java
@@ -1,309 +1,309 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
 import javax.persistence.EntityManager;
 import javax.persistence.EntityManagerFactory;
 import javax.transaction.SystemException;
 
 import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
-import org.hibernate.cfg.Configuration;
+import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
 import org.hibernate.envers.AuditReader;
 import org.hibernate.envers.AuditReaderFactory;
+import org.hibernate.envers.boot.internal.EnversIntegrator;
 import org.hibernate.envers.configuration.EnversSettings;
-import org.hibernate.envers.event.spi.EnversIntegrator;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.jpa.AvailableSettings;
 import org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl;
 import org.hibernate.jpa.boot.spi.Bootstrap;
 import org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor;
 import org.hibernate.jpa.internal.EntityManagerFactoryImpl;
 import org.hibernate.jpa.test.PersistenceUnitDescriptorAdapter;
 
 import org.hibernate.testing.AfterClassOnce;
 import org.hibernate.testing.BeforeClassOnce;
 import org.hibernate.testing.jta.TestingJtaPlatformImpl;
 import org.hibernate.testing.junit4.Helper;
 import org.junit.After;
 
 import org.jboss.logging.Logger;
 
 /**
  * @author Strong Liu (stliu@hibernate.org)
  */
 public abstract class BaseEnversJPAFunctionalTestCase extends AbstractEnversTest {
 	private static final Logger log = Logger.getLogger( BaseEnversJPAFunctionalTestCase.class );
 
 	private static final Dialect dialect = Dialect.getDialect();
 
 	private EntityManagerFactoryBuilderImpl entityManagerFactoryBuilder;
 	private StandardServiceRegistryImpl serviceRegistry;
 	private EntityManagerFactoryImpl entityManagerFactory;
 
 	private EntityManager em;
 	private AuditReader auditReader;
 	private ArrayList<EntityManager> isolatedEms = new ArrayList<EntityManager>();
 
 	protected Dialect getDialect() {
 		return dialect;
 	}
 
 	protected EntityManagerFactory entityManagerFactory() {
 		return entityManagerFactory;
 	}
 
 	protected StandardServiceRegistryImpl serviceRegistry() {
 		return serviceRegistry;
 	}
 
-	protected Configuration getCfg() {
-		return entityManagerFactoryBuilder.getHibernateConfiguration();
+	protected MetadataImplementor metadata() {
+		return entityManagerFactoryBuilder.getMetadata();
 	}
 
 	@BeforeClassOnce
 	@SuppressWarnings({"UnusedDeclaration"})
 	public void buildEntityManagerFactory() throws Exception {
 		log.trace( "Building EntityManagerFactory" );
 
 		entityManagerFactoryBuilder = (EntityManagerFactoryBuilderImpl) Bootstrap.getEntityManagerFactoryBuilder(
 				buildPersistenceUnitDescriptor(),
 				buildSettings()
 		);
 		entityManagerFactory = (EntityManagerFactoryImpl) entityManagerFactoryBuilder.build();
 
 		serviceRegistry = (StandardServiceRegistryImpl) entityManagerFactory.getSessionFactory()
 				.getServiceRegistry()
 				.getParentServiceRegistry();
 
 		afterEntityManagerFactoryBuilt();
 	}
 
 	private PersistenceUnitDescriptor buildPersistenceUnitDescriptor() {
 		return new PersistenceUnitDescriptorAdapter();
 	}
 
 	private Map buildSettings() {
 		Map settings = getConfig();
 		addMappings( settings );
 
 		if ( createSchema() ) {
 			settings.put( org.hibernate.cfg.AvailableSettings.HBM2DDL_AUTO, "create-drop" );
 			final String secondSchemaName = createSecondSchema();
 			if ( StringHelper.isNotEmpty( secondSchemaName ) ) {
 				if ( !(getDialect() instanceof H2Dialect) ) {
 					throw new UnsupportedOperationException( "Only H2 dialect supports creation of second schema." );
 				}
 				Helper.createH2Schema( secondSchemaName, settings );
 			}
 		}
 
 		if ( StringHelper.isNotEmpty( getAuditStrategy() ) ) {
 			settings.put( EnversSettings.AUDIT_STRATEGY, getAuditStrategy() );
 		}
 
 		if ( !autoRegisterListeners() ) {
 			settings.put( EnversIntegrator.AUTO_REGISTER, "false" );
 		}
 
 		settings.put( EnversSettings.USE_REVISION_ENTITY_WITH_NATIVE_ID, "false" );
 
 		settings.put( org.hibernate.cfg.AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS, "true" );
 		settings.put( org.hibernate.cfg.AvailableSettings.DIALECT, getDialect().getClass().getName() );
 		return settings;
 	}
 
 	protected Map getConfig() {
 		Map<Object, Object> config = new HashMap<Object, Object>();
 
 		config.put( AvailableSettings.LOADED_CLASSES, Arrays.asList( getAnnotatedClasses() ) );
 
 		for ( Map.Entry<Class, String> entry : getCachedClasses().entrySet() ) {
 			config.put( AvailableSettings.CLASS_CACHE_PREFIX + "." + entry.getKey().getName(), entry.getValue() );
 		}
 
 		for ( Map.Entry<String, String> entry : getCachedCollections().entrySet() ) {
 			config.put( AvailableSettings.COLLECTION_CACHE_PREFIX + "." + entry.getKey(), entry.getValue() );
 		}
 
 		if ( getEjb3DD().length > 0 ) {
 			ArrayList<String> dds = new ArrayList<String>();
 			dds.addAll( Arrays.asList( getEjb3DD() ) );
 			config.put( AvailableSettings.XML_FILE_NAMES, dds );
 		}
 
 		addConfigOptions( config );
 
 		return config;
 	}
 
 	@SuppressWarnings("unchecked")
 	protected void addMappings(Map settings) {
 		String[] mappings = getMappings();
 		if ( mappings != null ) {
 			settings.put( AvailableSettings.HBXML_FILES, StringHelper.join( ",", mappings ) );
 		}
 	}
 
 	protected static final String[] NO_MAPPINGS = new String[0];
 
 	protected String[] getMappings() {
 		return NO_MAPPINGS;
 	}
 
 	protected void addConfigOptions(Map options) {
 	}
 
 	protected static final Class<?>[] NO_CLASSES = new Class[0];
 
 	protected Class<?>[] getAnnotatedClasses() {
 		return NO_CLASSES;
 	}
 
 	public Map<Class, String> getCachedClasses() {
 		return new HashMap<Class, String>();
 	}
 
 	public Map<String, String> getCachedCollections() {
 		return new HashMap<String, String>();
 	}
 
 	public String[] getEjb3DD() {
 		return new String[] {};
 	}
 
 	protected void afterEntityManagerFactoryBuilt() {
 	}
 
 	protected boolean createSchema() {
 		return true;
 	}
 
 	/**
 	 * Feature supported only by H2 dialect.
 	 *
 	 * @return Provide not empty name to create second schema.
 	 */
 	protected String createSecondSchema() {
 		return null;
 	}
 
 	protected boolean autoRegisterListeners() {
 		return true;
 	}
 
 	@AfterClassOnce
 	public void releaseEntityManagerFactory() {
 		if ( entityManagerFactory != null && entityManagerFactory.isOpen() ) {
 			entityManagerFactory.close();
 		}
 	}
 
 	@After
 	@SuppressWarnings({"UnusedDeclaration"})
 	public void releaseUnclosedEntityManagers() {
 		releaseUnclosedEntityManager( this.em );
 		auditReader = null;
 		for ( EntityManager isolatedEm : isolatedEms ) {
 			releaseUnclosedEntityManager( isolatedEm );
 		}
 	}
 
 	private void releaseUnclosedEntityManager(EntityManager em) {
 		if ( em == null ) {
 			return;
 		}
 		if ( !em.isOpen() ) {
 			em = null;
 			return;
 		}
 		if ( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) ) {
 			log.warn( "Cleaning up unfinished transaction" );
 			try {
 				TestingJtaPlatformImpl.INSTANCE.getTransactionManager().rollback();
 			}
 			catch (SystemException ignored) {
 			}
 		}
 		try {
 			if ( em.getTransaction().isActive() ) {
 				em.getTransaction().rollback();
 				log.warn( "You left an open transaction! Fix your test case. For now, we are closing it for you." );
 			}
 		}
 		catch (IllegalStateException e) {
 		}
 		if ( em.isOpen() ) {
 			// as we open an EM before the test runs, it will still be open if the test uses a custom EM.
 			// or, the person may have forgotten to close. So, do not raise a "fail", but log the fact.
 			em.close();
 			log.warn( "The EntityManager is not closed. Closing it." );
 		}
 	}
 
 	protected EntityManager getEntityManager() {
 		return getOrCreateEntityManager();
 	}
 
 	protected EntityManager getOrCreateEntityManager() {
 		if ( em == null || !em.isOpen() ) {
 			em = entityManagerFactory.createEntityManager();
 		}
 		return em;
 	}
 
 	protected AuditReader getAuditReader() {
 		if ( auditReader != null ) {
 			return auditReader;
 		}
 		return auditReader = AuditReaderFactory.get( getOrCreateEntityManager() );
 	}
 
 	protected EntityManager createIsolatedEntityManager() {
 		EntityManager isolatedEm = entityManagerFactory.createEntityManager();
 		isolatedEms.add( isolatedEm );
 		return isolatedEm;
 	}
 
 	protected EntityManager createIsolatedEntityManager(Map props) {
 		EntityManager isolatedEm = entityManagerFactory.createEntityManager( props );
 		isolatedEms.add( isolatedEm );
 		return isolatedEm;
 	}
 
 	protected EntityManager createEntityManager(Map properties) {
 		// always reopen a new EM and close the existing one
 		if ( em != null && em.isOpen() ) {
 			em.close();
 		}
 		em = entityManagerFactory.createEntityManager( properties );
 		return em;
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/ColumnScalePrecisionTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/ColumnScalePrecisionTest.java
index 6a8168241b..746f0604c5 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/ColumnScalePrecisionTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/ColumnScalePrecisionTest.java
@@ -1,69 +1,69 @@
 package org.hibernate.envers.test.integration.basic;
 
 import java.util.Arrays;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Table;
 
 import org.hibernate.testing.TestForIssue;
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 @TestForIssue(jiraKey = "HHH-7003")
 public class ColumnScalePrecisionTest extends BaseEnversJPAFunctionalTestCase {
 	private Table auditTable = null;
 	private Table originalTable = null;
 	private Long id = null;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {ScalePrecisionEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		EntityManager em = getEntityManager();
 
 		// Revision 1
 		em.getTransaction().begin();
 		ScalePrecisionEntity entity = new ScalePrecisionEntity( 13.0 );
 		em.persist( entity );
 		em.getTransaction().commit();
 
 		id = entity.getId();
-		auditTable = getCfg().getClassMapping( "org.hibernate.envers.test.integration.basic.ScalePrecisionEntity_AUD" )
+		auditTable = metadata().getEntityBinding( "org.hibernate.envers.test.integration.basic.ScalePrecisionEntity_AUD" )
 				.getTable();
-		originalTable = getCfg().getClassMapping( "org.hibernate.envers.test.integration.basic.ScalePrecisionEntity" )
+		originalTable = metadata().getEntityBinding( "org.hibernate.envers.test.integration.basic.ScalePrecisionEntity" )
 				.getTable();
 	}
 
 	@Test
 	public void testColumnScalePrecision() {
 		Column testColumn = new Column( "wholeNumber" );
 		Column scalePrecisionAuditColumn = auditTable.getColumn( testColumn );
 		Column scalePrecisionColumn = originalTable.getColumn( testColumn );
 
 		Assert.assertNotNull( scalePrecisionAuditColumn );
 		Assert.assertEquals( scalePrecisionColumn.getPrecision(), scalePrecisionAuditColumn.getPrecision() );
 		Assert.assertEquals( scalePrecisionColumn.getScale(), scalePrecisionAuditColumn.getScale() );
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1 ).equals( getAuditReader().getRevisions( ScalePrecisionEntity.class, id ) );
 	}
 
 	@Test
 	public void testHistoryOfScalePrecisionEntity() {
 		ScalePrecisionEntity ver1 = new ScalePrecisionEntity( 13.0, id );
 
 		Assert.assertEquals( ver1, getAuditReader().find( ScalePrecisionEntity.class, id, 1 ) );
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/NoneAudited.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/NoneAudited.java
index 2acf054521..0d19b8401a 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/NoneAudited.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/NoneAudited.java
@@ -1,60 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.basic;
 
-import java.util.ArrayList;
-import java.util.Iterator;
 import java.util.List;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.mapping.PersistentClass;
 
 import org.junit.Assert;
 import org.junit.Test;
 
+import static org.hibernate.envers.internal.tools.Tools.collectionToList;
+
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class NoneAudited extends BaseEnversJPAFunctionalTestCase {
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {BasicTestEntity3.class};
 	}
 
 	@Test
 	public void testRevisionInfoTableNotCreated() {
-		@SuppressWarnings({"unchecked"}) List<PersistentClass> pcs = iteratorToList( getCfg().getClassMappings() );
+		@SuppressWarnings({"unchecked"}) List<PersistentClass> pcs = collectionToList( metadata().getEntityBindings() );
 		Assert.assertEquals( 1, pcs.size() );
 		Assert.assertTrue( pcs.get( 0 ).getClassName().contains( "BasicTestEntity3" ) );
 	}
-
-	private <T> List<T> iteratorToList(Iterator<T> it) {
-		List<T> result = new ArrayList<T>();
-		while ( it.hasNext() ) {
-			result.add( it.next() );
-		}
-
-		return result;
-	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/OutsideTransactionTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/OutsideTransactionTest.java
index 5519d305a1..71859c1dc7 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/OutsideTransactionTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/basic/OutsideTransactionTest.java
@@ -1,119 +1,122 @@
 package org.hibernate.envers.test.integration.basic;
 
+import java.util.Map;
+
 import org.hibernate.Session;
-import org.hibernate.cfg.Configuration;
 import org.hibernate.envers.configuration.EnversSettings;
 import org.hibernate.envers.exception.AuditException;
 import org.hibernate.envers.test.BaseEnversFunctionalTestCase;
 import org.hibernate.envers.test.entities.StrTestEntity;
 import org.hibernate.envers.test.integration.collection.norevision.Name;
 import org.hibernate.envers.test.integration.collection.norevision.Person;
 
 import org.hibernate.testing.TestForIssue;
 import org.junit.Test;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 @TestForIssue(jiraKey = "HHH-5565")
 public class OutsideTransactionTest extends BaseEnversFunctionalTestCase {
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {StrTestEntity.class, Person.class, Name.class};
 	}
 
 	@Override
-	protected void configure(Configuration configuration) {
-		configuration.setProperty( EnversSettings.STORE_DATA_AT_DELETE, "true" );
-		configuration.setProperty( EnversSettings.REVISION_ON_COLLECTION_CHANGE, "true" );
+	protected void addSettings(Map settings) {
+		super.addSettings( settings );
+
+		settings.put( EnversSettings.STORE_DATA_AT_DELETE, "true" );
+		settings.put( EnversSettings.REVISION_ON_COLLECTION_CHANGE, "true" );
 	}
 
 	@Test(expected = AuditException.class)
 	public void testInsertOutsideActiveTransaction() {
 		Session session = openSession();
 
 		// Illegal insertion of entity outside of active transaction.
 		StrTestEntity entity = new StrTestEntity( "data" );
 		session.persist( entity );
 		session.flush();
 
 		session.close();
 	}
 
 	@Test(expected = AuditException.class)
 	public void testUpdateOutsideActiveTransaction() {
 		Session session = openSession();
 
 		// Revision 1
 		session.getTransaction().begin();
 		StrTestEntity entity = new StrTestEntity( "data" );
 		session.persist( entity );
 		session.getTransaction().commit();
 
 		// Illegal modification of entity state outside of active transaction.
 		entity.setStr( "modified data" );
 		session.update( entity );
 		session.flush();
 
 		session.close();
 	}
 
 	@Test(expected = AuditException.class)
 	public void testDeleteOutsideActiveTransaction() {
 		Session session = openSession();
 
 		// Revision 1
 		session.getTransaction().begin();
 		StrTestEntity entity = new StrTestEntity( "data" );
 		session.persist( entity );
 		session.getTransaction().commit();
 
 		// Illegal removal of entity outside of active transaction.
 		session.delete( entity );
 		session.flush();
 
 		session.close();
 	}
 
 	@Test(expected = AuditException.class)
 	public void testCollectionUpdateOutsideActiveTransaction() {
 		Session session = openSession();
 
 		// Revision 1
 		session.getTransaction().begin();
 		Person person = new Person();
 		Name name = new Name();
 		name.setName( "Name" );
 		person.getNames().add( name );
 		session.saveOrUpdate( person );
 		session.getTransaction().commit();
 
 		// Illegal collection update outside of active transaction.
 		person.getNames().remove( name );
 		session.saveOrUpdate( person );
 		session.flush();
 
 		session.close();
 	}
 
 	@Test(expected = AuditException.class)
 	public void testCollectionRemovalOutsideActiveTransaction() {
 		Session session = openSession();
 
 		// Revision 1
 		session.getTransaction().begin();
 		Person person = new Person();
 		Name name = new Name();
 		name.setName( "Name" );
 		person.getNames().add( name );
 		session.saveOrUpdate( person );
 		session.getTransaction().commit();
 
 		// Illegal collection removal outside of active transaction.
 		person.setNames( null );
 		session.saveOrUpdate( person );
 		session.flush();
 
 		session.close();
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/collection/norevision/AbstractCollectionChangeTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/collection/norevision/AbstractCollectionChangeTest.java
index 294f109f21..70f15283d4 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/collection/norevision/AbstractCollectionChangeTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/collection/norevision/AbstractCollectionChangeTest.java
@@ -1,64 +1,66 @@
 package org.hibernate.envers.test.integration.collection.norevision;
 
 import java.util.List;
+import java.util.Map;
 
 import org.hibernate.Session;
-import org.hibernate.cfg.Configuration;
 import org.hibernate.envers.configuration.EnversSettings;
 import org.hibernate.envers.test.BaseEnversFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 
 import org.junit.Test;
 
 public abstract class AbstractCollectionChangeTest extends BaseEnversFunctionalTestCase {
 	protected Integer personId;
 
 	@Override
-	protected void configure(Configuration configuration) {
-		configuration.setProperty( EnversSettings.REVISION_ON_COLLECTION_CHANGE, getCollectionChangeValue() );
+	protected void addSettings(Map settings) {
+		super.addSettings( settings );
+
+		settings.put( EnversSettings.REVISION_ON_COLLECTION_CHANGE, getCollectionChangeValue() );
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {Person.class, Name.class};
 	}
 
 	protected abstract String getCollectionChangeValue();
 
 	protected abstract List<Integer> getExpectedPersonRevisions();
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		Session session = openSession();
 
 		// Rev 1
 		session.getTransaction().begin();
 		Person p = new Person();
 		Name n = new Name();
 		n.setName( "name1" );
 		p.getNames().add( n );
 		session.saveOrUpdate( p );
 		session.getTransaction().commit();
 
 		// Rev 2
 		session.getTransaction().begin();
 		n.setName( "Changed name" );
 		session.saveOrUpdate( p );
 		session.getTransaction().commit();
 
 		// Rev 3
 		session.getTransaction().begin();
 		Name n2 = new Name();
 		n2.setName( "name2" );
 		p.getNames().add( n2 );
 		session.getTransaction().commit();
 
 		personId = p.getId();
 	}
 
 	@Test
 	public void testPersonRevisionCount() {
 		assert getAuditReader().getRevisions( Person.class, personId ).equals( getExpectedPersonRevisions() );
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/components/PropertiesGroupTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/components/PropertiesGroupTest.java
index d0e3c30a81..ce41197798 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/components/PropertiesGroupTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/components/PropertiesGroupTest.java
@@ -1,89 +1,86 @@
 package org.hibernate.envers.test.integration.components;
 
 import org.hibernate.Session;
 import org.hibernate.envers.test.BaseEnversFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.entities.components.UniquePropsEntity;
 import org.hibernate.envers.test.entities.components.UniquePropsNotAuditedEntity;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.PersistentClass;
 
 import org.hibernate.testing.TestForIssue;
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 @TestForIssue(jiraKey = "HHH-6636")
 public class PropertiesGroupTest extends BaseEnversFunctionalTestCase {
 	private PersistentClass uniquePropsAudit = null;
 	private PersistentClass uniquePropsNotAuditedAudit = null;
 	private UniquePropsEntity entityRev1 = null;
 	private UniquePropsNotAuditedEntity entityNotAuditedRev2 = null;
 
 	@Override
 	protected String[] getMappings() {
 		return new String[] {
 				"mappings/components/UniquePropsEntity.hbm.xml",
 				"mappings/components/UniquePropsNotAuditedEntity.hbm.xml"
 		};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
-		uniquePropsAudit = configuration().getClassMapping(
+		uniquePropsAudit = metadata().getEntityBinding(
 				"org.hibernate.envers.test.entities.components.UniquePropsEntity_AUD"
 		);
-		uniquePropsNotAuditedAudit = configuration().getClassMapping(
+		uniquePropsNotAuditedAudit = metadata().getEntityBinding(
 				"org.hibernate.envers.test.entities.components.UniquePropsNotAuditedEntity_AUD"
 		);
 
 		// Revision 1
 		Session session = openSession();
 		session.getTransaction().begin();
 		UniquePropsEntity ent = new UniquePropsEntity();
 		ent.setData1( "data1" );
 		ent.setData2( "data2" );
 		session.persist( ent );
 		session.getTransaction().commit();
 
 		entityRev1 = new UniquePropsEntity( ent.getId(), ent.getData1(), ent.getData2() );
 
 		// Revision 2
 		session.getTransaction().begin();
 		UniquePropsNotAuditedEntity entNotAud = new UniquePropsNotAuditedEntity();
 		entNotAud.setData1( "data3" );
 		entNotAud.setData2( "data4" );
 		session.persist( entNotAud );
 		session.getTransaction().commit();
 
 		entityNotAuditedRev2 = new UniquePropsNotAuditedEntity( entNotAud.getId(), entNotAud.getData1(), null );
 	}
 
 	@Test
 	public void testAuditTableColumns() {
 		Assert.assertNotNull( uniquePropsAudit.getTable().getColumn( new Column( "DATA1" ) ) );
 		Assert.assertNotNull( uniquePropsAudit.getTable().getColumn( new Column( "DATA2" ) ) );
 
 		Assert.assertNotNull( uniquePropsNotAuditedAudit.getTable().getColumn( new Column( "DATA1" ) ) );
 		Assert.assertNull( uniquePropsNotAuditedAudit.getTable().getColumn( new Column( "DATA2" ) ) );
 	}
 
 	@Test
 	public void testHistoryOfUniquePropsEntity() {
 		Assert.assertEquals( entityRev1, getAuditReader().find( UniquePropsEntity.class, entityRev1.getId(), 1 ) );
 	}
 
 	@Test
 	public void testHistoryOfUniquePropsNotAuditedEntity() {
 		Assert.assertEquals(
-				entityNotAuditedRev2, getAuditReader().find(
-				UniquePropsNotAuditedEntity.class,
-				entityNotAuditedRev2.getId(),
-				2
-		)
+				entityNotAuditedRev2,
+				getAuditReader().find( UniquePropsNotAuditedEntity.class, entityNotAuditedRev2.getId(), 2 )
 		);
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/customtype/UnspecifiedEnumTypeTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/customtype/UnspecifiedEnumTypeTest.java
index a08bc88b16..527a821282 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/customtype/UnspecifiedEnumTypeTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/customtype/UnspecifiedEnumTypeTest.java
@@ -1,158 +1,160 @@
 package org.hibernate.envers.test.integration.customtype;
 
 import java.util.Arrays;
 import java.util.List;
+import java.util.Map;
 
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.envers.test.BaseEnversFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.entities.customtype.UnspecifiedEnumTypeEntity;
 
 import org.hibernate.testing.RequiresDialect;
 import org.hibernate.testing.TestForIssue;
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 @TestForIssue(jiraKey = "HHH-7780")
 @RequiresDialect(value = H2Dialect.class)
 public class UnspecifiedEnumTypeTest extends BaseEnversFunctionalTestCase {
 	private Long id = null;
 
 	@Override
 	protected String[] getMappings() {
 		return new String[] {"mappings/customType/mappings.hbm.xml"};
 	}
 
 	@Override
-	protected void configure(Configuration configuration) {
-		super.configure( configuration );
-		configuration.setProperty( Environment.HBM2DDL_AUTO, "" );
+	protected void addSettings(Map settings) {
+		super.addSettings( settings );
+
+		settings.put( Environment.HBM2DDL_AUTO, "" );
 	}
 
 	@Test
 	@Priority(10)
 	public void prepareSchema() {
 		Session session = openSession();
 		dropSchema( session );
 		createSchema( session );
 		session.close();
 	}
 
 	@Test
 	@Priority(1)
 	public void dropSchema() {
-		dropSchema( session );
+		dropSchema( getSession() );
 	}
 
 	public void dropSchema(Session session) {
 		executeUpdateSafety( session, "alter table ENUM_ENTITY_AUD drop constraint FK_AUD_REV" );
 		executeUpdateSafety( session, "drop table ENUM_ENTITY if exists" );
 		executeUpdateSafety( session, "drop table ENUM_ENTITY_AUD if exists" );
 		executeUpdateSafety( session, "drop table REVINFO if exists" );
 		executeUpdateSafety( session, "drop sequence REVISION_GENERATOR" );
 	}
 
 	private void createSchema(Session session) {
 		executeUpdateSafety(
 				session,
 				"create table ENUM_ENTITY (ID bigint not null, enum1 varchar(255), enum2 integer, primary key (ID))"
 		);
 		executeUpdateSafety(
 				session,
 				"create table ENUM_ENTITY_AUD (ID bigint not null, REV integer not null, REVTYPE tinyint, enum1 varchar(255), enum2 integer, primary key (ID, REV))"
 		);
 		executeUpdateSafety(
 				session,
 				"create table REVINFO (REV integer not null, REVTSTMP bigint, primary key (REV))"
 		);
 		executeUpdateSafety(
 				session,
 				"alter table ENUM_ENTITY_AUD add constraint FK_AUD_REV foreign key (REV) references REVINFO"
 		);
 		executeUpdateSafety( session, "create sequence REVISION_GENERATOR start with 1 increment by 1" );
 	}
 
 	private void executeUpdateSafety(Session session, String query) {
 		try {
 			session.createSQLQuery( query ).executeUpdate();
 		}
 		catch (Exception e) {
 		}
 	}
 
 	@Test
 	@Priority(9)
 	public void initData() {
 		Session session = getSession();
 
 		// Revision 1
 		session.getTransaction().begin();
 		UnspecifiedEnumTypeEntity entity = new UnspecifiedEnumTypeEntity(
 				UnspecifiedEnumTypeEntity.E1.X,
 				UnspecifiedEnumTypeEntity.E2.A
 		);
 		session.persist( entity );
 		session.getTransaction().commit();
 
 		id = entity.getId();
 
 		// Revision 2
 		session.getTransaction().begin();
 		entity = (UnspecifiedEnumTypeEntity) session.get( UnspecifiedEnumTypeEntity.class, entity.getId() );
 		entity.setEnum1( UnspecifiedEnumTypeEntity.E1.Y );
 		entity.setEnum2( UnspecifiedEnumTypeEntity.E2.B );
 		session.update( entity );
 		session.getTransaction().commit();
 
 		session.close();
 	}
 
 	@Test
 	@Priority(8)
 	public void testRevisionCount() {
 		Assert.assertEquals(
 				Arrays.asList( 1, 2 ), getAuditReader().getRevisions(
 				UnspecifiedEnumTypeEntity.class,
 				id
 		)
 		);
 	}
 
 	@Test
 	@Priority(7)
 	public void testHistoryOfEnums() {
 		UnspecifiedEnumTypeEntity ver1 = new UnspecifiedEnumTypeEntity(
 				UnspecifiedEnumTypeEntity.E1.X,
 				UnspecifiedEnumTypeEntity.E2.A,
 				id
 		);
 		UnspecifiedEnumTypeEntity ver2 = new UnspecifiedEnumTypeEntity(
 				UnspecifiedEnumTypeEntity.E1.Y,
 				UnspecifiedEnumTypeEntity.E2.B,
 				id
 		);
 
 		Assert.assertEquals( ver1, getAuditReader().find( UnspecifiedEnumTypeEntity.class, id, 1 ) );
 		Assert.assertEquals( ver2, getAuditReader().find( UnspecifiedEnumTypeEntity.class, id, 2 ) );
 	}
 
 	@Test
 	@Priority(6)
 	public void testEnumRepresentation() {
 		Session session = getSession();
 		List<Object[]> values = session.createSQLQuery( "SELECT enum1, enum2 FROM enum_entity_aud ORDER BY rev ASC" )
 				.list();
 		session.close();
 
 		Assert.assertNotNull( values );
 		Assert.assertEquals( 2, values.size() );
 		Assert.assertArrayEquals( new Object[] {"X", 0}, values.get( 0 ) );
 		Assert.assertArrayEquals( new Object[] {"Y", 1}, values.get( 1 ) );
 	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/inheritance/joined/primarykeyjoin/ChildPrimaryKeyJoinAuditing.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/inheritance/joined/primarykeyjoin/ChildPrimaryKeyJoinAuditing.java
index 411cfdd0db..0e86e5a94f 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/inheritance/joined/primarykeyjoin/ChildPrimaryKeyJoinAuditing.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/inheritance/joined/primarykeyjoin/ChildPrimaryKeyJoinAuditing.java
@@ -1,111 +1,109 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
 package org.hibernate.envers.test.integration.inheritance.joined.primarykeyjoin;
 
 import java.util.Arrays;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.integration.inheritance.joined.ParentEntity;
 import org.hibernate.mapping.Column;
 
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class ChildPrimaryKeyJoinAuditing extends BaseEnversJPAFunctionalTestCase {
 	private Integer id1;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {ChildPrimaryKeyJoinEntity.class, ParentEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		EntityManager em = getEntityManager();
 
 		id1 = 1;
 
 		// Rev 1
 		em.getTransaction().begin();
 		ChildPrimaryKeyJoinEntity ce = new ChildPrimaryKeyJoinEntity( id1, "x", 1l );
 		em.persist( ce );
 		em.getTransaction().commit();
 
 		// Rev 2
 		em.getTransaction().begin();
 		ce = em.find( ChildPrimaryKeyJoinEntity.class, id1 );
 		ce.setData( "y" );
 		ce.setNumVal( 2l );
 		em.getTransaction().commit();
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1, 2 ).equals( getAuditReader().getRevisions( ChildPrimaryKeyJoinEntity.class, id1 ) );
 	}
 
 	@Test
 	public void testHistoryOfChildId1() {
 		ChildPrimaryKeyJoinEntity ver1 = new ChildPrimaryKeyJoinEntity( id1, "x", 1l );
 		ChildPrimaryKeyJoinEntity ver2 = new ChildPrimaryKeyJoinEntity( id1, "y", 2l );
 
 		assert getAuditReader().find( ChildPrimaryKeyJoinEntity.class, id1, 1 ).equals( ver1 );
 		assert getAuditReader().find( ChildPrimaryKeyJoinEntity.class, id1, 2 ).equals( ver2 );
 
 		assert getAuditReader().find( ParentEntity.class, id1, 1 ).equals( ver1 );
 		assert getAuditReader().find( ParentEntity.class, id1, 2 ).equals( ver2 );
 	}
 
 	@Test
 	public void testPolymorphicQuery() {
 		ChildPrimaryKeyJoinEntity childVer1 = new ChildPrimaryKeyJoinEntity( id1, "x", 1l );
 
 		assert getAuditReader().createQuery()
 				.forEntitiesAtRevision( ChildPrimaryKeyJoinEntity.class, 1 )
 				.getSingleResult()
 				.equals( childVer1 );
 
 		assert getAuditReader().createQuery().forEntitiesAtRevision( ParentEntity.class, 1 ).getSingleResult()
 				.equals( childVer1 );
 	}
 
 	@Test
 	public void testChildIdColumnName() {
 		Assert.assertEquals(
 				"other_id",
-				((Column) getCfg()
-						.getClassMapping(
-								"org.hibernate.envers.test.integration.inheritance.joined.primarykeyjoin.ChildPrimaryKeyJoinEntity_AUD"
-						)
-						.getKey().getColumnIterator().next()).getName()
+				((Column) metadata().getEntityBinding(
+						"org.hibernate.envers.test.integration.inheritance.joined.primarykeyjoin.ChildPrimaryKeyJoinEntity_AUD"
+				).getKey().getColumnIterator().next()).getName()
 		);
 	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/inheritance/single/discriminatorformula/DiscriminatorFormulaTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/inheritance/single/discriminatorformula/DiscriminatorFormulaTest.java
index 327382fba6..f0a33c79f2 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/inheritance/single/discriminatorformula/DiscriminatorFormulaTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/inheritance/single/discriminatorformula/DiscriminatorFormulaTest.java
@@ -1,158 +1,158 @@
 package org.hibernate.envers.test.integration.inheritance.single.discriminatorformula;
 
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.mapping.Formula;
 import org.hibernate.mapping.PersistentClass;
 
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class DiscriminatorFormulaTest extends BaseEnversJPAFunctionalTestCase {
 	private PersistentClass parentAudit = null;
 	private ChildEntity childVer1 = null;
 	private ChildEntity childVer2 = null;
 	private ParentEntity parentVer1 = null;
 	private ParentEntity parentVer2 = null;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {ClassTypeEntity.class, ParentEntity.class, ChildEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
-		parentAudit = getCfg().getClassMapping(
+		parentAudit = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.inheritance.single.discriminatorformula.ParentEntity_AUD"
 		);
 
 		EntityManager em = getEntityManager();
 
 		// Child entity type
 		em.getTransaction().begin();
 		ClassTypeEntity childType = new ClassTypeEntity();
 		childType.setType( ClassTypeEntity.CHILD_TYPE );
 		em.persist( childType );
 		Long childTypeId = childType.getId();
 		em.getTransaction().commit();
 
 		// Parent entity type
 		em.getTransaction().begin();
 		ClassTypeEntity parentType = new ClassTypeEntity();
 		parentType.setType( ClassTypeEntity.PARENT_TYPE );
 		em.persist( parentType );
 		Long parentTypeId = parentType.getId();
 		em.getTransaction().commit();
 
 		// Child Rev 1
 		em.getTransaction().begin();
 		ChildEntity child = new ChildEntity( childTypeId, "Child data", "Child specific data" );
 		em.persist( child );
 		Long childId = child.getId();
 		em.getTransaction().commit();
 
 		// Parent Rev 2
 		em.getTransaction().begin();
 		ParentEntity parent = new ParentEntity( parentTypeId, "Parent data" );
 		em.persist( parent );
 		Long parentId = parent.getId();
 		em.getTransaction().commit();
 
 		// Child Rev 3
 		em.getTransaction().begin();
 		child = em.find( ChildEntity.class, childId );
 		child.setData( "Child data modified" );
 		em.getTransaction().commit();
 
 		// Parent Rev 4
 		em.getTransaction().begin();
 		parent = em.find( ParentEntity.class, parentId );
 		parent.setData( "Parent data modified" );
 		em.getTransaction().commit();
 
 		childVer1 = new ChildEntity( childId, childTypeId, "Child data", "Child specific data" );
 		childVer2 = new ChildEntity( childId, childTypeId, "Child data modified", "Child specific data" );
 		parentVer1 = new ParentEntity( parentId, parentTypeId, "Parent data" );
 		parentVer2 = new ParentEntity( parentId, parentTypeId, "Parent data modified" );
 	}
 
 	@Test
 	public void testDiscriminatorFormulaInAuditTable() {
 		assert parentAudit.getDiscriminator().hasFormula();
 		Iterator iterator = parentAudit.getDiscriminator().getColumnIterator();
 		while ( iterator.hasNext() ) {
 			Object o = iterator.next();
 			if ( o instanceof Formula ) {
 				Formula formula = (Formula) o;
 				Assert.assertEquals( ParentEntity.DISCRIMINATOR_QUERY, formula.getText() );
 				return;
 			}
 		}
 		assert false;
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		Assert.assertEquals(
 				Arrays.asList( 1, 3 ), getAuditReader().getRevisions(
 				ChildEntity.class,
 				childVer1.getId()
 		)
 		);
 		Assert.assertEquals(
 				Arrays.asList( 2, 4 ), getAuditReader().getRevisions(
 				ParentEntity.class,
 				parentVer1.getId()
 		)
 		);
 	}
 
 	@Test
 	public void testHistoryOfParent() {
 		Assert.assertEquals( parentVer1, getAuditReader().find( ParentEntity.class, parentVer1.getId(), 2 ) );
 		Assert.assertEquals( parentVer2, getAuditReader().find( ParentEntity.class, parentVer2.getId(), 4 ) );
 	}
 
 	@Test
 	public void testHistoryOfChild() {
 		Assert.assertEquals( childVer1, getAuditReader().find( ChildEntity.class, childVer1.getId(), 1 ) );
 		Assert.assertEquals( childVer2, getAuditReader().find( ChildEntity.class, childVer2.getId(), 3 ) );
 	}
 
 	@Test
 	public void testPolymorphicQuery() {
 		Assert.assertEquals(
 				childVer1, getAuditReader().createQuery()
 				.forEntitiesAtRevision( ChildEntity.class, 1 )
 				.getSingleResult()
 		);
 		Assert.assertEquals(
 				childVer1, getAuditReader().createQuery()
 				.forEntitiesAtRevision( ParentEntity.class, 1 )
 				.getSingleResult()
 		);
 
 		List childEntityRevisions = getAuditReader().createQuery().forRevisionsOfEntity(
 				ChildEntity.class,
 				true,
 				false
 		).getResultList();
 		Assert.assertEquals( Arrays.asList( childVer1, childVer2 ), childEntityRevisions );
 
 		List parentEntityRevisions = getAuditReader().createQuery().forRevisionsOfEntity(
 				ParentEntity.class,
 				true,
 				false
 		).getResultList();
 		Assert.assertEquals( Arrays.asList( childVer1, parentVer1, childVer2, parentVer2 ), parentEntityRevisions );
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/inheritance/tableperclass/abstractparent/AuditedAbstractParentTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/inheritance/tableperclass/abstractparent/AuditedAbstractParentTest.java
index f51f90a97d..9f73c21ab9 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/inheritance/tableperclass/abstractparent/AuditedAbstractParentTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/inheritance/tableperclass/abstractparent/AuditedAbstractParentTest.java
@@ -1,50 +1,48 @@
 package org.hibernate.envers.test.integration.inheritance.tableperclass.abstractparent;
 
 import java.util.Iterator;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.mapping.Table;
 
 import org.hibernate.testing.TestForIssue;
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 @TestForIssue(jiraKey = "HHH-5910")
 public class AuditedAbstractParentTest extends BaseEnversJPAFunctionalTestCase {
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] {AbstractEntity.class, EffectiveEntity1.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		EntityManager em = getEntityManager();
 
 		// Revision 1
 		em.getTransaction().begin();
 		EffectiveEntity1 entity = new EffectiveEntity1( 1L, "commonField", "specificField1" );
 		em.persist( entity );
 		em.getTransaction().commit();
 
 		em.close();
 	}
 
 	@Test
 	public void testAbstractTableExistence() {
-		Iterator<Table> tableIterator = getCfg().getTableMappings();
-		while ( tableIterator.hasNext() ) {
-			Table table = tableIterator.next();
+		for ( Table table : metadata().collectTableMappings() ) {
 			if ( "AbstractEntity_AUD".equals( table.getName() ) ) {
 				Assert.assertFalse( table.isPhysicalTable() );
 				return;
 			}
 		}
 		Assert.fail();
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/modifiedflags/HasChangedComponents.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/modifiedflags/HasChangedComponents.java
index 0352c455c5..cb7b3850f4 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/modifiedflags/HasChangedComponents.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/modifiedflags/HasChangedComponents.java
@@ -1,194 +1,194 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.modifiedflags;
 
 import java.util.List;
 import javax.persistence.EntityManager;
 
 import org.hibernate.QueryException;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.entities.components.Component1;
 import org.hibernate.envers.test.entities.components.Component2;
 import org.hibernate.envers.test.entities.components.ComponentTestEntity;
 import org.hibernate.envers.test.tools.TestTools;
 
 import org.junit.Test;
 
 import static junit.framework.Assert.assertEquals;
 import static org.hibernate.envers.test.tools.TestTools.extractRevisionNumbers;
 import static org.hibernate.envers.test.tools.TestTools.makeList;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public class HasChangedComponents extends AbstractModifiedFlagsEntityTest {
 	private Integer id1;
 	private Integer id2;
 	private Integer id3;
 	private Integer id4;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {ComponentTestEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		// Revision 1
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 
 		ComponentTestEntity cte1 = new ComponentTestEntity( new Component1( "a", "b" ), new Component2( "x", "y" ) );
 		ComponentTestEntity cte2 = new ComponentTestEntity(
 				new Component1( "a2", "b2" ), new Component2(
 				"x2",
 				"y2"
 		)
 		);
 		ComponentTestEntity cte3 = new ComponentTestEntity(
 				new Component1( "a3", "b3" ), new Component2(
 				"x3",
 				"y3"
 		)
 		);
 		ComponentTestEntity cte4 = new ComponentTestEntity( null, null );
 
 		em.persist( cte1 );
 		em.persist( cte2 );
 		em.persist( cte3 );
 		em.persist( cte4 );
 
 		em.getTransaction().commit();
 
 		// Revision 2
 		em = getEntityManager();
 		em.getTransaction().begin();
 
 		cte1 = em.find( ComponentTestEntity.class, cte1.getId() );
 		cte2 = em.find( ComponentTestEntity.class, cte2.getId() );
 		cte3 = em.find( ComponentTestEntity.class, cte3.getId() );
 		cte4 = em.find( ComponentTestEntity.class, cte4.getId() );
 
 		cte1.setComp1( new Component1( "a'", "b'" ) );
 		cte2.getComp1().setStr1( "a2'" );
 		cte3.getComp2().setStr6( "y3'" );
 		cte4.setComp1( new Component1() );
 		cte4.getComp1().setStr1( "n" );
 		cte4.setComp2( new Component2() );
 		cte4.getComp2().setStr5( "m" );
 
 		em.getTransaction().commit();
 
 		// Revision 3
 		em = getEntityManager();
 		em.getTransaction().begin();
 
 		cte1 = em.find( ComponentTestEntity.class, cte1.getId() );
 		cte2 = em.find( ComponentTestEntity.class, cte2.getId() );
 		cte3 = em.find( ComponentTestEntity.class, cte3.getId() );
 		cte4 = em.find( ComponentTestEntity.class, cte4.getId() );
 
 		cte1.setComp2( new Component2( "x'", "y'" ) );
 		cte3.getComp1().setStr2( "b3'" );
 		cte4.setComp1( null );
 		cte4.setComp2( null );
 
 		em.getTransaction().commit();
 
 		// Revision 4
 		em = getEntityManager();
 		em.getTransaction().begin();
 
 		cte2 = em.find( ComponentTestEntity.class, cte2.getId() );
 
 		em.remove( cte2 );
 
 		em.getTransaction().commit();
 
 		id1 = cte1.getId();
 		id2 = cte2.getId();
 		id3 = cte3.getId();
 		id4 = cte4.getId();
 	}
 
 	@Test
 	public void testModFlagProperties() {
 		assertEquals(
 				TestTools.makeSet( "comp1_MOD" ),
 				TestTools.extractModProperties(
-						getCfg().getClassMapping(
+						metadata().getEntityBinding(
 								"org.hibernate.envers.test.entities.components.ComponentTestEntity_AUD"
 						)
 				)
 		);
 	}
 
 	@Test(expected = QueryException.class)
 	public void testHasChangedNotAudited() throws Exception {
 		queryForPropertyHasChanged( ComponentTestEntity.class, id1, "comp2" );
 	}
 
 	@Test
 	public void testHasChangedId1() throws Exception {
 		List list = queryForPropertyHasChanged( ComponentTestEntity.class, id1, "comp1" );
 		assertEquals( 2, list.size() );
 		assertEquals( makeList( 1, 2 ), extractRevisionNumbers( list ) );
 
 		list = queryForPropertyHasNotChanged( ComponentTestEntity.class, id1, "comp1" );
 		assertEquals( 0, list.size() );
 	}
 
 	@Test
 	public void testHasChangedId2() throws Exception {
 		List list = queryForPropertyHasChangedWithDeleted( ComponentTestEntity.class, id2, "comp1" );
 		assertEquals( 3, list.size() );
 		assertEquals( makeList( 1, 2, 4 ), extractRevisionNumbers( list ) );
 
 		list = queryForPropertyHasNotChangedWithDeleted( ComponentTestEntity.class, id2, "comp1" );
 		assertEquals( 0, list.size() );
 	}
 
 	@Test
 	public void testHasChangedId3() throws Exception {
 		List list = queryForPropertyHasChangedWithDeleted( ComponentTestEntity.class, id3, "comp1" );
 		assertEquals( 2, list.size() );
 		assertEquals( makeList( 1, 3 ), extractRevisionNumbers( list ) );
 
 		list = queryForPropertyHasNotChangedWithDeleted( ComponentTestEntity.class, id3, "comp1" );
 		assertEquals( 0, list.size() );
 	}
 
 	@Test
 	public void testHasChangedId4() throws Exception {
 		List list = queryForPropertyHasChangedWithDeleted( ComponentTestEntity.class, id4, "comp1" );
 		assertEquals( 2, list.size() );
 		assertEquals( makeList( 2, 3 ), extractRevisionNumbers( list ) );
 
 		list = queryForPropertyHasNotChangedWithDeleted( ComponentTestEntity.class, id4, "comp1" );
 		assertEquals( 1, list.size() );
 		assertEquals( makeList( 1 ), extractRevisionNumbers( list ) );
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/modifiedflags/ModifiedFlagSuffix.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/modifiedflags/ModifiedFlagSuffix.java
index 18f3754e0c..1fa5e0cfc7 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/modifiedflags/ModifiedFlagSuffix.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/modifiedflags/ModifiedFlagSuffix.java
@@ -1,112 +1,112 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.modifiedflags;
 
 import java.util.List;
 import java.util.Map;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.configuration.EnversSettings;
 import org.hibernate.envers.query.AuditEntity;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.integration.basic.BasicTestEntity1;
 import org.hibernate.envers.test.tools.TestTools;
 
 import org.junit.Test;
 
 import static junit.framework.Assert.assertEquals;
 import static org.hibernate.envers.test.tools.TestTools.extractRevisionNumbers;
 import static org.hibernate.envers.test.tools.TestTools.makeList;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Michal Skowronek (mskowr at o2 dot pl)
  */
 public class ModifiedFlagSuffix extends AbstractModifiedFlagsEntityTest {
 	private Integer id1;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {BasicTestEntity1.class};
 	}
 
 	@Override
 	protected void addConfigOptions(Map options) {
 		super.addConfigOptions( options );
 		options.put( EnversSettings.MODIFIED_FLAG_SUFFIX, "_CHANGED" );
 	}
 
 	private Integer addNewEntity(String str, long lng) {
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 		BasicTestEntity1 bte1 = new BasicTestEntity1( str, lng );
 		em.persist( bte1 );
 		em.getTransaction().commit();
 
 		return bte1.getId();
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		id1 = addNewEntity( "x", 1 ); // rev 1
 	}
 
 	@Test
 	public void testModFlagProperties() {
 		assertEquals(
 				TestTools.makeSet( "str1_CHANGED", "long1_CHANGED" ),
 				TestTools.extractModProperties(
-						getCfg().getClassMapping(
+						metadata().getEntityBinding(
 								"org.hibernate.envers.test.integration.basic.BasicTestEntity1_AUD"
 						),
 						"_CHANGED"
 				)
 		);
 	}
 
 	@Test
 	public void testHasChanged() throws Exception {
 		List list = queryForPropertyHasChangedWithDeleted(
 				BasicTestEntity1.class,
 				id1, "str1"
 		);
 		assertEquals( 1, list.size() );
 		assertEquals( makeList( 1 ), extractRevisionNumbers( list ) );
 
 		list = queryForPropertyHasChangedWithDeleted(
 				BasicTestEntity1.class,
 				id1, "long1"
 		);
 		assertEquals( 1, list.size() );
 		assertEquals( makeList( 1 ), extractRevisionNumbers( list ) );
 
 		list = getAuditReader().createQuery().forRevisionsOfEntity( BasicTestEntity1.class, false, true )
 				.add( AuditEntity.property( "str1" ).hasChanged() )
 				.add( AuditEntity.property( "long1" ).hasChanged() )
 				.getResultList();
 		assertEquals( 1, list.size() );
 		assertEquals( makeList( 1 ), extractRevisionNumbers( list ) );
 	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/BasicNaming.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/BasicNaming.java
index 384d366e2b..e3778ef9b1 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/BasicNaming.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/BasicNaming.java
@@ -1,117 +1,116 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.naming;
 
 import java.util.Arrays;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 
 import org.junit.Test;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class BasicNaming extends BaseEnversJPAFunctionalTestCase {
 	private Integer id1;
 	private Integer id2;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {NamingTestEntity1.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		NamingTestEntity1 nte1 = new NamingTestEntity1( "data1" );
 		NamingTestEntity1 nte2 = new NamingTestEntity1( "data2" );
 
 		// Revision 1
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 
 		em.persist( nte1 );
 		em.persist( nte2 );
 
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 
 		nte1 = em.find( NamingTestEntity1.class, nte1.getId() );
 		nte1.setData( "data1'" );
 
 		em.getTransaction().commit();
 
 		// Revision 3
 		em.getTransaction().begin();
 
 		nte2 = em.find( NamingTestEntity1.class, nte2.getId() );
 		nte2.setData( "data2'" );
 
 		em.getTransaction().commit();
 
 		//
 
 		id1 = nte1.getId();
 		id2 = nte2.getId();
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1, 2 ).equals( getAuditReader().getRevisions( NamingTestEntity1.class, id1 ) );
 
 		assert Arrays.asList( 1, 3 ).equals( getAuditReader().getRevisions( NamingTestEntity1.class, id2 ) );
 	}
 
 	@Test
 	public void testHistoryOfId1() {
 		NamingTestEntity1 ver1 = new NamingTestEntity1( id1, "data1" );
 		NamingTestEntity1 ver2 = new NamingTestEntity1( id1, "data1'" );
 
 		assert getAuditReader().find( NamingTestEntity1.class, id1, 1 ).equals( ver1 );
 		assert getAuditReader().find( NamingTestEntity1.class, id1, 2 ).equals( ver2 );
 		assert getAuditReader().find( NamingTestEntity1.class, id1, 3 ).equals( ver2 );
 	}
 
 	@Test
 	public void testHistoryOfId2() {
 		NamingTestEntity1 ver1 = new NamingTestEntity1( id2, "data2" );
 		NamingTestEntity1 ver2 = new NamingTestEntity1( id2, "data2'" );
 
 		assert getAuditReader().find( NamingTestEntity1.class, id2, 1 ).equals( ver1 );
 		assert getAuditReader().find( NamingTestEntity1.class, id2, 2 ).equals( ver1 );
 		assert getAuditReader().find( NamingTestEntity1.class, id2, 3 ).equals( ver2 );
 	}
 
 	@Test
 	public void testTableName() {
 		assert "naming_test_entity_1_versions".equals(
-				getCfg().getClassMapping( "org.hibernate.envers.test.integration.naming.NamingTestEntity1_AUD" )
-						.getTable().getName()
+				metadata().getEntityBinding( "org.hibernate.envers.test.integration.naming.NamingTestEntity1_AUD" ).getTable().getName()
 		);
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/JoinNaming.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/JoinNaming.java
index 42bde825ab..e9ad60c91b 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/JoinNaming.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/JoinNaming.java
@@ -1,138 +1,138 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.naming;
 
 import java.util.Arrays;
 import java.util.Iterator;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.mapping.Column;
 
 import org.junit.Test;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class JoinNaming extends BaseEnversJPAFunctionalTestCase {
 	private Integer ed_id1;
 	private Integer ed_id2;
 	private Integer ing_id1;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {JoinNamingRefEdEntity.class, JoinNamingRefIngEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		JoinNamingRefEdEntity ed1 = new JoinNamingRefEdEntity( "data1" );
 		JoinNamingRefEdEntity ed2 = new JoinNamingRefEdEntity( "data2" );
 
 		JoinNamingRefIngEntity ing1 = new JoinNamingRefIngEntity( "x", ed1 );
 
 		// Revision 1
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 
 		em.persist( ed1 );
 		em.persist( ed2 );
 		em.persist( ing1 );
 
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 
 		ed2 = em.find( JoinNamingRefEdEntity.class, ed2.getId() );
 
 		ing1 = em.find( JoinNamingRefIngEntity.class, ing1.getId() );
 		ing1.setData( "y" );
 		ing1.setReference( ed2 );
 
 		em.getTransaction().commit();
 
 		//
 
 		ed_id1 = ed1.getId();
 		ed_id2 = ed2.getId();
 		ing_id1 = ing1.getId();
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1, 2 ).equals( getAuditReader().getRevisions( JoinNamingRefEdEntity.class, ed_id1 ) );
 		assert Arrays.asList( 1, 2 ).equals( getAuditReader().getRevisions( JoinNamingRefEdEntity.class, ed_id2 ) );
 		assert Arrays.asList( 1, 2 ).equals( getAuditReader().getRevisions( JoinNamingRefIngEntity.class, ing_id1 ) );
 	}
 
 	@Test
 	public void testHistoryOfEdId1() {
 		JoinNamingRefEdEntity ver1 = new JoinNamingRefEdEntity( ed_id1, "data1" );
 
 		assert getAuditReader().find( JoinNamingRefEdEntity.class, ed_id1, 1 ).equals( ver1 );
 		assert getAuditReader().find( JoinNamingRefEdEntity.class, ed_id1, 2 ).equals( ver1 );
 	}
 
 	@Test
 	public void testHistoryOfEdId2() {
 		JoinNamingRefEdEntity ver1 = new JoinNamingRefEdEntity( ed_id2, "data2" );
 
 		assert getAuditReader().find( JoinNamingRefEdEntity.class, ed_id2, 1 ).equals( ver1 );
 		assert getAuditReader().find( JoinNamingRefEdEntity.class, ed_id2, 2 ).equals( ver1 );
 	}
 
 	@Test
 	public void testHistoryOfIngId1() {
 		JoinNamingRefIngEntity ver1 = new JoinNamingRefIngEntity( ing_id1, "x", null );
 		JoinNamingRefIngEntity ver2 = new JoinNamingRefIngEntity( ing_id1, "y", null );
 
 		assert getAuditReader().find( JoinNamingRefIngEntity.class, ing_id1, 1 ).equals( ver1 );
 		assert getAuditReader().find( JoinNamingRefIngEntity.class, ing_id1, 2 ).equals( ver2 );
 
 		assert getAuditReader().find( JoinNamingRefIngEntity.class, ing_id1, 1 ).getReference().equals(
 				new JoinNamingRefEdEntity( ed_id1, "data1" )
 		);
 		assert getAuditReader().find( JoinNamingRefIngEntity.class, ing_id1, 2 ).getReference().equals(
 				new JoinNamingRefEdEntity( ed_id2, "data2" )
 		);
 	}
 
 	@SuppressWarnings({"unchecked"})
 	@Test
 	public void testJoinColumnName() {
-		Iterator<Column> columns =
-				getCfg().getClassMapping( "org.hibernate.envers.test.integration.naming.JoinNamingRefIngEntity_AUD" )
-						.getProperty( "reference_id" ).getColumnIterator();
+		Iterator<Column> columns = metadata().getEntityBinding(
+				"org.hibernate.envers.test.integration.naming.JoinNamingRefIngEntity_AUD"
+		).getProperty( "reference_id" ).getColumnIterator();
 		assertTrue( columns.hasNext() );
 		assertEquals( "jnree_column_reference", columns.next().getName() );
 		assertFalse( columns.hasNext() );
 	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/OneToManyUnidirectionalNaming.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/OneToManyUnidirectionalNaming.java
index 98ccf115d8..4f1b967d38 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/OneToManyUnidirectionalNaming.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/OneToManyUnidirectionalNaming.java
@@ -1,133 +1,133 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.naming;
 
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.Iterator;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.entities.StrTestEntity;
 import org.hibernate.envers.test.tools.TestTools;
 import org.hibernate.mapping.Column;
 
 import org.junit.Test;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class OneToManyUnidirectionalNaming extends BaseEnversJPAFunctionalTestCase {
 	private Integer uni1_id;
 	private Integer str1_id;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {DetachedNamingTestEntity.class, StrTestEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		DetachedNamingTestEntity uni1 = new DetachedNamingTestEntity( 1, "data1" );
 		StrTestEntity str1 = new StrTestEntity( "str1" );
 
 		// Revision 1
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 
 		uni1.setCollection( new HashSet<StrTestEntity>() );
 		em.persist( uni1 );
 		em.persist( str1 );
 
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 
 		uni1 = em.find( DetachedNamingTestEntity.class, uni1.getId() );
 		str1 = em.find( StrTestEntity.class, str1.getId() );
 		uni1.getCollection().add( str1 );
 
 		em.getTransaction().commit();
 
 		//
 
 		uni1_id = uni1.getId();
 		str1_id = str1.getId();
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1, 2 ).equals( getAuditReader().getRevisions( DetachedNamingTestEntity.class, uni1_id ) );
 		assert Arrays.asList( 1 ).equals( getAuditReader().getRevisions( StrTestEntity.class, str1_id ) );
 	}
 
 	@Test
 	public void testHistoryOfUniId1() {
 		StrTestEntity str1 = getEntityManager().find( StrTestEntity.class, str1_id );
 
 		DetachedNamingTestEntity rev1 = getAuditReader().find( DetachedNamingTestEntity.class, uni1_id, 1 );
 		DetachedNamingTestEntity rev2 = getAuditReader().find( DetachedNamingTestEntity.class, uni1_id, 2 );
 
 		assert rev1.getCollection().equals( TestTools.makeSet() );
 		assert rev2.getCollection().equals( TestTools.makeSet( str1 ) );
 
 		assert "data1".equals( rev1.getData() );
 		assert "data1".equals( rev2.getData() );
 	}
 
 	private final static String MIDDLE_VERSIONS_ENTITY_NAME = "UNI_NAMING_TEST_AUD";
 
 	@Test
 	public void testTableName() {
 		assert MIDDLE_VERSIONS_ENTITY_NAME.equals(
-				getCfg().getClassMapping( MIDDLE_VERSIONS_ENTITY_NAME ).getTable().getName()
+				metadata().getEntityBinding( MIDDLE_VERSIONS_ENTITY_NAME ).getTable().getName()
 		);
 	}
 
 	@SuppressWarnings({"unchecked"})
 	@Test
 	public void testJoinColumnName() {
 		Iterator<Column> columns =
-				getCfg().getClassMapping( MIDDLE_VERSIONS_ENTITY_NAME ).getTable().getColumnIterator();
+				metadata().getEntityBinding( MIDDLE_VERSIONS_ENTITY_NAME ).getTable().getColumnIterator();
 
 		boolean id1Found = false;
 		boolean id2Found = false;
 
 		while ( columns.hasNext() ) {
 			Column column = columns.next();
 			if ( "ID_1".equals( column.getName() ) ) {
 				id1Found = true;
 			}
 
 			if ( "ID_2".equals( column.getName() ) ) {
 				id2Found = true;
 			}
 		}
 
 		assert id1Found && id2Found;
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/VersionsJoinTableNaming.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/VersionsJoinTableNaming.java
index 895363ca1e..1a2b221f32 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/VersionsJoinTableNaming.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/VersionsJoinTableNaming.java
@@ -1,138 +1,138 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.naming;
 
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.Iterator;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.entities.StrTestEntity;
 import org.hibernate.envers.test.tools.TestTools;
 import org.hibernate.mapping.Column;
 
 import org.junit.Test;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class VersionsJoinTableNaming extends BaseEnversJPAFunctionalTestCase {
 	private Integer uni1_id;
 	private Integer str1_id;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {VersionsJoinTableTestEntity.class, StrTestEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		VersionsJoinTableTestEntity uni1 = new VersionsJoinTableTestEntity( 1, "data1" );
 		StrTestEntity str1 = new StrTestEntity( "str1" );
 
 		// Revision 1
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 
 		uni1.setCollection( new HashSet<StrTestEntity>() );
 		em.persist( uni1 );
 		em.persist( str1 );
 
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 
 		uni1 = em.find( VersionsJoinTableTestEntity.class, uni1.getId() );
 		str1 = em.find( StrTestEntity.class, str1.getId() );
 		uni1.getCollection().add( str1 );
 
 		em.getTransaction().commit();
 
 		//
 
 		uni1_id = uni1.getId();
 		str1_id = str1.getId();
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1, 2 ).equals(
 				getAuditReader().getRevisions(
 						VersionsJoinTableTestEntity.class,
 						uni1_id
 				)
 		);
 		assert Arrays.asList( 1 ).equals( getAuditReader().getRevisions( StrTestEntity.class, str1_id ) );
 	}
 
 	@Test
 	public void testHistoryOfUniId1() {
 		StrTestEntity str1 = getEntityManager().find( StrTestEntity.class, str1_id );
 
 		VersionsJoinTableTestEntity rev1 = getAuditReader().find( VersionsJoinTableTestEntity.class, uni1_id, 1 );
 		VersionsJoinTableTestEntity rev2 = getAuditReader().find( VersionsJoinTableTestEntity.class, uni1_id, 2 );
 
 		assert rev1.getCollection().equals( TestTools.makeSet() );
 		assert rev2.getCollection().equals( TestTools.makeSet( str1 ) );
 
 		assert "data1".equals( rev1.getData() );
 		assert "data1".equals( rev2.getData() );
 	}
 
 	private final static String MIDDLE_VERSIONS_ENTITY_NAME = "VERSIONS_JOIN_TABLE_TEST";
 
 	@Test
 	public void testTableName() {
 		assert MIDDLE_VERSIONS_ENTITY_NAME.equals(
-				getCfg().getClassMapping( MIDDLE_VERSIONS_ENTITY_NAME ).getTable().getName()
+				metadata().getEntityBinding( MIDDLE_VERSIONS_ENTITY_NAME ).getTable().getName()
 		);
 	}
 
 	@SuppressWarnings({"unchecked"})
 	@Test
 	public void testJoinColumnName() {
 		Iterator<Column> columns =
-				getCfg().getClassMapping( MIDDLE_VERSIONS_ENTITY_NAME ).getTable().getColumnIterator();
+				metadata().getEntityBinding( MIDDLE_VERSIONS_ENTITY_NAME ).getTable().getColumnIterator();
 
 		boolean id1Found = false;
 		boolean id2Found = false;
 
 		while ( columns.hasNext() ) {
 			Column column = columns.next();
 			if ( "VJT_ID".equals( column.getName() ) ) {
 				id1Found = true;
 			}
 
 			if ( "STR_ID".equals( column.getName() ) ) {
 				id2Found = true;
 			}
 		}
 
 		assert id1Found && id2Found;
 	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/VersionsJoinTableRangeComponentNamingTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/VersionsJoinTableRangeComponentNamingTest.java
index 440c397b35..37983e1f0b 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/VersionsJoinTableRangeComponentNamingTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/VersionsJoinTableRangeComponentNamingTest.java
@@ -1,326 +1,326 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.naming;
 
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.List;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.entities.components.Component1;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.PersistentClass;
 
 import org.junit.Test;
 
 /**
  * Test class for {@link VersionsJoinTableRangeComponentTestEntity}, to test
  * various {@link org.hibernate.envers.AuditOverride} annotations.
  *
  * @author Erik-Berndt Scheper
  */
 public class VersionsJoinTableRangeComponentNamingTest extends
 													   BaseEnversJPAFunctionalTestCase {
 	private Integer vjrcte_id;
 	private Integer vjtrte_id;
 	private Integer vjtrtae_id1;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {
 				VersionsJoinTableRangeComponentTestEntity.class,
 				VersionsJoinTableRangeTestEntitySuperClass.class,
 				VersionsJoinTableRangeTestEntity.class,
 				VersionsJoinTableRangeTestAlternateEntity.class
 		};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 
 		// Revision 1
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 
 		// create an instance of the test entity
 		VersionsJoinTableRangeComponentTestEntity vjrcte = new VersionsJoinTableRangeComponentTestEntity();
 		em.persist( vjrcte );
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 
 		vjrcte = em.find(
 				VersionsJoinTableRangeComponentTestEntity.class,
 				vjrcte.getId()
 		);
 
 		// create a component containing a list of
 		// VersionsJoinTableRangeTestEntity-instances
 		VersionsJoinTableRangeTestEntity vjtrte = new VersionsJoinTableRangeTestEntity();
 		vjtrte.setGenericValue( "generic1" );
 		vjtrte.setValue( "value1" );
 		// and add it to the test entity
 		vjrcte.getComponent1().getRange().add( vjtrte );
 
 		// create a second component containing a list of
 		// VersionsJoinTableRangeTestAlternateEntity-instances
 		VersionsJoinTableRangeTestAlternateEntity vjtrtae1 = new VersionsJoinTableRangeTestAlternateEntity();
 		vjtrtae1.setGenericValue( "generic2" );
 		vjtrtae1.setAlternateValue( "alternateValue2" );
 		// and add it to the test entity
 		vjrcte.getComponent2().getRange().add( vjtrtae1 );
 
 		// create a third component, and add it to the test entity
 		Component1 simpleComponent = new Component1( "string1", "string2" );
 		vjrcte.setComponent3( simpleComponent );
 
 		em.persist( vjtrte );
 		em.persist( vjtrtae1 );
 		em.persist( vjrcte );
 
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 
 		vjrcte = em.find(
 				VersionsJoinTableRangeComponentTestEntity.class,
 				vjrcte.getId()
 		);
 		vjtrte = em
 				.find( VersionsJoinTableRangeTestEntity.class, vjtrte.getId() );
 		vjtrtae1 = em.find(
 				VersionsJoinTableRangeTestAlternateEntity.class,
 				vjtrtae1.getId()
 		);
 
 		assert vjrcte != null;
 		assert vjtrte != null;
 		assert vjtrtae1 != null;
 
 		List<VersionsJoinTableRangeTestEntity> ent1List = vjrcte
 				.getComponent1().getRange();
 		assert ent1List.size() == 1;
 		assert vjtrte.equals( ent1List.get( 0 ) );
 
 		List<VersionsJoinTableRangeTestAlternateEntity> ent2List = vjrcte
 				.getComponent2().getRange();
 		assert ent2List.size() == 1;
 		assert vjtrtae1.equals( ent2List.get( 0 ) );
 
 		em.getTransaction().commit();
 
 		vjrcte_id = vjrcte.getId();
 		vjtrte_id = vjtrte.getId();
 		vjtrtae_id1 = vjtrtae1.getId();
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1, 2 ).equals(
 				getAuditReader().getRevisions(
 						VersionsJoinTableRangeComponentTestEntity.class,
 						vjrcte_id
 				)
 		);
 		assert Arrays.asList( 2 ).equals(
 				getAuditReader().getRevisions(
 						VersionsJoinTableRangeTestEntity.class, vjtrte_id
 				)
 		);
 		assert Arrays.asList( 2 ).equals(
 				getAuditReader().getRevisions(
 						VersionsJoinTableRangeTestAlternateEntity.class,
 						vjtrtae_id1
 				)
 		);
 	}
 
 	@Test
 	public void testHistoryOfUniId1() {
 		VersionsJoinTableRangeTestEntity vjtrte = getEntityManager().find(
 				VersionsJoinTableRangeTestEntity.class, vjtrte_id
 		);
 		VersionsJoinTableRangeTestAlternateEntity vjtrtae = getEntityManager()
 				.find(
 						VersionsJoinTableRangeTestAlternateEntity.class,
 						vjtrtae_id1
 				);
 
 		VersionsJoinTableRangeComponentTestEntity rev1 = getAuditReader().find(
 				VersionsJoinTableRangeComponentTestEntity.class, vjrcte_id, 1
 		);
 		VersionsJoinTableRangeComponentTestEntity rev2 = getAuditReader().find(
 				VersionsJoinTableRangeComponentTestEntity.class, vjrcte_id, 2
 		);
 
 		assert rev1.getComponent1().getRange().size() == 0;
 		assert rev1.getComponent2().getRange().size() == 0;
 
 		assert rev2.getComponent1().getRange().size() == 1;
 		assert rev2.getComponent1().getRange().get( 0 ).equals( vjtrte );
 		assert rev2.getComponent2().getRange().size() == 1;
 		assert rev2.getComponent2().getRange().get( 0 ).equals( vjtrtae );
 	}
 
 	/* The Audit join tables we expect */
 	private final static String COMPONENT_1_AUDIT_JOIN_TABLE_NAME = "JOIN_TABLE_COMPONENT_1_AUD";
 	private final static String COMPONENT_2_AUDIT_JOIN_TABLE_NAME = "JOIN_TABLE_COMPONENT_2_AUD";
 
 	/* The Audit join tables that should NOT be there */
 	private final static String UNMODIFIED_COMPONENT_1_AUDIT_JOIN_TABLE_NAME = "VersionsJoinTableRangeComponentTestEntity_VersionsJoinTableRangeTestEntity_AUD";
 	private final static String UNMODIFIED_COMPONENT_2_AUDIT_JOIN_TABLE_NAME = "VersionsJoinTableRangeComponentTestEntity_VersionsJoinTableRangeTestAlternateEntity_AUD";
 
 	@Test
 	public void testExpectedTableNameComponent1() {
-		PersistentClass auditClass = getCfg().getClassMapping(
+		PersistentClass auditClass = metadata().getEntityBinding(
 				COMPONENT_1_AUDIT_JOIN_TABLE_NAME
 		);
 		assert auditClass != null;
 		assert COMPONENT_1_AUDIT_JOIN_TABLE_NAME.equals(
 				auditClass.getTable()
 						.getName()
 		);
 	}
 
 	@Test
 	public void testExpectedTableNameComponent2() {
-		PersistentClass auditClass = getCfg().getClassMapping(
+		PersistentClass auditClass = metadata().getEntityBinding(
 				COMPONENT_2_AUDIT_JOIN_TABLE_NAME
 		);
 		assert auditClass != null;
 		assert COMPONENT_2_AUDIT_JOIN_TABLE_NAME.equals(
 				auditClass.getTable()
 						.getName()
 		);
 	}
 
 	@Test
 	public void testWrongTableNameComponent1() {
-		PersistentClass auditClass = getCfg().getClassMapping(
+		PersistentClass auditClass = metadata().getEntityBinding(
 				UNMODIFIED_COMPONENT_1_AUDIT_JOIN_TABLE_NAME
 		);
 		assert auditClass == null;
 	}
 
 	@Test
 	public void testWrongTableNameComponent2() {
-		PersistentClass auditClass = getCfg().getClassMapping(
+		PersistentClass auditClass = metadata().getEntityBinding(
 				UNMODIFIED_COMPONENT_2_AUDIT_JOIN_TABLE_NAME
 		);
 		assert auditClass == null;
 	}
 
 	@Test
 	public void testJoinColumnNamesComponent1() {
-		PersistentClass auditClass = getCfg().getClassMapping(
+		PersistentClass auditClass = metadata().getEntityBinding(
 				COMPONENT_1_AUDIT_JOIN_TABLE_NAME
 		);
 		assert auditClass != null;
 
 		@SuppressWarnings({"unchecked"})
 		Iterator<Column> columns = auditClass.getTable().getColumnIterator();
 
 		boolean id1Found = false;
 		boolean id2Found = false;
 
 		while ( columns.hasNext() ) {
 			Column column = columns.next();
 			if ( "VJTRCTE1_ID".equals( column.getName() ) ) {
 				id1Found = true;
 			}
 
 			if ( "VJTRTE_ID".equals( column.getName() ) ) {
 				id2Found = true;
 			}
 		}
 
 		assert id1Found && id2Found;
 	}
 
 	@Test
 	public void testJoinColumnNamesComponent2() {
-		PersistentClass auditClass = getCfg().getClassMapping(
+		PersistentClass auditClass = metadata().getEntityBinding(
 				COMPONENT_2_AUDIT_JOIN_TABLE_NAME
 		);
 		assert auditClass != null;
 
 		@SuppressWarnings({"unchecked"})
 		Iterator<Column> columns = auditClass.getTable().getColumnIterator();
 
 		boolean id1Found = false;
 		boolean id2Found = false;
 
 		while ( columns.hasNext() ) {
 			Column column = columns.next();
 			if ( "VJTRCTE2_ID".equals( column.getName() ) ) {
 				id1Found = true;
 			}
 
 			if ( "VJTRTAE_ID".equals( column.getName() ) ) {
 				id2Found = true;
 			}
 		}
 
 		assert id1Found && id2Found;
 	}
 
 	/**
 	 * Verify that
 	 * {@link VersionsJoinTableRangeComponentTestEntity#getComponent3()} is
 	 * partially audited.
 	 */
 	@Test
 	public void testOverrideNotAudited() {
-		PersistentClass auditClass = getCfg().getClassMapping(
+		PersistentClass auditClass = metadata().getEntityBinding(
 				VersionsJoinTableRangeComponentTestEntity.class.getName()
 						+ "_AUD"
 		);
 		assert auditClass != null;
 
 		@SuppressWarnings({"unchecked"})
 		Iterator<Column> columns = auditClass.getTable().getColumnIterator();
 
 		boolean auditColumn1Found = false;
 		boolean auditColumn2Found = false;
 
 		while ( columns.hasNext() ) {
 			Column column = columns.next();
 			if ( "STR1".equals( column.getName() ) ) {
 				auditColumn1Found = true;
 			}
 
 			if ( "STR2".equals( column.getName() ) ) {
 				auditColumn2Found = true;
 			}
 		}
 
 		assert auditColumn1Found && !auditColumn2Found;
 	}
 
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/ids/JoinEmbIdNaming.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/ids/JoinEmbIdNaming.java
index 3412b3a47d..de94c9ffe2 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/ids/JoinEmbIdNaming.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/ids/JoinEmbIdNaming.java
@@ -1,162 +1,160 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.naming.ids;
 
 import java.util.Arrays;
 import java.util.Iterator;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.mapping.Column;
 
 import org.junit.Test;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class JoinEmbIdNaming extends BaseEnversJPAFunctionalTestCase {
 	private EmbIdNaming ed_id1;
 	private EmbIdNaming ed_id2;
 	private EmbIdNaming ing_id1;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {JoinEmbIdNamingRefEdEntity.class, JoinEmbIdNamingRefIngEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		ed_id1 = new EmbIdNaming( 10, 20 );
 		ed_id2 = new EmbIdNaming( 11, 21 );
 		ing_id1 = new EmbIdNaming( 12, 22 );
 
 		JoinEmbIdNamingRefEdEntity ed1 = new JoinEmbIdNamingRefEdEntity( ed_id1, "data1" );
 		JoinEmbIdNamingRefEdEntity ed2 = new JoinEmbIdNamingRefEdEntity( ed_id2, "data2" );
 
 		JoinEmbIdNamingRefIngEntity ing1 = new JoinEmbIdNamingRefIngEntity( ing_id1, "x", ed1 );
 
 		// Revision 1
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 
 		em.persist( ed1 );
 		em.persist( ed2 );
 		em.persist( ing1 );
 
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 
 		ed2 = em.find( JoinEmbIdNamingRefEdEntity.class, ed2.getId() );
 
 		ing1 = em.find( JoinEmbIdNamingRefIngEntity.class, ing1.getId() );
 		ing1.setData( "y" );
 		ing1.setReference( ed2 );
 
 		em.getTransaction().commit();
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1, 2 ).equals(
 				getAuditReader().getRevisions(
 						JoinEmbIdNamingRefEdEntity.class,
 						ed_id1
 				)
 		);
 		assert Arrays.asList( 1, 2 ).equals(
 				getAuditReader().getRevisions(
 						JoinEmbIdNamingRefEdEntity.class,
 						ed_id2
 				)
 		);
 		assert Arrays.asList( 1, 2 ).equals(
 				getAuditReader().getRevisions(
 						JoinEmbIdNamingRefIngEntity.class,
 						ing_id1
 				)
 		);
 	}
 
 	@Test
 	public void testHistoryOfEdId1() {
 		JoinEmbIdNamingRefEdEntity ver1 = new JoinEmbIdNamingRefEdEntity( ed_id1, "data1" );
 
 		assert getAuditReader().find( JoinEmbIdNamingRefEdEntity.class, ed_id1, 1 ).equals( ver1 );
 		assert getAuditReader().find( JoinEmbIdNamingRefEdEntity.class, ed_id1, 2 ).equals( ver1 );
 	}
 
 	@Test
 	public void testHistoryOfEdId2() {
 		JoinEmbIdNamingRefEdEntity ver1 = new JoinEmbIdNamingRefEdEntity( ed_id2, "data2" );
 
 		assert getAuditReader().find( JoinEmbIdNamingRefEdEntity.class, ed_id2, 1 ).equals( ver1 );
 		assert getAuditReader().find( JoinEmbIdNamingRefEdEntity.class, ed_id2, 2 ).equals( ver1 );
 	}
 
 	@Test
 	public void testHistoryOfIngId1() {
 		JoinEmbIdNamingRefIngEntity ver1 = new JoinEmbIdNamingRefIngEntity( ing_id1, "x", null );
 		JoinEmbIdNamingRefIngEntity ver2 = new JoinEmbIdNamingRefIngEntity( ing_id1, "y", null );
 
 		assert getAuditReader().find( JoinEmbIdNamingRefIngEntity.class, ing_id1, 1 ).equals( ver1 );
 		assert getAuditReader().find( JoinEmbIdNamingRefIngEntity.class, ing_id1, 2 ).equals( ver2 );
 
 		assert getAuditReader().find( JoinEmbIdNamingRefIngEntity.class, ing_id1, 1 ).getReference().equals(
 				new JoinEmbIdNamingRefEdEntity( ed_id1, "data1" )
 		);
 		assert getAuditReader().find( JoinEmbIdNamingRefIngEntity.class, ing_id1, 2 ).getReference().equals(
 				new JoinEmbIdNamingRefEdEntity( ed_id2, "data2" )
 		);
 	}
 
 	@SuppressWarnings({"unchecked"})
 	@Test
 	public void testJoinColumnNames() {
-		Iterator<Column> columns =
-				getCfg().getClassMapping(
-						"org.hibernate.envers.test.integration.naming.ids.JoinEmbIdNamingRefIngEntity_AUD"
-				)
-						.getProperty( "reference_x" ).getColumnIterator();
+		Iterator<Column> columns = metadata().getEntityBinding(
+				"org.hibernate.envers.test.integration.naming.ids.JoinEmbIdNamingRefIngEntity_AUD"
+		).getProperty( "reference_x" ).getColumnIterator();
+
 		assertTrue( columns.hasNext() );
 		assertEquals( "XX_reference", columns.next().getName() );
 		assertFalse( columns.hasNext() );
 
-		columns = getCfg().getClassMapping(
+		columns = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.naming.ids.JoinEmbIdNamingRefIngEntity_AUD"
-		)
-				.getProperty( "reference_y" ).getColumnIterator();
+		).getProperty( "reference_y" ).getColumnIterator();
 
 		assertTrue( columns.hasNext() );
 		assertEquals( "YY_reference", columns.next().getName() );
 		assertFalse( columns.hasNext() );
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/ids/JoinMulIdNaming.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/ids/JoinMulIdNaming.java
index baac1f080f..896f1a1b64 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/ids/JoinMulIdNaming.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/ids/JoinMulIdNaming.java
@@ -1,161 +1,160 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.naming.ids;
 
 import java.util.Arrays;
 import java.util.Iterator;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.mapping.Column;
 
 import org.junit.Test;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class JoinMulIdNaming extends BaseEnversJPAFunctionalTestCase {
 	private MulIdNaming ed_id1;
 	private MulIdNaming ed_id2;
 	private MulIdNaming ing_id1;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {JoinMulIdNamingRefEdEntity.class, JoinMulIdNamingRefIngEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		ed_id1 = new MulIdNaming( 10, 20 );
 		ed_id2 = new MulIdNaming( 11, 21 );
 		ing_id1 = new MulIdNaming( 12, 22 );
 
 		JoinMulIdNamingRefEdEntity ed1 = new JoinMulIdNamingRefEdEntity( ed_id1, "data1" );
 		JoinMulIdNamingRefEdEntity ed2 = new JoinMulIdNamingRefEdEntity( ed_id2, "data2" );
 
 		JoinMulIdNamingRefIngEntity ing1 = new JoinMulIdNamingRefIngEntity( ing_id1, "x", ed1 );
 
 		// Revision 1
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 
 		em.persist( ed1 );
 		em.persist( ed2 );
 		em.persist( ing1 );
 
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 
 		ed2 = em.find( JoinMulIdNamingRefEdEntity.class, ed_id2 );
 
 		ing1 = em.find( JoinMulIdNamingRefIngEntity.class, ing_id1 );
 		ing1.setData( "y" );
 		ing1.setReference( ed2 );
 
 		em.getTransaction().commit();
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1, 2 ).equals(
 				getAuditReader().getRevisions(
 						JoinMulIdNamingRefEdEntity.class,
 						ed_id1
 				)
 		);
 		assert Arrays.asList( 1, 2 ).equals(
 				getAuditReader().getRevisions(
 						JoinMulIdNamingRefEdEntity.class,
 						ed_id2
 				)
 		);
 		assert Arrays.asList( 1, 2 ).equals(
 				getAuditReader().getRevisions(
 						JoinMulIdNamingRefIngEntity.class,
 						ing_id1
 				)
 		);
 	}
 
 	@Test
 	public void testHistoryOfEdId1() {
 		JoinMulIdNamingRefEdEntity ver1 = new JoinMulIdNamingRefEdEntity( ed_id1, "data1" );
 
 		assert getAuditReader().find( JoinMulIdNamingRefEdEntity.class, ed_id1, 1 ).equals( ver1 );
 		assert getAuditReader().find( JoinMulIdNamingRefEdEntity.class, ed_id1, 2 ).equals( ver1 );
 	}
 
 	@Test
 	public void testHistoryOfEdId2() {
 		JoinMulIdNamingRefEdEntity ver1 = new JoinMulIdNamingRefEdEntity( ed_id2, "data2" );
 
 		assert getAuditReader().find( JoinMulIdNamingRefEdEntity.class, ed_id2, 1 ).equals( ver1 );
 		assert getAuditReader().find( JoinMulIdNamingRefEdEntity.class, ed_id2, 2 ).equals( ver1 );
 	}
 
 	@Test
 	public void testHistoryOfIngId1() {
 		JoinMulIdNamingRefIngEntity ver1 = new JoinMulIdNamingRefIngEntity( ing_id1, "x", null );
 		JoinMulIdNamingRefIngEntity ver2 = new JoinMulIdNamingRefIngEntity( ing_id1, "y", null );
 
 		assert getAuditReader().find( JoinMulIdNamingRefIngEntity.class, ing_id1, 1 ).equals( ver1 );
 		assert getAuditReader().find( JoinMulIdNamingRefIngEntity.class, ing_id1, 2 ).equals( ver2 );
 
 		assert getAuditReader().find( JoinMulIdNamingRefIngEntity.class, ing_id1, 1 ).getReference().equals(
 				new JoinMulIdNamingRefEdEntity( ed_id1, "data1" )
 		);
 		assert getAuditReader().find( JoinMulIdNamingRefIngEntity.class, ing_id1, 2 ).getReference().equals(
 				new JoinMulIdNamingRefEdEntity( ed_id2, "data2" )
 		);
 	}
 
 	@SuppressWarnings({"unchecked"})
 	@Test
 	public void testJoinColumnNames() {
-		Iterator<Column> columns =
-				getCfg().getClassMapping(
-						"org.hibernate.envers.test.integration.naming.ids.JoinMulIdNamingRefIngEntity_AUD"
-				)
-						.getProperty( "reference_id1" ).getColumnIterator();
+		Iterator<Column> columns = metadata().getEntityBinding(
+				"org.hibernate.envers.test.integration.naming.ids.JoinMulIdNamingRefIngEntity_AUD"
+		).getProperty( "reference_id1" ).getColumnIterator();
+
 		assertTrue( columns.hasNext() );
 		assertEquals( "ID1_reference", columns.next().getName() );
 		assertFalse( columns.hasNext() );
 
-		columns = getCfg().getClassMapping(
+		columns = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.naming.ids.JoinMulIdNamingRefIngEntity_AUD"
-		)
-				.getProperty( "reference_id2" ).getColumnIterator();
+		).getProperty( "reference_id2" ).getColumnIterator();
+
 		assertTrue( columns.hasNext() );
 		assertEquals( "ID2_reference", columns.next().getName() );
 		assertFalse( columns.hasNext() );
 	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/quotation/QuotedFieldsTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/quotation/QuotedFieldsTest.java
index e8fa18936a..a9ea38d245 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/quotation/QuotedFieldsTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/naming/quotation/QuotedFieldsTest.java
@@ -1,107 +1,107 @@
 package org.hibernate.envers.test.integration.naming.quotation;
 
 import java.util.Arrays;
 import java.util.Iterator;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Table;
 
 import org.junit.Test;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class QuotedFieldsTest extends BaseEnversJPAFunctionalTestCase {
 	private Long qfeId1 = null;
 	private Long qfeId2 = null;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {QuotedFieldsEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		QuotedFieldsEntity qfe1 = new QuotedFieldsEntity( "data1", 1 );
 		QuotedFieldsEntity qfe2 = new QuotedFieldsEntity( "data2", 2 );
 
 		// Revision 1
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 		em.persist( qfe1 );
 		em.persist( qfe2 );
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 		qfe1 = em.find( QuotedFieldsEntity.class, qfe1.getId() );
 		qfe1.setData1( "data1 changed" );
 		em.getTransaction().commit();
 
 		// Revision 3
 		em.getTransaction().begin();
 		qfe2 = em.find( QuotedFieldsEntity.class, qfe2.getId() );
 		qfe2.setData2( 3 );
 		em.getTransaction().commit();
 
 		qfeId1 = qfe1.getId();
 		qfeId2 = qfe2.getId();
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1, 2 ).equals( getAuditReader().getRevisions( QuotedFieldsEntity.class, qfeId1 ) );
 		assert Arrays.asList( 1, 3 ).equals( getAuditReader().getRevisions( QuotedFieldsEntity.class, qfeId2 ) );
 	}
 
 	@Test
 	public void testHistoryOfId1() {
 		QuotedFieldsEntity ver1 = new QuotedFieldsEntity( qfeId1, "data1", 1 );
 		QuotedFieldsEntity ver2 = new QuotedFieldsEntity( qfeId1, "data1 changed", 1 );
 
 		assert getAuditReader().find( QuotedFieldsEntity.class, qfeId1, 1 ).equals( ver1 );
 		assert getAuditReader().find( QuotedFieldsEntity.class, qfeId1, 2 ).equals( ver2 );
 		assert getAuditReader().find( QuotedFieldsEntity.class, qfeId1, 3 ).equals( ver2 );
 	}
 
 	@Test
 	public void testHistoryOfId2() {
 		QuotedFieldsEntity ver1 = new QuotedFieldsEntity( qfeId2, "data2", 2 );
 		QuotedFieldsEntity ver2 = new QuotedFieldsEntity( qfeId2, "data2", 3 );
 
 		assert getAuditReader().find( QuotedFieldsEntity.class, qfeId2, 1 ).equals( ver1 );
 		assert getAuditReader().find( QuotedFieldsEntity.class, qfeId2, 2 ).equals( ver1 );
 		assert getAuditReader().find( QuotedFieldsEntity.class, qfeId2, 3 ).equals( ver2 );
 	}
 
 	@Test
 	public void testEscapeEntityField() {
-		Table table = getCfg().getClassMapping(
+		Table table = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.naming.quotation.QuotedFieldsEntity_AUD"
 		).getTable();
 		Column column1 = getColumnByName( table, "id" );
 		Column column2 = getColumnByName( table, "data1" );
 		Column column3 = getColumnByName( table, "data2" );
 		assert column1 != null;
 		assert column2 != null;
 		assert column3 != null;
 		assert column1.isQuoted();
 		assert column2.isQuoted();
 		assert column3.isQuoted();
 	}
 
 	private Column getColumnByName(Table table, String columnName) {
 		Iterator<Column> columnIterator = table.getColumnIterator();
 		while ( columnIterator.hasNext() ) {
 			Column column = columnIterator.next();
 			if ( columnName.equals( column.getName() ) ) {
 				return column;
 			}
 		}
 		return null;
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/properties/UnversionedOptimisticLockingField.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/properties/UnversionedOptimisticLockingField.java
index 00f9ac30f6..fed22f9c97 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/properties/UnversionedOptimisticLockingField.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/properties/UnversionedOptimisticLockingField.java
@@ -1,102 +1,102 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.properties;
 
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.Map;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.configuration.EnversSettings;
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 
 import org.junit.Test;
 
 /**
  * @author Nicolas Doroskevich
  */
 public class UnversionedOptimisticLockingField extends BaseEnversJPAFunctionalTestCase {
 	private Integer id1;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {UnversionedOptimisticLockingFieldEntity.class};
 	}
 
 	@Override
 	public void addConfigOptions(Map configuration) {
 		super.addConfigOptions( configuration );
 		configuration.put( EnversSettings.DO_NOT_AUDIT_OPTIMISTIC_LOCKING_FIELD, "true" );
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 		UnversionedOptimisticLockingFieldEntity olfe = new UnversionedOptimisticLockingFieldEntity( "x" );
 		em.persist( olfe );
 		id1 = olfe.getId();
 		em.getTransaction().commit();
 
 		em.getTransaction().begin();
 		olfe = em.find( UnversionedOptimisticLockingFieldEntity.class, id1 );
 		olfe.setStr( "y" );
 		em.getTransaction().commit();
 	}
 
 	@Test
 	public void testRevisionCounts() {
 		assert Arrays.asList( 1, 2 ).equals(
 				getAuditReader().getRevisions(
 						UnversionedOptimisticLockingFieldEntity.class,
 						id1
 				)
 		);
 	}
 
 	@Test
 	public void testHistoryOfId1() {
 		UnversionedOptimisticLockingFieldEntity ver1 = new UnversionedOptimisticLockingFieldEntity( id1, "x" );
 		UnversionedOptimisticLockingFieldEntity ver2 = new UnversionedOptimisticLockingFieldEntity( id1, "y" );
 
 		assert getAuditReader().find( UnversionedOptimisticLockingFieldEntity.class, id1, 1 )
 				.equals( ver1 );
 		assert getAuditReader().find( UnversionedOptimisticLockingFieldEntity.class, id1, 2 )
 				.equals( ver2 );
 	}
 
 	@Test
 	public void testMapping() {
-		PersistentClass pc = getCfg().getClassMapping( UnversionedOptimisticLockingFieldEntity.class.getName() + "_AUD" );
+		PersistentClass pc = metadata().getEntityBinding( UnversionedOptimisticLockingFieldEntity.class.getName() + "_AUD" );
 		Iterator pi = pc.getPropertyIterator();
 		while ( pi.hasNext() ) {
 			Property p = (Property) pi.next();
 			assert !"optLocking".equals( p.getName() );
 		}
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/DifferentDBSchemaTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/DifferentDBSchemaTest.java
index 9f6c6ae1cd..3baf1ae123 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/DifferentDBSchemaTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/DifferentDBSchemaTest.java
@@ -1,85 +1,85 @@
 package org.hibernate.envers.test.integration.reventity;
 
 import java.util.Arrays;
 import java.util.Map;
 import javax.persistence.EntityManager;
 
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.envers.configuration.EnversSettings;
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.entities.StrTestEntity;
 import org.hibernate.mapping.Table;
 
 import org.hibernate.testing.RequiresDialect;
 import org.junit.Test;
 
 /**
  * Tests simple auditing process (read and write operations) when <i>REVINFO</i> and audit tables
  * exist in a different database schema.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 @RequiresDialect({H2Dialect.class})
 public class DifferentDBSchemaTest extends BaseEnversJPAFunctionalTestCase {
 	private static final String SCHEMA_NAME = "ENVERS_AUDIT";
 	private Integer steId = null;
 
 	@Override
 	protected void addConfigOptions(Map options) {
 		super.addConfigOptions( options );
 		// Creates new schema after establishing connection
 		options.putAll( Environment.getProperties() );
 		options.put( EnversSettings.DEFAULT_SCHEMA, SCHEMA_NAME );
 	}
 
 	@Override
 	protected String createSecondSchema() {
 		return SCHEMA_NAME;
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {StrTestEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() throws InterruptedException {
 		// Revision 1
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 		StrTestEntity ste = new StrTestEntity( "x" );
 		em.persist( ste );
 		steId = ste.getId();
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 		ste = em.find( StrTestEntity.class, steId );
 		ste.setStr( "y" );
 		em.getTransaction().commit();
 	}
 
 	@Test
 	public void testRevinfoSchemaName() {
-		Table revisionTable = getCfg().getClassMapping( "org.hibernate.envers.enhanced.SequenceIdRevisionEntity" )
+		Table revisionTable = metadata().getEntityBinding( "org.hibernate.envers.enhanced.SequenceIdRevisionEntity" )
 				.getTable();
 		assert SCHEMA_NAME.equals( revisionTable.getSchema() );
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1, 2 ).equals( getAuditReader().getRevisions( StrTestEntity.class, steId ) );
 	}
 
 	@Test
 	public void testHistoryOfId1() {
 		StrTestEntity ver1 = new StrTestEntity( "x", steId );
 		StrTestEntity ver2 = new StrTestEntity( "y", steId );
 
 		assert getAuditReader().find( StrTestEntity.class, steId, 1 ).equals( ver1 );
 		assert getAuditReader().find( StrTestEntity.class, steId, 2 ).equals( ver2 );
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/LongRevEntityInheritanceChildAuditing.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/LongRevEntityInheritanceChildAuditing.java
index c73030cd11..18b3652d04 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/LongRevEntityInheritanceChildAuditing.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/LongRevEntityInheritanceChildAuditing.java
@@ -1,62 +1,62 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
 package org.hibernate.envers.test.integration.reventity;
 
 import java.util.Iterator;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.integration.inheritance.joined.ChildEntity;
 import org.hibernate.envers.test.integration.inheritance.joined.ParentEntity;
 import org.hibernate.mapping.Column;
 
 import org.junit.Test;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * A join-inheritance test using a custom revision entity where the revision number is a long, mapped in the database
  * as an int.
  *
  * @author Adam Warski (adam at warski dot org)
  */
 public class LongRevEntityInheritanceChildAuditing extends BaseEnversJPAFunctionalTestCase {
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {ChildEntity.class, ParentEntity.class, LongRevNumberRevEntity.class};
 	}
 
 	@Test
 	public void testChildRevColumnType() {
 		// We need the second column
-		Iterator childEntityKeyColumnsIterator = getCfg()
-				.getClassMapping( "org.hibernate.envers.test.integration.inheritance.joined.ChildEntity_AUD" )
+		Iterator childEntityKeyColumnsIterator = metadata()
+				.getEntityBinding("org.hibernate.envers.test.integration.inheritance.joined.ChildEntity_AUD" )
 				.getKey()
 				.getColumnIterator();
 		childEntityKeyColumnsIterator.next();
 		Column second = (Column) childEntityKeyColumnsIterator.next();
 
 		assertEquals( second.getSqlType(), "int" );
 	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/trackmodifiedentities/DefaultTrackingEntitiesTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/trackmodifiedentities/DefaultTrackingEntitiesTest.java
index 140c4ca473..39f87e299d 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/trackmodifiedentities/DefaultTrackingEntitiesTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/trackmodifiedentities/DefaultTrackingEntitiesTest.java
@@ -1,204 +1,202 @@
 package org.hibernate.envers.test.integration.reventity.trackmodifiedentities;
 
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.CrossTypeRevisionChangesReader;
 import org.hibernate.envers.RevisionType;
 import org.hibernate.envers.configuration.EnversSettings;
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.entities.StrIntTestEntity;
 import org.hibernate.envers.test.entities.StrTestEntity;
 import org.hibernate.envers.test.tools.TestTools;
 import org.hibernate.envers.tools.Pair;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Table;
 
 import org.junit.Test;
 
 /**
  * Tests proper behavior of tracking modified entity names when {@code org.hibernate.envers.track_entities_changed_in_revision}
  * parameter is set to {@code true}.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 @SuppressWarnings({"unchecked"})
 public class DefaultTrackingEntitiesTest extends BaseEnversJPAFunctionalTestCase {
 	private Integer steId = null;
 	private Integer siteId = null;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {StrTestEntity.class, StrIntTestEntity.class};
 	}
 
 	@Override
 	public void addConfigOptions(Map configuration) {
 		super.addConfigOptions( configuration );
 		configuration.put( EnversSettings.TRACK_ENTITIES_CHANGED_IN_REVISION, "true" );
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		EntityManager em = getEntityManager();
 
 		// Revision 1 - Adding two entities
 		em.getTransaction().begin();
 		StrTestEntity ste = new StrTestEntity( "x" );
 		StrIntTestEntity site = new StrIntTestEntity( "y", 1 );
 		em.persist( ste );
 		em.persist( site );
 		steId = ste.getId();
 		siteId = site.getId();
 		em.getTransaction().commit();
 
 		// Revision 2 - Modifying one entity
 		em.getTransaction().begin();
 		site = em.find( StrIntTestEntity.class, siteId );
 		site.setNumber( 2 );
 		em.getTransaction().commit();
 
 		// Revision 3 - Deleting both entities
 		em.getTransaction().begin();
 		ste = em.find( StrTestEntity.class, steId );
 		site = em.find( StrIntTestEntity.class, siteId );
 		em.remove( ste );
 		em.remove( site );
 		em.getTransaction().commit();
 	}
 
 	@Test
 	public void testRevEntityTableCreation() {
-		Iterator<Table> tableIterator = getCfg().getTableMappings();
-		while ( tableIterator.hasNext() ) {
-			Table table = tableIterator.next();
+		for ( Table table : metadata().collectTableMappings() ) {
 			if ( "REVCHANGES".equals( table.getName() ) ) {
 				assert table.getColumnSpan() == 2;
 				assert table.getColumn( new Column( "REV" ) ) != null;
 				assert table.getColumn( new Column( "ENTITYNAME" ) ) != null;
 				return;
 			}
 		}
 		assert false;
 	}
 
 	@Test
 	public void testTrackAddedEntities() {
 		StrTestEntity ste = new StrTestEntity( "x", steId );
 		StrIntTestEntity site = new StrIntTestEntity( "y", 1, siteId );
 
 		assert TestTools.checkCollection( getCrossTypeRevisionChangesReader().findEntities( 1 ), ste, site );
 	}
 
 	@Test
 	public void testTrackModifiedEntities() {
 		StrIntTestEntity site = new StrIntTestEntity( "y", 2, siteId );
 
 		assert TestTools.checkCollection( getCrossTypeRevisionChangesReader().findEntities( 2 ), site );
 	}
 
 	@Test
 	public void testTrackDeletedEntities() {
 		StrTestEntity ste = new StrTestEntity( null, steId );
 		StrIntTestEntity site = new StrIntTestEntity( null, null, siteId );
 
 		assert TestTools.checkCollection( getCrossTypeRevisionChangesReader().findEntities( 3 ), site, ste );
 	}
 
 	@Test
 	public void testFindChangesInInvalidRevision() {
 		assert getCrossTypeRevisionChangesReader().findEntities( 4 ).isEmpty();
 	}
 
 	@Test
 	public void testTrackAddedEntitiesGroupByRevisionType() {
 		StrTestEntity ste = new StrTestEntity( "x", steId );
 		StrIntTestEntity site = new StrIntTestEntity( "y", 1, siteId );
 
 		Map<RevisionType, List<Object>> result = getCrossTypeRevisionChangesReader().findEntitiesGroupByRevisionType( 1 );
 		assert TestTools.checkCollection( result.get( RevisionType.ADD ), site, ste );
 		assert TestTools.checkCollection( result.get( RevisionType.MOD ) );
 		assert TestTools.checkCollection( result.get( RevisionType.DEL ) );
 	}
 
 	@Test
 	public void testTrackModifiedEntitiesGroupByRevisionType() {
 		StrIntTestEntity site = new StrIntTestEntity( "y", 2, siteId );
 
 		Map<RevisionType, List<Object>> result = getCrossTypeRevisionChangesReader().findEntitiesGroupByRevisionType( 2 );
 		assert TestTools.checkCollection( result.get( RevisionType.ADD ) );
 		assert TestTools.checkCollection( result.get( RevisionType.MOD ), site );
 		assert TestTools.checkCollection( result.get( RevisionType.DEL ) );
 	}
 
 	@Test
 	public void testTrackDeletedEntitiesGroupByRevisionType() {
 		StrTestEntity ste = new StrTestEntity( null, steId );
 		StrIntTestEntity site = new StrIntTestEntity( null, null, siteId );
 
 		Map<RevisionType, List<Object>> result = getCrossTypeRevisionChangesReader().findEntitiesGroupByRevisionType( 3 );
 		assert TestTools.checkCollection( result.get( RevisionType.ADD ) );
 		assert TestTools.checkCollection( result.get( RevisionType.MOD ) );
 		assert TestTools.checkCollection( result.get( RevisionType.DEL ), site, ste );
 	}
 
 	@Test
 	public void testFindChangedEntitiesByRevisionTypeADD() {
 		StrTestEntity ste = new StrTestEntity( "x", steId );
 		StrIntTestEntity site = new StrIntTestEntity( "y", 1, siteId );
 
 		assert TestTools.checkCollection(
 				getCrossTypeRevisionChangesReader().findEntities( 1, RevisionType.ADD ),
 				ste,
 				site
 		);
 	}
 
 	@Test
 	public void testFindChangedEntitiesByRevisionTypeMOD() {
 		StrIntTestEntity site = new StrIntTestEntity( "y", 2, siteId );
 
 		assert TestTools.checkCollection(
 				getCrossTypeRevisionChangesReader().findEntities( 2, RevisionType.MOD ),
 				site
 		);
 	}
 
 	@Test
 	public void testFindChangedEntitiesByRevisionTypeDEL() {
 		StrTestEntity ste = new StrTestEntity( null, steId );
 		StrIntTestEntity site = new StrIntTestEntity( null, null, siteId );
 
 		assert TestTools.checkCollection(
 				getCrossTypeRevisionChangesReader().findEntities( 3, RevisionType.DEL ),
 				ste,
 				site
 		);
 	}
 
 	@Test
 	public void testFindEntityTypesChangedInRevision() {
 		assert TestTools.makeSet(
 				Pair.make( StrTestEntity.class.getName(), StrTestEntity.class ),
 				Pair.make( StrIntTestEntity.class.getName(), StrIntTestEntity.class )
 		)
 				.equals( getCrossTypeRevisionChangesReader().findEntityTypes( 1 ) );
 
 		assert TestTools.makeSet( Pair.make( StrIntTestEntity.class.getName(), StrIntTestEntity.class ) )
 				.equals( getCrossTypeRevisionChangesReader().findEntityTypes( 2 ) );
 
 		assert TestTools.makeSet(
 				Pair.make( StrTestEntity.class.getName(), StrTestEntity.class ),
 				Pair.make( StrIntTestEntity.class.getName(), StrIntTestEntity.class )
 		)
 				.equals( getCrossTypeRevisionChangesReader().findEntityTypes( 3 ) );
 	}
 
 	private CrossTypeRevisionChangesReader getCrossTypeRevisionChangesReader() {
 		return getAuditReader().getCrossTypeRevisionChangesReader();
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/trackmodifiedentities/EntityNamesTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/trackmodifiedentities/EntityNamesTest.java
index 703fe1b19f..f2d5534b85 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/trackmodifiedentities/EntityNamesTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/reventity/trackmodifiedentities/EntityNamesTest.java
@@ -1,79 +1,81 @@
 package org.hibernate.envers.test.integration.reventity.trackmodifiedentities;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Map;
 
-import org.hibernate.cfg.Configuration;
 import org.hibernate.envers.configuration.EnversSettings;
 import org.hibernate.envers.test.BaseEnversFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.integration.entityNames.manyToManyAudited.Car;
 import org.hibernate.envers.test.integration.entityNames.manyToManyAudited.Person;
 import org.hibernate.envers.test.tools.TestTools;
 import org.hibernate.envers.tools.Pair;
 
 import org.junit.Test;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class EntityNamesTest extends BaseEnversFunctionalTestCase {
 	@Override
 	protected String[] getMappings() {
 		return new String[] {"mappings/entityNames/manyToManyAudited/mappings.hbm.xml"};
 	}
 
 	@Override
-	protected void configure(Configuration configuration) {
-		configuration.setProperty( EnversSettings.TRACK_ENTITIES_CHANGED_IN_REVISION, "true" );
+	protected void addSettings(Map settings) {
+		super.addSettings( settings );
+
+		settings.put( EnversSettings.TRACK_ENTITIES_CHANGED_IN_REVISION, "true" );
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		Person pers1 = new Person( "Hernan", 28 );
 		Person pers2 = new Person( "Leandro", 29 );
 		Person pers3 = new Person( "Barba", 32 );
 		Person pers4 = new Person( "Camomo", 15 );
 
 		// Revision 1
 		getSession().getTransaction().begin();
 		List<Person> owners = new ArrayList<Person>();
 		owners.add( pers1 );
 		owners.add( pers2 );
 		owners.add( pers3 );
 		Car car1 = new Car( 5, owners );
 		getSession().persist( car1 );
 		getSession().getTransaction().commit();
 		long person1Id = pers1.getId();
 
 		// Revision 2
 		owners = new ArrayList<Person>();
 		owners.add( pers2 );
 		owners.add( pers3 );
 		owners.add( pers4 );
 		Car car2 = new Car( 27, owners );
 		getSession().getTransaction().begin();
 		Person person1 = (Person) getSession().get( "Personaje", person1Id );
 		person1.setName( "Hernan David" );
 		person1.setAge( 40 );
 		getSession().persist( car1 );
 		getSession().persist( car2 );
 		getSession().getTransaction().commit();
 	}
 
 	@Test
 	@SuppressWarnings("unchecked")
 	public void testModifiedEntityTypes() {
 		assert TestTools.makeSet(
 				Pair.make( Car.class.getName(), Car.class ),
 				Pair.make( "Personaje", Person.class )
 		)
 				.equals( getAuditReader().getCrossTypeRevisionChangesReader().findEntityTypes( 1 ) );
 		assert TestTools.makeSet(
 				Pair.make( Car.class.getName(), Car.class ),
 				Pair.make( "Personaje", Person.class )
 		)
 				.equals( getAuditReader().getCrossTypeRevisionChangesReader().findEntityTypes( 2 ) );
 	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/BasicSecondary.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/BasicSecondary.java
index 4df793b295..723eb041f9 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/BasicSecondary.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/BasicSecondary.java
@@ -1,100 +1,100 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.secondary;
 
 import java.util.Arrays;
 import java.util.Iterator;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.mapping.Join;
 
 import org.junit.Test;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class BasicSecondary extends BaseEnversJPAFunctionalTestCase {
 	private Integer id;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {SecondaryTestEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		SecondaryTestEntity ste = new SecondaryTestEntity( "a", "1" );
 
 		// Revision 1
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 
 		em.persist( ste );
 
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 
 		ste = em.find( SecondaryTestEntity.class, ste.getId() );
 		ste.setS1( "b" );
 		ste.setS2( "2" );
 
 		em.getTransaction().commit();
 
 		//
 
 		id = ste.getId();
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1, 2 ).equals( getAuditReader().getRevisions( SecondaryTestEntity.class, id ) );
 	}
 
 	@Test
 	public void testHistoryOfId() {
 		SecondaryTestEntity ver1 = new SecondaryTestEntity( id, "a", "1" );
 		SecondaryTestEntity ver2 = new SecondaryTestEntity( id, "b", "2" );
 
 		assert getAuditReader().find( SecondaryTestEntity.class, id, 1 ).equals( ver1 );
 		assert getAuditReader().find( SecondaryTestEntity.class, id, 2 ).equals( ver2 );
 	}
 
 	@SuppressWarnings({"unchecked"})
 	@Test
 	public void testTableNames() {
 		assert "secondary_AUD".equals(
 				((Iterator<Join>)
-						getCfg().getClassMapping(
+						metadata().getEntityBinding(
 								"org.hibernate.envers.test.integration.secondary.SecondaryTestEntity_AUD"
 						)
 								.getJoinIterator())
 						.next().getTable().getName()
 		);
 	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/NamingSecondary.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/NamingSecondary.java
index e6db9bf15e..48623b8043 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/NamingSecondary.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/NamingSecondary.java
@@ -1,100 +1,100 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.secondary;
 
 import java.util.Arrays;
 import java.util.Iterator;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.mapping.Join;
 
 import org.junit.Test;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class NamingSecondary extends BaseEnversJPAFunctionalTestCase {
 	private Integer id;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {SecondaryNamingTestEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		SecondaryNamingTestEntity ste = new SecondaryNamingTestEntity( "a", "1" );
 
 		// Revision 1
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 
 		em.persist( ste );
 
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 
 		ste = em.find( SecondaryNamingTestEntity.class, ste.getId() );
 		ste.setS1( "b" );
 		ste.setS2( "2" );
 
 		em.getTransaction().commit();
 
 		//
 
 		id = ste.getId();
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1, 2 ).equals( getAuditReader().getRevisions( SecondaryNamingTestEntity.class, id ) );
 	}
 
 	@Test
 	public void testHistoryOfId() {
 		SecondaryNamingTestEntity ver1 = new SecondaryNamingTestEntity( id, "a", "1" );
 		SecondaryNamingTestEntity ver2 = new SecondaryNamingTestEntity( id, "b", "2" );
 
 		assert getAuditReader().find( SecondaryNamingTestEntity.class, id, 1 ).equals( ver1 );
 		assert getAuditReader().find( SecondaryNamingTestEntity.class, id, 2 ).equals( ver2 );
 	}
 
 	@SuppressWarnings({"unchecked"})
 	@Test
 	public void testTableNames() {
 		assert "sec_versions".equals(
 				((Iterator<Join>)
-						getCfg().getClassMapping(
+						metadata().getEntityBinding(
 								"org.hibernate.envers.test.integration.secondary.SecondaryNamingTestEntity_AUD"
 						)
 								.getJoinIterator())
 						.next().getTable().getName()
 		);
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/ids/EmbIdSecondary.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/ids/EmbIdSecondary.java
index 478415292a..3401c7408d 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/ids/EmbIdSecondary.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/ids/EmbIdSecondary.java
@@ -1,99 +1,97 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.secondary.ids;
 
 import java.util.Arrays;
 import java.util.Iterator;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.entities.ids.EmbId;
 import org.hibernate.mapping.Join;
 
 import org.junit.Test;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class EmbIdSecondary extends BaseEnversJPAFunctionalTestCase {
 	private EmbId id;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {SecondaryEmbIdTestEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		id = new EmbId( 1, 2 );
 
 		SecondaryEmbIdTestEntity ste = new SecondaryEmbIdTestEntity( id, "a", "1" );
 
 		// Revision 1
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 
 		em.persist( ste );
 
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 
 		ste = em.find( SecondaryEmbIdTestEntity.class, ste.getId() );
 		ste.setS1( "b" );
 		ste.setS2( "2" );
 
 		em.getTransaction().commit();
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1, 2 ).equals( getAuditReader().getRevisions( SecondaryEmbIdTestEntity.class, id ) );
 	}
 
 	@Test
 	public void testHistoryOfId() {
 		SecondaryEmbIdTestEntity ver1 = new SecondaryEmbIdTestEntity( id, "a", "1" );
 		SecondaryEmbIdTestEntity ver2 = new SecondaryEmbIdTestEntity( id, "b", "2" );
 
 		assert getAuditReader().find( SecondaryEmbIdTestEntity.class, id, 1 ).equals( ver1 );
 		assert getAuditReader().find( SecondaryEmbIdTestEntity.class, id, 2 ).equals( ver2 );
 	}
 
 	@SuppressWarnings({"unchecked"})
 	@Test
 	public void testTableNames() {
 		assert "sec_embid_versions".equals(
 				((Iterator<Join>)
-						getCfg().getClassMapping(
+						metadata().getEntityBinding(
 								"org.hibernate.envers.test.integration.secondary.ids.SecondaryEmbIdTestEntity_AUD"
-						)
-								.getJoinIterator())
-						.next().getTable().getName()
+						).getJoinIterator()).next().getTable().getName()
 		);
 	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/ids/MulIdSecondary.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/ids/MulIdSecondary.java
index 209248f8be..0620775084 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/ids/MulIdSecondary.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/secondary/ids/MulIdSecondary.java
@@ -1,99 +1,99 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.integration.secondary.ids;
 
 import java.util.Arrays;
 import java.util.Iterator;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.entities.ids.MulId;
 import org.hibernate.mapping.Join;
 
 import org.junit.Test;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  */
 public class MulIdSecondary extends BaseEnversJPAFunctionalTestCase {
 	private MulId id;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {SecondaryMulIdTestEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		id = new MulId( 1, 2 );
 
 		SecondaryMulIdTestEntity ste = new SecondaryMulIdTestEntity( id, "a", "1" );
 
 		// Revision 1
 		EntityManager em = getEntityManager();
 		em.getTransaction().begin();
 
 		em.persist( ste );
 
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 
 		ste = em.find( SecondaryMulIdTestEntity.class, id );
 		ste.setS1( "b" );
 		ste.setS2( "2" );
 
 		em.getTransaction().commit();
 	}
 
 	@Test
 	public void testRevisionsCounts() {
 		assert Arrays.asList( 1, 2 ).equals( getAuditReader().getRevisions( SecondaryMulIdTestEntity.class, id ) );
 	}
 
 	@Test
 	public void testHistoryOfId() {
 		SecondaryMulIdTestEntity ver1 = new SecondaryMulIdTestEntity( id, "a", "1" );
 		SecondaryMulIdTestEntity ver2 = new SecondaryMulIdTestEntity( id, "b", "2" );
 
 		assert getAuditReader().find( SecondaryMulIdTestEntity.class, id, 1 ).equals( ver1 );
 		assert getAuditReader().find( SecondaryMulIdTestEntity.class, id, 2 ).equals( ver2 );
 	}
 
 	@SuppressWarnings({"unchecked"})
 	@Test
 	public void testTableNames() {
 		assert "sec_mulid_versions".equals(
 				((Iterator<Join>)
-						getCfg().getClassMapping(
+						metadata().getEntityBinding(
 								"org.hibernate.envers.test.integration.secondary.ids.SecondaryMulIdTestEntity_AUD"
 						)
 								.getJoinIterator())
 						.next().getTable().getName()
 		);
 	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditoverride/AuditClassOverrideTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditoverride/AuditClassOverrideTest.java
index 8e72ffeec0..f380137469 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditoverride/AuditClassOverrideTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditoverride/AuditClassOverrideTest.java
@@ -1,96 +1,96 @@
 package org.hibernate.envers.test.integration.superclass.auditoverride;
 
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Table;
 
 import org.hibernate.testing.TestForIssue;
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 @TestForIssue(jiraKey = "HHH-4439")
 public class AuditClassOverrideTest extends BaseEnversJPAFunctionalTestCase {
 	private Integer classAuditedEntityId = null;
 	private Integer classNotAuditedEntityId = null;
 	private Table classAuditedTable = null;
 	private Table classNotAuditedTable = null;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {ClassOverrideAuditedEntity.class, ClassOverrideNotAuditedEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		EntityManager em = getEntityManager();
 
 		// Revision 1
 		em.getTransaction().begin();
 		ClassOverrideAuditedEntity classOverrideAuditedEntity = new ClassOverrideAuditedEntity( "data 1", 1, "data 2" );
 		em.persist( classOverrideAuditedEntity );
 		em.getTransaction().commit();
 		classAuditedEntityId = classOverrideAuditedEntity.getId();
 
 		// Revision 2
 		em.getTransaction().begin();
 		ClassOverrideNotAuditedEntity classOverrideNotAuditedEntity = new ClassOverrideNotAuditedEntity(
 				"data 1",
 				1,
 				"data 2"
 		);
 		em.persist( classOverrideNotAuditedEntity );
 		em.getTransaction().commit();
 		classNotAuditedEntityId = classOverrideNotAuditedEntity.getId();
 
-		classAuditedTable = getCfg().getClassMapping(
+		classAuditedTable = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.superclass.auditoverride.ClassOverrideAuditedEntity_AUD"
 		).getTable();
-		classNotAuditedTable = getCfg().getClassMapping(
+		classNotAuditedTable = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.superclass.auditoverride.ClassOverrideNotAuditedEntity_AUD"
 		).getTable();
 	}
 
 	@Test
 	public void testAuditedProperty() {
 		Assert.assertNotNull( classAuditedTable.getColumn( new Column( "number1" ) ) );
 		Assert.assertNotNull( classAuditedTable.getColumn( new Column( "str1" ) ) );
 		Assert.assertNotNull( classAuditedTable.getColumn( new Column( "str2" ) ) );
 		Assert.assertNotNull( classNotAuditedTable.getColumn( new Column( "str2" ) ) );
 	}
 
 	@Test
 	public void testNotAuditedProperty() {
 		Assert.assertNull( classNotAuditedTable.getColumn( new Column( "number1" ) ) );
 		Assert.assertNull( classNotAuditedTable.getColumn( new Column( "str1" ) ) );
 	}
 
 	@Test
 	public void testHistoryOfClassOverrideAuditedEntity() {
 		ClassOverrideAuditedEntity ver1 = new ClassOverrideAuditedEntity( "data 1", 1, classAuditedEntityId, "data 2" );
 		Assert.assertEquals( ver1, getAuditReader().find( ClassOverrideAuditedEntity.class, classAuditedEntityId, 1 ) );
 	}
 
 	@Test
 	public void testHistoryOfClassOverrideNotAuditedEntity() {
 		ClassOverrideNotAuditedEntity ver1 = new ClassOverrideNotAuditedEntity(
 				null,
 				null,
 				classNotAuditedEntityId,
 				"data 2"
 		);
 		Assert.assertEquals(
 				ver1, getAuditReader().find(
 				ClassOverrideNotAuditedEntity.class,
 				classNotAuditedEntityId,
 				2
 		)
 		);
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditoverride/AuditPropertyOverrideTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditoverride/AuditPropertyOverrideTest.java
index 9d70e847ad..631ef7df71 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditoverride/AuditPropertyOverrideTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditoverride/AuditPropertyOverrideTest.java
@@ -1,110 +1,110 @@
 package org.hibernate.envers.test.integration.superclass.auditoverride;
 
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Table;
 
 import org.hibernate.testing.TestForIssue;
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 @TestForIssue(jiraKey = "HHH-4439")
 public class AuditPropertyOverrideTest extends BaseEnversJPAFunctionalTestCase {
 	private Integer propertyEntityId = null;
 	private Integer transitiveEntityId = null;
 	private Integer auditedEntityId = null;
 	private Table propertyTable = null;
 	private Table transitiveTable = null;
 	private Table auditedTable = null;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {PropertyOverrideEntity.class, TransitiveOverrideEntity.class, AuditedSpecialEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		EntityManager em = getEntityManager();
 
 		// Revision 1
 		em.getTransaction().begin();
 		PropertyOverrideEntity propertyEntity = new PropertyOverrideEntity( "data 1", 1, "data 2" );
 		em.persist( propertyEntity );
 		em.getTransaction().commit();
 		propertyEntityId = propertyEntity.getId();
 
 		// Revision 2
 		em.getTransaction().begin();
 		TransitiveOverrideEntity transitiveEntity = new TransitiveOverrideEntity( "data 1", 1, "data 2", 2, "data 3" );
 		em.persist( transitiveEntity );
 		em.getTransaction().commit();
 		transitiveEntityId = transitiveEntity.getId();
 
 		// Revision 3
 		em.getTransaction().begin();
 		AuditedSpecialEntity auditedEntity = new AuditedSpecialEntity( "data 1", 1, "data 2" );
 		em.persist( auditedEntity );
 		em.getTransaction().commit();
 		auditedEntityId = auditedEntity.getId();
 
-		propertyTable = getCfg().getClassMapping(
+		propertyTable = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.superclass.auditoverride.PropertyOverrideEntity_AUD"
 		).getTable();
-		transitiveTable = getCfg().getClassMapping(
+		transitiveTable = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.superclass.auditoverride.TransitiveOverrideEntity_AUD"
 		).getTable();
-		auditedTable = getCfg().getClassMapping(
+		auditedTable = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.superclass.auditoverride.AuditedSpecialEntity_AUD"
 		).getTable();
 	}
 
 	@Test
 	public void testNotAuditedProperty() {
 		Assert.assertNull( propertyTable.getColumn( new Column( "str1" ) ) );
 	}
 
 	@Test
 	public void testAuditedProperty() {
 		Assert.assertNotNull( propertyTable.getColumn( new Column( "number1" ) ) );
 		Assert.assertNotNull( transitiveTable.getColumn( new Column( "number2" ) ) );
 		Assert.assertNotNull( auditedTable.getColumn( new Column( "str1" ) ) );
 	}
 
 	@Test
 	public void testTransitiveAuditedProperty() {
 		Assert.assertNotNull( transitiveTable.getColumn( new Column( "number1" ) ) );
 		Assert.assertNotNull( transitiveTable.getColumn( new Column( "str1" ) ) );
 	}
 
 	@Test
 	public void testHistoryOfPropertyOverrideEntity() {
 		PropertyOverrideEntity ver1 = new PropertyOverrideEntity( null, 1, propertyEntityId, "data 2" );
 		Assert.assertEquals( ver1, getAuditReader().find( PropertyOverrideEntity.class, propertyEntityId, 1 ) );
 	}
 
 	@Test
 	public void testHistoryOfTransitiveOverrideEntity() {
 		TransitiveOverrideEntity ver1 = new TransitiveOverrideEntity(
 				"data 1",
 				1,
 				transitiveEntityId,
 				"data 2",
 				2,
 				"data 3"
 		);
 		Assert.assertEquals( ver1, getAuditReader().find( TransitiveOverrideEntity.class, transitiveEntityId, 2 ) );
 	}
 
 	@Test
 	public void testHistoryOfAuditedSpecialEntity() {
 		AuditedSpecialEntity ver1 = new AuditedSpecialEntity( "data 1", null, auditedEntityId, "data 2" );
 		Assert.assertEquals( ver1, getAuditReader().find( AuditedSpecialEntity.class, auditedEntityId, 3 ) );
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditoverride/MixedOverrideTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditoverride/MixedOverrideTest.java
index 55fc03e2d4..28d5f349b7 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditoverride/MixedOverrideTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditoverride/MixedOverrideTest.java
@@ -1,60 +1,60 @@
 package org.hibernate.envers.test.integration.superclass.auditoverride;
 
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Table;
 
 import org.hibernate.testing.TestForIssue;
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 @TestForIssue(jiraKey = "HHH-4439")
 public class MixedOverrideTest extends BaseEnversJPAFunctionalTestCase {
 	private Integer mixedEntityId = null;
 	private Table mixedTable = null;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {MixedOverrideEntity.class};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		EntityManager em = getEntityManager();
 
 		// Revision 1
 		em.getTransaction().begin();
 		MixedOverrideEntity mixedEntity = new MixedOverrideEntity( "data 1", 1, "data 2" );
 		em.persist( mixedEntity );
 		em.getTransaction().commit();
 		mixedEntityId = mixedEntity.getId();
 
-		mixedTable = getCfg().getClassMapping(
+		mixedTable = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.superclass.auditoverride.MixedOverrideEntity_AUD"
 		).getTable();
 	}
 
 	@Test
 	public void testAuditedProperty() {
 		Assert.assertNotNull( mixedTable.getColumn( new Column( "number1" ) ) );
 		Assert.assertNotNull( mixedTable.getColumn( new Column( "str2" ) ) );
 	}
 
 	@Test
 	public void testNotAuditedProperty() {
 		Assert.assertNull( mixedTable.getColumn( new Column( "str1" ) ) );
 	}
 
 	@Test
 	public void testHistoryOfMixedEntity() {
 		MixedOverrideEntity ver1 = new MixedOverrideEntity( null, 1, mixedEntityId, "data 2" );
 		Assert.assertEquals( ver1, getAuditReader().find( MixedOverrideEntity.class, mixedEntityId, 1 ) );
 	}
 }
\ No newline at end of file
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/MultipleAuditParentsTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/MultipleAuditParentsTest.java
index 91371b8716..3aae726bc6 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/MultipleAuditParentsTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/MultipleAuditParentsTest.java
@@ -1,102 +1,102 @@
 package org.hibernate.envers.test.integration.superclass.auditparents;
 
 import java.util.Set;
 import javax.persistence.EntityManager;
 import javax.persistence.MappedSuperclass;
 
 import org.hibernate.envers.Audited;
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.entities.StrIntTestEntity;
 import org.hibernate.envers.test.tools.TestTools;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Table;
 
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * Tests mapping of child entity that declares all of its ancestors as audited with {@link Audited#auditParents()} property.
  * All supperclasses are marked with {@link MappedSuperclass} annotation but not {@link Audited}.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class MultipleAuditParentsTest extends BaseEnversJPAFunctionalTestCase {
 	private long childMultipleId = 1L;
 	private Integer siteMultipleId = null;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {
 				MappedGrandparentEntity.class,
 				MappedParentEntity.class,
 				ChildMultipleParentsEntity.class,
 				StrIntTestEntity.class
 		};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		EntityManager em = getEntityManager();
 		// Revision 1
 		em.getTransaction().begin();
 		StrIntTestEntity siteMultiple = new StrIntTestEntity( "data 1", 1 );
 		em.persist( siteMultiple );
 		em.persist(
 				new ChildMultipleParentsEntity(
 						childMultipleId,
 						"grandparent 1",
 						"notAudited 1",
 						"parent 1",
 						"child 1",
 						siteMultiple
 				)
 		);
 		em.getTransaction().commit();
 		siteMultipleId = siteMultiple.getId();
 	}
 
 	@Test
 	public void testCreatedAuditTable() {
 		Set<String> expectedColumns = TestTools.makeSet( "child", "parent", "relation_id", "grandparent", "id" );
 		Set<String> unexpectedColumns = TestTools.makeSet( "notAudited" );
 
-		Table table = getCfg().getClassMapping(
+		Table table = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.superclass.auditparents.ChildMultipleParentsEntity_AUD"
 		).getTable();
 
 		for ( String columnName : expectedColumns ) {
 			// Check whether expected column exists.
 			Assert.assertNotNull( table.getColumn( new Column( columnName ) ) );
 		}
 		for ( String columnName : unexpectedColumns ) {
 			// Check whether unexpected column does not exist.
 			Assert.assertNull( table.getColumn( new Column( columnName ) ) );
 		}
 	}
 
 	@Test
 	public void testMultipleAuditParents() {
 		// expectedMultipleChild.notAudited shall be null, because it is not audited.
 		ChildMultipleParentsEntity expectedMultipleChild = new ChildMultipleParentsEntity(
 				childMultipleId,
 				"grandparent 1",
 				null,
 				"parent 1",
 				"child 1",
 				new StrIntTestEntity(
 						"data 1",
 						1,
 						siteMultipleId
 				)
 		);
 		ChildMultipleParentsEntity child = getAuditReader().find(
 				ChildMultipleParentsEntity.class,
 				childMultipleId,
 				1
 		);
 		Assert.assertEquals( expectedMultipleChild, child );
 		Assert.assertEquals( expectedMultipleChild.getRelation().getId(), child.getRelation().getId() );
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/SingleAuditParentsTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/SingleAuditParentsTest.java
index 1752542f3f..ea059136d3 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/SingleAuditParentsTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/SingleAuditParentsTest.java
@@ -1,95 +1,95 @@
 package org.hibernate.envers.test.integration.superclass.auditparents;
 
 import java.util.Set;
 import javax.persistence.EntityManager;
 import javax.persistence.MappedSuperclass;
 
 import org.hibernate.envers.Audited;
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.entities.StrIntTestEntity;
 import org.hibernate.envers.test.tools.TestTools;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Table;
 
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * Tests mapping of child entity that declares one of its ancestors as audited with {@link Audited#auditParents()} property.
  * All supperclasses are marked with {@link MappedSuperclass} annotation but not {@link Audited}.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class SingleAuditParentsTest extends BaseEnversJPAFunctionalTestCase {
 	private long childSingleId = 1L;
 	private Integer siteSingleId = null;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {
 				MappedGrandparentEntity.class,
 				MappedParentEntity.class,
 				ChildSingleParentEntity.class,
 				StrIntTestEntity.class
 		};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		EntityManager em = getEntityManager();
 		// Revision 1
 		em.getTransaction().begin();
 		StrIntTestEntity siteSingle = new StrIntTestEntity( "data 1", 1 );
 		em.persist( siteSingle );
 		em.persist(
 				new ChildSingleParentEntity(
 						childSingleId,
 						"grandparent 1",
 						"notAudited 1",
 						"parent 1",
 						"child 1",
 						siteSingle
 				)
 		);
 		em.getTransaction().commit();
 		siteSingleId = siteSingle.getId();
 		em.close();
 	}
 
 	@Test
 	public void testCreatedAuditTable() {
 		Set<String> expectedColumns = TestTools.makeSet( "child", "grandparent", "id" );
 		Set<String> unexpectedColumns = TestTools.makeSet( "parent", "relation_id", "notAudited" );
 
-		Table table = getCfg().getClassMapping(
+		Table table = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.superclass.auditparents.ChildSingleParentEntity_AUD"
 		).getTable();
 
 		for ( String columnName : expectedColumns ) {
 			// Check whether expected column exists.
 			Assert.assertNotNull( table.getColumn( new Column( columnName ) ) );
 		}
 		for ( String columnName : unexpectedColumns ) {
 			// Check whether unexpected column does not exist.
 			Assert.assertNull( table.getColumn( new Column( columnName ) ) );
 		}
 	}
 
 	@Test
 	public void testSingleAuditParent() {
 		// expectedSingleChild.parent, expectedSingleChild.relation and expectedSingleChild.notAudited shall be null, because they are not audited.
 		ChildSingleParentEntity expectedSingleChild = new ChildSingleParentEntity(
 				childSingleId,
 				"grandparent 1",
 				null,
 				null,
 				"child 1",
 				null
 		);
 		ChildSingleParentEntity child = getAuditReader().find( ChildSingleParentEntity.class, childSingleId, 1 );
 		Assert.assertEquals( expectedSingleChild, child );
 		Assert.assertNull( child.getRelation() );
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/TotalAuditParentsTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/TotalAuditParentsTest.java
index 6fe7d4bc8b..57c51d22e1 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/TotalAuditParentsTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/TotalAuditParentsTest.java
@@ -1,104 +1,104 @@
 package org.hibernate.envers.test.integration.superclass.auditparents;
 
 import java.util.Set;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.Audited;
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.entities.StrIntTestEntity;
 import org.hibernate.envers.test.tools.TestTools;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Table;
 
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * Tests mapping of baby entity which declares its parent as audited with {@link Audited#auditParents()} property.
  * Moreover, child class (mapped superclass of baby entity) declares grandparent entity as audited. In this case all
  * attributes of baby class shall be audited.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class TotalAuditParentsTest extends BaseEnversJPAFunctionalTestCase {
 	private long babyCompleteId = 1L;
 	private Integer siteCompleteId = null;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {
 				MappedGrandparentEntity.class,
 				MappedParentEntity.class,
 				StrIntTestEntity.class,
 				ChildCompleteEntity.class,
 				BabyCompleteEntity.class
 		};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		EntityManager em = getEntityManager();
 		// Revision 1
 		em.getTransaction().begin();
 		StrIntTestEntity siteComplete = new StrIntTestEntity( "data 1", 1 );
 		em.persist( siteComplete );
 		em.persist(
 				new BabyCompleteEntity(
 						babyCompleteId,
 						"grandparent 1",
 						"notAudited 1",
 						"parent 1",
 						"child 1",
 						siteComplete,
 						"baby 1"
 				)
 		);
 		em.getTransaction().commit();
 		siteCompleteId = siteComplete.getId();
 	}
 
 	@Test
 	public void testCreatedAuditTable() {
 		Set<String> expectedColumns = TestTools.makeSet(
 				"baby",
 				"child",
 				"parent",
 				"relation_id",
 				"grandparent",
 				"id"
 		);
 		Set<String> unexpectedColumns = TestTools.makeSet( "notAudited" );
 
-		Table table = getCfg().getClassMapping(
+		Table table = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.superclass.auditparents.BabyCompleteEntity_AUD"
 		).getTable();
 
 		for ( String columnName : expectedColumns ) {
 			// Check whether expected column exists.
 			Assert.assertNotNull( table.getColumn( new Column( columnName ) ) );
 		}
 		for ( String columnName : unexpectedColumns ) {
 			// Check whether unexpected column does not exist.
 			Assert.assertNull( table.getColumn( new Column( columnName ) ) );
 		}
 	}
 
 	@Test
 	public void testCompleteAuditParents() {
 		// expectedBaby.notAudited shall be null, because it is not audited.
 		BabyCompleteEntity expectedBaby = new BabyCompleteEntity(
 				babyCompleteId,
 				"grandparent 1",
 				null,
 				"parent 1",
 				"child 1",
 				new StrIntTestEntity( "data 1", 1, siteCompleteId ),
 				"baby 1"
 		);
 		BabyCompleteEntity baby = getAuditReader().find( BabyCompleteEntity.class, babyCompleteId, 1 );
 		Assert.assertEquals( expectedBaby, baby );
 		Assert.assertEquals( expectedBaby.getRelation().getId(), baby.getRelation().getId() );
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/TransitiveAuditParentsTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/TransitiveAuditParentsTest.java
index 5a18431928..96d2bb0ed8 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/TransitiveAuditParentsTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/superclass/auditparents/TransitiveAuditParentsTest.java
@@ -1,135 +1,135 @@
 package org.hibernate.envers.test.integration.superclass.auditparents;
 
 import java.util.Set;
 import javax.persistence.EntityManager;
 
 import org.hibernate.envers.Audited;
 import org.hibernate.envers.test.BaseEnversJPAFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.tools.TestTools;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Table;
 
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * Tests mapping of child entity which parent declares one of its ancestors as audited with {@link Audited#auditParents()}
  * property. Child entity may mark explicitly its parent as audited or not.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class TransitiveAuditParentsTest extends BaseEnversJPAFunctionalTestCase {
 	private long childImpTransId = 1L;
 	private long childExpTransId = 2L;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {
 				MappedGrandparentEntity.class,
 				TransitiveParentEntity.class,
 				ImplicitTransitiveChildEntity.class,
 				ExplicitTransitiveChildEntity.class
 		};
 	}
 
 	@Test
 	@Priority(10)
 	public void initData() {
 		EntityManager em = getEntityManager();
 
 		// Revision 1
 		em.getTransaction().begin();
 		em.persist(
 				new ImplicitTransitiveChildEntity(
 						childImpTransId,
 						"grandparent 1",
 						"notAudited 1",
 						"parent 1",
 						"child 1"
 				)
 		);
 		em.getTransaction().commit();
 
 		// Revision 2
 		em.getTransaction().begin();
 		em.persist(
 				new ExplicitTransitiveChildEntity(
 						childExpTransId,
 						"grandparent 2",
 						"notAudited 2",
 						"parent 2",
 						"child 2"
 				)
 		);
 		em.getTransaction().commit();
 	}
 
 	@Test
 	public void testCreatedAuditTables() {
-		Table explicitTransChildTable = getCfg().getClassMapping(
+		Table explicitTransChildTable = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.superclass.auditparents.ExplicitTransitiveChildEntity_AUD"
 		).getTable();
 		checkTableColumns(
 				TestTools.makeSet( "child", "parent", "grandparent", "id" ),
 				TestTools.makeSet( "notAudited" ),
 				explicitTransChildTable
 		);
 
-		Table implicitTransChildTable = getCfg().getClassMapping(
+		Table implicitTransChildTable = metadata().getEntityBinding(
 				"org.hibernate.envers.test.integration.superclass.auditparents.ImplicitTransitiveChildEntity_AUD"
 		).getTable();
 		checkTableColumns(
 				TestTools.makeSet( "child", "parent", "grandparent", "id" ),
 				TestTools.makeSet( "notAudited" ),
 				implicitTransChildTable
 		);
 	}
 
 	private void checkTableColumns(Set<String> expectedColumns, Set<String> unexpectedColumns, Table table) {
 		for ( String columnName : expectedColumns ) {
 			// Check whether expected column exists.
 			Assert.assertNotNull( table.getColumn( new Column( columnName ) ) );
 		}
 		for ( String columnName : unexpectedColumns ) {
 			// Check whether unexpected column does not exist.
 			Assert.assertNull( table.getColumn( new Column( columnName ) ) );
 		}
 	}
 
 	@Test
 	public void testImplicitTransitiveAuditParents() {
 		// expectedChild.notAudited shall be null, because it is not audited.
 		ImplicitTransitiveChildEntity expectedChild = new ImplicitTransitiveChildEntity(
 				childImpTransId,
 				"grandparent 1",
 				null,
 				"parent 1",
 				"child 1"
 		);
 		ImplicitTransitiveChildEntity child = getAuditReader().find(
 				ImplicitTransitiveChildEntity.class,
 				childImpTransId,
 				1
 		);
 		Assert.assertEquals( expectedChild, child );
 	}
 
 	@Test
 	public void testExplicitTransitiveAuditParents() {
 		// expectedChild.notAudited shall be null, because it is not audited.
 		ExplicitTransitiveChildEntity expectedChild = new ExplicitTransitiveChildEntity(
 				childExpTransId,
 				"grandparent 2",
 				null,
 				"parent 2",
 				"child 2"
 		);
 		ExplicitTransitiveChildEntity child = getAuditReader().find(
 				ExplicitTransitiveChildEntity.class,
 				childExpTransId,
 				2
 		);
 		Assert.assertEquals( expectedChild, child );
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/tools/SchemaExportTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/tools/SchemaExportTest.java
index 619198cb0b..efa3c17ea6 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/tools/SchemaExportTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/integration/tools/SchemaExportTest.java
@@ -1,60 +1,45 @@
 package org.hibernate.envers.test.integration.tools;
 
 import java.util.Arrays;
 
 import org.hibernate.Session;
 import org.hibernate.envers.test.BaseEnversFunctionalTestCase;
 import org.hibernate.envers.test.Priority;
 import org.hibernate.envers.test.entities.StrTestEntity;
-import org.hibernate.envers.tools.hbm2ddl.EnversSchemaGenerator;
 
 import org.hibernate.testing.TestForIssue;
 import org.junit.Assert;
 import org.junit.Test;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 @TestForIssue(jiraKey = "HHH-7106")
 public class SchemaExportTest extends BaseEnversFunctionalTestCase {
 	private Integer id = null;
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] {StrTestEntity.class};
 	}
 
-	protected boolean createSchema() {
-		// Disable schema auto generation.
-		return false;
-	}
-
 	@Test
 	@Priority(10)
 	public void testSchemaCreation() {
-		// Generate complete schema.
-		new EnversSchemaGenerator( configuration() ).export().create( true, true );
-
 		// Populate database with test data.
 		Session session = getSession();
 		session.getTransaction().begin();
 		StrTestEntity entity = new StrTestEntity( "data" );
 		session.save( entity );
 		session.getTransaction().commit();
 
 		id = entity.getId();
 	}
 
 	@Test
 	@Priority(9)
 	public void testAuditDataRetrieval() {
 		Assert.assertEquals( Arrays.asList( 1 ), getAuditReader().getRevisions( StrTestEntity.class, id ) );
 		Assert.assertEquals( new StrTestEntity( "data", id ), getAuditReader().find( StrTestEntity.class, id, 1 ) );
 	}
-
-	@Test
-	@Priority(8)
-	public void testSchemaDrop() {
-		new EnversSchemaGenerator( configuration() ).export().drop( true, true );
-	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/performance/AbstractEntityManagerTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/performance/AbstractEntityManagerTest.java
index 29e7d2dfc0..6dfa030cc8 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/performance/AbstractEntityManagerTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/performance/AbstractEntityManagerTest.java
@@ -1,155 +1,155 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.performance;
 
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Properties;
 import javax.persistence.EntityManager;
 
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.envers.AuditReader;
 import org.hibernate.envers.AuditReaderFactory;
 import org.hibernate.envers.configuration.EnversSettings;
-import org.hibernate.envers.event.spi.EnversIntegrator;
+import org.hibernate.envers.boot.internal.EnversIntegrator;
 import org.hibernate.envers.test.AbstractEnversTest;
 import org.hibernate.jpa.AvailableSettings;
 import org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl;
 import org.hibernate.jpa.boot.spi.Bootstrap;
 import org.hibernate.jpa.internal.EntityManagerFactoryImpl;
 import org.hibernate.jpa.test.PersistenceUnitDescriptorAdapter;
 
 import org.hibernate.testing.AfterClassOnce;
 import org.hibernate.testing.BeforeClassOnce;
 import org.junit.Before;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public abstract class AbstractEntityManagerTest extends AbstractEnversTest {
 	public static final Dialect DIALECT = Dialect.getDialect();
 
 	private EntityManagerFactoryBuilderImpl entityManagerFactoryBuilder;
 	private StandardServiceRegistryImpl serviceRegistry;
 	private EntityManagerFactoryImpl emf;
 	private EntityManager entityManager;
 	private AuditReader auditReader;
 	private boolean audited;
 
 	public void addConfigurationProperties(Properties configuration) {
 	}
 
 	protected static Dialect getDialect() {
 		return DIALECT;
 	}
 
 	private void closeEntityManager() {
 		if ( entityManager != null ) {
 			entityManager.close();
 			entityManager = null;
 		}
 	}
 
 	@Before
 	public void newEntityManager() {
 		closeEntityManager();
 
 		entityManager = emf.createEntityManager();
 
 		if ( audited ) {
 			auditReader = AuditReaderFactory.get( entityManager );
 		}
 	}
 
 	@BeforeClassOnce
 	public void init() throws IOException {
 		init( true, getAuditStrategy() );
 	}
 
 	protected void init(boolean audited, String auditStrategy) throws IOException {
 		this.audited = audited;
 
 		Properties configurationProperties = new Properties();
 		configurationProperties.putAll( Environment.getProperties() );
 		if ( !audited ) {
 			configurationProperties.setProperty( EnversIntegrator.AUTO_REGISTER, "false" );
 		}
 		if ( createSchema() ) {
 			configurationProperties.setProperty( Environment.HBM2DDL_AUTO, "create-drop" );
 			configurationProperties.setProperty( Environment.USE_NEW_ID_GENERATOR_MAPPINGS, "true" );
 			configurationProperties.setProperty( EnversSettings.USE_REVISION_ENTITY_WITH_NATIVE_ID, "false" );
 		}
 		if ( auditStrategy != null && !"".equals( auditStrategy ) ) {
 			configurationProperties.setProperty( "org.hibernate.envers.audit_strategy", auditStrategy );
 		}
 
 		addConfigurationProperties( configurationProperties );
 
 		configurationProperties.put( AvailableSettings.LOADED_CLASSES, Arrays.asList( getAnnotatedClasses() ) );
 
 		entityManagerFactoryBuilder = (EntityManagerFactoryBuilderImpl) Bootstrap.getEntityManagerFactoryBuilder(
 				new PersistenceUnitDescriptorAdapter(),
 				configurationProperties
 		);
 
 		emf = (EntityManagerFactoryImpl) entityManagerFactoryBuilder.build();
 
 		serviceRegistry = (StandardServiceRegistryImpl) emf.getSessionFactory()
 				.getServiceRegistry()
 				.getParentServiceRegistry();
 
 		newEntityManager();
 	}
 
 	protected Class[] getAnnotatedClasses() {
 		return new Class[0];
 	}
 
 	protected boolean createSchema() {
 		return true;
 	}
 
 	private BootstrapServiceRegistryBuilder createBootstrapRegistryBuilder() {
 		return new BootstrapServiceRegistryBuilder();
 	}
 
 	@AfterClassOnce
 	public void close() {
 		closeEntityManager();
 		emf.close();
 		//NOTE we don't build the service registry so we don't destroy it
 	}
 
 	public EntityManager getEntityManager() {
 		return entityManager;
 	}
 
 	public AuditReader getAuditReader() {
 		return auditReader;
 	}
 }
diff --git a/hibernate-envers/src/test/resources/log4j.properties b/hibernate-envers/src/test/resources/log4j.properties
index fa55250f40..091e82c4ba 100644
--- a/hibernate-envers/src/test/resources/log4j.properties
+++ b/hibernate-envers/src/test/resources/log4j.properties
@@ -1,12 +1,14 @@
 log4j.appender.stdout=org.apache.log4j.ConsoleAppender
 log4j.appender.stdout.Target=System.out
 log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
 log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n
 
 log4j.rootLogger=info, stdout
 
 log4j.logger.org.hibernate.test=info
 log4j.logger.org.hibernate.tool.hbm2ddl=debug
 
 # SQL Logging - HHH-6833
-log4j.logger.org.hibernate.SQL=debug
\ No newline at end of file
+log4j.logger.org.hibernate.SQL=debug
+
+log4j.logger.org.hibernate.envers.boot.internal.AdditionalJaxbMappingProducerImpl=trace
\ No newline at end of file
diff --git a/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseNonConfigCoreFunctionalTestCase.java b/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseNonConfigCoreFunctionalTestCase.java
index 8e13a3c5dc..b5d6951f3d 100644
--- a/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseNonConfigCoreFunctionalTestCase.java
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseNonConfigCoreFunctionalTestCase.java
@@ -1,533 +1,537 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2015, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.testing.junit4;
 
 import java.sql.Blob;
 import java.sql.Clob;
 import java.sql.Connection;
 import java.sql.NClob;
 import java.sql.SQLException;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.Session;
 import org.hibernate.boot.Metadata;
 import org.hibernate.boot.MetadataBuilder;
 import org.hibernate.boot.MetadataSources;
 import org.hibernate.boot.SessionFactoryBuilder;
 import org.hibernate.boot.model.naming.ImplicitNamingStrategyLegacyJpaImpl;
 import org.hibernate.boot.registry.BootstrapServiceRegistry;
 import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.boot.registry.StandardServiceRegistry;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.spi.MetadataImplementor;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.engine.jdbc.env.spi.JdbcEnvironment;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.jdbc.Work;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.type.BlobType;
 import org.hibernate.type.ClobType;
 import org.hibernate.type.NClobType;
 
 import org.hibernate.testing.AfterClassOnce;
 import org.hibernate.testing.BeforeClassOnce;
 import org.hibernate.testing.OnExpectedFailure;
 import org.hibernate.testing.OnFailure;
 import org.hibernate.testing.cache.CachingRegionFactory;
 import org.junit.After;
 import org.junit.Before;
 
 import static org.junit.Assert.fail;
 
 /**
  * Applies functional testing logic for core Hibernate testing on top of {@link BaseUnitTestCase}.
  * Much like {@link org.hibernate.testing.junit4.BaseCoreFunctionalTestCase}, except that
  * this form uses the new bootstrapping APIs while BaseCoreFunctionalTestCase continues to
  * use (the neutered form of) Configuration.
  *
  * @author Steve Ebersole
  */
 public class BaseNonConfigCoreFunctionalTestCase extends BaseUnitTestCase {
 	public static final String VALIDATE_DATA_CLEANUP = "hibernate.test.validateDataCleanup";
 
 	private StandardServiceRegistry serviceRegistry;
 	private MetadataImplementor metadata;
 	private SessionFactoryImplementor sessionFactory;
 
 	private Session session;
 
 	protected Dialect getDialect() {
 		if ( serviceRegistry != null ) {
 			return serviceRegistry.getService( JdbcEnvironment.class ).getDialect();
 		}
 		else {
 			return BaseCoreFunctionalTestCase.getDialect();
 		}
 	}
 
 	protected StandardServiceRegistry serviceRegistry() {
 		return serviceRegistry;
 	}
 
 	protected MetadataImplementor metadata() {
 		return metadata;
 	}
 
 	protected SessionFactoryImplementor sessionFactory() {
 		return sessionFactory;
 	}
 
 	protected Session openSession() throws HibernateException {
 		session = sessionFactory().openSession();
 		return session;
 	}
 
 	protected Session openSession(Interceptor interceptor) throws HibernateException {
 		session = sessionFactory().withOptions().interceptor( interceptor ).openSession();
 		return session;
 	}
 
+	protected Session getSession() {
+		return session;
+	}
+
 	protected void rebuildSessionFactory() {
 		releaseResources();
 		buildResources();
 	}
 
 	protected void cleanupCache() {
 		if ( sessionFactory != null ) {
 			sessionFactory.getCache().evictAllRegions();
 		}
 	}
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// JUNIT hooks
 
 	@BeforeClassOnce
 	@SuppressWarnings( {"UnusedDeclaration"})
 	protected void startUp() {
 		buildResources();
 	}
 
 	protected void buildResources() {
 		final StandardServiceRegistryBuilder ssrb = constructStandardServiceRegistryBuilder();
 
 		serviceRegistry = ssrb.build();
 		afterStandardServiceRegistryBuilt( serviceRegistry );
 
 		final MetadataSources metadataSources = new MetadataSources( serviceRegistry );
 		applyMetadataSources( metadataSources );
 		afterMetadataSourcesApplied( metadataSources );
 
 		final MetadataBuilder metadataBuilder = metadataSources.getMetadataBuilder();
 		initialize( metadataBuilder );
 		configureMetadataBuilder( metadataBuilder );
 
 		metadata = (MetadataImplementor) metadataBuilder.build();
 		applyCacheSettings( metadata );
 		afterMetadataBuilt( metadata );
 
 		final SessionFactoryBuilder sfb = metadata.getSessionFactoryBuilder();
 		initialize( sfb, metadata );
 		configureSessionFactoryBuilder( sfb );
 
 		sessionFactory = (SessionFactoryImplementor) sfb.build();
 		afterSessionFactoryBuilt( sessionFactory );
 	}
 
 	protected final StandardServiceRegistryBuilder constructStandardServiceRegistryBuilder() {
 		final BootstrapServiceRegistryBuilder bsrb = new BootstrapServiceRegistryBuilder();
 		// by default we do not share the BootstrapServiceRegistry nor the StandardServiceRegistry,
 		// so we want the BootstrapServiceRegistry to be automatically closed when the
 		// StandardServiceRegistry is closed.
 		bsrb.enableAutoClose();
 		configureBootstrapServiceRegistryBuilder( bsrb );
 
 		final BootstrapServiceRegistry bsr = bsrb.build();
 		afterBootstrapServiceRegistryBuilt( bsr );
 
 		final Map settings = new HashMap();
 		addSettings( settings );
 
 		final StandardServiceRegistryBuilder ssrb = new StandardServiceRegistryBuilder( bsr );
 		initialize( ssrb );
 		ssrb.applySettings( settings );
 		configureStandardServiceRegistryBuilder( ssrb );
 		return ssrb;
 	}
 
 	protected void addSettings(Map settings) {
 	}
 
 	/**
 	 * Apply any desired config to the BootstrapServiceRegistryBuilder to be incorporated
 	 * into the built BootstrapServiceRegistry
 	 *
 	 * @param bsrb The BootstrapServiceRegistryBuilder
 	 */
 	@SuppressWarnings({"SpellCheckingInspection", "UnusedParameters"})
 	protected void configureBootstrapServiceRegistryBuilder(BootstrapServiceRegistryBuilder bsrb) {
 	}
 
 	/**
 	 * Hook to allow tests to use the BootstrapServiceRegistry if they wish
 	 *
 	 * @param bsr The BootstrapServiceRegistry
 	 */
 	@SuppressWarnings("UnusedParameters")
 	protected void afterBootstrapServiceRegistryBuilt(BootstrapServiceRegistry bsr) {
 	}
 
 	@SuppressWarnings("SpellCheckingInspection")
 	private void initialize(StandardServiceRegistryBuilder ssrb) {
 		final Dialect dialect = BaseCoreFunctionalTestCase.getDialect();
 
 		ssrb.applySetting( AvailableSettings.CACHE_REGION_FACTORY, CachingRegionFactory.class.getName() );
 		ssrb.applySetting( AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS, "true" );
 		if ( createSchema() ) {
 			ssrb.applySetting( AvailableSettings.HBM2DDL_AUTO, "create-drop" );
 			final String secondSchemaName = createSecondSchema();
 			if ( StringHelper.isNotEmpty( secondSchemaName ) ) {
 				if ( !H2Dialect.class.isInstance( dialect ) ) {
 					// while it may be true that only H2 supports creation of a second schema via
 					// URL (no idea whether that is accurate), every db should support creation of schemas
 					// via DDL which SchemaExport can create for us.  See how this is used and
 					// whether that usage could not just leverage that capability
 					throw new UnsupportedOperationException( "Only H2 dialect supports creation of second schema." );
 				}
 				Helper.createH2Schema( secondSchemaName, ssrb.getSettings() );
 			}
 		}
 		ssrb.applySetting( AvailableSettings.DIALECT, dialect.getClass().getName() );
 	}
 
 	protected boolean createSchema() {
 		return true;
 	}
 
 	protected String createSecondSchema() {
 		// poorly named, yes, but to keep migration easy for existing BaseCoreFunctionalTestCase
 		// impls I kept the same name from there
 		return null;
 	}
 
 	/**
 	 * Apply any desired config to the StandardServiceRegistryBuilder to be incorporated
 	 * into the built StandardServiceRegistry
 	 *
 	 * @param ssrb The StandardServiceRegistryBuilder
 	 */
 	@SuppressWarnings({"SpellCheckingInspection", "UnusedParameters"})
 	protected void configureStandardServiceRegistryBuilder(StandardServiceRegistryBuilder ssrb) {
 	}
 
 	/**
 	 * Hook to allow tests to use the StandardServiceRegistry if they wish
 	 *
 	 * @param ssr The StandardServiceRegistry
 	 */
 	@SuppressWarnings("UnusedParameters")
 	protected void afterStandardServiceRegistryBuilt(StandardServiceRegistry ssr) {
 	}
 
 	protected void applyMetadataSources(MetadataSources metadataSources) {
 		for ( String mapping : getMappings() ) {
 			metadataSources.addResource( getBaseForMappings() + mapping );
 		}
 
 		for ( Class annotatedClass : getAnnotatedClasses() ) {
 			metadataSources.addAnnotatedClass( annotatedClass );
 		}
 
 		for ( String annotatedPackage : getAnnotatedPackages() ) {
 			metadataSources.addPackage( annotatedPackage );
 		}
 
 		for ( String ormXmlFile : getXmlFiles() ) {
 			metadataSources.addInputStream( Thread.currentThread().getContextClassLoader().getResourceAsStream( ormXmlFile ) );
 		}
 	}
 
 	protected static final String[] NO_MAPPINGS = new String[0];
 
 	protected String[] getMappings() {
 		return NO_MAPPINGS;
 	}
 
 	protected String getBaseForMappings() {
 		return "org/hibernate/test/";
 	}
 
 	protected static final Class[] NO_CLASSES = new Class[0];
 
 	protected Class[] getAnnotatedClasses() {
 		return NO_CLASSES;
 	}
 
 	protected String[] getAnnotatedPackages() {
 		return NO_MAPPINGS;
 	}
 
 	protected String[] getXmlFiles() {
 		return NO_MAPPINGS;
 	}
 
 	protected void afterMetadataSourcesApplied(MetadataSources metadataSources) {
 	}
 
 	private void initialize(MetadataBuilder metadataBuilder) {
 		metadataBuilder.withNewIdentifierGeneratorsEnabled( true );
 		metadataBuilder.with( ImplicitNamingStrategyLegacyJpaImpl.INSTANCE );
 	}
 
 	protected void configureMetadataBuilder(MetadataBuilder metadataBuilder) {
 	}
 
 	protected boolean overrideCacheStrategy() {
 		return true;
 	}
 
 	protected String getCacheConcurrencyStrategy() {
 		return null;
 	}
 
 	protected final void applyCacheSettings(Metadata metadata) {
 		if ( !overrideCacheStrategy() ) {
 			return;
 		}
 
 		if ( getCacheConcurrencyStrategy() == null ) {
 			return;
 		}
 
 		for ( PersistentClass entityBinding : metadata.getEntityBindings() ) {
 			if ( entityBinding.isInherited() ) {
 				continue;
 			}
 
 			boolean hasLob = false;
 
 			final Iterator props = entityBinding.getPropertyClosureIterator();
 			while ( props.hasNext() ) {
 				final Property prop = (Property) props.next();
 				if ( prop.getValue().isSimpleValue() ) {
 					if ( isLob( ( (SimpleValue) prop.getValue() ).getTypeName() ) ) {
 						hasLob = true;
 						break;
 					}
 				}
 			}
 
 			if ( !hasLob ) {
 				( ( RootClass) entityBinding ).setCacheConcurrencyStrategy( getCacheConcurrencyStrategy() );
 			}
 		}
 
 		for ( Collection collectionBinding : metadata.getCollectionBindings() ) {
 			boolean isLob = false;
 
 			if ( collectionBinding.getElement().isSimpleValue() ) {
 				isLob = isLob( ( (SimpleValue) collectionBinding.getElement() ).getTypeName() );
 			}
 
 			if ( !isLob ) {
 				collectionBinding.setCacheConcurrencyStrategy( getCacheConcurrencyStrategy() );
 			}
 		}
 	}
 
 	private boolean isLob(String typeName) {
 		return "blob".equals( typeName )
 				|| "clob".equals( typeName )
 				|| "nclob".equals( typeName )
 				|| Blob.class.getName().equals( typeName )
 				|| Clob.class.getName().equals( typeName )
 				|| NClob.class.getName().equals( typeName )
 				|| BlobType.class.getName().equals( typeName )
 				|| ClobType.class.getName().equals( typeName )
 				|| NClobType.class.getName().equals( typeName );
 	}
 
 	protected void afterMetadataBuilt(Metadata metadata) {
 	}
 
 	private void initialize(SessionFactoryBuilder sfb, Metadata metadata) {
 		// todo : this is where we need to apply cache settings to be like BaseCoreFunctionalTestCase
 		//		it reads the class/collection mappings and creates corresponding
 		//		CacheRegionDescription references.
 		//
 		//		Ultimately I want those to go on MetadataBuilder, and in fact MetadataBuilder
 		//		already defines the needed method.  But for the [pattern used by the
 		//		tests we need this as part of SessionFactoryBuilder
 	}
 
 	protected void configureSessionFactoryBuilder(SessionFactoryBuilder sfb) {
 	}
 
 	protected void afterSessionFactoryBuilt(SessionFactoryImplementor sessionFactory) {
 	}
 
 	@AfterClassOnce
 	@SuppressWarnings( {"UnusedDeclaration"})
 	protected void shutDown() {
 		releaseResources();
 	}
 
 	protected void releaseResources() {
 		if ( sessionFactory != null ) {
 			try {
 				sessionFactory.close();
 			}
 			catch (Exception e) {
 				System.err.println( "Unable to release SessionFactory : " + e.getMessage() );
 				e.printStackTrace();
 			}
 		}
 		sessionFactory = null;
 
 		if ( serviceRegistry != null ) {
 			try {
 				StandardServiceRegistryBuilder.destroy( serviceRegistry );
 			}
 			catch (Exception e) {
 				System.err.println( "Unable to release StandardServiceRegistry : " + e.getMessage() );
 				e.printStackTrace();
 			}
 		}
 		serviceRegistry=null;
 	}
 
 	@OnFailure
 	@OnExpectedFailure
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public void onFailure() {
 		if ( rebuildSessionFactoryOnError() ) {
 			rebuildSessionFactory();
 		}
 	}
 
 	protected boolean rebuildSessionFactoryOnError() {
 		return true;
 	}
 
 	@Before
 	public final void beforeTest() throws Exception {
 		prepareTest();
 	}
 
 	protected void prepareTest() throws Exception {
 	}
 
 	@After
 	public final void afterTest() throws Exception {
 		if ( isCleanupTestDataRequired() ) {
 			cleanupTestData();
 		}
 		cleanupTest();
 
 		cleanupSession();
 
 		assertAllDataRemoved();
 
 	}
 
 	protected boolean isCleanupTestDataRequired() { return false; }
 
 	protected void cleanupTestData() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete from java.lang.Object" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 
 	private void cleanupSession() {
 		if ( session != null && ! ( (SessionImplementor) session ).isClosed() ) {
 			if ( session.isConnected() ) {
 				session.doWork( new RollbackWork() );
 			}
 			session.close();
 		}
 		session = null;
 	}
 
 	public class RollbackWork implements Work {
 		public void execute(Connection connection) throws SQLException {
 			connection.rollback();
 		}
 	}
 
 	protected void cleanupTest() throws Exception {
 	}
 
 	@SuppressWarnings( {"UnnecessaryBoxing", "UnnecessaryUnboxing"})
 	protected void assertAllDataRemoved() {
 		if ( !createSchema() ) {
 			return; // no tables were created...
 		}
 		if ( !Boolean.getBoolean( VALIDATE_DATA_CLEANUP ) ) {
 			return;
 		}
 
 		Session tmpSession = sessionFactory.openSession();
 		try {
 			List list = tmpSession.createQuery( "select o from java.lang.Object o" ).list();
 
 			Map<String,Integer> items = new HashMap<String,Integer>();
 			if ( !list.isEmpty() ) {
 				for ( Object element : list ) {
 					Integer l = items.get( tmpSession.getEntityName( element ) );
 					if ( l == null ) {
 						l = 0;
 					}
 					l = l + 1 ;
 					items.put( tmpSession.getEntityName( element ), l );
 					System.out.println( "Data left: " + element );
 				}
 				fail( "Data is left in the database: " + items.toString() );
 			}
 		}
 		finally {
 			try {
 				tmpSession.close();
 			}
 			catch( Throwable t ) {
 				// intentionally empty
 			}
 		}
 	}
 
 }
diff --git a/working-5.0-migration-guide.md b/working-5.0-migration-guide.md
index b8e201de68..7fd1a1ef1d 100644
--- a/working-5.0-migration-guide.md
+++ b/working-5.0-migration-guide.md
@@ -1,55 +1,58 @@
 Working list of changes for 5.0
 ===================================
 
 * Switch from Configuration to ServiceRegistry+Metadata for SessionFactory building
 * `org.hibernate.hql.spi.MultiTableBulkIdStrategy#prepare` contract has been changed to account for Metadata
 * (proposed) `org.hibernate.persister.spi.PersisterFactory` contract, specifically building CollectionPersisters)
   has been changed to account for Metadata
 * extract `org.hibernate.engine.jdbc.env.spi.JdbcEnvironment` from `JdbcServices`; create
   `org.hibernate.engine.jdbc.env` package and moved a few contracts there.
 * Introduction of `org.hibernate.boot.model.relational.ExportableProducer` which will effect any
  `org.hibernate.id.PersistentIdentifierGenerator` implementations
 * Change to signature of `org.hibernate.id.Configurable` to accept `JdbcEnvironment` rather than just `Dialect`
 * Removed deprecated `org.hibernate.id.TableGenerator` id-generator
 * Removed deprecated `org.hibernate.id.TableHiLoGenerator` (hilo) id-generator
 * Deprecated `org.hibernate.id.SequenceGenerator` and its subclasses
 * cfg.xml files are again fully parsed and integrated (events, security, etc)
 * Removed the deprecated `org.hibernate.cfg.AnnotationConfiguration`
 * `Integrator` contract
 * `Configuration` is  no longer `Serializable`
 * `org.hibernate.dialect.Dialect.getQuerySequencesString` expected to retrieve catalog, schema, and increment values as well
 * properties loaded from cfg.xml through EMF did not previously prefix names with "hibernate." this is now made consistent.
+* removed AuditConfiguration in preference for new `org.hibernate.envers.boot.internal.EnversService`
+* changed AuditStrategy method parameters from (removed) AuditConfiguration to (new) EnversService
+
 
 TODOs
 =====
 * Still need to go back and make all "persistent id generators" to properly implement ExportableProducer
 * Add a setting to "consistently apply" naming strategies.  E.g. use the "join column" methods from hbm.xml binding.
 * Along with this ^^ consistency setting, split the implicit naming strategy for join columns into multiple methods - one for each usage:
    * many-to-one
    * one-to-one
    * etc
 
 
 Proposals for discussion
 ========================
 * Currently there is a "post-binding" hook to allow validation of the bound model (PersistentClass,
 Property, Value, etc).  However, the top-level entry points are currently the only possible place
 (per contract) to throw exceptions when a validation fails".  I'd like to instead consider a pattern
 where each level is asked to validate itself.  Given the current model, however, this is unfortunately
 not a win-win situation.  `org.hibernate.boot.model.source.internal.hbm.ModelBinder#createManyToOneAttribute`
 illustrates one such use case where this would be worthwhile, and also can illustrate how pushing the
 validation (and exception throwing down) can be less than stellar given the current model.  In the process
 of binding a many-to-one, we need to validate that any many-to-one that defines "delete-orphan" cascading
 is a "logical one-to-one".  There are 2 ways a many-to-one can be marked as a "logical one-to-one"; first
 is at the `<many-to-one/>` level; the other is through a singular `<column/>` that is marked as unique.
 Occasionally the binding of the column(s) of a many-to-one need to be delayed until a second pass, which
 means that sometimes we cannot perform this check immediately from the `#createManyToOneAttribute` method.
 What would be ideal would be to check this after all binding is complete.  In current code, this could be
 either an additional SecondPass or done in a `ManyToOne#isValid` override of `SimpleValue#isValid`.  The
 `ManyToOne#isValid` approach illustrates the conundrum... In the `ManyToOne#isValid` call we know the real
 reason the validation failed (non-unique many-to-one marked for orphan delete) but not the property name/path.
 Simply returning false from `ManyToOne#isValid` would instead lead to a misleading exception message, which
 would at least have the proper context to know the property name/path.
 * Should `org.hibernate.boot.MetadataBuilder` be folded into `org.hibernate.boot.MetadataSources`?
 * Consider an additional "naming strategy contract" specifically for logical naming.  This would be non-pluggable, and
 would be the thing that generates the names we use to cross-reference and locate tables, columns, etc.
\ No newline at end of file
