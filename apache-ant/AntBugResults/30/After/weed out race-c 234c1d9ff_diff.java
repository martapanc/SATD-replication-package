diff --git a/CONTRIBUTORS b/CONTRIBUTORS
index b2a74bbdb..009bb30bc 100644
--- a/CONTRIBUTORS
+++ b/CONTRIBUTORS
@@ -1,397 +1,398 @@
 Amongst other, the following people contributed to ant:
 
 Adam Blinkinsop
 Adam Bryzak
 Adam Sotona
 Aleksandr Ishutin
 Alex Rosen
 Alexei Yudichev
 Alexey Panchenko
 Alexey Solofnenko
 Alfred Theorin
 Alison Winters
 Andreas Ames
 Andreas Mross
 Andrew Eisenberg
 Andrew Everitt
 Andrew Stevens
 Andrey Urazov
 André-John Mas
 Andy Wood
 Anil K. Vijendran
 Anli Shundi
 Anthony Goubard
 Anthony Green
 Anthony Wat
 Antoine Baudoux
 Antoine Levy-Lambert
 Anton Mazkovoi
 Arjan Veenstra
 Arnaud Vandyck
 Arnout J. Kuiper
 Aslak Hellesôy
 Atsuhiko Yamanaka
 Avik Sengupta
 Balazs Fejes 2
 Bart Vanhaute
 Benjamin Burgess
 Ben Galbraith
 Ben Gertzfield
 Benoit Moussaud
 Bernd Dutkowski
 Bernhard Rosenkraenzer
 Brad Clark
 Brant Langer Gurganus
 Brian Curnow
 Brian Deitte
 Brian Felder
 Brian Repko
 Bruce Atherton
 Cedomir Igaly
 Charles Hudak
 Charlie Hubbard
 Chris Povirk
 Christian Knorr
 Christoph Gysin
 Christoph Wilhelms
 Christophe Labouisse
 Christopher A. Longo
 Christopher Charlier
 Clark Archer
 Clemens Hammacher
 Clement OUDOT
 Clive Brettingham-Moore
 Conor MacNeill
 Craeg Strong
 Craig Cottingham
 Craig R. McClanahan
 Craig Richardson
 Craig Ryan
 Craig Sandvik
 Curt Arnold
 Curtis White
 Cyrille Morvan
 D'Arcy Smith
 Dale Anson
 Dale Sherwood
 Dan Armbrust
 Daniel Henrique
 Daniel Ribagnac
 Daniel Spilker
 Daniel Trebbien
 Danno Ferrin
 Danny Yates
 Dante Briones
 Davanum Srinivas
 Dave Brondsema
 Dave Brosius
 David A. Herman
 David Crossley
 David Gärtner
 David S. Johnson
 David Kavanagh
 David LeRoy
 David Leal
 David M. Lloyd
 David Maclean
 David Rees
 Denis Hennessy
 Derek Slager
 Devon C. Miller
 Diane Holt
 dIon Gillard
 Dmitry A. Kuminov
 Dominique Devienne
 Donal Quinlan
 Don Brown
 Don Ferguson
 Don Jeffery
 Drew Sudell
 Eduard Wirch
 Edwin Woudt
 Eli Tucker
 Emmanuel Bourg
 Eric Barboni
 Eric Olsen
 Eric Pugh
 Erik Costlow
 Erik Hatcher
 Erik Langenbach
 Erik Meade
 Ernst de Haan
 Frank Harnack
 Frank Somers
 Frank Zeyda
 Frantisek Kucera
 Frederic Bothamy
 Frederic Lavigne
 Gary S. Weaver
 Gautam Guliani
 Gene-Sung Chung
 Georges-Etienne Legendre
 Gero Vermaas
 Gerrit Riessen
 Gilbert Rebhan
 Gilles Scokart
 Glenn McAllister
 Glenn Twiggs
 Greg Nelson
 Greg Roodt
 Greg Schueler
 Günther Kögel
 Harish Prabandham
 Haroon Rafique
 Hiroaki Nakamura
 Holger Engels
 Holger Joest
 Ignacio Coloma
 Ingenonsya France
 Ingmar Stein
 Irene Rusman
 Isaac Shabtay
 Ivan Ivanov
 J Bleijenbergh
 Jack J. Woehr
 James Duncan Davidson
 Jan Cumps
 Jan Matèrne
 Jan Mynarik
 Jan Stolze
 Jason Hunter
 Jason Pettiss
 Jason Salter
 Jason Yip
 Jay Dickon Glanville
 Jay Peck
 Jay van der Meer
 JC Mann
 J D Glanville
 Jean-Francois Brousseau
 Jean-Louis Boudart
 Jeff Gettle
 Jeff Martin
 Jeff Tulley
 Jeff Turner
 Jene Jasper
 Jeremy Mawson
 Jerome Lacoste
 Jesse Glick
 Jesse Stockall
 Jim Allers
 Joerg Wassmer
 Joey Richey
 Johann Herunter
 John Sisson
 Jon Dickinson
 Jon S. Stevens
 Jon Skeet
 Jose Alberto Fernandez
 Joseph Walton
 Josh Lucas
 Juerg Wanner
 Julian Simpson
 Justin Vallon
 Keiron Liddle
 Keith Visco
 Kevin Connor Arpe
 Kevin Greiner
 Kevin Jackson
 Kevin Ross
 Kevin Z Grey
 Kim Hansen
 Kirk Wylie
 Kyle Adams
 Larry Shatzer
 Larry Streepy
 Les Hughes
 Levi Cook
 lucas
 Ludovic Claude
 Maarten Coene
 Magesh Umasankar
 Maneesh Sahu
 Marcel Schutte
 Marcus B&ouml;rger
 Mario Frasca 
 Mariusz Nowostawski
 Mark A. Ziesemer
 Mark DeLaFranier
 Mark Hecker
 Mark R. Diggory
 Mark Salter
 Markus Kahl
 Martijn Kruithof
 Martin Landers
 Martin Poeschl
 Martin van den Bemt
 Martin von Gagern
 Mathieu Champlon
 Mathieu Peltier
 Matt Albrecht
 Matt Benson
 Matt Bishop
 Matt Foemmel
 Matt Grosso
 Matt Humphrey
 Matt Small
 Matt Wildig
 Matthew Hawthorne
 Matthew Inger
 Matthew Kuperus Heun
 Matthew Watson
+Matthias Bhend
 Michael Bayne
 Michael Clarke
 Michael Davey
 Michael J. Sikorsky
 Michael McCallum
 Michael Montuori
 Michael Newcomb
 Micheal Nygard
 Michael Saunders
 Miha
 Mike Davis
 Mike Roberts
 mnowostawski
 Mounir El Hajj
 Nathan Beyer
 Nick Chalko
 Nick Fortescue
 Nick Crossley
 Nick Pellow
 Nicola Ken Barozzi
 Nico Seessle
 Nigel Magnay
 Oliver Merkel
 Oliver Rossmueller
 Ondra Medek
 Omer Shapira
 Oystein Gisnas
 Patrick Altaie
 Patrick C. Beard
 Patrick Chanezon
 Patrick G. Heck (Gus Heck)
 Patrick Martin
 Paul Austin
 Paul Christmann
 Paul Galbraith
 Paul King
 Paulo Gaspar
 Pavan Bayyapu
 Pavel Jisl
 Pawel Zuzelski
 Peter B. West
 Peter Donald
 Peter Doornbosch
 Peter Hulst
 Peter Janes
 Peter Reilly
 Phil Hanna
 Philip Hourihane
 Phillip Wells
 Pierre Delisle
 Pierre Dittgen
 riasol
 R Handerson
 Rami Ojares
 Randy Watler
 Raphael Pierquin
 Ray Waldin
 Remie Bolte
 Richard Evans
 Richard Steele
 Rick Beton
 Robert Anderson
 Robert Clark
 Robert Flaherty
 Robert Shaw
 Robert Streich
 Robert Watkins
 Roberto Scaramuzzi
 Robin Green
 Robin Power
 Robin Verduijn
 Rob Oxspring
 Rob van Oostrum
 Rodrigo Schmidt
 Roger Vaughn
 Roman Ivashin
 Ronen Mashal
 Russell Gold
 Sam Ruby
 Sandra Metz
 Scott Carlson
 Scott Ellsworth
 Scott Johnson
 Scott M. Stirling
 Sean Egan
 Sean P. Kane
 Sebastien Arod
 Shiraz Kanga
 Sebastian Kantha
 Simon Law
 Simone Bordet
 Stefan Bodewig
 Stefan Heimann
 Stefano Mazzocchi
 Stephan Strittmatter
 Stephane Bailliez
 stephan
 Stephan Michels
 Stephen Chin
 Stephen Goetze
 Steve Cohen
 Steve Langley
 Steve Loughran
 Steve Morin
 Steve Wadsworth
 Steven E. Newton
 Sudheer Chigurupati
 Takashi Okamoto
 TAMURA Kent
 Taoufik Romdhane
 Tariq Master
 Thomas Aglassinger
 Thomas Butz
 Thomas Christen
 Thomas Christensen
 Thomas Haas
 Thomas Quas
 Tim Drury
 Tim Fennell
 Tim Stephenson
 Tim Whittington
 Timoteo Ohara
 Timothy Gerard Endres
 Tom Ball
 Tom Brus
 Tom Cunningham
 Tom Dimock
 Tom Eugelink
 Tom May
 Tomasz Bech
 Trejkaz Xaoza
 Ulrich Schmidt
 Uwe Schindler
 Valentino Miazzo
 Victor Toni
 Vimil Saju
 Vincent Legoll
 Volker Leidl
 Waldek Herka
 Wang Weijun
 Will Wang
 William Bernardet
 William Ferguson
 William Webber
 Wolf Siberski
 Wolfgang Baer
 Wolfgang Frech
 Wolfgang Glas
 Wolfgang Werner
 Xavier Hanin
 Xavier Witdouck
 Yohann Roussel
 Yuji Yamano
 Yves Martin
 Zach Garner
 Zdenek Wagner
diff --git a/WHATSNEW b/WHATSNEW
index 72b4d4e44..370ce7956 100644
--- a/WHATSNEW
+++ b/WHATSNEW
@@ -1,1019 +1,1023 @@
 Changes from Ant 1.9.3 TO current
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
 
 Fixed bugs:
 -----------
 
  * <import>/<include> failed when the importing file was loaded from an
    URI or a jar and it imported a file from the local file system via
    an absolute path.
    Bugzilla Report 50953
 
  * <import> could import the same resource twice when imported via
    different resource types.
    Bugzilla Report 55097
 
+ * several calls to File#mkdirs could fall victim to a race condition
+   where another thread already created the same directory.
+   Bugzilla Report 55290
+
 Other changes:
 --------------
 
 
 Changes from Ant 1.9.2 TO Ant 1.9.3
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
 
 Fixed bugs:
 -----------
 
  * <parallel> swallowed the status code of nested <fail> tasks.
    Bugzilla Report 55539.
 
  * a race condition could make <fixcrlf> tasks of parallel builds to
    interfere with each other.
    Bugzilla Report 54393.
 
  * <mail>'s mailport still didn't work properly when using smtps.
    Bugzilla Report 49267.
 
  * using attributes belonging to the if and unless namespaces
    made macrodef fail.
    Bugzilla Report 55885.
 
  * Ant 1.8 exec task changes have slowed exec to a crawl
    Bugzilla Report 54128.
 
  * Apt is not available under JDK 1.8
    Bugzilla Report 55922.
 
 
 Other changes:
 --------------
 
  * Documentation fix for if/unless attributes.  PR 55359.
 
  * tar entries with long link names are now handled the same way as
    entries with long names.
 
  * Addition of 'skipNonTests' attribute to <junit> and <batchtest>
    tasks to allow the tasks to skip classes that don't contain tests.
 
  * <filterset> now supports a nested <propertyset> to specify filters.
    Bugzilla Report 55794.
 
  * <xslt>'s params can now be typed.
    Bugzilla Report 21525.
 
  * build of Mac OS X pkg installer
    Bugzilla Report 55899.
 
 Changes from Ant 1.9.1 TO Ant 1.9.2
 ===================================
 
 Fixed bugs:
 -----------
 
  * Parsing of zip64 extra fields has become more lenient in order to
    be able to read archives created by DotNetZip and maybe other
    archivers as well.
 
  * TarInputStream should now properly read GNU longlink entries' names.
    Bugzilla Report 55040.
 
  * <java> and <exec> used to be too restrictive when evaluating
    whether a given set of options is compatible with spawning the new
    process.
    Bugzilla Report 55112.
 
 Other changes:
 --------------
 
  * <javadoc> will now post-process the generated in order to mitigate
    the frame injection attack possible in javadocs generated by Oracle
    JDKs prior to Java7 Update 25.  The vulnerability is known as
    CVE-2013-1571.
    There is an option to turn off the post-processing but it is only
    recommended you do so if all your builds use a JDK that's not
    vulnerable.
    Bugzilla Report 55132.
 
 Changes from Ant 1.9.0 TO Ant 1.9.1
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Users who have their own ProjectHelper implementation will need to change it because the import and include tasks
    will now default the targetPrefix to ProjectHelper.USE_PROJECT_NAME_AS_TARGET_PREFIX.
    Users using the default ProjectHelper2 with ant need not worry about this change done to fix Bugzilla Report 54940.
 
 
 Fixed bugs:
 -----------
 
  * Corrected XSLTC error in <junitreport>.
    Bugzilla Report 54641.
 
  * Provide more control over Zip64 extensions created by <zip> and
    related tasks.  In particular no Zip64 extensions will be used at
    all by the <jar> task family by default - this is required for jars
    to be readably by Java5.
    Bugzilla Report 54762.
 
  * Fixed loading of external dependencies in JUnit task.
    Bugzilla Report 54835.
 
  * Target rewriting for nested "include" only works when "as" is specified.
    See also "Changes that could break older environments"
    Bugzilla Report 54940.
 
 
 Other changes:
 --------------
 
  * strict attribute added to <signjar>.
    Bugzilla Report 54889.
 
  * simplifying Execute.getEnvironmentVariables since we are only running on Java 1.5 or higher now
 
  * Added conditional attributes.
    Bugzilla Report 43362
 
  * Recommending to upgrade jsch to 0.1.50, particularly if you are using Java 1.7.
    jsch is the library behind the sshexec and scp Ant tasks.
    Versions of jsch older than 0.1.50 fail randomly under Java 1.7 with an error message "verify: false"
 
 Changes from Ant 1.8.4 TO Ant 1.9.0
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Ant now requires at least Java 1.5 to compile and to run
 
  * FixCRLF used to treat the EOL value ASIS to convert to the system property
    line.separator. Specified was that ASIS would leave the EOL characters alone,
    the task now really leaves the EOL characters alone. This also implies that
    EOL ASIS will not insert a newline even if fixlast is set to true.
    Bugzilla report 53036
 
  * The CommandLauncher hierarchy that used to be a set of inner
    classes of Execute has been extracted to the
    org.apache.tools.ant.taskdefs.launcher package.
 
  * Any FileResource whose represented File has a parent also has a basedir.
 
  * Removing the Perforce Ant tasks replaced by tasks supplied by Perforce Inc.
 
  * Setting the default encoding of StringResource to UTF-8 instead of null
 
  * Upgrade JUnit 4 to JUnit 4.11
 
 Fixed bugs:
 -----------
 
  * Made VectorSet faster.
    Bugzilla Report 53622.
 
  * Incorrect URLs in Ant child POMs.
    Bugzilla Report 53617.
 
  * Subclasses of JUnitTask did not correctly find junit.jar.
    Bugzilla Report 53571.
 
  * External XML catalog resolver failed to use project basedir when given an
    unmentioned relative path like the internal resolver does.
    Bugzilla Report 52754.
 
  * Fixed some potential stream leaks.
    Bugzilla Reports 52738, 52740, 52742, 52743.
 
  * Updated documentation to fix spelling errors / broken links.
    Bugzilla Reports 53215, 53291, 53202
    
  * Unable to override system properties. It was not possible not to override
    system properties from the command line (or from a property file).
    Bugzilla Report 51792
    
  * <javac> by default fails when run on JDK 8.
    Bugzilla Report 53347.
 
  * ExtensionPoint doesn't work with nested import/include
    Bugzilla Report 53405.
 
  * <packagemapper> failed to strip the non-matched parts with
    handledirsep="true".
    Bugzilla Report 53399.
 
  * <expandproperties> filter caused a NullPointerException when input
    was empty.
    Bugzilla Report 53626.
 
  * <get> now supports HTTP redirects using status code 307.
    Bugzilla Report 54374.
 
  * ssh tasks prompt for kerberos username/password under Java 7
    Bugzilla Report 53437.
 
  * Zip task on <mappedresources> that excludes certain files by way of the mapper resulted in a NullPointerException
    Bugzilla Report 54026
 
  * The ant launcher script should properly detect JAVA_HOME on
    MacOS X 10.7
    Bugzilla Report 52632
 
  * Depend task does not handle invokeDynamic constant pool entries - java.lang.ClassFormatError: Invalid Constant Pool entry Type 18
    Bugzilla Report 54090
 
  * Base64Converter not properly handling bytes with MSB set (not masking byte to int conversion)
    Bugzilla Report 54460
 
  * The size resource comparator would return wrong results if file
    sizes differed by more than 2 GB.
    Bugzilla Report 54623
 
  * Unable to encode properly into UTF-8 when the system property file.encoding is
    set to ANSI_X3.4-1968.
    Bugzilla Report 54606
 
  * JUnit4 tests marked @Ignore do not appear in XML output
    Bugzilla Report 43969
 
 Other changes:
 --------------
 
  * merged the ZIP package from Commons Compress, it can now read
    archives using Zip64 extensions (files and archives bigger that 4GB
    and with more that 64k entries).
 
  * a new task <commandlauncher> can be used to configure the
    CommandLauncher used by Ant when forking external programs or new
    Java VMs.
    Bugzilla Report 52706.
 
  * merged the TAR package from Commons Compress, it can now read
    archives using POSIX extension headers and STAR extensions.
 
  * merged the BZIP2 package from Commons Compress, it can now
    optionally read files that contain multiple streams properly.
 
  * <bunzip2> will now properly expand files created by pbzip2 and
    similar tools that create files with multiple bzip2 streams.
 
  * <tar> now supports a new "posix" option for longfile-mode which
    will make it create PAX extension headers for long file names.  PAX
    extension headers are supported by all modern implementations of
    tar including GNU tar.
    This option should now be used in preference to "warn" or "gnu" as
    it is more portable.  For backwards compatibility reasons "warn"
    will still create "gnu" extensions rather than "posix" extensions.
 
  * The ProjectHelper class now exposes a method to be used by third party
    implementations to properly resolve the binding between target extensions
    and extension points.
    Bugzilla Report 53549.
 
  * Make extension point bindable to imported prefixed targets
    Bugzilla Report 53550.
 
  * Add the possibility to register a custom command line argument processor.
    See org.apache.tools.ant.ArgumentProcessor and manual/argumentprocessor.html
 
  * add the possibility to suppress stdout in the sshexec task.
    Bugzilla Report 50270.
 
  * add an encoding attribute to the contains selector.
    This will be useful to use the contains selector if the encoding of the VM is different from the encoding
    of the files being selected.
 
  * support for GNU Classpath.
    Bugzilla report 54760.
 
 Changes from Ant 1.8.3 TO Ant 1.8.4
 ===================================
 
 Fixed bugs:
 -----------
 
  * Ported libbzip2's fallback sort algorithm to CBZip2OutputStream to
    speed up compression in certain edge cases.  Merge from Commons
    Compress.
 
    Using specially crafted inputs this can be used as a denial of
    service attack.
    See http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2098
 
 Changes from Ant 1.8.2 TO Ant 1.8.3
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * The Enumeration returned by AntClassLoader#getResources used to
    return null in nextElement after hasNextElement would return false.
    It has been changed to throw a NoSuchElementException instead so
    that it now adheres to the contract of java.util.Enumeration.
    Bugzilla Report 51579.
 
 Fixed bugs:
 -----------
 
  * Removed buggy duplicate JAR list in RPM mode.
    Bugzilla Report 52556.
 
  * Launcher fixed to pass the right class loader parent.
    Bugzilla Report 48633.
 
  * <junitreport> mishandled ${line.separator}.
    Bugzilla Report 51049.
 
  * <junitreport> did not work in embedded environments on JDK 7.
    Nor did <xslt> when using Xalan redirects.
    Bugzilla Report 51668, 52382.
 
  * Encoding of unicode escape sequences by the property file task
    Bugzilla Report 50515.
 
  * The code that implicitly sets the -source switch if only -target
    has been specified in <javac> was broken for Java 5 and 6.
    Bugzilla Report 50578.
 
  * MailLogger ignore the Maillogger.starttls.enable property.
    Bugzilla Report 50668.
 
  * Delete task example does not work
    Bugzilla Report 50816.
 
  * <splash>'s proxy handling has been delegated to <setproxy>
    internally so the two tasks are consistent.  <splash>'s way of not
    setting a proxy caused problems with other Java libraries.
    Bugzilla Report 50888.
 
  * Include task breaks dependencies or extension-points for multiple
    files.
    Bugzilla Report 50866.
 
  * Read on System.in hangs for forked java task.
    Bugzilla Report 50960.
 
  * FileResource specified using basedir/name attributes was non-functional.
 
  * Resource collection implementation of mapped PropertySet returned
    unusable resources.
 
  * The hasmethod condition failed with a NullPointerException when
    ignoresystemclasses is true and Ant tried to load a "restricted
    class" - i.e. a class that the Java VM will only accept when loaded
    via the bootclassloader (a java.* class).
    It will now fail with a more useful error message.
    Bugzilla Report 51035.
 
  * Exec task may mix the stderr and stdout output while logging it
    Bugzilla Report 50507.
 
  * Missing space between "finished" and timestamp in task/target 
    finish message from ProfileLogger.
    Bugzilla Report 51109.
 
  * Redirecting the output of a java, exec or apply task could print in the
    error output stream some "Pipe broken" errors.
    Bugzilla Report 48789.
 
  * ZipFile failed to clean up some resources which could lead to
    OutOfMemoryException while unzipping large archives.
    A similar problem in ZipArchiveOutputStream has been fixed as well.
    Bugzilla Report 42696.
 
  * quiet attribute added to the copy and move tasks, to be used together
    with failonerror=false, so warnings won't get logged 
    Bugzilla Report 48789.
 
  * System.in was closed and not readable anymore by the DefaultInputHandler 
    when Ant is used via its Java API.
    Bugzilla Report 51161
 
  * <sync> only supported a single non-fileset resource collection even
    though the manual said it could be multiple.
 
  * <sync> didn't work properly when working on resource collections.
    Bugzilla Report 51462.
 
  * <augment> cause a NullPointerException if it was used in a target
    that was invoked by multiple targets from the command line.
    Bugzilla Report 50894.
 
  * The ZipFile class could read past the start of the file if the
    given file is not a ZIP archive and it is smaller than the size of
    a ZIP "end of central directory record".
 
  * <javac> would create the empty package-info.class file in the wrong
    directory if no destdir was specified.  Note it may still pick the
    wrong directory if you specify more than one source directory but
    no destDir.  It is highly recommended that you always explicitly
    specify the destDir attribute.
    Bugzilla Report 51947.
 
  * packagemapper now honors the handleDirSep attribute.
    Bugzilla Report 51086.
 
  * the attributes of macrodef tasks had their values run through
    property expansion twice. Still true by default, but can be disabled.
    Bugzilla Report 42046.
 
  * jvc doesn't like it if source file names in argument files are
    quoted.
    Bugzilla Report 31667.
 
  * ZipFile didn't work properly for archives using unicode extra
    fields rather than UTF-8 filenames and the EFS-Flag.
 
  * Access to DirectoryScanner's default excludes wasn't synchronized.
    Bugzilla Report 52188.
 
  * When a Project instance was created by a custom tasks its
    createTask method didn't work.
    Bugzilla Report 50788.
 
 Other changes:
 --------------
 
  * -f/-file/-buildfile accepts a directory containing build.xml.
 
  * The <javacc>, <jjtree> and <jjdoc> now support a new maxmemory
    attribute.
    Bugzilla Report 50513.
 
  * the documented inputstring attribute of sshexec has been
    implemented and the actually existing attribute inputproperty
    documented.
    Bugzilla Report 50576.
 
  * The concat task now permits the name of its exposed resource
    by means of its 'resourcename' attribute.
 
  * The expandproperties filter now accepts a nested propertyset
    which, if specified, provides the properties for expansion.
    Bugzilla Report 51044.
 
  * <junit filtertrace="true"/> will no longer filter out the very
    first line of the stacktrace containing the original exception
    message even if it matches one of the filter expressions.
 
  * Upgraded to Apache AntUnit 1.2
 
  * Provide read access to Mkdir.dir.  Bugzilla Report 51684.
 
  * <delete> and <move> have a new attribute performGCOnFailedDelete
    that may - when set to true - help resolve some problems with
    deleting empty directories on NFS shares.
    Bugzilla Report 45786.
 
  * <loadfile> and <loadresource> used to log at level INFO to signal a
    property hasn't been set when the resource was empty even if the
    quiet attribute was set to true.  They will now use VERBOSE
    instead.
    Bugzilla Report 52107.
 
  * <javac> has a new attribute createMissingPackageInfoClass that can
    be set to false to prevent Ant from creating empty dummy classes
    used for up-to-date-ness checks.
    Bugzilla Report 52096.
 
  * URLResources#isExists has become less noisy.
    Bugzilla Report 51829.
 
  * The <retry> task has a new optional attribute retryDelay that can
    be used to make the task sleep between retry attempts.
    Bugzilla Report 52076.
 
  * <signjar> has new attributes that control the signature and digest
    algorithms.
    Bugzilla Report 52344.
 
  * Initial support for Java 8.
 
  * <sshexec> can optionally create a pseudo terminal (like ssh -t)
    Bugzilla Report 52554.
 
 Changes from Ant 1.8.1 TO Ant 1.8.2
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Prior to Ant 1.8.0 the <copy> task and several other tasks would
    overwrite read-only destination files.  Starting with 1.8.0 they
    would only do so under special circumstances.  Ant 1.8.2 now
    consistently won't replace a read-only file by default. The same is
    true for a number of other tasks.
    The <copy>, <move> and <echo> tasks now have a new force attribute
    and <concat> has a new forceReadonly attribute that can be used to
    make the task overwrite read-only destinations.
    Bugzilla Report 49261.
 
  * Removed ant-nodeps.jar; it is now merged into ant.jar.
 
  * DOMElementWriter#encode used to employ special code before encoding
    ampersands so that &#123; remained &#123; rather than being turned
    into &amp;#123;.  This is no longer the case, ampersands will now
    be encoded unconditionally.
    Also DOMElementWriter#encodeData will treat CDATA sections containing a
    literal "]]>" sequence different now - it will split the CDATA
    section between the second "]" and ">" and create two sections.
    This affects <echoxml> task as well as the XML logger or JUnit
    formatter where ampersands will now always get encoded.
    In addition DOMElementWriter will now replace the characters \t, \r
    and \n in attribute values by entity references.
    Bugzilla Report 49404.
 
  * The list elements returned by ProjectHelper#getExtensionStack are
    now String arrays of length 3 rather than 2 in order to support the
    onMissingExtensionPoint attribute.
    Bugzilla Report 49473.
 
  * When using <property file="..." prefix="..."/> properties defined
    inside the same file will only get used in expansions if the ${}
    reference uses the same prefix.  This is different from Ant 1.8.1
    but is the same behavior Ant 1.8.0 and earlier exhibited.
    A new attribute prefixValues can be used to re-enable the behavior
    of Ant 1.8.1.
    Bugzilla Report 49373.
 
  * The files and directories used by Git, Mercurial and Bazaar to
    store their information are now excluded by the defaultexcludes.
    Bugzilla Report 49624.
 
  * The <junit> task no longer generates TestListener events - which
    have been introduced in ant 1.7.0 - by default.  The task has a new
    attribute enableTestListenerEvents and a new "magic" property
    ant.junit.enabletestlistenerevents has been added that can be used
    to reinstate the old behavior.
 
 Fixed bugs:
 -----------
 
  * hostinfo now prefers addresses with a hostname over addresses without 
    a hostname, provided the addresses have the same scope.
    For local lookup, no IP address will be put in NAME / DOMAIN anymore.
    For remote lookup, if a host name was provided and only an IP address is 
    found, the IP address will no longer overwrite the host name provided to the
    task.
    Bugzilla Report 49513
 
  * mmap-based file copy problems under JDK 1.4 on Linux.
    Bugzilla Report 49430.
 
  * The Sun JVM tries to mmap the entire file during a copy. 
    For large files this is not feasible. 
    We now explicitly request to copy at most 16 MiB per request.
    Bugzilla Report 49326.
 
  * DemuxInputStream.read() should return unsigned values
    Bugzilla Report 49279.
 
  * The MIME mailer ignored the port parameter when using SSL.
    Bugzilla Report 49267.
 
  * <xslt> ignored the classpath when using the default TraX processor.
    Bugzilla Report 49271.
 
  * <checksum>'s totalproperty only worked reliably if the same file
    name didn't occur inside more than one directory.
    Bugzilla Report 36748.
 
  * <ftp> could fail to download files from remote subdirectories under
    certain circumstances.
    Bugzilla Report 49296.
 
  * <junit> will now produce better diagnostics when it fails to delete
    a temporary file.
    Bugzilla Report 49419.
 
  * Ant would often scan directories even though there were known to
    only hold excluded files when evaluating filesets.  This never
    resulted in wrong results but degraded performance of the scan
    itself.
    Bugzilla Report 49420.
 
  * <javac> failed for long command lines on OS/2.
    Bugzilla Report 49425.
 
  * <junitreport> did not handle encodings well for stdout/stderr.
    Bugzilla Report 49418.
 
  * <junit> could issue a warning about multiple versions of Ant on the
    CLASSPATH if two CLASSPATH entries differed in case on a
    case-insensitive file system.
    Bugzilla Report 49041.
 
  * The <restrict> resource collection was checking every resource even if
    we actually just want the first one, like in the example of use of
    resourcelist in the documentation (getting the first available resource
    from a mirror list).
 
  * A race condition could lead to build failures if multiple <mkdir>
    tasks were trying to create the same directory.
    Bugzilla Report 49572.
 
  * the toString() method of the Resources class - and thus any
    ${toString:} expansion of a reference to a <resources> element -
    didn't iterate over its nested elements if it hadn't done so prior
    to the toString invocation already.
    Bugzilla Report 49588.
 
  * <apply> in parallel mode didn't work together with a nested
    <redirector> if maxparallel was <= 0 (the default) or no source
    files matched.
    Bugzilla Report 49594.
 
  * <jar filesetmanifest="merge"> didn't work for manifests added via
    <zipfileset>s that used the prefix or fullpath attributes.
    Bugzilla Report 49605.
 
  * <tempfile createfile="true"> would cause an error unless the prefix
    attribute has been specified.
    Bugzilla Report 49755.
 
  * If forked, after finished <java> was still reading the input stream
    for a bunch of characters, then stealing them from a following <input>.
    Bugzilla Report 49119.
 
  * Ant could be leaking threads for each forked process (started by
    <exec>, <apply>, <java> or similar tasks) that didn't receive input
    from a resource or string explicitly.
    Bugzilla Report 49587.
 
  * Project#setDefault threw an exception when null was passed in as
    argument, even though the Javadoc says null is a valid value.
    Bugzilla Report 49803.
 
  * runant.py would swallow the first argument if CLASSPATH wasn't set.
    Bugzilla Report 49963.
 
  * <taskdef> failed to load resources from jar files contained in a
    directory that has a "!" in its name.
    Bugzilla Report 50007.
 
  * ant.bat exit strategy improvements and issues
    make the exit codes work in environments where 4NT or MKS are installed
    Bugzilla Report 41039.
 
  * <signjar> would fail if used via its Java API and the File passed
    into the setJar method was not "normalized" (i.e. contained ".."
    segments).
    Bugzilla Report 50081.
 
  * <delete> ignored <fileset>'s errorOnMissingDir attribute
    Bugzilla Report 50124.
 
  * <symlink> failed to close files when reading a list of symbolic
    links from a properties file.
    Bugzilla Report 50136.
 
  * <parallel> could allow tasks to start executing even if a task
    scheduled to run before them timed out.
    Bugzilla Report 49527.
 
  * If a <junit> batch with multiple tests times out Ant logs a message
    about a test named Batch-With-Multiple-Tests since 1.8.0 but the
    logic that determined the Java package of this pseudo-test has been
    wrong.
    Bugzilla Report 45227.
 
  * <propertyfile> didn't preserve the original linefeed style when
    updating a file.
    Bugzilla Report 50049.
 
  * <zip>'s whenEmpty behavior never consulted the non-fileset
    resources so the task could fail even though resources have been
    provided using non-fileset resource collections.
    Bugzilla Issue 50115.
 
 *  ftp chmod could throw a NPE.
    Bugzilla report 50217.
 
 *  The project help (-p option in the command line) will now print
    the dependencies of the targets in debug mode (-d on the command
    line)
 
 Other changes:
 --------------
 
  * <concat>'s force attribute has been deprecated in favor of a new
    overwrite attribute that is consistent with <copy>'s attribute
    names.
 
  * You can now specify a list of methods to run in a JUnit test case.
    Bugzilla Report 34748.
 
  * properties in files read because of the -propertyfile command line
    option will now get resolved against other properties that are
    defined before the project starts executing (those from the same or
    earlier -propertfiles or defined via the -D option).
    Bugzilla Report 18732.
 
  * <pathelement>s can now contain wildcards in order to use wildcard
    CLASSPATH entries introduced with Java6.
    The wildcards are not expanded or even evaluated by Ant and will be
    used literally.  The resulting path may be unusable as a CLASSPATH
    for Java versions prior to Java6 and likely doesn't mean anything
    when used in any other way than a CLASSPATH for a forked Java VM. 
    Bugzilla Report 46842.
 
  * A new attribute allows targets to deal with nonexistent extension
    points, i.e. they can extend an extension-point if it has been
    defined or silently work as plain targets if it hasn't.  This is
    useful for targets that get included/imported in different
    scenarios where a given extension-point may or may not exist.
    Bugzilla Report 49473.
 
  * Ant now logs a warning message if it fails to change the file
    modification time in for example when using <touch> or preserving
    timestamps in various tasks.
    Bugzilla Report 49485.
 
  * ProjectHelpers can now be installed dynamically via the <projecthelper>
    Ant task.
 
  * <import> is now able to switch to the proper ProjectHelper to parse
    the imported resource. This means that several kinds of different build
    files can import each other.
 
  * <copy tofile=""> now also works for non-filesystem resources.
    Bugzilla Report 49756.
 
  * The <linecontainsregexp> filter now supports a casesensitive
    attribute.
 
  * The <containsregexp> selector now supports casesensitive, multiline
    and singleline attributes.
    Bugzilla Report 49764.
 
  * A new <cutdirsmapper> can be used like wget's --cut-dirs option to
    strip leading directories from file names.
 
  * <javah> now supports the GNU project's gcjh compiler.
    Bugzilla Report 50149.
 
  * <checksum> supports additional views of a file's path as elements
    for a custom pattern.
    Bugzilla Report 50114.
 
  * JUnit XMLResultAggregator logs the stack trace of caught IO exceptions
    in verbose runs.
    Bugzilla Report 48836.
 
  * StringUtils.parseHumanSizes() should turn parse failures into
    BuildExceptions.
    Bugzilla Report 48835.
 
  * New task <bindtargets> to make a list of targets bound to some
    specified extension point.
 
  * Initial support for OpenJDK7 has been added.
 
  * Ant now uses java.net.CookieStore rather than
    java.util.ServiceLocator to detect whether the environment is a
    Java 1.6 system.  This means releases of gcj/gij at the time of
    this release of Ant are detected as Java 1.5 and not 1.6.
    Bugzilla Report 50256.
 
  * It is now possible to write a compiler adapter for <javac> that
    compiles sources with extensions other than .java (but that still
    compile to .class files).
    Bugzilla Report 48829.
 
  * The performance of VectorSet#add(Object) has been improved which
    should also benefit any operation that scans directories in Ant.
    Bugzilla Report 50200.
 
 Changes from Ant 1.8.0 TO Ant 1.8.1 
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * ant-trax.jar is no longer produced since TrAX is included in JDK 1.4+.
 
  * Ant no longer ships with Apache Xerces-J or the XML APIs but relies
    on the Java runtime to provide a parser and matching API versions.
 
  * The stylebook ant task and the ant-stylebook.jar are removed.
 
 Fixed bugs:
 -----------
 
  * Tasks that iterate over task or type definitions, references or
    targets now iterate over copies instead of the live maps to avoid
    ConcurrentModificationExceptions if another thread changes the
    maps.
    Bugzilla Report 48310.
 
  * The filesmatch condition threw a NullPointerException when
    comparing text files and the second file contained fewer lines than
    the first one.
    Bugzilla Report 48715.
 
  * Regression: The <ear> task would allow multiple
    META-INF/application.xml files to be added.
    Bugzilla Report 6836.
 
  * VectorSet#remove(Object) would fail if the size of the vector
    equaled its capacity.
 
  * Regression : ant -diagnostics was returning with exit code 1
    Bugzilla Report 48782
 
  * Fix for exec task sometimes inserts extraneous newlines
    Bugzilla Report 48746
 
  * SymlinkTest#testSymbolicLinkUtilsMethods failing on MacOS
    Bugzilla Report 48785.
 
  * If <concat>'s first resourcecollection child is a <resources>,
    any subsequently added child resourcecollection joins the first.
    Bugzilla Report 48816.
 
  * <get> with an invalid URL could trigger an NPE in some JVMs.
    Bugzilla Report 48833
 
  * Broken Pipe issue under Ubuntu Linux
    Bugzilla Report 48789
 
  * Properties wrongly read from file or not update during read
    Bugzilla Report 48768
 
  * AntClassLoader in Ant 1.8.0 has been considerably slower than in
    1.7.1
    Bugzilla Report 48853
 
  * ANT_CMD_LINE_ARGS are rippling through lower level Ant usage 
    Bugzilla Report 48876
 
  * email : IO error sending mail with plain mimetype
    Bugzilla Report 48932
 
  * the complete-ant-cmd.pl script failed to create a proper cache of
    target if "ant -p" failed.
    Bugzilla Report 48980
 
  * <rmic>'s sourcebase attribute was broken.
    Bugzilla Report 48970
 
  * <copy>'s failonerror didn't work as expected when copying a single
    element resource collection to a file.
    Bugzilla Report 49070
 
  * <get> no longer followed redirects if the redirect URL was relative
    and not an absolute URL.
    Bugzilla Report 48972
 
  * fixed a performance degradation in the code that expands property
    references.
    Bugzilla Reports 48961 and 49079
 
  * <jar filesetmanifest="merge"> was broken on Windows.
    Bugzilla Report 49090
 
  * <symlink> delete failed if the link attribute was a relative path
    to a link inside the current directory without a leading ".".
    Bugzilla Report 49137
 
  * <telnet> and <rexec> failed to find the expected strings when
    waiting for responses and thus always failed.
    Bugzilla Report 49173
 
 Other changes:
 --------------
 
  * Project provides new get methods that return copies instead of the
    live maps of task and type definitions, references and targets.
 
  * Ant is now more lenient with ZIP extra fields and will be able to
    read archives that it failed to read in earlier versions.
    Bugzilla Report 48781.
 
  * The <zip> family of tasks has been sped up for bigger archives.
    Bugzilla Report 48755.
 
  * Add removeKeepExtension option to NetRexxC task.
    Bugzilla Report 48788.
 
  * Add prefix attribute to loadproperties task.
 
  * Add resource attribute to length task.
 
  * PropertyResource will effectively proxy another Resource if ${name}
    evaluates to a Resource object.
 
  * Added forcestring attribute to equals condition to force evaluation
    of Object args as strings; previously only API-level usage of the
    equals condition allowed Object args, but Ant 1.8.x+ property
    evaluation may yield values of any type.
 
  * BuildFileTest.assertPropertyUnset() fails with a slightly more 
    meaningful error message
    Bugzilla Report 48834
 
  * <junit> will now throw an exception if a test name is empty.  This
    used to manifest itself in unrelated errors like
    Bugzilla Report 43586.
 
  * A change that made <exec> more reliable on Windows (Bugzilla Report
    5003) strongly impacts the performance for commands that execute
    quickly, like attrib.  Basically no single execution of a command
    could take less than a second on Windows.
    A few timeouts have been tweaked to allow these commands to finish
    more quickly but still they will take longer than they did with Ant
    1.7.1.
    Bugzilla Report 48734.
 
  * Added SimpleBigProjectLogger, intermediate between NoBannerLogger and
    BigProjectLogger.
 
  * <mappedresources> supports new attributes enablemultiplemappings
    and cache.
 
  * Added the augment task to manipulate existing references via Ant's basic
    introspection mechanisms.
 
 Changes from Ant 1.8.0RC1 TO Ant 1.8.0
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * the appendtolines filter has been renamed to suffixlines.
 
 Fixed bugs:
 -----------
 
  * stack traces were not reported at all by <junit/>
    when filtertrace="on", which is the default.
 
  * ant.bat can now also process the -noclasspath switch when it is 
    the first switch on a command line.
    Bugzilla Report 48186.
 
  * <fixcrlf> now tries to delete the created temporary files earlier.
    Bugzilla Report 48506.
 
  * the implementation of <zip> had been changed in a way that broke
    the jarjar links task and protentially other third-party subclasses
    as well.
    Bugzilla Report 48541.
 
  * <scp> task didn't report build file location when a remote operation failed
    Bugzilla Report 48578.
 
  * <propertyfile> would add the same comment and a date line each time
    it updated an existing property file.
    Bugzilla Report 48558.
 
  * <sound> didn't work properly in recent Java VMs.
    Bugzilla Report 48637.
 
 Other changes:
 --------------
 
 Changes from Ant 1.7.1 TO Ant 1.8.0RC1
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * if and unless attributes (on <target> as well as various tasks and other
    elements) have long permitted ${property} interpolation. Now, if the result
    evaluates to "true" or "false" (or "yes", "no", "on", "off"), that boolean
    value will be used; otherwise the traditional behavior of treating the value
    as a property name (defined ~ true, undefined ~ false) is used. Existing
    scripts could be broken if they perversely defined a property named "false"
    and expected if="false" to be true, or used if="true" expecting this to be
    triggered only if a property named "true" were defined.
 
  * Ant now requires Java 1.4 or later.
 
  * Improved handling of InterruptException (lets suppose someone/thing
    is trying to kill the thread when we receive an
    InterruptException), when an InterruptException is received, we do
    not wait anymore in a while loop till the end time has been
    reached.
    Bugzilla Report 42924.
 
  * Refactor PropertyHelper and introspection APIs to make extension
    more granular and support setting task/type attribute values to
    objects decoded by custom PropertyEvaluator delegates. Also add
    <propertyhelper> task for registering delegates and/or replacing
    the registered PropertyHelper instance.
    Bugzilla Report 42736.
 
  * Added a restricted form of typedef called <componentdef>. This
    allows definition of elements that can only be within tasks or
    types. This method is now used to define conditions, selectors,
    comparators and filterreaders. This means that tasks may now have
    nested conditions just by implementing the Condition interface,
diff --git a/contributors.xml b/contributors.xml
index 7853a41af..e3a1bcee2 100644
--- a/contributors.xml
+++ b/contributors.xml
@@ -1,1587 +1,1595 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 -->
 <!DOCTYPE contributors
 [
 <!ELEMENT name (first?, middle?, last)>
 <!ELEMENT contributors (introduction, name+)>
 <!ELEMENT first (#PCDATA)>
 <!ELEMENT introduction (#PCDATA)>
 <!ELEMENT middle (#PCDATA)>
 <!ELEMENT last (#PCDATA)>
 ]
 >
 
 <contributors>
   <introduction>
   These are some of the many people who have helped Ant become so successful.
   </introduction>
   <name>
     <first>Adam</first>
     <last>Blinkinsop</last>
   </name>
   <name>
     <first>Adam</first>
     <last>Bryzak</last>
   </name>
   <name>
     <first>Adam</first>
     <last>Sotona</last>
   </name>
   <name>
     <first>Aleksandr</first>
     <last>Ishutin</last>
   </name>
   <name>
     <first>Alex</first>
     <last>Rosen</last>
   </name>
   <name>
     <first>Alexei</first>
     <last>Yudichev</last>
   </name>
   <name>
     <first>Alexey</first>
     <last>Panchenko</last>
   </name>
   <name>
     <first>Alexey</first>
     <last>Solofnenko</last>
   </name>
   <name>
     <first>Alfred</first>
     <last>Theorin</last>
   </name>
   <name>
     <first>Alison</first>
     <last>Winters</last>
   </name>
   <name>
     <first>Andreas</first>
     <last>Ames</last>
   </name>
   <name>
     <first>Andrew</first>
     <last>Eisenberg</last>
   </name>
   <name>
     <first>Andrew</first>
     <last>Everitt</last>
   </name>
   <name>
     <first>Andrew</first>
     <last>Stevens</last>
   </name>
   <name>
     <first>Andrey</first>
     <last>Urazov</last>
   </name>
   <name>
     <first>André-John</first>
     <last>Mas</last>
   </name>
   <name>
     <first>Andy</first>
     <last>Wood</last>
   </name>
   <name>
     <first>Anil</first>
     <middle>K.</middle>
     <last>Vijendran</last>
   </name>
   <name>
     <first>Anli</first>
     <last>Shundi</last>
   </name>
   <name>
     <first>Anthony</first>
     <last>Green</last>
   </name>
   <name>
     <first>Anthony</first>
     <last>Wat</last>
   </name>
   <name>
     <first>Antoine</first>
     <last>Baudoux</last>
   </name>
   <name>
     <first>Antoine</first>
     <last>Levy-Lambert</last>
   </name>
   <name>
     <first>Anton</first>
     <last>Mazkovoi</last>
   </name>
   <name>
     <first>Arjan</first>
     <last>Veenstra</last>
   </name>
   <name>
     <first>Arnaud</first>
     <last>Vandyck</last>
   </name>
   <name>
     <first>Arnout</first>
     <middle>J.</middle>
     <last>Kuiper</last>
   </name>
   <name>
     <first>Aslak</first>
     <last>Helles&#244;y</last>
   </name>
   <name>
     <first>Atsuhiko</first>
     <last>Yamanaka</last>
   </name>
   <name>
     <first>Avik</first>
     <last>Sengupta</last>
   </name>
   <name>
     <first>Balazs</first>
     <last>Fejes 2</last>
   </name>
   <name>
     <first>Bart</first>
     <last>Vanhaute</last>
   </name>
   <name>
     <first>Benjamin</first>
     <last>Burgess</last>
   </name>
   <name>
     <first>Ben</first>
     <last>Galbraith</last>
   </name>
   <name>
     <first>Ben</first>
     <last>Gertzfield</last>
   </name>
   <name>
     <first>Benoit</first>
     <last>Moussaud</last>
   </name>
   <name>
     <first>Bernd</first>
     <last>Dutkowski</last>
   </name>
   <name>
     <first>Bernhard</first>
     <last>Rosenkraenzer</last>
   </name>
   <name>
     <first>Brad</first>
     <last>Clark</last>
   </name>
   <name>
     <first>Brant</first>
     <middle>Langer</middle>
     <last>Gurganus</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Curnow</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Deitte</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Felder</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Repko</last>
   </name>
   <name>
     <first>Bruce</first>
     <last>Atherton</last>
   </name>
   <name>
     <first>Charles</first>
     <last>Hudak</last>
   </name>
   <name>
     <first>Charlie</first>
     <last>Hubbard</last>
   </name>
   <name>
     <first>Chris</first>
     <last>Povirk</last>
   </name>
   <name>
     <first>Christian</first>
     <last>Knorr</last>
   </name>
   <name>
     <first>Christoph</first>
     <last>Gysin</last>
   </name>
   <name>
     <first>Christoph</first>
     <last>Wilhelms</last>
   </name>
   <name>
     <first>Christophe</first>
     <last>Labouisse</last>
   </name>
   <name>
     <first>Christopher</first>
     <middle>A.</middle>
     <last>Longo</last>
   </name>
   <name>
     <first>Christopher</first>
     <last>Charlier</last>
   </name>
   <name>
     <first>Clark</first>
     <last>Archer</last>
   </name>
   <name>
     <first>Clemens</first>
     <last>Hammacher</last>
   </name>
   <name>
     <first>Clement</first>
     <last>OUDOT</last>
   </name>
   <name>
     <first>Clive</first>
     <last>Brettingham-Moore</last>
   </name>
   <name>
     <first>Conor</first>
     <last>MacNeill</last>
   </name>
   <name>
     <first>Craeg</first>
     <last>Strong</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Cottingham</last>
   </name>
   <name>
     <first>Craig</first>
     <middle>R.</middle>
     <last>McClanahan</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Ryan</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Richardson</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Sandvik</last>
   </name>
   <name>
     <first>Curt</first>
     <last>Arnold</last>
   </name>
   <name>
     <first>Curtis</first>
     <last>White</last>
   </name>
   <name>
     <first>Cyrille</first>
     <last>Morvan</last>
   </name>
   <name>
     <first>D'Arcy</first>
     <last>Smith</last>
   </name>
   <name>
     <first>Dale</first>
     <last>Anson</last>
   </name>
   <name>
     <first>Dale</first>
     <last>Sherwood</last>
   </name>
   <name>
     <first>Dan</first>
     <last>Armbrust</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Henrique</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Ribagnac</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Spilker</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Trebbien</last>
   </name>
   <name>
     <first>Danno</first>
     <last>Ferrin</last>
   </name>
   <name>
     <first>Danny</first>
     <last>Yates</last>
   </name>
   <name>
     <first>Dante</first>
     <last>Briones</last>
   </name>
   <name>
     <first>Davanum</first>
     <last>Srinivas</last>
   </name>
   <name>
     <first>Dave</first>
     <last>Brondsema</last>
   </name>
   <name>
     <first>Dave</first>
     <last>Brosius</last>
   </name>
   <name>
     <first>David</first>
     <last>A.</last>
   </name>
   <name>
     <first>David</first>
     <last>Crossley</last>
   </name>
   <name>
     <first>David</first>
     <last>G&#228;rtner</last>
   </name>
   <name>
     <first>David</first>
     <middle>S.</middle>
     <last>Johnson</last>
   </name>
   <name>
     <first>David</first>
     <last>Kavanagh</last>
   </name>
   <name>
     <first>David</first>
     <last>LeRoy</last>
   </name>
   <name>
     <first>David</first>
     <last>Leal</last>
   </name>
   <name>
     <first>David</first>
     <middle>M.</middle>
     <last>Lloyd</last>
   </name>
   <name>
     <first>David</first>
     <last>Maclean</last>
   </name>
   <name>
     <first>David</first>
     <last>Rees</last>
   </name>
   <name>
     <first>Denis</first>
     <last>Hennessy</last>
   </name>
   <name>
     <first>Derek</first>
     <last>Slager</last>
   </name>
   <name>
     <first>Devon</first>
     <middle>C.</middle>
     <last>Miller</last>
   </name>
   <name>
     <first>Diane</first>
     <last>Holt</last>
   </name>
   <name>
     <first>dIon</first>
     <last>Gillard</last>
   </name>
   <name>
     <first>Dmitry</first>
     <middle>A.</middle>
     <last>Kuminov</last>
   </name>
   <name>
     <first>Dominique</first>
     <last>Devienne</last>
   </name>
   <name>
     <first>Donal</first>
     <last>Quinlan</last>
   </name>
   <name>
     <first>Don</first>
     <last>Bnamen</last>
   </name>
   <name>
     <first>Don</first>
     <last>Ferguson</last>
   </name>
   <name>
     <first>Don</first>
     <last>Jeffery</last>
   </name>
   <name>
     <first>Drew</first>
     <last>Sudell</last>
   </name>
   <name>
     <first>Eduard</first>
     <last>Wirch</last>
   </name>
   <name>
     <first>Edwin</first>
     <last>Woudt</last>
   </name>
   <name>
     <first>Eli</first>
     <last>Tucker</last>
   </name>
   <name>
     <first>Emmanuel</first>
     <last>Bourg</last>
   </name>
   <name>
     <first>Eric</first>
     <last>Olsen</last>
   </name>
   <name>
     <first>Eric</first>
     <last>Pugh</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Costlow</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Hatcher</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Langenbach</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Meade</last>
   </name>
   <name>
     <first>Ernst</first>
     <last>de Haan</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Harnack</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Somers</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Zeyda</last>
   </name>
   <name>
     <first>František</first>
     <last>Kučera</last>
   </name>
   <name>
     <first>Frédéric</first>
     <last>Bothamy</last>
   </name>
   <name>
     <first>Frederic</first>
     <last>Lavigne</last>
   </name>
   <name>
     <first>Gary</first>
     <middle>S.</middle>
     <last>Weaver</last>
   </name>
   <name>
     <first>Gautam</first>
     <last>Guliani</last>
   </name>
   <name>
     <first>Gene-Sung</first>
     <last>Chung</last>
   </name>
   <name>
     <first>Georges-Etienne</first>
     <last>Legendre</last>
   </name>
   <name>
     <first>Gero</first>
     <last>Vermaas</last>
   </name>
   <name>
     <first>Gerrit</first>
     <last>Riessen</last>
   </name>
   <name>
     <first>Gilbert</first>
     <last>Rebhan</last>
   </name>
   <name>
     <first>Gilles</first>
     <last>Scokart</last>
   </name>
   <name>
     <first>Glenn</first>
     <last>McAllister</last>
   </name>
   <name>
     <first>Glenn</first>
     <last>Twiggs</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Nelson</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Roodt</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Schueler</last>
   </name>
   <name>
     <first>Günther</first>
     <last>Kögel</last>
   </name>
   <name>
     <first>Harish</first>
     <last>Prabandham</last>
   </name>
   <name>
     <first>Haroon</first>
     <last>Rafique</last>
   </name>
   <name>
     <first>Hiroaki</first>
     <last>Nakamura</last>
   </name>
   <name>
     <first>Holger</first>
     <last>Engels</last>
   </name>
   <name>
     <first>Holger</first>
     <last>Joest</last>
   </name>
   <name>
     <first>Ignacio</first>
     <last>Coloma</last>
   </name>
   <name>
     <first>Ingenonsya</first>
     <last>France</last>
   </name>
   <name>
     <first>Ingmar</first>
     <last>Stein</last>
   </name>
   <name>
     <first>Irene</first>
     <last>Rusman</last>
   </name>
   <name>
     <first>Isaac</first>
     <last>Shabtay</last>
   </name>
   <name>
     <first>Ivan</first>
     <last>Ivanov</last>
   </name>
   <name>
     <first>J</first>
     <last>Bleijenbergh</last>
   </name>
   <name>
     <first>Jack</first>
     <middle>J.</middle>
     <last>Woehr</last>
   </name>
   <name>
     <first>James</first>
     <middle>Duncan</middle>
     <last>Davidson</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Cumps</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Mat&#232;rne</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Mynarik</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Stolze</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Hunter</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Pettiss</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Salter</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Yip</last>
   </name>
   <name>
     <first>Jay</first>
     <middle>Dickon</middle>
     <last>Glanville</last>
   </name>
   <name>
     <first>Jay</first>
     <last>Peck</last>
   </name>
   <name>
     <first>Jay</first>
     <last>van der Meer</last>
   </name>
   <name>
     <first>JC</first>
     <last>Mann</last>
   </name>
   <name>
     <first>J</first>
     <last>D</last>
   </name>
   <name>
     <first>Jean-Francois</first>
     <last>Brousseau</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Gettle</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Martin</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Tulley</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Turner</last>
   </name>
   <name>
     <first>Jene</first>
     <last>Jasper</last>
   </name>
   <name>
     <first>Jeremy</first>
     <last>Mawson</last>
   </name>
   <name>
     <first>Jerome</first>
     <last>Lacoste</last>
   </name>
   <name>
     <first>Jesse</first>
     <last>Glick</last>
   </name>
   <name>
     <first>Jesse</first>
     <last>Stockall</last>
   </name>
   <name>
     <first>Jim</first>
     <last>Allers</last>
   </name>
   <name>
     <first>Joerg</first>
     <last>Wassmer</last>
   </name>
   <name>
     <first>Joey</first>
     <last>Richey</last>
   </name>
   <name>
     <first>Johann</first>
     <last>Herunter</last>
   </name>
   <name>
     <first>John</first>
     <last>Sisson</last>
   </name>
   <name>
     <first>Jon</first>
     <last>Dickinson</last>
   </name>
   <name>
     <first>Jon</first>
     <last>Skeet</last>
   </name>
   <name>
     <first>Jon</first>
     <middle>S.</middle>
     <last>Stevens</last>
   </name>
   <name>
     <first>Jose</first>
     <middle>Alberto</middle>
     <last>Fernandez</last>
   </name>
   <name>
     <first>Josh</first>
     <last>Lucas</last>
   </name>
   <name>
     <first>Joseph</first>
     <last>Walton</last>
   </name>
   <name>
     <first>Juerg</first>
     <last>Wanner</last>
   </name>
   <name>
     <first>Julian</first>
     <last>Simpson</last>
   </name>
   <name>
     <first>Justin</first>
     <last>Vallon</last>
   </name>
   <name>
     <first>Keiron</first>
     <last>Liddle</last>
   </name>
   <name>
     <first>Keith</first>
     <last>Visco</last>
   </name>
   <name>
     <first>Kevin</first>
     <middle>Connor</middle>
     <last>Arpe</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Greiner</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Jackson</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Ross</last>
   </name>
   <name>
     <first>Kevin</first>
     <middle>Z</middle>
     <last>Grey</last>
   </name>
   <name>
     <first>Kim</first>
     <last>Hansen</last>
   </name>
   <name>
     <first>Kirk</first>
     <last>Wylie</last>
   </name>
   <name>
     <first>Kyle</first>
     <last>Adams</last>
   </name>
   <name>
     <first>Larry</first>
     <last>Shatzer</last>
   </name>
   <name>
     <first>Larry</first>
     <last>Streepy</last>
   </name>
   <name>
     <first>Les</first>
     <last>Hughes</last>
   </name>
   <name>
     <first>Levi</first>
     <last>Cook</last>
   </name>
   <name>
     <last>lucas</last>
   </name>
   <name>
     <first>Ludovic</first>
     <last>Claude</last>
   </name>
   <name>
     <first>Magesh</first>
     <last>Umasankar</last>
   </name>
   <name>
     <first>Maneesh</first>
     <last>Sahu</last>
   </name>
   <name>
     <first>Marcel</first>
     <last>Schutte</last>
   </name>
   <name>
     <first>Marcus</first>
     <last>Börger</last>
   </name>
   <name>
     <first>Mario</first>
     <last>Frasca</last>
   </name>
   <name>
     <first>Mariusz</first>
     <last>Nowostawski</last>
   </name>
   <name>
     <first>Mark</first>
     <last>DeLaFranier</last>
   </name>
   <name>
     <first>Mark</first>
     <last>Hecker</last>
   </name>
   <name>
     <first>Mark</first>
     <last>Salter</last>
   </name>
   <name>
     <first>Mark</first>
     <middle>R.</middle>
     <last>Diggory</last>
   </name>
   <name>
     <first>Mark</first>
     <middle>A.</middle>
     <last>Ziesemer</last>
   </name>
   <name>
     <first>Markus</first>
     <last>Kahl</last>
   </name>
   <name>
     <first>Martijn</first>
     <last>Kruithof</last>
   </name>
   <name>
     <first>Martin</first>
     <last>Landers</last>
   </name>
   <name>
     <first>Martin</first>
     <last>Poeschl</last>
   </name>
   <name>
     <first>Martin</first>
     <last>van den Bemt</last>
   </name>
   <name>
     <first>Martin</first>
     <last>von Gagern</last>
   </name>
   <name>
-    <first>Mathieu</first>
-    <last>Champlon</last>
-  </name>
-  <name>
-    <first>Mathieu</first>
-    <last>Peltier</last>
-  </name>
-  <name>
     <first>Matt</first>
     <last>Albrecht</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Benson</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Bishop</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Foemmel</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Grosso</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Humphrey</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Small</last>
   </name>
   <name>
+    <first>Matt</first>
+    <last>Wildig</last>
+  </name>
+  <name>
+    <first>Mathieu</first>
+    <last>Champlon</last>
+  </name>
+  <name>
+    <first>Mathieu</first>
+    <last>Peltier</last>
+  </name>
+  <name>
+    <first>Matthias</first>
+    <last>Bhend</last>
+  </name>
+  <name>
     <first>Matthew</first>
     <last>Hawthorne</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Inger</last>
   </name>
   <name>
     <first>Matthew</first>
     <middle>Kuperus</middle>
     <last>Heun</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Watson</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Bayne</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Clarke</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Davey</last>
   </name>
   <name>
     <first>Michael</first>
     <middle>J.</middle>
     <last>Sikorsky</last>
   </name>
   <name>
     <first>Michael</first>
     <last>McCallum</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Newcomb</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Nygard</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Saunders</last>
   </name>
   <name>
     <last>Miha</last>
   </name>
   <name>
     <first>Mike</first>
     <last>Davis</last>
   </name>
   <name>
     <first>Mike</first>
     <last>Roberts</last>
   </name>
   <name>
     <last>mnowostawski</last>
   </name>
   <name>
     <first>Mounir</first>
     <last>El Hajj</last>
   </name>
   <name>
     <first>Nathan</first>
     <last>Beyer</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Chalko</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Crossley</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Fortescue</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Pellow</last>
   </name>
   <name>
     <first>Nicola</first>
     <last>Ken</last>
   </name>
   <name>
     <first>Nico</first>
     <last>Seessle</last>
   </name>
   <name>
     <first>Nigel</first>
     <last>Magnay</last>
   </name>
   <name>
     <first>Oliver</first>
     <last>Merkel</last>
   </name>
   <name>
     <first>Oliver</first>
     <last>Rossmueller</last>
   </name>
   <name>
     <first>Omer</first>
     <last>Shapira</last>
   </name>
   <name>
     <first>Ondra</first>
     <last>Medek</last>
   </name>
   <name>
     <first>&#216;ystein</first>
     <last>Gisn&#229;s</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Altaie</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>C.</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Chanezon</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Gus</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Austin</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Christmann</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Galbraith</last>
   </name>
   <name>
     <first>Paul</first>
     <last>King</last>
   </name>
   <name>
     <first>Paulo</first>
     <last>Gaspar</last>
   </name>
   <name>
     <first>Pavan</first>
     <last>Bayyapu</last>
   </name>
   <name>
     <first>Pavel</first>
     <last>Jisl</last>
   </name>
   <name>
     <first>Paweł</first>
     <last>Zuzelski</last>
   </name>
   <name>
     <first>Peter</first>
     <middle>B.</middle>
     <last>West</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Donald</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Doornbosch</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Hulst</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Janes</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Reilly</last>
   </name>
   <name>
     <first>Phil</first>
     <last>Hanna</last>
   </name>
   <name>
     <first>Philip</first>
     <last>Hourihane</last>
   </name>
   <name>
     <first>Phillip</first>
     <last>Wells</last>
   </name>
   <name>
     <first>Pierre</first>
     <last>Delisle</last>
   </name>
   <name>
     <first>Pierre</first>
     <last>Dittgen</last>
   </name>
   <name>
     <first>R</first>
     <last>Handerson</last>
   </name>
   <name>
     <first>Rami</first>
     <last>Ojares</last>
   </name>
   <name>
     <first>Randy</first>
     <last>Watler</last>
   </name>
   <name>
     <first>Raphael</first>
     <last>Pierquin</last>
   </name>
   <name>
     <first>Ray</first>
     <last>Waldin</last>
   </name>
   <name>
     <first>Remie</first>
     <last>Bolte</last>
   </name>
   <name>
     <first>Richard</first>
     <last>Evans</last>
   </name>
   <name>
     <first>Richard</first>
     <last>Steele</last>
   </name>
   <name>
     <first>Rick</first>
     <last>Beton</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Anderson</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Clark</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Flaherty</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Shaw</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Streich</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Watkins</last>
   </name>
   <name>
     <first>Roberto</first>
     <last>Scaramuzzi</last>
   </name>
   <name>
     <first>Robin</first>
     <last>Green</last>
   </name>
   <name>
     <first>Robin</first>
     <last>Power</last>
   </name>
   <name>
     <first>Robin</first>
     <last>Verduijn</last>
   </name>
   <name>
     <first>Rob</first>
     <last>Oxspring</last>
   </name>
   <name>
     <first>Rob</first>
     <last>van Oostrum</last>
   </name>
   <name>
     <first>Rodrigo</first>
     <last>Schmidt</last>
   </name>
   <name>
     <first>Roger</first>
     <last>Vaughn</last>
   </name>
   <name>
     <first>Roman</first>
     <last>Ivashin</last>
   </name>
   <name>
     <first>Ronen</first>
     <last>Mashal</last>
   </name>
   <name>
     <first>Russell</first>
     <last>Gold</last>
   </name>
   <name>
     <first>Sam</first>
     <last>Ruby</last>
   </name>
   <name>
     <first>Sandra</first>
     <last>Metz</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Carlson</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Ellsworth</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Johnson</last>
   </name>
   <name>
     <first>Scott</first>
     <middle>M.</middle>
     <last>Stirling</last>
   </name>
   <name>
     <first>Sean</first>
     <last>Egan</last>
   </name>
   <name>
     <first>Sean</first>
     <middle>P.</middle>
     <last>Kane</last>
   </name>
   <name>
     <first>Sebastien</first>
     <last>Arod</last>
   </name>
   <name>
     <first>Shiraz</first>
     <last>Kanga</last>
   </name>
   <name>
     <first>Sebastian</first>
     <last>Kantha</last>
   </name>
   <name>
       <first>Simon</first>
       <last>Law</last>
   </name>
   <name>
     <first>Simone</first>
     <last>Bordet</last>
   </name>
   <name>
     <first>Stefan</first>
     <last>Bodewig</last>
   </name>
   <name>
     <first>Stefan</first>
     <last>Heimann</last>
   </name>
   <name>
     <first>Stefano</first>
     <last>Mazzocchi</last>
   </name>
   <name>
     <first>Stephan</first>
     <last>Strittmatter</last>
   </name>
   <name>
     <first>Stephane</first>
     <last>Bailliez</last>
   </name>
   <name>
     <last>stephan</last>
   </name>
   <name>
     <first>Stephan</first>
     <last>Michels</last>
   </name>
   <name>
     <first>Stephen</first>
     <last>Chin</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Cohen</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Langley</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Loughran</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Morin</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Wadsworth</last>
   </name>
   <name>
     <first>Steven</first>
     <middle>E.</middle>
     <last>Newton</last>
   </name>
   <name>
     <first>Sudheer</first>
     <last>Chigurupati</last>
   </name>
   <name>
     <first>Takashi</first>
     <last>Okamoto</last>
   </name>
   <name>
     <first>TAMURA</first>
     <last>Kent</last>
   </name>
   <name>
     <first>Taoufik</first>
     <last>Romdhane</last>
   </name>
   <name>
     <first>Tariq</first>
     <last>Master</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Aglassinger</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Butz</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Christen</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Christensen</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Haas</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Quas</last>
   </name>
   <name>
     <first>Tim</first>
     <last>Drury</last>
   </name>
   <name>
     <first>Tim</first>
     <last>Fennell</last>
   </name>
   <name>
     <first>Tim</first>
     <last>Whittington</last>
   </name>
   <name>
     <first>Timoteo</first>
     <last>Ohara</last>
   </name>
   <name>
     <first>Timothy</first>
     <middle>Gerard</middle>
     <last>Endres</last>
   </name>
   <name>
     <first>Tim</first>
     <last>Stephenson</last>
   </name>
   <name>
     <first>Tom</first>
     <last>Ball</last>
   </name>
   <name>
     <first>Tom</first>
     <last>Cunningham</last>
   </name>
   <name>
     <first>Tom</first>
     <last>Dimock</last>
   </name>
   <name>
     <first>Tom</first>
     <last>Eugelink</last>
   </name>
   <name>
     <first>Tom</first>
     <last>May</last>
   </name>
   <name>
     <first>Tomasz</first>
     <last>Bech</last>
   </name>
   <name>
     <first>Trejkaz</first>
     <last>Xaoz</last>
   </name>
   <name>
     <first>Ulrich</first>
     <last>Schmidt</last>
   </name>
   <name>
     <first>Uwe</first>
     <last>Schindler</last>
   </name>
   <name>
     <first>Valentino</first>
     <last>Miazzo</last>
   </name>
   <name>
     <first>Victor</first>
     <last>Toni</last>
   </name>
   <name>
     <first>Vincent</first>
     <last>Legoll</last>
   </name>
   <name>
     <first>Vimil</first>
     <last>Saju</last>
   </name>
   <name>
     <first>Volker</first>
     <last>Leidl</last>
   </name>
   <name>
     <first>Wang</first>
     <last>Weijun</last>
   </name>
   <name>
     <first>Will</first>
     <last>Wang</last>
   </name>
   <name>
     <first>William</first>
     <last>Bernardet</last>
   </name>
   <name>
     <first>William</first>
     <last>Ferguson</last>
   </name>
   <name>
     <first>William</first>
     <last>Webber</last>
   </name>
   <name>
     <first>Wolf</first>
     <last>Siberski</last>
   </name>
   <name>
     <first>Wolfgang</first>
     <last>Baer</last>
   </name>
   <name>
     <first>Wolfgang</first>
     <last>Frech</last>
   </name>
   <name>
     <first>Wolfgang</first>
     <last>Glas</last>
   </name>
   <name>
     <first>Wolfgang</first>
     <last>Werner</last>
   </name>
   <name>
     <first>Xavier</first>
     <last>Hanin</last>
   </name>
   <name>
     <first>Xavier</first>
     <last>Witdouck</last>
   </name>
   <name>
     <first>Yohann</first>
     <last>Roussel</last>
   </name>
   <name>
     <first>Yuji</first>
     <last>Yamano</last>
   </name>
   <name>
     <first>Yves</first>
     <last>Martin</last>
   </name>
   <name>
     <first>Zach</first>
     <last>Garner</last>
   </name>
   <name>
     <first>Zdenek</first>
     <last>Wagner</last>
   </name>
   <name>
     <first/>
     <last>riasol</last>
   </name>
 </contributors>
diff --git a/src/main/org/apache/tools/ant/taskdefs/Copy.java b/src/main/org/apache/tools/ant/taskdefs/Copy.java
index da9578739..2d72ed69f 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Copy.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Copy.java
@@ -1,1105 +1,1105 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Hashtable;
 import java.util.List;
 import java.util.Map;
 import java.util.Vector;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.types.Mapper;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.FilterSet;
 import org.apache.tools.ant.types.FilterChain;
 import org.apache.tools.ant.types.FilterSetCollection;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.ResourceFactory;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.IdentityMapper;
 import org.apache.tools.ant.util.LinkedHashtable;
 import org.apache.tools.ant.util.ResourceUtils;
 import org.apache.tools.ant.util.SourceFileScanner;
 import org.apache.tools.ant.util.FlatFileNameMapper;
 
 /**
  * Copies a file or directory to a new file
  * or directory.  Files are only copied if the source file is newer
  * than the destination file, or when the destination file does not
  * exist.  It is possible to explicitly overwrite existing files.</p>
  *
  * <p>This implementation is based on Arnout Kuiper's initial design
  * document, the following mailing list discussions, and the
  * copyfile/copydir tasks.</p>
  *
  *
  * @since Ant 1.2
  *
  * @ant.task category="filesystem"
  */
 public class Copy extends Task {
     private static final String MSG_WHEN_COPYING_EMPTY_RC_TO_FILE =
         "Cannot perform operation from directory to file.";
 
     static final File NULL_FILE_PLACEHOLDER = new File("/NULL_FILE");
     static final String LINE_SEPARATOR = System.getProperty("line.separator");
     // CheckStyle:VisibilityModifier OFF - bc
     protected File file = null;     // the source file
     protected File destFile = null; // the destination file
     protected File destDir = null;  // the destination directory
     protected Vector<ResourceCollection> rcs = new Vector<ResourceCollection>();
     // here to provide API backwards compatibility
     protected Vector<ResourceCollection> filesets = rcs;
 
     private boolean enableMultipleMappings = false;
     protected boolean filtering = false;
     protected boolean preserveLastModified = false;
     protected boolean forceOverwrite = false;
     protected boolean flatten = false;
     protected int verbosity = Project.MSG_VERBOSE;
     protected boolean includeEmpty = true;
     protected boolean failonerror = true;
 
     protected Hashtable<String, String[]> fileCopyMap = new LinkedHashtable<String, String[]>();
     protected Hashtable<String, String[]> dirCopyMap = new LinkedHashtable<String, String[]>();
     protected Hashtable<File, File> completeDirMap = new LinkedHashtable<File, File>();
 
     protected Mapper mapperElement = null;
     protected FileUtils fileUtils;
     //CheckStyle:VisibilityModifier ON
     private Vector<FilterChain> filterChains = new Vector<FilterChain>();
     private Vector<FilterSet> filterSets = new Vector<FilterSet>();
     private String inputEncoding = null;
     private String outputEncoding = null;
     private long granularity = 0;
     private boolean force = false;
     private boolean quiet = false;
 
     // used to store the single non-file resource to copy when the
     // tofile attribute has been used
     private Resource singleResource = null;
 
     /**
      * Copy task constructor.
      */
     public Copy() {
         fileUtils = FileUtils.getFileUtils();
         granularity = fileUtils.getFileTimestampGranularity();
     }
 
     /**
      * Get the FileUtils for this task.
      * @return the fileutils object.
      */
     protected FileUtils getFileUtils() {
         return fileUtils;
     }
 
     /**
      * Set a single source file to copy.
      * @param file the file to copy.
      */
     public void setFile(File file) {
         this.file = file;
     }
 
     /**
      * Set the destination file.
      * @param destFile the file to copy to.
      */
     public void setTofile(File destFile) {
         this.destFile = destFile;
     }
 
     /**
      * Set the destination directory.
      * @param destDir the destination directory.
      */
     public void setTodir(File destDir) {
         this.destDir = destDir;
     }
 
     /**
      * Add a FilterChain.
      * @return a filter chain object.
      */
     public FilterChain createFilterChain() {
         FilterChain filterChain = new FilterChain();
         filterChains.addElement(filterChain);
         return filterChain;
     }
 
     /**
      * Add a filterset.
      * @return a filter set object.
      */
     public FilterSet createFilterSet() {
         FilterSet filterSet = new FilterSet();
         filterSets.addElement(filterSet);
         return filterSet;
     }
 
     /**
      * Give the copied files the same last modified time as the original files.
      * @param preserve a boolean string.
      * @deprecated since 1.5.x.
      *             setPreserveLastModified(String) has been deprecated and
      *             replaced with setPreserveLastModified(boolean) to
      *             consistently let the Introspection mechanism work.
      */
     public void setPreserveLastModified(String preserve) {
         setPreserveLastModified(Project.toBoolean(preserve));
     }
 
     /**
      * Give the copied files the same last modified time as the original files.
      * @param preserve if true preserve the modified time; default is false.
      */
     public void setPreserveLastModified(boolean preserve) {
         preserveLastModified = preserve;
     }
 
     /**
      * Get whether to give the copied files the same last modified time as
      * the original files.
      * @return the whether destination files will inherit the modification
      *         times of the corresponding source files.
      * @since 1.32, Ant 1.5
      */
     public boolean getPreserveLastModified() {
         return preserveLastModified;
     }
 
     /**
      * Get the filtersets being applied to this operation.
      *
      * @return a vector of FilterSet objects.
      */
     protected Vector<FilterSet> getFilterSets() {
         return filterSets;
     }
 
     /**
      * Get the filterchains being applied to this operation.
      *
      * @return a vector of FilterChain objects.
      */
     protected Vector<FilterChain> getFilterChains() {
         return filterChains;
     }
 
     /**
      * Set filtering mode.
      * @param filtering if true enable filtering; default is false.
      */
     public void setFiltering(boolean filtering) {
         this.filtering = filtering;
     }
 
     /**
      * Set overwrite mode regarding existing destination file(s).
      * @param overwrite if true force overwriting of destination file(s)
      *                  even if the destination file(s) are younger than
      *                  the corresponding source file. Default is false.
      */
     public void setOverwrite(boolean overwrite) {
         this.forceOverwrite = overwrite;
     }
 
     /**
      * Whether read-only destinations will be overwritten.
      *
      * <p>Defaults to false</p>
      *
      * @since Ant 1.8.2
      */
     public void setForce(boolean f) {
         force = f;
     }
 
     /**
      * Whether read-only destinations will be overwritten.
      *
      * @since Ant 1.8.2
      */
     public boolean getForce() {
         return force;
     }
 
     /**
      * Set whether files copied from directory trees will be "flattened"
      * into a single directory.  If there are multiple files with
      * the same name in the source directory tree, only the first
      * file will be copied into the "flattened" directory, unless
      * the forceoverwrite attribute is true.
      * @param flatten if true flatten the destination directory. Default
      *                is false.
      */
     public void setFlatten(boolean flatten) {
         this.flatten = flatten;
     }
 
     /**
      * Set verbose mode. Used to force listing of all names of copied files.
      * @param verbose whether to output the names of copied files.
      *                Default is false.
      */
     public void setVerbose(boolean verbose) {
         this.verbosity = verbose ? Project.MSG_INFO : Project.MSG_VERBOSE;
     }
 
     /**
      * Set whether to copy empty directories.
      * @param includeEmpty if true copy empty directories. Default is true.
      */
     public void setIncludeEmptyDirs(boolean includeEmpty) {
         this.includeEmpty = includeEmpty;
     }
 
 	/**
 	 * Set quiet mode. Used to hide messages when a file or directory to be
 	 * copied does not exist.
 	 *
 	 * @param quiet
 	 *            whether or not to display error messages when a file or
 	 *            directory does not exist. Default is false.
 	 */
 	public void setQuiet(boolean quiet) {
 		this.quiet = quiet;
 	}
 
     /**
      * Set method of handling mappers that return multiple
      * mappings for a given source path.
      * @param enableMultipleMappings If true the task will
      *        copy to all the mappings for a given source path, if
      *        false, only the first file or directory is
      *        processed.
      *        By default, this setting is false to provide backward
      *        compatibility with earlier releases.
      * @since Ant 1.6
      */
     public void setEnableMultipleMappings(boolean enableMultipleMappings) {
         this.enableMultipleMappings = enableMultipleMappings;
     }
 
     /**
      * Get whether multiple mapping is enabled.
      * @return true if multiple mapping is enabled; false otherwise.
      */
     public boolean isEnableMultipleMapping() {
         return enableMultipleMappings;
     }
 
     /**
      * Set whether to fail when errors are encountered. If false, note errors
      * to the output but keep going. Default is true.
      * @param failonerror true or false.
      */
     public void setFailOnError(boolean failonerror) {
         this.failonerror = failonerror;
     }
 
     /**
      * Add a set of files to copy.
      * @param set a set of files to copy.
      */
     public void addFileset(FileSet set) {
         add(set);
     }
 
     /**
      * Add a collection of files to copy.
      * @param res a resource collection to copy.
      * @since Ant 1.7
      */
     public void add(ResourceCollection res) {
         rcs.add(res);
     }
 
     /**
      * Define the mapper to map source to destination files.
      * @return a mapper to be configured.
      * @exception BuildException if more than one mapper is defined.
      */
     public Mapper createMapper() throws BuildException {
         if (mapperElement != null) {
             throw new BuildException("Cannot define more than one mapper",
                                      getLocation());
         }
         mapperElement = new Mapper(getProject());
         return mapperElement;
     }
 
     /**
      * Add a nested filenamemapper.
      * @param fileNameMapper the mapper to add.
      * @since Ant 1.6.3
      */
     public void add(FileNameMapper fileNameMapper) {
         createMapper().add(fileNameMapper);
     }
 
     /**
      * Set the character encoding.
      * @param encoding the character encoding.
      * @since 1.32, Ant 1.5
      */
     public void setEncoding(String encoding) {
         this.inputEncoding = encoding;
         if (outputEncoding == null) {
             outputEncoding = encoding;
         }
     }
 
     /**
      * Get the character encoding to be used.
      * @return the character encoding, <code>null</code> if not set.
      *
      * @since 1.32, Ant 1.5
      */
     public String getEncoding() {
         return inputEncoding;
     }
 
     /**
      * Set the character encoding for output files.
      * @param encoding the output character encoding.
      * @since Ant 1.6
      */
     public void setOutputEncoding(String encoding) {
         this.outputEncoding = encoding;
     }
 
     /**
      * Get the character encoding for output files.
      * @return the character encoding for output files,
      * <code>null</code> if not set.
      *
      * @since Ant 1.6
      */
     public String getOutputEncoding() {
         return outputEncoding;
     }
 
     /**
      * Set the number of milliseconds leeway to give before deciding a
      * target is out of date.
      *
      * <p>Default is 1 second, or 2 seconds on DOS systems.</p>
      * @param granularity the granularity used to decide if a target is out of
      *                    date.
      * @since Ant 1.6.2
      */
     public void setGranularity(long granularity) {
         this.granularity = granularity;
     }
 
     /**
      * Perform the copy operation.
      * @exception BuildException if an error occurs.
      */
     public void execute() throws BuildException {
         File savedFile = file; // may be altered in validateAttributes
         File savedDestFile = destFile;
         File savedDestDir = destDir;
         ResourceCollection savedRc = null;
         if (file == null && destFile != null && rcs.size() == 1) {
             // will be removed in validateAttributes
             savedRc = (ResourceCollection) rcs.elementAt(0);
         }
 
         try {
             // make sure we don't have an illegal set of options
             try {
                 validateAttributes();
             } catch (BuildException e) {
                 if (failonerror
                     || !getMessage(e)
                     .equals(MSG_WHEN_COPYING_EMPTY_RC_TO_FILE)) {
                     throw e;
                 } else {
                     log("Warning: " + getMessage(e), Project.MSG_ERR);
                     return;
                 }
             }
 
             // deal with the single file
             copySingleFile();
 
             // deal with the ResourceCollections
 
             /* for historical and performance reasons we have to do
                things in a rather complex way.
 
                (1) Move is optimized to move directories if a fileset
                has been included completely, therefore FileSets need a
                special treatment.  This is also required to support
                the failOnError semantice (skip filesets with broken
                basedir but handle the remaining collections).
 
                (2) We carry around a few protected methods that work
                on basedirs and arrays of names.  To optimize stuff, all
                resources with the same basedir get collected in
                separate lists and then each list is handled in one go.
             */
 
             HashMap<File, List<String>> filesByBasedir = new HashMap<File, List<String>>();
             HashMap<File, List<String>> dirsByBasedir = new HashMap<File, List<String>>();
             HashSet<File> baseDirs = new HashSet<File>();
             ArrayList<Resource> nonFileResources = new ArrayList<Resource>();
             final int size = rcs.size();
             for (int i = 0; i < size; i++) {
                 ResourceCollection rc = rcs.elementAt(i);
 
                 // Step (1) - beware of the ZipFileSet
                 if (rc instanceof FileSet && rc.isFilesystemOnly()) {
                     FileSet fs = (FileSet) rc;
                     DirectoryScanner ds = null;
                     try {
                         ds = fs.getDirectoryScanner(getProject());
                     } catch (BuildException e) {
                         if (failonerror
                             || !getMessage(e).endsWith(DirectoryScanner
                                                        .DOES_NOT_EXIST_POSTFIX)) {
                             throw e;
                         } else {
                             if (!quiet) {
                                 log("Warning: " + getMessage(e), Project.MSG_ERR);
                             }
                             continue;
                         }
                     }
                     File fromDir = fs.getDir(getProject());
 
                     String[] srcFiles = ds.getIncludedFiles();
                     String[] srcDirs = ds.getIncludedDirectories();
                     if (!flatten && mapperElement == null
                         && ds.isEverythingIncluded() && !fs.hasPatterns()) {
                         completeDirMap.put(fromDir, destDir);
                     }
                     add(fromDir, srcFiles, filesByBasedir);
                     add(fromDir, srcDirs, dirsByBasedir);
                     baseDirs.add(fromDir);
                 } else { // not a fileset or contains non-file resources
 
                     if (!rc.isFilesystemOnly() && !supportsNonFileResources()) {
                         throw new BuildException(
                                    "Only FileSystem resources are supported.");
                     }
 
                     for (Resource r : rc) {
                         if (!r.isExists()) {
                             String message = "Warning: Could not find resource "
                                 + r.toLongString() + " to copy.";
                             if (!failonerror) {
                                 if (!quiet) {
                                     log(message, Project.MSG_ERR);
                                 }
                             } else {
                                 throw new BuildException(message);
                             }
                             continue;
                         }
 
                         File baseDir = NULL_FILE_PLACEHOLDER;
                         String name = r.getName();
                         FileProvider fp = r.as(FileProvider.class);
                         if (fp != null) {
                             FileResource fr = ResourceUtils.asFileResource(fp);
                             baseDir = getKeyFile(fr.getBaseDir());
                             if (fr.getBaseDir() == null) {
                                 name = fr.getFile().getAbsolutePath();
                             }
                         }
 
                         // copying of dirs is trivial and can be done
                         // for non-file resources as well as for real
                         // files.
                         if (r.isDirectory() || fp != null) {
                             add(baseDir, name,
                                 r.isDirectory() ? dirsByBasedir
                                                 : filesByBasedir);
                             baseDirs.add(baseDir);
                         } else { // a not-directory file resource
                             // needs special treatment
                             nonFileResources.add(r);
                         }
                     }
                 }
             }
 
             iterateOverBaseDirs(baseDirs, dirsByBasedir, filesByBasedir);
 
             // do all the copy operations now...
             try {
                 doFileOperations();
             } catch (BuildException e) {
                 if (!failonerror) {
                     if (!quiet) {
                         log("Warning: " + getMessage(e), Project.MSG_ERR);
                     }
                 } else {
                     throw e;
                 }
             }
 
             if (nonFileResources.size() > 0 || singleResource != null) {
                 Resource[] nonFiles =
                     (Resource[]) nonFileResources.toArray(new Resource[nonFileResources.size()]);
                 // restrict to out-of-date resources
                 Map<Resource, String[]> map = scan(nonFiles, destDir);
                 if (singleResource != null) {
                     map.put(singleResource,
                             new String[] { destFile.getAbsolutePath() });
                 }
                 try {
                     doResourceOperations(map);
                 } catch (BuildException e) {
                     if (!failonerror) {
                         if (!quiet) {
                             log("Warning: " + getMessage(e), Project.MSG_ERR);
                         }
                     } else {
                         throw e;
                     }
                 }
             }
         } finally {
             // clean up again, so this instance can be used a second
             // time
             singleResource = null;
             file = savedFile;
             destFile = savedDestFile;
             destDir = savedDestDir;
             if (savedRc != null) {
                 rcs.insertElementAt(savedRc, 0);
             }
             fileCopyMap.clear();
             dirCopyMap.clear();
             completeDirMap.clear();
         }
     }
 
     /************************************************************************
      **  protected and private methods
      ************************************************************************/
 
     private void copySingleFile() {
         // deal with the single file
         if (file != null) {
             if (file.exists()) {
                 if (destFile == null) {
                     destFile = new File(destDir, file.getName());
                 }
                 if (forceOverwrite || !destFile.exists()
                     || (file.lastModified() - granularity
                         > destFile.lastModified())) {
                     fileCopyMap.put(file.getAbsolutePath(),
                                     new String[] {destFile.getAbsolutePath()});
                 } else {
                     log(file + " omitted as " + destFile
                         + " is up to date.", Project.MSG_VERBOSE);
                 }
             } else {
                 String message = "Warning: Could not find file "
                     + file.getAbsolutePath() + " to copy.";
                 if (!failonerror) {
                     if (!quiet) {
                       log(message, Project.MSG_ERR);
                     }
                 } else {
                     throw new BuildException(message);
                 }
             }
         }
     }
 
     private void iterateOverBaseDirs(
         HashSet<File> baseDirs, HashMap<File, List<String>> dirsByBasedir, HashMap<File, List<String>> filesByBasedir) {
 
         for (File f : baseDirs) {
             List<String> files = filesByBasedir.get(f);
             List<String> dirs = dirsByBasedir.get(f);
 
             String[] srcFiles = new String[0];
             if (files != null) {
                 srcFiles = files.toArray(srcFiles);
             }
             String[] srcDirs = new String[0];
             if (dirs != null) {
                 srcDirs = dirs.toArray(srcDirs);
             }
             scan(f == NULL_FILE_PLACEHOLDER ? null : f, destDir, srcFiles,
                  srcDirs);
         }
     }
 
     /**
      * Ensure we have a consistent and legal set of attributes, and set
      * any internal flags necessary based on different combinations
      * of attributes.
      * @exception BuildException if an error occurs.
      */
     protected void validateAttributes() throws BuildException {
         if (file == null && rcs.size() == 0) {
             throw new BuildException(
                 "Specify at least one source--a file or a resource collection.");
         }
         if (destFile != null && destDir != null) {
             throw new BuildException(
                 "Only one of tofile and todir may be set.");
         }
         if (destFile == null && destDir == null) {
             throw new BuildException("One of tofile or todir must be set.");
         }
         if (file != null && file.isDirectory()) {
             throw new BuildException("Use a resource collection to copy directories.");
         }
         if (destFile != null && rcs.size() > 0) {
             if (rcs.size() > 1) {
                 throw new BuildException(
                     "Cannot concatenate multiple files into a single file.");
             } else {
                 ResourceCollection rc = (ResourceCollection) rcs.elementAt(0);
                 if (!rc.isFilesystemOnly() && !supportsNonFileResources()) {
                     throw new BuildException("Only FileSystem resources are"
                                              + " supported.");
                 }
                 if (rc.size() == 0) {
                     throw new BuildException(MSG_WHEN_COPYING_EMPTY_RC_TO_FILE);
                 } else if (rc.size() == 1) {
                     Resource res = rc.iterator().next();
                     FileProvider r = res.as(FileProvider.class);
                     if (file == null) {
                         if (r != null) {
                             file = r.getFile();
                         } else {
                             singleResource = res;
                         }
                         rcs.removeElementAt(0);
                     } else {
                         throw new BuildException(
                             "Cannot concatenate multiple files into a single file.");
                     }
                 } else {
                     throw new BuildException(
                         "Cannot concatenate multiple files into a single file.");
                 }
             }
         }
         if (destFile != null) {
             destDir = destFile.getParentFile();
         }
     }
 
     /**
      * Compares source files to destination files to see if they should be
      * copied.
      *
      * @param fromDir  The source directory.
      * @param toDir    The destination directory.
      * @param files    A list of files to copy.
      * @param dirs     A list of directories to copy.
      */
     protected void scan(File fromDir, File toDir, String[] files,
                         String[] dirs) {
         FileNameMapper mapper = getMapper();
         buildMap(fromDir, toDir, files, mapper, fileCopyMap);
 
         if (includeEmpty) {
             buildMap(fromDir, toDir, dirs, mapper, dirCopyMap);
         }
     }
 
     /**
      * Compares source resources to destination files to see if they
      * should be copied.
      *
      * @param fromResources  The source resources.
      * @param toDir          The destination directory.
      *
      * @return a Map with the out-of-date resources as keys and an
      * array of target file names as values.
      *
      * @since Ant 1.7
      */
     protected Map<Resource, String[]> scan(Resource[] fromResources, File toDir) {
         return buildMap(fromResources, toDir, getMapper());
     }
 
     /**
      * Add to a map of files/directories to copy.
      *
      * @param fromDir the source directory.
      * @param toDir   the destination directory.
      * @param names   a list of filenames.
      * @param mapper  a <code>FileNameMapper</code> value.
      * @param map     a map of source file to array of destination files.
      */
     protected void buildMap(File fromDir, File toDir, String[] names,
                             FileNameMapper mapper, Hashtable<String, String[]> map) {
         String[] toCopy = null;
         if (forceOverwrite) {
             Vector<String> v = new Vector<String>();
             for (int i = 0; i < names.length; i++) {
                 if (mapper.mapFileName(names[i]) != null) {
                     v.addElement(names[i]);
                 }
             }
             toCopy = new String[v.size()];
             v.copyInto(toCopy);
         } else {
             SourceFileScanner ds = new SourceFileScanner(this);
             toCopy = ds.restrict(names, fromDir, toDir, mapper, granularity);
         }
         for (int i = 0; i < toCopy.length; i++) {
             File src = new File(fromDir, toCopy[i]);
             String[] mappedFiles = mapper.mapFileName(toCopy[i]);
 
             if (!enableMultipleMappings) {
                 map.put(src.getAbsolutePath(),
                         new String[] {new File(toDir, mappedFiles[0]).getAbsolutePath()});
             } else {
                 // reuse the array created by the mapper
                 for (int k = 0; k < mappedFiles.length; k++) {
                     mappedFiles[k] = new File(toDir, mappedFiles[k]).getAbsolutePath();
                 }
                 map.put(src.getAbsolutePath(), mappedFiles);
             }
         }
     }
 
     /**
      * Create a map of resources to copy.
      *
      * @param fromResources  The source resources.
      * @param toDir   the destination directory.
      * @param mapper  a <code>FileNameMapper</code> value.
      * @return a map of source resource to array of destination files.
      * @since Ant 1.7
      */
     protected Map<Resource, String[]> buildMap(Resource[] fromResources, final File toDir,
                            FileNameMapper mapper) {
         HashMap<Resource, String[]> map = new HashMap<Resource, String[]>();
         Resource[] toCopy = null;
         if (forceOverwrite) {
             Vector<Resource> v = new Vector<Resource>();
             for (int i = 0; i < fromResources.length; i++) {
                 if (mapper.mapFileName(fromResources[i].getName()) != null) {
                     v.addElement(fromResources[i]);
                 }
             }
             toCopy = new Resource[v.size()];
             v.copyInto(toCopy);
         } else {
             toCopy =
                 ResourceUtils.selectOutOfDateSources(this, fromResources,
                                                      mapper,
                                                      new ResourceFactory() {
                            public Resource getResource(String name) {
                                return new FileResource(toDir, name);
                            }
                                                      },
                                                      granularity);
         }
         for (int i = 0; i < toCopy.length; i++) {
             String[] mappedFiles = mapper.mapFileName(toCopy[i].getName());
             for (int j = 0; j < mappedFiles.length; j++) {
                 if (mappedFiles[j] == null) {
                     throw new BuildException("Can't copy a resource without a"
                                              + " name if the mapper doesn't"
                                              + " provide one.");
                 }
             }
 
             if (!enableMultipleMappings) {
                 map.put(toCopy[i],
                         new String[] {new File(toDir, mappedFiles[0]).getAbsolutePath()});
             } else {
                 // reuse the array created by the mapper
                 for (int k = 0; k < mappedFiles.length; k++) {
                     mappedFiles[k] = new File(toDir, mappedFiles[k]).getAbsolutePath();
                 }
                 map.put(toCopy[i], mappedFiles);
             }
         }
         return map;
     }
 
     /**
      * Actually does the file (and possibly empty directory) copies.
      * This is a good method for subclasses to override.
      */
     protected void doFileOperations() {
         if (fileCopyMap.size() > 0) {
             log("Copying " + fileCopyMap.size()
                 + " file" + (fileCopyMap.size() == 1 ? "" : "s")
                 + " to " + destDir.getAbsolutePath());
 
             for (Map.Entry<String, String[]> e : fileCopyMap.entrySet()) {
                 String fromFile = e.getKey();
                 String[] toFiles = e.getValue();
 
                 for (int i = 0; i < toFiles.length; i++) {
                     String toFile = toFiles[i];
 
                     if (fromFile.equals(toFile)) {
                         log("Skipping self-copy of " + fromFile, verbosity);
                         continue;
                     }
                     try {
                         log("Copying " + fromFile + " to " + toFile, verbosity);
 
                         FilterSetCollection executionFilters =
                             new FilterSetCollection();
                         if (filtering) {
                             executionFilters
                                 .addFilterSet(getProject().getGlobalFilterSet());
                         }
                         for (FilterSet filterSet : filterSets) {
                             executionFilters.addFilterSet(filterSet);
                         }
                         fileUtils.copyFile(new File(fromFile), new File(toFile),
                                            executionFilters,
                                            filterChains, forceOverwrite,
                                            preserveLastModified,
                                            /* append: */ false, inputEncoding,
                                            outputEncoding, getProject(),
                                            getForce());
                     } catch (IOException ioe) {
                         String msg = "Failed to copy " + fromFile + " to " + toFile
                             + " due to " + getDueTo(ioe);
                         File targetFile = new File(toFile);
                         if (targetFile.exists() && !targetFile.delete()) {
                             msg += " and I couldn't delete the corrupt " + toFile;
                         }
                         if (failonerror) {
                             throw new BuildException(msg, ioe, getLocation());
                         }
                         log(msg, Project.MSG_ERR);
                     }
                 }
             }
         }
         if (includeEmpty) {
             int createCount = 0;
             for (String[] dirs : dirCopyMap.values()) {
                 for (int i = 0; i < dirs.length; i++) {
                     File d = new File(dirs[i]);
                     if (!d.exists()) {
-                        if (!d.mkdirs()) {
+                        if (!(d.mkdirs() || d.isDirectory())) {
                             log("Unable to create directory "
                                 + d.getAbsolutePath(), Project.MSG_ERR);
                         } else {
                             createCount++;
                         }
                     }
                 }
             }
             if (createCount > 0) {
                 log("Copied " + dirCopyMap.size()
                     + " empty director"
                     + (dirCopyMap.size() == 1 ? "y" : "ies")
                     + " to " + createCount
                     + " empty director"
                     + (createCount == 1 ? "y" : "ies") + " under "
                     + destDir.getAbsolutePath());
             }
         }
     }
 
     /**
      * Actually does the resource copies.
      * This is a good method for subclasses to override.
      * @param map a map of source resource to array of destination files.
      * @since Ant 1.7
      */
     protected void doResourceOperations(Map<Resource, String[]> map) {
         if (map.size() > 0) {
             log("Copying " + map.size()
                 + " resource" + (map.size() == 1 ? "" : "s")
                 + " to " + destDir.getAbsolutePath());
 
             for (Map.Entry<Resource, String[]> e : map.entrySet()) {
                 Resource fromResource = e.getKey();
                 for (String toFile : e.getValue()) {
                     try {
                         log("Copying " + fromResource + " to " + toFile,
                             verbosity);
 
                         FilterSetCollection executionFilters = new FilterSetCollection();
                         if (filtering) {
                             executionFilters
                                 .addFilterSet(getProject().getGlobalFilterSet());
                         }
                         for (FilterSet filterSet : filterSets) {
                             executionFilters.addFilterSet(filterSet);
                         }
                         ResourceUtils.copyResource(fromResource,
                                                    new FileResource(destDir,
                                                                     toFile),
                                                    executionFilters,
                                                    filterChains,
                                                    forceOverwrite,
                                                    preserveLastModified,
                                                    /* append: */ false,
                                                    inputEncoding,
                                                    outputEncoding,
                                                    getProject(),
                                                    getForce());
                     } catch (IOException ioe) {
                         String msg = "Failed to copy " + fromResource
                             + " to " + toFile
                             + " due to " + getDueTo(ioe);
                         File targetFile = new File(toFile);
                         if (targetFile.exists() && !targetFile.delete()) {
                             msg += " and I couldn't delete the corrupt " + toFile;
                         }
                         if (failonerror) {
                             throw new BuildException(msg, ioe, getLocation());
                         }
                         log(msg, Project.MSG_ERR);
                     }
                 }
             }
         }
     }
 
     /**
      * Whether this task can deal with non-file resources.
      *
      * <p>&lt;copy&gt; can while &lt;move&gt; can't since we don't
      * know how to remove non-file resources.</p>
      *
      * <p>This implementation returns true only if this task is
      * &lt;copy&gt;.  Any subclass of this class that also wants to
      * support non-file resources needs to override this method.  We
      * need to do so for backwards compatibility reasons since we
      * can't expect subclasses to support resources.</p>
      * @return true if this task supports non file resources.
      * @since Ant 1.7
      */
     protected boolean supportsNonFileResources() {
         return getClass().equals(Copy.class);
     }
 
     /**
      * Adds the given strings to a list contained in the given map.
      * The file is the key into the map.
      */
     private static void add(File baseDir, String[] names, Map<File, List<String>> m) {
         if (names != null) {
             baseDir = getKeyFile(baseDir);
             List<String> l = m.get(baseDir);
             if (l == null) {
                 l = new ArrayList<String>(names.length);
                 m.put(baseDir, l);
             }
             l.addAll(java.util.Arrays.asList(names));
         }
     }
 
     /**
      * Adds the given string to a list contained in the given map.
      * The file is the key into the map.
      */
     private static void add(File baseDir, String name, Map<File, List<String>> m) {
         if (name != null) {
             add(baseDir, new String[] {name}, m);
         }
     }
 
     /**
      * Either returns its argument or a plaeholder if the argument is null.
      */
     private static File getKeyFile(File f) {
         return f == null ? NULL_FILE_PLACEHOLDER : f;
     }
 
     /**
      * returns the mapper to use based on nested elements or the
      * flatten attribute.
      */
     private FileNameMapper getMapper() {
         FileNameMapper mapper = null;
         if (mapperElement != null) {
             mapper = mapperElement.getImplementation();
         } else if (flatten) {
             mapper = new FlatFileNameMapper();
         } else {
             mapper = new IdentityMapper();
         }
         return mapper;
     }
 
     /**
      * Handle getMessage() for exceptions.
      * @param ex the exception to handle
      * @return ex.getMessage() if ex.getMessage() is not null
      *         otherwise return ex.toString()
      */
     private String getMessage(Exception ex) {
         return ex.getMessage() == null ? ex.toString() : ex.getMessage();
     }
 
     /**
      * Returns a reason for failure based on
      * the exception thrown.
      * If the exception is not IOException output the class name,
      * output the message
      * if the exception is MalformedInput add a little note.
      */
     private String getDueTo(Exception ex) {
         boolean baseIOException = ex.getClass() == IOException.class;
         StringBuffer message = new StringBuffer();
         if (!baseIOException || ex.getMessage() == null) {
             message.append(ex.getClass().getName());
         }
         if (ex.getMessage() != null) {
             if (!baseIOException) {
                 message.append(" ");
             }
             message.append(ex.getMessage());
         }
         if (ex.getClass().getName().indexOf("MalformedInput") != -1) {
             message.append(LINE_SEPARATOR);
             message.append(
                 "This is normally due to the input file containing invalid");
              message.append(LINE_SEPARATOR);
             message.append("bytes for the character encoding used : ");
             message.append(
                 (inputEncoding == null
                  ? fileUtils.getDefaultEncoding() : inputEncoding));
             message.append(LINE_SEPARATOR);
         }
         return message.toString();
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Move.java b/src/main/org/apache/tools/ant/taskdefs/Move.java
index 99404b920..4c27bac5a 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Move.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Move.java
@@ -1,382 +1,382 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.IOException;
 import java.util.Iterator;
 
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.taskdefs.condition.Os;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.FilterSet;
 import org.apache.tools.ant.types.FilterSetCollection;
 
 /**
  * Moves a file or directory to a new file or directory.
  * By default, the
  * destination file is overwritten if it already exists.
  * When <i>overwrite</i> is
  * turned off, then files are only moved if the source file is
  * newer than the destination file, or when the destination file does
  * not exist.
  *
  * <p>Source files and directories are only deleted when the file or
  * directory has been copied to the destination successfully.  Filtering
  * also works.</p>
  *
  * <p>This implementation is based on Arnout Kuiper's initial design
  * document, the following mailing list discussions, and the
  * copyfile/copydir tasks.</p>
  *
  * @since Ant 1.2
  *
  * @ant.task category="filesystem"
  */
 public class Move extends Copy {
 
     private boolean performGc = Os.isFamily("windows");
 
     /**
      * Constructor of object.
      * This sets the forceOverwrite attribute of the Copy parent class
      * to true.
      *
      */
     public Move() {
         super();
         setOverwrite(true);
     }
 
     /**
      * Whether to perform a garbage collection before retrying a failed delete.
      *
      * <p>This may be required on Windows (where it is set to true by
      * default) but also on other operating systems, for example when
      * deleting directories from an NFS share.</p>
      *
      * @since Ant 1.8.3
      */
     public void setPerformGcOnFailedDelete(boolean b) {
         performGc = b;
     }
 
     /** {@inheritDoc}. */
     protected void validateAttributes() throws BuildException {
         if (file != null && file.isDirectory()) {
             if ((destFile != null && destDir != null)
                 || (destFile == null && destDir == null)) {
                 throw new BuildException("One and only one of tofile and todir must be set.");
             }
             destFile = destFile == null ? new File(destDir, file.getName()) : destFile;
             destDir = destDir == null ? destFile.getParentFile() : destDir;
 
             completeDirMap.put(file, destFile);
             file = null;
         } else {
             super.validateAttributes();
         }
     }
 
 //************************************************************************
 //  protected and private methods
 //************************************************************************
 
     /**
      * Override copy's doFileOperations to move the files instead of copying them.
      */
     protected void doFileOperations() {
         //Attempt complete directory renames, if any, first.
         if (completeDirMap.size() > 0) {
             for (Iterator fromDirs = completeDirMap.keySet().iterator(); fromDirs.hasNext();) {
                 File fromDir = (File) fromDirs.next();
                 File toDir = (File) completeDirMap.get(fromDir);
                 boolean renamed = false;
                 try {
                     log("Attempting to rename dir: " + fromDir + " to " + toDir, verbosity);
                     renamed = renameFile(fromDir, toDir, filtering, forceOverwrite);
                 } catch (IOException ioe) {
                     String msg = "Failed to rename dir " + fromDir
                             + " to " + toDir + " due to " + ioe.getMessage();
                     throw new BuildException(msg, ioe, getLocation());
                 }
                 if (!renamed) {
                     FileSet fs = new FileSet();
                     fs.setProject(getProject());
                     fs.setDir(fromDir);
                     addFileset(fs);
                     DirectoryScanner ds = fs.getDirectoryScanner(getProject());
                     String[] files = ds.getIncludedFiles();
                     String[] dirs = ds.getIncludedDirectories();
                     scan(fromDir, toDir, files, dirs);
                 }
             }
         }
         int moveCount = fileCopyMap.size();
         if (moveCount > 0) {   // files to move
             log("Moving " + moveCount + " file" + ((moveCount == 1) ? "" : "s")
                     + " to " + destDir.getAbsolutePath());
 
             for (Iterator fromFiles = fileCopyMap.keySet().iterator(); fromFiles.hasNext();) {
                 String fromFile = (String) fromFiles.next();
                 File f = new File(fromFile);
                 boolean selfMove = false;
                 if (f.exists()) { //Is this file still available to be moved?
                     String[] toFiles = (String[]) fileCopyMap.get(fromFile);
                     for (int i = 0; i < toFiles.length; i++) {
                         String toFile = (String) toFiles[i];
 
                         if (fromFile.equals(toFile)) {
                             log("Skipping self-move of " + fromFile, verbosity);
                             selfMove = true;
 
                             // if this is the last time through the loop then
                             // move will not occur, but that's what we want
                             continue;
                         }
                         File d = new File(toFile);
                         if ((i + 1) == toFiles.length && !selfMove) {
                             // Only try to move if this is the last mapped file
                             // and one of the mappings isn't to itself
                             moveFile(f, d, filtering, forceOverwrite);
                         } else {
                             copyFile(f, d, filtering, forceOverwrite);
                         }
                     }
                 }
             }
         }
 
         if (includeEmpty) {
             int createCount = 0;
             for (Iterator fromDirNames = dirCopyMap.keySet().iterator(); fromDirNames.hasNext();) {
                 String fromDirName = (String) fromDirNames.next();
                 String[] toDirNames = (String[]) dirCopyMap.get(fromDirName);
                 boolean selfMove = false;
                 for (int i = 0; i < toDirNames.length; i++) {
                     if (fromDirName.equals(toDirNames[i])) {
                         log("Skipping self-move of " + fromDirName, verbosity);
                         selfMove = true;
                         continue;
                     }
                     File d = new File(toDirNames[i]);
                     if (!d.exists()) {
-                        if (!d.mkdirs()) {
+                        if (!(d.mkdirs() || d.exists())) {
                             log("Unable to create directory "
                                     + d.getAbsolutePath(), Project.MSG_ERR);
                         } else {
                             createCount++;
                         }
                     }
                 }
                 File fromDir = new File(fromDirName);
                 if (!selfMove && okToDelete(fromDir)) {
                     deleteDir(fromDir);
                 }
             }
             if (createCount > 0) {
                 log("Moved " + dirCopyMap.size()
                         + " empty director"
                         + (dirCopyMap.size() == 1 ? "y" : "ies")
                         + " to " + createCount
                         + " empty director"
                         + (createCount == 1 ? "y" : "ies") + " under "
                         + destDir.getAbsolutePath());
             }
         }
     }
 
     /**
      * Try to move the file via a rename, but if this fails or filtering
      * is enabled, copy the file then delete the sourceFile.
      */
     private void moveFile(File fromFile, File toFile, boolean filtering, boolean overwrite) {
         boolean moved = false;
         try {
             log("Attempting to rename: " + fromFile + " to " + toFile, verbosity);
             moved = renameFile(fromFile, toFile, filtering, forceOverwrite);
         } catch (IOException ioe) {
             String msg = "Failed to rename " + fromFile
                 + " to " + toFile + " due to " + ioe.getMessage();
             throw new BuildException(msg, ioe, getLocation());
         }
 
         if (!moved) {
             copyFile(fromFile, toFile, filtering, overwrite);
             if (!getFileUtils().tryHardToDelete(fromFile, performGc)) {
                 throw new BuildException("Unable to delete " + "file "
                         + fromFile.getAbsolutePath());
             }
         }
     }
 
     /**
      * Copy fromFile to toFile.
      * @param fromFile
      * @param toFile
      * @param filtering
      * @param overwrite
      */
     private void copyFile(File fromFile, File toFile, boolean filtering, boolean overwrite) {
         try {
             log("Copying " + fromFile + " to " + toFile, verbosity);
 
             FilterSetCollection executionFilters = new FilterSetCollection();
             if (filtering) {
                 executionFilters.addFilterSet(getProject().getGlobalFilterSet());
             }
             for (Iterator filterIter = getFilterSets().iterator(); filterIter.hasNext();) {
                 executionFilters.addFilterSet((FilterSet) filterIter.next());
             }
             getFileUtils().copyFile(fromFile, toFile, executionFilters,
                                     getFilterChains(),
                                     forceOverwrite,
                                     getPreserveLastModified(),
                                     /* append: */ false,
                                     getEncoding(),
                                     getOutputEncoding(),
                                     getProject(), getForce());
         } catch (IOException ioe) {
             String msg = "Failed to copy " + fromFile
                     + " to " + toFile + " due to " + ioe.getMessage();
             throw new BuildException(msg, ioe, getLocation());
         }
     }
 
     /**
      * Its only ok to delete a directory tree if there are no files in it.
      * @param d the directory to check
      * @return true if a deletion can go ahead
      */
     protected boolean okToDelete(File d) {
         String[] list = d.list();
         if (list == null) {
             return false;
         }     // maybe io error?
 
         for (int i = 0; i < list.length; i++) {
             String s = list[i];
             File f = new File(d, s);
             if (f.isDirectory()) {
                 if (!okToDelete(f)) {
                     return false;
                 }
             } else {
                 return false;   // found a file
             }
         }
         return true;
     }
 
     /**
      * Go and delete the directory tree.
      * @param d the directory to delete
      */
     protected void deleteDir(File d) {
         deleteDir(d, false);
     }
 
     /**
      * Go and delete the directory tree.
      * @param d the directory to delete
      * @param deleteFiles whether to delete files
      */
     protected void deleteDir(File d, boolean deleteFiles) {
         String[] list = d.list();
         if (list == null) {
             return;
         }      // on an io error list() can return null
 
         for (int i = 0; i < list.length; i++) {
             String s = list[i];
             File f = new File(d, s);
             if (f.isDirectory()) {
                 deleteDir(f);
             } else if (deleteFiles && !getFileUtils().tryHardToDelete(f,
                                                                       performGc)) {
                 throw new BuildException("Unable to delete file " + f.getAbsolutePath());
             } else {
                 throw new BuildException("UNEXPECTED ERROR - The file "
                         + f.getAbsolutePath() + " should not exist!");
             }
         }
         log("Deleting directory " + d.getAbsolutePath(), verbosity);
         if (!getFileUtils().tryHardToDelete(d, performGc)) {
             throw new BuildException("Unable to delete directory " + d.getAbsolutePath());
         }
     }
 
     /**
      * Attempts to rename a file from a source to a destination.
      * If overwrite is set to true, this method overwrites existing file
      * even if the destination file is newer.  Otherwise, the source file is
      * renamed only if the destination file is older than it.
      * Method then checks if token filtering is used.  If it is, this method
      * returns false assuming it is the responsibility to the copyFile method.
      *
      * @param sourceFile the file to rename
      * @param destFile   the destination file
      * @param filtering  if true, filtering is in operation, file will
      *                   be copied/deleted instead of renamed
      * @param overwrite  if true force overwrite even if destination file
      *                   is newer than source file
      * @return true if the file was renamed
      * @exception IOException if an error occurs
      * @exception BuildException if an error occurs
      */
     protected boolean renameFile(File sourceFile, File destFile, boolean filtering,
                                  boolean overwrite) throws IOException, BuildException {
         if (destFile.isDirectory() || filtering || getFilterSets().size() > 0
                 || getFilterChains().size() > 0) {
             return false;
         }
 
         // identical logic lives in ResourceUtils.copyResource():
         if (destFile.isFile() && !destFile.canWrite()) {
             if (!getForce()) {
                 throw new IOException("can't replace read-only destination "
                                       + "file " + destFile);
             } else if (!getFileUtils().tryHardToDelete(destFile)) {
                 throw new IOException("failed to delete read-only "
                                       + "destination file " + destFile);
             }
         }
 
         // identical logic lives in FileUtils.rename():
         File parent = destFile.getParentFile();
         if (parent != null && !parent.exists()) {
             parent.mkdirs();
         } else if (destFile.isFile()) {
             sourceFile = getFileUtils().normalize(sourceFile.getAbsolutePath()).getCanonicalFile();
             destFile = getFileUtils().normalize(destFile.getAbsolutePath());
             if (destFile.getAbsolutePath().equals(sourceFile.getAbsolutePath())) {
                 //no point in renaming a file to its own canonical version...
                 log("Rename of " + sourceFile + " to " + destFile
                     + " is a no-op.", Project.MSG_VERBOSE);
                 return true;
             }
             if (!(getFileUtils().areSame(sourceFile, destFile)
                   || getFileUtils().tryHardToDelete(destFile, performGc))) {
                 throw new BuildException("Unable to remove existing file " + destFile);
             }
         }
         return sourceFile.renameTo(destFile);
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Tar.java b/src/main/org/apache/tools/ant/taskdefs/Tar.java
index 000f2f415..a0230dcd4 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Tar.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Tar.java
@@ -1,973 +1,974 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.BufferedOutputStream;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Vector;
 import java.util.zip.GZIPOutputStream;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.ArchiveFileSet;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.resources.ArchiveResource;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.selectors.SelectorUtils;
 import org.apache.tools.ant.types.resources.TarResource;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.MergingMapper;
 import org.apache.tools.ant.util.ResourceUtils;
 import org.apache.tools.ant.util.SourceFileScanner;
 import org.apache.tools.bzip2.CBZip2OutputStream;
 import org.apache.tools.tar.TarConstants;
 import org.apache.tools.tar.TarEntry;
 import org.apache.tools.tar.TarOutputStream;
 
 /**
  * Creates a tar archive.
  *
  * @since Ant 1.1
  *
  * @ant.task category="packaging"
  */
 public class Tar extends MatchingTask {
     private static final int BUFFER_SIZE = 8 * 1024;
 
     /**
      * @deprecated since 1.5.x.
      *             Tar.WARN is deprecated and is replaced with
      *             Tar.TarLongFileMode.WARN
      */
     public static final String WARN = "warn";
     /**
      * @deprecated since 1.5.x.
      *             Tar.FAIL is deprecated and is replaced with
      *             Tar.TarLongFileMode.FAIL
      */
     public static final String FAIL = "fail";
     /**
      * @deprecated since 1.5.x.
      *             Tar.TRUNCATE is deprecated and is replaced with
      *             Tar.TarLongFileMode.TRUNCATE
      */
     public static final String TRUNCATE = "truncate";
     /**
      * @deprecated since 1.5.x.
      *             Tar.GNU is deprecated and is replaced with
      *             Tar.TarLongFileMode.GNU
      */
     public static final String GNU = "gnu";
     /**
      * @deprecated since 1.5.x.
      *             Tar.OMIT is deprecated and is replaced with
      *             Tar.TarLongFileMode.OMIT
      */
     public static final String OMIT = "omit";
 
     // CheckStyle:VisibilityModifier OFF - bc
     File tarFile;
     File baseDir;
 
     private TarLongFileMode longFileMode = new TarLongFileMode();
 
     // need to keep the package private version for backwards compatibility
     Vector filesets = new Vector();
     // we must keep two lists since other classes may modify the
     // filesets Vector (it is package private) without us noticing
     private Vector resourceCollections = new Vector();
 
     Vector fileSetFiles = new Vector();
 
     // CheckStyle:VisibilityModifier ON
 
     /**
      * Indicates whether the user has been warned about long files already.
      */
     private boolean longWarningGiven = false;
 
     private TarCompressionMethod compression = new TarCompressionMethod();
 
     /**
      * Add a new fileset with the option to specify permissions
      * @return the tar fileset to be used as the nested element.
      */
     public TarFileSet createTarFileSet() {
         TarFileSet fs = new TarFileSet();
         fs.setProject(getProject());
         filesets.addElement(fs);
         return fs;
     }
 
     /**
      * Add a collection of resources to archive.
      * @param res a resource collection to archive.
      * @since Ant 1.7
      */
     public void add(ResourceCollection res) {
         resourceCollections.add(res);
     }
 
     /**
      * Set is the name/location of where to create the tar file.
      * @param tarFile the location of the tar file.
      * @deprecated since 1.5.x.
      *             For consistency with other tasks, please use setDestFile().
      */
     public void setTarfile(File tarFile) {
         this.tarFile = tarFile;
     }
 
     /**
      * Set is the name/location of where to create the tar file.
      * @since Ant 1.5
      * @param destFile The output of the tar
      */
     public void setDestFile(File destFile) {
         this.tarFile = destFile;
     }
 
     /**
      * This is the base directory to look in for things to tar.
      * @param baseDir the base directory.
      */
     public void setBasedir(File baseDir) {
         this.baseDir = baseDir;
     }
 
     /**
      * Set how to handle long files, those with a path&gt;100 chars.
      * Optional, default=warn.
      * <p>
      * Allowable values are
      * <ul>
      * <li>  truncate - paths are truncated to the maximum length
      * <li>  fail - paths greater than the maximum cause a build exception
      * <li>  warn - paths greater than the maximum cause a warning and GNU is used
      * <li>  gnu - GNU extensions are used for any paths greater than the maximum.
      * <li>  omit - paths greater than the maximum are omitted from the archive
      * </ul>
      * @param mode the mode string to handle long files.
      * @deprecated since 1.5.x.
      *             setLongFile(String) is deprecated and is replaced with
      *             setLongFile(Tar.TarLongFileMode) to make Ant's Introspection
      *             mechanism do the work and also to encapsulate operations on
      *             the mode in its own class.
      */
     public void setLongfile(String mode) {
         log("DEPRECATED - The setLongfile(String) method has been deprecated."
             + " Use setLongfile(Tar.TarLongFileMode) instead.");
         this.longFileMode = new TarLongFileMode();
         longFileMode.setValue(mode);
     }
 
     /**
      * Set how to handle long files, those with a path&gt;100 chars.
      * Optional, default=warn.
      * <p>
      * Allowable values are
      * <ul>
      * <li>  truncate - paths are truncated to the maximum length
      * <li>  fail - paths greater than the maximum cause a build exception
      * <li>  warn - paths greater than the maximum cause a warning and GNU is used
      * <li>  gnu - extensions used by older versions of GNU tar are used for any paths greater than the maximum.
      * <li>  posix - use POSIX PAX extension headers for any paths greater than the maximum.  Supported by all modern tar implementations.
      * <li>  omit - paths greater than the maximum are omitted from the archive
      * </ul>
      * @param mode the mode to handle long file names.
      */
     public void setLongfile(TarLongFileMode mode) {
         this.longFileMode = mode;
     }
 
     /**
      * Set compression method.
      * Allowable values are
      * <ul>
      * <li>  none - no compression
      * <li>  gzip - Gzip compression
      * <li>  bzip2 - Bzip2 compression
      * </ul>
      * @param mode the compression method.
      */
     public void setCompression(TarCompressionMethod mode) {
         this.compression = mode;
     }
 
     /**
      * do the business
      * @throws BuildException on error
      */
     public void execute() throws BuildException {
         if (tarFile == null) {
             throw new BuildException("tarfile attribute must be set!",
                                      getLocation());
         }
 
         if (tarFile.exists() && tarFile.isDirectory()) {
             throw new BuildException("tarfile is a directory!",
                                      getLocation());
         }
 
         if (tarFile.exists() && !tarFile.canWrite()) {
             throw new BuildException("Can not write to the specified tarfile!",
                                      getLocation());
         }
 
         Vector savedFileSets = (Vector) filesets.clone();
         try {
             if (baseDir != null) {
                 if (!baseDir.exists()) {
                     throw new BuildException("basedir does not exist!",
                                              getLocation());
                 }
 
                 // add the main fileset to the list of filesets to process.
                 TarFileSet mainFileSet = new TarFileSet(fileset);
                 mainFileSet.setDir(baseDir);
                 filesets.addElement(mainFileSet);
             }
 
             if (filesets.size() == 0 && resourceCollections.size() == 0) {
                 throw new BuildException("You must supply either a basedir "
                                          + "attribute or some nested resource"
                                          + " collections.",
                                          getLocation());
             }
 
             // check if tar is out of date with respect to each
             // fileset
             boolean upToDate = true;
             for (Enumeration e = filesets.elements(); e.hasMoreElements();) {
                 upToDate &= check((TarFileSet) e.nextElement());
             }
             for (Enumeration e = resourceCollections.elements();
                  e.hasMoreElements();) {
                 upToDate &= check((ResourceCollection) e.nextElement());
             }
 
             if (upToDate) {
                 log("Nothing to do: " + tarFile.getAbsolutePath()
                     + " is up to date.", Project.MSG_INFO);
                 return;
             }
 
             File parent = tarFile.getParentFile();
-            if (parent != null && !parent.isDirectory() && !parent.mkdirs()) {
+            if (parent != null && !parent.isDirectory()
+                && !(parent.mkdirs() || parent.isDirectory())) {
                 throw new BuildException("Failed to create missing parent"
                                          + " directory for " + tarFile);
             }
 
             log("Building tar: " + tarFile.getAbsolutePath(), Project.MSG_INFO);
 
             TarOutputStream tOut = null;
             try {
                 tOut = new TarOutputStream(
                     compression.compress(
                         new BufferedOutputStream(
                             new FileOutputStream(tarFile))));
                 tOut.setDebug(true);
                 if (longFileMode.isTruncateMode()) {
                     tOut.setLongFileMode(TarOutputStream.LONGFILE_TRUNCATE);
                 } else if (longFileMode.isFailMode()
                             || longFileMode.isOmitMode()) {
                     tOut.setLongFileMode(TarOutputStream.LONGFILE_ERROR);
                 } else if (longFileMode.isPosixMode()) {
                     tOut.setLongFileMode(TarOutputStream.LONGFILE_POSIX);
                 } else {
                     // warn or GNU
                     tOut.setLongFileMode(TarOutputStream.LONGFILE_GNU);
                 }
 
                 longWarningGiven = false;
                 for (Enumeration e = filesets.elements();
                      e.hasMoreElements();) {
                     tar((TarFileSet) e.nextElement(), tOut);
                 }
                 for (Enumeration e = resourceCollections.elements();
                      e.hasMoreElements();) {
                     tar((ResourceCollection) e.nextElement(), tOut);
                 }
             } catch (IOException ioe) {
                 String msg = "Problem creating TAR: " + ioe.getMessage();
                 throw new BuildException(msg, ioe, getLocation());
             } finally {
                 FileUtils.close(tOut);
             }
         } finally {
             filesets = savedFileSets;
         }
     }
 
     /**
      * tar a file
      * @param file the file to tar
      * @param tOut the output stream
      * @param vPath the path name of the file to tar
      * @param tarFileSet the fileset that the file came from.
      * @throws IOException on error
      */
     protected void tarFile(File file, TarOutputStream tOut, String vPath,
                            TarFileSet tarFileSet)
         throws IOException {
         if (file.equals(tarFile)) {
             // If the archive is built for the first time and it is
             // matched by a resource collection, then it hasn't been
             // found in check (it hasn't been there) but will be
             // included now.
             //
             // for some strange reason the old code would simply skip
             // the entry and not fail, do the same now for backwards
             // compatibility reasons.  Without this, the which4j build
             // fails in Gump
             return;
         }
         tarResource(new FileResource(file), tOut, vPath, tarFileSet);
     }
 
     /**
      * tar a resource
      * @param r the resource to tar
      * @param tOut the output stream
      * @param vPath the path name of the file to tar
      * @param tarFileSet the fileset that the file came from, may be null.
      * @throws IOException on error
      * @since Ant 1.7
      */
     protected void tarResource(Resource r, TarOutputStream tOut, String vPath,
                                TarFileSet tarFileSet)
         throws IOException {
 
         if (!r.isExists()) {
             return;
         }
 
         boolean preserveLeadingSlashes = false;
 
         if (tarFileSet != null) {
             String fullpath = tarFileSet.getFullpath(this.getProject());
             if (fullpath.length() > 0) {
                 vPath = fullpath;
             } else {
                 // don't add "" to the archive
                 if (vPath.length() <= 0) {
                     return;
                 }
 
                 String prefix = tarFileSet.getPrefix(this.getProject());
                 // '/' is appended for compatibility with the zip task.
                 if (prefix.length() > 0 && !prefix.endsWith("/")) {
                     prefix = prefix + "/";
                 }
                 vPath = prefix + vPath;
             }
 
             preserveLeadingSlashes = tarFileSet.getPreserveLeadingSlashes();
 
             if (vPath.startsWith("/") && !preserveLeadingSlashes) {
                 int l = vPath.length();
                 if (l <= 1) {
                     // we would end up adding "" to the archive
                     return;
                 }
                 vPath = vPath.substring(1, l);
             }
         }
 
         if (r.isDirectory() && !vPath.endsWith("/")) {
             vPath += "/";
         }
 
         if (vPath.length() >= TarConstants.NAMELEN) {
             if (longFileMode.isOmitMode()) {
                 log("Omitting: " + vPath, Project.MSG_INFO);
                 return;
             } else if (longFileMode.isWarnMode()) {
                 log("Entry: " + vPath + " longer than "
                     + TarConstants.NAMELEN + " characters.",
                     Project.MSG_WARN);
                 if (!longWarningGiven) {
                     log("Resulting tar file can only be processed "
                         + "successfully by GNU compatible tar commands",
                         Project.MSG_WARN);
                     longWarningGiven = true;
                 }
             } else if (longFileMode.isFailMode()) {
                 throw new BuildException("Entry: " + vPath
                         + " longer than " + TarConstants.NAMELEN
                         + "characters.", getLocation());
             }
         }
 
         TarEntry te = new TarEntry(vPath, preserveLeadingSlashes);
         te.setModTime(r.getLastModified());
         // preserve permissions
         if (r instanceof ArchiveResource) {
             ArchiveResource ar = (ArchiveResource) r;
             te.setMode(ar.getMode());
             if (r instanceof TarResource) {
                 TarResource tr = (TarResource) r;
                 te.setUserName(tr.getUserName());
                 te.setUserId(tr.getUid());
                 te.setGroupName(tr.getGroup());
                 te.setGroupId(tr.getGid());
             }
         }
 
         if (!r.isDirectory()) {
             if (r.size() > TarConstants.MAXSIZE) {
                 throw new BuildException(
                     "Resource: " + r + " larger than "
                     + TarConstants.MAXSIZE + " bytes.");
             }
             te.setSize(r.getSize());
             // override permissions if set explicitly
             if (tarFileSet != null && tarFileSet.hasFileModeBeenSet()) {
                 te.setMode(tarFileSet.getMode());
             }
         } else if (tarFileSet != null && tarFileSet.hasDirModeBeenSet()) {
             // override permissions if set explicitly
             te.setMode(tarFileSet.getDirMode(this.getProject()));
         }
 
         if (tarFileSet != null) {
             // only override permissions if set explicitly
             if (tarFileSet.hasUserNameBeenSet()) {
                 te.setUserName(tarFileSet.getUserName());
             }
             if (tarFileSet.hasGroupBeenSet()) {
                 te.setGroupName(tarFileSet.getGroup());
             }
             if (tarFileSet.hasUserIdBeenSet()) {
                 te.setUserId(tarFileSet.getUid());
             }
             if (tarFileSet.hasGroupIdBeenSet()) {
                 te.setGroupId(tarFileSet.getGid());
             }
         }
 
         InputStream in = null;
         try {
             tOut.putNextEntry(te);
 
             if (!r.isDirectory()) {
                 in = r.getInputStream();
 
                 byte[] buffer = new byte[BUFFER_SIZE];
                 int count = 0;
                 do {
                     tOut.write(buffer, 0, count);
                     count = in.read(buffer, 0, buffer.length);
                 } while (count != -1);
             }
 
             tOut.closeEntry();
         } finally {
             FileUtils.close(in);
         }
     }
 
     /**
      * Is the archive up to date in relationship to a list of files.
      * @param files the files to check
      * @return true if the archive is up to date.
      * @deprecated since 1.5.x.
      *             use the two-arg version instead.
      */
     protected boolean archiveIsUpToDate(String[] files) {
         return archiveIsUpToDate(files, baseDir);
     }
 
     /**
      * Is the archive up to date in relationship to a list of files.
      * @param files the files to check
      * @param dir   the base directory for the files.
      * @return true if the archive is up to date.
      * @since Ant 1.5.2
      */
     protected boolean archiveIsUpToDate(String[] files, File dir) {
         SourceFileScanner sfs = new SourceFileScanner(this);
         MergingMapper mm = new MergingMapper();
         mm.setTo(tarFile.getAbsolutePath());
         return sfs.restrict(files, dir, null, mm).length == 0;
     }
 
     /**
      * Is the archive up to date in relationship to a list of files.
      * @param r the files to check
      * @return true if the archive is up to date.
      * @since Ant 1.7
      */
     protected boolean archiveIsUpToDate(Resource r) {
         return SelectorUtils.isOutOfDate(new FileResource(tarFile), r,
                                          FileUtils.getFileUtils()
                                          .getFileTimestampGranularity());
     }
 
     /**
      * Whether this task can deal with non-file resources.
      *
      * <p>This implementation returns true only if this task is
      * &lt;tar&gt;.  Any subclass of this class that also wants to
      * support non-file resources needs to override this method.  We
      * need to do so for backwards compatibility reasons since we
      * can't expect subclasses to support resources.</p>
      * @return true for this task.
      * @since Ant 1.7
      */
     protected boolean supportsNonFileResources() {
         return getClass().equals(Tar.class);
     }
 
     /**
      * Checks whether the archive is out-of-date with respect to the resources
      * of the given collection.
      *
      * <p>Also checks that either all collections only contain file
      * resources or this class supports non-file collections.</p>
      *
      * <p>And - in case of file-collections - ensures that the archive won't
      * contain itself.</p>
      *
      * @param rc the resource collection to check
      * @return whether the archive is up-to-date
      * @since Ant 1.7
      */
     protected boolean check(ResourceCollection rc) {
         boolean upToDate = true;
         if (isFileFileSet(rc)) {
             FileSet fs = (FileSet) rc;
             upToDate = check(fs.getDir(getProject()), getFileNames(fs));
         } else if (!rc.isFilesystemOnly() && !supportsNonFileResources()) {
             throw new BuildException("only filesystem resources are supported");
         } else if (rc.isFilesystemOnly()) {
             HashSet basedirs = new HashSet();
             HashMap basedirToFilesMap = new HashMap();
             for (Resource res : rc) {
                 FileResource r = ResourceUtils
                     .asFileResource(res.as(FileProvider.class));
                 File base = r.getBaseDir();
                 if (base == null) {
                     base = Copy.NULL_FILE_PLACEHOLDER;
                 }
                 basedirs.add(base);
                 Vector files = (Vector) basedirToFilesMap.get(base);
                 if (files == null) {
                     files = new Vector();
                     basedirToFilesMap.put(base, files);
                 }
                 if (base == Copy.NULL_FILE_PLACEHOLDER) {
                     files.add(r.getFile().getAbsolutePath());
                 } else {
                     files.add(r.getName());
                 }
             }
             Iterator iter = basedirs.iterator();
             while (iter.hasNext()) {
                 File base = (File) iter.next();
                 Vector f = (Vector) basedirToFilesMap.get(base);
                 String[] files = (String[]) f.toArray(new String[f.size()]);
                 upToDate &=
                     check(base == Copy.NULL_FILE_PLACEHOLDER ? null : base,
                           files);
             }
         } else { // non-file resources
             Iterator<Resource> iter = rc.iterator();
             while (upToDate && iter.hasNext()) {
                 Resource r = iter.next();
                 upToDate = archiveIsUpToDate(r);
             }
         }
         return upToDate;
     }
 
     /**
      * Checks whether the archive is out-of-date with respect to the
      * given files, ensures that the archive won't contain itself.</p>
      *
      * @param basedir base directory for file names
      * @param files array of relative file names
      * @return whether the archive is up-to-date
      * @since Ant 1.7
      */
     protected boolean check(File basedir, String[] files) {
         boolean upToDate = true;
         if (!archiveIsUpToDate(files, basedir)) {
             upToDate = false;
         }
 
         for (int i = 0; i < files.length; ++i) {
             if (tarFile.equals(new File(basedir, files[i]))) {
                 throw new BuildException("A tar file cannot include "
                                          + "itself", getLocation());
             }
         }
         return upToDate;
     }
 
     /**
      * Adds the resources contained in this collection to the archive.
      *
      * <p>Uses the file based methods for file resources for backwards
      * compatibility.</p>
      *
      * @param rc the collection containing resources to add
      * @param tOut stream writing to the archive.
      * @throws IOException on error.
      * @since Ant 1.7
      */
     protected void tar(ResourceCollection rc, TarOutputStream tOut)
         throws IOException {
         ArchiveFileSet afs = null;
         if (rc instanceof ArchiveFileSet) {
             afs = (ArchiveFileSet) rc;
         }
         if (afs != null && afs.size() > 1
             && afs.getFullpath(this.getProject()).length() > 0) {
             throw new BuildException("fullpath attribute may only "
                                      + "be specified for "
                                      + "filesets that specify a "
                                      + "single file.");
         }
         TarFileSet tfs = asTarFileSet(afs);
 
         if (isFileFileSet(rc)) {
             FileSet fs = (FileSet) rc;
             String[] files = getFileNames(fs);
             for (int i = 0; i < files.length; i++) {
                 File f = new File(fs.getDir(getProject()), files[i]);
                 String name = files[i].replace(File.separatorChar, '/');
                 tarFile(f, tOut, name, tfs);
             }
         } else if (rc.isFilesystemOnly()) {
             for (Resource r : rc) {
                 File f = r.as(FileProvider.class).getFile();
                 tarFile(f, tOut, f.getName(), tfs);
             }
         } else { // non-file resources
             for (Resource r : rc) {
                 tarResource(r, tOut, r.getName(), tfs);
             }
         }
     }
 
     /**
      * whether the given resource collection is a (subclass of)
      * FileSet that only contains file system resources.
      * @param rc the resource collection to check.
      * @return true if the collection is a fileset.
      * @since Ant 1.7
      */
     protected static boolean isFileFileSet(ResourceCollection rc) {
         return rc instanceof FileSet && rc.isFilesystemOnly();
     }
 
     /**
      * Grabs all included files and directors from the FileSet and
      * returns them as an array of (relative) file names.
      * @param fs the fileset to operate on.
      * @return a list of the filenames.
      * @since Ant 1.7
      */
     protected static String[] getFileNames(FileSet fs) {
         DirectoryScanner ds = fs.getDirectoryScanner(fs.getProject());
         String[] directories = ds.getIncludedDirectories();
         String[] filesPerSe = ds.getIncludedFiles();
         String[] files = new String [directories.length + filesPerSe.length];
         System.arraycopy(directories, 0, files, 0, directories.length);
         System.arraycopy(filesPerSe, 0, files, directories.length,
                          filesPerSe.length);
         return files;
     }
 
     /**
      * Copies fullpath, prefix and permission attributes from the
      * ArchiveFileSet to a new TarFileSet (or returns it unchanged if
      * it already is a TarFileSet).
      *
      * @param archiveFileSet fileset to copy attributes from, may be null
      * @return a new TarFileSet.
      * @since Ant 1.7
      */
     protected TarFileSet asTarFileSet(ArchiveFileSet archiveFileSet) {
         TarFileSet tfs = null;
         if (archiveFileSet != null && archiveFileSet instanceof TarFileSet) {
             tfs = (TarFileSet) archiveFileSet;
         } else {
             tfs = new TarFileSet();
             tfs.setProject(getProject());
             if (archiveFileSet != null) {
                 tfs.setPrefix(archiveFileSet.getPrefix(getProject()));
                 tfs.setFullpath(archiveFileSet.getFullpath(getProject()));
                 if (archiveFileSet.hasFileModeBeenSet()) {
                     tfs.integerSetFileMode(archiveFileSet
                                            .getFileMode(getProject()));
                 }
                 if (archiveFileSet.hasDirModeBeenSet()) {
                     tfs.integerSetDirMode(archiveFileSet
                                           .getDirMode(getProject()));
                 }
 
                 if (archiveFileSet
                     instanceof org.apache.tools.ant.types.TarFileSet) {
                     org.apache.tools.ant.types.TarFileSet t =
                         (org.apache.tools.ant.types.TarFileSet) archiveFileSet;
                     if (t.hasUserNameBeenSet()) {
                         tfs.setUserName(t.getUserName());
                     }
                     if (t.hasGroupBeenSet()) {
                         tfs.setGroup(t.getGroup());
                     }
                     if (t.hasUserIdBeenSet()) {
                         tfs.setUid(t.getUid());
                     }
                     if (t.hasGroupIdBeenSet()) {
                         tfs.setGid(t.getGid());
                     }
                 }
             }
         }
         return tfs;
     }
 
     /**
      * This is a FileSet with the option to specify permissions
      * and other attributes.
      */
     public static class TarFileSet
         extends org.apache.tools.ant.types.TarFileSet {
         private String[] files = null;
 
         private boolean preserveLeadingSlashes = false;
 
         /**
          * Creates a new <code>TarFileSet</code> instance.
          * Using a fileset as a constructor argument.
          *
          * @param fileset a <code>FileSet</code> value
          */
         public TarFileSet(FileSet fileset) {
             super(fileset);
         }
 
         /**
          * Creates a new <code>TarFileSet</code> instance.
          *
          */
         public TarFileSet() {
             super();
         }
 
         /**
          *  Get a list of files and directories specified in the fileset.
          * @param p the current project.
          * @return a list of file and directory names, relative to
          *    the baseDir for the project.
          */
         public String[] getFiles(Project p) {
             if (files == null) {
                 files = getFileNames(this);
             }
 
             return files;
         }
 
         /**
          * A 3 digit octal string, specify the user, group and
          * other modes in the standard Unix fashion;
          * optional, default=0644
          * @param octalString a 3 digit octal string.
          */
         public void setMode(String octalString) {
             setFileMode(octalString);
         }
 
         /**
          * @return the current mode.
          */
         public int getMode() {
             return getFileMode(this.getProject());
         }
 
         /**
          * Flag to indicates whether leading `/'s should
          * be preserved in the file names.
          * Optional, default is <code>false</code>.
          * @param b the leading slashes flag.
          */
         public void setPreserveLeadingSlashes(boolean b) {
             this.preserveLeadingSlashes = b;
         }
 
         /**
          * @return the leading slashes flag.
          */
         public boolean getPreserveLeadingSlashes() {
             return preserveLeadingSlashes;
         }
     }
 
     /**
      * Set of options for long file handling in the task.
      *
      */
     public static class TarLongFileMode extends EnumeratedAttribute {
 
         /** permissible values for longfile attribute */
         public static final String
             WARN = "warn",
             FAIL = "fail",
             TRUNCATE = "truncate",
             GNU = "gnu",
             POSIX = "posix",
             OMIT = "omit";
 
         private final String[] validModes = {
             WARN, FAIL, TRUNCATE, GNU, POSIX, OMIT
         };
 
         /** Constructor, defaults to "warn" */
         public TarLongFileMode() {
             super();
             setValue(WARN);
         }
 
         /**
          * @return the possible values for this enumerated type.
          */
         public String[] getValues() {
             return validModes;
         }
 
         /**
          * @return true if value is "truncate".
          */
         public boolean isTruncateMode() {
             return TRUNCATE.equalsIgnoreCase(getValue());
         }
 
         /**
          * @return true if value is "warn".
          */
         public boolean isWarnMode() {
             return WARN.equalsIgnoreCase(getValue());
         }
 
         /**
          * @return true if value is "gnu".
          */
         public boolean isGnuMode() {
             return GNU.equalsIgnoreCase(getValue());
         }
 
         /**
          * @return true if value is "fail".
          */
         public boolean isFailMode() {
             return FAIL.equalsIgnoreCase(getValue());
         }
 
         /**
          * @return true if value is "omit".
          */
         public boolean isOmitMode() {
             return OMIT.equalsIgnoreCase(getValue());
         }
 
         /**
          * @return true if value is "posix".
          */
         public boolean isPosixMode() {
             return POSIX.equalsIgnoreCase(getValue());
         }
     }
 
     /**
      * Valid Modes for Compression attribute to Tar Task
      *
      */
     public static final class TarCompressionMethod extends EnumeratedAttribute {
 
         // permissible values for compression attribute
         /**
          *    No compression
          */
         private static final String NONE = "none";
         /**
          *    GZIP compression
          */
         private static final String GZIP = "gzip";
         /**
          *    BZIP2 compression
          */
         private static final String BZIP2 = "bzip2";
 
 
         /**
          * Default constructor
          */
         public TarCompressionMethod() {
             super();
             setValue(NONE);
         }
 
         /**
          *  Get valid enumeration values.
          *  @return valid enumeration values
          */
         public String[] getValues() {
             return new String[] {NONE, GZIP, BZIP2 };
         }
 
         /**
          *  This method wraps the output stream with the
          *     corresponding compression method
          *
          *  @param ostream output stream
          *  @return output stream with on-the-fly compression
          *  @exception IOException thrown if file is not writable
          */
         private OutputStream compress(final OutputStream ostream)
             throws IOException {
             final String v = getValue();
             if (GZIP.equals(v)) {
                 return new GZIPOutputStream(ostream);
             } else {
                 if (BZIP2.equals(v)) {
                     ostream.write('B');
                     ostream.write('Z');
                     return new CBZip2OutputStream(ostream);
                 }
             }
             return ostream;
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java b/src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java
index e602b9b56..94271f54e 100644
--- a/src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java
+++ b/src/main/org/apache/tools/ant/taskdefs/XSLTProcess.java
@@ -1,1686 +1,1686 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.EnumMap;
 import java.util.Enumeration;
 import java.util.List;
 import java.util.Map;
 import java.util.Vector;
 import javax.xml.namespace.QName;
 import javax.xml.xpath.XPath;
 import javax.xml.xpath.XPathConstants;
 import javax.xml.xpath.XPathExpression;
 import javax.xml.xpath.XPathExpressionException;
 import javax.xml.xpath.XPathFactory;
 import javax.xml.xpath.XPathVariableResolver;
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.DynamicConfigurator;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.PropertyHelper;
 import org.apache.tools.ant.types.CommandlineJava;
 import org.apache.tools.ant.types.Environment;
 import org.apache.tools.ant.types.Mapper;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.types.PropertySet;
 import org.apache.tools.ant.types.Reference;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.XMLCatalog;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.Resources;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.ResourceUtils;
 
 /**
  * Processes a set of XML documents via XSLT. This is
  * useful for building views of XML based documentation.
  *
  *
  * @since Ant 1.1
  *
  * @ant.task name="xslt" category="xml"
  */
 
 public class XSLTProcess extends MatchingTask implements XSLTLogger {
     /** destination directory */
     private File destDir = null;
 
     /** where to find the source XML file, default is the project's basedir */
     private File baseDir = null;
 
     /** XSL stylesheet as a filename */
     private String xslFile = null;
 
     /** XSL stylesheet as a {@link org.apache.tools.ant.types.Resource} */
     private Resource xslResource = null;
 
     /** extension of the files produced by XSL processing */
     private String targetExtension = ".html";
 
     /** name for XSL parameter containing the filename */
     private String fileNameParameter = null;
 
     /** name for XSL parameter containing the file directory */
     private String fileDirParameter = null;
 
     /** additional parameters to be passed to the stylesheets */
     private List<Param> params = new ArrayList<Param>();
 
     /** Input XML document to be used */
     private File inFile = null;
 
     /** Output file */
     private File outFile = null;
 
     /** The name of the XSL processor to use */
     private String processor;
 
     /** Classpath to use when trying to load the XSL processor */
     private Path classpath = null;
 
     /** The Liaison implementation to use to communicate with the XSL
      *  processor */
     private XSLTLiaison liaison;
 
     /** Flag which indicates if the stylesheet has been loaded into
      *  the processor */
     private boolean stylesheetLoaded = false;
 
     /** force output of target files even if they already exist */
     private boolean force = false;
 
     /** XSL output properties to be used */
     private Vector outputProperties = new Vector();
 
     /** for resolving entities such as dtds */
     private XMLCatalog xmlCatalog = new XMLCatalog();
 
     /** Utilities used for file operations */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * Whether to style all files in the included directories as well.
      *
      * @since Ant 1.5
      */
     private boolean performDirectoryScan = true;
 
     /**
      * factory element for TraX processors only
      * @since Ant 1.6
      */
     private Factory factory = null;
 
     /**
      * whether to reuse Transformer if transforming multiple files.
      * @since 1.5.2
      */
     private boolean reuseLoadedStylesheet = true;
 
     /**
      * AntClassLoader for the nested &lt;classpath&gt; - if set.
      *
      * <p>We keep this here in order to reset the context classloader
      * in execute.  We can't use liaison.getClass().getClassLoader()
      * since the actual liaison class may have been loaded by a loader
      * higher up (system classloader, for example).</p>
      *
      * @since Ant 1.6.2
      */
     private AntClassLoader loader = null;
 
     /**
      * Mapper to use when a set of files gets processed.
      *
      * @since Ant 1.6.2
      */
     private Mapper mapperElement = null;
 
     /**
      * Additional resource collections to process.
      *
      * @since Ant 1.7
      */
     private Union resources = new Union();
 
     /**
      * Whether to use the implicit fileset.
      *
      * @since Ant 1.7
      */
     private boolean useImplicitFileset = true;
 
     /**
      * The default processor is trax
      * @since Ant 1.7
      */
     public static final String PROCESSOR_TRAX = "trax";
 
     /**
      * whether to suppress warnings.
      *
      * @since Ant 1.8.0
      */
     private boolean suppressWarnings = false;
 
     /**
      * whether to fail the build if an error occurs during transformation.
      *
      * @since Ant 1.8.0
      */
     private boolean failOnTransformationError = true;
 
     /**
      * whether to fail the build if an error occurs.
      *
      * @since Ant 1.8.0
      */
     private boolean failOnError = true;
 
     /**
      * Whether the build should fail if the nested resource collection
      * is empty.
      *
      * @since Ant 1.8.0
      */
     private boolean failOnNoResources = true;
     
     /**
      * For evaluating template params
      *
      * @since Ant 1.9.3
      */
     private XPathFactory xpathFactory;
     /**
      * For evaluating template params
      *
      * @since Ant 1.9.3
      */
     private XPath xpath;
 
     /**
      * System properties to set during transformation.
      *
      * @since Ant 1.8.0
      */
     private CommandlineJava.SysProperties sysProperties =
         new CommandlineJava.SysProperties();
 
     /**
      * Trace configuration for Xalan2.
      *
      * @since Ant 1.8.0
      */
     private TraceConfiguration traceConfiguration;
 
     /**
      * Creates a new XSLTProcess Task.
      */
     public XSLTProcess() {
     } //-- XSLTProcess
 
     /**
      * Whether to style all files in the included directories as well;
      * optional, default is true.
      *
      * @param b true if files in included directories are processed.
      * @since Ant 1.5
      */
     public void setScanIncludedDirectories(boolean b) {
         performDirectoryScan = b;
     }
 
     /**
      * Controls whether the stylesheet is reloaded for every transform.
      *
      * <p>Setting this to true may get around a bug in certain
      * Xalan-J versions, default is false.</p>
      * @param b a <code>boolean</code> value
      * @since Ant 1.5.2
      */
     public void setReloadStylesheet(boolean b) {
         reuseLoadedStylesheet = !b;
     }
 
     /**
      * Defines the mapper to map source to destination files.
      * @param mapper the mapper to use
      * @exception BuildException if more than one mapper is defined
      * @since Ant 1.6.2
      */
     public void addMapper(Mapper mapper) {
         if (mapperElement != null) {
             handleError("Cannot define more than one mapper");
         } else {
             mapperElement = mapper;
         }
     }
 
     /**
      * Adds a collection of resources to style in addition to the
      * given file or the implicit fileset.
      *
      * @param rc the collection of resources to style
      * @since Ant 1.7
      */
     public void add(ResourceCollection rc) {
         resources.add(rc);
     }
 
     /**
      * Add a nested &lt;style&gt; element.
      * @param rc the configured Resources object represented as &lt;style&gt;.
      * @since Ant 1.7
      */
     public void addConfiguredStyle(Resources rc) {
         if (rc.size() != 1) {
             handleError("The style element must be specified with exactly one"
                         + " nested resource.");
         } else {
             setXslResource(rc.iterator().next());
         }
     }
 
     /**
      * API method to set the XSL Resource.
      * @param xslResource Resource to set as the stylesheet.
      * @since Ant 1.7
      */
     public void setXslResource(Resource xslResource) {
         this.xslResource = xslResource;
     }
 
     /**
      * Adds a nested filenamemapper.
      * @param fileNameMapper the mapper to add
      * @exception BuildException if more than one mapper is defined
      * @since Ant 1.7.0
      */
     public void add(FileNameMapper fileNameMapper) throws BuildException {
        Mapper mapper = new Mapper(getProject());
        mapper.add(fileNameMapper);
        addMapper(mapper);
     }
 
     /**
      * Executes the task.
      *
      * @exception BuildException if there is an execution problem.
      * @todo validate that if either in or out is defined, then both are
      */
     @Override
     public void execute() throws BuildException {
         if ("style".equals(getTaskType())) {
             log("Warning: the task name <style> is deprecated. Use <xslt> instead.",
                     Project.MSG_WARN);
         }
         File savedBaseDir = baseDir;
 
         DirectoryScanner scanner;
         String[]         list;
         String[]         dirs;
 
         String baseMessage =
             "specify the stylesheet either as a filename in style attribute "
             + "or as a nested resource";
 
         if (xslResource == null && xslFile == null) {
             handleError(baseMessage);
             return;
         }
         if (xslResource != null && xslFile != null) {
             handleError(baseMessage + " but not as both");
             return;
         }
         if (inFile != null && !inFile.exists()) {
             handleError("input file " + inFile + " does not exist");
             return;
         }
         try {
             setupLoader();
 
             if (sysProperties.size() > 0) {
                 sysProperties.setSystem();
             }
 
             Resource styleResource;
             if (baseDir == null) {
                 baseDir = getProject().getBaseDir();
             }
             liaison = getLiaison();
 
             // check if liaison wants to log errors using us as logger
             if (liaison instanceof XSLTLoggerAware) {
                 ((XSLTLoggerAware) liaison).setLogger(this);
             }
             log("Using " + liaison.getClass().toString(), Project.MSG_VERBOSE);
 
             if (xslFile != null) {
                 // If we enter here, it means that the stylesheet is supplied
                 // via style attribute
                 File stylesheet = getProject().resolveFile(xslFile);
                 if (!stylesheet.exists()) {
                     File alternative = FILE_UTILS.resolveFile(baseDir, xslFile);
                     /*
                      * shouldn't throw out deprecation warnings before we know,
                      * the wrong version has been used.
                      */
                     if (alternative.exists()) {
                         log("DEPRECATED - the 'style' attribute should be "
                             + "relative to the project's");
                         log("             basedir, not the tasks's basedir.");
                         stylesheet = alternative;
                     }
                 }
                 FileResource fr = new FileResource();
                 fr.setProject(getProject());
                 fr.setFile(stylesheet);
                 styleResource = fr;
             } else {
                 styleResource = xslResource;
             }
 
             if (!styleResource.isExists()) {
                 handleError("stylesheet " + styleResource + " doesn't exist.");
                 return;
             }
 
             // if we have an in file and out then process them
             if (inFile != null && outFile != null) {
                 process(inFile, outFile, styleResource);
                 return;
             }
             /*
              * if we get here, in and out have not been specified, we are
              * in batch processing mode.
              */
 
             //-- make sure destination directory exists...
             checkDest();
 
             if (useImplicitFileset) {
                 scanner = getDirectoryScanner(baseDir);
                 log("Transforming into " + destDir, Project.MSG_INFO);
 
                 // Process all the files marked for styling
                 list = scanner.getIncludedFiles();
                 for (int i = 0; i < list.length; ++i) {
                     process(baseDir, list[i], destDir, styleResource);
                 }
                 if (performDirectoryScan) {
                     // Process all the directories marked for styling
                     dirs = scanner.getIncludedDirectories();
                     for (int j = 0; j < dirs.length; ++j) {
                         list = new File(baseDir, dirs[j]).list();
                         for (int i = 0; i < list.length; ++i) {
                             process(baseDir, dirs[j] + File.separator + list[i], destDir,
                                     styleResource);
                         }
                     }
                 }
             } else { // only resource collections, there better be some
                 if (resources.size() == 0) {
                     if (failOnNoResources) {
                         handleError("no resources specified");
                     }
                     return;
                 }
             }
             processResources(styleResource);
         } finally {
             if (loader != null) {
                 loader.resetThreadContextLoader();
                 loader.cleanup();
                 loader = null;
             }
             if (sysProperties.size() > 0) {
                 sysProperties.restoreSystem();
             }
             liaison = null;
             stylesheetLoaded = false;
             baseDir = savedBaseDir;
         }
     }
 
     /**
      * Set whether to check dependencies, or always generate;
      * optional, default is false.
      *
      * @param force true if always generate.
      */
     public void setForce(boolean force) {
         this.force = force;
     }
 
     /**
      * Set the base directory;
      * optional, default is the project's basedir.
      *
      * @param dir the base directory
      **/
     public void setBasedir(File dir) {
         baseDir = dir;
     }
 
     /**
      * Set the destination directory into which the XSL result
      * files should be copied to;
      * required, unless <tt>in</tt> and <tt>out</tt> are
      * specified.
      * @param dir the name of the destination directory
      **/
     public void setDestdir(File dir) {
         destDir = dir;
     }
 
     /**
      * Set the desired file extension to be used for the target;
      * optional, default is html.
      * @param name the extension to use
      **/
     public void setExtension(String name) {
         targetExtension = name;
     }
 
     /**
      * Name of the stylesheet to use - given either relative
      * to the project's basedir or as an absolute path; required.
      *
      * @param xslFile the stylesheet to use
      */
     public void setStyle(String xslFile) {
         this.xslFile = xslFile;
     }
 
     /**
      * Set the optional classpath to the XSL processor
      *
      * @param classpath the classpath to use when loading the XSL processor
      */
     public void setClasspath(Path classpath) {
         createClasspath().append(classpath);
     }
 
     /**
      * Set the optional classpath to the XSL processor
      *
      * @return a path instance to be configured by the Ant core.
      */
     public Path createClasspath() {
         if (classpath == null) {
             classpath = new Path(getProject());
         }
         return classpath.createPath();
     }
 
     /**
      * Set the reference to an optional classpath to the XSL processor
      *
      * @param r the id of the Ant path instance to act as the classpath
      *          for loading the XSL processor
      */
     public void setClasspathRef(Reference r) {
         createClasspath().setRefid(r);
     }
 
     /**
      * Set the name of the XSL processor to use; optional, default trax.
      *
      * @param processor the name of the XSL processor
      */
     public void setProcessor(String processor) {
         this.processor = processor;
     }
 
     /**
      * Whether to use the implicit fileset.
      *
      * <p>Set this to false if you want explicit control with nested
      * resource collections.</p>
      * @param useimplicitfileset set to true if you want to use implicit fileset
      * @since Ant 1.7
      */
     public void setUseImplicitFileset(boolean useimplicitfileset) {
         useImplicitFileset = useimplicitfileset;
     }
 
     /**
      * Add the catalog to our internal catalog
      *
      * @param xmlCatalog the XMLCatalog instance to use to look up DTDs
      */
     public void addConfiguredXMLCatalog(XMLCatalog xmlCatalog) {
         this.xmlCatalog.addConfiguredXMLCatalog(xmlCatalog);
     }
 
     /**
      * Pass the filename of the current processed file as a xsl parameter
      * to the transformation. This value sets the name of that xsl parameter.
      *
      * @param fileNameParameter name of the xsl parameter retrieving the
      *                          current file name
      */
     public void setFileNameParameter(String fileNameParameter) {
         this.fileNameParameter = fileNameParameter;
     }
 
     /**
      * Pass the directory name of the current processed file as a xsl parameter
      * to the transformation. This value sets the name of that xsl parameter.
      *
      * @param fileDirParameter name of the xsl parameter retrieving the
      *                         current file directory
      */
     public void setFileDirParameter(String fileDirParameter) {
         this.fileDirParameter = fileDirParameter;
     }
 
     /**
      * Whether to suppress warning messages of the processor.
      *
      * @since Ant 1.8.0
      */
     public void setSuppressWarnings(boolean b) {
         suppressWarnings = b;
     }
 
     /**
      * Whether to suppress warning messages of the processor.
      *
      * @since Ant 1.8.0
      */
     public boolean getSuppressWarnings() {
         return suppressWarnings;
     }    
 
     /**
      * Whether transformation errors should make the build fail.
      *
      * @since Ant 1.8.0
      */
     public void setFailOnTransformationError(boolean b) {
         failOnTransformationError = b;
     }
 
     /**
      * Whether any errors should make the build fail.
      *
      * @since Ant 1.8.0
      */
     public void setFailOnError(boolean b) {
         failOnError = b;
     }
 
     /**
      * Whether the build should fail if the nested resource collection is empty.
      *
      * @since Ant 1.8.0
      */
     public void setFailOnNoResources(boolean b) {
         failOnNoResources = b;
     }
 
     /**
      * A system property to set during transformation.
      *
      * @since Ant 1.8.0
      */
     public void addSysproperty(Environment.Variable sysp) {
         sysProperties.addVariable(sysp);
     }
 
     /**
      * A set of system properties to set during transformation.
      *
      * @since Ant 1.8.0
      */
     public void addSyspropertyset(PropertySet sysp) {
         sysProperties.addSyspropertyset(sysp);
     }
 
     /**
      * Enables Xalan2 traces and uses the given configuration.
      *
      * <p>Note that this element doesn't have any effect with a
      * processor other than trax or if the Transformer is not Xalan2's
      * transformer implementation.</p>
      *
      * @since Ant 1.8.0
      */
     public TraceConfiguration createTrace() {
         if (traceConfiguration != null) {
             throw new BuildException("can't have more than one trace"
                                      + " configuration");
         }
         traceConfiguration = new TraceConfiguration();
         return traceConfiguration;
     }
 
     /**
      * Configuration for Xalan2 traces.
      *
      * @since Ant 1.8.0
      */
     public TraceConfiguration getTraceConfiguration() {
         return traceConfiguration;
     }
 
     /**
      * Load processor here instead of in setProcessor - this will be
      * called from within execute, so we have access to the latest
      * classpath.
      *
      * @param proc the name of the processor to load.
      * @exception Exception if the processor cannot be loaded.
      */
     private void resolveProcessor(String proc) throws Exception {
         if (proc.equals(PROCESSOR_TRAX)) {
             liaison = new org.apache.tools.ant.taskdefs.optional.TraXLiaison();
         } else {
             //anything else is a classname
             Class clazz = loadClass(proc);
             liaison = (XSLTLiaison) clazz.newInstance();
         }
     }
 
     /**
      * Load named class either via the system classloader or a given
      * custom classloader.
      *
      * As a side effect, the loader is set as the thread context classloader
      * @param classname the name of the class to load.
      * @return the requested class.
      * @exception Exception if the class could not be loaded.
      */
     private Class loadClass(String classname) throws Exception {
         setupLoader();
         if (loader == null) {
             return Class.forName(classname);
         }
         return Class.forName(classname, true, loader);
     }
 
     /**
      * If a custom classpath has been defined but no loader created
      * yet, create the classloader and set it as the context
      * classloader.
      */
     private void setupLoader() {
         if (classpath != null && loader == null) {
             loader = getProject().createClassLoader(classpath);
             loader.setThreadContextLoader();
         }
     }
 
     /**
      * Specifies the output name for the styled result from the
      * <tt>in</tt> attribute; required if <tt>in</tt> is set
      *
      * @param outFile the output File instance.
      */
     public void setOut(File outFile) {
         this.outFile = outFile;
     }
 
     /**
      * specifies a single XML document to be styled. Should be used
      * with the <tt>out</tt> attribute; ; required if <tt>out</tt> is set
      *
      * @param inFile the input file
      */
     public void setIn(File inFile) {
         this.inFile = inFile;
     }
 
     /**
      * Throws a BuildException if the destination directory hasn't
      * been specified.
      * @since Ant 1.7
      */
     private void checkDest() {
         if (destDir == null) {
             handleError("destdir attributes must be set!");
         }
     }
 
     /**
      * Styles all existing resources.
      *
      * @param stylesheet style sheet to use
      * @since Ant 1.7
      */
     private void processResources(Resource stylesheet) {
         for (Resource r : resources) {
             if (!r.isExists()) {
                 continue;
             }
             File base = baseDir;
             String name = r.getName();
             FileProvider fp = r.as(FileProvider.class);
             if (fp != null) {
                 FileResource f = ResourceUtils.asFileResource(fp);
                 base = f.getBaseDir();
                 if (base == null) {
                     name = f.getFile().getAbsolutePath();
                 }
             }
             process(base, name, destDir, stylesheet);
         }
     }
 
     /**
      * Processes the given input XML file and stores the result
      * in the given resultFile.
      *
      * @param baseDir the base directory for resolving files.
      * @param xmlFile the input file
      * @param destDir the destination directory
      * @param stylesheet the stylesheet to use.
      * @exception BuildException if the processing fails.
      */
     private void process(File baseDir, String xmlFile, File destDir, Resource stylesheet)
             throws BuildException {
 
         File   outF = null;
         File   inF = null;
 
         try {
             long styleSheetLastModified = stylesheet.getLastModified();
             inF = new File(baseDir, xmlFile);
 
             if (inF.isDirectory()) {
                 log("Skipping " + inF + " it is a directory.", Project.MSG_VERBOSE);
                 return;
             }
             FileNameMapper mapper = null;
             if (mapperElement != null) {
                 mapper = mapperElement.getImplementation();
             } else {
                 mapper = new StyleMapper();
             }
 
             String[] outFileName = mapper.mapFileName(xmlFile);
             if (outFileName == null || outFileName.length == 0) {
                 log("Skipping " + inFile + " it cannot get mapped to output.", Project.MSG_VERBOSE);
                 return;
             } else if (outFileName == null || outFileName.length > 1) {
                 log("Skipping " + inFile + " its mapping is ambiguos.", Project.MSG_VERBOSE);
                 return;
             }
             outF = new File(destDir, outFileName[0]);
 
             if (force || inF.lastModified() > outF.lastModified()
                     || styleSheetLastModified > outF.lastModified()) {
                 ensureDirectoryFor(outF);
                 log("Processing " + inF + " to " + outF);
                 configureLiaison(stylesheet);
                 setLiaisonDynamicFileParameters(liaison, inF);
                 liaison.transform(inF, outF);
             }
         } catch (Exception ex) {
             // If failed to process document, must delete target document,
             // or it will not attempt to process it the second time
             log("Failed to process " + inFile, Project.MSG_INFO);
             if (outF != null) {
                 outF.delete();
             }
             handleTransformationError(ex);
         }
 
     } //-- processXML
 
     /**
      * Process the input file to the output file with the given stylesheet.
      *
      * @param inFile the input file to process.
      * @param outFile the destination file.
      * @param stylesheet the stylesheet to use.
      * @exception BuildException if the processing fails.
      */
     private void process(File inFile, File outFile, Resource stylesheet) throws BuildException {
         try {
             long styleSheetLastModified = stylesheet.getLastModified();
             log("In file " + inFile + " time: " + inFile.lastModified(), Project.MSG_DEBUG);
             log("Out file " + outFile + " time: " + outFile.lastModified(), Project.MSG_DEBUG);
             log("Style file " + xslFile + " time: " + styleSheetLastModified, Project.MSG_DEBUG);
             if (force || inFile.lastModified() >= outFile.lastModified()
                     || styleSheetLastModified >= outFile.lastModified()) {
                 ensureDirectoryFor(outFile);
                 log("Processing " + inFile + " to " + outFile, Project.MSG_INFO);
                 configureLiaison(stylesheet);
                 setLiaisonDynamicFileParameters(liaison, inFile);
                 liaison.transform(inFile, outFile);
             } else {
                 log("Skipping input file " + inFile + " because it is older than output file "
                         + outFile + " and so is the stylesheet " + stylesheet, Project.MSG_DEBUG);
             }
         } catch (Exception ex) {
             log("Failed to process " + inFile, Project.MSG_INFO);
             if (outFile != null) {
                 outFile.delete();
             }
             handleTransformationError(ex);
         }
     }
 
     /**
      * Ensure the directory exists for a given file
      *
      * @param targetFile the file for which the directories are required.
      * @exception BuildException if the directories cannot be created.
      */
     private void ensureDirectoryFor(File targetFile) throws BuildException {
         File directory = targetFile.getParentFile();
         if (!directory.exists()) {
-            if (!directory.mkdirs()) {
+            if (!(directory.mkdirs() || directory.isDirectory())) {
                 handleError("Unable to create directory: "
                             + directory.getAbsolutePath());
             }
         }
     }
 
     /**
      * Get the factory instance configured for this processor
      *
      * @return the factory instance in use
      */
     public Factory getFactory() {
         return factory;
     }
 
     /**
      * Get the XML catalog containing entity definitions
      *
      * @return the XML catalog for the task.
      */
     public XMLCatalog getXMLCatalog() {
         xmlCatalog.setProject(getProject());
         return xmlCatalog;
     }
 
     /**
      * Get an enumeration on the outputproperties.
      * @return the outputproperties
      */
     public Enumeration getOutputProperties() {
         return outputProperties.elements();
     }
 
     /**
      * Get the Liaison implementation to use in processing.
      *
      * @return an instance of the XSLTLiaison interface.
      */
     protected XSLTLiaison getLiaison() {
         // if processor wasn't specified, use TraX.
         if (liaison == null) {
             if (processor != null) {
                 try {
                     resolveProcessor(processor);
                 } catch (Exception e) {
                     handleError(e);
                 }
             } else {
                 try {
                     resolveProcessor(PROCESSOR_TRAX);
                 } catch (Throwable e1) {
                     e1.printStackTrace();
                     handleError(e1);
                 }
             }
         }
         return liaison;
     }
 
     /**
      * Create an instance of an XSL parameter for configuration by Ant.
      *
      * @return an instance of the Param class to be configured.
      */
     public Param createParam() {
         Param p = new Param();
         params.add(p);
         return p;
     }
 
     /**
      * The Param inner class used to store XSL parameters
      */
     public static class Param {
         /** The parameter name */
         private String name = null;
 
         /** The parameter's value */
         private String expression = null;
         
         /**
          * Type of the expression.
          * @see ParamType
          */
         private String type;
 
         private Object ifCond;
         private Object unlessCond;
         private Project project;
 
         /**
          * Set the current project
          *
          * @param project the current project
          */
         public void setProject(Project project) {
             this.project = project;
         }
 
         /**
          * Set the parameter name.
          *
          * @param name the name of the parameter.
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * The parameter value -
          * can be a primitive type value or an XPath expression.
          * @param expression the parameter's value/expression.
          * @see #setType(java.lang.String) 
          */
         public void setExpression(String expression) {
             this.expression = expression;
         }
 
         /**
          * @see ParamType
          * @since Ant 1.9.3
          */
         public void setType(String type) {
             this.type = type;
         }
         
         /**
          * Get the parameter name
          *
          * @return the parameter name
          * @exception BuildException if the name is not set.
          */
         public String getName() throws BuildException {
             if (name == null) {
                 throw new BuildException("Name attribute is missing.");
             }
             return name;
         }
 
         /**
          * Get the parameter's value
          *
          * @return the parameter value
          * @exception BuildException if the value is not set.
          * @see #getType()
          */
         public String getExpression() throws BuildException {
             if (expression == null) {
                 throw new BuildException("Expression attribute is missing.");
             }
             return expression;
         }
 
         /**
          * @see ParamType
          * @since Ant 1.9.3
          */
         public String getType() {
             return type;
         }
 
         /**
          * Set whether this param should be used.  It will be used if
          * the expression evaluates to true or the name of a property
          * which has been set, otherwise it won't.
          * @param ifCond evaluated expression
          * @since Ant 1.8.0
          */
         public void setIf(Object ifCond) {
             this.ifCond = ifCond;
         }
 
         /**
          * Set whether this param should be used.  It will be used if
          * the expression evaluates to true or the name of a property
          * which has been set, otherwise it won't.
          * @param ifProperty evaluated expression
          */
         public void setIf(String ifProperty) {
             setIf((Object) ifProperty);
         }
 
         /**
          * Set whether this param should NOT be used. It will not be
          * used if the expression evaluates to true or the name of a
          * property which has been set, otherwise it will be used.
          * @param unlessCond evaluated expression
          * @since Ant 1.8.0
          */
         public void setUnless(Object unlessCond) {
             this.unlessCond = unlessCond;
         }
 
         /**
          * Set whether this param should NOT be used. It will not be
          * used if the expression evaluates to true or the name of a
          * property which has been set, otherwise it will be used.
          * @param unlessProperty evaluated expression
          */
         public void setUnless(String unlessProperty) {
             setUnless((Object) unlessProperty);
         }
 
         /**
          * Ensures that the param passes the conditions placed
          * on it with <code>if</code> and <code>unless</code> properties.
          * @return true if the task passes the "if" and "unless" parameters
          */
         public boolean shouldUse() {
             PropertyHelper ph = PropertyHelper.getPropertyHelper(project);
             return ph.testIfCondition(ifCond)
                 && ph.testUnlessCondition(unlessCond);
         }
     } // Param
     
     /**
      * Enum for types of the parameter expression.
      *
      * <p>The expression can be:</p>
      * <ul>
      * <li>primitive type that will be parsed from the string value e.g.
      * {@linkplain Integer#parseInt(java.lang.String)}</li>
      * <li>XPath expression that will be evaluated (outside of the transformed
      * document - on empty one) and casted to given type. Inside XPath
      * expressions the Ant variables (properties) can be used (as XPath
      * variables - e.g. $variable123). n.b. placeholders in form of
      * ${variable123} will be substituted with their values before evaluating the
      * XPath expression (so it can be used for dynamic XPath function names and
      * other hacks).</li>
      * </ul>
      * <p>The parameter will be then passed to the XSLT template.</p>
      *
      * <p>Default type (if omited) is primitive String. So if the expression is e.g
      * "true" with no type, in XSLT it will be only a text string, not true
      * boolean.</p>
      * 
      * @see Param#setType(java.lang.String)
      * @see Param#setExpression(java.lang.String)
      * @since Ant 1.9.3
      */
     public enum ParamType {
 
         STRING,
         BOOLEAN,
         INT,
         LONG,
         DOUBLE,
         XPATH_STRING,
         XPATH_BOOLEAN,
         XPATH_NUMBER,
         XPATH_NODE,
         XPATH_NODESET;
         
         public static final Map<ParamType, QName> XPATH_TYPES;
 
         static {
             Map<ParamType, QName> m = new EnumMap<ParamType, QName>(ParamType.class);
             m.put(XPATH_STRING, XPathConstants.STRING);
             m.put(XPATH_BOOLEAN, XPathConstants.BOOLEAN);
             m.put(XPATH_NUMBER, XPathConstants.NUMBER);
             m.put(XPATH_NODE, XPathConstants.NODE);
             m.put(XPATH_NODESET, XPathConstants.NODESET);
             XPATH_TYPES = Collections.unmodifiableMap(m);
         }
     }
 
     /**
      * Create an instance of an output property to be configured.
      * @return the newly created output property.
      * @since Ant 1.5
      */
     public OutputProperty createOutputProperty() {
         OutputProperty p = new OutputProperty();
         outputProperties.addElement(p);
         return p;
     }
 
     /**
      * Specify how the result tree should be output as specified
      * in the <a href="http://www.w3.org/TR/xslt#output">
      * specification</a>.
      * @since Ant 1.5
      */
     public static class OutputProperty {
         /** output property name */
         private String name;
 
         /** output property value */
         private String value;
 
         /**
          * @return the output property name.
          */
         public String getName() {
             return name;
         }
 
         /**
          * set the name for this property
          * @param name A non-null String that specifies an
          * output property name, which may be namespace qualified.
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * @return the output property value.
          */
         public String getValue() {
             return value;
         }
 
         /**
          * set the value for this property
          * @param value The non-null string value of the output property.
          */
         public void setValue(String value) {
             this.value = value;
         }
     }
 
     /**
      * Initialize internal instance of XMLCatalog.
      * Initialize XPath for parameter evaluation.
      * @throws BuildException on error
      */
     @Override
     public void init() throws BuildException {
         super.init();
         xmlCatalog.setProject(getProject());
         
         xpathFactory = XPathFactory.newInstance();
         xpath = xpathFactory.newXPath();
         xpath.setXPathVariableResolver(new XPathVariableResolver() {
             public Object resolveVariable(QName variableName) {
                 return getProject().getProperty(variableName.toString());
             }
         });
     }
 
     /**
      * Loads the stylesheet and set xsl:param parameters.
      *
      * @param stylesheet the file from which to load the stylesheet.
      * @exception BuildException if the stylesheet cannot be loaded.
      * @deprecated since Ant 1.7
      */
     protected void configureLiaison(File stylesheet) throws BuildException {
         FileResource fr = new FileResource();
         fr.setProject(getProject());
         fr.setFile(stylesheet);
         configureLiaison(fr);
     }
 
     /**
      * Loads the stylesheet and set xsl:param parameters.
      *
      * @param stylesheet the resource from which to load the stylesheet.
      * @exception BuildException if the stylesheet cannot be loaded.
      * @since Ant 1.7
      */
     protected void configureLiaison(Resource stylesheet) throws BuildException {
         if (stylesheetLoaded && reuseLoadedStylesheet) {
             return;
         }
         stylesheetLoaded = true;
 
         try {
             log("Loading stylesheet " + stylesheet, Project.MSG_INFO);
             // We call liaison.configure() and then liaison.setStylesheet()
             // so that the internal variables of liaison can be set up
             if (liaison instanceof XSLTLiaison2) {
                 ((XSLTLiaison2) liaison).configure(this);
             }
             if (liaison instanceof XSLTLiaison3) {
                 // If we are here we can set the stylesheet as a
                 // resource
                 ((XSLTLiaison3) liaison).setStylesheet(stylesheet);
             } else {
                 // If we are here we cannot set the stylesheet as
                 // a resource, but we can set it as a file. So,
                 // we make an attempt to get it as a file
                 FileProvider fp =
                     stylesheet.as(FileProvider.class);
                 if (fp != null) {
                     liaison.setStylesheet(fp.getFile());
                 } else {
                     handleError(liaison.getClass().toString()
                                 + " accepts the stylesheet only as a file");
                     return;
                 }
             }
             for (Param p : params) {
                 if (p.shouldUse()) {
                     Object evaluatedParam = evaluateParam(p);
                     if (liaison instanceof XSLTLiaison4) {
                         ((XSLTLiaison4)liaison).addParam(p.getName(), evaluatedParam);
                     } else {
                         if (evaluatedParam == null || evaluatedParam instanceof String) {
                             liaison.addParam(p.getName(), (String)evaluatedParam);
                         } else {
                             log("XSLTLiaison '" + liaison.getClass().getName()
                                     + "' supports only String parameters. Converting parameter '" + p.getName()
                                     + "' to its String value '" + evaluatedParam, Project.MSG_WARN);
                             liaison.addParam(p.getName(), String.valueOf(evaluatedParam));
                         }
                     }
                 }
             }
         } catch (Exception ex) {
             log("Failed to transform using stylesheet " + stylesheet, Project.MSG_INFO);
             handleTransformationError(ex);
         }
     }
     
     /**
      * Evaluates parameter expression according to its type.
      *
      * @param param parameter from Ant build file
      * @return value to be passed to XSLT as parameter
      * @throws IllegalArgumentException if param type is unsupported
      * @throws NumberFormatException if expression of numeric type is not
      * desired numeric type
      * @throws XPathExpressionException if XPath expression can not be compiled
      * @since Ant 1.9.3
      */
     private Object evaluateParam(Param param) throws XPathExpressionException {
         String typeName = param.getType();
         String expression = param.getExpression();
 
         ParamType type;
 
         if (typeName == null || "".equals(typeName)) {
             type = ParamType.STRING; // String is default
         } else {
             try {
                 type = ParamType.valueOf(typeName);
             } catch (IllegalArgumentException e) {
                 throw new IllegalArgumentException("Invalid XSLT parameter type: " + typeName, e);
             }
         }
 
         switch (type) {
             case STRING:
                 return expression;
             case BOOLEAN:
                 return Boolean.parseBoolean(expression);
             case DOUBLE:
                 return Double.parseDouble(expression);
             case INT:
                 return Integer.parseInt(expression);
             case LONG:
                 return Long.parseLong(expression);
             default: // XPath expression
                 QName xpathType = ParamType.XPATH_TYPES.get(type);
                 if (xpathType == null) {
                     throw new IllegalArgumentException("Invalid XSLT parameter type: " + typeName);
                 } else {
                     XPathExpression xpe = xpath.compile(expression);
                     // null = evaluate XPath on empty XML document
                     return xpe.evaluate((Object) null, xpathType);
                 }
         }
     }
 
     /**
      * Sets file parameter(s) for directory and filename if the attribute
      * 'filenameparameter' or 'filedirparameter' are set in the task.
      *
      * @param  liaison    to change parameters for
      * @param  inFile     to get the additional file information from
      * @throws Exception  if an exception occurs on filename lookup
      *
      * @since Ant 1.7
      */
     private void setLiaisonDynamicFileParameters(
         XSLTLiaison liaison, File inFile) throws Exception {
         if (fileNameParameter != null) {
             liaison.addParam(fileNameParameter, inFile.getName());
         }
         if (fileDirParameter != null) {
             String fileName = FileUtils.getRelativePath(baseDir, inFile);
             File file = new File(fileName);
             // Give always a slash as file separator, so the stylesheet could be sure about that
             // Use '.' so a dir+"/"+name would not result in an absolute path
             liaison.addParam(fileDirParameter, file.getParent() != null ? file.getParent().replace(
                     '\\', '/') : ".");
         }
     }
 
     /**
      * Create the factory element to configure a trax liaison.
      * @return the newly created factory element.
      * @throws BuildException if the element is created more than one time.
      */
     public Factory createFactory() throws BuildException {
         if (factory != null) {
             handleError("'factory' element must be unique");
         } else {
             factory = new Factory();
         }
         return factory;
     }
 
     /**
      * Throws an exception with the given message if failOnError is
      * true, otherwise logs the message using the WARN level.
      *
      * @since Ant 1.8.0
      */
     protected void handleError(String msg) {
         if (failOnError) {
             throw new BuildException(msg, getLocation());
         }
         log(msg, Project.MSG_WARN);
     }
 
 
     /**
      * Throws an exception with the given nested exception if
      * failOnError is true, otherwise logs the message using the WARN
      * level.
      *
      * @since Ant 1.8.0
      */
     protected void handleError(Throwable ex) {
         if (failOnError) {
             throw new BuildException(ex);
         } else {
             log("Caught an exception: " + ex, Project.MSG_WARN);
         }
     }
 
     /**
      * Throws an exception with the given nested exception if
      * failOnError and failOnTransformationError are true, otherwise
      * logs the message using the WARN level.
      *
      * @since Ant 1.8.0
      */
     protected void handleTransformationError(Exception ex) {
         if (failOnError && failOnTransformationError) {
             throw new BuildException(ex);
         } else {
             log("Caught an error during transformation: " + ex,
                 Project.MSG_WARN);
         }
     }
 
     /**
      * The factory element to configure a transformer factory
      * @since Ant 1.6
      */
     public static class Factory {
 
         /** the factory class name to use for TraXLiaison */
         private String name;
 
         /**
          * the list of factory attributes to use for TraXLiaison
          */
         private Vector attributes = new Vector();
 
         /**
          * @return the name of the factory.
          */
         public String getName() {
             return name;
         }
 
         /**
          * Set the name of the factory
          * @param name the name of the factory.
          */
         public void setName(String name) {
             this.name = name;
         }
 
         /**
          * Create an instance of a factory attribute.
          * @param attr the newly created factory attribute
          */
         public void addAttribute(Attribute attr) {
             attributes.addElement(attr);
         }
 
         /**
          * return the attribute elements.
          * @return the enumeration of attributes
          */
         public Enumeration getAttributes() {
             return attributes.elements();
         }
 
         /**
          * A JAXP factory attribute. This is mostly processor specific, for
          * example for Xalan 2.3+, the following attributes could be set:
          * <ul>
          *  <li>http://xml.apache.org/xalan/features/optimize (true|false) </li>
          *  <li>http://xml.apache.org/xalan/features/incremental (true|false) </li>
          * </ul>
          */
         public static class Attribute implements DynamicConfigurator {
 
             /** attribute name, mostly processor specific */
             private String name;
 
             /** attribute value, often a boolean string */
             private Object value;
 
             /**
              * @return the attribute name.
              */
             public String getName() {
                 return name;
             }
 
             /**
              * @return the output property value.
              */
             public Object getValue() {
                 return value;
             }
 
             /**
              * Not used.
              * @param name not used
              * @return null
              * @throws BuildException never
              */
             public Object createDynamicElement(String name) throws BuildException {
                 return null;
             }
 
             /**
              * Set an attribute.
              * Only "name" and "value" are supported as names.
              * @param name the name of the attribute
              * @param value the value of the attribute
              * @throws BuildException on error
              */
             public void setDynamicAttribute(String name, String value) throws BuildException {
                 // only 'name' and 'value' exist.
                 if ("name".equalsIgnoreCase(name)) {
                     this.name = value;
                 } else if ("value".equalsIgnoreCase(name)) {
                     // a value must be of a given type
                     // say boolean|integer|string that are mostly used.
                     if ("true".equalsIgnoreCase(value)) {
                         this.value = Boolean.TRUE;
                     } else if ("false".equalsIgnoreCase(value)) {
                         this.value = Boolean.FALSE;
                     } else {
                         try {
                             this.value = new Integer(value);
                         } catch (NumberFormatException e) {
                             this.value = value;
                         }
                     }
                 } else {
                     throw new BuildException("Unsupported attribute: " + name);
                 }
             }
         } // -- class Attribute
     } // -- class Factory
 
     /**
      * Mapper implementation of the "traditional" way &lt;xslt&gt;
      * mapped filenames.
      *
      * <p>If the file has an extension, chop it off.  Append whatever
      * the user has specified as extension or ".html".</p>
      *
      * @since Ant 1.6.2
      */
     private class StyleMapper implements FileNameMapper {
         public void setFrom(String from) {
         }
         public void setTo(String to) {
         }
         public String[] mapFileName(String xmlFile) {
             int dotPos = xmlFile.lastIndexOf('.');
             if (dotPos > 0) {
                 xmlFile = xmlFile.substring(0, dotPos);
             }
             return new String[] {xmlFile + targetExtension};
         }
     }
 
     /**
      * Configuration for Xalan2 traces.
      *
      * @since Ant 1.8.0
      */
     public final class TraceConfiguration {
         private boolean elements, extension, generation, selection, templates;
 
         /**
          * Set to true if the listener is to print events that occur
          * as each node is 'executed' in the stylesheet.
          */
         public void setElements(boolean b) {
             elements = b;
         }
 
         /**
          * True if the listener is to print events that occur as each
          * node is 'executed' in the stylesheet.
          */
         public boolean getElements() {
             return elements;
         }
 
         /**
          * Set to true if the listener is to print information after
          * each extension event.
          */
         public void setExtension(boolean b) {
             extension = b;
         }
 
         /**
          * True if the listener is to print information after each
          * extension event.
          */
         public boolean getExtension() {
             return extension;
         }
 
         /**
          * Set to true if the listener is to print information after
          * each result-tree generation event.
          */
         public void setGeneration(boolean b) {
             generation = b;
         }
 
         /**
          * True if the listener is to print information after each
          * result-tree generation event.
          */
         public boolean getGeneration() {
             return generation;
         }
 
         /**
          * Set to true if the listener is to print information after
          * each selection event.
          */
         public void setSelection(boolean b) {
             selection = b;
         }
 
         /**
          * True if the listener is to print information after each
          * selection event.
          */
         public boolean getSelection() {
             return selection;
         }
 
         /**
          * Set to true if the listener is to print an event whenever a
          * template is invoked.
          */
         public void setTemplates(boolean b) {
             templates = b;
         }
 
         /**
          * True if the listener is to print an event whenever a
          * template is invoked.
          */
         public boolean getTemplates() {
             return templates;
         }
 
         /**
          * The stream to write traces to.
          */
         public java.io.OutputStream getOutputStream() {
             return new LogOutputStream(XSLTProcess.this);
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Zip.java b/src/main/org/apache/tools/ant/taskdefs/Zip.java
index 4bd32c7e9..3d05349a4 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Zip.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Zip.java
@@ -1,1648 +1,1649 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs;
 
 import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.Map;
 import java.util.Stack;
 import java.util.Vector;
 import java.util.zip.CRC32;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.FileScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.ArchiveFileSet;
 import org.apache.tools.ant.types.EnumeratedAttribute;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.PatternSet;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.ZipFileSet;
 import org.apache.tools.ant.types.ZipScanner;
 import org.apache.tools.ant.types.resources.ArchiveResource;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.types.resources.ZipResource;
 import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.GlobPatternMapper;
 import org.apache.tools.ant.util.IdentityMapper;
 import org.apache.tools.ant.util.MergingMapper;
 import org.apache.tools.ant.util.ResourceUtils;
 import org.apache.tools.zip.UnixStat;
 import org.apache.tools.zip.Zip64Mode;
 import org.apache.tools.zip.ZipEntry;
 import org.apache.tools.zip.ZipExtraField;
 import org.apache.tools.zip.ZipFile;
 import org.apache.tools.zip.ZipOutputStream;
 import org.apache.tools.zip.ZipOutputStream.UnicodeExtraFieldPolicy;
 
 /**
  * Create a Zip file.
  *
  * @since Ant 1.1
  *
  * @ant.task category="packaging"
  */
 public class Zip extends MatchingTask {
     private static final int BUFFER_SIZE = 8 * 1024;
     private static final int ROUNDUP_MILLIS = 1999; // 2 seconds - 1
     // CheckStyle:VisibilityModifier OFF - bc
 
     protected File zipFile;
     // use to scan own archive
     private ZipScanner zs;
     private File baseDir;
     protected Hashtable<String, String> entries = new Hashtable<String, String>();
     private Vector<FileSet> groupfilesets = new Vector<FileSet>();
     private Vector<ZipFileSet> filesetsFromGroupfilesets = new Vector<ZipFileSet>();
     protected String duplicate = "add";
     private boolean doCompress = true;
     private boolean doUpdate = false;
     // shadow of the above if the value is altered in execute
     private boolean savedDoUpdate = false;
     private boolean doFilesonly = false;
     protected String archiveType = "zip";
 
     // For directories:
     private static final long EMPTY_CRC = new CRC32 ().getValue ();
     protected String emptyBehavior = "skip";
     private Vector<ResourceCollection> resources = new Vector<ResourceCollection>();
     protected Hashtable<String, String> addedDirs = new Hashtable<String, String>();
     private Vector<String> addedFiles = new Vector<String>();
 
     private static final ResourceSelector MISSING_SELECTOR =
         new ResourceSelector() {
             public boolean isSelected(Resource target) {
                 return !target.isExists();
             }
         };
 
     private static final ResourceUtils.ResourceSelectorProvider
         MISSING_DIR_PROVIDER = new ResourceUtils.ResourceSelectorProvider() {
                 public ResourceSelector
                     getTargetSelectorForSource(Resource sr) {
                     return MISSING_SELECTOR;
                 }
             };
 
     /**
      * If this flag is true, execute() will run most operations twice,
      * the first time with {@link #skipWriting skipWriting} set to
      * true and the second time with setting it to false.
      *
      * <p>The only situation in Ant's current code base where this is
      * ever going to be true is if the jar task has been configured
      * with a filesetmanifest other than "skip".</p>
      */
     protected boolean doubleFilePass = false;
     /**
      * whether the methods should just perform some sort of dry-run.
      *
      * <p>Will only ever be true in the first pass if the task
      * performs two passes because {@link #doubleFilePass
      * doubleFilePass} is true.</p>
      */
     protected boolean skipWriting = false;
 
     /**
      * Whether this is the first time the archive building methods are invoked.
      *
      * @return true if either {@link #doubleFilePass doubleFilePass}
      * is false or {@link #skipWriting skipWriting} is true.
      *
      * @since Ant 1.8.0
      */
     protected final boolean isFirstPass() {
         return !doubleFilePass || skipWriting;
     }
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     // CheckStyle:VisibilityModifier ON
 
     // This boolean is set if the task detects that the
     // target is outofdate and has written to the target file.
     private boolean updatedFile = false;
 
     /**
      * true when we are adding new files into the Zip file, as opposed
      * to adding back the unchanged files
      */
     private boolean addingNewFiles = false;
 
     /**
      * Encoding to use for filenames, defaults to the platform's
      * default encoding.
      */
     private String encoding;
 
     /**
      * Whether the original compression of entries coming from a ZIP
      * archive should be kept (for example when updating an archive).
      *
      * @since Ant 1.6
      */
     private boolean keepCompression = false;
 
     /**
      * Whether the file modification times will be rounded up to the
      * next even number of seconds.
      *
      * @since Ant 1.6.2
      */
     private boolean roundUp = true;
 
     /**
      * Comment for the archive.
      * @since Ant 1.6.3
      */
     private String comment = "";
 
     private int level = ZipOutputStream.DEFAULT_COMPRESSION;
 
     /**
      * Assume 0 Unix mode is intentional.
      * @since Ant 1.8.0
      */
     private boolean preserve0Permissions = false;
 
     /**
      * Whether to set the language encoding flag when creating the archive.
      *
      * @since Ant 1.8.0
      */
     private boolean useLanguageEncodingFlag = true;
 
     /**
      * Whether to add unicode extra fields.
      *
      * @since Ant 1.8.0
      */
     private UnicodeExtraField createUnicodeExtraFields =
         UnicodeExtraField.NEVER;
 
     /**
      * Whether to fall back to UTF-8 if a name cannot be encoded using
      * the specified encoding.
      *
      * @since Ant 1.8.0
      */
     private boolean fallBackToUTF8 = false;
 
     /**
      * Whether to enable Zip64 extensions.
      *
      * @since Ant 1.9.1
      */
     private Zip64ModeAttribute zip64Mode = Zip64ModeAttribute.AS_NEEDED;
 
     /**
      * This is the name/location of where to
      * create the .zip file.
      * @param zipFile the path of the zipFile
      * @deprecated since 1.5.x.
      *             Use setDestFile(File) instead.
      * @ant.attribute ignore="true"
      */
     public void setZipfile(File zipFile) {
         setDestFile(zipFile);
     }
 
     /**
      * This is the name/location of where to
      * create the file.
      * @param file the path of the zipFile
      * @since Ant 1.5
      * @deprecated since 1.5.x.
      *             Use setDestFile(File) instead.
      * @ant.attribute ignore="true"
      */
     public void setFile(File file) {
         setDestFile(file);
     }
 
 
     /**
      * The file to create; required.
      * @since Ant 1.5
      * @param destFile The new destination File
      */
     public void setDestFile(File destFile) {
        this.zipFile = destFile;
     }
 
     /**
      * The file to create.
      * @return the destination file
      * @since Ant 1.5.2
      */
     public File getDestFile() {
         return zipFile;
     }
 
 
     /**
      * Directory from which to archive files; optional.
      * @param baseDir the base directory
      */
     public void setBasedir(File baseDir) {
         this.baseDir = baseDir;
     }
 
     /**
      * Whether we want to compress the files or only store them;
      * optional, default=true;
      * @param c if true, compress the files
      */
     public void setCompress(boolean c) {
         doCompress = c;
     }
 
     /**
      * Whether we want to compress the files or only store them;
      * @return true if the files are to be compressed
      * @since Ant 1.5.2
      */
     public boolean isCompress() {
         return doCompress;
     }
 
     /**
      * If true, emulate Sun's jar utility by not adding parent directories;
      * optional, defaults to false.
      * @param f if true, emulate sun's jar by not adding parent directories
      */
     public void setFilesonly(boolean f) {
         doFilesonly = f;
     }
 
     /**
      * If true, updates an existing file, otherwise overwrite
      * any existing one; optional defaults to false.
      * @param c if true, updates an existing zip file
      */
     public void setUpdate(boolean c) {
         doUpdate = c;
         savedDoUpdate = c;
     }
 
     /**
      * Are we updating an existing archive?
      * @return true if updating an existing archive
      */
     public boolean isInUpdateMode() {
         return doUpdate;
     }
 
     /**
      * Adds a set of files.
      * @param set the fileset to add
      */
     public void addFileset(FileSet set) {
         add(set);
     }
 
     /**
      * Adds a set of files that can be
      * read from an archive and be given a prefix/fullpath.
      * @param set the zipfileset to add
      */
     public void addZipfileset(ZipFileSet set) {
         add(set);
     }
 
     /**
      * Add a collection of resources to be archived.
      * @param a the resources to archive
      * @since Ant 1.7
      */
     public void add(ResourceCollection a) {
         resources.add(a);
     }
 
     /**
      * Adds a group of zip files.
      * @param set the group (a fileset) to add
      */
     public void addZipGroupFileset(FileSet set) {
         groupfilesets.addElement(set);
     }
 
     /**
      * Sets behavior for when a duplicate file is about to be added -
      * one of <code>add</code>, <code>preserve</code> or <code>fail</code>.
      * Possible values are: <code>add</code> (keep both
      * of the files); <code>preserve</code> (keep the first version
      * of the file found); <code>fail</code> halt a problem
      * Default for zip tasks is <code>add</code>
      * @param df a <code>Duplicate</code> enumerated value
      */
     public void setDuplicate(Duplicate df) {
         duplicate = df.getValue();
     }
 
     /**
      * Possible behaviors when there are no matching files for the task:
      * "fail", "skip", or "create".
      */
     public static class WhenEmpty extends EnumeratedAttribute {
         /**
          * The string values for the enumerated value
          * @return the values
          */
         public String[] getValues() {
             return new String[] {"fail", "skip", "create"};
         }
     }
 
     /**
      * Sets behavior of the task when no files match.
      * Possible values are: <code>fail</code> (throw an exception
      * and halt the build); <code>skip</code> (do not create
      * any archive, but issue a warning); <code>create</code>
      * (make an archive with no entries).
      * Default for zip tasks is <code>skip</code>;
      * for jar tasks, <code>create</code>.
      * @param we a <code>WhenEmpty</code> enumerated value
      */
     public void setWhenempty(WhenEmpty we) {
         emptyBehavior = we.getValue();
     }
 
     /**
      * Encoding to use for filenames, defaults to the platform's
      * default encoding.
      *
      * <p>For a list of possible values see <a
      * href="http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.</p>
      * @param encoding the encoding name
      */
     public void setEncoding(String encoding) {
         this.encoding = encoding;
     }
 
     /**
      * Encoding to use for filenames.
      * @return the name of the encoding to use
      * @since Ant 1.5.2
      */
     public String getEncoding() {
         return encoding;
     }
 
     /**
      * Whether the original compression of entries coming from a ZIP
      * archive should be kept (for example when updating an archive).
      * Default is false.
      * @param keep if true, keep the original compression
      * @since Ant 1.6
      */
     public void setKeepCompression(boolean keep) {
         keepCompression = keep;
     }
 
     /**
      * Comment to use for archive.
      *
      * @param comment The content of the comment.
      * @since Ant 1.6.3
      */
     public void setComment(String comment) {
         this.comment = comment;
     }
 
     /**
      * Comment of the archive
      *
      * @return Comment of the archive.
      * @since Ant 1.6.3
      */
     public String getComment() {
         return comment;
     }
 
     /**
      * Set the compression level to use.  Default is
      * ZipOutputStream.DEFAULT_COMPRESSION.
      * @param level compression level.
      * @since Ant 1.7
      */
     public void setLevel(int level) {
         this.level = level;
     }
 
     /**
      * Get the compression level.
      * @return compression level.
      * @since Ant 1.7
      */
     public int getLevel() {
         return level;
     }
 
     /**
      * Whether the file modification times will be rounded up to the
      * next even number of seconds.
      *
      * <p>Zip archives store file modification times with a
      * granularity of two seconds, so the times will either be rounded
      * up or down.  If you round down, the archive will always seem
      * out-of-date when you rerun the task, so the default is to round
      * up.  Rounding up may lead to a different type of problems like
      * JSPs inside a web archive that seem to be slightly more recent
      * than precompiled pages, rendering precompilation useless.</p>
      * @param r a <code>boolean</code> value
      * @since Ant 1.6.2
      */
     public void setRoundUp(boolean r) {
         roundUp = r;
     }
 
     /**
      * Assume 0 Unix mode is intentional.
      * @since Ant 1.8.0
      */
     public void setPreserve0Permissions(boolean b) {
         preserve0Permissions = b;
     }
 
     /**
      * Assume 0 Unix mode is intentional.
      * @since Ant 1.8.0
      */
     public boolean getPreserve0Permissions() {
         return preserve0Permissions;
     }
 
     /**
      * Whether to set the language encoding flag.
      * @since Ant 1.8.0
      */
     public void setUseLanguageEncodingFlag(boolean b) {
         useLanguageEncodingFlag = b;
     }
 
     /**
      * Whether the language encoding flag will be used.
      * @since Ant 1.8.0
      */
     public boolean getUseLanguageEnodingFlag() {
         return useLanguageEncodingFlag;
     }
 
     /**
      * Whether Unicode extra fields will be created.
      * @since Ant 1.8.0
      */
     public void setCreateUnicodeExtraFields(UnicodeExtraField b) {
         createUnicodeExtraFields = b;
     }
 
     /**
      * Whether Unicode extra fields will be created.
      * @since Ant 1.8.0
      */
     public UnicodeExtraField getCreateUnicodeExtraFields() {
         return createUnicodeExtraFields;
     }
 
     /**
      * Whether to fall back to UTF-8 if a name cannot be encoded using
      * the specified encoding.
      *
      * <p>Defaults to false.</p>
      *
      * @since Ant 1.8.0
      */
     public void setFallBackToUTF8(boolean b) {
         fallBackToUTF8 = b;
     }
 
     /**
      * Whether to fall back to UTF-8 if a name cannot be encoded using
      * the specified encoding.
      *
      * @since Ant 1.8.0
      */
     public boolean getFallBackToUTF8() {
         return fallBackToUTF8;
     }
 
     /**
      * Whether Zip64 extensions should be used.
      * @since Ant 1.9.1
      */
     public void setZip64Mode(Zip64ModeAttribute b) {
         zip64Mode = b;
     }
 
     /**
      * Whether Zip64 extensions will be used.
      * @since Ant 1.9.1
      */
     public Zip64ModeAttribute getZip64Mode() {
         return zip64Mode;
     }
 
     /**
      * validate and build
      * @throws BuildException on error
      */
     public void execute() throws BuildException {
 
         if (doubleFilePass) {
             skipWriting = true;
             executeMain();
             skipWriting = false;
             executeMain();
         } else {
             executeMain();
         }
     }
 
     /**
      * Get the value of the updatedFile attribute.
      * This should only be called after executeMain has been
      * called.
      * @return true if executeMain has written to the zip file.
      */
     protected boolean hasUpdatedFile() {
         return updatedFile;
     }
 
     /**
      * Build the zip file.
      * This is called twice if doubleFilePass is true.
      * @throws BuildException on error
      */
     public void executeMain() throws BuildException {
 
         checkAttributesAndElements();
 
         // Renamed version of original file, if it exists
         File renamedFile = null;
         addingNewFiles = true;
 
         processDoUpdate();
         processGroupFilesets();
 
         // collect filesets to pass them to getResourcesToAdd
         Vector<ResourceCollection> vfss = new Vector<ResourceCollection>();
         if (baseDir != null) {
             FileSet fs = (FileSet) getImplicitFileSet().clone();
             fs.setDir(baseDir);
             vfss.addElement(fs);
         }
         final int size = resources.size();
         for (int i = 0; i < size; i++) {
             ResourceCollection rc = (ResourceCollection) resources.elementAt(i);
             vfss.addElement(rc);
         }
 
         ResourceCollection[] fss = new ResourceCollection[vfss.size()];
         vfss.copyInto(fss);
         boolean success = false;
         try {
             // can also handle empty archives
             ArchiveState state = getResourcesToAdd(fss, zipFile, false);
 
             // quick exit if the target is up to date
             if (!state.isOutOfDate()) {
                 return;
             }
 
             File parent = zipFile.getParentFile();
-            if (parent != null && !parent.isDirectory() && !parent.mkdirs()) {
+            if (parent != null && !parent.isDirectory()
+                && !(parent.mkdirs() || parent.isDirectory())) {
                 throw new BuildException("Failed to create missing parent"
                                          + " directory for " + zipFile);
             }
 
             updatedFile = true;
             if (!zipFile.exists() && state.isWithoutAnyResources()) {
                 createEmptyZip(zipFile);
                 return;
             }
             Resource[][] addThem = state.getResourcesToAdd();
 
             if (doUpdate) {
                 renamedFile = renameFile();
             }
 
             String action = doUpdate ? "Updating " : "Building ";
 
             if (!skipWriting) {
                 log(action + archiveType + ": " + zipFile.getAbsolutePath());
             }
 
             ZipOutputStream zOut = null;
             try {
                 if (!skipWriting) {
                     zOut = new ZipOutputStream(zipFile);
 
                     zOut.setEncoding(encoding);
                     zOut.setUseLanguageEncodingFlag(useLanguageEncodingFlag);
                     zOut.setCreateUnicodeExtraFields(createUnicodeExtraFields.
                                                      getPolicy());
                     zOut.setFallbackToUTF8(fallBackToUTF8);
                     zOut.setMethod(doCompress
                         ? ZipOutputStream.DEFLATED : ZipOutputStream.STORED);
                     zOut.setLevel(level);
                     zOut.setUseZip64(zip64Mode.getMode());
                 }
                 initZipOutputStream(zOut);
 
                 // Add the explicit resource collections to the archive.
                 for (int i = 0; i < fss.length; i++) {
                     if (addThem[i].length != 0) {
                         addResources(fss[i], addThem[i], zOut);
                     }
                 }
 
                 if (doUpdate) {
                     addingNewFiles = false;
                     ZipFileSet oldFiles = new ZipFileSet();
                     oldFiles.setProject(getProject());
                     oldFiles.setSrc(renamedFile);
                     oldFiles.setDefaultexcludes(false);
 
                     final int addSize = addedFiles.size();
                     for (int i = 0; i < addSize; i++) {
                         PatternSet.NameEntry ne = oldFiles.createExclude();
                         ne.setName((String) addedFiles.elementAt(i));
                     }
                     DirectoryScanner ds =
                         oldFiles.getDirectoryScanner(getProject());
                     ((ZipScanner) ds).setEncoding(encoding);
 
                     String[] f = ds.getIncludedFiles();
                     Resource[] r = new Resource[f.length];
                     for (int i = 0; i < f.length; i++) {
                         r[i] = ds.getResource(f[i]);
                     }
 
                     if (!doFilesonly) {
                         String[] d = ds.getIncludedDirectories();
                         Resource[] dr = new Resource[d.length];
                         for (int i = 0; i < d.length; i++) {
                             dr[i] = ds.getResource(d[i]);
                         }
                         Resource[] tmp = r;
                         r = new Resource[tmp.length + dr.length];
                         System.arraycopy(dr, 0, r, 0, dr.length);
                         System.arraycopy(tmp, 0, r, dr.length, tmp.length);
                     }
                     addResources(oldFiles, r, zOut);
                 }
                 if (zOut != null) {
                     zOut.setComment(comment);
                 }
                 finalizeZipOutputStream(zOut);
 
                 // If we've been successful on an update, delete the
                 // temporary file
                 if (doUpdate) {
                     if (!renamedFile.delete()) {
                         log ("Warning: unable to delete temporary file "
                             + renamedFile.getName(), Project.MSG_WARN);
                     }
                 }
                 success = true;
             } finally {
                 // Close the output stream.
                 closeZout(zOut, success);
             }
         } catch (IOException ioe) {
             String msg = "Problem creating " + archiveType + ": "
                 + ioe.getMessage();
 
             // delete a bogus ZIP file (but only if it's not the original one)
             if ((!doUpdate || renamedFile != null) && !zipFile.delete()) {
                 msg += " (and the archive is probably corrupt but I could not "
                     + "delete it)";
             }
 
             if (doUpdate && renamedFile != null) {
                 try {
                     FILE_UTILS.rename(renamedFile, zipFile);
                 } catch (IOException e) {
                     msg += " (and I couldn't rename the temporary file "
                             + renamedFile.getName() + " back)";
                 }
             }
 
             throw new BuildException(msg, ioe, getLocation());
         } finally {
             cleanUp();
         }
     }
 
     /** rename the zip file. */
     private File renameFile() {
         File renamedFile = FILE_UTILS.createTempFile(
             "zip", ".tmp", zipFile.getParentFile(), true, false);
         try {
             FILE_UTILS.rename(zipFile, renamedFile);
         } catch (SecurityException e) {
             throw new BuildException(
                 "Not allowed to rename old file ("
                 + zipFile.getAbsolutePath()
                 + ") to temporary file");
         } catch (IOException e) {
             throw new BuildException(
                 "Unable to rename old file ("
                 + zipFile.getAbsolutePath()
                 + ") to temporary file");
         }
         return renamedFile;
     }
 
     /** Close zout */
     private void closeZout(ZipOutputStream zOut, boolean success)
         throws IOException {
         if (zOut == null) {
             return;
         }
         try {
             zOut.close();
         } catch (IOException ex) {
             // If we're in this finally clause because of an
             // exception, we don't really care if there's an
             // exception when closing the stream. E.g. if it
             // throws "ZIP file must have at least one entry",
             // because an exception happened before we added
             // any files, then we must swallow this
             // exception. Otherwise, the error that's reported
             // will be the close() error, which is not the
             // real cause of the problem.
             if (success) {
                 throw ex;
             }
         }
     }
 
     /** Check the attributes and elements */
     private void checkAttributesAndElements() {
         if (baseDir == null && resources.size() == 0
             && groupfilesets.size() == 0 && "zip".equals(archiveType)) {
             throw new BuildException("basedir attribute must be set, "
                                      + "or at least one "
                                      + "resource collection must be given!");
         }
 
         if (zipFile == null) {
             throw new BuildException("You must specify the "
                                      + archiveType + " file to create!");
         }
 
         if (zipFile.exists() && !zipFile.isFile()) {
             throw new BuildException(zipFile + " is not a file.");
         }
 
         if (zipFile.exists() && !zipFile.canWrite()) {
             throw new BuildException(zipFile + " is read-only.");
         }
     }
 
     /** Process doupdate */
     private void processDoUpdate() {
         // Whether or not an actual update is required -
         // we don't need to update if the original file doesn't exist
         if (doUpdate && !zipFile.exists()) {
             doUpdate = false;
             logWhenWriting("ignoring update attribute as " + archiveType
                            + " doesn't exist.", Project.MSG_DEBUG);
         }
     }
 
     /** Process groupfilesets */
     private void processGroupFilesets() {
         // Add the files found in groupfileset to fileset
         final int size = groupfilesets.size();
         for (int i = 0; i < size; i++) {
 
             logWhenWriting("Processing groupfileset ", Project.MSG_VERBOSE);
             FileSet fs = (FileSet) groupfilesets.elementAt(i);
             FileScanner scanner = fs.getDirectoryScanner(getProject());
             String[] files = scanner.getIncludedFiles();
             File basedir = scanner.getBasedir();
             for (int j = 0; j < files.length; j++) {
 
                 logWhenWriting("Adding file " + files[j] + " to fileset",
                                Project.MSG_VERBOSE);
                 ZipFileSet zf = new ZipFileSet();
                 zf.setProject(getProject());
                 zf.setSrc(new File(basedir, files[j]));
                 add(zf);
                 filesetsFromGroupfilesets.addElement(zf);
             }
         }
     }
 
     /**
      * Indicates if the task is adding new files into the archive as opposed to
      * copying back unchanged files from the backup copy
      * @return true if adding new files
      */
     protected final boolean isAddingNewFiles() {
         return addingNewFiles;
     }
 
     /**
      * Add the given resources.
      *
      * @param fileset may give additional information like fullpath or
      * permissions.
      * @param resources the resources to add
      * @param zOut the stream to write to
      * @throws IOException on error
      *
      * @since Ant 1.5.2
      */
     protected final void addResources(FileSet fileset, Resource[] resources,
                                       ZipOutputStream zOut)
         throws IOException {
 
         String prefix = "";
         String fullpath = "";
         int dirMode = ArchiveFileSet.DEFAULT_DIR_MODE;
         int fileMode = ArchiveFileSet.DEFAULT_FILE_MODE;
 
         ArchiveFileSet zfs = null;
         if (fileset instanceof ArchiveFileSet) {
             zfs = (ArchiveFileSet) fileset;
             prefix = zfs.getPrefix(getProject());
             fullpath = zfs.getFullpath(getProject());
             dirMode = zfs.getDirMode(getProject());
             fileMode = zfs.getFileMode(getProject());
         }
 
         if (prefix.length() > 0 && fullpath.length() > 0) {
             throw new BuildException("Both prefix and fullpath attributes must"
                                      + " not be set on the same fileset.");
         }
 
         if (resources.length != 1 && fullpath.length() > 0) {
             throw new BuildException("fullpath attribute may only be specified"
                                      + " for filesets that specify a single"
                                      + " file.");
         }
 
         if (prefix.length() > 0) {
             if (!prefix.endsWith("/") && !prefix.endsWith("\\")) {
                 prefix += "/";
             }
             addParentDirs(null, prefix, zOut, "", dirMode);
         }
 
         ZipFile zf = null;
         try {
             boolean dealingWithFiles = false;
             File base = null;
 
             if (zfs == null || zfs.getSrc(getProject()) == null) {
                 dealingWithFiles = true;
                 base = fileset.getDir(getProject());
             } else if (zfs instanceof ZipFileSet) {
                 zf = new ZipFile(zfs.getSrc(getProject()), encoding);
             }
 
             for (int i = 0; i < resources.length; i++) {
                 String name = null;
                 if (fullpath.length() > 0) {
                     name = fullpath;
                 } else {
                     name = resources[i].getName();
                 }
                 name = name.replace(File.separatorChar, '/');
 
                 if ("".equals(name)) {
                     continue;
                 }
 
                 if (resources[i].isDirectory()) {
                     if (doFilesonly) {
                         continue;
                     }
                     int thisDirMode = zfs != null && zfs.hasDirModeBeenSet()
                         ? dirMode : getUnixMode(resources[i], zf, dirMode);
                     addDirectoryResource(resources[i], name, prefix,
                                          base, zOut,
                                          dirMode, thisDirMode);
 
                 } else { // !isDirectory
 
                     addParentDirs(base, name, zOut, prefix, dirMode);
 
                     if (dealingWithFiles) {
                         File f = FILE_UTILS.resolveFile(base,
                                                         resources[i].getName());
                         zipFile(f, zOut, prefix + name, fileMode);
                     } else {
                         int thisFileMode =
                             zfs != null && zfs.hasFileModeBeenSet()
                             ? fileMode : getUnixMode(resources[i], zf,
                                                      fileMode);
                         addResource(resources[i], name, prefix,
                                     zOut, thisFileMode, zf,
                                     zfs == null
                                     ? null : zfs.getSrc(getProject()));
                     }
                 }
             }
         } finally {
             if (zf != null) {
                 zf.close();
             }
         }
     }
 
     /**
      * Add a directory entry to the archive using a specified
      * Unix-mode and the default mode for its parent directories (if
      * necessary).
      */
     private void addDirectoryResource(Resource r, String name, String prefix,
                                       File base, ZipOutputStream zOut,
                                       int defaultDirMode, int thisDirMode)
         throws IOException {
 
         if (!name.endsWith("/")) {
             name = name + "/";
         }
 
         int nextToLastSlash = name.lastIndexOf("/", name.length() - 2);
         if (nextToLastSlash != -1) {
             addParentDirs(base, name.substring(0, nextToLastSlash + 1),
                           zOut, prefix, defaultDirMode);
         }
         zipDir(r, zOut, prefix + name, thisDirMode,
                r instanceof ZipResource
                ? ((ZipResource) r).getExtraFields() : null);
     }
 
     /**
      * Determine a Resource's Unix mode or return the given default
      * value if not available.
      */
     private int getUnixMode(Resource r, ZipFile zf, int defaultMode)
         throws IOException {
 
         int unixMode = defaultMode;
         if (zf != null) {
             ZipEntry ze = zf.getEntry(r.getName());
             unixMode = ze.getUnixMode();
             if ((unixMode == 0 || unixMode == UnixStat.DIR_FLAG)
                 && !preserve0Permissions) {
                 unixMode = defaultMode;
             }
         } else if (r instanceof ArchiveResource) {
             unixMode = ((ArchiveResource) r).getMode();
         }
         return unixMode;
     }
 
     /**
      * Add a file entry.
      */
     private void addResource(Resource r, String name, String prefix,
                              ZipOutputStream zOut, int mode,
                              ZipFile zf, File fromArchive)
         throws IOException {
 
         if (zf != null) {
             ZipEntry ze = zf.getEntry(r.getName());
 
             if (ze != null) {
                 boolean oldCompress = doCompress;
                 if (keepCompression) {
                     doCompress = (ze.getMethod() == ZipEntry.DEFLATED);
                 }
                 InputStream is = null;
                 try {
                     is = zf.getInputStream(ze);
                     zipFile(is, zOut, prefix + name, ze.getTime(),
                             fromArchive, mode, ze.getExtraFields(true));
                 } finally {
                     doCompress = oldCompress;
                     FileUtils.close(is);
                 }
             }
         } else {
             InputStream is = null;
             try {
                 is = r.getInputStream();
                 zipFile(is, zOut, prefix + name, r.getLastModified(),
                         fromArchive, mode, r instanceof ZipResource
                         ? ((ZipResource) r).getExtraFields() : null);
             } finally {
                 FileUtils.close(is);
             }
         }
     }
 
     /**
      * Add the given resources.
      *
      * @param rc may give additional information like fullpath or
      * permissions.
      * @param resources the resources to add
      * @param zOut the stream to write to
      * @throws IOException on error
      *
      * @since Ant 1.7
      */
     protected final void addResources(ResourceCollection rc,
                                       Resource[] resources,
                                       ZipOutputStream zOut)
         throws IOException {
         if (rc instanceof FileSet) {
             addResources((FileSet) rc, resources, zOut);
             return;
         }
         for (int i = 0; i < resources.length; i++) {
             final Resource resource = resources[i];
             String name = resource.getName();
             if (name == null) {
                 continue;
             }
             name = name.replace(File.separatorChar, '/');
 
             if ("".equals(name)) {
                 continue;
             }
             if (resource.isDirectory() && doFilesonly) {
                 continue;
             }
             File base = null;
             FileProvider fp = resource.as(FileProvider.class);
             if (fp != null) {
                 base = ResourceUtils.asFileResource(fp).getBaseDir();
             }
 
             if (resource.isDirectory()) {
                 addDirectoryResource(resource, name, "", base, zOut,
                                      ArchiveFileSet.DEFAULT_DIR_MODE,
                                      ArchiveFileSet.DEFAULT_DIR_MODE);
 
             } else {
                 addParentDirs(base, name, zOut, "",
                               ArchiveFileSet.DEFAULT_DIR_MODE);
 
                 if (fp != null) {
                     File f = (fp).getFile();
                     zipFile(f, zOut, name, ArchiveFileSet.DEFAULT_FILE_MODE);
                 } else {
                     addResource(resource, name, "", zOut,
                                 ArchiveFileSet.DEFAULT_FILE_MODE,
                                 null, null);
                 }
             }
         }
     }
 
     /**
      * method for subclasses to override
      * @param zOut the zip output stream
      * @throws IOException on output error
      * @throws BuildException on other errors
      */
     protected void initZipOutputStream(ZipOutputStream zOut)
         throws IOException, BuildException {
     }
 
     /**
      * method for subclasses to override
      * @param zOut the zip output stream
      * @throws IOException on output error
      * @throws BuildException on other errors
      */
     protected void finalizeZipOutputStream(ZipOutputStream zOut)
         throws IOException, BuildException {
     }
 
     /**
      * Create an empty zip file
      * @param zipFile the zip file
      * @return true for historic reasons
      * @throws BuildException on error
      */
     protected boolean createEmptyZip(File zipFile) throws BuildException {
         // In this case using java.util.zip will not work
         // because it does not permit a zero-entry archive.
         // Must create it manually.
         if (!skipWriting) {
             log("Note: creating empty " + archiveType + " archive " + zipFile,
                 Project.MSG_INFO);
         }
         OutputStream os = null;
         try {
             os = new FileOutputStream(zipFile);
             // CheckStyle:MagicNumber OFF
             // Cf. PKZIP specification.
             byte[] empty = new byte[22];
             empty[0] = 80; // P
             empty[1] = 75; // K
             empty[2] = 5;
             empty[3] = 6;
             // remainder zeros
             // CheckStyle:MagicNumber ON
             os.write(empty);
         } catch (IOException ioe) {
             throw new BuildException("Could not create empty ZIP archive "
                                      + "(" + ioe.getMessage() + ")", ioe,
                                      getLocation());
         } finally {
             FileUtils.close(os);
         }
         return true;
     }
 
     /**
      * @since Ant 1.5.2
      */
     private synchronized ZipScanner getZipScanner() {
         if (zs == null) {
             zs = new ZipScanner();
             zs.setEncoding(encoding);
             zs.setSrc(zipFile);
         }
         return zs;
     }
 
     /**
      * Collect the resources that are newer than the corresponding
      * entries (or missing) in the original archive.
      *
      * <p>If we are going to recreate the archive instead of updating
      * it, all resources should be considered as new, if a single one
      * is.  Because of this, subclasses overriding this method must
      * call <code>super.getResourcesToAdd</code> and indicate with the
      * third arg if they already know that the archive is
      * out-of-date.</p>
      *
      * <p>This method first delegates to getNonFileSetResourcesToAdd
      * and then invokes the FileSet-arg version.  All this to keep
      * backwards compatibility for subclasses that don't know how to
      * deal with non-FileSet ResourceCollections.</p>
      *
      * @param rcs The resource collections to grab resources from
      * @param zipFile intended archive file (may or may not exist)
      * @param needsUpdate whether we already know that the archive is
      * out-of-date.  Subclasses overriding this method are supposed to
      * set this value correctly in their call to
      * <code>super.getResourcesToAdd</code>.
      * @return an array of resources to add for each fileset passed in as well
      *         as a flag that indicates whether the archive is uptodate.
      *
      * @exception BuildException if it likes
      * @since Ant 1.7
      */
     protected ArchiveState getResourcesToAdd(ResourceCollection[] rcs,
                                              File zipFile,
                                              boolean needsUpdate)
         throws BuildException {
         ArrayList<ResourceCollection> filesets = new ArrayList<ResourceCollection>();
         ArrayList<ResourceCollection> rest = new ArrayList<ResourceCollection>();
         for (int i = 0; i < rcs.length; i++) {
             if (rcs[i] instanceof FileSet) {
                 filesets.add(rcs[i]);
             } else {
                 rest.add(rcs[i]);
             }
         }
         ResourceCollection[] rc =
             rest.toArray(new ResourceCollection[rest.size()]);
         ArchiveState as = getNonFileSetResourcesToAdd(rc, zipFile,
                                                       needsUpdate);
 
         FileSet[] fs = (FileSet[]) filesets.toArray(new FileSet[filesets
                                                                 .size()]);
         ArchiveState as2 = getResourcesToAdd(fs, zipFile, as.isOutOfDate());
         if (!as.isOutOfDate() && as2.isOutOfDate()) {
             /*
              * Bad luck.
              *
              * There are resources in the filesets that make the
              * archive out of date, but not in the non-fileset
              * resources. We need to rescan the non-FileSets to grab
              * all of them now.
              */
             as = getNonFileSetResourcesToAdd(rc, zipFile, true);
         }
 
         Resource[][] toAdd = new Resource[rcs.length][];
         int fsIndex = 0;
         int restIndex = 0;
         for (int i = 0; i < rcs.length; i++) {
             if (rcs[i] instanceof FileSet) {
                 toAdd[i] = as2.getResourcesToAdd()[fsIndex++];
             } else {
                 toAdd[i] = as.getResourcesToAdd()[restIndex++];
             }
         }
         return new ArchiveState(as2.isOutOfDate(), toAdd);
     }
 
     /*
      * This is yet another hacky construct to extend the FileSet[]
      * getResourcesToAdd method so we can pass the information whether
      * non-fileset resources have been available to it without having
      * to move the withEmpty behavior checks (since either would break
      * subclasses in several ways).
      */
     private static final ThreadLocal<Boolean> HAVE_NON_FILE_SET_RESOURCES_TO_ADD = new ThreadLocal<Boolean>() {
             protected Boolean initialValue() {
                 return Boolean.FALSE;
             }
         };
 
     /**
      * Collect the resources that are newer than the corresponding
      * entries (or missing) in the original archive.
      *
      * <p>If we are going to recreate the archive instead of updating
      * it, all resources should be considered as new, if a single one
      * is.  Because of this, subclasses overriding this method must
      * call <code>super.getResourcesToAdd</code> and indicate with the
      * third arg if they already know that the archive is
      * out-of-date.</p>
      *
      * @param filesets The filesets to grab resources from
      * @param zipFile intended archive file (may or may not exist)
      * @param needsUpdate whether we already know that the archive is
      * out-of-date.  Subclasses overriding this method are supposed to
      * set this value correctly in their call to
      * <code>super.getResourcesToAdd</code>.
      * @return an array of resources to add for each fileset passed in as well
      *         as a flag that indicates whether the archive is uptodate.
      *
      * @exception BuildException if it likes
      */
     protected ArchiveState getResourcesToAdd(FileSet[] filesets,
                                              File zipFile,
                                              boolean needsUpdate)
         throws BuildException {
 
         Resource[][] initialResources = grabResources(filesets);
         if (isEmpty(initialResources)) {
             if (Boolean.FALSE.equals(HAVE_NON_FILE_SET_RESOURCES_TO_ADD.get())) {
                 if (needsUpdate && doUpdate) {
                     /*
                      * This is a rather hairy case.
                      *
                      * One of our subclasses knows that we need to
                      * update the archive, but at the same time, there
                      * are no resources known to us that would need to
                      * be added.  Only the subclass seems to know
                      * what's going on.
                      *
                      * This happens if <jar> detects that the manifest
                      * has changed, for example.  The manifest is not
                      * part of any resources because of our support
                      * for inline <manifest>s.
                      *
                      * If we invoke createEmptyZip like Ant 1.5.2 did,
                      * we'll loose all stuff that has been in the
                      * original archive (bugzilla report 17780).
                      */
                     return new ArchiveState(true, initialResources);
                 }
 
                 if (emptyBehavior.equals("skip")) {
                     if (doUpdate) {
                         logWhenWriting(archiveType + " archive " + zipFile
                                        + " not updated because no new files were"
                                        + " included.", Project.MSG_VERBOSE);
                     } else {
                         logWhenWriting("Warning: skipping " + archiveType
                                        + " archive " + zipFile
                                        + " because no files were included.",
                                        Project.MSG_WARN);
                     }
                 } else if (emptyBehavior.equals("fail")) {
                     throw new BuildException("Cannot create " + archiveType
                                              + " archive " + zipFile
                                              + ": no files were included.",
                                              getLocation());
                 } else {
                     // Create.
                     if (!zipFile.exists())  {
                         needsUpdate = true;
                     }
                 }
             }
 
             // either there are non-fileset resources or we
             // (re-)create the archive anyway
             return new ArchiveState(needsUpdate, initialResources);
         }
 
         // initialResources is not empty
 
         if (!zipFile.exists()) {
             return new ArchiveState(true, initialResources);
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         Resource[][] newerResources = new Resource[filesets.length][];
 
         for (int i = 0; i < filesets.length; i++) {
             if (!(fileset instanceof ZipFileSet)
                 || ((ZipFileSet) fileset).getSrc(getProject()) == null) {
                 File base = filesets[i].getDir(getProject());
 
                 for (int j = 0; j < initialResources[i].length; j++) {
                     File resourceAsFile =
                         FILE_UTILS.resolveFile(base,
                                               initialResources[i][j].getName());
                     if (resourceAsFile.equals(zipFile)) {
                         throw new BuildException("A zip file cannot include "
                                                  + "itself", getLocation());
                     }
                 }
             }
         }
 
         for (int i = 0; i < filesets.length; i++) {
             if (initialResources[i].length == 0) {
                 newerResources[i] = new Resource[] {};
                 continue;
             }
 
             FileNameMapper myMapper = new IdentityMapper();
             if (filesets[i] instanceof ZipFileSet) {
                 ZipFileSet zfs = (ZipFileSet) filesets[i];
                 if (zfs.getFullpath(getProject()) != null
                     && !zfs.getFullpath(getProject()).equals("")) {
                     // in this case all files from origin map to
                     // the fullPath attribute of the zipfileset at
                     // destination
                     MergingMapper fm = new MergingMapper();
                     fm.setTo(zfs.getFullpath(getProject()));
                     myMapper = fm;
 
                 } else if (zfs.getPrefix(getProject()) != null
                            && !zfs.getPrefix(getProject()).equals("")) {
                     GlobPatternMapper gm = new GlobPatternMapper();
                     gm.setFrom("*");
                     String prefix = zfs.getPrefix(getProject());
                     if (!prefix.endsWith("/") && !prefix.endsWith("\\")) {
                         prefix += "/";
                     }
                     gm.setTo(prefix + "*");
                     myMapper = gm;
                 }
             }
 
             newerResources[i] = selectOutOfDateResources(initialResources[i],
                                                          myMapper);
             needsUpdate = needsUpdate || (newerResources[i].length > 0);
 
             if (needsUpdate && !doUpdate) {
                 // we will return initialResources anyway, no reason
                 // to scan further.
                 break;
             }
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         return new ArchiveState(needsUpdate, newerResources);
     }
 
     /**
      * Collect the resources that are newer than the corresponding
      * entries (or missing) in the original archive.
      *
      * <p>If we are going to recreate the archive instead of updating
      * it, all resources should be considered as new, if a single one
      * is.  Because of this, subclasses overriding this method must
      * call <code>super.getResourcesToAdd</code> and indicate with the
      * third arg if they already know that the archive is
      * out-of-date.</p>
      *
      * @param rcs The filesets to grab resources from
      * @param zipFile intended archive file (may or may not exist)
      * @param needsUpdate whether we already know that the archive is
      * out-of-date.  Subclasses overriding this method are supposed to
      * set this value correctly in their call to
      * <code>super.getResourcesToAdd</code>.
      * @return an array of resources to add for each fileset passed in as well
      *         as a flag that indicates whether the archive is uptodate.
      *
      * @exception BuildException if it likes
      */
     protected ArchiveState getNonFileSetResourcesToAdd(ResourceCollection[] rcs,
                                                        File zipFile,
                                                        boolean needsUpdate)
         throws BuildException {
         /*
          * Backwards compatibility forces us to repeat the logic of
          * getResourcesToAdd(FileSet[], ...) here once again.
          */
 
         Resource[][] initialResources = grabNonFileSetResources(rcs);
         boolean empty = isEmpty(initialResources);
         HAVE_NON_FILE_SET_RESOURCES_TO_ADD.set(Boolean.valueOf(!empty));
         if (empty) {
             // no emptyBehavior handling since the FileSet version
             // will take care of it.
             return new ArchiveState(needsUpdate, initialResources);
         }
 
         // initialResources is not empty
 
         if (!zipFile.exists()) {
             return new ArchiveState(true, initialResources);
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         Resource[][] newerResources = new Resource[rcs.length][];
 
         for (int i = 0; i < rcs.length; i++) {
             if (initialResources[i].length == 0) {
                 newerResources[i] = new Resource[] {};
                 continue;
             }
 
             for (int j = 0; j < initialResources[i].length; j++) {
                 FileProvider fp =
                     initialResources[i][j].as(FileProvider.class);
                 if (fp != null && zipFile.equals(fp.getFile())) {
                     throw new BuildException("A zip file cannot include "
                                              + "itself", getLocation());
                 }
             }
 
             newerResources[i] = selectOutOfDateResources(initialResources[i],
                                                          new IdentityMapper());
             needsUpdate = needsUpdate || (newerResources[i].length > 0);
 
             if (needsUpdate && !doUpdate) {
                 // we will return initialResources anyway, no reason
                 // to scan further.
                 break;
             }
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         return new ArchiveState(needsUpdate, newerResources);
     }
 
     private Resource[] selectOutOfDateResources(Resource[] initial,
                                                 FileNameMapper mapper) {
         Resource[] rs = selectFileResources(initial);
         Resource[] result =
             ResourceUtils.selectOutOfDateSources(this, rs, mapper,
                                                  getZipScanner());
         if (!doFilesonly) {
             Union u = new Union();
             u.addAll(Arrays.asList(selectDirectoryResources(initial)));
             ResourceCollection rc =
                 ResourceUtils.selectSources(this, u, mapper,
                                             getZipScanner(),
                                             MISSING_DIR_PROVIDER);
             if (rc.size() > 0) {
                 ArrayList<Resource> newer = new ArrayList<Resource>();
                 newer.addAll(Arrays.asList(((Union) rc).listResources()));
                 newer.addAll(Arrays.asList(result));
                 result = newer.toArray(result);
             }
         }
         return result;
     }
 
     /**
      * Fetch all included and not excluded resources from the sets.
      *
      * <p>Included directories will precede included files.</p>
      * @param filesets an array of filesets
      * @return the resources included
      * @since Ant 1.5.2
      */
     protected Resource[][] grabResources(FileSet[] filesets) {
         Resource[][] result = new Resource[filesets.length][];
         for (int i = 0; i < filesets.length; i++) {
             boolean skipEmptyNames = true;
             if (filesets[i] instanceof ZipFileSet) {
                 ZipFileSet zfs = (ZipFileSet) filesets[i];
                 skipEmptyNames = zfs.getPrefix(getProject()).equals("")
                     && zfs.getFullpath(getProject()).equals("");
             }
             DirectoryScanner rs =
                 filesets[i].getDirectoryScanner(getProject());
             if (rs instanceof ZipScanner) {
                 ((ZipScanner) rs).setEncoding(encoding);
             }
             Vector<Resource> resources = new Vector<Resource>();
             if (!doFilesonly) {
                 String[] directories = rs.getIncludedDirectories();
                 for (int j = 0; j < directories.length; j++) {
                     if (!"".equals(directories[j]) || !skipEmptyNames) {
                         resources.addElement(rs.getResource(directories[j]));
                     }
                 }
             }
             String[] files = rs.getIncludedFiles();
             for (int j = 0; j < files.length; j++) {
                 if (!"".equals(files[j]) || !skipEmptyNames) {
                     resources.addElement(rs.getResource(files[j]));
                 }
             }
 
             result[i] = new Resource[resources.size()];
             resources.copyInto(result[i]);
         }
         return result;
     }
 
     /**
      * Fetch all included and not excluded resources from the collections.
      *
      * <p>Included directories will precede included files.</p>
      * @param rcs an array of resource collections
      * @return the resources included
      * @since Ant 1.7
      */
     protected Resource[][] grabNonFileSetResources(ResourceCollection[] rcs) {
         Resource[][] result = new Resource[rcs.length][];
         for (int i = 0; i < rcs.length; i++) {
             ArrayList<Resource> dirs = new ArrayList<Resource>();
             ArrayList<Resource> files = new ArrayList<Resource>();
             for (Resource r : rcs[i]) {
                 if (r.isExists()) {
                     if (r.isDirectory()) {
                         dirs.add(r);
                     } else {
                         files.add(r);
                     }
                 }
             }
             // make sure directories are in alpha-order - this also
             // ensures parents come before their children
             Collections.sort(dirs, new Comparator<Resource>() {
                     public int compare(Resource r1, Resource r2) {
                         return r1.getName().compareTo(r2.getName());
                     }
                 });
             ArrayList<Resource> rs = new ArrayList<Resource>(dirs);
             rs.addAll(files);
             result[i] = rs.toArray(new Resource[rs.size()]);
         }
         return result;
     }
 
     /**
      * Add a directory to the zip stream.
      * @param dir  the directort to add to the archive
      * @param zOut the stream to write to
      * @param vPath the name this entry shall have in the archive
      * @param mode the Unix permissions to set.
diff --git a/src/main/org/apache/tools/ant/taskdefs/compilers/Gcj.java b/src/main/org/apache/tools/ant/taskdefs/compilers/Gcj.java
index 889d66712..3167cc244 100644
--- a/src/main/org/apache/tools/ant/taskdefs/compilers/Gcj.java
+++ b/src/main/org/apache/tools/ant/taskdefs/compilers/Gcj.java
@@ -1,159 +1,160 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.compilers;
 
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.types.Path;
 
 /**
  * The implementation of the gcj compiler.
  * This is primarily a cut-and-paste from the jikes.
  *
  * @since Ant 1.4
  */
 public class Gcj extends DefaultCompilerAdapter {
 
     /**
      * Performs a compile using the gcj compiler.
      * @return true if the compilation succeeded
      * @throws BuildException on error
      */
     public boolean execute() throws BuildException {
         Commandline cmd;
         attributes.log("Using gcj compiler", Project.MSG_VERBOSE);
         cmd = setupGCJCommand();
 
         int firstFileName = cmd.size();
         logAndAddFilesToCompile(cmd);
 
         return
             executeExternalCompile(cmd.getCommandline(), firstFileName) == 0;
     }
 
     /**
      * Set up the gcj commandline.
      * @return the command line
      */
     protected Commandline setupGCJCommand() {
         Commandline cmd = new Commandline();
         Path classpath = new Path(project);
 
         // gcj doesn't support bootclasspath dir (-bootclasspath)
         // so we'll emulate it for compatibility and convenience.
         Path p = getBootClassPath();
         if (p.size() > 0) {
             classpath.append(p);
         }
 
         // gcj doesn't support an extension dir (-extdir)
         // so we'll emulate it for compatibility and convenience.
         if (extdirs != null || includeJavaRuntime) {
             classpath.addExtdirs(extdirs);
         }
 
         classpath.append(getCompileClasspath());
 
         // Gcj has no option for source-path so we
         // will add it to classpath.
         if (compileSourcepath != null) {
             classpath.append(compileSourcepath);
         } else {
             classpath.append(src);
         }
 
         String exec = getJavac().getExecutable();
         cmd.setExecutable(exec == null ? "gcj" : exec);
 
         if (destDir != null) {
             cmd.createArgument().setValue("-d");
             cmd.createArgument().setFile(destDir);
 
-            if (!destDir.exists() && !destDir.mkdirs()) {
+            if (!destDir.exists()
+                && !(destDir.mkdirs() || destDir.isDirectory())) {
                 throw new BuildException("Can't make output directories. "
                                          + "Maybe permission is wrong. ");
             }
         }
 
         cmd.createArgument().setValue("-classpath");
         cmd.createArgument().setPath(classpath);
 
         if (encoding != null) {
             cmd.createArgument().setValue("--encoding=" + encoding);
         }
         if (debug) {
             cmd.createArgument().setValue("-g1");
         }
         if (optimize) {
             cmd.createArgument().setValue("-O");
         }
 
         /**
          *  gcj should be set for generate class.
          * ... if no 'compile to native' argument is passed
          */
         if (!isNativeBuild()) {
             cmd.createArgument().setValue("-C");
         }
 
         if (attributes.getSource() != null) {
             String source = attributes.getSource();
             cmd.createArgument().setValue("-fsource=" + source);
         }
 
         if (attributes.getTarget() != null) {
             String target = attributes.getTarget();
             cmd.createArgument().setValue("-ftarget=" + target);
         }
 
         addCurrentCompilerArgs(cmd);
 
         return cmd;
     }
 
     /**
      * Whether any of the arguments given via &lt;compilerarg&gt;
      * implies that compilation to native code is requested.
      * @return true if compilation to native code is requested
      * @since Ant 1.6.2
      */
     public boolean isNativeBuild() {
         boolean nativeBuild = false;
         String[] additionalArguments = getJavac().getCurrentCompilerArgs();
         int argsLength = 0;
         while (!nativeBuild && argsLength < additionalArguments.length) {
             int conflictLength = 0;
             while (!nativeBuild
                    && conflictLength < CONFLICT_WITH_DASH_C.length) {
                 nativeBuild = (additionalArguments[argsLength].startsWith
                                (CONFLICT_WITH_DASH_C[conflictLength]));
                 conflictLength++;
             }
             argsLength++;
         }
         return nativeBuild;
     }
 
     private static final String [] CONFLICT_WITH_DASH_C = {
         "-o" , "--main=", "-D", "-fjni", "-L"
     };
 
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/Native2Ascii.java b/src/main/org/apache/tools/ant/taskdefs/optional/Native2Ascii.java
index 2ff92f0ff..49b086acf 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/Native2Ascii.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/Native2Ascii.java
@@ -1,326 +1,327 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs.optional;
 
 import java.io.File;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.taskdefs.optional.native2ascii.Native2AsciiAdapter;
 import org.apache.tools.ant.taskdefs.optional.native2ascii.Native2AsciiAdapterFactory;
 import org.apache.tools.ant.types.Mapper;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.IdentityMapper;
 import org.apache.tools.ant.util.SourceFileScanner;
 import org.apache.tools.ant.util.facade.FacadeTaskHelper;
 import org.apache.tools.ant.util.facade.ImplementationSpecificArgument;
 
 /**
  * Converts files from native encodings to ASCII.
  *
  * @since Ant 1.2
  */
 public class Native2Ascii extends MatchingTask {
 
     private boolean reverse = false;  // convert from ascii back to native
     private String encoding = null;   // encoding to convert to/from
     private File srcDir = null;       // Where to find input files
     private File destDir = null;      // Where to put output files
     private String extension = null;  // Extension of output files if different
 
     private Mapper mapper;
     private FacadeTaskHelper facade = null;
     private Native2AsciiAdapter nestedAdapter = null;
 
     /** No args constructor */
     public Native2Ascii() {
         facade = new FacadeTaskHelper(Native2AsciiAdapterFactory.getDefault());
     }
 
     /**
      * Flag the conversion to run in the reverse sense,
      * that is Ascii to Native encoding.
      *
      * @param reverse True if the conversion is to be reversed,
      *                otherwise false;
      */
     public void setReverse(boolean reverse) {
         this.reverse = reverse;
     }
 
     /**
      * The value of the reverse attribute.
      * @return the reverse attribute.
      * @since Ant 1.6.3
      */
     public boolean getReverse() {
         return reverse;
     }
 
     /**
      * Set the encoding to translate to/from.
      * If unset, the default encoding for the JVM is used.
      *
      * @param encoding String containing the name of the Native
      *                 encoding to convert from or to.
      */
     public void setEncoding(String encoding) {
         this.encoding = encoding;
     }
 
     /**
      * The value of the encoding attribute.
      * @return the encoding attribute.
      * @since Ant 1.6.3
      */
     public String getEncoding() {
         return encoding;
     }
 
     /**
      * Set the source directory in which to find files to convert.
      *
      * @param srcDir directory to find input file in.
      */
     public void setSrc(File srcDir) {
         this.srcDir = srcDir;
     }
 
 
     /**
      * Set the destination directory to place converted files into.
      *
      * @param destDir directory to place output file into.
      */
     public void setDest(File destDir) {
         this.destDir = destDir;
     }
 
     /**
      * Set the extension which converted files should have.
      * If unset, files will not be renamed.
      *
      * @param ext File extension to use for converted files.
      */
     public void setExt(String ext) {
         this.extension = ext;
     }
 
     /**
      * Choose the implementation for this particular task.
      * @param impl the name of the implementation
      * @since Ant 1.6.3
      */
     public void setImplementation(String impl) {
         if ("default".equals(impl)) {
             facade.setImplementation(Native2AsciiAdapterFactory.getDefault());
         } else {
             facade.setImplementation(impl);
         }
     }
 
     /**
      * Defines the FileNameMapper to use (nested mapper element).
      *
      * @return the mapper to use for file name translations.
      *
      * @throws BuildException if more than one mapper is defined.
      */
     public Mapper createMapper() throws BuildException {
         if (mapper != null) {
             throw new BuildException("Cannot define more than one mapper",
                                      getLocation());
         }
         mapper = new Mapper(getProject());
         return mapper;
     }
 
     /**
      * A nested filenamemapper
      * @param fileNameMapper the mapper to add
      * @since Ant 1.6.3
      */
     public void add(FileNameMapper fileNameMapper) {
         createMapper().add(fileNameMapper);
     }
 
     /**
      * Adds an implementation specific command-line argument.
      * @return a ImplementationSpecificArgument to be configured
      *
      * @since Ant 1.6.3
      */
     public ImplementationSpecificArgument createArg() {
         ImplementationSpecificArgument arg =
             new ImplementationSpecificArgument();
         facade.addImplementationArgument(arg);
         return arg;
     }
 
     /**
      * The classpath to use when loading the native2ascii
      * implementation if it is not a built-in one.
      *
      * @since Ant 1.8.0
      */
     public Path createImplementationClasspath() {
         return facade.getImplementationClasspath(getProject());
     }
 
     /**
      * Set the adapter explicitly.
      * @since Ant 1.8.0
      */
     public void add(Native2AsciiAdapter adapter) {
         if (nestedAdapter != null) {
             throw new BuildException("Can't have more than one native2ascii"
                                      + " adapter");
         }
         nestedAdapter = adapter;
     }
 
     /**
      * Execute the task
      *
      * @throws BuildException is there is a problem in the task execution.
      */
     public void execute() throws BuildException {
 
         DirectoryScanner scanner = null; // Scanner to find our inputs
         String[] files;                  // list of files to process
 
         // default srcDir to basedir
         if (srcDir == null) {
             srcDir = getProject().resolveFile(".");
         }
 
         // Require destDir
         if (destDir == null) {
             throw new BuildException("The dest attribute must be set.");
         }
 
         // if src and dest dirs are the same, require the extension
         // to be set, so we don't stomp every file.  One could still
         // include a file with the same extension, but ....
         if (srcDir.equals(destDir) && extension == null && mapper == null) {
             throw new BuildException("The ext attribute or a mapper must be set if"
                                      + " src and dest dirs are the same.");
         }
 
         FileNameMapper m = null;
         if (mapper == null) {
             if (extension == null) {
                 m = new IdentityMapper();
             } else {
                 m = new ExtMapper();
             }
         } else {
             m = mapper.getImplementation();
         }
 
         scanner = getDirectoryScanner(srcDir);
         files = scanner.getIncludedFiles();
         SourceFileScanner sfs = new SourceFileScanner(this);
         files = sfs.restrict(files, srcDir, destDir, m);
         int count = files.length;
         if (count == 0) {
             return;
         }
         String message = "Converting " + count + " file"
             + (count != 1 ? "s" : "") + " from ";
         log(message + srcDir + " to " + destDir);
         for (int i = 0; i < files.length; i++) {
             convert(files[i], m.mapFileName(files[i])[0]);
         }
     }
 
     /**
      * Convert a single file.
      *
      * @param srcName name of the input file.
      * @param destName name of the input file.
      */
     private void convert(String srcName, String destName)
         throws BuildException {
         File srcFile;                         // File to convert
         File destFile;                        // where to put the results
 
         // Build the full file names
         srcFile = new File(srcDir, srcName);
         destFile = new File(destDir, destName);
 
         // Make sure we're not about to clobber something
         if (srcFile.equals(destFile)) {
             throw new BuildException("file " + srcFile
                                      + " would overwrite its self");
         }
 
         // Make intermediate directories if needed
         // TODO JDK 1.1 doesn't have File.getParentFile,
         String parentName = destFile.getParent();
         if (parentName != null) {
             File parentFile = new File(parentName);
 
-            if ((!parentFile.exists()) && (!parentFile.mkdirs())) {
+            if (!parentFile.exists()
+                && !(parentFile.mkdirs() || parentFile.isDirectory())) {
                 throw new BuildException("cannot create parent directory "
                                          + parentName);
             }
         }
 
         log("converting " + srcName, Project.MSG_VERBOSE);
         Native2AsciiAdapter ad =
             nestedAdapter != null ? nestedAdapter :
             Native2AsciiAdapterFactory.getAdapter(facade.getImplementation(),
                                                   this,
                                                   createImplementationClasspath());
         if (!ad.convert(this, srcFile, destFile)) {
             throw new BuildException("conversion failed");
         }
     }
 
     /**
      * Returns the (implementation specific) settings given as nested
      * arg elements.
      * @return the arguments.
      * @since Ant 1.6.3
      */
     public String[] getCurrentArgs() {
         return facade.getArgs();
     }
 
     private class ExtMapper implements FileNameMapper {
 
         public void setFrom(String s) {
         }
         public void setTo(String s) {
         }
 
         public String[] mapFileName(String fileName) {
             int lastDot = fileName.lastIndexOf('.');
             if (lastDot >= 0) {
                 return new String[] {fileName.substring(0, lastDot)
                                          + extension};
             } else {
                 return new String[] {fileName + extension};
             }
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/image/Image.java b/src/main/org/apache/tools/ant/taskdefs/optional/image/Image.java
index 8b5a2f919..1567c6760 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/image/Image.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/image/Image.java
@@ -1,420 +1,421 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.image;
 
 import com.sun.media.jai.codec.FileSeekableStream;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.DirectoryScanner;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.MatchingTask;
 import org.apache.tools.ant.types.FileSet;
 import org.apache.tools.ant.types.Mapper;
 import org.apache.tools.ant.types.optional.image.Draw;
 import org.apache.tools.ant.types.optional.image.ImageOperation;
 import org.apache.tools.ant.types.optional.image.Rotate;
 import org.apache.tools.ant.types.optional.image.Scale;
 import org.apache.tools.ant.types.optional.image.TransformOperation;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.IdentityMapper;
 
 import javax.media.jai.JAI;
 import javax.media.jai.PlanarImage;
 import java.io.File;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.Locale;
 import java.util.Vector;
 
 /**
  * A MatchingTask which relies on <a
  * href="http://java.sun.com/products/java-media/jai">JAI (Java
  * Advanced Imaging)</a> to perform image manipulation operations on
  * existing images.  The operations are represented as ImageOperation
  * DataType objects.  The operations are arranged to conform to the
  * Chaining Model of JAI.  Check out the <a
  * href="http://java.sun.com/products/java-media/jai/forDevelopers/jai1_0_1guide-unc/">
  * JAI Programming Guide</a>.
  *
  * @see org.apache.tools.ant.types.optional.image.ImageOperation
  * @see org.apache.tools.ant.types.DataType
  */
 public class Image extends MatchingTask {
     // CheckStyle:VisibilityModifier OFF - bc
     protected Vector instructions = new Vector();
     protected boolean overwrite = false;
     protected Vector filesets = new Vector();
     protected File srcDir = null;
     protected File destDir = null;
 
     // CheckStyle:MemberNameCheck OFF - bc
 
     //cannot remove underscores due to protected visibility >:(
     protected String str_encoding = "JPEG";
     protected boolean garbage_collect = false;
 
     private boolean failonerror = true;
 
     // CheckStyle:MemberNameCheck ON
 
     // CheckStyle:VisibilityModifier ON
 
     private Mapper mapperElement = null;
 
     /**
      * Add a set of files to be deleted.
      * @param set the FileSet to add.
      */
     public void addFileset(FileSet set) {
         filesets.addElement(set);
     }
 
     /**
      * Set whether to fail on error.
      * If false, note errors to the output but keep going.
      * @param failonerror true or false.
      */
     public void setFailOnError(boolean failonerror) {
         this.failonerror = failonerror;
     }
 
     /**
      * Set the source dir to find the image files.
      * @param srcDir the directory in which the image files reside.
      */
     public void setSrcdir(File srcDir) {
         this.srcDir = srcDir;
     }
 
     /**
      * Set the image encoding type.  <a
      * href="http://java.sun.com/products/java-media/jai/forDevelopers/jai1_0_1guide-unc/Encode.doc.html#56610">
      * See this table in the JAI Programming Guide</a>.
      * @param encoding the String image encoding.
      */
     public void setEncoding(String encoding) {
         str_encoding = encoding;
     }
 
     /**
      * Set whether to overwrite a file if there is a naming conflict.
      * @param overwrite whether to overwrite.
      */
     public void setOverwrite(boolean overwrite) {
         this.overwrite = overwrite;
     }
 
     /**
      * Set whether to invoke Garbage Collection after each image processed.
      * Defaults to false.
      * @param gc whether to invoke the garbage collector.
      */
     public void setGc(boolean gc) {
         garbage_collect = gc;
     }
 
     /**
      * Set the destination directory for manipulated images.
      * @param destDir The destination directory.
      */
     public void setDestDir(File destDir) {
         this.destDir = destDir;
     }
 
     /**
      * Add an ImageOperation to chain.
      * @param instr The ImageOperation to append to the chain.
      */
     public void addImageOperation(ImageOperation instr) {
         instructions.add(instr);
     }
 
     /**
      * Add a Rotate ImageOperation to the chain.
      * @param instr The Rotate operation to add to the chain.
      * @see org.apache.tools.ant.types.optional.image.Rotate
      */
     public void addRotate(Rotate instr) {
         instructions.add(instr);
     }
 
     /**
      * Add a Scale ImageOperation to the chain.
      * @param instr The Scale operation to add to the chain.
      * @see org.apache.tools.ant.types.optional.image.Scale
      */
     public void addScale(Scale instr) {
         instructions.add(instr);
     }
 
     /**
      * Add a Draw ImageOperation to the chain.  DrawOperation
      * DataType objects can be nested inside the Draw object.
      * @param instr The Draw operation to add to the chain.
      * @see org.apache.tools.ant.types.optional.image.Draw
      * @see org.apache.tools.ant.types.optional.image.DrawOperation
      */
     public void addDraw(Draw instr) {
         instructions.add(instr);
     }
 
     /**
     * Add an ImageOperation to chain.
     * @param instr The ImageOperation to append to the chain.
     * @since Ant 1.7
     */
     public void add(ImageOperation instr) {
         addImageOperation(instr);
     }
 
     /**
      * Defines the mapper to map source to destination files.
      * @return a mapper to be configured
      * @exception BuildException if more than one mapper is defined
      * @since Ant 1.8.0
      */
     public Mapper createMapper() throws BuildException {
         if (mapperElement != null) {
             throw new BuildException("Cannot define more than one mapper",
                                      getLocation());
         }
         mapperElement = new Mapper(getProject());
         return mapperElement;
     }
 
     /**
      * Add a nested filenamemapper.
      * @param fileNameMapper the mapper to add.
      * @since Ant 1.8.0
      */
     public void add(FileNameMapper fileNameMapper) {
         createMapper().add(fileNameMapper);
     }
 
     /**
      * Executes all the chained ImageOperations on the files inside
      * the directory.
      * @since Ant 1.8.0
      */
     public int processDir(final File srcDir, final String[] srcNames,
                           final File dstDir, final FileNameMapper mapper) {
         int writeCount = 0;
 
         for (int i = 0; i < srcNames.length; ++i) {
             final String srcName = srcNames[i];
             final File srcFile = new File(srcDir, srcName).getAbsoluteFile();
 
             final String[] dstNames = mapper.mapFileName(srcName);
             if (dstNames == null) {
                 log(srcFile + " skipped, don't know how to handle it",
                     Project.MSG_VERBOSE);
                 continue;
             }
 
             for (int j = 0; j < dstNames.length; ++j){
 
                 final String dstName = dstNames[j];
                 final File dstFile = new File(dstDir, dstName).getAbsoluteFile();
 
                 if (dstFile.exists()){
                     // avoid overwriting unless necessary
                     if(!overwrite
                        && srcFile.lastModified() <= dstFile.lastModified()) {
 
                         log(srcFile + " omitted as " + dstFile
                             + " is up to date.", Project.MSG_VERBOSE);
 
                         // don't overwrite the file
                         continue;
                     }
 
                     // avoid extra work while overwriting
                     if (!srcFile.equals(dstFile)){
                         dstFile.delete();
                     }
                 }
                 processFile(srcFile, dstFile);
                 ++writeCount;
             }
         }
 
         // run the garbage collector if wanted
         if (garbage_collect) {
             System.gc();
         }
 
         return writeCount;
     }
 
     /**
      * Executes all the chained ImageOperations on the file
      * specified.
      * @param file The file to be processed.
      * @deprecated this method isn't used anymore
      */
     public void processFile(File file) {
         processFile(file, new File(destDir == null
                                    ? srcDir : destDir, file.getName()));
     }
 
     /**
      * Executes all the chained ImageOperations on the file
      * specified.
      * @param file The file to be processed.
      * @param newFile The file to write to.
      * @since Ant 1.8.0
      */
     public void processFile(File file, File newFile) {
         try {
             log("Processing File: " + file.getAbsolutePath());
 
             FileSeekableStream input = null;
             PlanarImage image = null;
             try {
                 input = new FileSeekableStream(file);
                 image = JAI.create("stream", input);
                 final int size = instructions.size();
                 for (int i = 0; i < size; i++) {
                     Object instr = instructions.elementAt(i);
                     if (instr instanceof TransformOperation) {
                         image = ((TransformOperation) instr)
                             .executeTransformOperation(image);
                     } else {
                         log("Not a TransformOperation: " + instr);
                     }
                 }
             } finally {
                 FileUtils.close(input);
             }
 
             File dstParent = newFile.getParentFile();
-            if (!dstParent.isDirectory() && !dstParent.mkdirs()){
+            if (!dstParent.isDirectory()
+                && !(dstParent.mkdirs() || dstParent.isDirectory())) {
                 throw new BuildException("Failed to create parent directory "
                                          + dstParent);
             }
 
             if ((overwrite && newFile.exists()) && (!newFile.equals(file))) {
                 newFile.delete();
             }
 
             FileOutputStream stream = null;
             try {
                 stream = new FileOutputStream(newFile);
 
                 JAI.create("encode", image, stream,
                            str_encoding.toUpperCase(Locale.ENGLISH),
                            null);
                 stream.flush();
             } finally {
                 FileUtils.close(stream);
             }
         } catch (IOException err) {
             if (!file.equals(newFile)){
                 newFile.delete();
             }
             if (!failonerror) {
                 log("Error processing file:  " + err);
             } else {
                 throw new BuildException(err);
             }
         } catch (java.lang.RuntimeException rerr) {
             if (!file.equals(newFile)){
                 newFile.delete();
             }
             if (!failonerror) {
                 log("Error processing file:  " + rerr);
             } else {
                 throw new BuildException(rerr);
             }
         }
     }
 
     /**
      * Executes the Task.
      * @throws BuildException on error.
      */
     public void execute() throws BuildException {
 
         validateAttributes();
 
         try {
             File dest = destDir != null ? destDir : srcDir;
 
             int writeCount = 0;
 
             // build mapper
             final FileNameMapper mapper;
             if (mapperElement==null){
                 mapper = new IdentityMapper();
             } else {
                 mapper = mapperElement.getImplementation();
             }
 
             // deal with specified srcDir
             if (srcDir != null) {
                 final DirectoryScanner ds = super.getDirectoryScanner(srcDir);
 
                 final String[] files = ds.getIncludedFiles();
                 writeCount += processDir(srcDir, files, dest, mapper);
             }
             // deal with the filesets
             final int size = filesets.size();
             for (int i = 0; i < size; i++) {
                 final FileSet fs = (FileSet) filesets.elementAt(i);
                 final DirectoryScanner ds =
                     fs.getDirectoryScanner(getProject());
                 final String[] files = ds.getIncludedFiles();
                 final File fromDir = fs.getDir(getProject());
                 writeCount += processDir(fromDir, files, dest, mapper);
             }
 
             if (writeCount>0){
                 log("Processed " + writeCount +
                     (writeCount == 1 ? " image." : " images."));
             }
 
         } catch (Exception err) {
             err.printStackTrace();
             throw new BuildException(err.getMessage());
         }
     }
 
     /**
      * Ensure we have a consistent and legal set of attributes, and set
      * any internal flags necessary based on different combinations
      * of attributes.
      * @throws BuildException on error.
      */
     protected void validateAttributes() throws BuildException {
         if (srcDir == null && filesets.size() == 0) {
             throw new BuildException("Specify at least one source"
                                      + "--a srcDir or a fileset.");
         }
         if (srcDir == null && destDir == null) {
             throw new BuildException("Specify the destDir, or the srcDir.");
         }
         if (str_encoding.equalsIgnoreCase("jpg")) {
             str_encoding = "JPEG";
         } else if (str_encoding.equalsIgnoreCase("tif")) {
             str_encoding = "TIFF";
         }
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java b/src/main/org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java
index c42f0348f..3e105639c 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/pvcs/Pvcs.java
@@ -1,674 +1,674 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.pvcs;
 
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.FileReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.text.MessageFormat;
 import java.text.ParseException;
 import java.util.Enumeration;
 import java.util.Random;
 import java.util.Vector;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.taskdefs.Execute;
 import org.apache.tools.ant.taskdefs.ExecuteStreamHandler;
 import org.apache.tools.ant.taskdefs.LogOutputStream;
 import org.apache.tools.ant.taskdefs.LogStreamHandler;
 import org.apache.tools.ant.taskdefs.PumpStreamHandler;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  *
  * Extracts the latest edition of the source code from a PVCS repository.
  * PVCS is a version control system
  * developed by <a href="http://www.merant.com/products/pvcs">Merant</a>.
  * <br>
  * Before using this tag, the user running ant must have access to the commands
  * of PVCS (get and pcli) and must have access to the repository. Note that the way to specify
  * the repository is platform dependent so use property to specify location of repository.
  * <br>
  * This version has been tested agains PVCS version 6.5 and 6.6 under Windows and Solaris.
 
  *
  * <b>19-04-2001</b> <p>The task now has a more robust
  * parser. It allows for platform independant file paths
  * and supports file names with <i>()</i>. Thanks to Erik Husby for
  * bringing the bug to my attention.
  *
  * <b>27-04-2001</b> <p>UNC paths are now handled properly.
  * Fix provided by Don Jeffery. He also added an <i>UpdateOnly</i> flag
  * that, when true, conditions the PVCS get using the -U option to only
  * update those files that have a modification time (in PVCS) that is newer
  * than the existing workfile.
  *
  * <b>25-10-2002</b> <p>Added a revision attribute that currently is a
  * synonym for label, but in a future release the behavior of the label
  * attribute will change to use the -v option of GET.  See bug #13847 for
  * discussion.
  *
  */
 public class Pvcs extends org.apache.tools.ant.Task {
     // CheckStyle - magic numbers
     // checking for "X:\ 0=dquote,1=letter,2=:,3=\
     private static final int POS_1 = 1;
     private static final int POS_2 = 2;
     private static final int POS_3 = 3;
 
     private String pvcsbin;
     private String repository;
     private String pvcsProject;
     private Vector pvcsProjects;
     private String workspace;
     private String force;
     private String promotiongroup;
     private String label;
     private String revision;
     private boolean ignorerc;
     private boolean updateOnly;
     private String filenameFormat;
     private String lineStart;
     private String userId;
     private String config;
     /**
      * Constant for the thing to execute
      */
     private static final String PCLI_EXE = "pcli";
 
     /*
      * Constant for the PCLI listversionedfiles recursive i a format "get" understands
      */
     // private static final String PCLI_LVF_ARGS = "lvf -z -aw";
 
     /**
      * Constant for the thing to execute
      */
     private static final String GET_EXE = "get";
 
 
     /**
      * Run the command.
      * @param cmd the command line to use.
      * @param out the output stream handler to use.
      * @return the exit code of the command.
      */
     protected int runCmd(Commandline cmd, ExecuteStreamHandler out) {
         try {
             Project aProj = getProject();
             Execute exe = new Execute(out);
             exe.setAntRun(aProj);
             exe.setWorkingDirectory(aProj.getBaseDir());
             exe.setCommandline(cmd.getCommandline());
             return exe.execute();
         } catch (java.io.IOException e) {
             String msg = "Failed executing: " + cmd.toString()
                 + ". Exception: " + e.getMessage();
             throw new BuildException(msg, getLocation());
         }
     }
 
     private String getExecutable(String exe) {
         StringBuffer correctedExe = new StringBuffer();
         if (getPvcsbin() != null) {
             if (pvcsbin.endsWith(File.separator)) {
                 correctedExe.append(pvcsbin);
             } else {
                 correctedExe.append(pvcsbin).append(File.separator);
             }
         }
         return correctedExe.append(exe).toString();
     }
 
     /**
      * @exception org.apache.tools.ant.BuildException Something is stopping the build...
      */
     public void execute() throws org.apache.tools.ant.BuildException {
         int result = 0;
 
         if (repository == null || repository.trim().equals("")) {
             throw new BuildException("Required argument repository not specified");
         }
 
         // Check workspace exists
         // Launch PCLI listversionedfiles -z -aw
         // Capture output
         // build the command line from what we got the format is
         Commandline commandLine = new Commandline();
         commandLine.setExecutable(getExecutable(PCLI_EXE));
 
         commandLine.createArgument().setValue("lvf");
         commandLine.createArgument().setValue("-z");
         commandLine.createArgument().setValue("-aw");
         if (getWorkspace() != null) {
             commandLine.createArgument().setValue("-sp" + getWorkspace());
         }
         commandLine.createArgument().setValue("-pr" + getRepository());
 
         String uid = getUserId();
 
         if (uid != null) {
             commandLine.createArgument().setValue("-id" + uid);
         }
 
         // default pvcs project is "/"
         if (getPvcsproject() == null && getPvcsprojects().isEmpty()) {
             pvcsProject = "/";
         }
 
         if (getPvcsproject() != null) {
             commandLine.createArgument().setValue(getPvcsproject());
         }
         if (!getPvcsprojects().isEmpty()) {
             Enumeration e = getPvcsprojects().elements();
             while (e.hasMoreElements()) {
                 String projectName = ((PvcsProject) e.nextElement()).getName();
                 if (projectName == null || (projectName.trim()).equals("")) {
                     throw new BuildException("name is a required attribute "
                         + "of pvcsproject");
                 }
                 commandLine.createArgument().setValue(projectName);
             }
         }
 
         File tmp = null;
         File tmp2 = null;
         try {
             Random rand = new Random(System.currentTimeMillis());
             tmp = new File("pvcs_ant_" + rand.nextLong() + ".log");
             FileOutputStream fos = new FileOutputStream(tmp);
             tmp2 = new File("pvcs_ant_" + rand.nextLong() + ".log");
             log(commandLine.describeCommand(), Project.MSG_VERBOSE);
             try {
                 result = runCmd(commandLine,
                                 new PumpStreamHandler(fos,
                                     new LogOutputStream(this,
                                                         Project.MSG_WARN)));
             } finally {
                 FileUtils.close(fos);
             }
 
             if (Execute.isFailure(result) && !ignorerc) {
                 String msg = "Failed executing: " + commandLine.toString();
                 throw new BuildException(msg, getLocation());
             }
 
             if (!tmp.exists()) {
                 throw new BuildException("Communication between ant and pvcs "
                     + "failed. No output generated from executing PVCS "
                     + "commandline interface \"pcli\" and \"get\"");
             }
 
             // Create folders in workspace
             log("Creating folders", Project.MSG_INFO);
             createFolders(tmp);
 
             // Massage PCLI lvf output transforming '\' to '/' so get command works appropriately
             massagePCLI(tmp, tmp2);
 
             // Launch get on output captured from PCLI lvf
             commandLine.clearArgs();
             commandLine.setExecutable(getExecutable(GET_EXE));
 
             if (getConfig() != null && getConfig().length() > 0) {
                 commandLine.createArgument().setValue("-c" + getConfig());
             }
 
             if (getForce() != null && getForce().equals("yes")) {
                 commandLine.createArgument().setValue("-Y");
             } else {
                 commandLine.createArgument().setValue("-N");
             }
 
             if (getPromotiongroup() != null) {
                 commandLine.createArgument().setValue("-G"
                     + getPromotiongroup());
             } else {
                 if (getLabel() != null) {
                     commandLine.createArgument().setValue("-v" + getLabel());
                 } else {
                     if (getRevision() != null) {
                         commandLine.createArgument().setValue("-r"
                             + getRevision());
                     }
                 }
             }
 
             if (updateOnly) {
                 commandLine.createArgument().setValue("-U");
             }
 
             commandLine.createArgument().setValue("@" + tmp2.getAbsolutePath());
             log("Getting files", Project.MSG_INFO);
             log("Executing " + commandLine.toString(), Project.MSG_VERBOSE);
             result = runCmd(commandLine,
                 new LogStreamHandler(this, Project.MSG_INFO, Project.MSG_WARN));
             if (result != 0 && !ignorerc) {
                 String msg = "Failed executing: " + commandLine.toString()
                     + ". Return code was " + result;
                 throw new BuildException(msg, getLocation());
             }
 
         } catch (FileNotFoundException e) {
             String msg = "Failed executing: " + commandLine.toString()
                 + ". Exception: " + e.getMessage();
             throw new BuildException(msg, getLocation());
         } catch (IOException e) {
             String msg = "Failed executing: " + commandLine.toString()
                 + ". Exception: " + e.getMessage();
             throw new BuildException(msg, getLocation());
         } catch (ParseException e) {
             String msg = "Failed executing: " + commandLine.toString()
                 + ". Exception: " + e.getMessage();
             throw new BuildException(msg, getLocation());
         } finally {
             if (tmp != null) {
                 tmp.delete();
             }
             if (tmp2 != null) {
                 tmp2.delete();
             }
         }
     }
 
     /**
      * Parses the file and creates the folders specified in the output section
      */
     private void createFolders(File file) throws IOException, ParseException {
         BufferedReader in = null;
         try {
             in = new BufferedReader(new FileReader(file));
             MessageFormat mf = new MessageFormat(getFilenameFormat());
             String line = in.readLine();
             while (line != null) {
                 log("Considering \"" + line + "\"", Project.MSG_VERBOSE);
                 if (line.startsWith("\"\\")    // Checking for "\
                     || line.startsWith("\"/")  // or           "/
                                                // or           "X:\...
                    || (line.length() > POS_3 && line.startsWith("\"")
                         && Character.isLetter(line.charAt(POS_1))
                         && String.valueOf(line.charAt(POS_2)).equals(":")
                         && String.valueOf(line.charAt(POS_3)).equals("\\"))) {
                     Object[] objs = mf.parse(line);
                     String f = (String) objs[1];
                     // Extract the name of the directory from the filename
                     int index = f.lastIndexOf(File.separator);
                     if (index > -1) {
                         File dir = new File(f.substring(0, index));
                         if (!dir.exists()) {
                             log("Creating " + dir.getAbsolutePath(),
                                 Project.MSG_VERBOSE);
-                            if (dir.mkdirs()) {
+                            if (dir.mkdirs() || dir.isDirectory()) {
                                 log("Created " + dir.getAbsolutePath(),
                                     Project.MSG_INFO);
                             } else {
                                 log("Failed to create "
                                     + dir.getAbsolutePath(),
                                     Project.MSG_INFO);
                             }
                         } else {
                             log(dir.getAbsolutePath() + " exists. Skipping",
                                 Project.MSG_VERBOSE);
                         }
                     } else {
                         log("File separator problem with " + line,
                             Project.MSG_WARN);
                     }
                 } else {
                     log("Skipped \"" + line + "\"", Project.MSG_VERBOSE);
                 }
                 line = in.readLine();
             }
         } finally {
             FileUtils.close(in);
         }
     }
 
 
     /**
      * Simple hack to handle the PVCS command-line tools botch when
      * handling UNC notation.
      * @throws IOException if there is an error.
      */
     private void massagePCLI(File in, File out)
         throws IOException {
         BufferedReader inReader = null;
         BufferedWriter outWriter = null;
         try {
             inReader = new BufferedReader(new FileReader(in));
             outWriter = new BufferedWriter(new FileWriter(out));
             String s = null;
             while ((s = inReader.readLine()) != null) {
                 String sNormal = s.replace('\\', '/');
                 outWriter.write(sNormal);
                 outWriter.newLine();
             }
         } finally {
             FileUtils.close(inReader);
             FileUtils.close(outWriter);
         }
     }
 
     /**
      * Get network name of the PVCS repository
      * @return String
      */
     public String getRepository() {
         return repository;
     }
 
     /**
      *  The filenameFormat attribute defines a MessageFormat string used
      *  to parse the output of the pcli command.  It defaults to
      *  <code>{0}-arc({1})</code>.  Repositories where the archive
      *   extension is not  -arc should set this.
      * @return the filename format attribute.
      */
     public String getFilenameFormat() {
         return filenameFormat;
     }
 
     /**
      * The format of the folder names; optional.
      * This must be in a format suitable for
      * <code>java.text.MessageFormat</code>.
      *  Index 1 of the format will be used as the file name.
      *  Defaults to <code>{0}-arc({1})</code>
      * @param f the format to use.
      */
     public void setFilenameFormat(String f) {
         filenameFormat = f;
     }
 
     /**
 
      * The lineStart attribute is used to parse the output of the pcli
      * command. It defaults to <code>&quot;P:</code>.  The parser already
      * knows about / and \\, this property is useful in cases where the
      * repository is accessed on a Windows platform via a drive letter
      * mapping.
      * @return the lineStart attribute.
      */
     public String getLineStart() {
         return lineStart;
     }
 
     /**
      * What a valid return value from PVCS looks like
      *  when it describes a file.  Defaults to <code>&quot;P:</code>.
      * If you are not using an UNC name for your repository and the
      * drive letter <code>P</code> is incorrect for your setup, you may
      * need to change this value, UNC names will always be
      * accepted.
      * @param l the value to use.
      */
     public void setLineStart(String l) {
         lineStart = l;
     }
 
     /**
      * The network name of the PVCS repository; required.
      * @param repo String
      */
     public void setRepository(String repo) {
         repository = repo;
     }
 
     /**
      * Get name of the project in the PVCS repository
      * @return String
      */
     public String getPvcsproject() {
         return pvcsProject;
     }
 
     /**
      * The project within the PVCS repository to extract files from;
      * optional, default &quot;/&quot;
      * @param prj String
      */
     public void setPvcsproject(String prj) {
         pvcsProject = prj;
     }
 
     /**
      * Get name of the project in the PVCS repository
      * @return Vector
      */
     public Vector getPvcsprojects() {
         return pvcsProjects;
     }
 
     /**
      * Get name of the workspace to store the retrieved files
      * @return String
      */
     public String getWorkspace() {
         return workspace;
     }
 
     /**
      * Workspace to use; optional.
      * By specifying a workspace, the files are extracted to that location.
      * A PVCS workspace is a name for a location of the workfiles and
      * isn't as such the location itself.
      * You define the location for a workspace using the PVCS GUI clients.
      * If this isn't specified the default workspace for the current user is used.
      * @param ws String
      */
     public void setWorkspace(String ws) {
         workspace = ws;
     }
 
     /**
      * Get name of the PVCS bin directory
      * @return String
      */
     public String getPvcsbin() {
         return pvcsbin;
     }
 
     /**
      * Specifies the location of the PVCS bin directory; optional if on the PATH.
      * On some systems the PVCS executables <i>pcli</i>
      * and <i>get</i> are not found in the PATH. In such cases this attribute
      * should be set to the bin directory of the PVCS installation containing
      * the executables mentioned before. If this attribute isn't specified the
      * tag expects the executables to be found using the PATH environment variable.
      * @param bin PVCS bin directory
      * @todo use a File setter and resolve paths.
      */
     public void setPvcsbin(String bin) {
         pvcsbin = bin;
     }
 
     /**
      * Get value of force
      * @return String
      */
     public String getForce() {
         return force;
     }
 
     /**
      * Specifies the value of the force argument; optional.
      * If set to <i>yes</i> all files that exists and are
      * writable are overwritten. Default <i>no</i> causes the files
      * that are writable to be ignored. This stops the PVCS command
      * <i>get</i> to stop asking questions!
      * @todo make a boolean setter
      * @param f String (yes/no)
      */
     public void setForce(String f) {
         if (f != null && f.equalsIgnoreCase("yes")) {
             force = "yes";
         } else {
             force = "no";
         }
     }
 
     /**
      * Get value of promotiongroup
      * @return String
      */
     public String getPromotiongroup() {
         return promotiongroup;
     }
 
     /**
      * Specifies the name of the promotiongroup argument
      * @param w String
      */
     public void setPromotiongroup(String w) {
         promotiongroup = w;
     }
 
     /**
      * Get value of label
      * @return String
      */
     public String getLabel() {
         return label;
     }
 
     /**
      * Only files marked with this label are extracted; optional.
      * @param l String
      */
     public void setLabel(String l) {
         label = l;
     }
 
     /**
      * Get value of revision
      * @return String
      */
     public String getRevision() {
         return revision;
     }
 
     /**
      * Only files with this revision are extract; optional.
      * @param r String
      */
     public void setRevision(String r) {
         revision = r;
     }
 
     /**
      * Get value of ignorereturncode
      * @return String
      */
     public boolean getIgnoreReturnCode() {
         return ignorerc;
     }
 
     /**
      * If set to true the return value from executing the pvcs
      * commands are ignored; optional, default false.
      * @param b a <code>boolean</code> value.
      */
     public void setIgnoreReturnCode(boolean b) {
         ignorerc = b;
     }
 
     /**
      * Specify a project within the PVCS repository to extract files from.
      * @param p the pvcs project to use.
      */
     public void addPvcsproject(PvcsProject p) {
         pvcsProjects.addElement(p);
     }
 
     /**
      * get the updateOnly attribute.
      * @return the updateOnly attribute.
      */
     public boolean getUpdateOnly() {
         return updateOnly;
     }
 
     /**
      * If set to <i>true</i> files are fetched only if
      * newer than existing local files; optional, default false.
      * @param l a <code>boolean</code> value.
      */
     public void setUpdateOnly(boolean l) {
         updateOnly = l;
     }
 
     /**
      * returns the path of the configuration file to be used
      * @return the path of the config file
      */
     public String getConfig() {
         return config;
     }
 
     /**
      * Sets a configuration file other than the default to be used.
      * These files have a .cfg extension and are often found in archive or pvcsprop folders.
      * @param f config file - can be given absolute or relative to ant basedir
      */
     public void setConfig(File f) {
         config = f.toString();
     }
 
 
     /**
      * Get the userid.
      * @return the userid.
      */
     public String getUserId() {
         return userId;
     }
 
     /**
      * User ID
      * @param u the value to use.
      */
     public void setUserId(String u) {
         userId = u;
     }
 
     /**
      * Creates a Pvcs object
      */
     public Pvcs() {
         super();
         pvcsProject = null;
         pvcsProjects = new Vector();
         workspace = null;
         repository = null;
         pvcsbin = null;
         force = null;
         promotiongroup = null;
         label = null;
         ignorerc = false;
         updateOnly = false;
         lineStart = "\"P:";
         filenameFormat = "{0}-arc({1})";
     }
 }
 
diff --git a/src/main/org/apache/tools/ant/taskdefs/optional/sos/SOS.java b/src/main/org/apache/tools/ant/taskdefs/optional/sos/SOS.java
index 8c1992a59..80bb1041d 100644
--- a/src/main/org/apache/tools/ant/taskdefs/optional/sos/SOS.java
+++ b/src/main/org/apache/tools/ant/taskdefs/optional/sos/SOS.java
@@ -1,478 +1,478 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.taskdefs.optional.sos;
 
 import java.io.File;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.taskdefs.Execute;
 import org.apache.tools.ant.taskdefs.LogStreamHandler;
 import org.apache.tools.ant.types.Commandline;
 import org.apache.tools.ant.types.Path;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * A base class for creating tasks for executing commands on SourceOffSite.
  *
  *  These tasks were inspired by the VSS tasks.
  *
  */
 
 public abstract class SOS extends Task implements SOSCmd {
 
     private static final int ERROR_EXIT_STATUS = 255;
 
     private String sosCmdDir = null;
     private String sosUsername = null;
     private String sosPassword = "";
     private String projectPath = null;
     private String vssServerPath = null;
     private String sosServerPath = null;
     private String sosHome = null;
     private String localPath = null;
     private String version = null;
     private String label = null;
     private String comment = null;
     private String filename = null;
 
     private boolean noCompress = false;
     private boolean noCache = false;
     private boolean recursive = false;
     private boolean verbose = false;
 
     // CheckStyle:VisibilityModifier OFF - bc
     /** Commandline to be executed. */
     protected Commandline commandLine;
     // CheckStyle:VisibilityModifier ON
 
     /**
      * Flag to disable the cache when set.
      * Required if SOSHOME is set as an environment variable.
      * Defaults to false.
      *
      * @param  nocache  True to disable caching.
      */
     public final void setNoCache(boolean nocache) {
         noCache = nocache;
     }
 
     /**
      * Flag to disable compression when set. Defaults to false.
      *
      * @param  nocompress  True to disable compression.
      */
     public final void setNoCompress(boolean nocompress) {
         noCompress = nocompress;
     }
 
     /**
      * The directory where soscmd(.exe) is located.
      * soscmd must be on the path if omitted.
      *
      * @param  dir  The new sosCmd value.
      */
     public final void setSosCmd(String dir) {
         sosCmdDir = FileUtils.translatePath(dir);
     }
 
     /**
      * The SourceSafe username.
      *
      * @param  username  The new username value.
      *
      * @ant.attribute group="required"
      */
     public final void setUsername(String username) {
         sosUsername = username;
     }
 
     /**
      * The SourceSafe password.
      *
      * @param  password  The new password value.
      */
     public final void setPassword(String password) {
         sosPassword = password;
     }
 
     /**
      * The SourceSafe project path.
      *
      * @param  projectpath  The new projectpath value.
      *
      * @ant.attribute group="required"
      */
     public final void setProjectPath(String projectpath) {
         if (projectpath.startsWith(SOSCmd.PROJECT_PREFIX)) {
             projectPath = projectpath;
         } else {
             projectPath = SOSCmd.PROJECT_PREFIX + projectpath;
         }
     }
 
     /**
      * The path to the location of the ss.ini file.
      *
      * @param  vssServerPath  The new vssServerPath value.
      *
      * @ant.attribute group="required"
      */
     public final void setVssServerPath(String vssServerPath) {
         this.vssServerPath = vssServerPath;
     }
 
     /**
      * Path to the SourceOffSite home directory.
      *
      * @param  sosHome  The new sosHome value.
      */
     public final void setSosHome(String sosHome) {
         this.sosHome = sosHome;
     }
 
     /**
      * The address and port of SourceOffSite Server,
      * for example 192.168.0.1:8888.
      *
      * @param  sosServerPath  The new sosServerPath value.
      *
      * @ant.attribute group="required"
      */
     public final void setSosServerPath(String sosServerPath) {
         this.sosServerPath = sosServerPath;
     }
 
     /**
      * Override the working directory and get to the specified path.
      *
      * @param  path  The new localPath value.
      */
     public final void setLocalPath(Path path) {
         localPath = path.toString();
     }
 
     /**
      * Enable verbose output. Defaults to false.
      *
      * @param  verbose  True for verbose output.
      */
     public void setVerbose(boolean verbose) {
         this.verbose = verbose;
     }
 
     // Special setters for the sub-classes
 
     /**
      * Set the file name.
      * @param file the filename to use.
      */
     protected void setInternalFilename(String file) {
         filename = file;
     }
 
     /**
      * Set the recursive flag.
      * @param recurse if true use the recursive flag on the command line.
      */
     protected void setInternalRecursive(boolean recurse) {
         recursive = recurse;
     }
 
     /**
      * Set the comment text.
      * @param text the comment text to use.
      */
     protected void setInternalComment(String text) {
         comment = text;
     }
 
     /**
      * Set the label.
      * @param text the label to use.
      */
     protected void setInternalLabel(String text) {
         label = text;
     }
 
     /**
      * Set the version.
      * @param text the version to use.
      */
     protected void setInternalVersion(String text) {
         version = text;
     }
 
     /**
      * Get the executable to run. Add the path if it was specified in the build file
      *
      * @return the executable to run.
      */
     protected String getSosCommand() {
         if (sosCmdDir == null) {
             return COMMAND_SOS_EXE;
         } else {
             return sosCmdDir + File.separator + COMMAND_SOS_EXE;
         }
     }
 
     /**
      * Get the comment
      * @return if it was set, null if not.
      */
     protected String getComment() {
         return comment;
     }
 
     /**
      * Get the version
      * @return if it was set, null if not.
      */
     protected String getVersion() {
         return version;
     }
 
     /**
      * Get the label
      * @return if it was set, null if not.
      */
     protected String getLabel() {
         return label;
     }
 
     /**
      * Get the username
      * @return if it was set, null if not.
      */
     protected String getUsername() {
         return sosUsername;
     }
 
     /**
      * Get the password
      * @return empty string if it wasn't set.
      */
     protected String getPassword() {
         return sosPassword;
     }
 
     /**
      * Get the project path
      * @return if it was set, null if not.
      */
     protected String getProjectPath() {
         return projectPath;
     }
 
     /**
      * Get the VSS server path
      * @return if it was set, null if not.
      */
     protected String getVssServerPath() {
         return vssServerPath;
     }
 
     /**
      * Get the SOS home directory.
      * @return if it was set, null if not.
      */
     protected String getSosHome() {
         return sosHome;
     }
 
     /**
      * Get the SOS serve path.
      * @return if it was set, null if not.
      */
     protected String getSosServerPath() {
         return sosServerPath;
     }
 
     /**
      * Get the filename to be acted upon.
      * @return if it was set, null if not.
      */
     protected String getFilename() {
         return filename;
     }
 
     /**
      * Get the NoCompress flag.
      *
      * @return the 'nocompress' Flag if the attribute was 'true',
      *         otherwise an empty string.
      */
     protected String getNoCompress() {
         return noCompress ? FLAG_NO_COMPRESSION : "";
     }
 
     /**
      * Get the NoCache flag.
      *
      * @return the 'nocache' Flag if the attribute was 'true', otherwise an empty string.
      */
     protected String getNoCache() {
         return noCache ? FLAG_NO_CACHE : "";
     }
 
     /**
      * Get the 'verbose' Flag.
      *
      * @return the 'verbose' Flag if the attribute was 'true', otherwise an empty string.
      */
     protected String getVerbose() {
         return verbose ? FLAG_VERBOSE : "";
     }
 
     /**
      * Get the 'recursive' Flag.
      *
      * @return the 'recursive' Flag if the attribute was 'true', otherwise an empty string.
      */
     protected String getRecursive() {
         return recursive ? FLAG_RECURSION : "";
     }
 
     /**
      * Builds and returns the working directory.
      * <p>
      * The localpath is created if it didn't exist.
      *
      * @return the absolute path of the working directory.
      */
     protected String getLocalPath() {
         if (localPath == null) {
             return getProject().getBaseDir().getAbsolutePath();
         } else {
             // make sure localDir exists, create it if it doesn't
             File dir = getProject().resolveFile(localPath);
             if (!dir.exists()) {
-                boolean done = dir.mkdirs();
+                boolean done = dir.mkdirs() || dir.isDirectory();
                 if (!done) {
                     String msg = "Directory " + localPath + " creation was not "
                         + "successful for an unknown reason";
                     throw new BuildException(msg, getLocation());
                 }
                 getProject().log("Created dir: " + dir.getAbsolutePath());
             }
             return dir.getAbsolutePath();
         }
     }
 
     /**
      * Subclasses implement the logic required to construct the command line.
      *
      * @return   The command line to execute.
      */
     abstract Commandline buildCmdLine();
 
 
     /**
      * Execute the created command line.
      *
      * @throws BuildException on error.
      */
     public void execute()
         throws BuildException {
         int result = 0;
         buildCmdLine();
         result = run(commandLine);
         if (result == ERROR_EXIT_STATUS) {  // This is the exit status
             String msg = "Failed executing: " + commandLine.toString();
             throw new BuildException(msg, getLocation());
         }
     }
 
     /**
      * Execute the created command line.
      *
      * @param  cmd              The command line to run.
      * @return                  int the exit code.
      * @throws  BuildException
      */
     protected int run(Commandline cmd) {
         try {
             Execute exe = new Execute(new LogStreamHandler(this,
                     Project.MSG_INFO,
                     Project.MSG_WARN));
 
             exe.setAntRun(getProject());
             exe.setWorkingDirectory(getProject().getBaseDir());
             exe.setCommandline(cmd.getCommandline());
             exe.setVMLauncher(false);  // Use the OS VM launcher so we get environment variables
             return exe.execute();
         } catch (java.io.IOException e) {
             throw new BuildException(e, getLocation());
         }
     }
 
     /** Sets the executable and add the required attributes to the command line. */
     protected void getRequiredAttributes() {
         // Get the path to the soscmd(.exe)
         commandLine.setExecutable(getSosCommand());
         // SOS server address is required
         if (getSosServerPath() == null) {
             throw new BuildException("sosserverpath attribute must be set!", getLocation());
         }
         commandLine.createArgument().setValue(FLAG_SOS_SERVER);
         commandLine.createArgument().setValue(getSosServerPath());
         // Login info is required
         if (getUsername() == null) {
             throw new BuildException("username attribute must be set!", getLocation());
         }
         commandLine.createArgument().setValue(FLAG_USERNAME);
         commandLine.createArgument().setValue(getUsername());
         // The SOS class knows that the SOS server needs the password flag,
         // even if there is no password ,so we send a " "
         commandLine.createArgument().setValue(FLAG_PASSWORD);
         commandLine.createArgument().setValue(getPassword());
         // VSS Info is required
         if (getVssServerPath() == null) {
             throw new BuildException("vssserverpath attribute must be set!", getLocation());
         }
         commandLine.createArgument().setValue(FLAG_VSS_SERVER);
         commandLine.createArgument().setValue(getVssServerPath());
         // VSS project is required
         if (getProjectPath() == null) {
             throw new BuildException("projectpath attribute must be set!", getLocation());
         }
         commandLine.createArgument().setValue(FLAG_PROJECT);
         commandLine.createArgument().setValue(getProjectPath());
     }
 
     /** Adds the optional attributes to the command line. */
     protected void getOptionalAttributes() {
         // -verbose
         commandLine.createArgument().setValue(getVerbose());
         // Disable Compression
         commandLine.createArgument().setValue(getNoCompress());
         // Path to the SourceOffSite home directory /home/user/.sos
         if (getSosHome() == null) {
             // If -soshome was not specified then we can look for nocache
             commandLine.createArgument().setValue(getNoCache());
         } else {
             commandLine.createArgument().setValue(FLAG_SOS_HOME);
             commandLine.createArgument().setValue(getSosHome());
         }
         //If a working directory was specified then add it to the command line
         if (getLocalPath() != null) {
             commandLine.createArgument().setValue(FLAG_WORKING_DIR);
             commandLine.createArgument().setValue(getLocalPath());
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/util/FileUtils.java b/src/main/org/apache/tools/ant/util/FileUtils.java
index caaa82b61..01030107f 100644
--- a/src/main/org/apache/tools/ant/util/FileUtils.java
+++ b/src/main/org/apache/tools/ant/util/FileUtils.java
@@ -311,1411 +311,1412 @@ public class FileUtils {
     }
 
     /**
      * Convenience method to copy a file from a source to a destination. No filtering is performed.
      *
      * @param sourceFile the file to copy from. Must not be <code>null</code>.
      * @param destFile the file to copy to. Must not be <code>null</code>.
      *
      * @throws IOException if the copying fails.
      */
     public void copyFile(File sourceFile, File destFile) throws IOException {
         copyFile(sourceFile, destFile, null, false, false);
     }
 
     /**
      * Convenience method to copy a file from a source to a destination
      * specifying if token filtering must be used.
      *
      * @param sourceFile the file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile the file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      *
      * @throws IOException if the copying fails.
      */
     public void copyFile(File sourceFile, File destFile, FilterSetCollection filters)
             throws IOException {
         copyFile(sourceFile, destFile, filters, false, false);
     }
 
     /**
      * Convenience method to copy a file from a source to a
      * destination specifying if token filtering must be used and if
      * source files may overwrite newer destination files.
      *
      * @param sourceFile the file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile the file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param overwrite Whether or not the destination file should be
      *                  overwritten if it already exists.
      *
      * @throws IOException if the copying fails.
      */
     public void copyFile(File sourceFile, File destFile, FilterSetCollection filters,
                          boolean overwrite) throws IOException {
         copyFile(sourceFile, destFile, filters, overwrite, false);
     }
 
     /**
      * Convenience method to copy a file from a source to a
      * destination specifying if token filtering must be used, if
      * source files may overwrite newer destination files and the
      * last modified time of <code>destFile</code> file should be made equal
      * to the last modified time of <code>sourceFile</code>.
      *
      * @param sourceFile the file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile the file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param overwrite Whether or not the destination file should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the resulting file should be set to that
      *                             of the source file.
      *
      * @throws IOException if the copying fails.
      */
     public void copyFile(File sourceFile, File destFile, FilterSetCollection filters,
                          boolean overwrite, boolean preserveLastModified) throws IOException {
         copyFile(sourceFile, destFile, filters, overwrite, preserveLastModified, null);
     }
 
     /**
      * Convenience method to copy a file from a source to a destination specifying if token
      * filtering must be used, if source files may overwrite newer destination files, the last
      * modified time of <code>destFile</code> file should be made equal to the last modified time
      * of <code>sourceFile</code> and which character encoding to assume.
      *
      * @param sourceFile the file to copy from. Must not be <code>null</code>.
      * @param destFile the file to copy to. Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param overwrite Whether or not the destination file should be overwritten if it already
      *            exists.
      * @param preserveLastModified Whether or not the last modified time of the resulting file
      *            should be set to that of the source file.
      * @param encoding the encoding used to read and write the files.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.5
      */
     public void copyFile(File sourceFile, File destFile,
                          FilterSetCollection filters, boolean overwrite,
                          boolean preserveLastModified, String encoding) throws IOException {
         copyFile(sourceFile, destFile, filters, null, overwrite,
                  preserveLastModified, encoding, null);
     }
 
     /**
      * Convenience method to copy a file from a source to a
      * destination specifying if token filtering must be used, if
      * filter chains must be used, if source files may overwrite
      * newer destination files and the last modified time of
      * <code>destFile</code> file should be made equal
      * to the last modified time of <code>sourceFile</code>.
      *
      * @param sourceFile the file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile the file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination file should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the resulting file should be set to that
      *                             of the source file.
      * @param encoding the encoding used to read and write the files.
      * @param project the project instance.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.5
      */
     public void copyFile(File sourceFile, File destFile,
                          FilterSetCollection filters, Vector filterChains,
                          boolean overwrite, boolean preserveLastModified,
                          String encoding, Project project) throws IOException {
         copyFile(sourceFile, destFile, filters, filterChains,
                  overwrite, preserveLastModified, encoding, encoding, project);
     }
 
     /**
      * Convenience method to copy a file from a source to a
      * destination specifying if token filtering must be used, if
      * filter chains must be used, if source files may overwrite
      * newer destination files and the last modified time of
      * <code>destFile</code> file should be made equal
      * to the last modified time of <code>sourceFile</code>.
      *
      * @param sourceFile the file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile the file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination file should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the resulting file should be set to that
      *                             of the source file.
      * @param inputEncoding the encoding used to read the files.
      * @param outputEncoding the encoding used to write the files.
      * @param project the project instance.
      *
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.6
      */
     public void copyFile(File sourceFile, File destFile,
             FilterSetCollection filters, Vector filterChains,
             boolean overwrite, boolean preserveLastModified,
             String inputEncoding, String outputEncoding,
             Project project) throws IOException {
         copyFile(sourceFile, destFile, filters, filterChains, overwrite, preserveLastModified,
                 false, inputEncoding, outputEncoding, project);
     }
 
     /**
      * Convenience method to copy a file from a source to a
      * destination specifying if token filtering must be used, if
      * filter chains must be used, if source files may overwrite
      * newer destination files and the last modified time of
      * <code>destFile</code> file should be made equal
      * to the last modified time of <code>sourceFile</code>.
      *
      * @param sourceFile the file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile the file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination file should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the resulting file should be set to that
      *                             of the source file.
      * @param append whether to append to the destination file.
      * @param inputEncoding the encoding used to read the files.
      * @param outputEncoding the encoding used to write the files.
      * @param project the project instance.
      *
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.8
      */
     public void copyFile(File sourceFile, File destFile,
                          FilterSetCollection filters, Vector filterChains,
                          boolean overwrite, boolean preserveLastModified,
                          boolean append,
                          String inputEncoding, String outputEncoding,
                          Project project) throws IOException {
         copyFile(sourceFile, destFile, filters, filterChains, overwrite,
                  preserveLastModified, append, inputEncoding, outputEncoding,
                  project, /* force: */ false);
     }
 
     /**
      * Convenience method to copy a file from a source to a
      * destination specifying if token filtering must be used, if
      * filter chains must be used, if source files may overwrite
      * newer destination files and the last modified time of
      * <code>destFile</code> file should be made equal
      * to the last modified time of <code>sourceFile</code>.
      *
      * @param sourceFile the file to copy from.
      *                   Must not be <code>null</code>.
      * @param destFile the file to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination file should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the resulting file should be set to that
      *                             of the source file.
      * @param append whether to append to the destination file.
      * @param inputEncoding the encoding used to read the files.
      * @param outputEncoding the encoding used to write the files.
      * @param project the project instance.
      * @param force whether to overwrite read-only destination files.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.8.2
      */
     public void copyFile(File sourceFile, File destFile,
                          FilterSetCollection filters, Vector filterChains,
                          boolean overwrite, boolean preserveLastModified,
                          boolean append,
                          String inputEncoding, String outputEncoding,
                          Project project, boolean force) throws IOException {
         ResourceUtils.copyResource(new FileResource(sourceFile),
                                    new FileResource(destFile),
                                    filters, filterChains, overwrite,
                                    preserveLastModified, append, inputEncoding,
                                    outputEncoding, project, force);
     }
 
     // CheckStyle:ParameterNumberCheck ON
 
     /**
      * Calls File.setLastModified(long time). Originally written to
      * to dynamically bind to that call on Java1.2+.
      *
      * @param file the file whose modified time is to be set
      * @param time the time to which the last modified time is to be set.
      *             if this is -1, the current time is used.
      */
     public void setFileLastModified(File file, long time) {
         ResourceUtils.setLastModified(new FileResource(file), time);
     }
 
     /**
      * Interpret the filename as a file relative to the given file
      * unless the filename already represents an absolute filename.
      * Differs from <code>new File(file, filename)</code> in that
      * the resulting File's path will always be a normalized,
      * absolute pathname.  Also, if it is determined that
      * <code>filename</code> is context-relative, <code>file</code>
      * will be discarded and the reference will be resolved using
      * available context/state information about the filesystem.
      *
      * @param file the "reference" file for relative paths. This
      * instance must be an absolute file and must not contain
      * &quot;./&quot; or &quot;../&quot; sequences (same for \ instead
      * of /).  If it is null, this call is equivalent to
      * <code>new java.io.File(filename).getAbsoluteFile()</code>.
      *
      * @param filename a file name.
      *
      * @return an absolute file.
      * @throws java.lang.NullPointerException if filename is null.
      */
     public File resolveFile(File file, String filename) {
         if (!isAbsolutePath(filename)) {
             char sep = File.separatorChar;
             filename = filename.replace('/', sep).replace('\\', sep);
             if (isContextRelativePath(filename)) {
                 file = null;
                 // on cygwin, our current directory can be a UNC;
                 // assume user.dir is absolute or all hell breaks loose...
                 String udir = System.getProperty("user.dir");
                 if (filename.charAt(0) == sep && udir.charAt(0) == sep) {
                     filename = dissect(udir)[0] + filename.substring(1);
                 }
             }
             filename = new File(file, filename).getAbsolutePath();
         }
         return normalize(filename);
     }
 
     /**
      * On DOS and NetWare, the evaluation of certain file
      * specifications is context-dependent.  These are filenames
      * beginning with a single separator (relative to current root directory)
      * and filenames with a drive specification and no intervening separator
      * (relative to current directory of the specified root).
      * @param filename the filename to evaluate.
      * @return true if the filename is relative to system context.
      * @throws java.lang.NullPointerException if filename is null.
      * @since Ant 1.7
      */
     public static boolean isContextRelativePath(String filename) {
         if (!(ON_DOS || ON_NETWARE) || filename.length() == 0) {
             return false;
         }
         char sep = File.separatorChar;
         filename = filename.replace('/', sep).replace('\\', sep);
         char c = filename.charAt(0);
         int len = filename.length();
         return (c == sep && (len == 1 || filename.charAt(1) != sep))
                 || (Character.isLetter(c) && len > 1
                 && filename.indexOf(':') == 1
                 && (len == 2 || filename.charAt(2) != sep));
     }
 
     /**
      * Verifies that the specified filename represents an absolute path.
      * Differs from new java.io.File("filename").isAbsolute() in that a path
      * beginning with a double file separator--signifying a Windows UNC--must
      * at minimum match "\\a\b" to be considered an absolute path.
      * @param filename the filename to be checked.
      * @return true if the filename represents an absolute path.
      * @throws java.lang.NullPointerException if filename is null.
      * @since Ant 1.6.3
      */
     public static boolean isAbsolutePath(String filename) {
         int len = filename.length();
         if (len == 0) {
             return false;
         }
         char sep = File.separatorChar;
         filename = filename.replace('/', sep).replace('\\', sep);
         char c = filename.charAt(0);
         if (!(ON_DOS || ON_NETWARE)) {
             return (c == sep);
         }
         if (c == sep) {
             // CheckStyle:MagicNumber OFF
             if (!(ON_DOS && len > 4 && filename.charAt(1) == sep)) {
                 return false;
             }
             // CheckStyle:MagicNumber ON
             int nextsep = filename.indexOf(sep, 2);
             return nextsep > 2 && nextsep + 1 < len;
         }
         int colon = filename.indexOf(':');
         return (Character.isLetter(c) && colon == 1
                 && filename.length() > 2 && filename.charAt(2) == sep)
                 || (ON_NETWARE && colon > 0);
     }
 
     /**
      * Translate a path into its native (platform specific) format.
      * <p>
      * This method uses PathTokenizer to separate the input path
      * into its components. This handles DOS style paths in a relatively
      * sensible way. The file separators are then converted to their platform
      * specific versions.
      *
      * @param toProcess The path to be translated.
      *                  May be <code>null</code>.
      *
      * @return the native version of the specified path or
      *         an empty string if the path is <code>null</code> or empty.
      *
      * @since ant 1.7
      * @see PathTokenizer
      */
     public static String translatePath(String toProcess) {
         if (toProcess == null || toProcess.length() == 0) {
             return "";
         }
         StringBuffer path = new StringBuffer(toProcess.length() + EXPAND_SPACE);
         PathTokenizer tokenizer = new PathTokenizer(toProcess);
         while (tokenizer.hasMoreTokens()) {
             String pathComponent = tokenizer.nextToken();
             pathComponent = pathComponent.replace('/', File.separatorChar);
             pathComponent = pathComponent.replace('\\', File.separatorChar);
             if (path.length() != 0) {
                 path.append(File.pathSeparatorChar);
             }
             path.append(pathComponent);
         }
         return path.toString();
     }
 
     /**
      * &quot;Normalize&quot; the given absolute path.
      *
      * <p>This includes:
      * <ul>
      *   <li>Uppercase the drive letter if there is one.</li>
      *   <li>Remove redundant slashes after the drive spec.</li>
      *   <li>Resolve all ./, .\, ../ and ..\ sequences.</li>
      *   <li>DOS style paths that start with a drive letter will have
      *     \ as the separator.</li>
      * </ul>
      * Unlike {@link File#getCanonicalPath()} this method
      * specifically does not resolve symbolic links.
      *
      * @param path the path to be normalized.
      * @return the normalized version of the path.
      *
      * @throws java.lang.NullPointerException if path is null.
      */
     public File normalize(final String path) {
         Stack s = new Stack();
         String[] dissect = dissect(path);
         s.push(dissect[0]);
 
         StringTokenizer tok = new StringTokenizer(dissect[1], File.separator);
         while (tok.hasMoreTokens()) {
             String thisToken = tok.nextToken();
             if (".".equals(thisToken)) {
                 continue;
             }
             if ("..".equals(thisToken)) {
                 if (s.size() < 2) {
                     // Cannot resolve it, so skip it.
                     return new File(path);
                 }
                 s.pop();
             } else { // plain component
                 s.push(thisToken);
             }
         }
         StringBuffer sb = new StringBuffer();
         final int size = s.size();
         for (int i = 0; i < size; i++) {
             if (i > 1) {
                 // not before the filesystem root and not after it, since root
                 // already contains one
                 sb.append(File.separatorChar);
             }
             sb.append(s.elementAt(i));
         }
         return new File(sb.toString());
     }
 
     /**
      * Dissect the specified absolute path.
      * @param path the path to dissect.
      * @return String[] {root, remaining path}.
      * @throws java.lang.NullPointerException if path is null.
      * @since Ant 1.7
      */
     public String[] dissect(String path) {
         char sep = File.separatorChar;
         path = path.replace('/', sep).replace('\\', sep);
 
         // make sure we are dealing with an absolute path
         if (!isAbsolutePath(path)) {
             throw new BuildException(path + " is not an absolute path");
         }
         String root = null;
         int colon = path.indexOf(':');
         if (colon > 0 && (ON_DOS || ON_NETWARE)) {
 
             int next = colon + 1;
             root = path.substring(0, next);
             char[] ca = path.toCharArray();
             root += sep;
             //remove the initial separator; the root has it.
             next = (ca[next] == sep) ? next + 1 : next;
 
             StringBuffer sbPath = new StringBuffer();
             // Eliminate consecutive slashes after the drive spec:
             for (int i = next; i < ca.length; i++) {
                 if (ca[i] != sep || ca[i - 1] != sep) {
                     sbPath.append(ca[i]);
                 }
             }
             path = sbPath.toString();
         } else if (path.length() > 1 && path.charAt(1) == sep) {
             // UNC drive
             int nextsep = path.indexOf(sep, 2);
             nextsep = path.indexOf(sep, nextsep + 1);
             root = (nextsep > 2) ? path.substring(0, nextsep + 1) : path;
             path = path.substring(root.length());
         } else {
             root = File.separator;
             path = path.substring(1);
         }
         return new String[] {root, path};
     }
 
     /**
      * Returns a VMS String representation of a <code>File</code> object.
      * This is useful since the JVM by default internally converts VMS paths
      * to Unix style.
      * The returned String is always an absolute path.
      *
      * @param f The <code>File</code> to get the VMS path for.
      * @return The absolute VMS path to <code>f</code>.
      */
     public String toVMSPath(File f) {
         // format: "DEVICE:[DIR.SUBDIR]FILE"
         String osPath;
         String path = normalize(f.getAbsolutePath()).getPath();
         String name = f.getName();
         boolean isAbsolute = path.charAt(0) == File.separatorChar;
         // treat directories specified using .DIR syntax as files
         // CheckStyle:MagicNumber OFF
         boolean isDirectory = f.isDirectory()
                 && !name.regionMatches(true, name.length() - 4, ".DIR", 0, 4);
         // CheckStyle:MagicNumber ON
         String device = null;
         StringBuffer directory = null;
         String file = null;
 
         int index = 0;
 
         if (isAbsolute) {
             index = path.indexOf(File.separatorChar, 1);
             if (index == -1) {
                 return path.substring(1) + ":[000000]";
             }
             device = path.substring(1, index++);
         }
         if (isDirectory) {
             directory = new StringBuffer(path.substring(index).replace(File.separatorChar, '.'));
         } else {
             int dirEnd = path.lastIndexOf(File.separatorChar, path.length());
             if (dirEnd == -1 || dirEnd < index) {
                 file = path.substring(index);
             } else {
                 directory = new StringBuffer(path.substring(index, dirEnd).
                                              replace(File.separatorChar, '.'));
                 index = dirEnd + 1;
                 if (path.length() > index) {
                     file = path.substring(index);
                 }
             }
         }
         if (!isAbsolute && directory != null) {
             directory.insert(0, '.');
         }
         osPath = ((device != null) ? device + ":" : "")
                 + ((directory != null) ? "[" + directory + "]" : "")
                 + ((file != null) ? file : "");
         return osPath;
     }
 
     /**
      * Create a File object for a temporary file in a given directory. Without
      * actually creating the file.
      *
      * <p>
      * The file denoted by the returned abstract pathname did not exist before
      * this method was invoked, any subsequent invocation of this method will
      * yield a different file name.
      * </p>
      * <p>
      * The filename is prefixNNNNNsuffix where NNNN is a random number.
      * </p>
      *
      * @param prefix
      *            prefix before the random number.
      * @param suffix
      *            file extension; include the '.'.
      * @param parentDir
      *            Directory to create the temporary file in; java.io.tmpdir used
      *            if not specified.
      *
      * @deprecated since ant 1.7.1 use createTempFile(String, String, File,
      * boolean, boolean) instead.
      * @return a File reference to the new, nonexistent temporary file.
      */
     public File createTempFile(String prefix, String suffix, File parentDir) {
         return createTempFile(prefix, suffix, parentDir, false, false);
     }
 
     private static final String NULL_PLACEHOLDER = "null";
 
     /**
      * Create a temporary file in a given directory.
      *
      * <p>The file denoted by the returned abstract pathname did not
      * exist before this method was invoked, any subsequent invocation
      * of this method will yield a different file name.</p>
      *
      * @param prefix prefix before the random number.
      * @param suffix file extension; include the '.'.
      * @param parentDir Directory to create the temporary file in;
      * java.io.tmpdir used if not specified.
      * @param deleteOnExit whether to set the tempfile for deletion on
      *        normal VM exit.
      * @param createFile true if the file must actually be created. If false
      * chances exist that a file with the same name is created in the time
      * between invoking this method and the moment the file is actually created.
      * If possible set to true.
      *
      * @return a File reference to the new temporary file.
      * @since Ant 1.7.1
      */
     public File createTempFile(String prefix, String suffix, File parentDir,
             boolean deleteOnExit, boolean createFile) {
         File result = null;
         String parent = (parentDir == null)
                 ? System.getProperty("java.io.tmpdir")
                 : parentDir.getPath();
         if (prefix == null) {
             prefix = NULL_PLACEHOLDER;
         }
         if (suffix == null) {
             suffix = NULL_PLACEHOLDER;
         }
 
         if (createFile) {
             try {
                 result = File.createTempFile(prefix, suffix, new File(parent));
             } catch (IOException e) {
                 throw new BuildException("Could not create tempfile in "
                         + parent, e);
             }
         } else {
             DecimalFormat fmt = new DecimalFormat("#####");
             synchronized (rand) {
                 do {
                     result = new File(parent, prefix
                             + fmt.format(rand.nextInt(Integer.MAX_VALUE)) + suffix);
                 } while (result.exists());
             }
         }
 
         if (deleteOnExit) {
             result.deleteOnExit();
         }
         return result;
     }
 
     /**
      * Create a File object for a temporary file in a given directory. Without
      * actually creating the file.
      *
      * <p>
      * The file denoted by the returned abstract pathname did not exist before
      * this method was invoked, any subsequent invocation of this method will
      * yield a different file name.
      * </p>
      * <p>
      * The filename is prefixNNNNNsuffix where NNNN is a random number.
      * </p>
      *
      * @param prefix
      *            prefix before the random number.
      * @param suffix
      *            file extension; include the '.'.
      * @param parentDir
      *            Directory to create the temporary file in; java.io.tmpdir used
      *            if not specified.
      * @param deleteOnExit
      *            whether to set the tempfile for deletion on normal VM exit.
      *
      * @deprecated since ant 1.7.1 use createTempFile(String, String, File,
      * boolean, boolean) instead.
      * @return a File reference to the new, nonexistent temporary file.
      */
     public File createTempFile(String prefix, String suffix,
             File parentDir, boolean deleteOnExit) {
         return createTempFile(prefix, suffix, parentDir, deleteOnExit, false);
     }
 
     /**
      * Compares the contents of two files.
      *
      * @param f1 the file whose content is to be compared.
      * @param f2 the other file whose content is to be compared.
      *
      * @return true if the content of the files is the same.
      *
      * @throws IOException if the files cannot be read.
      */
     public boolean contentEquals(File f1, File f2) throws IOException {
         return contentEquals(f1, f2, false);
     }
 
     /**
      * Compares the contents of two files.
      *
      * @param f1 the file whose content is to be compared.
      * @param f2 the other file whose content is to be compared.
      * @param textfile true if the file is to be treated as a text file and
      *        differences in kind of line break are to be ignored.
      *
      * @return true if the content of the files is the same.
      *
      * @throws IOException if the files cannot be read.
      * @since Ant 1.6.3
      */
     public boolean contentEquals(File f1, File f2, boolean textfile) throws IOException {
         return ResourceUtils.contentEquals(new FileResource(f1), new FileResource(f2), textfile);
     }
 
     /**
      * This was originally an emulation of {@link File#getParentFile} for JDK 1.1, but it is now
      * implemented using that method (Ant 1.6.3 onwards).
      *
      * @param f the file whose parent is required.
      * @return the given file's parent, or null if the file does not have a parent.
      * @since 1.10
      * @deprecated since 1.7. Just use {@link File#getParentFile} directly.
      */
     public File getParentFile(File f) {
         return (f == null) ? null : f.getParentFile();
     }
 
     /**
      * Read from reader till EOF.
      * @param rdr the reader from which to read.
      * @return the contents read out of the given reader.
      *
      * @throws IOException if the contents could not be read out from the
      *         reader.
      */
     public static String readFully(Reader rdr) throws IOException {
         return readFully(rdr, BUF_SIZE);
     }
 
     /**
      * Read from reader till EOF.
      *
      * @param rdr the reader from which to read.
      * @param bufferSize the buffer size to use when reading.
      *
      * @return the contents read out of the given reader.
      *
      * @throws IOException if the contents could not be read out from the
      *         reader.
      */
     public static String readFully(Reader rdr, int bufferSize)
         throws IOException {
         if (bufferSize <= 0) {
             throw new IllegalArgumentException("Buffer size must be greater "
                                                + "than 0");
         }
         final char[] buffer = new char[bufferSize];
         int bufferLength = 0;
         StringBuffer textBuffer = null;
         while (bufferLength != -1) {
             bufferLength = rdr.read(buffer);
             if (bufferLength > 0) {
                 textBuffer = (textBuffer == null) ? new StringBuffer() : textBuffer;
                 textBuffer.append(new String(buffer, 0, bufferLength));
             }
         }
         return (textBuffer == null) ? null : textBuffer.toString();
     }
 
     /**
      * Safe read fully - do not return a null for an empty reader.
      * @param reader the input to read from.
      * @return the string.
      * @throws IOException if unable to read from reader.
      * @since Ant 1.7.1
      */
     public static String safeReadFully(Reader reader) throws IOException {
         String ret = readFully(reader);
         return ret == null ? "" : ret;
     }
 
     /**
      * This was originally an emulation of File.createNewFile for JDK 1.1,
      * but it is now implemented using that method (Ant 1.6.3 onwards).
      *
      * <p>This method has historically <strong>not</strong> guaranteed that the
      * operation was atomic. In its current implementation it is.
      *
      * @param f the file to be created.
      * @return true if the file did not exist already.
      * @throws IOException on error.
      * @since Ant 1.5
      */
     public boolean createNewFile(File f) throws IOException {
         return f.createNewFile();
     }
 
     /**
      * Create a new file, optionally creating parent directories.
      *
      * @param f the file to be created.
      * @param mkdirs <code>boolean</code> whether to create parent directories.
      * @return true if the file did not exist already.
      * @throws IOException on error.
      * @since Ant 1.6.3
      */
     public boolean createNewFile(File f, boolean mkdirs) throws IOException {
         File parent = f.getParentFile();
         if (mkdirs && !(parent.exists())) {
             parent.mkdirs();
         }
         return f.createNewFile();
     }
 
     /**
      * Checks whether a given file is a symbolic link.
      *
      * <p>It doesn't really test for symbolic links but whether the
      * canonical and absolute paths of the file are identical--this
      * may lead to false positives on some platforms.</p>
      *
      * @param parent the parent directory of the file to test
      * @param name the name of the file to test.
      *
      * @return true if the file is a symbolic link.
      * @throws IOException on error.
      * @since Ant 1.5
      * @deprecated use SymbolicLinkUtils instead
      */
     public boolean isSymbolicLink(File parent, String name)
         throws IOException {
         SymbolicLinkUtils u = SymbolicLinkUtils.getSymbolicLinkUtils();
         if (parent == null) {
             return u.isSymbolicLink(name);
         }
         return u.isSymbolicLink(parent, name);
     }
 
     /**
      * Removes a leading path from a second path.
      *
      * @param leading The leading path, must not be null, must be absolute.
      * @param path The path to remove from, must not be null, must be absolute.
      *
      * @return path's normalized absolute if it doesn't start with
      * leading; path's path with leading's path removed otherwise.
      *
      * @since Ant 1.5
      */
     public String removeLeadingPath(File leading, File path) {
         String l = normalize(leading.getAbsolutePath()).getAbsolutePath();
         String p = normalize(path.getAbsolutePath()).getAbsolutePath();
         if (l.equals(p)) {
             return "";
         }
         // ensure that l ends with a /
         // so we never think /foo was a parent directory of /foobar
         if (!l.endsWith(File.separator)) {
             l += File.separator;
         }
         return (p.startsWith(l)) ? p.substring(l.length()) : p;
     }
 
     /**
      * Learn whether one path "leads" another.
      * @param leading The leading path, must not be null, must be absolute.
      * @param path The path to remove from, must not be null, must be absolute.
      * @return true if path starts with leading; false otherwise.
      * @since Ant 1.7
      */
     public boolean isLeadingPath(File leading, File path) {
         String l = normalize(leading.getAbsolutePath()).getAbsolutePath();
         String p = normalize(path.getAbsolutePath()).getAbsolutePath();
         if (l.equals(p)) {
             return true;
         }
         // ensure that l ends with a /
         // so we never think /foo was a parent directory of /foobar
         if (!l.endsWith(File.separator)) {
             l += File.separator;
         }
         return p.startsWith(l);
     }
 
     /**
      * Constructs a <code>file:</code> URI that represents the
      * external form of the given pathname.
      *
      * <p>Will be an absolute URI if the given path is absolute.</p>
      *
      * <p>This code encodes non ASCII characters too.</p>
      *
      * <p>The coding of the output is the same as what File.toURI().toASCIIString() produces</p>
      *
      * See <a href="http://www.w3.org/TR/xml11/#dt-sysid">dt-sysid</a>
      * which makes some mention of how
      * characters not supported by URI Reference syntax should be escaped.
      *
      * @param path the path in the local file system.
      * @return the URI version of the local path.
      * @since Ant 1.6
      */
     public String toURI(String path) {
         return new File(path).toURI().toASCIIString();
     }
 
     /**
      * Constructs a file path from a <code>file:</code> URI.
      *
      * <p>Will be an absolute path if the given URI is absolute.</p>
      *
      * <p>Swallows '%' that are not followed by two characters,
      * doesn't deal with non-ASCII characters.</p>
      *
      * @param uri the URI designating a file in the local filesystem.
      * @return the local file system path for the file.
      * @since Ant 1.6
      */
     public String fromURI(String uri) {
         synchronized (cacheFromUriLock) {
             if (uri.equals(cacheFromUriRequest)) {
                 return cacheFromUriResponse;
             }
             String path = Locator.fromURI(uri);
             String ret = isAbsolutePath(path) ? normalize(path).getAbsolutePath() : path;
             cacheFromUriRequest = uri;
             cacheFromUriResponse = ret;
             return ret;
         }
     }
 
     /**
      * Compares two filenames.
      *
      * <p>Unlike java.io.File#equals this method will try to compare
      * the absolute paths and &quot;normalize&quot; the filenames
      * before comparing them.</p>
      *
      * @param f1 the file whose name is to be compared.
      * @param f2 the other file whose name is to be compared.
      *
      * @return true if the file are for the same file.
      *
      * @since Ant 1.5.3
      */
     public boolean fileNameEquals(File f1, File f2) {
         return normalize(f1.getAbsolutePath()).getAbsolutePath().equals(
                 normalize(f2.getAbsolutePath()).getAbsolutePath());
     }
 
     /**
      * Are the two File instances pointing to the same object on the
      * file system?
      * @since Ant 1.8.2
      */
     public boolean areSame(File f1, File f2) throws IOException {
         if (f1 == null && f2 == null) {
             return true;
         }
         if (f1 == null || f2 == null) {
             return false;
         }
         File f1Normalized = normalize(f1.getAbsolutePath());
         File f2Normalized = normalize(f2.getAbsolutePath());
         return f1Normalized.equals(f2Normalized)
             || f1Normalized.getCanonicalFile().equals(f2Normalized
                                                       .getCanonicalFile());
     }
 
     /**
      * Renames a file, even if that involves crossing file system boundaries.
      *
      * <p>This will remove <code>to</code> (if it exists), ensure that
      * <code>to</code>'s parent directory exists and move
      * <code>from</code>, which involves deleting <code>from</code> as
      * well.</p>
      *
      * @param from the file to move.
      * @param to the new file name.
      *
      * @throws IOException if anything bad happens during this
      * process.  Note that <code>to</code> may have been deleted
      * already when this happens.
      *
      * @since Ant 1.6
      */
     public void rename(File from, File to) throws IOException {
         // identical logic lives in Move.renameFile():
         from = normalize(from.getAbsolutePath()).getCanonicalFile();
         to = normalize(to.getAbsolutePath());
         if (!from.exists()) {
             System.err.println("Cannot rename nonexistent file " + from);
             return;
         }
         if (from.getAbsolutePath().equals(to.getAbsolutePath())) {
             System.err.println("Rename of " + from + " to " + to + " is a no-op.");
             return;
         }
         if (to.exists() && !(areSame(from, to) || tryHardToDelete(to))) {
             throw new IOException("Failed to delete " + to + " while trying to rename " + from);
         }
         File parent = to.getParentFile();
-        if (parent != null && !parent.exists() && !parent.mkdirs()) {
+        if (parent != null && !parent.isDirectory()
+            && !(parent.mkdirs() || parent.isDirectory())) {
             throw new IOException("Failed to create directory " + parent
                                   + " while trying to rename " + from);
         }
         if (!from.renameTo(to)) {
             copyFile(from, to);
             if (!tryHardToDelete(from)) {
                 throw new IOException("Failed to delete " + from + " while trying to rename it.");
             }
         }
     }
 
     /**
      * Get the granularity of file timestamps. The choice is made based on OS, which is
      * incorrect--it should really be by filesystem. We do not have an easy way to probe for file
      * systems, however, so this heuristic gives us a decent default.
      *
      * @return the difference, in milliseconds, which two file timestamps must have in order for the
      *         two files to be considered to have different timestamps.
      */
     public long getFileTimestampGranularity() {
         if (ON_WIN9X) {
             return FAT_FILE_TIMESTAMP_GRANULARITY;
         }
         if (ON_WINDOWS) {
             return NTFS_FILE_TIMESTAMP_GRANULARITY;
         }
         if (ON_DOS) {
             return FAT_FILE_TIMESTAMP_GRANULARITY;
         }
         return UNIX_FILE_TIMESTAMP_GRANULARITY;
     }
 
     /**
      * test whether a file or directory exists, with an error in the
      * upper/lower case spelling of the name.
      * Using this method is only interesting on case insensitive file systems
      * (Windows).<br/>
      * It will return true only if 3 conditions are met :
      * <br/>
      * <ul>
      *   <li>operating system is case insensitive</li>
      *   <li>file exists</li>
      *   <li>actual name from directory reading is different from the
      *       supplied argument</li>
      * </ul>
      *  <br/>
      * the purpose is to identify files or directories on case-insensitive
      * filesystems whose case is not what is expected.<br/>
      * Possibly to rename them afterwards to the desired upper/lowercase
      * combination.
      * <br/>
      * @param localFile file to test
      * @return true if the file exists and the case of the actual file
      *              is not the case of the parameter
      * @since Ant 1.7.1
      */
     public boolean hasErrorInCase(File localFile) {
         localFile = normalize(localFile.getAbsolutePath());
         if (!localFile.exists()) {
             return false;
         }
         final String localFileName = localFile.getName();
         FilenameFilter ff = new FilenameFilter () {
             public boolean accept(File dir, String name) {
                 return name.equalsIgnoreCase(localFileName) && (!name.equals(localFileName));
             }
         };
         String[] names = localFile.getParentFile().list(ff);
         return names != null && names.length == 1;
     }
 
     /**
      * Returns true if the source is older than the dest.
      * If the dest file does not exist, then the test returns false; it is
      * implicitly not up do date.
      * @param source source file (should be the older).
      * @param dest dest file (should be the newer).
      * @param granularity an offset added to the source time.
      * @return true if the source is older than the dest after accounting
      *              for granularity.
      * @since Ant 1.6.3
      */
     public boolean isUpToDate(File source, File dest, long granularity) {
         //do a check for the destination file existing
         if (!dest.exists()) {
             //if it does not, then the file is not up to date.
             return false;
         }
         long sourceTime = source.lastModified();
         long destTime = dest.lastModified();
         return isUpToDate(sourceTime, destTime, granularity);
     }
 
     /**
      * Returns true if the source is older than the dest.
      * @param source source file (should be the older).
      * @param dest dest file (should be the newer).
      * @return true if the source is older than the dest, taking the granularity into account.
      * @since Ant 1.6.3
      */
     public boolean isUpToDate(File source, File dest) {
         return isUpToDate(source, dest, getFileTimestampGranularity());
     }
 
     /**
      * Compare two timestamps for being up to date using
      * the specified granularity.
      *
      * @param sourceTime timestamp of source file.
      * @param destTime timestamp of dest file.
      * @param granularity os/filesys granularity.
      * @return true if the dest file is considered up to date.
      */
     public boolean isUpToDate(long sourceTime, long destTime, long granularity) {
         return destTime != -1 && destTime >= sourceTime + granularity;
     }
 
     /**
      * Compare two timestamps for being up to date using the
      * current granularity.
      *
      * @param sourceTime  timestamp of source file.
      * @param destTime    timestamp of dest file.
      * @return true if the dest file is considered up to date.
      */
     public boolean isUpToDate(long sourceTime, long destTime) {
         return isUpToDate(sourceTime, destTime, getFileTimestampGranularity());
     }
 
     /**
      * Close a Writer without throwing any exception if something went wrong.
      * Do not attempt to close it if the argument is null.
      * @param device output writer, can be null.
      */
     public static void close(Writer device) {
         if (null != device) {
             try {
                 device.close();
             } catch (IOException e) {
                 //ignore
             }
         }
     }
 
     /**
      * Close a Reader without throwing any exception if something went wrong.
      * Do not attempt to close it if the argument is null.
      *
      * @param device Reader, can be null.
      */
     public static void close(Reader device) {
         if (null != device) {
             try {
                 device.close();
             } catch (IOException e) {
                 //ignore
             }
         }
     }
 
     /**
      * Close a stream without throwing any exception if something went wrong.
      * Do not attempt to close it if the argument is null.
      *
      * @param device stream, can be null.
      */
     public static void close(OutputStream device) {
         if (null != device) {
             try {
                 device.close();
             } catch (IOException e) {
                 //ignore
             }
         }
     }
 
     /**
      * Close a stream without throwing any exception if something went wrong.
      * Do not attempt to close it if the argument is null.
      *
      * @param device stream, can be null.
      */
     public static void close(InputStream device) {
         if (null != device) {
             try {
                 device.close();
             } catch (IOException e) {
                 //ignore
             }
         }
     }
 
     /**
      * Close a Channel without throwing any exception if something went wrong.
      * Do not attempt to close it if the argument is null.
      *
      * @param device channel, can be null.
      * @since Ant 1.8.0
      */
     public static void close(Channel device) {
         if (null != device) {
             try {
                 device.close();
             } catch (IOException e) {
                 //ignore
             }
         }
     }
 
     /**
      * Closes an URLConnection if its concrete implementation provides
      * a way to close it that Ant knows of.
      *
      * @param conn connection, can be null
      * @since Ant 1.8.0
      */
     public static void close(URLConnection conn) {
         if (conn != null) {
             try {
                 if (conn instanceof JarURLConnection) {
                     JarURLConnection juc = (JarURLConnection) conn;
                     JarFile jf = juc.getJarFile();
                     jf.close();
                     jf = null;
                 } else if (conn instanceof HttpURLConnection) {
                     ((HttpURLConnection) conn).disconnect();
                 }
             } catch (IOException exc) {
                 //ignore
             }
         }
     }
 
     /**
      * Delete the file with {@link File#delete()} if the argument is not null.
      * Do nothing on a null argument.
      * @param file file to delete.
      */
     public static void delete(File file) {
         if (file != null) {
             file.delete();
         }
     }
 
     /**
      * Accommodate Windows bug encountered in both Sun and IBM JDKs.
      * Others possible. If the delete does not work, call System.gc(),
      * wait a little and try again.
      *
      * @return whether deletion was successful
      * @since Ant 1.8.0
      */
     public boolean tryHardToDelete(File f) {
         return tryHardToDelete(f, ON_WINDOWS);
     }
 
     /**
      * If delete does not work, call System.gc() if asked to, wait a
      * little and try again.
      *
      * @return whether deletion was successful
      * @since Ant 1.8.3
      */
     public boolean tryHardToDelete(File f, boolean runGC) {
         if (!f.delete()) {
             if (runGC) {
                 System.gc();
             }
             try {
                 Thread.sleep(DELETE_RETRY_SLEEP_MILLIS);
             } catch (InterruptedException ex) {
                 // Ignore Exception
             }
             return f.delete();
         }
         return true;
     }
 
     /**
      * Calculates the relative path between two files.
      * <p>
      * Implementation note:<br/> This function may throw an IOException if an I/O error occurs
      * because its use of the canonical pathname may require filesystem queries.
      * </p>
      *
      * @param fromFile the <code>File</code> to calculate the path from
      * @param toFile the <code>File</code> to calculate the path to
      * @return the relative path between the files
      * @throws Exception for undocumented reasons
      * @see File#getCanonicalPath()
      *
      * @since Ant 1.7
      */
     public static String getRelativePath(File fromFile, File toFile) throws Exception {
         String fromPath = fromFile.getCanonicalPath();
         String toPath = toFile.getCanonicalPath();
 
         // build the path stack info to compare
         String[] fromPathStack = getPathStack(fromPath);
         String[] toPathStack = getPathStack(toPath);
 
         if (0 < toPathStack.length && 0 < fromPathStack.length) {
             if (!fromPathStack[0].equals(toPathStack[0])) {
                 // not the same device (would be "" on Linux/Unix)
 
                 return getPath(Arrays.asList(toPathStack));
             }
         } else {
             // no comparison possible
             return getPath(Arrays.asList(toPathStack));
         }
 
         int minLength = Math.min(fromPathStack.length, toPathStack.length);
         int same = 1; // Used outside the for loop
 
         // get index of parts which are equal
         for (;
              same < minLength && fromPathStack[same].equals(toPathStack[same]);
              same++) {
             // Do nothing
         }
 
         List relativePathStack = new ArrayList();
 
         // if "from" part is longer, fill it up with ".."
         // to reach path which is equal to both paths
         for (int i = same; i < fromPathStack.length; i++) {
             relativePathStack.add("..");
         }
 
         // fill it up path with parts which were not equal
         for (int i = same; i < toPathStack.length; i++) {
             relativePathStack.add(toPathStack[i]);
         }
 
         return getPath(relativePathStack);
     }
 
     /**
      * Gets all names of the path as an array of <code>String</code>s.
      *
      * @param path to get names from
      * @return <code>String</code>s, never <code>null</code>
      *
      * @since Ant 1.7
      */
     public static String[] getPathStack(String path) {
         String normalizedPath = path.replace(File.separatorChar, '/');
 
         return normalizedPath.split("/");
     }
 
     /**
      * Gets path from a <code>List</code> of <code>String</code>s.
      *
      * @param pathStack <code>List</code> of <code>String</code>s to be concatenated as a path.
      * @return <code>String</code>, never <code>null</code>
      *
      * @since Ant 1.7
      */
     public static String getPath(List pathStack) {
         // can safely use '/' because Windows understands '/' as separator
         return getPath(pathStack, '/');
     }
 
     /**
      * Gets path from a <code>List</code> of <code>String</code>s.
      *
      * @param pathStack <code>List</code> of <code>String</code>s to be concated as a path.
      * @param separatorChar <code>char</code> to be used as separator between names in path
      * @return <code>String</code>, never <code>null</code>
      *
      * @since Ant 1.7
      */
     public static String getPath(final List pathStack, final char separatorChar) {
         final StringBuffer buffer = new StringBuffer();
 
         final Iterator iter = pathStack.iterator();
         if (iter.hasNext()) {
             buffer.append(iter.next());
         }
         while (iter.hasNext()) {
             buffer.append(separatorChar);
             buffer.append(iter.next());
         }
         return buffer.toString();
     }
 
     /**
      * Get the default encoding.
      * This is done by opening an InputStreamReader on
      * a dummy InputStream and getting the encoding.
      * Could use System.getProperty("file.encoding"), but cannot
      * see where this is documented.
      * @return the default file encoding.
      */
     public String getDefaultEncoding() {
         InputStreamReader is = new InputStreamReader(
             new InputStream() {
                 public int read() {
                     return -1;
                 }
             });
         try {
             return is.getEncoding();
         } finally {
             close(is);
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/util/ResourceUtils.java b/src/main/org/apache/tools/ant/util/ResourceUtils.java
index 7b6bc2557..e4562db55 100644
--- a/src/main/org/apache/tools/ant/util/ResourceUtils.java
+++ b/src/main/org/apache/tools/ant/util/ResourceUtils.java
@@ -1,788 +1,788 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.util;
 
 import java.io.BufferedInputStream;
 import java.io.BufferedReader;
 import java.io.BufferedWriter;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.OutputStream;
 import java.io.OutputStreamWriter;
 import java.io.Reader;
 import java.nio.channels.FileChannel;
 import java.util.Arrays;
 import java.util.Iterator;
 import java.util.Vector;
 
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.ProjectComponent;
 import org.apache.tools.ant.filters.util.ChainReaderHelper;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.TimeComparison;
 import org.apache.tools.ant.types.ResourceFactory;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.FilterSetCollection;
 import org.apache.tools.ant.types.resources.Appendable;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.FileResource;
 import org.apache.tools.ant.types.resources.Union;
 import org.apache.tools.ant.types.resources.Restrict;
 import org.apache.tools.ant.types.resources.Resources;
 import org.apache.tools.ant.types.resources.StringResource;
 import org.apache.tools.ant.types.resources.Touchable;
 import org.apache.tools.ant.types.resources.selectors.Date;
 import org.apache.tools.ant.types.resources.selectors.ResourceSelector;
 import org.apache.tools.ant.types.selectors.SelectorUtils;
 
 // CheckStyle:HideUtilityClassConstructorCheck OFF - bc
 
 /**
  * This class provides utility methods to process Resources.
  *
  * @since Ant 1.5.2
  */
 public class ResourceUtils {
 
     /** Utilities used for file operations */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * Name of charset "ISO Latin Alphabet No. 1, a.k.a. ISO-LATIN-1".
      *
      * @since Ant 1.8.1
      */
     public static final String ISO_8859_1 = "ISO-8859-1";
 
     private static final long MAX_IO_CHUNK_SIZE = 16*1024*1024; // 16 MB
 
     /**
      * Tells which source files should be reprocessed based on the
      * last modification date of target files.
      * @param logTo where to send (more or less) interesting output.
      * @param source array of resources bearing relative path and last
      * modification date.
      * @param mapper filename mapper indicating how to find the target
      * files.
      * @param targets object able to map as a resource a relative path
      * at <b>destination</b>.
      * @return array containing the source files which need to be
      * copied or processed, because the targets are out of date or do
      * not exist.
      */
     public static Resource[] selectOutOfDateSources(ProjectComponent logTo,
                                                     Resource[] source,
                                                     FileNameMapper mapper,
                                                     ResourceFactory targets) {
         return selectOutOfDateSources(logTo, source, mapper, targets,
                                       FILE_UTILS.getFileTimestampGranularity());
     }
 
     /**
      * Tells which source files should be reprocessed based on the
      * last modification date of target files.
      * @param logTo where to send (more or less) interesting output.
      * @param source array of resources bearing relative path and last
      * modification date.
      * @param mapper filename mapper indicating how to find the target
      * files.
      * @param targets object able to map as a resource a relative path
      * at <b>destination</b>.
      * @param granularity The number of milliseconds leeway to give
      * before deciding a target is out of date.
      * @return array containing the source files which need to be
      * copied or processed, because the targets are out of date or do
      * not exist.
      * @since Ant 1.6.2
      */
     public static Resource[] selectOutOfDateSources(ProjectComponent logTo,
                                                     Resource[] source,
                                                     FileNameMapper mapper,
                                                     ResourceFactory targets,
                                                     long granularity) {
         Union u = new Union();
         u.addAll(Arrays.asList(source));
         ResourceCollection rc
             = selectOutOfDateSources(logTo, u, mapper, targets, granularity);
         return rc.size() == 0 ? new Resource[0] : ((Union) rc).listResources();
     }
 
     /**
      * Tells which sources should be reprocessed based on the
      * last modification date of targets.
      * @param logTo where to send (more or less) interesting output.
      * @param source ResourceCollection.
      * @param mapper filename mapper indicating how to find the target Resources.
      * @param targets object able to map a relative path as a Resource.
      * @param granularity The number of milliseconds leeway to give
      * before deciding a target is out of date.
      * @return ResourceCollection.
      * @since Ant 1.7
      */
     public static ResourceCollection selectOutOfDateSources(ProjectComponent logTo,
                                                             ResourceCollection source,
                                                             FileNameMapper mapper,
                                                             ResourceFactory targets,
                                                             final long granularity) {
         logFuture(logTo, source, granularity);
         ResourceSelectorProvider p = 
             new ResourceSelectorProvider() {
                 public ResourceSelector
                     getTargetSelectorForSource(final Resource sr) {
                     return new ResourceSelector() {
                         public boolean isSelected(Resource target) {
                             /* Extra I/O, probably wasted:
                                if (target.isDirectory()) {
                                return false;
                                }
                             */
                             return SelectorUtils.isOutOfDate(sr, target,
                                                              granularity);
                         }
                     };
                 }
             };
         return selectSources(logTo, source, mapper, targets, p);
     }
 
     /**
      * Tells which sources should be reprocessed because the given
      * selector selects at least one target.
      * 
      * @param logTo where to send (more or less) interesting output.
      * @param source ResourceCollection.
      * @param mapper filename mapper indicating how to find the target Resources.
      * @param targets object able to map a relative path as a Resource.
      * @param selector returns a selector that is applied to target
      * files.  If it selects at least one target the source will be
      * added to the returned collection.
      * @return ResourceCollection.
      * @since Ant 1.8.0
      */
     public static ResourceCollection selectSources(ProjectComponent logTo,
                                                    ResourceCollection source,
                                                    FileNameMapper mapper,
                                                    ResourceFactory targets,
                                                    ResourceSelectorProvider selector) {
         if (source.size() == 0) {
             logTo.log("No sources found.", Project.MSG_VERBOSE);
             return Resources.NONE;
         }
         source = Union.getInstance(source);
 
         Union result = new Union();
         for (Resource sr : source) {
             String srName = sr.getName();
             srName = srName == null
                 ? srName : srName.replace('/', File.separatorChar);
 
             String[] targetnames = null;
             try {
                 targetnames = mapper.mapFileName(srName);
             } catch (Exception e) {
                 logTo.log("Caught " + e + " mapping resource " + sr,
                     Project.MSG_VERBOSE);
             }
             if (targetnames == null || targetnames.length == 0) {
                 logTo.log(sr + " skipped - don\'t know how to handle it",
                       Project.MSG_VERBOSE);
                 continue;
             }
             for (int i = 0; i < targetnames.length; i++) {
                 if (targetnames[i] == null) {
                     targetnames[i] = "(no name)";
                 }
             }
             Union targetColl = new Union();
             for (int i = 0; i < targetnames.length; i++) {
                 targetColl.add(targets.getResource(
                     targetnames[i].replace(File.separatorChar, '/')));
             }
             //find the out-of-date targets:
             Restrict r = new Restrict();
             r.add(selector.getTargetSelectorForSource(sr));
             r.add(targetColl);
             if (r.size() > 0) {
                 result.add(sr);
                 Resource t = r.iterator().next();
                 logTo.log(sr.getName() + " added as " + t.getName()
                     + (t.isExists() ? " is outdated." : " doesn\'t exist."),
                     Project.MSG_VERBOSE);
                 continue;
             }
             //log uptodateness of all targets:
             logTo.log(sr.getName()
                   + " omitted as " + targetColl.toString()
                   + (targetColl.size() == 1 ? " is" : " are ")
                   + " up to date.", Project.MSG_VERBOSE);
         }
         return result;
     }
 
     /**
      * Convenience method to copy content from one Resource to another.
      * No filtering is performed.
      *
      * @param source the Resource to copy from.
      *                   Must not be <code>null</code>.
      * @param dest   the Resource to copy to.
      *                 Must not be <code>null</code>.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.7
      */
     public static void copyResource(Resource source, Resource dest) throws IOException {
         copyResource(source, dest, null);
     }
 
     /**
      * Convenience method to copy content from one Resource to another.
      * No filtering is performed.
      *
      * @param source the Resource to copy from.
      *                   Must not be <code>null</code>.
      * @param dest   the Resource to copy to.
      *                 Must not be <code>null</code>.
      * @param project the project instance.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.7
      */
     public static void copyResource(Resource source, Resource dest, Project project)
         throws IOException {
         copyResource(source, dest, null, null, false,
                      false, null, null, project);
     }
 
     // CheckStyle:ParameterNumberCheck OFF - bc
     /**
      * Convenience method to copy content from one Resource to another
      * specifying whether token filtering must be used, whether filter chains
      * must be used, whether newer destination files may be overwritten and
      * whether the last modified time of <code>dest</code> file should be made
      * equal to the last modified time of <code>source</code>.
      *
      * @param source the Resource to copy from.
      *                   Must not be <code>null</code>.
      * @param dest   the Resource to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination Resource should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the destination Resource should be set to that
      *                             of the source.
      * @param inputEncoding the encoding used to read the files.
      * @param outputEncoding the encoding used to write the files.
      * @param project the project instance.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.7
      */
     public static void copyResource(Resource source, Resource dest,
                              FilterSetCollection filters, Vector filterChains,
                              boolean overwrite, boolean preserveLastModified,
                              String inputEncoding, String outputEncoding,
                              Project project)
         throws IOException {
         copyResource(source, dest, filters, filterChains, overwrite, preserveLastModified, false, inputEncoding, outputEncoding, project);
     }
 
     // CheckStyle:ParameterNumberCheck OFF - bc
     /**
      * Convenience method to copy content from one Resource to another
      * specifying whether token filtering must be used, whether filter chains
      * must be used, whether newer destination files may be overwritten and
      * whether the last modified time of <code>dest</code> file should be made
      * equal to the last modified time of <code>source</code>.
      *
      * @param source the Resource to copy from.
      *                   Must not be <code>null</code>.
      * @param dest   the Resource to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination Resource should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the destination Resource should be set to that
      *                             of the source.
      * @param append Whether to append to an Appendable Resource.
      * @param inputEncoding the encoding used to read the files.
      * @param outputEncoding the encoding used to write the files.
      * @param project the project instance.
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.8
      */
     public static void copyResource(Resource source, Resource dest,
                             FilterSetCollection filters, Vector filterChains,
                             boolean overwrite, boolean preserveLastModified,
                                     boolean append,
                             String inputEncoding, String outputEncoding,
                             Project project)
         throws IOException {
         copyResource(source, dest, filters, filterChains, overwrite,
                      preserveLastModified, append, inputEncoding,
                      outputEncoding, project, /* force: */ false);
     }
 
     /**
      * Convenience method to copy content from one Resource to another
      * specifying whether token filtering must be used, whether filter chains
      * must be used, whether newer destination files may be overwritten and
      * whether the last modified time of <code>dest</code> file should be made
      * equal to the last modified time of <code>source</code>.
      *
      * @param source the Resource to copy from.
      *                   Must not be <code>null</code>.
      * @param dest   the Resource to copy to.
      *                 Must not be <code>null</code>.
      * @param filters the collection of filters to apply to this copy.
      * @param filterChains filterChains to apply during the copy.
      * @param overwrite Whether or not the destination Resource should be
      *                  overwritten if it already exists.
      * @param preserveLastModified Whether or not the last modified time of
      *                             the destination Resource should be set to that
      *                             of the source.
      * @param append Whether to append to an Appendable Resource.
      * @param inputEncoding the encoding used to read the files.
      * @param outputEncoding the encoding used to write the files.
      * @param project the project instance.
      * @param force whether read-only target files will be overwritten
      *
      * @throws IOException if the copying fails.
      *
      * @since Ant 1.8.2
      */
     public static void copyResource(Resource source, Resource dest,
                             FilterSetCollection filters, Vector filterChains,
                             boolean overwrite, boolean preserveLastModified,
                                     boolean append,
                                     String inputEncoding, String outputEncoding,
                                     Project project, boolean force)
         throws IOException {
         if (!(overwrite || SelectorUtils.isOutOfDate(source, dest, FileUtils.getFileUtils()
                 .getFileTimestampGranularity()))) {
             return;
         }
         final boolean filterSetsAvailable = (filters != null
                                              && filters.hasFilters());
         final boolean filterChainsAvailable = (filterChains != null
                                                && filterChains.size() > 0);
         String effectiveInputEncoding = null;
         if (source instanceof StringResource) {
              effectiveInputEncoding = ((StringResource) source).getEncoding();
         } else {
             effectiveInputEncoding = inputEncoding;
         }
         File destFile = null;
         if (dest.as(FileProvider.class) != null) {
             destFile = dest.as(FileProvider.class).getFile();
         }
         if (destFile != null && destFile.isFile() && !destFile.canWrite()) {
             if (!force) {
                 throw new IOException("can't write to read-only destination "
                                       + "file " + destFile);
             } else if (!FILE_UTILS.tryHardToDelete(destFile)) {
                 throw new IOException("failed to delete read-only "
                                       + "destination file " + destFile);
             }
         }
 
         if (filterSetsAvailable) {
             BufferedReader in = null;
             BufferedWriter out = null;
             try {
                 InputStreamReader isr = null;
                 if (effectiveInputEncoding == null) {
                     isr = new InputStreamReader(source.getInputStream());
                 } else {
                     isr = new InputStreamReader(source.getInputStream(),
                                                 effectiveInputEncoding);
                 }
                 in = new BufferedReader(isr);
                 OutputStream os = getOutputStream(dest, append, project);
                 OutputStreamWriter osw;
                 if (outputEncoding == null) {
                     osw = new OutputStreamWriter(os);
                 } else {
                     osw = new OutputStreamWriter(os, outputEncoding);
                 }
                 out = new BufferedWriter(osw);
                 if (filterChainsAvailable) {
                     ChainReaderHelper crh = new ChainReaderHelper();
                     crh.setBufferSize(FileUtils.BUF_SIZE);
                     crh.setPrimaryReader(in);
                     crh.setFilterChains(filterChains);
                     crh.setProject(project);
                     Reader rdr = crh.getAssembledReader();
                     in = new BufferedReader(rdr);
                 }
                 LineTokenizer lineTokenizer = new LineTokenizer();
                 lineTokenizer.setIncludeDelims(true);
                 String newline = null;
                 String line = lineTokenizer.getToken(in);
                 while (line != null) {
                     if (line.length() == 0) {
                         // this should not happen, because the lines are
                         // returned with the end of line delimiter
                         out.newLine();
                     } else {
                         newline = filters.replaceTokens(line);
                         out.write(newline);
                     }
                     line = lineTokenizer.getToken(in);
                 }
             } finally {
                 FileUtils.close(out);
                 FileUtils.close(in);
             }
         } else if (filterChainsAvailable
                    || (effectiveInputEncoding != null
                        && !effectiveInputEncoding.equals(outputEncoding))
                    || (effectiveInputEncoding == null && outputEncoding != null)) {
             BufferedReader in = null;
             BufferedWriter out = null;
             try {
                 InputStreamReader isr = null;
                 if (effectiveInputEncoding == null) {
                     isr = new InputStreamReader(source.getInputStream());
                 } else {
                     isr = new InputStreamReader(source.getInputStream(),
                                                 effectiveInputEncoding);
                 }
                 in = new BufferedReader(isr);
                 OutputStream os = getOutputStream(dest, append, project);
                 OutputStreamWriter osw;
                 if (outputEncoding == null) {
                     osw = new OutputStreamWriter(os);
                 } else {
                     osw = new OutputStreamWriter(os, outputEncoding);
                 }
                 out = new BufferedWriter(osw);
                 if (filterChainsAvailable) {
                     ChainReaderHelper crh = new ChainReaderHelper();
                     crh.setBufferSize(FileUtils.BUF_SIZE);
                     crh.setPrimaryReader(in);
                     crh.setFilterChains(filterChains);
                     crh.setProject(project);
                     Reader rdr = crh.getAssembledReader();
                     in = new BufferedReader(rdr);
                 }
                 char[] buffer = new char[FileUtils.BUF_SIZE];
                 while (true) {
                     int nRead = in.read(buffer, 0, buffer.length);
                     if (nRead == -1) {
                         break;
                     }
                     out.write(buffer, 0, nRead);
                 }
             } finally {
                 FileUtils.close(out);
                 FileUtils.close(in);
             }
         } else if (source.as(FileProvider.class) != null
                    && destFile != null) {
             File sourceFile =
                 source.as(FileProvider.class).getFile();
 
             File parent = destFile.getParentFile();
             if (parent != null && !parent.isDirectory()
-                && !destFile.getParentFile().mkdirs()) {
+                && !(parent.mkdirs() || parent.isDirectory())) {
                 throw new IOException("failed to create the parent directory"
                                       + " for " + destFile);
             }
 
             FileInputStream in = null;
             FileOutputStream out = null;
             FileChannel srcChannel = null;
             FileChannel destChannel = null;
 
             try {
                 in = new FileInputStream(sourceFile);
                 out = new FileOutputStream(destFile);
                     
                 srcChannel = in.getChannel();
                 destChannel = out.getChannel();
                 
                 long position = 0;
                 long count = srcChannel.size();
                 while (position < count) {
                     long chunk = Math.min(MAX_IO_CHUNK_SIZE, count - position);
                     position +=
                         destChannel.transferFrom(srcChannel, position, chunk);
                 }
             } finally {
                 FileUtils.close(srcChannel);
                 FileUtils.close(destChannel);
                 FileUtils.close(out);
                 FileUtils.close(in);
             }
         } else {
             InputStream in = null;
             OutputStream out = null;
             try {
                 in = source.getInputStream();
                 out = getOutputStream(dest, append, project);
 
                 byte[] buffer = new byte[FileUtils.BUF_SIZE];
                 int count = 0;
                 do {
                     out.write(buffer, 0, count);
                     count = in.read(buffer, 0, buffer.length);
                 } while (count != -1);
             } finally {
                 FileUtils.close(out);
                 FileUtils.close(in);
             }
         }
         if (preserveLastModified) {
             Touchable t = dest.as(Touchable.class);
             if (t != null) {
                 setLastModified(t, source.getLastModified());
             }
         }
     }
     // CheckStyle:ParameterNumberCheck ON
 
     /**
      * Set the last modified time of an object implementing
      * org.apache.tools.ant.types.resources.Touchable .
      *
      * @param t the Touchable whose modified time is to be set.
      * @param time the time to which the last modified time is to be set.
      *             if this is -1, the current time is used.
      * @since Ant 1.7
      */
     public static void setLastModified(Touchable t, long time) {
         t.touch((time < 0) ? System.currentTimeMillis() : time);
     }
 
     /**
      * Compares the contents of two Resources.
      *
      * @param r1 the Resource whose content is to be compared.
      * @param r2 the other Resource whose content is to be compared.
      * @param text true if the content is to be treated as text and
      *        differences in kind of line break are to be ignored.
      *
      * @return true if the content of the Resources is the same.
      *
      * @throws IOException if the Resources cannot be read.
      * @since Ant 1.7
      */
     public static boolean contentEquals(Resource r1, Resource r2, boolean text) throws IOException {
         if (r1.isExists() != r2.isExists()) {
             return false;
         }
         if (!r1.isExists()) {
             // two not existing files are equal
             return true;
         }
         // should the following two be switched?  If r1 and r2 refer to the same file,
         // isn't their content equal regardless of whether that file is a directory?
         if (r1.isDirectory() || r2.isDirectory()) {
             // don't want to compare directory contents for now
             return false;
         }
         if (r1.equals(r2)) {
             return true;
         }
         if (!text) {
             long s1 = r1.getSize();
             long s2 = r2.getSize();
             if (s1 != Resource.UNKNOWN_SIZE && s2 != Resource.UNKNOWN_SIZE
                     && s1 != s2) {
                 return false;
             }
         }
         return compareContent(r1, r2, text) == 0;
     }
 
     /**
      * Compare the content of two Resources. A nonexistent Resource's
      * content is "less than" that of an existing Resource; a directory-type
      * Resource's content is "less than" that of a file-type Resource.
      * @param r1 the Resource whose content is to be compared.
      * @param r2 the other Resource whose content is to be compared.
      * @param text true if the content is to be treated as text and
      *        differences in kind of line break are to be ignored.
      * @return a negative integer, zero, or a positive integer as the first
      *         argument is less than, equal to, or greater than the second.
      * @throws IOException if the Resources cannot be read.
      * @since Ant 1.7
      */
     public static int compareContent(Resource r1, Resource r2, boolean text) throws IOException {
         if (r1.equals(r2)) {
             return 0;
         }
         boolean e1 = r1.isExists();
         boolean e2 = r2.isExists();
         if (!(e1 || e2)) {
             return 0;
         }
         if (e1 != e2) {
             return e1 ? 1 : -1;
         }
         boolean d1 = r1.isDirectory();
         boolean d2 = r2.isDirectory();
         if (d1 && d2) {
             return 0;
         }
         if (d1 || d2) {
             return d1 ? -1 : 1;
         }
         return text ? textCompare(r1, r2) : binaryCompare(r1, r2);
     }
 
     /**
      * Convenience method to turn any fileProvider into a basic
      * FileResource with the file's immediate parent as the basedir,
      * for tasks that need one.
      * @param fileProvider input
      * @return fileProvider if it is a FileResource instance, or a new
      * FileResource with fileProvider's file.
      * @since Ant 1.8
      */
     public static FileResource asFileResource(FileProvider fileProvider) {
         if (fileProvider instanceof FileResource || fileProvider == null) {
             return (FileResource) fileProvider;
         }
         FileResource result = new FileResource(fileProvider.getFile());
         result.setProject(Project.getProject(fileProvider));
         return result;
     }
 
     /**
      * Binary compares the contents of two Resources.
      * <p>
      * simple but sub-optimal comparision algorithm. written for working
      * rather than fast. Better would be a block read into buffers followed
      * by long comparisions apart from the final 1-7 bytes.
      * </p>
      *
      * @param r1 the Resource whose content is to be compared.
      * @param r2 the other Resource whose content is to be compared.
      * @return a negative integer, zero, or a positive integer as the first
      *         argument is less than, equal to, or greater than the second.
      * @throws IOException if the Resources cannot be read.
      * @since Ant 1.7
      */
     private static int binaryCompare(Resource r1, Resource r2) throws IOException {
         InputStream in1 = null;
         InputStream in2 = null;
         try {
             in1 = new BufferedInputStream(r1.getInputStream());
             in2 = new BufferedInputStream(r2.getInputStream());
 
             for (int b1 = in1.read(); b1 != -1; b1 = in1.read()) {
                 int b2 = in2.read();
                 if (b1 != b2) {
                     return b1 > b2 ? 1 : -1;
                 }
             }
             return in2.read() == -1 ? 0 : -1;
         } finally {
             FileUtils.close(in1);
             FileUtils.close(in2);
         }
     }
 
     /**
      * Text compares the contents of two Resources.
      * Ignores different kinds of line endings.
      * @param r1 the Resource whose content is to be compared.
      * @param r2 the other Resource whose content is to be compared.
      * @return a negative integer, zero, or a positive integer as the first
      *         argument is less than, equal to, or greater than the second.
      * @throws IOException if the Resources cannot be read.
      * @since Ant 1.7
      */
     private static int textCompare(Resource r1, Resource r2) throws IOException {
         BufferedReader in1 = null;
         BufferedReader in2 = null;
         try {
             in1 = new BufferedReader(new InputStreamReader(r1.getInputStream()));
             in2 = new BufferedReader(new InputStreamReader(r2.getInputStream()));
 
             String expected = in1.readLine();
             while (expected != null) {
                 String actual = in2.readLine();
                 if (!expected.equals(actual)) {
                     if (actual == null) {
                         return 1;
                     }
                     return expected.compareTo(actual);
                 }
                 expected = in1.readLine();
             }
             return in2.readLine() == null ? 0 : -1;
         } finally {
             FileUtils.close(in1);
             FileUtils.close(in2);
         }
     }
 
     /**
      * Log which Resources (if any) have been modified in the future.
      * @param logTo the ProjectComponent to do the logging.
      * @param rc the collection of Resources to check.
      * @param granularity the timestamp granularity to use.
      * @since Ant 1.7
      */
     private static void logFuture(ProjectComponent logTo,
                                   ResourceCollection rc, long granularity) {
         long now = System.currentTimeMillis() + granularity;
         Date sel = new Date();
         sel.setMillis(now);
         sel.setWhen(TimeComparison.AFTER);
         Restrict future = new Restrict();
         future.add(sel);
         future.add(rc);
         for (Resource r : future) {
             logTo.log("Warning: " + r.getName() + " modified in the future.", Project.MSG_WARN);
         }
     }
 
     private static OutputStream getOutputStream(Resource resource, boolean append, Project project)
             throws IOException {
         if (append) {
             Appendable a = resource.as(Appendable.class);
             if (a != null) {
                 return a.getAppendOutputStream();
             }
             project.log("Appendable OutputStream not available for non-appendable resource "
                     + resource + "; using plain OutputStream", Project.MSG_VERBOSE);
         }
         return resource.getOutputStream();
     }
 
     public static interface ResourceSelectorProvider {
         ResourceSelector getTargetSelectorForSource(Resource source);
     }
 }
