diff --git a/CONTRIBUTORS b/CONTRIBUTORS
index 3672d801a..c209a5810 100644
--- a/CONTRIBUTORS
+++ b/CONTRIBUTORS
@@ -1,381 +1,382 @@
 Amongst other, the following people contributed to ant:
 
 Adam Blinkinsop
 Adam Bryzak
 Adam Sotona
 Aleksandr Ishutin
 Alex Rosen
 Alexei Yudichev
 Alexey Panchenko
 Alexey Solofnenko
 Alfred Theorin
 Alison Winters
 Andreas Ames
 Andreas Mross
 Andrew Eisenberg
 Andrew Everitt
 Andrew Stevens
 Andrey Urazov
 Andy Wood
 Anil K. Vijendran
 Anli Shundi
 Anthony Goubard
 Anthony Green
 Anthony Wat
 Antoine Baudoux
 Antoine Levy-Lambert
 Anton Mazkovoi
 Arjan Veenstra
 Arnaud Vandyck
 Arnout J. Kuiper
 Aslak Hellesôy
 Atsuhiko Yamanaka
 Avik Sengupta
 Balazs Fejes 2
 Bart Vanhaute
 Benjamin Burgess
 Ben Galbraith
 Benoit Moussaud
 Bernd Dutkowski
 Bernhard Rosenkraenzer
 Brad Clark
 Brant Langer Gurganus
 Brian Curnow
 Brian Deitte
 Brian Felder
 Brian Repko
 Bruce Atherton
 Cedomir Igaly
 Charles Hudak
 Charlie Hubbard
 Chris Povirk
 Christian Knorr
 Christoph Wilhelms
 Christophe Labouisse
 Christopher A. Longo
 Christopher Charlier
 Clark Archer
 Clemens Hammacher
 Clement OUDOT
 Conor MacNeill
 Craeg Strong
 Craig Cottingham
 Craig R. McClanahan
 Craig Richardson
 Craig Ryan
 Craig Sandvik
 Curt Arnold
 Curtis White
 Cyrille Morvan
 D'Arcy Smith
 Dale Anson
 Dale Sherwood
 Dan Armbrust
 Daniel Henrique
 Daniel Ribagnac
 Daniel Spilker
+Daniel Trebbien
 Danno Ferrin
 Danny Yates
 Dante Briones
 Davanum Srinivas
 Dave Brondsema
 Dave Brosius
 David A. Herman
 David Crossley
 David Gärtner
 David S. Johnson
 David Kavanagh
 David LeRoy
 David Leal
 David M. Lloyd
 David Maclean
 David Rees
 Denis Hennessy
 Derek Slager
 Devon C. Miller
 Diane Holt
 dIon Gillard
 Dmitry A. Kuminov
 Dominique Devienne
 Donal Quinlan
 Don Brown
 Don Ferguson
 Don Jeffery
 Drew Sudell
 Eduard Wirch
 Edwin Woudt
 Eli Tucker
 Emmanuel Bourg
 Eric Barboni
 Eric Olsen
 Eric Pugh
 Erik Hatcher
 Erik Langenbach
 Erik Meade
 Ernst de Haan
 Frank Harnack
 Frank Somers
 Frank Zeyda
 Frederic Bothamy
 Frederic Lavigne
 Gary S. Weaver
 Gautam Guliani
 Gene-Sung Chung
 Georges-Etienne Legendre
 Gero Vermaas
 Gerrit Riessen
 Gilbert Rebhan
 Gilles Scokart
 Glenn McAllister
 Glenn Twiggs
 Greg Nelson
 Greg Roodt
 Greg Schueler
 Günther Kögel
 Harish Prabandham
 Haroon Rafique
 Hiroaki Nakamura
 Holger Engels
 Holger Joest
 Ignacio Coloma
 Ingenonsya France
 Ingmar Stein
 Irene Rusman
 Ivan Ivanov
 J Bleijenbergh
 Jack J. Woehr
 James Duncan Davidson
 Jan Cumps
 Jan Matèrne
 Jan Mynarik
 Jason Hunter
 Jason Pettiss
 Jason Salter
 Jason Yip
 Jay Dickon Glanville
 Jay Peck
 Jay van der Meer
 JC Mann
 J D Glanville
 Jean-Francois Brousseau
 Jean-Louis Boudart
 Jeff Gettle
 Jeff Martin
 Jeff Tulley
 Jeff Turner
 Jene Jasper
 Jeremy Mawson
 Jerome Lacoste
 Jesse Glick
 Jesse Stockall
 Jim Allers
 Joerg Wassmer
 Joey Richey
 Johann Herunter
 John Sisson
 Jon Dickinson
 Jon S. Stevens
 Jon Skeet
 Jose Alberto Fernandez
 Joseph Walton
 Josh Lucas
 Juerg Wanner
 Julian Simpson
 Justin Vallon
 Keiron Liddle
 Keith Visco
 Kevin Connor Arpe
 Kevin Greiner
 Kevin Jackson
 Kevin Ross
 Kevin Z Grey
 Kim Hansen
 Kirk Wylie
 Kyle Adams
 Larry Shatzer
 Larry Streepy
 Les Hughes
 Levi Cook
 lucas
 Ludovic Claude
 Maarten Coene
 Magesh Umasankar
 Maneesh Sahu
 Marcel Schutte
 Marcus B&ouml;rger
 Mario Frasca 
 Mariusz Nowostawski
 Mark A. Ziesemer
 Mark DeLaFranier
 Mark Hecker
 Mark R. Diggory
 Mark Salter
 Markus Kahl
 Martijn Kruithof
 Martin Landers
 Martin Poeschl
 Martin van den Bemt
 Martin von Gagern
 Mathieu Champlon
 Mathieu Peltier
 Matt Albrecht
 Matt Benson
 Matt Bishop
 Matt Foemmel
 Matt Grosso
 Matt Humphrey
 Matt Small
 Matt Wildig
 Matthew Hawthorne
 Matthew Inger
 Matthew Kuperus Heun
 Matthew Watson
 Michael Bayne
 Michael Davey
 Michael J. Sikorsky
 Michael McCallum
 Michael Montuori
 Michael Newcomb
 Micheal Nygard
 Michael Saunders
 Miha
 Mike Davis
 Mike Roberts
 mnowostawski
 Mounir El Hajj
 Nathan Beyer
 Nick Chalko
 Nick Fortescue
 Nick Crossley
 Nick Pellow
 Nicola Ken Barozzi
 Nico Seessle
 Nigel Magnay
 Oliver Merkel
 Oliver Rossmueller
 Ondra Medek
 Omer Shapira
 Oystein Gisnas
 Patrick C. Beard
 Patrick Chanezon
 Patrick G. Heck (Gus Heck)
 Patrick Martin
 Paul Austin
 Paul Christmann
 Paul Galbraith
 Paul King
 Paulo Gaspar
 Pavan Bayyapu
 Pavel Jisl
 Pawel Zuzelski
 Peter B. West
 Peter Donald
 Peter Doornbosch
 Peter Hulst
 Peter Janes
 Peter Reilly
 Phil Hanna
 Philip Hourihane
 Phillip Wells
 Pierre Delisle
 Pierre Dittgen
 riasol
 R Handerson
 Rami Ojares
 Randy Watler
 Raphael Pierquin
 Ray Waldin
 Remie Bolte
 Richard Evans
 Rick Beton
 Robert Anderson
 Robert Clark
 Robert Flaherty
 Robert Shaw
 Robert Streich
 Robert Watkins
 Roberto Scaramuzzi
 Robin Green
 Robin Verduijn
 Rob Oxspring
 Rob van Oostrum
 Rodrigo Schmidt
 Roger Vaughn
 Roman Ivashin
 Ronen Mashal
 Russell Gold
 Sam Ruby
 Sandra Metz
 Scott Carlson
 Scott Ellsworth
 Scott Johnson
 Scott M. Stirling
 Sean Egan
 Sean P. Kane
 Sebastien Arod
 Shiraz Kanga
 Sebastian Kantha
 Simon Law
 Simone Bordet
 Stefan Bodewig
 Stefan Heimann
 Stefano Mazzocchi
 Stephan Strittmatter
 Stephane Bailliez
 stephan
 Stephan Michels
 Stephen Chin
 Stephen Goetze
 Steve Cohen
 Steve Langley
 Steve Loughran
 Steve Morin
 Steve Wadsworth
 Steven E. Newton
 Takashi Okamoto
 TAMURA Kent
 Taoufik Romdhane
 Tariq Master
 Thomas Aglassinger
 Thomas Butz
 Thomas Christen
 Thomas Christensen
 Thomas Haas
 Thomas Quas
 Tim Drury
 Tim Fennell
 Tim Stephenson
 Timoteo Ohara
 Timothy Gerard Endres
 Tom Ball
 Tom Brus
 Tom Cunningham
 Tom Dimock
 Tom Eugelink
 Tom May
 Tomasz Bech
 Trejkaz Xaoza
 Ulrich Schmidt
 Valentino Miazzo
 Victor Toni
 Vimil Saju
 Vincent Legoll
 Volker Leidl
 Waldek Herka
 Wang Weijun
 Will Wang
 William Bernardet
 William Ferguson
 William Webber
 Wolf Siberski
 Wolfgang Baer
 Wolfgang Frech
 Wolfgang Glas
 Wolfgang Werner
 Xavier Hanin
 Xavier Witdouck
 Yohann Roussel
 Yuji Yamano
 Yves Martin
 Zach Garner
 Zdenek Wagner
diff --git a/WHATSNEW b/WHATSNEW
index bcab2c871..09905e746 100644
--- a/WHATSNEW
+++ b/WHATSNEW
@@ -1,1064 +1,1068 @@
     Changes from Ant 1.8.4 TO Ant 1.9.0
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * FixCRLF used to treat the EOL value ASIS to convert to the system property 
    line.separator. Specified was that ASIS would leave the EOL characters alone,
    the task now really leaves the EOL characters alone. This also implies that
    EOL ASIS will not insert a newline even if fixlast is set to true.
    Bugzilla report 53036
 
  * The CommandLauncher hierarchy that used to be a set of inner
    classes of Execute has been extracted to the
    org.apache.tools.ant.taskdefs.launcher package.
 
  * Any FileResource whose represented File has a parent also has a basedir.
 
 Fixed bugs:
 -----------
 
  * Made VectorSet faster.
    Bugzilla Report 53622.
 
  * Incorrect URLs in Ant child POMs.
    Bugzilla Report 53617.
 
  * Subclasses of JUnitTask did not correctly find junit.jar.
    Bugzilla Report 53571.
 
  * External XML catalog resolver failed to use project basedir when given an
    unmentioned relative path like the internal resolver does.
    Bugzilla Report 52754.
 
  * Fixed some potential stream leaks.
    Bugzilla Reports 52738, 52740, 52742, 52743.
 
  * Updated documentation to fix spelling errors / broken links.
    Bugzilla Reports 53215, 53291, 53202
    
  * Unable to override system properties. It was not possible not to override
    system properties from the command line (or from a property file).
    Bugzilla Report 51792
    
  * <javac> by default fails when run on JDK 8.
    Bugzilla Report 53347.
 
  * ExtensionPoint doesn't work with nested import/include
    Bugzilla Report 53405.
 
  * <packagemapper> failed to strip the non-matched parts with
    handledirsep="true".
    Bugzilla Report 53399.
 
  * <expandproperties> filter caused a NullPointerExcpetion when input
    was empty.
    Bugzilla Report 53626.
 
  * <get> now supports HTTP redirects using status code 307.
    Bugzilla Report 54374.
 
  * ssh tasks prompt for kerberos username/password under Java 7
    Bugzilla Report 53437.
 
+ * Zip task on <mappedresources> that excludes certain files by way of the mapper resulted in a NullPointerException
+   Bugzilla Report 54026
+
+
 Other changes:
 --------------
 
  * merged the ZIP package from Commons Compress, it can now read
    archives using Zip64 extensions (files and archives bigger that 4GB
    and with more that 64k entries).
 
  * a new task <commandlaucher> can be used to configure the
    CommandLauncher used by Ant when forking external programs or new
    Java VMs.
    Bugzilla Report 52706.
 
  * merged the TAR package from Commons Compress, it can now read
    archives using POSIX extension headers and STAR extensions.
 
  * merged the BZIP2 package from Commons Compress, it can now
    optionally read files that contain multiple streams properly.
 
  * <bunzip2> will now properly expand files created by pbzip2 and
    similar tools that create files with multiple bzip2 streams.
 
  * <tar> now supports a new "posix" option for longfile-mode which
    will make it create PAX extension headers for long file names.  PAX
    extension headers are supported by all modern implementations of
    tar including GNU tar.
    This option should now be used in preference to "warn" or "gnu" as
    it is more portable.  For backwards compatibility reasons "warn"
    will still create "gnu" extensions rather than "posix" extensions.
 
  * The ProjectHelper class now exposes a method to be used by third party
    implementations to properly resolve the binding between target extensions
    and extension points.
    Bugzilla Report 53549.
 
  * Make extension point bindable to imported prefixed targets
    Bugzilla Report 53550.
 
  * Add the possibility to register a custom command line argument processor.
    See org.apache.tools.ant.ArgumentProcessor and manual/argumentprocessor.html
 
 Changes from Ant 1.8.3 TO Ant 1.8.4
 ===================================
 
 Fixed bugs:
 -----------
 
  * Ported libbzip2's fallback sort algorithm to CBZip2OutputStream to
    speed up compression in certain edge cases.  Merge from Commons
    Compress.
 
    Using specially crafted inputs this can be used as a denial of
    service attack.
    See http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2098
 
 Changes from Ant 1.8.2 TO Ant 1.8.3
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * The Enumeration returned by AntClassLoader#getResources used to
    return null in nextElement after hasNextElement would return false.
    It has been changed to throw a NoSuchElementException instead so
    that it now adheres to the contract of java.util.Enumeration.
    Bugzilla Report 51579.
 
 Fixed bugs:
 -----------
 
  * Removed buggy duplicate JAR list in RPM mode.
    Bugzilla Report 52556.
 
  * Launcher fixed to pass the right class loader parent.
    Bugzilla Report 48633.
 
  * <junitreport> mishandled ${line.separator}.
    Bugzilla Report 51049.
 
  * <junitreport> did not work in embedded environments on JDK 7.
    Nor did <xslt> when using Xalan redirects.
    Bugzilla Report 51668, 52382.
 
  * Encoding of unicode escape sequences by the property file task
    Bugzilla Report 50515.
 
  * The code that implicitly sets the -source switch if only -target
    has been specified in <javac> was broken for Java 5 and 6.
    Bugzilla Report 50578.
 
  * MailLogger ignore the Maillogger.starttls.enable property.
    Bugzilla Report 50668.
 
  * Delete task example does not work
    Bugzilla Report 50816.
 
  * <splash>'s proxy handling has been delegated to <setproxy>
    internally so the two tasks are consistent.  <splash>'s way of not
    setting a proxy caused problems with other Java libraries.
    Bugzilla Report 50888.
 
  * Include task breaks dependencies or extension-points for multiple
    files.
    Bugzilla Report 50866.
 
  * Read on System.in hangs for forked java task.
    Bugzilla Report 50960.
 
  * FileResource specified using basedir/name attributes was non-functional.
 
  * Resource collection implementation of mapped PropertySet returned
    unusable resources.
 
  * The hasmethod condition failed with a NullPointerException when
    ignoresystemclasses is true and Ant tried to load a "restricted
    class" - i.e. a class that the Java VM will only accept when loaded
    via the bootclassloader (a java.* class).
    It will now fail with a more useful error message.
    Bugzilla Report 51035.
 
  * Exec task may mix the stderr and stdout output while logging it
    Bugzilla Report 50507.
 
  * Missing space between "finished" and timestamp in task/target 
    finish message from ProfileLogger.
    Bugzilla Report 51109.
 
  * Redirecting the output of a java, exec or apply task could print in the
    error output stream some "Pipe broken" errors.
    Bugzilla Report 48789.
 
  * ZipFile failed to clean up some resources which could lead to
    OutOfMemoryException while unzipping large archives.
    A similar problem in ZipArchiveOutputStream has been fixed as well.
    Bugzilla Report 42696.
 
  * quiet attribute added to the copy and move tasks, to be used together
    with failonerror=false, so warnings won't get logged 
    Bugzilla Report 48789.
 
  * System.in was closed and not readable anymore by the DefaultInputHandler 
    when Ant is used via its Java API.
    Bugzilla Report 51161
 
  * <sync> only supported a single non-fileset resource collection even
    though the manual said it could be multiple.
 
  * <sync> didn't work properly when working on resource collections.
    Bugzilla Report 51462.
 
  * <augment> cause a NullPointerException if it was used in a target
    that was invoked by multiple targets from the command line.
    Bugzilla Report 50894.
 
  * The ZipFile class could read past the start of the file if the
    given file is not a ZIP archive and it is smaller than the size of
    a ZIP "end of central directory record".
 
  * <javac> would create the empty package-info.class file in the wrong
    directory if no destdir was specified.  Note it may still pick the
    wrong directory if you specify more than one source directory but
    no destDir.  It is highly recommended that you always explicitly
    specify the destDir attribute.
    Bugzilla Report 51947.
 
  * packagemapper now honors the handleDirSep attribute.
    Bugzilla Report 51086.
 
  * the attributes of macrodef tasks had their values run through
    property expansion twice. Still true by default, but can be disabled.
    Bugzilla Report 42046.
 
  * jvc doesn't like it if source file names in argument files are
    quoted.
    Bugzilla Report 31667.
 
  * ZipFile didn't work properly for archives using unicode extra
    fields rather than UTF-8 filenames and the EFS-Flag.
 
  * Access to DirectoryScanner's default excludes wasn't synchronized.
    Bugzilla Report 52188.
 
  * When a Project instance was created by a custom tasks its
    createTask method didn't work.
    Bugzilla Report 50788.
 
 Other changes:
 --------------
 
  * -f/-file/-buildfile accepts a directory containing build.xml.
 
  * The <javacc>, <jjtree> and <jjdoc> now support a new maxmemory
    attribute.
    Bugzilla Report 50513.
 
  * the documented inputstring attribute of sshexec has been
    implemented and the actually existing attribute inputproperty
    documented.
    Bugzilla Report 50576.
 
  * The concat task now permits the name of its exposed resource
    by means of its 'resourcename' attribute.
 
  * The expandproperties filter now accepts a nested propertyset
    which, if specified, provides the properties for expansion.
    Bugzilla Report 51044.
 
  * <junit filtertrace="true"/> will no longer filter out the very
    first line of the stacktrace containing the original exception
    message even if it matches one of the filter expressions.
 
  * Upgraded to Apache AntUnit 1.2
 
  * Provide read access to Mkdir.dir.  Bugzilla Report 51684.
 
  * <delete> and <move> have a new attribute performGCOnFailedDelete
    that may - when set to true - help resolve some problems with
    deleting empty directories on NFS shares.
    Bugzilla Report 45786.
 
  * <loadfile> and <loadresource> used to log at level INFO to signal a
    property hasn't been set when the resource was empty even if the
    quiet attribute was set to true.  They will now use VERBOSE
    instead.
    Bugzilla Report 52107.
 
  * <javac> has a new attribute createMissingPackageInfoClass that can
    be set to false to prevent Ant from creating empty dummy classes
    used for up-to-date-ness checks.
    Bugzilla Report 52096.
 
  * URLResources#isExists has become less noisy.
    Bugzilla Report 51829.
 
  * The <retry> task has a new optional attribute retryDelay that can
    be used to make the task sleep between retry attempts.
    Bugzilla Report 52076.
 
  * <signjar> has new attributes that control the signature and digest
    algorithms.
    Bugzilla Report 52344.
 
  * Initial support for Java 8.
 
  * <sshexec> can optionally create a pseudo terminal (like ssh -t)
    Bugzilla Report 52554.
 
 Changes from Ant 1.8.1 TO Ant 1.8.2
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Prior to Ant 1.8.0 the <copy> task and several other tasks would
    overwrite read-only destination files.  Starting with 1.8.0 they
    would only do so under special circumstances.  Ant 1.8.2 now
    consistently won't replace a read-only file by default. The same is
    true for a number of other tasks.
    The <copy>, <move> and <echo> tasks now have a new force attribute
    and <concat> has a new forceReadonly attribute that can be used to
    make the task overwrite read-only destinations.
    Bugzilla Report 49261.
 
  * Removed ant-nodeps.jar; it is now merged into ant.jar.
 
  * DOMElementWriter#encode used to employ special code before encoding
    ampersands so that &#123; remained &#123; rather than being turned
    into &amp;#123;.  This is no longer the case, ampersands will now
    be encoded unconditionally.
    Also DOMElementWriter#encodeData will treat CDATA sections containing a
    literal "]]>" sequence different now - it will split the CDATA
    section between the second "]" and ">" and create two sections.
    This affects <echoxml> task as well as the XML logger or JUnit
    formatter where ampersands will now always get encoded.
    In addition DOMElementWriter will now replace the characters \t, \r
    and \n in attribute values by entity references.
    Bugzilla Report 49404.
 
  * The list elements returned by ProjectHelper#getExtensionStack are
    now String arrays of length 3 rather than 2 in order to support the
    onMissingExtensionPoint attribute.
    Bugzilla Report 49473.
 
  * When using <property file="..." prefix="..."/> properties defined
    inside the same file will only get used in expansions if the ${}
    reference uses the same prefix.  This is different from Ant 1.8.1
    but is the same behavior Ant 1.8.0 and earlier exhibited.
    A new attribute prefixValues can be used to re-enable the behavior
    of Ant 1.8.1.
    Bugzilla Report 49373.
 
  * The files and directories used by Git, Mercurial and Bazaar to
    store their information are now excluded by the defaultexcludes.
    Bugzilla Report 49624.
 
  * The <junit> task no longer generates TestListener events - which
    have been introduced in ant 1.7.0 - by default.  The task has a new
    attribute enableTestListenerEvents and a new "magic" property
    ant.junit.enabletestlistenerevents has been added that can be used
    to reinstate the old behavior.
 
 Fixed bugs:
 -----------
 
  * hostinfo now prefers addresses with a hostname over addresses without 
    a hostname, provided the addresses have the same scope.
    For local lookup, no IP address will be put in NAME / DOMAIN anymore.
    For remote lookup, if a host name was provided and only an IP address is 
    found, the IP address will no longer overwrite the host name provided to the
    task.
    Bugzilla Report 49513
 
  * mmap-based file copy problems under JDK 1.4 on Linux.
    Bugzilla Report 49430.
 
  * The Sun JVM tries to mmap the entire file during a copy. 
    For large files this is not feasible. 
    We now explicitly request to copy at most 16 MiB per request.
    Bugzilla Report 49326.
 
  * DemuxInputStream.read() should return unsigned values
    Bugzilla Report 49279.
 
  * The MIME mailer ignored the port parameter when using SSL.
    Bugzilla Report 49267.
 
  * <xslt> ignored the classpath when using the default TraX processor.
    Bugzilla Report 49271.
 
  * <checksum>'s totalproperty only worked reliably if the same file
    name didn't occur inside more than one directory.
    Bugzilla Report 36748.
 
  * <ftp> could fail to download files from remote subdirectories under
    certain circumstances.
    Bugzilla Report 49296.
 
  * <junit> will now produce better diagnostics when it fails to delete
    a temporary file.
    Bugzilla Report 49419.
 
  * Ant would often scan directories even though there were known to
    only hold excluded files when evaluating filesets.  This never
    resulted in wrong results but degraded performance of the scan
    itself.
    Bugzilla Report 49420.
 
  * <javac> failed for long command lines on OS/2.
    Bugzilla Report 49425.
 
  * <junitreport> did not handle encodings well for stdout/stderr.
    Bugzilla Report 49418.
 
  * <junit> could issue a warning about multiple versions of Ant on the
    CLASSPATH if two CLASSPATH entries differed in case on a
    case-insensitive file system.
    Bugzilla Report 49041.
 
  * The <restrict> resource collection was checking every resource even if
    we actually just want the first one, like in the example of use of
    resourcelist in the documentation (getting the first available resource
    from a mirror list).
 
  * A race condition could lead to build failures if multiple <mkdir>
    tasks were trying to create the same directory.
    Bugzilla Report 49572.
 
  * the toString() method of the Resources class - and thus any
    ${toString:} expansion of a reference to a <resources> element -
    didn't iterate over its nested elements if it hadn't done so prior
    to the toString invocation already.
    Bugzilla Report 49588.
 
  * <apply> in parallel mode didn't work together with a nested
    <redirector> if maxparallel was <= 0 (the default) or no source
    files matched.
    Bugzilla Report 49594.
 
  * <jar filesetmanifest="merge"> didn't work for manifests added via
    <zipfileset>s that used the prefix or fullpath attributes.
    Bugzilla Report 49605.
 
  * <tempfile createfile="true"> would cause an error unless the prefix
    attribute has been specified.
    Bugzilla Report 49755.
 
  * If forked, after finished <java> was still reading the input stream
    for a bunch of characters, then stealing them from a following <input>.
    Bugzilla Report 49119.
 
  * Ant could be leaking threads for each forked process (started by
    <exec>, <apply>, <java> or similar tasks) that didn't receive input
    from a resource or string explicitly.
    Bugzilla Report 49587.
 
  * Project#setDefault threw an exception when null was passed in as
    argument, even though the Javadoc says null is a valid value.
    Bugzilla Report 49803.
 
  * runant.py would swallow the first argument if CLASSPATH wasn't set.
    Bugzilla Report 49963.
 
  * <taskdef> failed to load resources from jar files contained in a
    directory that has a "!" in its name.
    Bugzilla Report 50007.
 
  * ant.bat exit strategy improvements and issues
    make the exit codes work in environments where 4NT or MKS are installed
    Bugzilla Report 41039.
 
  * <signjar> would fail if used via its Java API and the File passed
    into the setJar method was not "normalized" (i.e. contained ".."
    segments).
    Bugzilla Report 50081.
 
  * <delete> ignored <fileset>'s errorOnMissingDir attribute
    Bugzilla Report 50124.
 
  * <symlink> failed to close files when reading a list of symbolic
    links from a properties file.
    Bugzilla Report 50136.
 
  * <parallel> could allow tasks to start executing even if a task
    scheduled to run before them timed out.
    Bugzilla Report 49527.
 
  * If a <junit> batch with multiple tests times out Ant logs a message
    about a test named Batch-With-Multiple-Tests since 1.8.0 but the
    logic that determined the Java package of this pseudo-test has been
    wrong.
    Bugzilla Report 45227.
 
  * <propertyfile> didn't preserve the original linefeed style when
    updating a file.
    Bugzilla Report 50049.
 
  * <zip>'s whenEmpty behavior never consulted the non-fileset
    resources so the task could fail even though resources have been
    provided using non-fileset resource collections.
    Bugzilla Issue 50115.
 
 *  ftp chmod could throw a NPE.
    Bugzilla report 50217.
 
 *  The project help (-p option in the command line) will now print
    the dependencies of the targets in debug mode (-d on the command
    line)
 
 Other changes:
 --------------
 
  * <concat>'s force attribute has been deprecated in favor of a new
    overwrite attribute that is consistent with <copy>'s attribute
    names.
 
  * You can now specify a list of methods to run in a JUnit test case.
    Bugzilla Report 34748.
 
  * properties in files read because of the -propertyfile command line
    option will now get resolved against other properties that are
    defined before the project starts executing (those from the same or
    earlier -propertfiles or defined via the -D option).
    Bugzilla Report 18732.
 
  * <pathelement>s can now contain wildcards in order to use wildcard
    CLASSPATH entries introduced with Java6.
    The wildcards are not expanded or even evaluated by Ant and will be
    used literally.  The resulting path may be unusable as a CLASSPATH
    for Java versions prior to Java6 and likely doesn't mean anything
    when used in any other way than a CLASSPATH for a forked Java VM. 
    Bugzilla Report 46842.
 
  * A new attribute allows targets to deal with nonexistent extension
    points, i.e. they can extend an extension-point if it has been
    defined or silently work as plain targets if it hasn't.  This is
    useful for targets that get included/imported in different
    scenarios where a given extension-point may or may not exist.
    Bugzilla Report 49473.
 
  * Ant now logs a warning message if it fails to change the file
    modification time in for example when using <touch> or preserving
    timestamps in various tasks.
    Bugzilla Report 49485.
 
  * ProjectHelpers can now be installed dynamically via the <projecthelper>
    Ant task.
 
  * <import> is now able to switch to the proper ProjectHelper to parse
    the imported resource. This means that several kinds of different build
    files can import each other.
 
  * <copy tofile=""> now also works for non-filesystem resources.
    Bugzilla Report 49756.
 
  * The <linecontainsregexp> filter now supports a casesensitive
    attribute.
 
  * The <containsregexp> selector now supports casesensitive, multiline
    and singleline attributes.
    Bugzilla Report 49764.
 
  * A new <cutdirsmapper> can be used like wget's --cut-dirs option to
    strip leading directories from file names.
 
  * <javah> now supports the GNU project's gcjh compiler.
    Bugzilla Report 50149.
 
  * <checksum> supports additional views of a file's path as elements
    for a custom pattern.
    Bugzilla Report 50114.
 
  * JUnit XMLResultAggregator logs the stack trace of caught IO exceptions
    in verbose runs.
    Bugzilla Report 48836.
 
  * StringUtils.parseHumanSizes() should turn parse failures into
    BuildExceptions.
    Bugzilla Report 48835.
 
  * New task <bindtargets> to make a list of targets bound to some
    specified extension point.
 
  * Initial support for OpenJDK7 has been added.
 
  * Ant now uses java.net.CookieStore rather than
    java.util.ServiceLocator to detect whether the environment is a
    Java 1.6 system.  This means releases of gcj/gij at the time of
    this release of Ant are detected as Java 1.5 and not 1.6.
    Bugzilla Report 50256.
 
  * It is now possible to write a compiler adapter for <javac> that
    compiles sources with extensions other than .java (but that still
    compile to .class files).
    Bugzilla Report 48829.
 
  * The performance of VectorSet#add(Object) has been improved which
    should also benefit any operation that scans directories in Ant.
    Bugzilla Report 50200.
 
 Changes from Ant 1.8.0 TO Ant 1.8.1 
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * ant-trax.jar is no longer produced since TrAX is included in JDK 1.4+.
 
  * Ant no longer ships with Apache Xerces-J or the XML APIs but relies
    on the Java runtime to provide a parser and matching API versions.
 
  * The stylebook ant task and the ant-stylebook.jar are removed.
 
 Fixed bugs:
 -----------
 
  * Tasks that iterate over task or type definitions, references or
    targets now iterate over copies instead of the live maps to avoid
    ConcurrentModificationExceptions if another thread changes the
    maps.
    Bugzilla Report 48310.
 
  * The filesmatch condition threw a NullPointerException when
    comparing text files and the second file contained fewer lines than
    the first one.
    Bugzilla Report 48715.
 
  * Regression: The <ear> task would allow multiple
    META-INF/application.xml files to be added.
    Bugzilla Report 6836.
 
  * VectorSet#remove(Object) would fail if the size of the vector
    equaled its capacity.
 
  * Regression : ant -diagnostics was returning with exit code 1
    Bugzilla Report 48782
 
  * Fix for exec task sometimes inserts extraneous newlines
    Bugzilla Report 48746
 
  * SymlinkTest#testSymbolicLinkUtilsMethods failing on MacOS
    Bugzilla Report 48785.
 
  * If <concat>'s first resourcecollection child is a <resources>,
    any subsequently added child resourcecollection joins the first.
    Bugzilla Report 48816.
 
  * <get> with an invalid URL could trigger an NPE in some JVMs.
    Bugzilla Report 48833
 
  * Broken Pipe issue under Ubuntu Linux
    Bugzilla Report 48789
 
  * Properties wrongly read from file or not update during read
    Bugzilla Report 48768
 
  * AntClassLoader in Ant 1.8.0 has been considerably slower than in
    1.7.1
    Bugzilla Report 48853
 
  * ANT_CMD_LINE_ARGS are rippling through lower level Ant usage 
    Bugzilla Report 48876
 
  * email : IO error sending mail with plain mimetype
    Bugzilla Report 48932
 
  * the complete-ant-cmd.pl script failed to create a proper cache of
    target if "ant -p" failed.
    Bugzilla Report 48980
 
  * <rmic>'s sourcebase attribute was broken.
    Bugzilla Report 48970
 
  * <copy>'s failonerror didn't work as expected when copying a single
    element resource collection to a file.
    Bugzilla Report 49070
 
  * <get> no longer followed redirects if the redirect URL was relative
    and not an absolute URL.
    Bugzilla Report 48972
 
  * fixed a performance degradation in the code that expands property
    references.
    Bugzilla Reports 48961 and 49079
 
  * <jar filesetmanifest="merge"> was broken on Windows.
    Bugzilla Report 49090
 
  * <symlink> delete failed if the link attribute was a relative path
    to a link inside the current directory without a leading ".".
    Bugzilla Report 49137
 
  * <telnet> and <rexec> failed to find the expected strings when
    waiting for responses and thus always failed.
    Bugzilla Report 49173
 
 Other changes:
 --------------
 
  * Project provides new get methods that return copies instead of the
    live maps of task and type definitions, references and targets.
 
  * Ant is now more lenient with ZIP extra fields and will be able to
    read archives that it failed to read in earlier versions.
    Bugzilla Report 48781.
 
  * The <zip> family of tasks has been sped up for bigger archives.
    Bugzilla Report 48755.
 
  * Add removeKeepExtension option to NetRexxC task.
    Bugzilla Report 48788.
 
  * Add prefix attribute to loadproperties task.
 
  * Add resource attribute to length task.
 
  * PropertyResource will effectively proxy another Resource if ${name}
    evaluates to a Resource object.
 
  * Added forcestring attribute to equals condition to force evaluation
    of Object args as strings; previously only API-level usage of the
    equals condition allowed Object args, but Ant 1.8.x+ property
    evaluation may yield values of any type.
 
  * BuildFileTest.assertPropertyUnset() fails with a slightly more 
    meaningful error message
    Bugzilla Report 48834
 
  * <junit> will now throw an exception if a test name is empty.  This
    used to manifest itself in unrelated errors like
    Bugzilla Report 43586.
 
  * A change that made <exec> more reliable on Windows (Bugzilla Report
    5003) strongly impacts the performance for commands that execute
    quickly, like attrib.  Basically no single execution of a command
    could take less than a second on Windows.
    A few timeouts have been tweaked to allow these commands to finish
    more quickly but still they will take longer than they did with Ant
    1.7.1.
    Bugzilla Report 48734.
 
  * Added SimpleBigProjectLogger, intermediate between NoBannerLogger and
    BigProjectLogger.
 
  * <mappedresources> supports new attributes enablemultiplemappings
    and cache.
 
  * Added the augment task to manipulate existing references via Ant's basic
    introspection mechanisms.
 
 Changes from Ant 1.8.0RC1 TO Ant 1.8.0
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * the appendtolines filter has been renamed to suffixlines.
 
 Fixed bugs:
 -----------
 
  * stack traces were not reported at all by <junit/>
    when filtertrace="on", which is the default.
 
  * ant.bat can now also process the -noclasspath switch when it is 
    the first switch on a command line.
    Bugzilla Report 48186.
 
  * <fixcrlf> now tries to delete the created temporary files earlier.
    Bugzilla Report 48506.
 
  * the implementation of <zip> had been changed in a way that broke
    the jarjar links task and protentially other third-party subclasses
    as well.
    Bugzilla Report 48541.
 
  * <scp> task didn't report build file location when a remote operation failed
    Bugzilla Report 48578.
 
  * <propertyfile> would add the same comment and a date line each time
    it updated an existing property file.
    Bugzilla Report 48558.
 
  * <sound> didn't work properly in recent Java VMs.
    Bugzilla Report 48637.
 
 Other changes:
 --------------
 
 Changes from Ant 1.7.1 TO Ant 1.8.0RC1
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * if and unless attributes (on <target> as well as various tasks and other
    elements) have long permitted ${property} interpolation. Now, if the result
    evaluates to "true" or "false" (or "yes", "no", "on", "off"), that boolean
    value will be used; otherwise the traditional behavior of treating the value
    as a property name (defined ~ true, undefined ~ false) is used. Existing
    scripts could be broken if they perversely defined a property named "false"
    and expected if="false" to be true, or used if="true" expecting this to be
    triggered only if a property named "true" were defined.
 
  * Ant now requires Java 1.4 or later.
 
  * Improved handling of InterruptException (lets suppose someone/thing
    is trying to kill the thread when we receive an
    InterruptException), when an InterruptException is received, we do
    not wait anymore in a while loop till the end time has been
    reached.
    Bugzilla Report 42924.
 
  * Refactor PropertyHelper and introspection APIs to make extension
    more granular and support setting task/type attribute values to
    objects decoded by custom PropertyEvaluator delegates. Also add
    <propertyhelper> task for registering delegates and/or replacing
    the registered PropertyHelper instance.
    Bugzilla Report 42736.
 
  * Added a restricted form of typedef called <componentdef>. This
    allows definition of elements that can only be within tasks or
    types. This method is now used to define conditions, selectors,
    comparators and filterreaders. This means that tasks may now have
    nested conditions just by implementing the Condition interface,
    rather than extending ConditionBase. It also means that the use of
    namespaces for some of the selectors introduced in Ant 1.7.0 is no
    longer necessary.  Implementing this means that the DynamicElement
    work-around introduced in Ant 1.7.0 has been removed.
    Bugzilla Report 40511.
 
  * In the <touch> task when a <mapper> is used, the millis and
    datetime attributes now override the time of the source resource if
    provisioned.
    Bugzilla Report 43235.
 
  * Remove fall-back mechanism for references that are not resolved
    during normal runtime execution.
 
  * FileUtils.createTempFile now actually creates the file.
    The TempFile task still does not create the file by default, can be
    instructed to do so however using a new parameter.
    Bugzilla Report 33969.
 
  * A lock in Project ensured that a BuildListener's messageLogged
    method was only ever executed by a single thread at a time, while
    all other methods could be invoked by multiple threads
    simultaniously (while within <parallel>, for example).  This lock
    is no longer in place, messageLogged should be made thread-safe
    now.
 
  * <sql>'s onError="stop" no longer fails the build if an error
    occurs,  this is the main difference between stop and error and
    matches what the documentation implied.
    Bugzilla Report 24668.
 
  * Ant's configuration introspection mechanisms have been modified to prefer
    Resource and FileProvider attributes to plain java.io.File attributes;
    however the configuration-from-String behavior remains equivalent, rendering
    a FileResource.
 
  * CBZip2InputStream will now throw an IOException if
    passed in a null or empty InputStream to read from.
    Bugzilla Reports 32200.
 
  * <unzip> will now fail when trying to extract certain broken
    archives that would have been silently ignored in earlier version.
    Bugzilla Report 35000.
 
  * Ant's <zip> family of tasks tries to preserve the existing Unix
    permissions when updating archives or copying entries from one
    archive to another.
    Since not all archiving tools support storing Unix permissions in
    the same way that is used by Ant, sometimes the permissions read by
    Ant seem to be 0, which means nobody is allowed to do anything to
    the file or directory.
    If Ant now encounters a permission set of 0 it will assume that
    this is not the intended value and instead apply its own default
    values.  Ant used to create entries with 0 permissions itself.
    The <zip> family of tasks has a new attribute preserve0permissions
    that can be set to restore the old behavior.
    Bugzilla Report 42122.
 
  * If a batch containing multiple JUnit tests running inside a forked
    Java VM caused the VM to crash (or caused a timeout), the
    formatters would receive an error message for the last test in the
    batch.
    Ant will now pass in a test with the name "Batch-With-Multiple-Tests"
    instead - this is supposed to show more clearly that the last test
    may not have started at all.
    Bugzilla Report 45227.
 
  * If the number of minutes a build takes is bigger then 1000 Ant will
    no longer print a thousands separator in the "elapsed time"
    message.  It used to be the thousands separator of the current
    locale.
    Bugzilla Report 44659.
 
  * <symlink action="delete"> used to fail if the link was broken (i.e.
    pointing to a file or directory that no longer existed).  It will now
    silently try to remove the link.
    Bugzilla Report 41285.
 
  * <delete file="..."> used to log a warning and not delete broken
    symbolic links.  <delete dir="..."/> didn't even log a warning.
    The task will now try to delete them in both cases.
    Bugzilla Report 41285.
 
  * if the dir attribute of a <fileset> points to a symbolic link and
    followsymlinks is set to false, the fileset will no longer be
    scanned and always seem empty.
    Bugzilla Report 45741.
 
  * the .NET tasks that have been deprecated since Ant 1.7.0 have been
    removed, please use the stand-alone Antlib you can find at
    http://ant.apache.org/antlibs/dotnet/index.html
    instead.
 
  * the logic of closing streams connected to forked processes (read
    the input and output of <exec> and friends) has been changed to
    deal with cases where child processes of the forked processes live
    longer than their parents and keep Ant from exiting.
    It is unlikely but possible that the changed logic breaks stream
    handling on certain Java VMs.
    Bugzilla issue 5003.
 
  * <checksum>'s totalproperty was platform dependent because it relied
    on java.io.File#compareTo.  It has now been made platform
    independent, which means that totalPropery values obtained on
    Windows (and other systems where the sort order of File is not case
    sensitive) can be different from the values obtained with earlier
    versions of Ant.
    Bugzilla Report 36748.
 
  * globmapper didn't work properly if the "to" or "from" patterns
    didn't contain a "*".  In particular it implicitly added a * to the
    end of the pattern(s).  This is no longer the case.  If you relied
    on this behavior you will now need to explicitly specify the
    trailing "*".
    Bugzilla Report 46506.
 
  * <copy> silently ignored missing resources even with
    failOnError="true".  If your build tries to copy non-existant
    resources and you relied on this behavior you must now explicitly
    set failOnError to false.
    Bugzilla Report 47362.
 
  * Ant now prefers the java.runtime.version system property over
    java.vm.version for the Created-By Manifest attribute.
    Bugzilla Report 47632.
 
  * The <image> task now supports a nested mapper.  In order to
    implement this, the Java API of the task had to change so any
    custom subclass overriding the processFile method will need to
    adapt (by overriding the new two-arg processFile method).
    Bugzilla Report 23243.
 
  * A new property syntax can be used to set attributes from
    references: ${ant.ref:some-reference}
 
    In most cases this will yield the exact same result as 
    ${toString:some-reference} - only when an attribute setter method
    accepts an object type other than string and the project's
    reference is an Object of matching type the new syntax will pass in
    that object.
 
    If your build file already contains properties whose name starts
    with "ant.ref:" there is a potential for collision.  If your
    property has been set, normal property expansion will take
    precedence over the new syntax.  If the property has not been set
    and a reference with the postfix of your property name exists
    (i.e. in a very unlikely event) then the new syntax would yield a
    different result (an expanded property) than Ant 1.7.1 did.
 
  * A ProjectHelper implementation can now provide the default build file
    name it is expecting, and can specify if they can support a specific build
    file. So Ant is now capable of supporting several ProjectHelper
    implementations, deciding on which to use depending of the input build file.
 
  * Mapper-aware selectors (depends, different, present) now accept typedef'd
    FileNameMappers.
 
 Fixed bugs:
 -----------
 
  * The default logger was failing to print complete stack traces for
    exceptions other than BuildException when inside <ant> or
    <antcall>, thus omitting often important diagnostic
    information.
    Bugzilla 43398 (continued).
 
  * Better handling of package-info.class.
    Bugzilla Report 43114.
 
  * RPM task needed an inserted space between the define and the value.
    Bugzilla Report 46659.
 
  * Got rid of deadlock between in, out and err in the Redirector. 
    Bugzilla Report 44544.
 
  * Caused by AssertionError no longer filtered.
    Bugzilla Report 45631.
  
  * <zip> would sometimes recreate JARs unnecessarily.
    Bugzilla Report 45902.
 
  * <symlink> task couldn't overwrite existing symlinks that pointed to
    nonexistent files
    Bugzilla Report 38199.
 
  * <symlink> task couldn't overwrite files that were in the way of the symlink.
    Bugzilla Report 43426.
 
  * <symlink> task failonerror="false" does not stop build from failing
    when 'ln' command returns non-zero.
    Bugzilla Report 43624
 
  * <touch> task couldn't differentiate between "no resources
    specified" and "no resources matched."
    Bugzilla Report 43799.
 
  * ManifestClassPath failed when a relative path would traverse the
    file system root.
    Bugzilla Report 44499.
 
  * <globmapper> had an indexoutofbounds when the prefix and postfix
    overlapped.
    Bugzilla Report 44731.
 
  * <typedef> and <taskdef> failed to accept file names with #
    characters in them.
    Bugzilla Report 45190
 
  * A deadlock could occur if a BuildListener tried to access an Ant property
    within messageLogged while a different thread also accessed one.
    Bugzilla Report 45194
 
  * Handle null result of system getProperty() in CommandlineJava.
    Similar to Bugzilla Report 42334.
 
  * Length task did not process nonexistent Resources even though these might
    conceivably still carry file length information.
    Bugzilla Report 45271.
 
  * <javac>'s includeJavaRuntime="false" should work for gcj now.  Note
    that you may need to set includeAntRuntime to false in order to
    have full control.
    Bugzilla Report 34638.
 
  * <sql> would fail if the executed statment didn't return a result
    set with some JDBC driver that dissalow Statement.getResultSet to
    be called in such a situation.
    Bugzilla Report 36265 
 
  * if the executed statement in <sql> returned a result set and an
    update count, the count would be lost.
 
  * if an executed statement in <sql> mixes update count and result set
    parts, some result sets wouldn't get printed.
    Bugzilla Report 32168.
 
  * XmlLogger could lose messages if <parallel> is used.
diff --git a/contributors.xml b/contributors.xml
index 9e970355a..f726989c6 100644
--- a/contributors.xml
+++ b/contributors.xml
@@ -1,1322 +1,1326 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 -->
 <!DOCTYPE contributors
 [
 <!ELEMENT name (first?, middle?, last)>
 <!ELEMENT contributors (introduction, name+)>
 <!ELEMENT first (#PCDATA)>
 <!ELEMENT introduction (#PCDATA)>
 <!ELEMENT middle (#PCDATA)>
 <!ELEMENT last (#PCDATA)>
 ]
 >
 
 <contributors>
   <introduction>
   These are some of the many people who have helped Ant become so successful.
   </introduction>
   <name>
     <first>Adam</first>
     <last>Blinkinsop</last>
   </name>
   <name>
     <first>Adam</first>
     <last>Bryzak</last>
   </name>
   <name>
     <first>Adam</first>
     <last>Sotona</last>
   </name>
   <name>
     <first>Aleksandr</first>
     <last>Ishutin</last>
   </name>
   <name>
     <first>Alex</first>
     <last>Rosen</last>
   </name>
   <name>
     <first>Alexei</first>
     <last>Yudichev</last>
   </name>
   <name>
     <first>Alexey</first>
     <last>Panchenko</last>
   </name>
   <name>
     <first>Alexey</first>
     <last>Solofnenko</last>
   </name>
   <name>
     <first>Alfred</first>
     <last>Theorin</last>
   </name>
   <name>
     <first>Alison</first>
     <last>Winters</last>
   </name>
   <name>
     <first>Andreas</first>
     <last>Ames</last>
   </name>
   <name>
     <first>Andrew</first>
     <last>Eisenberg</last>
   </name>
   <name>
     <first>Andrew</first>
     <last>Everitt</last>
   </name>
   <name>
     <first>Andrew</first>
     <last>Stevens</last>
   </name>
   <name>
     <first>Andrey</first>
     <last>Urazov</last>
   </name>
   <name>
     <first>Andy</first>
     <last>Wood</last>
   </name>
   <name>
     <first>Anil</first>
     <middle>K.</middle>
     <last>Vijendran</last>
   </name>
   <name>
     <first>Anli</first>
     <last>Shundi</last>
   </name>
   <name>
     <first>Anthony</first>
     <last>Green</last>
   </name>
   <name>
     <first>Anthony</first>
     <last>Wat</last>
   </name>
   <name>
     <first>Antoine</first>
     <last>Baudoux</last>
   </name>
   <name>
     <first>Antoine</first>
     <last>Levy-Lambert</last>
   </name>
   <name>
     <first>Anton</first>
     <last>Mazkovoi</last>
   </name>
   <name>
     <first>Arjan</first>
     <last>Veenstra</last>
   </name>
   <name>
     <first>Arnaud</first>
     <last>Vandyck</last>
   </name>
   <name>
     <first>Arnout</first>
     <middle>J.</middle>
     <last>Kuiper</last>
   </name>
   <name>
     <first>Aslak</first>
     <last>Helles&#244;y</last>
   </name>
   <name>
     <first>Atsuhiko</first>
     <last>Yamanaka</last>
   </name>
   <name>
     <first>Avik</first>
     <last>Sengupta</last>
   </name>
   <name>
     <first>Balazs</first>
     <last>Fejes 2</last>
   </name>
   <name>
     <first>Bart</first>
     <last>Vanhaute</last>
   </name>
   <name>
     <first>Benjamin</first>
     <last>Burgess</last>
   </name>
   <name>
     <first>Ben</first>
     <last>Galbraith</last>
   </name>
   <name>
     <first>Benoit</first>
     <last>Moussaud</last>
   </name>
   <name>
     <first>Bernd</first>
     <last>Dutkowski</last>
   </name>
   <name>
     <first>Bernhard</first>
     <last>Rosenkraenzer</last>
   </name>
   <name>
     <first>Brad</first>
     <last>Clark</last>
   </name>
   <name>
     <first>Brant</first>
     <middle>Langer</middle>
     <last>Gurganus</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Curnow</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Deitte</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Felder</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Repko</last>
   </name>
   <name>
     <first>Bruce</first>
     <last>Atherton</last>
   </name>
   <name>
     <first>Charles</first>
     <last>Hudak</last>
   </name>
   <name>
     <first>Charlie</first>
     <last>Hubbard</last>
   </name>
   <name>
     <first>Chris</first>
     <last>Povirk</last>
   </name>
   <name>
     <first>Christian</first>
     <last>Knorr</last>
   </name>
   <name>
     <first>Christoph</first>
     <last>Wilhelms</last>
   </name>
   <name>
     <first>Christophe</first>
     <last>Labouisse</last>
   </name>
   <name>
     <first>Christopher</first>
     <middle>A.</middle>
     <last>Longo</last>
   </name>
   <name>
     <first>Christopher</first>
     <last>Charlier</last>
   </name>
   <name>
     <first>Clark</first>
     <last>Archer</last>
   </name>
   <name>
     <first>Clemens</first>
     <last>Hammacher</last>
   </name>
   <name>
     <first>Clement</first>
     <last>OUDOT</last>
   </name>
   <name>
     <first>Conor</first>
     <last>MacNeill</last>
   </name>
   <name>
     <first>Craeg</first>
     <last>Strong</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Cottingham</last>
   </name>
   <name>
     <first>Craig</first>
     <middle>R.</middle>
     <last>McClanahan</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Ryan</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Richardson</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Sandvik</last>
   </name>
   <name>
     <first>Curt</first>
     <last>Arnold</last>
   </name>
   <name>
     <first>Curtis</first>
     <last>White</last>
   </name>
   <name>
     <first>Cyrille</first>
     <last>Morvan</last>
   </name>
   <name>
     <first>D'Arcy</first>
     <last>Smith</last>
   </name>
   <name>
     <first>Dale</first>
     <last>Anson</last>
   </name>
   <name>
     <first>Dale</first>
     <last>Sherwood</last>
   </name>
   <name>
     <first>Dan</first>
     <last>Armbrust</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Henrique</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Ribagnac</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Spilker</last>
   </name>
   <name>
+    <first>Daniel</first>
+    <last>Trebbien</last>
+  </name>
+  <name>
     <first>Danno</first>
     <last>Ferrin</last>
   </name>
   <name>
     <first>Danny</first>
     <last>Yates</last>
   </name>
   <name>
     <first>Dante</first>
     <last>Briones</last>
   </name>
   <name>
     <first>Davanum</first>
     <last>Srinivas</last>
   </name>
   <name>
     <first>Dave</first>
     <last>Brondsema</last>
   </name>
   <name>
     <first>Dave</first>
     <last>Brosius</last>
   </name>
   <name>
     <first>David</first>
     <last>A.</last>
   </name>
   <name>
     <first>David</first>
     <last>Crossley</last>
   </name>
   <name>
     <first>David</first>
     <last>G&#228;rtner</last>
   </name>
   <name>
     <first>David</first>
     <middle>S.</middle>
     <last>Johnson</last>
   </name>
   <name>
     <first>David</first>
     <last>Kavanagh</last>
   </name>
   <name>
     <first>David</first>
     <last>LeRoy</last>
   </name>
   <name>
     <first>David</first>
     <last>Leal</last>
   </name>
   <name>
     <first>David</first>
     <middle>M.</middle>
     <last>Lloyd</last>
   </name>
   <name>
     <first>David</first>
     <last>Maclean</last>
   </name>
   <name>
     <first>David</first>
     <last>Rees</last>
   </name>
   <name>
     <first>Denis</first>
     <last>Hennessy</last>
   </name>
   <name>
     <first>Derek</first>
     <last>Slager</last>
   </name>
   <name>
     <first>Devon</first>
     <middle>C.</middle>
     <last>Miller</last>
   </name>
   <name>
     <first>Diane</first>
     <last>Holt</last>
   </name>
   <name>
     <first>dIon</first>
     <last>Gillard</last>
   </name>
   <name>
     <first>Dmitry</first>
     <middle>A.</middle>
     <last>Kuminov</last>
   </name>
   <name>
     <first>Dominique</first>
     <last>Devienne</last>
   </name>
   <name>
     <first>Donal</first>
     <last>Quinlan</last>
   </name>
   <name>
     <first>Don</first>
     <last>Bnamen</last>
   </name>
   <name>
     <first>Don</first>
     <last>Ferguson</last>
   </name>
   <name>
     <first>Don</first>
     <last>Jeffery</last>
   </name>
   <name>
     <first>Drew</first>
     <last>Sudell</last>
   </name>
   <name>
     <first>Eduard</first>
     <last>Wirch</last>
   </name>
   <name>
     <first>Edwin</first>
     <last>Woudt</last>
   </name>
   <name>
     <first>Eli</first>
     <last>Tucker</last>
   </name>
   <name>
     <first>Emmanuel</first>
     <last>Bourg</last>
   </name>
   <name>
     <first>Eric</first>
     <last>Olsen</last>
   </name>
   <name>
     <first>Eric</first>
     <last>Pugh</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Hatcher</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Langenbach</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Meade</last>
   </name>
   <name>
     <first>Ernst</first>
     <last>de Haan</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Harnack</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Somers</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Zeyda</last>
   </name>
   <name>
     <first>Frédéric</first>
     <last>Bothamy</last>
   </name>
   <name>
     <first>Frederic</first>
     <last>Lavigne</last>
   </name>
   <name>
     <first>Gary</first>
     <middle>S.</middle>
     <last>Weaver</last>
   </name>
   <name>
     <first>Gautam</first>
     <last>Guliani</last>
   </name>
   <name>
     <first>Gene-Sung</first>
     <last>Chung</last>
   </name>
   <name>
     <first>Georges-Etienne</first>
     <last>Legendre</last>
   </name>
   <name>
     <first>Gero</first>
     <last>Vermaas</last>
   </name>
   <name>
     <first>Gerrit</first>
     <last>Riessen</last>
   </name>
   <name>
     <first>Gilbert</first>
     <last>Rebhan</last>
   </name>
   <name>
     <first>Gilles</first>
     <last>Scokart</last>
   </name>
   <name>
     <first>Glenn</first>
     <last>McAllister</last>
   </name>
   <name>
     <first>Glenn</first>
     <last>Twiggs</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Nelson</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Roodt</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Schueler</last>
   </name>
   <name>
     <first>Günther</first>
     <last>Kögel</last>
   </name>
   <name>
     <first>Harish</first>
     <last>Prabandham</last>
   </name>
   <name>
     <first>Haroon</first>
     <last>Rafique</last>
   </name>
   <name>
     <first>Hiroaki</first>
     <last>Nakamura</last>
   </name>
   <name>
     <first>Holger</first>
     <last>Engels</last>
   </name>
   <name>
     <first>Holger</first>
     <last>Joest</last>
   </name>
   <name>
     <first>Ignacio</first>
     <last>Coloma</last>
   </name>
   <name>
     <first>Ingenonsya</first>
     <last>France</last>
   </name>
   <name>
     <first>Ingmar</first>
     <last>Stein</last>
   </name>
   <name>
     <first>Irene</first>
     <last>Rusman</last>
   </name>
   <name>
     <first>Ivan</first>
     <last>Ivanov</last>
   </name>
   <name>
     <first>J</first>
     <last>Bleijenbergh</last>
   </name>
   <name>
     <first>Jack</first>
     <middle>J.</middle>
     <last>Woehr</last>
   </name>
   <name>
     <first>James</first>
     <middle>Duncan</middle>
     <last>Davidson</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Mat&#232;rne</last>
   </name>
     <name>
       <first>Jan</first>
       <last>Cumps</last>
     </name>
   <name>
     <first>Jan</first>
     <last>Mynarik</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Hunter</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Pettiss</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Salter</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Yip</last>
   </name>
   <name>
     <first>Jay</first>
     <middle>Dickon</middle>
     <last>Glanville</last>
   </name>
   <name>
     <first>Jay</first>
     <last>Peck</last>
   </name>
   <name>
     <first>Jay</first>
     <last>van der Meer</last>
   </name>
   <name>
     <first>JC</first>
     <last>Mann</last>
   </name>
   <name>
     <first>J</first>
     <last>D</last>
   </name>
   <name>
     <first>Jean-Francois</first>
     <last>Brousseau</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Gettle</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Martin</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Tulley</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Turner</last>
   </name>
   <name>
     <first>Jene</first>
     <last>Jasper</last>
   </name>
   <name>
     <first>Jeremy</first>
     <last>Mawson</last>
   </name>
   <name>
     <first>Jerome</first>
     <last>Lacoste</last>
   </name>
   <name>
     <first>Jesse</first>
     <last>Glick</last>
   </name>
   <name>
     <first>Jesse</first>
     <last>Stockall</last>
   </name>
   <name>
     <first>Jim</first>
     <last>Allers</last>
   </name>
   <name>
     <first>Joerg</first>
     <last>Wassmer</last>
   </name>
   <name>
     <first>Joey</first>
     <last>Richey</last>
   </name>
   <name>
     <first>Johann</first>
     <last>Herunter</last>
   </name>
   <name>
     <first>John</first>
     <last>Sisson</last>
   </name>
   <name>
     <first>Jon</first>
     <last>Dickinson</last>
   </name>
   <name>
     <first>Jon</first>
     <last>Skeet</last>
   </name>
   <name>
     <first>Jon</first>
     <middle>S.</middle>
     <last>Stevens</last>
   </name>
   <name>
     <first>Jose</first>
     <middle>Alberto</middle>
     <last>Fernandez</last>
   </name>
   <name>
     <first>Josh</first>
     <last>Lucas</last>
   </name>
   <name>
     <first>Joseph</first>
     <last>Walton</last>
   </name>
   <name>
     <first>Juerg</first>
     <last>Wanner</last>
   </name>
   <name>
     <first>Julian</first>
     <last>Simpson</last>
   </name>
   <name>
     <first>Justin</first>
     <last>Vallon</last>
   </name>
   <name>
     <first>Keiron</first>
     <last>Liddle</last>
   </name>
   <name>
     <first>Keith</first>
     <last>Visco</last>
   </name>
   <name>
     <first>Kevin</first>
     <middle>Connor</middle>
     <last>Arpe</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Greiner</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Jackson</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Ross</last>
   </name>
   <name>
     <first>Kevin</first>
     <middle>Z</middle>
     <last>Grey</last>
   </name>
   <name>
     <first>Kim</first>
     <last>Hansen</last>
   </name>
   <name>
     <first>Kirk</first>
     <last>Wylie</last>
   </name>
   <name>
     <first>Kyle</first>
     <last>Adams</last>
   </name>
   <name>
     <first>Larry</first>
     <last>Shatzer</last>
   </name>
   <name>
     <first>Larry</first>
     <last>Streepy</last>
   </name>
   <name>
     <first>Les</first>
     <last>Hughes</last>
   </name>
   <name>
     <first>Levi</first>
     <last>Cook</last>
   </name>
   <name>
     <last>lucas</last>
   </name>
   <name>
     <first>Ludovic</first>
     <last>Claude</last>
   </name>
   <name>
     <first>Magesh</first>
     <last>Umasankar</last>
   </name>
   <name>
     <first>Maneesh</first>
     <last>Sahu</last>
   </name>
   <name>
     <first>Marcel</first>
     <last>Schutte</last>
   </name>
   <name>
     <first>Marcus</first>
     <last>Börger</last>
   </name>
   <name>
     <first>Mario</first>
     <last>Frasca</last>
   </name>
   <name>
     <first>Mariusz</first>
     <last>Nowostawski</last>
   </name>
   <name>
     <first>Mark</first>
     <last>DeLaFranier</last>
   </name>
   <name>
     <first>Mark</first>
     <last>Hecker</last>
   </name>
   <name>
     <first>Mark</first>
     <last>Salter</last>
   </name>
   <name>
     <first>Mark</first>
     <middle>R.</middle>
     <last>Diggory</last>
   </name>
   <name>
     <first>Mark</first>
     <middle>A.</middle>
     <last>Ziesemer</last>
   </name>
   <name>
     <first>Markus</first>
     <last>Kahl</last>
   </name>
   <name>
     <first>Martijn</first>
     <last>Kruithof</last>
   </name>
   <name>
     <first>Martin</first>
     <last>Landers</last>
   </name>
   <name>
     <first>Martin</first>
     <last>Poeschl</last>
   </name>
   <name>
     <first>Martin</first>
     <last>van den Bemt</last>
   </name>
   <name>
     <first>Martin</first>
     <last>von Gagern</last>
   </name>
   <name>
     <first>Mathieu</first>
     <last>Champlon</last>
   </name>
   <name>
     <first>Mathieu</first>
     <last>Peltier</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Albrecht</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Benson</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Bishop</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Foemmel</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Grosso</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Humphrey</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Small</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Hawthorne</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Inger</last>
   </name>
   <name>
     <first>Matthew</first>
     <middle>Kuperus</middle>
     <last>Heun</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Watson</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Bayne</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Davey</last>
   </name>
   <name>
     <first>Michael</first>
     <middle>J.</middle>
     <last>Sikorsky</last>
   </name>
   <name>
     <first>Michael</first>
     <last>McCallum</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Newcomb</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Nygard</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Saunders</last>
   </name>
   <name>
     <last>Miha</last>
   </name>
   <name>
     <first>Mike</first>
     <last>Davis</last>
   </name>
   <name>
     <first>Mike</first>
     <last>Roberts</last>
   </name>
   <name>
     <last>mnowostawski</last>
   </name>
   <name>
     <first>Mounir</first>
     <last>El Hajj</last>
   </name>
   <name>
     <first>Nathan</first>
     <last>Beyer</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Chalko</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Crossley</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Fortescue</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Pellow</last>
   </name>
   <name>
     <first>Nicola</first>
     <last>Ken</last>
   </name>
   <name>
     <first>Nico</first>
     <last>Seessle</last>
   </name>
   <name>
     <first>Nigel</first>
     <last>Magnay</last>
   </name>
   <name>
     <first>Oliver</first>
     <last>Merkel</last>
   </name>
   <name>
     <first>Oliver</first>
     <last>Rossmueller</last>
   </name>
   <name>
     <first>Omer</first>
     <last>Shapira</last>
   </name>
   <name>
     <first>Ondra</first>
     <last>Medek</last>
   </name>
   <name>
     <first>&#216;ystein</first>
     <last>Gisn&#229;s</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>C.</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Chanezon</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Gus</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Austin</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Christmann</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Galbraith</last>
   </name>
   <name>
     <first>Paul</first>
     <last>King</last>
   </name>
   <name>
     <first>Paulo</first>
     <last>Gaspar</last>
   </name>
   <name>
     <first>Pavan</first>
     <last>Bayyapu</last>
   </name>
   <name>
     <first>Pavel</first>
     <last>Jisl</last>
   </name>
   <name>
     <first>Paweł</first>
     <last>Zuzelski</last>
   </name>
   <name>
     <first>Peter</first>
     <middle>B.</middle>
     <last>West</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Donald</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Doornbosch</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Hulst</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Janes</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Reilly</last>
   </name>
   <name>
     <first>Phil</first>
     <last>Hanna</last>
   </name>
   <name>
     <first>Philip</first>
     <last>Hourihane</last>
   </name>
   <name>
     <first>Phillip</first>
     <last>Wells</last>
   </name>
   <name>
     <first>Pierre</first>
     <last>Delisle</last>
   </name>
   <name>
     <first>Pierre</first>
     <last>Dittgen</last>
   </name>
   <name>
     <first>R</first>
     <last>Handerson</last>
   </name>
   <name>
     <first>Rami</first>
     <last>Ojares</last>
   </name>
   <name>
     <first>Randy</first>
     <last>Watler</last>
   </name>
   <name>
     <first>Raphael</first>
     <last>Pierquin</last>
   </name>
   <name>
     <first>Ray</first>
     <last>Waldin</last>
   </name>
   <name>
     <first>Remie</first>
     <last>Bolte</last>
   </name>
   <name>
     <first>Richard</first>
     <last>Evans</last>
   </name>
   <name>
     <first>Rick</first>
     <last>Beton</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Anderson</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Clark</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Flaherty</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Shaw</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Streich</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Watkins</last>
   </name>
   <name>
     <first>Roberto</first>
     <last>Scaramuzzi</last>
   </name>
   <name>
     <first>Robin</first>
     <last>Green</last>
   </name>
   <name>
     <first>Robin</first>
     <last>Verduijn</last>
   </name>
   <name>
     <first>Rob</first>
     <last>Oxspring</last>
   </name>
   <name>
     <first>Rob</first>
     <last>van Oostrum</last>
   </name>
   <name>
     <first>Rodrigo</first>
     <last>Schmidt</last>
   </name>
   <name>
     <first>Roger</first>
     <last>Vaughn</last>
   </name>
   <name>
     <first>Roman</first>
     <last>Ivashin</last>
   </name>
   <name>
     <first>Ronen</first>
     <last>Mashal</last>
   </name>
   <name>
     <first>Russell</first>
     <last>Gold</last>
   </name>
   <name>
     <first>Sam</first>
     <last>Ruby</last>
   </name>
   <name>
     <first>Sandra</first>
     <last>Metz</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Carlson</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Ellsworth</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Johnson</last>
   </name>
   <name>
     <first>Scott</first>
     <middle>M.</middle>
     <last>Stirling</last>
   </name>
   <name>
     <first>Sean</first>
     <last>Egan</last>
   </name>
   <name>
     <first>Sean</first>
     <middle>P.</middle>
     <last>Kane</last>
   </name>
   <name>
     <first>Sebastien</first>
     <last>Arod</last>
   </name>
   <name>
     <first>Shiraz</first>
     <last>Kanga</last>
   </name>
   <name>
     <first>Sebastian</first>
     <last>Kantha</last>
   </name>
   <name>
       <first>Simon</first>
       <last>Law</last>
   </name>
   <name>
     <first>Simone</first>
     <last>Bordet</last>
   </name>
   <name>
     <first>Stefan</first>
     <last>Bodewig</last>
   </name>
   <name>
     <first>Stefan</first>
     <last>Heimann</last>
   </name>
   <name>
     <first>Stefano</first>
     <last>Mazzocchi</last>
   </name>
   <name>
     <first>Stephan</first>
     <last>Strittmatter</last>
   </name>
   <name>
     <first>Stephane</first>
     <last>Bailliez</last>
   </name>
   <name>
     <last>stephan</last>
   </name>
   <name>
     <first>Stephan</first>
     <last>Michels</last>
   </name>
   <name>
     <first>Stephen</first>
     <last>Chin</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Cohen</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Langley</last>
   </name>
   <name>
     <first>Steve</first>
diff --git a/src/main/org/apache/tools/ant/taskdefs/Zip.java b/src/main/org/apache/tools/ant/taskdefs/Zip.java
index c20027220..a58ac1bf5 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Zip.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Zip.java
@@ -71,2028 +71,2033 @@ import org.apache.tools.zip.ZipOutputStream.UnicodeExtraFieldPolicy;
 /**
  * Create a Zip file.
  *
  * @since Ant 1.1
  *
  * @ant.task category="packaging"
  */
 public class Zip extends MatchingTask {
     private static final int BUFFER_SIZE = 8 * 1024;
     private static final int ROUNDUP_MILLIS = 1999; // 2 seconds - 1
     // CheckStyle:VisibilityModifier OFF - bc
 
     protected File zipFile;
     // use to scan own archive
     private ZipScanner zs;
     private File baseDir;
     protected Hashtable<String, String> entries = new Hashtable<String, String>();
     private Vector<FileSet> groupfilesets = new Vector<FileSet>();
     private Vector<ZipFileSet> filesetsFromGroupfilesets = new Vector<ZipFileSet>();
     protected String duplicate = "add";
     private boolean doCompress = true;
     private boolean doUpdate = false;
     // shadow of the above if the value is altered in execute
     private boolean savedDoUpdate = false;
     private boolean doFilesonly = false;
     protected String archiveType = "zip";
 
     // For directories:
     private static final long EMPTY_CRC = new CRC32 ().getValue ();
     protected String emptyBehavior = "skip";
     private Vector<ResourceCollection> resources = new Vector<ResourceCollection>();
     protected Hashtable<String, String> addedDirs = new Hashtable<String, String>();
     private Vector<String> addedFiles = new Vector<String>();
 
     private static final ResourceSelector MISSING_SELECTOR =
         new ResourceSelector() {
             public boolean isSelected(Resource target) {
                 return !target.isExists();
             }
         };
 
     private static final ResourceUtils.ResourceSelectorProvider
         MISSING_DIR_PROVIDER = new ResourceUtils.ResourceSelectorProvider() {
                 public ResourceSelector
                     getTargetSelectorForSource(Resource sr) {
                     return MISSING_SELECTOR;
                 }
             };
 
     /**
      * If this flag is true, execute() will run most operations twice,
      * the first time with {@link #skipWriting skipWriting} set to
      * true and the second time with setting it to false.
      *
      * <p>The only situation in Ant's current code base where this is
      * ever going to be true is if the jar task has been configured
      * with a filesetmanifest other than "skip".</p>
      */
     protected boolean doubleFilePass = false;
     /**
      * whether the methods should just perform some sort of dry-run.
      *
      * <p>Will only ever be true in the first pass if the task
      * performs two passes because {@link #doubleFilePass
      * doubleFilePass} is true.</p>
      */
     protected boolean skipWriting = false;
 
     /**
      * Whether this is the first time the archive building methods are invoked.
      *
      * @return true if either {@link #doubleFilePass doubleFilePass}
      * is false or {@link #skipWriting skipWriting} is true.
      *
      * @since Ant 1.8.0
      */
     protected final boolean isFirstPass() {
         return !doubleFilePass || skipWriting;
     }
 
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     // CheckStyle:VisibilityModifier ON
 
     // This boolean is set if the task detects that the
     // target is outofdate and has written to the target file.
     private boolean updatedFile = false;
 
     /**
      * true when we are adding new files into the Zip file, as opposed
      * to adding back the unchanged files
      */
     private boolean addingNewFiles = false;
 
     /**
      * Encoding to use for filenames, defaults to the platform's
      * default encoding.
      */
     private String encoding;
 
     /**
      * Whether the original compression of entries coming from a ZIP
      * archive should be kept (for example when updating an archive).
      *
      * @since Ant 1.6
      */
     private boolean keepCompression = false;
 
     /**
      * Whether the file modification times will be rounded up to the
      * next even number of seconds.
      *
      * @since Ant 1.6.2
      */
     private boolean roundUp = true;
 
     /**
      * Comment for the archive.
      * @since Ant 1.6.3
      */
     private String comment = "";
 
     private int level = ZipOutputStream.DEFAULT_COMPRESSION;
 
     /**
      * Assume 0 Unix mode is intentional.
      * @since Ant 1.8.0
      */
     private boolean preserve0Permissions = false;
 
     /**
      * Whether to set the language encoding flag when creating the archive.
      *
      * @since Ant 1.8.0
      */
     private boolean useLanguageEncodingFlag = true;
 
     /**
      * Whether to add unicode extra fields.
      *
      * @since Ant 1.8.0
      */
     private UnicodeExtraField createUnicodeExtraFields =
         UnicodeExtraField.NEVER;
 
     /**
      * Whether to fall back to UTF-8 if a name cannot be encoded using
      * the specified encoding.
      *
      * @since Ant 1.8.0
      */
     private boolean fallBackToUTF8 = false;
 
     /**
      * This is the name/location of where to
      * create the .zip file.
      * @param zipFile the path of the zipFile
      * @deprecated since 1.5.x.
      *             Use setDestFile(File) instead.
      * @ant.attribute ignore="true"
      */
     public void setZipfile(File zipFile) {
         setDestFile(zipFile);
     }
 
     /**
      * This is the name/location of where to
      * create the file.
      * @param file the path of the zipFile
      * @since Ant 1.5
      * @deprecated since 1.5.x.
      *             Use setDestFile(File) instead.
      * @ant.attribute ignore="true"
      */
     public void setFile(File file) {
         setDestFile(file);
     }
 
 
     /**
      * The file to create; required.
      * @since Ant 1.5
      * @param destFile The new destination File
      */
     public void setDestFile(File destFile) {
        this.zipFile = destFile;
     }
 
     /**
      * The file to create.
      * @return the destination file
      * @since Ant 1.5.2
      */
     public File getDestFile() {
         return zipFile;
     }
 
 
     /**
      * Directory from which to archive files; optional.
      * @param baseDir the base directory
      */
     public void setBasedir(File baseDir) {
         this.baseDir = baseDir;
     }
 
     /**
      * Whether we want to compress the files or only store them;
      * optional, default=true;
      * @param c if true, compress the files
      */
     public void setCompress(boolean c) {
         doCompress = c;
     }
 
     /**
      * Whether we want to compress the files or only store them;
      * @return true if the files are to be compressed
      * @since Ant 1.5.2
      */
     public boolean isCompress() {
         return doCompress;
     }
 
     /**
      * If true, emulate Sun's jar utility by not adding parent directories;
      * optional, defaults to false.
      * @param f if true, emulate sun's jar by not adding parent directories
      */
     public void setFilesonly(boolean f) {
         doFilesonly = f;
     }
 
     /**
      * If true, updates an existing file, otherwise overwrite
      * any existing one; optional defaults to false.
      * @param c if true, updates an existing zip file
      */
     public void setUpdate(boolean c) {
         doUpdate = c;
         savedDoUpdate = c;
     }
 
     /**
      * Are we updating an existing archive?
      * @return true if updating an existing archive
      */
     public boolean isInUpdateMode() {
         return doUpdate;
     }
 
     /**
      * Adds a set of files.
      * @param set the fileset to add
      */
     public void addFileset(FileSet set) {
         add(set);
     }
 
     /**
      * Adds a set of files that can be
      * read from an archive and be given a prefix/fullpath.
      * @param set the zipfileset to add
      */
     public void addZipfileset(ZipFileSet set) {
         add(set);
     }
 
     /**
      * Add a collection of resources to be archived.
      * @param a the resources to archive
      * @since Ant 1.7
      */
     public void add(ResourceCollection a) {
         resources.add(a);
     }
 
     /**
      * Adds a group of zip files.
      * @param set the group (a fileset) to add
      */
     public void addZipGroupFileset(FileSet set) {
         groupfilesets.addElement(set);
     }
 
     /**
      * Sets behavior for when a duplicate file is about to be added -
      * one of <code>add</code>, <code>preserve</code> or <code>fail</code>.
      * Possible values are: <code>add</code> (keep both
      * of the files); <code>preserve</code> (keep the first version
      * of the file found); <code>fail</code> halt a problem
      * Default for zip tasks is <code>add</code>
      * @param df a <code>Duplicate</code> enumerated value
      */
     public void setDuplicate(Duplicate df) {
         duplicate = df.getValue();
     }
 
     /**
      * Possible behaviors when there are no matching files for the task:
      * "fail", "skip", or "create".
      */
     public static class WhenEmpty extends EnumeratedAttribute {
         /**
          * The string values for the enumerated value
          * @return the values
          */
         public String[] getValues() {
             return new String[] {"fail", "skip", "create"};
         }
     }
 
     /**
      * Sets behavior of the task when no files match.
      * Possible values are: <code>fail</code> (throw an exception
      * and halt the build); <code>skip</code> (do not create
      * any archive, but issue a warning); <code>create</code>
      * (make an archive with no entries).
      * Default for zip tasks is <code>skip</code>;
      * for jar tasks, <code>create</code>.
      * @param we a <code>WhenEmpty</code> enumerated value
      */
     public void setWhenempty(WhenEmpty we) {
         emptyBehavior = we.getValue();
     }
 
     /**
      * Encoding to use for filenames, defaults to the platform's
      * default encoding.
      *
      * <p>For a list of possible values see <a
      * href="http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html">http://java.sun.com/j2se/1.5.0/docs/guide/intl/encoding.doc.html</a>.</p>
      * @param encoding the encoding name
      */
     public void setEncoding(String encoding) {
         this.encoding = encoding;
     }
 
     /**
      * Encoding to use for filenames.
      * @return the name of the encoding to use
      * @since Ant 1.5.2
      */
     public String getEncoding() {
         return encoding;
     }
 
     /**
      * Whether the original compression of entries coming from a ZIP
      * archive should be kept (for example when updating an archive).
      * Default is false.
      * @param keep if true, keep the original compression
      * @since Ant 1.6
      */
     public void setKeepCompression(boolean keep) {
         keepCompression = keep;
     }
 
     /**
      * Comment to use for archive.
      *
      * @param comment The content of the comment.
      * @since Ant 1.6.3
      */
     public void setComment(String comment) {
         this.comment = comment;
     }
 
     /**
      * Comment of the archive
      *
      * @return Comment of the archive.
      * @since Ant 1.6.3
      */
     public String getComment() {
         return comment;
     }
 
     /**
      * Set the compression level to use.  Default is
      * ZipOutputStream.DEFAULT_COMPRESSION.
      * @param level compression level.
      * @since Ant 1.7
      */
     public void setLevel(int level) {
         this.level = level;
     }
 
     /**
      * Get the compression level.
      * @return compression level.
      * @since Ant 1.7
      */
     public int getLevel() {
         return level;
     }
 
     /**
      * Whether the file modification times will be rounded up to the
      * next even number of seconds.
      *
      * <p>Zip archives store file modification times with a
      * granularity of two seconds, so the times will either be rounded
      * up or down.  If you round down, the archive will always seem
      * out-of-date when you rerun the task, so the default is to round
      * up.  Rounding up may lead to a different type of problems like
      * JSPs inside a web archive that seem to be slightly more recent
      * than precompiled pages, rendering precompilation useless.</p>
      * @param r a <code>boolean</code> value
      * @since Ant 1.6.2
      */
     public void setRoundUp(boolean r) {
         roundUp = r;
     }
 
     /**
      * Assume 0 Unix mode is intentional.
      * @since Ant 1.8.0
      */
     public void setPreserve0Permissions(boolean b) {
         preserve0Permissions = b;
     }
 
     /**
      * Assume 0 Unix mode is intentional.
      * @since Ant 1.8.0
      */
     public boolean getPreserve0Permissions() {
         return preserve0Permissions;
     }
 
     /**
      * Whether to set the language encoding flag.
      * @since Ant 1.8.0
      */
     public void setUseLanguageEncodingFlag(boolean b) {
         useLanguageEncodingFlag = b;
     }
 
     /**
      * Whether the language encoding flag will be used.
      * @since Ant 1.8.0
      */
     public boolean getUseLanguageEnodingFlag() {
         return useLanguageEncodingFlag;
     }
 
     /**
      * Whether Unicode extra fields will be created.
      * @since Ant 1.8.0
      */
     public void setCreateUnicodeExtraFields(UnicodeExtraField b) {
         createUnicodeExtraFields = b;
     }
 
     /**
      * Whether Unicode extra fields will be created.
      * @since Ant 1.8.0
      */
     public UnicodeExtraField getCreateUnicodeExtraFields() {
         return createUnicodeExtraFields;
     }
 
     /**
      * Whether to fall back to UTF-8 if a name cannot be encoded using
      * the specified encoding.
      *
      * <p>Defaults to false.</p>
      *
      * @since Ant 1.8.0
      */
     public void setFallBackToUTF8(boolean b) {
         fallBackToUTF8 = b;
     }
 
     /**
      * Whether to fall back to UTF-8 if a name cannot be encoded using
      * the specified encoding.
      *
      * @since Ant 1.8.0
      */
     public boolean getFallBackToUTF8() {
         return fallBackToUTF8;
     }
 
     /**
      * validate and build
      * @throws BuildException on error
      */
     public void execute() throws BuildException {
 
         if (doubleFilePass) {
             skipWriting = true;
             executeMain();
             skipWriting = false;
             executeMain();
         } else {
             executeMain();
         }
     }
 
     /**
      * Get the value of the updatedFile attribute.
      * This should only be called after executeMain has been
      * called.
      * @return true if executeMain has written to the zip file.
      */
     protected boolean hasUpdatedFile() {
         return updatedFile;
     }
 
     /**
      * Build the zip file.
      * This is called twice if doubleFilePass is true.
      * @throws BuildException on error
      */
     public void executeMain() throws BuildException {
 
         checkAttributesAndElements();
 
         // Renamed version of original file, if it exists
         File renamedFile = null;
         addingNewFiles = true;
 
         processDoUpdate();
         processGroupFilesets();
 
         // collect filesets to pass them to getResourcesToAdd
         Vector<ResourceCollection> vfss = new Vector<ResourceCollection>();
         if (baseDir != null) {
             FileSet fs = (FileSet) getImplicitFileSet().clone();
             fs.setDir(baseDir);
             vfss.addElement(fs);
         }
         final int size = resources.size();
         for (int i = 0; i < size; i++) {
             ResourceCollection rc = (ResourceCollection) resources.elementAt(i);
             vfss.addElement(rc);
         }
 
         ResourceCollection[] fss = new ResourceCollection[vfss.size()];
         vfss.copyInto(fss);
         boolean success = false;
         try {
             // can also handle empty archives
             ArchiveState state = getResourcesToAdd(fss, zipFile, false);
 
             // quick exit if the target is up to date
             if (!state.isOutOfDate()) {
                 return;
             }
 
             File parent = zipFile.getParentFile();
             if (parent != null && !parent.isDirectory() && !parent.mkdirs()) {
                 throw new BuildException("Failed to create missing parent"
                                          + " directory for " + zipFile);
             }
 
             updatedFile = true;
             if (!zipFile.exists() && state.isWithoutAnyResources()) {
                 createEmptyZip(zipFile);
                 return;
             }
             Resource[][] addThem = state.getResourcesToAdd();
 
             if (doUpdate) {
                 renamedFile = renameFile();
             }
 
             String action = doUpdate ? "Updating " : "Building ";
 
             if (!skipWriting) {
                 log(action + archiveType + ": " + zipFile.getAbsolutePath());
             }
 
             ZipOutputStream zOut = null;
             try {
                 if (!skipWriting) {
                     zOut = new ZipOutputStream(zipFile);
 
                     zOut.setEncoding(encoding);
                     zOut.setUseLanguageEncodingFlag(useLanguageEncodingFlag);
                     zOut.setCreateUnicodeExtraFields(createUnicodeExtraFields.
                                                      getPolicy());
                     zOut.setFallbackToUTF8(fallBackToUTF8);
                     zOut.setMethod(doCompress
                         ? ZipOutputStream.DEFLATED : ZipOutputStream.STORED);
                     zOut.setLevel(level);
                 }
                 initZipOutputStream(zOut);
 
                 // Add the explicit resource collections to the archive.
                 for (int i = 0; i < fss.length; i++) {
                     if (addThem[i].length != 0) {
                         addResources(fss[i], addThem[i], zOut);
                     }
                 }
 
                 if (doUpdate) {
                     addingNewFiles = false;
                     ZipFileSet oldFiles = new ZipFileSet();
                     oldFiles.setProject(getProject());
                     oldFiles.setSrc(renamedFile);
                     oldFiles.setDefaultexcludes(false);
 
                     final int addSize = addedFiles.size();
                     for (int i = 0; i < addSize; i++) {
                         PatternSet.NameEntry ne = oldFiles.createExclude();
                         ne.setName((String) addedFiles.elementAt(i));
                     }
                     DirectoryScanner ds =
                         oldFiles.getDirectoryScanner(getProject());
                     ((ZipScanner) ds).setEncoding(encoding);
 
                     String[] f = ds.getIncludedFiles();
                     Resource[] r = new Resource[f.length];
                     for (int i = 0; i < f.length; i++) {
                         r[i] = ds.getResource(f[i]);
                     }
 
                     if (!doFilesonly) {
                         String[] d = ds.getIncludedDirectories();
                         Resource[] dr = new Resource[d.length];
                         for (int i = 0; i < d.length; i++) {
                             dr[i] = ds.getResource(d[i]);
                         }
                         Resource[] tmp = r;
                         r = new Resource[tmp.length + dr.length];
                         System.arraycopy(dr, 0, r, 0, dr.length);
                         System.arraycopy(tmp, 0, r, dr.length, tmp.length);
                     }
                     addResources(oldFiles, r, zOut);
                 }
                 if (zOut != null) {
                     zOut.setComment(comment);
                 }
                 finalizeZipOutputStream(zOut);
 
                 // If we've been successful on an update, delete the
                 // temporary file
                 if (doUpdate) {
                     if (!renamedFile.delete()) {
                         log ("Warning: unable to delete temporary file "
                             + renamedFile.getName(), Project.MSG_WARN);
                     }
                 }
                 success = true;
             } finally {
                 // Close the output stream.
                 closeZout(zOut, success);
             }
         } catch (IOException ioe) {
             String msg = "Problem creating " + archiveType + ": "
                 + ioe.getMessage();
 
             // delete a bogus ZIP file (but only if it's not the original one)
             if ((!doUpdate || renamedFile != null) && !zipFile.delete()) {
                 msg += " (and the archive is probably corrupt but I could not "
                     + "delete it)";
             }
 
             if (doUpdate && renamedFile != null) {
                 try {
                     FILE_UTILS.rename(renamedFile, zipFile);
                 } catch (IOException e) {
                     msg += " (and I couldn't rename the temporary file "
                             + renamedFile.getName() + " back)";
                 }
             }
 
             throw new BuildException(msg, ioe, getLocation());
         } finally {
             cleanUp();
         }
     }
 
     /** rename the zip file. */
     private File renameFile() {
         File renamedFile = FILE_UTILS.createTempFile(
             "zip", ".tmp", zipFile.getParentFile(), true, false);
         try {
             FILE_UTILS.rename(zipFile, renamedFile);
         } catch (SecurityException e) {
             throw new BuildException(
                 "Not allowed to rename old file ("
                 + zipFile.getAbsolutePath()
                 + ") to temporary file");
         } catch (IOException e) {
             throw new BuildException(
                 "Unable to rename old file ("
                 + zipFile.getAbsolutePath()
                 + ") to temporary file");
         }
         return renamedFile;
     }
 
     /** Close zout */
     private void closeZout(ZipOutputStream zOut, boolean success)
         throws IOException {
         if (zOut == null) {
             return;
         }
         try {
             zOut.close();
         } catch (IOException ex) {
             // If we're in this finally clause because of an
             // exception, we don't really care if there's an
             // exception when closing the stream. E.g. if it
             // throws "ZIP file must have at least one entry",
             // because an exception happened before we added
             // any files, then we must swallow this
             // exception. Otherwise, the error that's reported
             // will be the close() error, which is not the
             // real cause of the problem.
             if (success) {
                 throw ex;
             }
         }
     }
 
     /** Check the attributes and elements */
     private void checkAttributesAndElements() {
         if (baseDir == null && resources.size() == 0
             && groupfilesets.size() == 0 && "zip".equals(archiveType)) {
             throw new BuildException("basedir attribute must be set, "
                                      + "or at least one "
                                      + "resource collection must be given!");
         }
 
         if (zipFile == null) {
             throw new BuildException("You must specify the "
                                      + archiveType + " file to create!");
         }
 
         if (zipFile.exists() && !zipFile.isFile()) {
             throw new BuildException(zipFile + " is not a file.");
         }
 
         if (zipFile.exists() && !zipFile.canWrite()) {
             throw new BuildException(zipFile + " is read-only.");
         }
     }
 
     /** Process doupdate */
     private void processDoUpdate() {
         // Whether or not an actual update is required -
         // we don't need to update if the original file doesn't exist
         if (doUpdate && !zipFile.exists()) {
             doUpdate = false;
             logWhenWriting("ignoring update attribute as " + archiveType
                            + " doesn't exist.", Project.MSG_DEBUG);
         }
     }
 
     /** Process groupfilesets */
     private void processGroupFilesets() {
         // Add the files found in groupfileset to fileset
         final int size = groupfilesets.size();
         for (int i = 0; i < size; i++) {
 
             logWhenWriting("Processing groupfileset ", Project.MSG_VERBOSE);
             FileSet fs = (FileSet) groupfilesets.elementAt(i);
             FileScanner scanner = fs.getDirectoryScanner(getProject());
             String[] files = scanner.getIncludedFiles();
             File basedir = scanner.getBasedir();
             for (int j = 0; j < files.length; j++) {
 
                 logWhenWriting("Adding file " + files[j] + " to fileset",
                                Project.MSG_VERBOSE);
                 ZipFileSet zf = new ZipFileSet();
                 zf.setProject(getProject());
                 zf.setSrc(new File(basedir, files[j]));
                 add(zf);
                 filesetsFromGroupfilesets.addElement(zf);
             }
         }
     }
 
     /**
      * Indicates if the task is adding new files into the archive as opposed to
      * copying back unchanged files from the backup copy
      * @return true if adding new files
      */
     protected final boolean isAddingNewFiles() {
         return addingNewFiles;
     }
 
     /**
      * Add the given resources.
      *
      * @param fileset may give additional information like fullpath or
      * permissions.
      * @param resources the resources to add
      * @param zOut the stream to write to
      * @throws IOException on error
      *
      * @since Ant 1.5.2
      */
     protected final void addResources(FileSet fileset, Resource[] resources,
                                       ZipOutputStream zOut)
         throws IOException {
 
         String prefix = "";
         String fullpath = "";
         int dirMode = ArchiveFileSet.DEFAULT_DIR_MODE;
         int fileMode = ArchiveFileSet.DEFAULT_FILE_MODE;
 
         ArchiveFileSet zfs = null;
         if (fileset instanceof ArchiveFileSet) {
             zfs = (ArchiveFileSet) fileset;
             prefix = zfs.getPrefix(getProject());
             fullpath = zfs.getFullpath(getProject());
             dirMode = zfs.getDirMode(getProject());
             fileMode = zfs.getFileMode(getProject());
         }
 
         if (prefix.length() > 0 && fullpath.length() > 0) {
             throw new BuildException("Both prefix and fullpath attributes must"
                                      + " not be set on the same fileset.");
         }
 
         if (resources.length != 1 && fullpath.length() > 0) {
             throw new BuildException("fullpath attribute may only be specified"
                                      + " for filesets that specify a single"
                                      + " file.");
         }
 
         if (prefix.length() > 0) {
             if (!prefix.endsWith("/") && !prefix.endsWith("\\")) {
                 prefix += "/";
             }
             addParentDirs(null, prefix, zOut, "", dirMode);
         }
 
         ZipFile zf = null;
         try {
             boolean dealingWithFiles = false;
             File base = null;
 
             if (zfs == null || zfs.getSrc(getProject()) == null) {
                 dealingWithFiles = true;
                 base = fileset.getDir(getProject());
             } else if (zfs instanceof ZipFileSet) {
                 zf = new ZipFile(zfs.getSrc(getProject()), encoding);
             }
 
             for (int i = 0; i < resources.length; i++) {
                 String name = null;
                 if (fullpath.length() > 0) {
                     name = fullpath;
                 } else {
                     name = resources[i].getName();
                 }
                 name = name.replace(File.separatorChar, '/');
 
                 if ("".equals(name)) {
                     continue;
                 }
 
                 if (resources[i].isDirectory()) {
                     if (doFilesonly) {
                         continue;
                     }
                     int thisDirMode = zfs != null && zfs.hasDirModeBeenSet()
                         ? dirMode : getUnixMode(resources[i], zf, dirMode);
                     addDirectoryResource(resources[i], name, prefix,
                                          base, zOut,
                                          dirMode, thisDirMode);
 
                 } else { // !isDirectory
 
                     addParentDirs(base, name, zOut, prefix, dirMode);
 
                     if (dealingWithFiles) {
                         File f = FILE_UTILS.resolveFile(base,
                                                         resources[i].getName());
                         zipFile(f, zOut, prefix + name, fileMode);
                     } else {
                         int thisFileMode =
                             zfs != null && zfs.hasFileModeBeenSet()
                             ? fileMode : getUnixMode(resources[i], zf,
                                                      fileMode);
                         addResource(resources[i], name, prefix,
                                     zOut, thisFileMode, zf,
                                     zfs == null
                                     ? null : zfs.getSrc(getProject()));
                     }
                 }
             }
         } finally {
             if (zf != null) {
                 zf.close();
             }
         }
     }
 
     /**
      * Add a directory entry to the archive using a specified
      * Unix-mode and the default mode for its parent directories (if
      * necessary).
      */
     private void addDirectoryResource(Resource r, String name, String prefix,
                                       File base, ZipOutputStream zOut,
                                       int defaultDirMode, int thisDirMode)
         throws IOException {
 
         if (!name.endsWith("/")) {
             name = name + "/";
         }
 
         int nextToLastSlash = name.lastIndexOf("/", name.length() - 2);
         if (nextToLastSlash != -1) {
             addParentDirs(base, name.substring(0, nextToLastSlash + 1),
                           zOut, prefix, defaultDirMode);
         }
         zipDir(r, zOut, prefix + name, thisDirMode,
                r instanceof ZipResource
                ? ((ZipResource) r).getExtraFields() : null);
     }
 
     /**
      * Determine a Resource's Unix mode or return the given default
      * value if not available.
      */
     private int getUnixMode(Resource r, ZipFile zf, int defaultMode)
         throws IOException {
 
         int unixMode = defaultMode;
         if (zf != null) {
             ZipEntry ze = zf.getEntry(r.getName());
             unixMode = ze.getUnixMode();
             if ((unixMode == 0 || unixMode == UnixStat.DIR_FLAG)
                 && !preserve0Permissions) {
                 unixMode = defaultMode;
             }
         } else if (r instanceof ArchiveResource) {
             unixMode = ((ArchiveResource) r).getMode();
         }
         return unixMode;
     }
 
     /**
      * Add a file entry.
      */
     private void addResource(Resource r, String name, String prefix,
                              ZipOutputStream zOut, int mode,
                              ZipFile zf, File fromArchive)
         throws IOException {
 
         if (zf != null) {
             ZipEntry ze = zf.getEntry(r.getName());
 
             if (ze != null) {
                 boolean oldCompress = doCompress;
                 if (keepCompression) {
                     doCompress = (ze.getMethod() == ZipEntry.DEFLATED);
                 }
                 InputStream is = null;
                 try {
                     is = zf.getInputStream(ze);
                     zipFile(is, zOut, prefix + name, ze.getTime(),
                             fromArchive, mode, ze.getExtraFields(true));
                 } finally {
                     doCompress = oldCompress;
                     FileUtils.close(is);
                 }
             }
         } else {
             InputStream is = null;
             try {
                 is = r.getInputStream();
                 zipFile(is, zOut, prefix + name, r.getLastModified(),
                         fromArchive, mode, r instanceof ZipResource
                         ? ((ZipResource) r).getExtraFields() : null);
             } finally {
                 FileUtils.close(is);
             }
         }
     }
 
     /**
      * Add the given resources.
      *
      * @param rc may give additional information like fullpath or
      * permissions.
      * @param resources the resources to add
      * @param zOut the stream to write to
      * @throws IOException on error
      *
      * @since Ant 1.7
      */
     protected final void addResources(ResourceCollection rc,
                                       Resource[] resources,
                                       ZipOutputStream zOut)
         throws IOException {
         if (rc instanceof FileSet) {
             addResources((FileSet) rc, resources, zOut);
             return;
         }
         for (int i = 0; i < resources.length; i++) {
-            String name = resources[i].getName().replace(File.separatorChar,
-                                                         '/');
+            final Resource resource = resources[i];
+            String name = resource.getName();
+            if (name == null) {
+                continue;
+            }
+            name = name.replace(File.separatorChar, '/');
+
             if ("".equals(name)) {
                 continue;
             }
-            if (resources[i].isDirectory() && doFilesonly) {
+            if (resource.isDirectory() && doFilesonly) {
                 continue;
             }
             File base = null;
-            FileProvider fp = resources[i].as(FileProvider.class);
+            FileProvider fp = resource.as(FileProvider.class);
             if (fp != null) {
                 base = ResourceUtils.asFileResource(fp).getBaseDir();
             }
 
-            if (resources[i].isDirectory()) {
-                addDirectoryResource(resources[i], name, "", base, zOut,
+            if (resource.isDirectory()) {
+                addDirectoryResource(resource, name, "", base, zOut,
                                      ArchiveFileSet.DEFAULT_DIR_MODE,
                                      ArchiveFileSet.DEFAULT_DIR_MODE);
 
             } else {
                 addParentDirs(base, name, zOut, "",
                               ArchiveFileSet.DEFAULT_DIR_MODE);
 
                 if (fp != null) {
                     File f = (fp).getFile();
                     zipFile(f, zOut, name, ArchiveFileSet.DEFAULT_FILE_MODE);
                 } else {
-                    addResource(resources[i], name, "", zOut,
+                    addResource(resource, name, "", zOut,
                                 ArchiveFileSet.DEFAULT_FILE_MODE,
                                 null, null);
                 }
             }
         }
     }
 
     /**
      * method for subclasses to override
      * @param zOut the zip output stream
      * @throws IOException on output error
      * @throws BuildException on other errors
      */
     protected void initZipOutputStream(ZipOutputStream zOut)
         throws IOException, BuildException {
     }
 
     /**
      * method for subclasses to override
      * @param zOut the zip output stream
      * @throws IOException on output error
      * @throws BuildException on other errors
      */
     protected void finalizeZipOutputStream(ZipOutputStream zOut)
         throws IOException, BuildException {
     }
 
     /**
      * Create an empty zip file
      * @param zipFile the zip file
      * @return true for historic reasons
      * @throws BuildException on error
      */
     protected boolean createEmptyZip(File zipFile) throws BuildException {
         // In this case using java.util.zip will not work
         // because it does not permit a zero-entry archive.
         // Must create it manually.
         if (!skipWriting) {
             log("Note: creating empty " + archiveType + " archive " + zipFile,
                 Project.MSG_INFO);
         }
         OutputStream os = null;
         try {
             os = new FileOutputStream(zipFile);
             // CheckStyle:MagicNumber OFF
             // Cf. PKZIP specification.
             byte[] empty = new byte[22];
             empty[0] = 80; // P
             empty[1] = 75; // K
             empty[2] = 5;
             empty[3] = 6;
             // remainder zeros
             // CheckStyle:MagicNumber ON
             os.write(empty);
         } catch (IOException ioe) {
             throw new BuildException("Could not create empty ZIP archive "
                                      + "(" + ioe.getMessage() + ")", ioe,
                                      getLocation());
         } finally {
             FileUtils.close(os);
         }
         return true;
     }
 
     /**
      * @since Ant 1.5.2
      */
     private synchronized ZipScanner getZipScanner() {
         if (zs == null) {
             zs = new ZipScanner();
             zs.setEncoding(encoding);
             zs.setSrc(zipFile);
         }
         return zs;
     }
 
     /**
      * Collect the resources that are newer than the corresponding
      * entries (or missing) in the original archive.
      *
      * <p>If we are going to recreate the archive instead of updating
      * it, all resources should be considered as new, if a single one
      * is.  Because of this, subclasses overriding this method must
      * call <code>super.getResourcesToAdd</code> and indicate with the
      * third arg if they already know that the archive is
      * out-of-date.</p>
      *
      * <p>This method first delegates to getNonFileSetResourcesToAdd
      * and then invokes the FileSet-arg version.  All this to keep
      * backwards compatibility for subclasses that don't know how to
      * deal with non-FileSet ResourceCollections.</p>
      *
      * @param rcs The resource collections to grab resources from
      * @param zipFile intended archive file (may or may not exist)
      * @param needsUpdate whether we already know that the archive is
      * out-of-date.  Subclasses overriding this method are supposed to
      * set this value correctly in their call to
      * <code>super.getResourcesToAdd</code>.
      * @return an array of resources to add for each fileset passed in as well
      *         as a flag that indicates whether the archive is uptodate.
      *
      * @exception BuildException if it likes
      * @since Ant 1.7
      */
     protected ArchiveState getResourcesToAdd(ResourceCollection[] rcs,
                                              File zipFile,
                                              boolean needsUpdate)
         throws BuildException {
         ArrayList<ResourceCollection> filesets = new ArrayList<ResourceCollection>();
         ArrayList<ResourceCollection> rest = new ArrayList<ResourceCollection>();
         for (int i = 0; i < rcs.length; i++) {
             if (rcs[i] instanceof FileSet) {
                 filesets.add(rcs[i]);
             } else {
                 rest.add(rcs[i]);
             }
         }
         ResourceCollection[] rc =
             rest.toArray(new ResourceCollection[rest.size()]);
         ArchiveState as = getNonFileSetResourcesToAdd(rc, zipFile,
                                                       needsUpdate);
 
         FileSet[] fs = (FileSet[]) filesets.toArray(new FileSet[filesets
                                                                 .size()]);
         ArchiveState as2 = getResourcesToAdd(fs, zipFile, as.isOutOfDate());
         if (!as.isOutOfDate() && as2.isOutOfDate()) {
             /*
              * Bad luck.
              *
              * There are resources in the filesets that make the
              * archive out of date, but not in the non-fileset
              * resources. We need to rescan the non-FileSets to grab
              * all of them now.
              */
             as = getNonFileSetResourcesToAdd(rc, zipFile, true);
         }
 
         Resource[][] toAdd = new Resource[rcs.length][];
         int fsIndex = 0;
         int restIndex = 0;
         for (int i = 0; i < rcs.length; i++) {
             if (rcs[i] instanceof FileSet) {
                 toAdd[i] = as2.getResourcesToAdd()[fsIndex++];
             } else {
                 toAdd[i] = as.getResourcesToAdd()[restIndex++];
             }
         }
         return new ArchiveState(as2.isOutOfDate(), toAdd);
     }
 
     /*
      * This is yet another hacky construct to extend the FileSet[]
      * getResourcesToAdd method so we can pass the information whether
      * non-fileset resources have been available to it without having
      * to move the withEmpty behavior checks (since either would break
      * subclasses in several ways).
      */
     private static final ThreadLocal<Boolean> HAVE_NON_FILE_SET_RESOURCES_TO_ADD = new ThreadLocal<Boolean>() {
             protected Boolean initialValue() {
                 return Boolean.FALSE;
             }
         };
 
     /**
      * Collect the resources that are newer than the corresponding
      * entries (or missing) in the original archive.
      *
      * <p>If we are going to recreate the archive instead of updating
      * it, all resources should be considered as new, if a single one
      * is.  Because of this, subclasses overriding this method must
      * call <code>super.getResourcesToAdd</code> and indicate with the
      * third arg if they already know that the archive is
      * out-of-date.</p>
      *
      * @param filesets The filesets to grab resources from
      * @param zipFile intended archive file (may or may not exist)
      * @param needsUpdate whether we already know that the archive is
      * out-of-date.  Subclasses overriding this method are supposed to
      * set this value correctly in their call to
      * <code>super.getResourcesToAdd</code>.
      * @return an array of resources to add for each fileset passed in as well
      *         as a flag that indicates whether the archive is uptodate.
      *
      * @exception BuildException if it likes
      */
     protected ArchiveState getResourcesToAdd(FileSet[] filesets,
                                              File zipFile,
                                              boolean needsUpdate)
         throws BuildException {
 
         Resource[][] initialResources = grabResources(filesets);
         if (isEmpty(initialResources)) {
             if (Boolean.FALSE.equals(HAVE_NON_FILE_SET_RESOURCES_TO_ADD.get())) {
                 if (needsUpdate && doUpdate) {
                     /*
                      * This is a rather hairy case.
                      *
                      * One of our subclasses knows that we need to
                      * update the archive, but at the same time, there
                      * are no resources known to us that would need to
                      * be added.  Only the subclass seems to know
                      * what's going on.
                      *
                      * This happens if <jar> detects that the manifest
                      * has changed, for example.  The manifest is not
                      * part of any resources because of our support
                      * for inline <manifest>s.
                      *
                      * If we invoke createEmptyZip like Ant 1.5.2 did,
                      * we'll loose all stuff that has been in the
                      * original archive (bugzilla report 17780).
                      */
                     return new ArchiveState(true, initialResources);
                 }
 
                 if (emptyBehavior.equals("skip")) {
                     if (doUpdate) {
                         logWhenWriting(archiveType + " archive " + zipFile
                                        + " not updated because no new files were"
                                        + " included.", Project.MSG_VERBOSE);
                     } else {
                         logWhenWriting("Warning: skipping " + archiveType
                                        + " archive " + zipFile
                                        + " because no files were included.",
                                        Project.MSG_WARN);
                     }
                 } else if (emptyBehavior.equals("fail")) {
                     throw new BuildException("Cannot create " + archiveType
                                              + " archive " + zipFile
                                              + ": no files were included.",
                                              getLocation());
                 } else {
                     // Create.
                     if (!zipFile.exists())  {
                         needsUpdate = true;
                     }
                 }
             }
 
             // either there are non-fileset resources or we
             // (re-)create the archive anyway
             return new ArchiveState(needsUpdate, initialResources);
         }
 
         // initialResources is not empty
 
         if (!zipFile.exists()) {
             return new ArchiveState(true, initialResources);
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         Resource[][] newerResources = new Resource[filesets.length][];
 
         for (int i = 0; i < filesets.length; i++) {
             if (!(fileset instanceof ZipFileSet)
                 || ((ZipFileSet) fileset).getSrc(getProject()) == null) {
                 File base = filesets[i].getDir(getProject());
 
                 for (int j = 0; j < initialResources[i].length; j++) {
                     File resourceAsFile =
                         FILE_UTILS.resolveFile(base,
                                               initialResources[i][j].getName());
                     if (resourceAsFile.equals(zipFile)) {
                         throw new BuildException("A zip file cannot include "
                                                  + "itself", getLocation());
                     }
                 }
             }
         }
 
         for (int i = 0; i < filesets.length; i++) {
             if (initialResources[i].length == 0) {
                 newerResources[i] = new Resource[] {};
                 continue;
             }
 
             FileNameMapper myMapper = new IdentityMapper();
             if (filesets[i] instanceof ZipFileSet) {
                 ZipFileSet zfs = (ZipFileSet) filesets[i];
                 if (zfs.getFullpath(getProject()) != null
                     && !zfs.getFullpath(getProject()).equals("")) {
                     // in this case all files from origin map to
                     // the fullPath attribute of the zipfileset at
                     // destination
                     MergingMapper fm = new MergingMapper();
                     fm.setTo(zfs.getFullpath(getProject()));
                     myMapper = fm;
 
                 } else if (zfs.getPrefix(getProject()) != null
                            && !zfs.getPrefix(getProject()).equals("")) {
                     GlobPatternMapper gm = new GlobPatternMapper();
                     gm.setFrom("*");
                     String prefix = zfs.getPrefix(getProject());
                     if (!prefix.endsWith("/") && !prefix.endsWith("\\")) {
                         prefix += "/";
                     }
                     gm.setTo(prefix + "*");
                     myMapper = gm;
                 }
             }
 
             newerResources[i] = selectOutOfDateResources(initialResources[i],
                                                          myMapper);
             needsUpdate = needsUpdate || (newerResources[i].length > 0);
 
             if (needsUpdate && !doUpdate) {
                 // we will return initialResources anyway, no reason
                 // to scan further.
                 break;
             }
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         return new ArchiveState(needsUpdate, newerResources);
     }
 
     /**
      * Collect the resources that are newer than the corresponding
      * entries (or missing) in the original archive.
      *
      * <p>If we are going to recreate the archive instead of updating
      * it, all resources should be considered as new, if a single one
      * is.  Because of this, subclasses overriding this method must
      * call <code>super.getResourcesToAdd</code> and indicate with the
      * third arg if they already know that the archive is
      * out-of-date.</p>
      *
      * @param rcs The filesets to grab resources from
      * @param zipFile intended archive file (may or may not exist)
      * @param needsUpdate whether we already know that the archive is
      * out-of-date.  Subclasses overriding this method are supposed to
      * set this value correctly in their call to
      * <code>super.getResourcesToAdd</code>.
      * @return an array of resources to add for each fileset passed in as well
      *         as a flag that indicates whether the archive is uptodate.
      *
      * @exception BuildException if it likes
      */
     protected ArchiveState getNonFileSetResourcesToAdd(ResourceCollection[] rcs,
                                                        File zipFile,
                                                        boolean needsUpdate)
         throws BuildException {
         /*
          * Backwards compatibility forces us to repeat the logic of
          * getResourcesToAdd(FileSet[], ...) here once again.
          */
 
         Resource[][] initialResources = grabNonFileSetResources(rcs);
         boolean empty = isEmpty(initialResources);
         HAVE_NON_FILE_SET_RESOURCES_TO_ADD.set(Boolean.valueOf(!empty));
         if (empty) {
             // no emptyBehavior handling since the FileSet version
             // will take care of it.
             return new ArchiveState(needsUpdate, initialResources);
         }
 
         // initialResources is not empty
 
         if (!zipFile.exists()) {
             return new ArchiveState(true, initialResources);
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         Resource[][] newerResources = new Resource[rcs.length][];
 
         for (int i = 0; i < rcs.length; i++) {
             if (initialResources[i].length == 0) {
                 newerResources[i] = new Resource[] {};
                 continue;
             }
 
             for (int j = 0; j < initialResources[i].length; j++) {
                 FileProvider fp =
                     initialResources[i][j].as(FileProvider.class);
                 if (fp != null && zipFile.equals(fp.getFile())) {
                     throw new BuildException("A zip file cannot include "
                                              + "itself", getLocation());
                 }
             }
 
             newerResources[i] = selectOutOfDateResources(initialResources[i],
                                                          new IdentityMapper());
             needsUpdate = needsUpdate || (newerResources[i].length > 0);
 
             if (needsUpdate && !doUpdate) {
                 // we will return initialResources anyway, no reason
                 // to scan further.
                 break;
             }
         }
 
         if (needsUpdate && !doUpdate) {
             // we are recreating the archive, need all resources
             return new ArchiveState(true, initialResources);
         }
 
         return new ArchiveState(needsUpdate, newerResources);
     }
 
     private Resource[] selectOutOfDateResources(Resource[] initial,
                                                 FileNameMapper mapper) {
         Resource[] rs = selectFileResources(initial);
         Resource[] result =
             ResourceUtils.selectOutOfDateSources(this, rs, mapper,
                                                  getZipScanner());
         if (!doFilesonly) {
             Union u = new Union();
             u.addAll(Arrays.asList(selectDirectoryResources(initial)));
             ResourceCollection rc =
                 ResourceUtils.selectSources(this, u, mapper,
                                             getZipScanner(),
                                             MISSING_DIR_PROVIDER);
             if (rc.size() > 0) {
                 ArrayList<Resource> newer = new ArrayList<Resource>();
                 newer.addAll(Arrays.asList(((Union) rc).listResources()));
                 newer.addAll(Arrays.asList(result));
                 result = newer.toArray(result);
             }
         }
         return result;
     }
 
     /**
      * Fetch all included and not excluded resources from the sets.
      *
      * <p>Included directories will precede included files.</p>
      * @param filesets an array of filesets
      * @return the resources included
      * @since Ant 1.5.2
      */
     protected Resource[][] grabResources(FileSet[] filesets) {
         Resource[][] result = new Resource[filesets.length][];
         for (int i = 0; i < filesets.length; i++) {
             boolean skipEmptyNames = true;
             if (filesets[i] instanceof ZipFileSet) {
                 ZipFileSet zfs = (ZipFileSet) filesets[i];
                 skipEmptyNames = zfs.getPrefix(getProject()).equals("")
                     && zfs.getFullpath(getProject()).equals("");
             }
             DirectoryScanner rs =
                 filesets[i].getDirectoryScanner(getProject());
             if (rs instanceof ZipScanner) {
                 ((ZipScanner) rs).setEncoding(encoding);
             }
             Vector<Resource> resources = new Vector<Resource>();
             if (!doFilesonly) {
                 String[] directories = rs.getIncludedDirectories();
                 for (int j = 0; j < directories.length; j++) {
                     if (!"".equals(directories[j]) || !skipEmptyNames) {
                         resources.addElement(rs.getResource(directories[j]));
                     }
                 }
             }
             String[] files = rs.getIncludedFiles();
             for (int j = 0; j < files.length; j++) {
                 if (!"".equals(files[j]) || !skipEmptyNames) {
                     resources.addElement(rs.getResource(files[j]));
                 }
             }
 
             result[i] = new Resource[resources.size()];
             resources.copyInto(result[i]);
         }
         return result;
     }
 
     /**
      * Fetch all included and not excluded resources from the collections.
      *
      * <p>Included directories will precede included files.</p>
      * @param rcs an array of resource collections
      * @return the resources included
      * @since Ant 1.7
      */
     protected Resource[][] grabNonFileSetResources(ResourceCollection[] rcs) {
         Resource[][] result = new Resource[rcs.length][];
         for (int i = 0; i < rcs.length; i++) {
             ArrayList<Resource> dirs = new ArrayList<Resource>();
             ArrayList<Resource> files = new ArrayList<Resource>();
             for (Resource r : rcs[i]) {
                 if (r.isExists()) {
                     if (r.isDirectory()) {
                         dirs.add(r);
                     } else {
                         files.add(r);
                     }
                 }
             }
             // make sure directories are in alpha-order - this also
             // ensures parents come before their children
             Collections.sort(dirs, new Comparator<Resource>() {
                     public int compare(Resource r1, Resource r2) {
                         return r1.getName().compareTo(r2.getName());
                     }
                 });
             ArrayList<Resource> rs = new ArrayList<Resource>(dirs);
             rs.addAll(files);
             result[i] = rs.toArray(new Resource[rs.size()]);
         }
         return result;
     }
 
     /**
      * Add a directory to the zip stream.
      * @param dir  the directort to add to the archive
      * @param zOut the stream to write to
      * @param vPath the name this entry shall have in the archive
      * @param mode the Unix permissions to set.
      * @throws IOException on error
      * @since Ant 1.5.2
      */
     protected void zipDir(File dir, ZipOutputStream zOut, String vPath,
                           int mode)
         throws IOException {
         zipDir(dir, zOut, vPath, mode, null);
     }
 
     /**
      * Add a directory to the zip stream.
      * @param dir  the directory to add to the archive
      * @param zOut the stream to write to
      * @param vPath the name this entry shall have in the archive
      * @param mode the Unix permissions to set.
      * @param extra ZipExtraFields to add
      * @throws IOException on error
      * @since Ant 1.6.3
      */
     protected void zipDir(File dir, ZipOutputStream zOut, String vPath,
                           int mode, ZipExtraField[] extra)
         throws IOException {
         zipDir(dir == null ? (Resource) null : new FileResource(dir),
                zOut, vPath, mode, extra);
     }
 
     /**
      * Add a directory to the zip stream.
      * @param dir  the directory to add to the archive
      * @param zOut the stream to write to
      * @param vPath the name this entry shall have in the archive
      * @param mode the Unix permissions to set.
      * @param extra ZipExtraFields to add
      * @throws IOException on error
      * @since Ant 1.8.0
      */
     protected void zipDir(Resource dir, ZipOutputStream zOut, String vPath,
                           int mode, ZipExtraField[] extra)
         throws IOException {
         if (doFilesonly) {
             logWhenWriting("skipping directory " + vPath
                            + " for file-only archive",
                            Project.MSG_VERBOSE);
             return;
         }
         if (addedDirs.get(vPath) != null) {
             // don't add directories we've already added.
             // no warning if we try, it is harmless in and of itself
             return;
         }
 
         logWhenWriting("adding directory " + vPath, Project.MSG_VERBOSE);
         addedDirs.put(vPath, vPath);
 
         if (!skipWriting) {
             ZipEntry ze = new ZipEntry (vPath);
 
             // ZIPs store time with a granularity of 2 seconds, round up
             int millisToAdd = roundUp ? ROUNDUP_MILLIS : 0;
 
             if (dir != null && dir.isExists()) {
                 ze.setTime(dir.getLastModified() + millisToAdd);
             } else {
                 ze.setTime(System.currentTimeMillis() + millisToAdd);
             }
             ze.setSize (0);
             ze.setMethod (ZipEntry.STORED);
             // This is faintly ridiculous:
             ze.setCrc (EMPTY_CRC);
             ze.setUnixMode(mode);
 
             if (extra != null) {
                 ze.setExtraFields(extra);
             }
 
             zOut.putNextEntry(ze);
         }
     }
 
     /*
      * This is a hacky construct to extend the zipFile method to
      * support a new parameter (extra fields to preserve) without
      * breaking subclasses that override the old method signature.
      */
     private static final ThreadLocal<ZipExtraField[]> CURRENT_ZIP_EXTRA = new ThreadLocal<ZipExtraField[]>();
 
     /**
      * Provides the extra fields for the zip entry currently being
      * added to the archive - if any.
      * @since Ant 1.8.0
      */
     protected final ZipExtraField[] getCurrentExtraFields() {
         return (ZipExtraField[]) CURRENT_ZIP_EXTRA.get();
     }
 
     /**
      * Sets the extra fields for the zip entry currently being
      * added to the archive - if any.
      * @since Ant 1.8.0
      */
     protected final void setCurrentExtraFields(ZipExtraField[] extra) {
         CURRENT_ZIP_EXTRA.set(extra);
     }
 
     /**
      * Adds a new entry to the archive, takes care of duplicates as well.
      *
      * @param in the stream to read data for the entry from.  The
      * caller of the method is responsible for closing the stream.
      * @param zOut the stream to write to.
      * @param vPath the name this entry shall have in the archive.
      * @param lastModified last modification time for the entry.
      * @param fromArchive the original archive we are copying this
      * entry from, will be null if we are not copying from an archive.
      * @param mode the Unix permissions to set.
      *
      * @since Ant 1.5.2
      * @throws IOException on error
      */
     protected void zipFile(InputStream in, ZipOutputStream zOut, String vPath,
                            long lastModified, File fromArchive, int mode)
         throws IOException {
         // fromArchive is used in subclasses overriding this method
 
         if (entries.containsKey(vPath)) {
 
             if (duplicate.equals("preserve")) {
                 logWhenWriting(vPath + " already added, skipping",
                                Project.MSG_INFO);
                 return;
             } else if (duplicate.equals("fail")) {
                 throw new BuildException("Duplicate file " + vPath
                                          + " was found and the duplicate "
                                          + "attribute is 'fail'.");
             } else {
                 // duplicate equal to add, so we continue
                 logWhenWriting("duplicate file " + vPath
                                + " found, adding.", Project.MSG_VERBOSE);
             }
         } else {
             logWhenWriting("adding entry " + vPath, Project.MSG_VERBOSE);
         }
 
         entries.put(vPath, vPath);
 
         if (!skipWriting) {
             ZipEntry ze = new ZipEntry(vPath);
             ze.setTime(lastModified);
             ze.setMethod(doCompress ? ZipEntry.DEFLATED : ZipEntry.STORED);
 
             /*
              * ZipOutputStream.putNextEntry expects the ZipEntry to
              * know its size and the CRC sum before you start writing
              * the data when using STORED mode - unless it is seekable.
              *
              * This forces us to process the data twice.
              */
             if (!zOut.isSeekable() && !doCompress) {
                 long size = 0;
                 CRC32 cal = new CRC32();
                 if (!in.markSupported()) {
                     // Store data into a byte[]
                     ByteArrayOutputStream bos = new ByteArrayOutputStream();
 
                     byte[] buffer = new byte[BUFFER_SIZE];
                     int count = 0;
                     do {
                         size += count;
                         cal.update(buffer, 0, count);
                         bos.write(buffer, 0, count);
                         count = in.read(buffer, 0, buffer.length);
                     } while (count != -1);
                     in = new ByteArrayInputStream(bos.toByteArray());
 
                 } else {
                     in.mark(Integer.MAX_VALUE);
                     byte[] buffer = new byte[BUFFER_SIZE];
                     int count = 0;
                     do {
                         size += count;
                         cal.update(buffer, 0, count);
                         count = in.read(buffer, 0, buffer.length);
                     } while (count != -1);
                     in.reset();
                 }
                 ze.setSize(size);
                 ze.setCrc(cal.getValue());
             }
 
             ze.setUnixMode(mode);
             ZipExtraField[] extra = getCurrentExtraFields();
             if (extra != null) {
                 ze.setExtraFields(extra);
             }
 
             zOut.putNextEntry(ze);
 
             byte[] buffer = new byte[BUFFER_SIZE];
             int count = 0;
             do {
                 if (count != 0) {
                     zOut.write(buffer, 0, count);
                 }
                 count = in.read(buffer, 0, buffer.length);
             } while (count != -1);
         }
         addedFiles.addElement(vPath);
     }
 
     /**
      * Adds a new entry to the archive, takes care of duplicates as well.
      *
      * @param in the stream to read data for the entry from.  The
      * caller of the method is responsible for closing the stream.
      * @param zOut the stream to write to.
      * @param vPath the name this entry shall have in the archive.
      * @param lastModified last modification time for the entry.
      * @param fromArchive the original archive we are copying this
      * entry from, will be null if we are not copying from an archive.
      * @param mode the Unix permissions to set.
      * @param extra ZipExtraFields to add
      *
      * @since Ant 1.8.0
      * @throws IOException on error
      */
     protected final void zipFile(InputStream in, ZipOutputStream zOut,
                                  String vPath, long lastModified,
                                  File fromArchive, int mode,
                                  ZipExtraField[] extra)
         throws IOException {
         try {
             setCurrentExtraFields(extra);
             zipFile(in, zOut, vPath, lastModified, fromArchive, mode);
         } finally {
             setCurrentExtraFields(null);
         }
     }
 
     /**
      * Method that gets called when adding from <code>java.io.File</code> instances.
      *
      * <p>This implementation delegates to the six-arg version.</p>
      *
      * @param file the file to add to the archive
      * @param zOut the stream to write to
      * @param vPath the name this entry shall have in the archive
      * @param mode the Unix permissions to set.
      * @throws IOException on error
      *
      * @since Ant 1.5.2
      */
     protected void zipFile(File file, ZipOutputStream zOut, String vPath,
                            int mode)
         throws IOException {
         if (file.equals(zipFile)) {
             throw new BuildException("A zip file cannot include itself",
                                      getLocation());
         }
 
         FileInputStream fIn = new FileInputStream(file);
         try {
             // ZIPs store time with a granularity of 2 seconds, round up
             zipFile(fIn, zOut, vPath,
                     file.lastModified() + (roundUp ? ROUNDUP_MILLIS : 0),
                     null, mode);
         } finally {
             fIn.close();
         }
     }
 
     /**
      * Ensure all parent dirs of a given entry have been added.
      * @param baseDir the base directory to use (may be null)
      * @param entry   the entry name to create directories from
      * @param zOut    the stream to write to
      * @param prefix  a prefix to place on the created entries
      * @param dirMode the directory mode
      * @throws IOException on error
      * @since Ant 1.5.2
      */
     protected final void addParentDirs(File baseDir, String entry,
                                        ZipOutputStream zOut, String prefix,
                                        int dirMode)
         throws IOException {
         if (!doFilesonly) {
             Stack<String> directories = new Stack<String>();
             int slashPos = entry.length();
 
             while ((slashPos = entry.lastIndexOf('/', slashPos - 1)) != -1) {
                 String dir = entry.substring(0, slashPos + 1);
                 if (addedDirs.get(prefix + dir) != null) {
                     break;
                 }
                 directories.push(dir);
             }
 
             while (!directories.isEmpty()) {
                 String dir = directories.pop();
                 File f = null;
                 if (baseDir != null) {
                     f = new File(baseDir, dir);
                 } else {
                     f = new File(dir);
                 }
                 zipDir(f, zOut, prefix + dir, dirMode);
             }
         }
     }
 
     /**
      * Do any clean up necessary to allow this instance to be used again.
      *
      * <p>When we get here, the Zip file has been closed and all we
      * need to do is to reset some globals.</p>
      *
      * <p>This method will only reset globals that have been changed
      * during execute(), it will not alter the attributes or nested
      * child elements.  If you want to reset the instance so that you
      * can later zip a completely different set of files, you must use
      * the reset method.</p>
      *
      * @see #reset
      */
     protected void cleanUp() {
         addedDirs.clear();
         addedFiles.removeAllElements();
         entries.clear();
         addingNewFiles = false;
         doUpdate = savedDoUpdate;
         Enumeration<ZipFileSet> e = filesetsFromGroupfilesets.elements();
         while (e.hasMoreElements()) {
             ZipFileSet zf = e.nextElement();
             resources.removeElement(zf);
         }
         filesetsFromGroupfilesets.removeAllElements();
         HAVE_NON_FILE_SET_RESOURCES_TO_ADD.set(Boolean.FALSE);
     }
 
     /**
      * Makes this instance reset all attributes to their default
      * values and forget all children.
      *
      * @since Ant 1.5
      *
      * @see #cleanUp
      */
     public void reset() {
         resources.removeAllElements();
         zipFile = null;
         baseDir = null;
         groupfilesets.removeAllElements();
         duplicate = "add";
         archiveType = "zip";
         doCompress = true;
         emptyBehavior = "skip";
         doUpdate = false;
         doFilesonly = false;
         encoding = null;
     }
 
     /**
      * Check is the resource arrays are empty.
      * @param r the arrays to check
      * @return true if all individual arrays are empty
      *
      * @since Ant 1.5.2
      */
     protected static final boolean isEmpty(Resource[][] r) {
         for (int i = 0; i < r.length; i++) {
             if (r[i].length > 0) {
                 return false;
             }
         }
         return true;
     }
 
     /**
      * Drops all non-file resources from the given array.
      * @param orig the resources to filter
      * @return the filters resources
      * @since Ant 1.6
      */
     protected Resource[] selectFileResources(Resource[] orig) {
         return selectResources(orig,
                                new ResourceSelector() {
                                    public boolean isSelected(Resource r) {
                                        if (!r.isDirectory()) {
                                            return true;
                                        } else if (doFilesonly) {
                                            logWhenWriting("Ignoring directory "
                                                           + r.getName()
                                                           + " as only files will"
                                                           + " be added.",
                                                           Project.MSG_VERBOSE);
                                        }
                                        return false;
                                    }
                                });
     }
 
     /**
      * Drops all non-directory resources from the given array.
      * @param orig the resources to filter
      * @return the filters resources
      * @since Ant 1.8.0
      */
     protected Resource[] selectDirectoryResources(Resource[] orig) {
         return selectResources(orig,
                                new ResourceSelector() {
                                    public boolean isSelected(Resource r) {
                                        return r.isDirectory();
                                    }
                                });
     }
 
     /**
      * Drops all resources from the given array that are not selected
      * @param orig the resources to filter
      * @return the filters resources
      * @since Ant 1.8.0
      */
     protected Resource[] selectResources(Resource[] orig,
                                          ResourceSelector selector) {
         if (orig.length == 0) {
             return orig;
         }
 
         ArrayList<Resource> v = new ArrayList<Resource>(orig.length);
         for (int i = 0; i < orig.length; i++) {
             if (selector.isSelected(orig[i])) {
                 v.add(orig[i]);
             }
         }
 
         if (v.size() != orig.length) {
             return v.toArray(new Resource[v.size()]);
         }
         return orig;
     }
 
     /**
      * Logs a message at the given output level, but only if this is
      * the pass that will actually create the archive.
      *
      * @since Ant 1.8.0
      */
     protected void logWhenWriting(String msg, int level) {
         if (!skipWriting) {
             log(msg, level);
         }
     }
 
     /**
      * Possible behaviors when a duplicate file is added:
      * "add", "preserve" or "fail"
      */
     public static class Duplicate extends EnumeratedAttribute {
         /**
          * @see EnumeratedAttribute#getValues()
          */
         /** {@inheritDoc} */
         public String[] getValues() {
             return new String[] {"add", "preserve", "fail"};
         }
     }
 
     /**
      * Holds the up-to-date status and the out-of-date resources of
      * the original archive.
      *
      * @since Ant 1.5.3
      */
     public static class ArchiveState {
         private boolean outOfDate;
         private Resource[][] resourcesToAdd;
 
         ArchiveState(boolean state, Resource[][] r) {
             outOfDate = state;
             resourcesToAdd = r;
         }
diff --git a/src/tests/antunit/taskdefs/zip-test.xml b/src/tests/antunit/taskdefs/zip-test.xml
index e64b679b1..682ac95f8 100644
--- a/src/tests/antunit/taskdefs/zip-test.xml
+++ b/src/tests/antunit/taskdefs/zip-test.xml
@@ -1,157 +1,172 @@
 <?xml version="1.0"?>
 <!--
   Licensed to the Apache Software Foundation (ASF) under one or more
   contributor license agreements.  See the NOTICE file distributed with
   this work for additional information regarding copyright ownership.
   The ASF licenses this file to You under the Apache License, Version 2.0
   (the "License"); you may not use this file except in compliance with
   the License.  You may obtain a copy of the License at
 
       http://www.apache.org/licenses/LICENSE-2.0
 
   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
 -->
 <project default="antunit" xmlns:au="antlib:org.apache.ant.antunit">
   <import file="../antunit-base.xml" />
 
   <target name="testEmptyDirs">
     <mkdir dir="${input}/foo"/>
     <mkdir dir="${output}/bar"/>
     <zip destfile="${output}/test.zip">
       <fileset dir="${input}"/>
     </zip>
     <unzip src="${output}/test.zip" dest="${output}/bar"/>
     <au:assertFileExists file="${output}/bar/foo"/>
   </target>
 
   <target name="testMappedResources">
     <mkdir dir="${input}"/>
     <mkdir dir="${output}/out"/>
     <echo file="${input}/foo.txt">Hello, world!</echo>
     <zip destfile="${output}/test.zip">
       <mappedresources>
         <fileset dir="${input}"/>
         <globmapper from="foo.*" to="bar.*"/>
       </mappedresources>
     </zip>
     <unzip src="${output}/test.zip" dest="${output}/out"/>
     <au:assertFileDoesntExist file="${output}/out/foo.txt"/>
     <au:assertFileExists file="${output}/out/bar.txt"/>
     <au:assertFilesMatch expected="${input}/foo.txt"
                          actual="${output}/out/bar.txt"/>
   </target>
 
+  <target name="test-54026">
+    <mkdir dir="${input}"/>
+    <touch file="${input}/test1"/>
+    <mkdir dir="${input}/subdir"/>
+    <touch file="${input}/subdir/test2"/>
+    <zip destfile="${output}/br54026-destzip.zip">
+      <mappedresources>
+        <fileset dir="${input}"/>
+        <globmapper from="subdir/*" to="subdir.orig/*"/>
+      </mappedresources>
+    </zip>
+
+    <au:assertFileExists file="${output}/br54026-destzip.zip"/>
+  </target>
+
   <target name="testMappedClasspath">
     <mkdir dir="${input}"/>
     <mkdir dir="${output}/out"/>
     <zip destfile="${output}/test.zip">
       <mappedresources>
         <path path="${java.class.path}"/>
         <chainedmapper>
           <flattenmapper/>
           <globmapper from="*" to="WEB-INF/lib/*"/>
         </chainedmapper>
       </mappedresources>
     </zip>
     <unzip src="${output}/test.zip" dest="${output}/out"/>
     <au:assertFileExists file="${output}/out/WEB-INF/lib/ant.jar"/>
   </target>
 
     <target name="testIssue45902"
             description="https://issues.apache.org/bugzilla/show_bug.cgi?id=45902">
       <mkdir dir="${input}/src/p"/>
       <mkdir dir="${output}"/>
       <touch file="${input}/src/p/X.java"/>
       <touch file="${input}/src/p/x.properties"/>
       <mkdir dir="${input}/build"/>
       <copy todir="${input}/build">
         <fileset dir="${input}/src" includes="**/*.java"/>
       </copy>
 
       <jar jarfile="${output}/jar.jar">
         <fileset dir="${input}/build"/>
         <fileset dir="${input}/src" excludes="**/*.java"/>
       </jar>
       <copy file="${output}/jar.jar" tofile="${output}/reference.jar"/>
 
       <sleep seconds="1"/>
       <touch file="${input}/src/p/y.properties"/>
       <sleep seconds="1"/>
       <delete file="${input}/src/p/y.properties"/>
       <jar jarfile="${output}/jar.jar">
         <fileset dir="${input}/build"/>
         <fileset dir="${input}/src" excludes="**/*.java"/>
       </jar>
       <au:assertDestIsUptodate src="${output}/jar.jar"
                                dest="${output}/reference.jar"/>
 
       <sleep seconds="1"/>
       <jar jarfile="${output}/jar.jar">
         <fileset dir="${input}/build"/>
         <fileset dir="${input}/src" excludes="**/*.java"/>
       </jar>
       <au:assertDestIsUptodate src="${output}/jar.jar"
                                dest="${output}/reference.jar"/>
 
       <jar jarfile="${output}/jar.jar">
         <fileset dir="${input}/build"/>
         <fileset dir="${input}/src" excludes="**/*.java"/>
       </jar>
       <au:assertDestIsUptodate src="${output}/jar.jar"
                                dest="${output}/reference.jar"/>
     </target>
 
     <target name="testNewEmptyDirUpdatesArchive">
       <mkdir dir="${input}"/>
       <touch file="${input}/x"/>
       <mkdir dir="${output}"/>
       <jar jarfile="${output}/jar.jar">
         <fileset dir="${input}"/>
       </jar>
       <copy file="${output}/jar.jar" tofile="${output}/reference.jar"/>
 
       <mkdir dir="${input}/y"/>
       <sleep seconds="2"/>
       <jar jarfile="${output}/jar.jar">
         <fileset dir="${input}"/>
       </jar>
       <au:assertDestIsOutofdate src="${output}/jar.jar"
                                dest="${output}/reference.jar"/>
     </target>
 
     <target name="testFilesetInsideResources"
             description="https://issues.apache.org/bugzilla/show_bug.cgi?id=50115">
       <mkdir dir="${input}/test2"/>
       <touch file="${input}/test1.txt"/>
       <mkdir dir="${output}"/>
       <mkdir dir="${output}/expand"/>
       <zip destfile="${output}/test.zip" whenempty="skip">
         <resources>
           <fileset dir="${input}" includes="test**"/>
         </resources>
       </zip>
       <au:assertLogDoesntContain text="skipping zip archive"/>
       <unzip src="${output}/test.zip" dest="${output}/expand"/>
       <au:assertFileExists file="${output}/expand/test1.txt"/>
       <!--au:assertFileExists file="${output}/expand/test2"/-->
     </target>
 
     <target name="testWhenEmptyChecksNonFileSets"
             description="https://issues.apache.org/bugzilla/show_bug.cgi?id=50115">
       <mkdir dir="${input}/"/>
       <touch file="${input}/test1.txt"/>
       <mkdir dir="${output}"/>
       <mkdir dir="${output}/expand"/>
       <zip destfile="${output}/test.zip" whenempty="fail">
         <resources>
           <fileset dir="${input}" includes="test**"/>
         </resources>
       </zip>
       <unzip src="${output}/test.zip" dest="${output}/expand"/>
       <au:assertFileExists file="${output}/expand/test1.txt"/>
     </target>
 </project>
