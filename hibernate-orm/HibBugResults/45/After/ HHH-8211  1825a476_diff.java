diff --git a/hibernate-core/src/main/java/org/hibernate/bytecode/instrumentation/internal/javassist/FieldInterceptorImpl.java b/hibernate-core/src/main/java/org/hibernate/bytecode/instrumentation/internal/javassist/FieldInterceptorImpl.java
index 1d37ebd961..ae835a9b64 100644
--- a/hibernate-core/src/main/java/org/hibernate/bytecode/instrumentation/internal/javassist/FieldInterceptorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/bytecode/instrumentation/internal/javassist/FieldInterceptorImpl.java
@@ -1,163 +1,162 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.bytecode.instrumentation.internal.javassist;
 
 import java.io.Serializable;
 import java.util.Set;
 
 import org.hibernate.bytecode.instrumentation.spi.AbstractFieldInterceptor;
 import org.hibernate.bytecode.internal.javassist.FieldHandler;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.LazyInitializer;
 
 /**
  * A field-level interceptor that initializes lazily fetched properties.
  * This interceptor can be attached to classes instrumented by Javassist.
  * Note that this implementation assumes that the instance variable
  * name is the same as the name of the persistent property that must
  * be loaded.
  * </p>
  * Note: most of the interesting functionality here is farmed off
  * to the super-class.  The stuff here mainly acts as an adapter to the
  * Javassist-specific functionality, routing interception through
  * the super-class's intercept() method
  *
  * @author Steve Ebersole
  */
-@SuppressWarnings( {"UnnecessaryUnboxing", "UnnecessaryBoxing"})
 final class FieldInterceptorImpl extends AbstractFieldInterceptor implements FieldHandler, Serializable {
 
 	FieldInterceptorImpl(SessionImplementor session, Set uninitializedFields, String entityName) {
 		super( session, uninitializedFields, entityName );
 	}
 
 
 	// FieldHandler impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-
+	@Override
 	public boolean readBoolean(Object target, String name, boolean oldValue) {
-		return ( (Boolean) intercept( target, name, oldValue ) ).booleanValue();
+		return (Boolean) intercept( target, name, oldValue );
 	}
-
+	@Override
 	public byte readByte(Object target, String name, byte oldValue) {
-		return ( (Byte) intercept( target, name, Byte.valueOf( oldValue ) ) ).byteValue();
+		return (Byte) intercept( target, name, oldValue );
 	}
-
+	@Override
 	public char readChar(Object target, String name, char oldValue) {
-		return ( (Character) intercept( target, name, Character.valueOf( oldValue ) ) ).charValue();
+		return (Character) intercept( target, name, oldValue );
 	}
-
+	@Override
 	public double readDouble(Object target, String name, double oldValue) {
-		return ( (Double) intercept( target, name, Double.valueOf( oldValue ) ) ).doubleValue();
+		return (Double) intercept( target, name, oldValue );
 	}
-
+	@Override
 	public float readFloat(Object target, String name, float oldValue) {
-		return ( (Float) intercept( target, name, Float.valueOf( oldValue ) ) ).floatValue();
+		return (Float) intercept( target, name, oldValue );
 	}
-
+	@Override
 	public int readInt(Object target, String name, int oldValue) {
-		return ( (Integer) intercept( target, name, Integer.valueOf( oldValue ) ) );
+		return (Integer) intercept( target, name, oldValue );
 	}
-
+	@Override
 	public long readLong(Object target, String name, long oldValue) {
-		return ( (Long) intercept( target, name, Long.valueOf( oldValue ) ) ).longValue();
+		return (Long) intercept( target, name, oldValue );
 	}
-
+	@Override
 	public short readShort(Object target, String name, short oldValue) {
-		return ( (Short) intercept( target, name, Short.valueOf( oldValue ) ) ).shortValue();
+		return (Short) intercept( target, name, oldValue );
 	}
-
+	@Override
 	public Object readObject(Object target, String name, Object oldValue) {
 		Object value = intercept( target, name, oldValue );
 		if ( value instanceof HibernateProxy ) {
 			final LazyInitializer li = ( (HibernateProxy) value ).getHibernateLazyInitializer();
 			if ( li.isUnwrap() ) {
 				value = li.getImplementation();
 			}
 		}
 		return value;
 	}
-
+	@Override
 	public boolean writeBoolean(Object target, String name, boolean oldValue, boolean newValue) {
 		dirty();
 		intercept( target, name, oldValue );
 		return newValue;
 	}
-
+	@Override
 	public byte writeByte(Object target, String name, byte oldValue, byte newValue) {
 		dirty();
-		intercept( target, name, Byte.valueOf( oldValue ) );
+		intercept( target, name, oldValue );
 		return newValue;
 	}
-
+	@Override
 	public char writeChar(Object target, String name, char oldValue, char newValue) {
 		dirty();
-		intercept( target, name, Character.valueOf( oldValue ) );
+		intercept( target, name, oldValue );
 		return newValue;
 	}
-
+	@Override
 	public double writeDouble(Object target, String name, double oldValue, double newValue) {
 		dirty();
-		intercept( target, name, Double.valueOf( oldValue ) );
+		intercept( target, name, oldValue );
 		return newValue;
 	}
-
+	@Override
 	public float writeFloat(Object target, String name, float oldValue, float newValue) {
 		dirty();
-		intercept( target, name, Float.valueOf( oldValue ) );
+		intercept( target, name, oldValue );
 		return newValue;
 	}
-
+	@Override
 	public int writeInt(Object target, String name, int oldValue, int newValue) {
 		dirty();
-		intercept( target, name, Integer.valueOf( oldValue ) );
+		intercept( target, name, oldValue );
 		return newValue;
 	}
-
+	@Override
 	public long writeLong(Object target, String name, long oldValue, long newValue) {
 		dirty();
-		intercept( target, name, Long.valueOf( oldValue ) );
+		intercept( target, name, oldValue );
 		return newValue;
 	}
-
+	@Override
 	public short writeShort(Object target, String name, short oldValue, short newValue) {
 		dirty();
-		intercept( target, name, Short.valueOf( oldValue ) );
+		intercept( target, name, oldValue );
 		return newValue;
 	}
-
+	@Override
 	public Object writeObject(Object target, String name, Object oldValue, Object newValue) {
 		dirty();
 		intercept( target, name, oldValue );
 		return newValue;
 	}
-
+	@Override
 	public String toString() {
 		return "FieldInterceptorImpl(entityName=" + getEntityName() +
 				",dirty=" + isDirty() +
 				",uninitializedFields=" + getUninitializedFields() +
 				')';
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cache/internal/StandardQueryCache.java b/hibernate-core/src/main/java/org/hibernate/cache/internal/StandardQueryCache.java
index 9d2abf41fb..e5c92ed07e 100644
--- a/hibernate-core/src/main/java/org/hibernate/cache/internal/StandardQueryCache.java
+++ b/hibernate-core/src/main/java/org/hibernate/cache/internal/StandardQueryCache.java
@@ -1,323 +1,323 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cache.internal;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Properties;
 import java.util.Set;
 import javax.persistence.EntityNotFoundException;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.UnresolvableObjectException;
 import org.hibernate.cache.CacheException;
 import org.hibernate.cache.spi.QueryCache;
 import org.hibernate.cache.spi.QueryKey;
 import org.hibernate.cache.spi.QueryResultsRegion;
 import org.hibernate.cache.spi.UpdateTimestampsCache;
 import org.hibernate.cfg.Settings;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeHelper;
 
 /**
  * The standard implementation of the Hibernate QueryCache interface.  This
  * implementation is very good at recognizing stale query results and
  * and re-running queries when it detects this condition, re-caching the new
  * results.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class StandardQueryCache implements QueryCache {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			StandardQueryCache.class.getName()
 	);
 
 	private static final boolean DEBUGGING = LOG.isDebugEnabled();
 	private static final boolean TRACING = LOG.isTraceEnabled();
 
 	private QueryResultsRegion cacheRegion;
 	private UpdateTimestampsCache updateTimestampsCache;
 
 	/**
 	 * Constructs a StandardQueryCache instance
 	 *
 	 * @param settings The SessionFactory settings.
 	 * @param props Any properties
 	 * @param updateTimestampsCache The update-timestamps cache to use.
 	 * @param regionName The base query cache region name
 	 */
 	public StandardQueryCache(
 			final Settings settings,
 			final Properties props,
 			final UpdateTimestampsCache updateTimestampsCache,
 			final String regionName) {
 		String regionNameToUse = regionName;
 		if ( regionNameToUse == null ) {
 			regionNameToUse = StandardQueryCache.class.getName();
 		}
 		final String prefix = settings.getCacheRegionPrefix();
 		if ( prefix != null ) {
 			regionNameToUse = prefix + '.' + regionNameToUse;
 		}
 		LOG.startingQueryCache( regionNameToUse );
 
 		this.cacheRegion = settings.getRegionFactory().buildQueryResultsRegion( regionNameToUse, props );
 		this.updateTimestampsCache = updateTimestampsCache;
 	}
 
 	@Override
 	public QueryResultsRegion getRegion() {
 		return cacheRegion;
 	}
 
 	@Override
 	public void destroy() {
 		try {
 			cacheRegion.destroy();
 		}
 		catch ( Exception e ) {
 			LOG.unableToDestroyQueryCache( cacheRegion.getName(), e.getMessage() );
 		}
 	}
 
 	@Override
 	public void clear() throws CacheException {
 		cacheRegion.evictAll();
 	}
 
 	@Override
 	@SuppressWarnings({ "unchecked" })
 	public boolean put(
 			final QueryKey key,
 			final Type[] returnTypes,
 			final List result,
 			final boolean isNaturalKeyLookup,
 			final SessionImplementor session) throws HibernateException {
 		if ( isNaturalKeyLookup && result.isEmpty() ) {
 			return false;
 		}
 		final long ts = cacheRegion.nextTimestamp();
 
 		if ( DEBUGGING ) {
 			LOG.debugf( "Caching query results in region: %s; timestamp=%s", cacheRegion.getName(), ts );
 		}
 
 		final List cacheable = new ArrayList( result.size() + 1 );
 		logCachedResultDetails( key, null, returnTypes, cacheable );
 		cacheable.add( ts );
 
 		final boolean isSingleResult = returnTypes.length == 1;
 		for ( Object aResult : result ) {
 			final Serializable cacheItem = isSingleResult
 					? returnTypes[0].disassemble( aResult, session, null )
 					: TypeHelper.disassemble( (Object[]) aResult, returnTypes, null, session, null );
 			cacheable.add( cacheItem );
 			logCachedResultRowDetails( returnTypes, aResult );
 		}
 
 		cacheRegion.put( key, cacheable );
 		return true;
 	}
 
 	@Override
 	@SuppressWarnings({ "unchecked" })
 	public List get(
 			final QueryKey key,
 			final Type[] returnTypes,
 			final boolean isNaturalKeyLookup,
-			final Set spaces,
+			final Set<Serializable> spaces,
 			final SessionImplementor session) throws HibernateException {
 		if ( DEBUGGING ) {
 			LOG.debugf( "Checking cached query results in region: %s", cacheRegion.getName() );
 		}
 
 		final List cacheable = (List) cacheRegion.get( key );
 		logCachedResultDetails( key, spaces, returnTypes, cacheable );
 
 		if ( cacheable == null ) {
 			if ( DEBUGGING ) {
 				LOG.debug( "Query results were not found in cache" );
 			}
 			return null;
 		}
 
 		final Long timestamp = (Long) cacheable.get( 0 );
 		if ( !isNaturalKeyLookup && !isUpToDate( spaces, timestamp ) ) {
 			if ( DEBUGGING ) {
 				LOG.debug( "Cached query results were not up-to-date" );
 			}
 			return null;
 		}
 
 		if ( DEBUGGING ) {
 			LOG.debug( "Returning cached query results" );
 		}
 		final boolean singleResult = returnTypes.length == 1;
 		for ( int i = 1; i < cacheable.size(); i++ ) {
 			if ( singleResult ) {
 				returnTypes[0].beforeAssemble( (Serializable) cacheable.get( i ), session );
 			}
 			else {
 				TypeHelper.beforeAssemble( (Serializable[]) cacheable.get( i ), returnTypes, session );
 			}
 		}
 
 		final List result = new ArrayList( cacheable.size() - 1 );
 		for ( int i = 1; i < cacheable.size(); i++ ) {
 			try {
 				if ( singleResult ) {
 					result.add( returnTypes[0].assemble( (Serializable) cacheable.get( i ), session, null ) );
 				}
 				else {
 					result.add(
 							TypeHelper.assemble( (Serializable[]) cacheable.get( i ), returnTypes, session, null )
 					);
 				}
 				logCachedResultRowDetails( returnTypes, result.get( i - 1 ) );
 			}
 			catch ( RuntimeException ex ) {
 				if ( isNaturalKeyLookup ) {
 					// potentially perform special handling for natural-id look ups.
 					if ( UnresolvableObjectException.class.isInstance( ex )
 							|| EntityNotFoundException.class.isInstance( ex ) ) {
 						if ( DEBUGGING ) {
 							LOG.debug( "Unable to reassemble cached natural-id query result" );
 						}
 						cacheRegion.evict( key );
 
 						// EARLY EXIT !!!!!
 						return null;
 					}
 				}
 				throw ex;
 			}
 		}
 		return result;
 	}
 
-	protected boolean isUpToDate(final Set spaces, final Long timestamp) {
+	protected boolean isUpToDate(final Set<Serializable> spaces, final Long timestamp) {
 		if ( DEBUGGING ) {
 			LOG.debugf( "Checking query spaces are up-to-date: %s", spaces );
 		}
 		return updateTimestampsCache.isUpToDate( spaces, timestamp );
 	}
 
 	@Override
 	public String toString() {
 		return "StandardQueryCache(" + cacheRegion.getName() + ')';
 	}
 
 	private static void logCachedResultDetails(QueryKey key, Set querySpaces, Type[] returnTypes, List result) {
 		if ( !TRACING ) {
 			return;
 		}
 		LOG.trace( "key.hashCode=" + key.hashCode() );
 		LOG.trace( "querySpaces=" + querySpaces );
 		if ( returnTypes == null || returnTypes.length == 0 ) {
 			LOG.trace(
 					"Unexpected returnTypes is "
 							+ ( returnTypes == null ? "null" : "empty" ) + "! result"
 							+ ( result == null ? " is null" : ".size()=" + result.size() )
 			);
 		}
 		else {
 			final StringBuilder returnTypeInfo = new StringBuilder();
 			for ( Type returnType : returnTypes ) {
 				returnTypeInfo.append( "typename=" )
 						.append( returnType.getName() )
 						.append( " class=" )
 						.append( returnType.getReturnedClass().getName() )
 						.append( ' ' );
 			}
 			LOG.trace( "unexpected returnTypes is " + returnTypeInfo.toString() + "! result" );
 		}
 	}
 
 	private static void logCachedResultRowDetails(Type[] returnTypes, Object result) {
 		if ( !TRACING ) {
 			return;
 		}
 		logCachedResultRowDetails(
 				returnTypes,
 				( result instanceof Object[] ? (Object[]) result : new Object[] { result } )
 		);
 	}
 
 	private static void logCachedResultRowDetails(Type[] returnTypes, Object[] tuple) {
 		if ( !TRACING ) {
 			return;
 		}
 		if ( tuple == null ) {
 			LOG.tracef(
 					"tuple is null; returnTypes is %s",
 					returnTypes == null ? "null" : "Type[" + returnTypes.length + "]"
 			);
 			if ( returnTypes != null && returnTypes.length > 1 ) {
 				LOG.trace(
 						"Unexpected result tuple! tuple is null; should be Object["
 								+ returnTypes.length + "]!"
 				);
 			}
 		}
 		else {
 			if ( returnTypes == null || returnTypes.length == 0 ) {
 				LOG.trace(
 						"Unexpected result tuple! tuple is null; returnTypes is "
 								+ ( returnTypes == null ? "null" : "empty" )
 				);
 			}
 			LOG.tracef(
 					"tuple is Object[%s]; returnTypes is %s",
 					tuple.length,
 					returnTypes == null ? "null" : "Type[" + returnTypes.length + "]"
 			);
 			if ( returnTypes != null && tuple.length != returnTypes.length ) {
 				LOG.trace(
 						"Unexpected tuple length! transformer= expected="
 								+ returnTypes.length + " got=" + tuple.length
 				);
 			}
 			else {
 				for ( int j = 0; j < tuple.length; j++ ) {
 					if ( tuple[j] != null && returnTypes != null
 							&& ! returnTypes[j].getReturnedClass().isInstance( tuple[j] ) ) {
 						LOG.trace(
 								"Unexpected tuple value type! transformer= expected="
 										+ returnTypes[j].getReturnedClass().getName()
 										+ " got="
 										+ tuple[j].getClass().getName()
 						);
 					}
 				}
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cache/spi/QueryCache.java b/hibernate-core/src/main/java/org/hibernate/cache/spi/QueryCache.java
index ebbbc4e719..305dfbf4c9 100644
--- a/hibernate-core/src/main/java/org/hibernate/cache/spi/QueryCache.java
+++ b/hibernate-core/src/main/java/org/hibernate/cache/spi/QueryCache.java
@@ -1,92 +1,93 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cache.spi;
 
+import java.io.Serializable;
 import java.util.List;
 import java.util.Set;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cache.CacheException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.type.Type;
 
 /**
  * Defines the contract for caches capable of storing query results.  These
  * caches should only concern themselves with storing the matching result ids.
  * The transactional semantics are necessarily less strict than the semantics
  * of an item cache.
  * 
  * @author Gavin King
  */
 public interface QueryCache {
 	/**
 	 * Clear items from the query cache.
 	 *
 	 * @throws CacheException Indicates a problem delegating to the underlying cache.
 	 */
 	public void clear() throws CacheException;
 
 	/**
 	 * Put a result into the query cache.
 	 *
 	 * @param key The cache key
 	 * @param returnTypes The result types
 	 * @param result The results to cache
 	 * @param isNaturalKeyLookup Was this a natural id lookup?
 	 * @param session The originating session
 	 *
 	 * @return Whether the put actually happened.
 	 *
 	 * @throws HibernateException Indicates a problem delegating to the underlying cache.
 	 */
 	public boolean put(QueryKey key, Type[] returnTypes, List result, boolean isNaturalKeyLookup, SessionImplementor session) throws HibernateException;
 
 	/**
 	 * Get results from the cache.
 	 *
 	 * @param key The cache key
 	 * @param returnTypes The result types
 	 * @param isNaturalKeyLookup Was this a natural id lookup?
 	 * @param spaces The query spaces (used in invalidation plus validation checks)
 	 * @param session The originating session
 	 *
 	 * @return The cached results; may be null.
 	 *
 	 * @throws HibernateException Indicates a problem delegating to the underlying cache.
 	 */
-	public List get(QueryKey key, Type[] returnTypes, boolean isNaturalKeyLookup, Set spaces, SessionImplementor session) throws HibernateException;
+	public List get(QueryKey key, Type[] returnTypes, boolean isNaturalKeyLookup, Set<Serializable> spaces, SessionImplementor session) throws HibernateException;
 
 	/**
 	 * Destroy the cache.
 	 */
 	public void destroy();
 
 	/**
 	 * The underlying cache factory region being used.
 	 *
 	 * @return The cache region.
 	 */
 	public QueryResultsRegion getRegion();
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cache/spi/UpdateTimestampsCache.java b/hibernate-core/src/main/java/org/hibernate/cache/spi/UpdateTimestampsCache.java
index 470174044c..6879046284 100644
--- a/hibernate-core/src/main/java/org/hibernate/cache/spi/UpdateTimestampsCache.java
+++ b/hibernate-core/src/main/java/org/hibernate/cache/spi/UpdateTimestampsCache.java
@@ -1,222 +1,216 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cache.spi;
 
 import java.io.Serializable;
 import java.util.Properties;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.cache.CacheException;
 import org.hibernate.cfg.Settings;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 
 /**
  * Tracks the timestamps of the most recent updates to particular tables. It is
  * important that the cache timeout of the underlying cache implementation be set
  * to a higher value than the timeouts of any of the query caches. In fact, we
  * recommend that the the underlying cache not be configured for expiry at all.
  * Note, in particular, that an LRU cache expiry policy is never appropriate.
  *
  * @author Gavin King
  * @author Mikheil Kapanadze
  */
 public class UpdateTimestampsCache {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, UpdateTimestampsCache.class.getName() );
-
+	private static final boolean DEBUG_ENABLED = LOG.isDebugEnabled();
 	/**
 	 * The region name of the update-timestamps cache.
 	 */
 	public static final String REGION_NAME = UpdateTimestampsCache.class.getName();
 
 
 	private final SessionFactoryImplementor factory;
 	private final TimestampsRegion region;
 
 	/**
 	 * Constructs an UpdateTimestampsCache.
 	 *
 	 * @param settings The SessionFactory settings
 	 * @param props Any properties
 	 * @param factory The SessionFactory
 	 */
 	public UpdateTimestampsCache(Settings settings, Properties props, final SessionFactoryImplementor factory) {
 		this.factory = factory;
 		final String prefix = settings.getCacheRegionPrefix();
 		final String regionName = prefix == null ? REGION_NAME : prefix + '.' + REGION_NAME;
 
 		LOG.startingUpdateTimestampsCache( regionName );
 		this.region = settings.getRegionFactory().buildTimestampsRegion( regionName, props );
 	}
 
 	/**
 	 * Constructs an UpdateTimestampsCache.
 	 *
 	 * @param settings The SessionFactory settings
 	 * @param props Any properties
 	 */
 	@SuppressWarnings({"UnusedDeclaration"})
 	public UpdateTimestampsCache(Settings settings, Properties props) {
 		this( settings, props, null );
 	}
 
 	/**
 	 * Perform pre-invalidation.
 	 *
 	 * @param spaces The spaces to pre-invalidate
 	 *
 	 * @throws CacheException Indicated problem delegating to underlying region.
 	 */
-	@SuppressWarnings({"UnnecessaryBoxing"})
 	public void preinvalidate(Serializable[] spaces) throws CacheException {
-		final boolean debug = LOG.isDebugEnabled();
 		final boolean stats = factory != null && factory.getStatistics().isStatisticsEnabled();
 
 		final Long ts = region.nextTimestamp() + region.getTimeout();
 
 		for ( Serializable space : spaces ) {
-			if ( debug ) {
+			if ( DEBUG_ENABLED ) {
 				LOG.debugf( "Pre-invalidating space [%s], timestamp: %s", space, ts );
 			}
 			//put() has nowait semantics, is this really appropriate?
 			//note that it needs to be async replication, never local or sync
 			region.put( space, ts );
 			if ( stats ) {
 				factory.getStatisticsImplementor().updateTimestampsCachePut();
 			}
 		}
 	}
 
 	/**
 	 * Perform invalidation.
 	 *
 	 * @param spaces The spaces to pre-invalidate
 	 *
 	 * @throws CacheException Indicated problem delegating to underlying region.
 	 */
-	@SuppressWarnings({"UnnecessaryBoxing"})
 	public void invalidate(Serializable[] spaces) throws CacheException {
-		final boolean debug = LOG.isDebugEnabled();
 		final boolean stats = factory != null && factory.getStatistics().isStatisticsEnabled();
 
 		final Long ts = region.nextTimestamp();
 
 		for (Serializable space : spaces) {
-			if ( debug ) {
+			if ( DEBUG_ENABLED ) {
 				LOG.debugf( "Invalidating space [%s], timestamp: %s", space, ts );
 			}
 			//put() has nowait semantics, is this really appropriate?
 			//note that it needs to be async replication, never local or sync
 			region.put( space, ts );
 			if ( stats ) {
 				factory.getStatisticsImplementor().updateTimestampsCachePut();
 			}
 		}
 	}
 
 	/**
 	 * Perform an up-to-date check for the given set of query spaces.
 	 *
 	 * @param spaces The spaces to check
 	 * @param timestamp The timestamp against which to check.
 	 *
 	 * @return Whether all those spaces are up-to-date
 	 *
 	 * @throws CacheException Indicated problem delegating to underlying region.
 	 */
-	@SuppressWarnings({"unchecked", "UnnecessaryUnboxing"})
-	public boolean isUpToDate(Set spaces, Long timestamp) throws CacheException {
-		final boolean debug = LOG.isDebugEnabled();
+	public boolean isUpToDate(Set<Serializable> spaces, Long timestamp) throws CacheException {
 		final boolean stats = factory != null && factory.getStatistics().isStatisticsEnabled();
 
-		for ( Serializable space : (Set<Serializable>) spaces ) {
+		for ( Serializable space : spaces ) {
 			final Long lastUpdate = (Long) region.get( space );
 			if ( lastUpdate == null ) {
 				if ( stats ) {
 					factory.getStatisticsImplementor().updateTimestampsCacheMiss();
 				}
 				//the last update timestamp was lost from the cache
 				//(or there were no updates since startup!)
 				//updateTimestamps.put( space, new Long( updateTimestamps.nextTimestamp() ) );
 				//result = false; // safer
 			}
 			else {
-				if ( debug ) {
+				if ( DEBUG_ENABLED ) {
 					LOG.debugf(
 							"[%s] last update timestamp: %s",
 							space,
 							lastUpdate + ", result set timestamp: " + timestamp
 					);
 				}
 				if ( stats ) {
 					factory.getStatisticsImplementor().updateTimestampsCacheHit();
 				}
 				if ( lastUpdate >= timestamp ) {
 					return false;
 				}
 			}
 		}
 		return true;
 	}
 
 	/**
 	 * Clear the update-timestamps data.
 	 *
 	 * @throws CacheException Indicates problem delegating call to underlying region.
 	 */
 	public void clear() throws CacheException {
 		region.evictAll();
 	}
 
 	/**
 	 * Destroys the cache.
 	 *
 	 * @throws CacheException Indicates problem delegating call to underlying region.
 	 */
 	public void destroy() {
 		try {
 			region.destroy();
 		}
 		catch (Exception e) {
 			LOG.unableToDestroyUpdateTimestampsCache( region.getName(), e.getMessage() );
 		}
 	}
 
 	/**
 	 * Get the underlying cache region where data is stored..
 	 *
 	 * @return The underlying region.
 	 */
 	public TimestampsRegion getRegion() {
 		return region;
 	}
 
 	@Override
 	public String toString() {
 		return "UpdateTimestampsCache";
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cache/spi/entry/StructuredCacheEntry.java b/hibernate-core/src/main/java/org/hibernate/cache/spi/entry/StructuredCacheEntry.java
index e9107c4601..f62df21dbd 100755
--- a/hibernate-core/src/main/java/org/hibernate/cache/spi/entry/StructuredCacheEntry.java
+++ b/hibernate-core/src/main/java/org/hibernate/cache/spi/entry/StructuredCacheEntry.java
@@ -1,82 +1,81 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cache.spi.entry;
 
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.persister.entity.EntityPersister;
 
 /**
  * Structured CacheEntry format for entities.  Used to store the entry into the second-level cache
  * as a Map so that users can more easily see the cached state.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class StructuredCacheEntry implements CacheEntryStructure {
 	private EntityPersister persister;
 
 	/**
 	 * Constructs a StructuredCacheEntry strategy
 	 *
 	 * @param persister The persister whose data needs to be structured.
 	 */
 	public StructuredCacheEntry(EntityPersister persister) {
 		this.persister = persister;
 	}
 
 	@Override
-	@SuppressWarnings("UnnecessaryUnboxing")
 	public Object destructure(Object structured, SessionFactoryImplementor factory) {
 		final Map map = (Map) structured;
-		final boolean lazyPropertiesUnfetched = ( (Boolean) map.get( "_lazyPropertiesUnfetched" ) ).booleanValue();
+		final boolean lazyPropertiesUnfetched = (Boolean) map.get( "_lazyPropertiesUnfetched" );
 		final String subclass = (String) map.get( "_subclass" );
 		final Object version = map.get( "_version" );
 		final EntityPersister subclassPersister = factory.getEntityPersister( subclass );
 		final String[] names = subclassPersister.getPropertyNames();
 		final Serializable[] state = new Serializable[names.length];
 		for ( int i = 0; i < names.length; i++ ) {
 			state[i] = (Serializable) map.get( names[i] );
 		}
 		return new StandardCacheEntryImpl( state, subclass, lazyPropertiesUnfetched, version );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object structure(Object item) {
 		final CacheEntry entry = (CacheEntry) item;
 		final String[] names = persister.getPropertyNames();
 		final Map map = new HashMap(names.length+2);
 		map.put( "_subclass", entry.getSubclass() );
 		map.put( "_version", entry.getVersion() );
 		map.put( "_lazyPropertiesUnfetched", entry.areLazyPropertiesUnfetched() );
 		for ( int i=0; i<names.length; i++ ) {
 			map.put( names[i], entry.getDisassembledState()[i] );
 		}
 		return map;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java b/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
index ef240e4cb7..1b9a9954f5 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
@@ -1,3797 +1,3793 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
 import java.io.StringReader;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.TreeMap;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.jar.JarFile;
 import java.util.zip.ZipEntry;
 
 import javax.persistence.AttributeConverter;
 import javax.persistence.Embeddable;
 import javax.persistence.Entity;
 import javax.persistence.MapsId;
 
 import org.dom4j.Attribute;
 import org.dom4j.Document;
 import org.dom4j.DocumentException;
 import org.dom4j.Element;
 import org.hibernate.AnnotationException;
 import org.hibernate.AssertionFailure;
 import org.hibernate.DuplicateMappingException;
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.InvalidMappingException;
 import org.hibernate.MappingException;
 import org.hibernate.MappingNotFoundException;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.annotations.AnyMetaDef;
 import org.hibernate.annotations.common.reflection.MetadataProvider;
 import org.hibernate.annotations.common.reflection.MetadataProviderInjector;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.annotations.common.reflection.XClass;
 import org.hibernate.annotations.common.reflection.java.JavaReflectionManager;
 import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
-import org.hibernate.cache.spi.GeneralDataRegion;
 import org.hibernate.cfg.annotations.NamedEntityGraphDefinition;
 import org.hibernate.cfg.annotations.NamedProcedureCallDefinition;
 import org.hibernate.cfg.annotations.reflection.JPAMetadataProvider;
 import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.IdentifierGeneratorAggregator;
 import org.hibernate.id.PersistentIdentifierGenerator;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
 import org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory;
 import org.hibernate.id.factory.spi.MutableIdentifierGeneratorFactory;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.SessionFactoryImpl;
 import org.hibernate.internal.util.ClassLoaderHelper;
 import org.hibernate.internal.util.ConfigHelper;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.SerializationHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.internal.util.collections.JoinedIterator;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.internal.util.xml.ErrorLogger;
 import org.hibernate.internal.util.xml.MappingReader;
 import org.hibernate.internal.util.xml.Origin;
 import org.hibernate.internal.util.xml.OriginImpl;
 import org.hibernate.internal.util.xml.XMLHelper;
 import org.hibernate.internal.util.xml.XmlDocument;
 import org.hibernate.internal.util.xml.XmlDocumentImpl;
 import org.hibernate.mapping.AuxiliaryDatabaseObject;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Constraint;
 import org.hibernate.mapping.DenormalizedTable;
 import org.hibernate.mapping.FetchProfile;
 import org.hibernate.mapping.ForeignKey;
 import org.hibernate.mapping.IdGenerator;
 import org.hibernate.mapping.IdentifierCollection;
 import org.hibernate.mapping.Index;
 import org.hibernate.mapping.Join;
 import org.hibernate.mapping.MappedSuperclass;
 import org.hibernate.mapping.MetadataSource;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.mapping.Table;
 import org.hibernate.mapping.TypeDef;
 import org.hibernate.mapping.UniqueKey;
 import org.hibernate.metamodel.spi.TypeContributions;
 import org.hibernate.metamodel.spi.TypeContributor;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.secure.spi.GrantedPermission;
 import org.hibernate.secure.spi.JaccPermissionDeclarations;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.tool.hbm2ddl.DatabaseMetadata;
 import org.hibernate.tool.hbm2ddl.IndexMetadata;
 import org.hibernate.tool.hbm2ddl.SchemaUpdateScript;
 import org.hibernate.tool.hbm2ddl.TableMetadata;
 import org.hibernate.tool.hbm2ddl.UniqueConstraintSchemaUpdateStrategy;
 import org.hibernate.tuple.entity.EntityTuplizerFactory;
 import org.hibernate.type.BasicType;
 import org.hibernate.type.SerializationException;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeResolver;
 import org.hibernate.usertype.CompositeUserType;
 import org.hibernate.usertype.UserType;
 import org.jboss.logging.Logger;
 import org.xml.sax.EntityResolver;
 import org.xml.sax.InputSource;
 
 /**
  * An instance of <tt>Configuration</tt> allows the application
  * to specify properties and mapping documents to be used when
  * creating a <tt>SessionFactory</tt>. Usually an application will create
  * a single <tt>Configuration</tt>, build a single instance of
  * <tt>SessionFactory</tt> and then instantiate <tt>Session</tt>s in
  * threads servicing client requests. The <tt>Configuration</tt> is meant
  * only as an initialization-time object. <tt>SessionFactory</tt>s are
  * immutable and do not retain any association back to the
  * <tt>Configuration</tt>.<br>
  * <br>
  * A new <tt>Configuration</tt> will use the properties specified in
  * <tt>hibernate.properties</tt> by default.
  * <p/>
  * NOTE : This will be replaced by use of {@link org.hibernate.boot.registry.StandardServiceRegistryBuilder} and
  * {@link org.hibernate.metamodel.MetadataSources} instead after the 4.0 release at which point this class will become
  * deprecated and scheduled for removal in 5.0.  See
  * <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-6183">HHH-6183</a>,
  * <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-2578">HHH-2578</a> and
  * <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-6586">HHH-6586</a> for details
  *
  * @author Gavin King
  * @see org.hibernate.SessionFactory
  */
 @SuppressWarnings( {"UnusedDeclaration"})
 public class Configuration implements Serializable {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, Configuration.class.getName());
 
 	public static final String DEFAULT_CACHE_CONCURRENCY_STRATEGY = AvailableSettings.DEFAULT_CACHE_CONCURRENCY_STRATEGY;
 
 	public static final String USE_NEW_ID_GENERATOR_MAPPINGS = AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS;
 
 	public static final String ARTEFACT_PROCESSING_ORDER = "hibernate.mapping.precedence";
 
 	/**
 	 * Class name of the class needed to enable Search.
 	 */
 	private static final String SEARCH_STARTUP_CLASS = "org.hibernate.search.event.EventListenerRegister";
 
 	/**
 	 * Method to call to enable Search.
 	 */
 	private static final String SEARCH_STARTUP_METHOD = "enableHibernateSearch";
 
 	protected MetadataSourceQueue metadataSourceQueue;
 	private transient ReflectionManager reflectionManager;
 
 	protected Map<String, PersistentClass> classes;
 	protected Map<String, String> imports;
 	protected Map<String, Collection> collections;
 	protected Map<String, Table> tables;
 	protected List<AuxiliaryDatabaseObject> auxiliaryDatabaseObjects;
 
 	protected Map<String, NamedQueryDefinition> namedQueries;
 	protected Map<String, NamedSQLQueryDefinition> namedSqlQueries;
 	protected Map<String, NamedProcedureCallDefinition> namedProcedureCallMap;
 	protected Map<String, ResultSetMappingDefinition> sqlResultSetMappings;
 	protected Map<String, NamedEntityGraphDefinition> namedEntityGraphMap;
 
 	protected Map<String, TypeDef> typeDefs;
 	protected Map<String, FilterDefinition> filterDefinitions;
 	protected Map<String, FetchProfile> fetchProfiles;
 
 	protected Map tableNameBinding;
 	protected Map columnNameBindingPerTable;
 
 	protected List<SecondPass> secondPasses;
 	protected List<Mappings.PropertyReference> propertyReferences;
 	protected Map<ExtendsQueueEntry, ?> extendsQueue;
 
 	protected Map<String, SQLFunction> sqlFunctions;
 	
 	private TypeResolver typeResolver = new TypeResolver();
 	private List<TypeContributor> typeContributorRegistrations = new ArrayList<TypeContributor>();
 
 	private EntityTuplizerFactory entityTuplizerFactory;
 //	private ComponentTuplizerFactory componentTuplizerFactory; todo : HHH-3517 and HHH-1907
 
 	private Interceptor interceptor;
 	private Properties properties;
 	private EntityResolver entityResolver;
 	private EntityNotFoundDelegate entityNotFoundDelegate;
 
 	protected transient XMLHelper xmlHelper;
 	protected NamingStrategy namingStrategy;
 	private SessionFactoryObserver sessionFactoryObserver;
 
 	protected final SettingsFactory settingsFactory;
 
 	private transient Mapping mapping = buildMapping();
 
 	private MutableIdentifierGeneratorFactory identifierGeneratorFactory;
 
 	private Map<Class<?>, org.hibernate.mapping.MappedSuperclass> mappedSuperClasses;
 
 	private Map<String, IdGenerator> namedGenerators;
 	private Map<String, Map<String, Join>> joins;
 	private Map<String, AnnotatedClassType> classTypes;
 	private Set<String> defaultNamedQueryNames;
 	private Set<String> defaultNamedNativeQueryNames;
 	private Set<String> defaultSqlResultSetMappingNames;
 	private Set<String> defaultNamedProcedure;
 
 	private Set<String> defaultNamedGenerators;
 	private Map<String, Properties> generatorTables;
 	private Map<Table, List<UniqueConstraintHolder>> uniqueConstraintHoldersByTable;
 	private Map<Table, List<JPAIndexHolder>> jpaIndexHoldersByTable;
 	private Map<String, String> mappedByResolver;
 	private Map<String, String> propertyRefResolver;
 	private Map<String, AnyMetaDef> anyMetaDefs;
 	private List<CacheHolder> caches;
 	private boolean inSecondPass = false;
 	private boolean isDefaultProcessed = false;
 	private boolean isValidatorNotPresentLogged;
 	private Map<XClass, Map<String, PropertyData>> propertiesAnnotatedWithMapsId;
 	private Map<XClass, Map<String, PropertyData>> propertiesAnnotatedWithIdAndToOne;
 	private CurrentTenantIdentifierResolver currentTenantIdentifierResolver;
 	private boolean specjProprietarySyntaxEnabled;
 
 	private ConcurrentHashMap<Class,AttributeConverterDefinition> attributeConverterDefinitionsByClass;
 
 	protected Configuration(SettingsFactory settingsFactory) {
 		this.settingsFactory = settingsFactory;
 		reset();
 	}
 
 	public Configuration() {
 		this( new SettingsFactory() );
 	}
 
 	protected void reset() {
 		metadataSourceQueue = new MetadataSourceQueue();
 		createReflectionManager();
 
 		classes = new HashMap<String,PersistentClass>();
 		imports = new HashMap<String,String>();
 		collections = new HashMap<String,Collection>();
 		tables = new TreeMap<String,Table>();
 
 		namedQueries = new HashMap<String,NamedQueryDefinition>();
 		namedSqlQueries = new HashMap<String,NamedSQLQueryDefinition>();
 		sqlResultSetMappings = new HashMap<String, ResultSetMappingDefinition>();
 		namedEntityGraphMap = new HashMap<String, NamedEntityGraphDefinition>();
 		namedProcedureCallMap = new HashMap<String, NamedProcedureCallDefinition>(  );
 		typeDefs = new HashMap<String,TypeDef>();
 		filterDefinitions = new HashMap<String, FilterDefinition>();
 		fetchProfiles = new HashMap<String, FetchProfile>();
 		auxiliaryDatabaseObjects = new ArrayList<AuxiliaryDatabaseObject>();
 
 		tableNameBinding = new HashMap();
 		columnNameBindingPerTable = new HashMap();
 
 		secondPasses = new ArrayList<SecondPass>();
 		propertyReferences = new ArrayList<Mappings.PropertyReference>();
 		extendsQueue = new HashMap<ExtendsQueueEntry, String>();
 
 		xmlHelper = new XMLHelper();
 		interceptor = EmptyInterceptor.INSTANCE;
 		properties = Environment.getProperties();
 		entityResolver = XMLHelper.DEFAULT_DTD_RESOLVER;
 
 		sqlFunctions = new HashMap<String, SQLFunction>();
 
 		entityTuplizerFactory = new EntityTuplizerFactory();
 //		componentTuplizerFactory = new ComponentTuplizerFactory();
 
 		identifierGeneratorFactory = new DefaultIdentifierGeneratorFactory();
 
 		mappedSuperClasses = new HashMap<Class<?>, MappedSuperclass>();
 
 		metadataSourcePrecedence = Collections.emptyList();
 
 		namedGenerators = new HashMap<String, IdGenerator>();
 		joins = new HashMap<String, Map<String, Join>>();
 		classTypes = new HashMap<String, AnnotatedClassType>();
 		generatorTables = new HashMap<String, Properties>();
 		defaultNamedQueryNames = new HashSet<String>();
 		defaultNamedNativeQueryNames = new HashSet<String>();
 		defaultSqlResultSetMappingNames = new HashSet<String>();
 		defaultNamedProcedure =  new HashSet<String>(  );
 		defaultNamedGenerators = new HashSet<String>();
 		uniqueConstraintHoldersByTable = new HashMap<Table, List<UniqueConstraintHolder>>();
 		jpaIndexHoldersByTable = new HashMap<Table,List<JPAIndexHolder>>(  );
 		mappedByResolver = new HashMap<String, String>();
 		propertyRefResolver = new HashMap<String, String>();
 		caches = new ArrayList<CacheHolder>();
 		namingStrategy = EJB3NamingStrategy.INSTANCE;
 		setEntityResolver( new EJB3DTDEntityResolver() );
 		anyMetaDefs = new HashMap<String, AnyMetaDef>();
 		propertiesAnnotatedWithMapsId = new HashMap<XClass, Map<String, PropertyData>>();
 		propertiesAnnotatedWithIdAndToOne = new HashMap<XClass, Map<String, PropertyData>>();
 		specjProprietarySyntaxEnabled = System.getProperty( "hibernate.enable_specj_proprietary_syntax" ) != null;
 	}
 
 	public EntityTuplizerFactory getEntityTuplizerFactory() {
 		return entityTuplizerFactory;
 	}
 
 	public ReflectionManager getReflectionManager() {
 		return reflectionManager;
 	}
 
 //	public ComponentTuplizerFactory getComponentTuplizerFactory() {
 //		return componentTuplizerFactory;
 //	}
 
 	/**
 	 * Iterate the entity mappings
 	 *
 	 * @return Iterator of the entity mappings currently contained in the configuration.
 	 */
 	public Iterator<PersistentClass> getClassMappings() {
 		return classes.values().iterator();
 	}
 
 	/**
 	 * Iterate the collection mappings
 	 *
 	 * @return Iterator of the collection mappings currently contained in the configuration.
 	 */
 	public Iterator getCollectionMappings() {
 		return collections.values().iterator();
 	}
 
 	/**
 	 * Iterate the table mappings
 	 *
 	 * @return Iterator of the table mappings currently contained in the configuration.
 	 */
 	public Iterator<Table> getTableMappings() {
 		return tables.values().iterator();
 	}
 
 	/**
 	 * Iterate the mapped super class mappings
 	 * EXPERIMENTAL Consider this API as PRIVATE
 	 *
 	 * @return iterator over the MappedSuperclass mapping currently contained in the configuration.
 	 */
 	public Iterator<MappedSuperclass> getMappedSuperclassMappings() {
 		return mappedSuperClasses.values().iterator();
 	}
 
 	/**
 	 * Get the mapping for a particular entity
 	 *
 	 * @param entityName An entity name.
 	 * @return the entity mapping information
 	 */
 	public PersistentClass getClassMapping(String entityName) {
 		return classes.get( entityName );
 	}
 
 	/**
 	 * Get the mapping for a particular collection role
 	 *
 	 * @param role a collection role
 	 * @return The collection mapping information
 	 */
 	public Collection getCollectionMapping(String role) {
 		return collections.get( role );
 	}
 
 	/**
 	 * Set a custom entity resolver. This entity resolver must be
 	 * set before addXXX(misc) call.
 	 * Default value is {@link org.hibernate.internal.util.xml.DTDEntityResolver}
 	 *
 	 * @param entityResolver entity resolver to use
 	 */
 	public void setEntityResolver(EntityResolver entityResolver) {
 		this.entityResolver = entityResolver;
 	}
 
 	public EntityResolver getEntityResolver() {
 		return entityResolver;
 	}
 
 	/**
 	 * Retrieve the user-supplied delegate to handle non-existent entity
 	 * scenarios.  May be null.
 	 *
 	 * @return The user-supplied delegate
 	 */
 	public EntityNotFoundDelegate getEntityNotFoundDelegate() {
 		return entityNotFoundDelegate;
 	}
 
 	/**
 	 * Specify a user-supplied delegate to be used to handle scenarios where an entity could not be
 	 * located by specified id.  This is mainly intended for EJB3 implementations to be able to
 	 * control how proxy initialization errors should be handled...
 	 *
 	 * @param entityNotFoundDelegate The delegate to use
 	 */
 	public void setEntityNotFoundDelegate(EntityNotFoundDelegate entityNotFoundDelegate) {
 		this.entityNotFoundDelegate = entityNotFoundDelegate;
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param xmlFile a path to a file
 	 * @return this (for method chaining purposes)
 	 * @throws org.hibernate.MappingException Indicates inability to locate or parse
 	 * the specified mapping file.
 	 * @see #addFile(java.io.File)
 	 */
 	public Configuration addFile(String xmlFile) throws MappingException {
 		return addFile( new File( xmlFile ) );
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param xmlFile a path to a file
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates inability to locate the specified mapping file.  Historically this could
 	 * have indicated a problem parsing the XML document, but that is now delayed until after {@link #buildMappings}
 	 */
 	public Configuration addFile(final File xmlFile) throws MappingException {
 		LOG.readingMappingsFromFile( xmlFile.getPath() );
 		final String name =  xmlFile.getAbsolutePath();
 		final InputSource inputSource;
 		try {
 			inputSource = new InputSource( new FileInputStream( xmlFile ) );
 		}
 		catch ( FileNotFoundException e ) {
 			throw new MappingNotFoundException( "file", xmlFile.toString() );
 		}
 		add( inputSource, "file", name );
 		return this;
 	}
 
 	private XmlDocument add(InputSource inputSource, String originType, String originName) {
 		return add( inputSource, new OriginImpl( originType, originName ) );
 	}
 
 	private XmlDocument add(InputSource inputSource, Origin origin) {
 		XmlDocument metadataXml = MappingReader.INSTANCE.readMappingDocument( entityResolver, inputSource, origin );
 		add( metadataXml );
 		return metadataXml;
 	}
 
 	public void add(XmlDocument metadataXml) {
 		if ( inSecondPass || !isOrmXml( metadataXml ) ) {
 			metadataSourceQueue.add( metadataXml );
 		}
 		else {
 			final MetadataProvider metadataProvider = ( (MetadataProviderInjector) reflectionManager ).getMetadataProvider();
 			JPAMetadataProvider jpaMetadataProvider = ( JPAMetadataProvider ) metadataProvider;
 			List<String> classNames = jpaMetadataProvider.getXMLContext().addDocument( metadataXml.getDocumentTree() );
 			for ( String className : classNames ) {
 				try {
 					metadataSourceQueue.add( reflectionManager.classForName( className, this.getClass() ) );
 				}
 				catch ( ClassNotFoundException e ) {
 					throw new AnnotationException( "Unable to load class defined in XML: " + className, e );
 				}
 			}
 		}
 	}
 
 	private static boolean isOrmXml(XmlDocument xmlDocument) {
 		return "entity-mappings".equals( xmlDocument.getDocumentTree().getRootElement().getName() );
 	}
 
 	/**
 	 * Add a cached mapping file.  A cached file is a serialized representation
 	 * of the DOM structure of a particular mapping.  It is saved from a previous
 	 * call as a file with the name <tt>xmlFile + ".bin"</tt> where xmlFile is
 	 * the name of the original mapping file.
 	 * </p>
 	 * If a cached <tt>xmlFile + ".bin"</tt> exists and is newer than
 	 * <tt>xmlFile</tt> the <tt>".bin"</tt> file will be read directly. Otherwise
 	 * xmlFile is read and then serialized to <tt>xmlFile + ".bin"</tt> for use
 	 * the next time.
 	 *
 	 * @param xmlFile The cacheable mapping file to be added.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the cached file or processing
 	 * the non-cached file.
 	 */
 	public Configuration addCacheableFile(File xmlFile) throws MappingException {
 		File cachedFile = determineCachedDomFile( xmlFile );
 
 		try {
 			return addCacheableFileStrictly( xmlFile );
 		}
 		catch ( SerializationException e ) {
 			LOG.unableToDeserializeCache( cachedFile.getPath(), e );
 		}
 		catch ( FileNotFoundException e ) {
 			LOG.cachedFileNotFound( cachedFile.getPath(), e );
 		}
 
 		final String name = xmlFile.getAbsolutePath();
 		final InputSource inputSource;
 		try {
 			inputSource = new InputSource( new FileInputStream( xmlFile ) );
 		}
 		catch ( FileNotFoundException e ) {
 			throw new MappingNotFoundException( "file", xmlFile.toString() );
 		}
 
 		LOG.readingMappingsFromFile( xmlFile.getPath() );
 		XmlDocument metadataXml = add( inputSource, "file", name );
 
 		try {
 			LOG.debugf( "Writing cache file for: %s to: %s", xmlFile, cachedFile );
 			SerializationHelper.serialize( ( Serializable ) metadataXml.getDocumentTree(), new FileOutputStream( cachedFile ) );
 		}
 		catch ( Exception e ) {
 			LOG.unableToWriteCachedFile( cachedFile.getPath(), e.getMessage() );
 		}
 
 		return this;
 	}
 
 	private File determineCachedDomFile(File xmlFile) {
 		return new File( xmlFile.getAbsolutePath() + ".bin" );
 	}
 
 	/**
 	 * <b>INTENDED FOR TESTSUITE USE ONLY!</b>
 	 * <p/>
 	 * Much like {@link #addCacheableFile(File)} except that here we will fail immediately if
 	 * the cache version cannot be found or used for whatever reason
 	 *
 	 * @param xmlFile The xml file, not the bin!
 	 *
 	 * @return The dom "deserialized" from the cached file.
 	 *
 	 * @throws SerializationException Indicates a problem deserializing the cached dom tree
 	 * @throws FileNotFoundException Indicates that the cached file was not found or was not usable.
 	 */
 	public Configuration addCacheableFileStrictly(File xmlFile) throws SerializationException, FileNotFoundException {
 		final File cachedFile = determineCachedDomFile( xmlFile );
 
 		final boolean useCachedFile = xmlFile.exists()
 				&& cachedFile.exists()
 				&& xmlFile.lastModified() < cachedFile.lastModified();
 
 		if ( ! useCachedFile ) {
 			throw new FileNotFoundException( "Cached file could not be found or could not be used" );
 		}
 
 		LOG.readingCachedMappings( cachedFile );
 		Document document = ( Document ) SerializationHelper.deserialize( new FileInputStream( cachedFile ) );
 		add( new XmlDocumentImpl( document, "file", xmlFile.getAbsolutePath() ) );
 		return this;
 	}
 
 	/**
 	 * Add a cacheable mapping file.
 	 *
 	 * @param xmlFile The name of the file to be added.  This must be in a form
 	 * useable to simply construct a {@link java.io.File} instance.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the cached file or processing
 	 * the non-cached file.
 	 * @see #addCacheableFile(java.io.File)
 	 */
 	public Configuration addCacheableFile(String xmlFile) throws MappingException {
 		return addCacheableFile( new File( xmlFile ) );
 	}
 
 
 	/**
 	 * Read mappings from a <tt>String</tt>
 	 *
 	 * @param xml an XML string
 	 * @return this (for method chaining purposes)
 	 * @throws org.hibernate.MappingException Indicates problems parsing the
 	 * given XML string
 	 */
 	public Configuration addXML(String xml) throws MappingException {
 		LOG.debugf( "Mapping XML:\n%s", xml );
 		final InputSource inputSource = new InputSource( new StringReader( xml ) );
 		add( inputSource, "string", "XML String" );
 		return this;
 	}
 
 	/**
 	 * Read mappings from a <tt>URL</tt>
 	 *
 	 * @param url The url for the mapping document to be read.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the URL or processing
 	 * the mapping document.
 	 */
 	public Configuration addURL(URL url) throws MappingException {
 		final String urlExternalForm = url.toExternalForm();
 
 		LOG.debugf( "Reading mapping document from URL : %s", urlExternalForm );
 
 		try {
 			add( url.openStream(), "URL", urlExternalForm );
 		}
 		catch ( IOException e ) {
 			throw new InvalidMappingException( "Unable to open url stream [" + urlExternalForm + "]", "URL", urlExternalForm, e );
 		}
 		return this;
 	}
 
 	private XmlDocument add(InputStream inputStream, final String type, final String name) {
 		final InputSource inputSource = new InputSource( inputStream );
 		try {
 			return add( inputSource, type, name );
 		}
 		finally {
 			try {
 				inputStream.close();
 			}
 			catch ( IOException ignore ) {
 				LOG.trace( "Was unable to close input stream");
 			}
 		}
 	}
 
 	/**
 	 * Read mappings from a DOM <tt>Document</tt>
 	 *
 	 * @param doc The DOM document
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the DOM or processing
 	 * the mapping document.
 	 */
 	public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
 		LOG.debugf( "Mapping Document:\n%s", doc );
 
 		final Document document = xmlHelper.createDOMReader().read( doc );
 		add( new XmlDocumentImpl( document, "unknown", null ) );
 
 		return this;
 	}
 
 	/**
 	 * Read mappings from an {@link java.io.InputStream}.
 	 *
 	 * @param xmlInputStream The input stream containing a DOM.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the stream, or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addInputStream(InputStream xmlInputStream) throws MappingException {
 		add( xmlInputStream, "input stream", null );
 		return this;
 	}
 
 	/**
 	 * Read mappings as a application resource (i.e. classpath lookup).
 	 *
 	 * @param resourceName The resource name
 	 * @param classLoader The class loader to use.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems locating the resource or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addResource(String resourceName, ClassLoader classLoader) throws MappingException {
 		LOG.readingMappingsFromResource( resourceName );
 		InputStream resourceInputStream = classLoader.getResourceAsStream( resourceName );
 		if ( resourceInputStream == null ) {
 			throw new MappingNotFoundException( "resource", resourceName );
 		}
 		add( resourceInputStream, "resource", resourceName );
 		return this;
 	}
 
 	/**
 	 * Read mappings as a application resourceName (i.e. classpath lookup)
 	 * trying different class loaders.
 	 *
 	 * @param resourceName The resource name
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems locating the resource or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addResource(String resourceName) throws MappingException {
 		LOG.readingMappingsFromResource( resourceName );
 		ClassLoader contextClassLoader = ClassLoaderHelper.getContextClassLoader();
 		InputStream resourceInputStream = null;
 		if ( contextClassLoader != null ) {
 			resourceInputStream = contextClassLoader.getResourceAsStream( resourceName );
 		}
 		if ( resourceInputStream == null ) {
 			resourceInputStream = Environment.class.getClassLoader().getResourceAsStream( resourceName );
 		}
 		if ( resourceInputStream == null ) {
 			throw new MappingNotFoundException( "resource", resourceName );
 		}
 		add( resourceInputStream, "resource", resourceName );
 		return this;
 	}
 
 	/**
 	 * Read a mapping as an application resource using the convention that a class
 	 * named <tt>foo.bar.Foo</tt> is mapped by a file <tt>foo/bar/Foo.hbm.xml</tt>
 	 * which can be resolved as a classpath resource.
 	 *
 	 * @param persistentClass The mapped class
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems locating the resource or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addClass(Class persistentClass) throws MappingException {
 		String mappingResourceName = persistentClass.getName().replace( '.', '/' ) + ".hbm.xml";
 		LOG.readingMappingsFromResource( mappingResourceName );
 		return addResource( mappingResourceName, persistentClass.getClassLoader() );
 	}
 
 	/**
 	 * Read metadata from the annotations associated with this class.
 	 *
 	 * @param annotatedClass The class containing annotations
 	 *
 	 * @return this (for method chaining)
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public Configuration addAnnotatedClass(Class annotatedClass) {
 		XClass xClass = reflectionManager.toXClass( annotatedClass );
 		metadataSourceQueue.add( xClass );
 		return this;
 	}
 
 	/**
 	 * Read package-level metadata.
 	 *
 	 * @param packageName java package name
 	 *
 	 * @return this (for method chaining)
 	 *
 	 * @throws MappingException in case there is an error in the mapping data
 	 */
 	public Configuration addPackage(String packageName) throws MappingException {
 		LOG.debugf( "Mapping Package %s", packageName );
 		try {
 			AnnotationBinder.bindPackage( packageName, createMappings() );
 			return this;
 		}
 		catch ( MappingException me ) {
 			LOG.unableToParseMetadata( packageName );
 			throw me;
 		}
 	}
 
 	/**
 	 * Read all mappings from a jar file
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param jar a jar file
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the jar file or
 	 * processing the contained mapping documents.
 	 */
 	public Configuration addJar(File jar) throws MappingException {
 		LOG.searchingForMappingDocuments( jar.getName() );
 		JarFile jarFile = null;
 		try {
 			try {
 				jarFile = new JarFile( jar );
 			}
 			catch (IOException ioe) {
 				throw new InvalidMappingException(
 						"Could not read mapping documents from jar: " + jar.getName(), "jar", jar.getName(),
 						ioe
 				);
 			}
 			Enumeration jarEntries = jarFile.entries();
 			while ( jarEntries.hasMoreElements() ) {
 				ZipEntry ze = (ZipEntry) jarEntries.nextElement();
 				if ( ze.getName().endsWith( ".hbm.xml" ) ) {
 					LOG.foundMappingDocument( ze.getName() );
 					try {
 						addInputStream( jarFile.getInputStream( ze ) );
 					}
 					catch (Exception e) {
 						throw new InvalidMappingException(
 								"Could not read mapping documents from jar: " + jar.getName(),
 								"jar",
 								jar.getName(),
 								e
 						);
 					}
 				}
 			}
 		}
 		finally {
 			try {
 				if ( jarFile != null ) {
 					jarFile.close();
 				}
 			}
 			catch (IOException ioe) {
 				LOG.unableToCloseJar( ioe.getMessage() );
 			}
 		}
 
 		return this;
 	}
 
 	/**
 	 * Read all mapping documents from a directory tree.
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param dir The directory
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the jar file or
 	 * processing the contained mapping documents.
 	 */
 	public Configuration addDirectory(File dir) throws MappingException {
 		File[] files = dir.listFiles();
-		for ( File file : files ) {
-			if ( file.isDirectory() ) {
-				addDirectory( file );
-			}
-			else if ( file.getName().endsWith( ".hbm.xml" ) ) {
-				addFile( file );
+		if ( files != null ) {
+			for ( File file : files ) {
+				if ( file.isDirectory() ) {
+					addDirectory( file );
+				}
+				else if ( file.getName().endsWith( ".hbm.xml" ) ) {
+					addFile( file );
+				}
 			}
 		}
 		return this;
 	}
 
 	/**
 	 * Create a new <tt>Mappings</tt> to add class and collection mappings to.
 	 *
 	 * @return The created mappings
 	 */
 	public Mappings createMappings() {
 		return new MappingsImpl();
 	}
 
 
 	@SuppressWarnings({ "unchecked" })
 	public Iterator<IdentifierGenerator> iterateGenerators(Dialect dialect) throws MappingException {
 
 		TreeMap generators = new TreeMap();
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		for ( PersistentClass pc : classes.values() ) {
 			if ( !pc.isInherited() ) {
 				IdentifierGenerator ig = pc.getIdentifier().createIdentifierGenerator(
 						getIdentifierGeneratorFactory(),
 						dialect,
 						defaultCatalog,
 						defaultSchema,
 						(RootClass) pc
 				);
 
 				if ( ig instanceof PersistentIdentifierGenerator ) {
 					generators.put( ( (PersistentIdentifierGenerator) ig ).generatorKey(), ig );
 				}
 				else if ( ig instanceof IdentifierGeneratorAggregator ) {
 					( (IdentifierGeneratorAggregator) ig ).registerPersistentGenerators( generators );
 				}
 			}
 		}
 
 		for ( Collection collection : collections.values() ) {
 			if ( collection.isIdentified() ) {
 				IdentifierGenerator ig = ( ( IdentifierCollection ) collection ).getIdentifier().createIdentifierGenerator(
 						getIdentifierGeneratorFactory(),
 						dialect,
 						defaultCatalog,
 						defaultSchema,
 						null
 				);
 
 				if ( ig instanceof PersistentIdentifierGenerator ) {
 					generators.put( ( (PersistentIdentifierGenerator) ig ).generatorKey(), ig );
 				}
 			}
 		}
 
 		return generators.values().iterator();
 	}
 
 	/**
 	 * Generate DDL for dropping tables
 	 *
 	 * @param dialect The dialect for which to generate the drop script
 
 	 * @return The sequence of DDL commands to drop the schema objects
 
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	public String[] generateDropSchemaScript(Dialect dialect) throws HibernateException {
 		secondPassCompile();
 
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		ArrayList<String> script = new ArrayList<String>( 50 );
 
 		// drop them in reverse order in case db needs it done that way...
 		{
 			ListIterator itr = auxiliaryDatabaseObjects.listIterator( auxiliaryDatabaseObjects.size() );
 			while ( itr.hasPrevious() ) {
 				AuxiliaryDatabaseObject object = (AuxiliaryDatabaseObject) itr.previous();
 				if ( object.appliesToDialect( dialect ) ) {
 					script.add( object.sqlDropString( dialect, defaultCatalog, defaultSchema ) );
 				}
 			}
 		}
 
 		if ( dialect.dropConstraints() ) {
 			Iterator itr = getTableMappings();
 			while ( itr.hasNext() ) {
 				Table table = (Table) itr.next();
 				if ( table.isPhysicalTable() ) {
 					Iterator subItr = table.getForeignKeyIterator();
 					while ( subItr.hasNext() ) {
 						ForeignKey fk = (ForeignKey) subItr.next();
 						if ( fk.isPhysicalConstraint() ) {
 							script.add(
 									fk.sqlDropString(
 											dialect,
 											defaultCatalog,
 											defaultSchema
 										)
 								);
 						}
 					}
 				}
 			}
 		}
 
 
 		Iterator itr = getTableMappings();
 		while ( itr.hasNext() ) {
 
 			Table table = (Table) itr.next();
 			if ( table.isPhysicalTable() ) {
 
 				/*Iterator subIter = table.getIndexIterator();
 				while ( subIter.hasNext() ) {
 					Index index = (Index) subIter.next();
 					if ( !index.isForeignKey() || !dialect.hasImplicitIndexForForeignKey() ) {
 						script.add( index.sqlDropString(dialect) );
 					}
 				}*/
 
 				script.add(
 						table.sqlDropString(
 								dialect,
 								defaultCatalog,
 								defaultSchema
 							)
 					);
 
 			}
 
 		}
 
 		itr = iterateGenerators( dialect );
 		while ( itr.hasNext() ) {
 			String[] lines = ( (PersistentIdentifierGenerator) itr.next() ).sqlDropStrings( dialect );
 			script.addAll( Arrays.asList( lines ) );
 		}
 
 		return ArrayHelper.toStringArray( script );
 	}
 
 	/**
 	 * @param dialect The dialect for which to generate the creation script
 	 *
 	 * @return The sequence of DDL commands to create the schema objects
 	 *
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 	 *
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public String[] generateSchemaCreationScript(Dialect dialect) throws HibernateException {
 		secondPassCompile();
 
 		ArrayList<String> script = new ArrayList<String>( 50 );
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		Iterator iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 				script.add(
 						table.sqlCreateString(
 								dialect,
 								mapping,
 								defaultCatalog,
 								defaultSchema
 							)
 					);
 				Iterator<String> comments = table.sqlCommentStrings( dialect, defaultCatalog, defaultSchema );
 				while ( comments.hasNext() ) {
 					script.add( comments.next() );
 				}
 			}
 		}
 
 		iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 
 				Iterator subIter = table.getUniqueKeyIterator();
 				while ( subIter.hasNext() ) {
 					UniqueKey uk = (UniqueKey) subIter.next();
 					String constraintString = uk.sqlCreateString( dialect, mapping, defaultCatalog, defaultSchema );
 					if (constraintString != null) script.add( constraintString );
 				}
 
 
 				subIter = table.getIndexIterator();
 				while ( subIter.hasNext() ) {
 					Index index = (Index) subIter.next();
 					script.add(
 							index.sqlCreateString(
 									dialect,
 									mapping,
 									defaultCatalog,
 									defaultSchema
 								)
 						);
 				}
 
 				if ( dialect.hasAlterTable() ) {
 					subIter = table.getForeignKeyIterator();
 					while ( subIter.hasNext() ) {
 						ForeignKey fk = (ForeignKey) subIter.next();
 						if ( fk.isPhysicalConstraint() ) {
 							script.add(
 									fk.sqlCreateString(
 											dialect, mapping,
 											defaultCatalog,
 											defaultSchema
 										)
 								);
 						}
 					}
 				}
 
 			}
 		}
 
 		iter = iterateGenerators( dialect );
 		while ( iter.hasNext() ) {
 			String[] lines = ( (PersistentIdentifierGenerator) iter.next() ).sqlCreateStrings( dialect );
 			script.addAll( Arrays.asList( lines ) );
 		}
 
 		for ( AuxiliaryDatabaseObject auxiliaryDatabaseObject : auxiliaryDatabaseObjects ) {
 			if ( auxiliaryDatabaseObject.appliesToDialect( dialect ) ) {
 				script.add( auxiliaryDatabaseObject.sqlCreateString( dialect, mapping, defaultCatalog, defaultSchema ) );
 			}
 		}
 
 		return ArrayHelper.toStringArray( script );
 	}
 
 	/**
 	 * @param dialect The dialect for which to generate the creation script
 	 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out what
 	 * should be created/altered
 	 *
 	 * @return The sequence of DDL commands to apply the schema objects
 	 *
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 	 *
 	 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 	 * 
 	 * @deprecated Use {@link #generateSchemaUpdateScriptList(Dialect, DatabaseMetadata)} instead
 	 */
 	@SuppressWarnings({ "unchecked" })
 	@Deprecated
 	public String[] generateSchemaUpdateScript(Dialect dialect, DatabaseMetadata databaseMetadata)
 			throws HibernateException {
 		List<SchemaUpdateScript> scripts = generateSchemaUpdateScriptList( dialect, databaseMetadata );
 		return SchemaUpdateScript.toStringArray( scripts );
 	}
 	
 	/**
 	 * @param dialect The dialect for which to generate the creation script
 	 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out what
 	 * should be created/altered
 	 *
 	 * @return The sequence of DDL commands to apply the schema objects
 	 *
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 	 *
 	 * @see org.hibernate.tool.hbm2ddl.SchemaUpdate
 	 */
 	public List<SchemaUpdateScript> generateSchemaUpdateScriptList(Dialect dialect, DatabaseMetadata databaseMetadata)
 			throws HibernateException {
 		secondPassCompile();
 
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 		UniqueConstraintSchemaUpdateStrategy constraintMethod = UniqueConstraintSchemaUpdateStrategy.interpret( properties
 				.get( Environment.UNIQUE_CONSTRAINT_SCHEMA_UPDATE_STRATEGY ) );
 
 		List<SchemaUpdateScript> scripts = new ArrayList<SchemaUpdateScript>();
 
 		Iterator iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			String tableSchema = ( table.getSchema() == null ) ? defaultSchema : table.getSchema();
 			String tableCatalog = ( table.getCatalog() == null ) ? defaultCatalog : table.getCatalog();
 			if ( table.isPhysicalTable() ) {
 
 				TableMetadata tableInfo = databaseMetadata.getTableMetadata( table.getName(), tableSchema,
 						tableCatalog, table.isQuoted() );
 				if ( tableInfo == null ) {
 					scripts.add( new SchemaUpdateScript( table.sqlCreateString( dialect, mapping, tableCatalog,
 							tableSchema ), false ) );
 				}
 				else {
 					Iterator<String> subiter = table.sqlAlterStrings( dialect, mapping, tableInfo, tableCatalog,
 							tableSchema );
 					while ( subiter.hasNext() ) {
 						scripts.add( new SchemaUpdateScript( subiter.next(), false ) );
 					}
 				}
 
 				Iterator<String> comments = table.sqlCommentStrings( dialect, defaultCatalog, defaultSchema );
 				while ( comments.hasNext() ) {
 					scripts.add( new SchemaUpdateScript( comments.next(), false ) );
 				}
 
 			}
 		}
 
 		iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			String tableSchema = ( table.getSchema() == null ) ? defaultSchema : table.getSchema();
 			String tableCatalog = ( table.getCatalog() == null ) ? defaultCatalog : table.getCatalog();
 			if ( table.isPhysicalTable() ) {
 
 				TableMetadata tableInfo = databaseMetadata.getTableMetadata( table.getName(), tableSchema,
 						tableCatalog, table.isQuoted() );
 
 				if (! constraintMethod.equals( UniqueConstraintSchemaUpdateStrategy.SKIP )) {
 					Iterator uniqueIter = table.getUniqueKeyIterator();
 					while ( uniqueIter.hasNext() ) {
 						final UniqueKey uniqueKey = (UniqueKey) uniqueIter.next();
 						// Skip if index already exists. Most of the time, this
 						// won't work since most Dialects use Constraints. However,
 						// keep it for the few that do use Indexes.
 						if ( tableInfo != null && StringHelper.isNotEmpty( uniqueKey.getName() ) ) {
 							final IndexMetadata meta = tableInfo.getIndexMetadata( uniqueKey.getName() );
 							if ( meta != null ) {
 								continue;
 							}
 						}
 						String constraintString = uniqueKey.sqlCreateString( dialect, mapping, tableCatalog, tableSchema );
 						if ( constraintString != null && !constraintString.isEmpty() )
 							if ( constraintMethod.equals( UniqueConstraintSchemaUpdateStrategy.DROP_RECREATE_QUIETLY ) ) {
 								String constraintDropString = uniqueKey.sqlDropString( dialect, tableCatalog, tableCatalog );
 								scripts.add( new SchemaUpdateScript( constraintDropString, true) );
 							}
 							scripts.add( new SchemaUpdateScript( constraintString, true) );
 					}
 				}
 
 				if ( dialect.hasAlterTable() ) {
 					Iterator subIter = table.getForeignKeyIterator();
 					while ( subIter.hasNext() ) {
 						ForeignKey fk = (ForeignKey) subIter.next();
 						if ( fk.isPhysicalConstraint() ) {
 							boolean create = tableInfo == null || ( tableInfo.getForeignKeyMetadata( fk ) == null && (
 							// Icky workaround for MySQL bug:
 									!( dialect instanceof MySQLDialect ) || tableInfo.getIndexMetadata( fk.getName() ) == null ) );
 							if ( create ) {
 								scripts.add( new SchemaUpdateScript( fk.sqlCreateString( dialect, mapping,
 										tableCatalog, tableSchema ), false ) );
 							}
 						}
 					}
 				}
 
 				Iterator subIter = table.getIndexIterator();
 				while ( subIter.hasNext() ) {
 					final Index index = (Index) subIter.next();
 					// Skip if index already exists
 					if ( tableInfo != null && StringHelper.isNotEmpty( index.getName() ) ) {
 						final IndexMetadata meta = tableInfo.getIndexMetadata( index.getName() );
 						if ( meta != null ) {
 							continue;
 						}
 					}
 					scripts.add( new SchemaUpdateScript( index.sqlCreateString( dialect, mapping, tableCatalog,
 							tableSchema ), false ) );
 				}
 			}
 		}
 
 		iter = iterateGenerators( dialect );
 		while ( iter.hasNext() ) {
 			PersistentIdentifierGenerator generator = (PersistentIdentifierGenerator) iter.next();
 			Object key = generator.generatorKey();
 			if ( !databaseMetadata.isSequence( key ) && !databaseMetadata.isTable( key ) ) {
 				String[] lines = generator.sqlCreateStrings( dialect );
 				scripts.addAll( SchemaUpdateScript.fromStringArray( lines, false ) );
 			}
 		}
 
 		return scripts;
 	}
 
 	public void validateSchema(Dialect dialect, DatabaseMetadata databaseMetadata)throws HibernateException {
 		secondPassCompile();
 
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		Iterator iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 
 
 				TableMetadata tableInfo = databaseMetadata.getTableMetadata(
 						table.getName(),
 						( table.getSchema() == null ) ? defaultSchema : table.getSchema(),
 						( table.getCatalog() == null ) ? defaultCatalog : table.getCatalog(),
 								table.isQuoted());
 				if ( tableInfo == null ) {
 					throw new HibernateException( "Missing table: " + table.getName() );
 				}
 				else {
 					table.validateColumns( dialect, mapping, tableInfo );
 				}
 
 			}
 		}
 
 		iter = iterateGenerators( dialect );
 		while ( iter.hasNext() ) {
 			PersistentIdentifierGenerator generator = (PersistentIdentifierGenerator) iter.next();
 			Object key = generator.generatorKey();
 			if ( !databaseMetadata.isSequence( key ) && !databaseMetadata.isTable( key ) ) {
 				throw new HibernateException( "Missing sequence or table: " + key );
 			}
 		}
 	}
 
 	private void validate() throws MappingException {
 		Iterator iter = classes.values().iterator();
 		while ( iter.hasNext() ) {
 			( (PersistentClass) iter.next() ).validate( mapping );
 		}
 		iter = collections.values().iterator();
 		while ( iter.hasNext() ) {
 			( (Collection) iter.next() ).validate( mapping );
 		}
 	}
 
 	/**
 	 * Call this to ensure the mappings are fully compiled/built. Usefull to ensure getting
 	 * access to all information in the metamodel when calling e.g. getClassMappings().
 	 */
 	public void buildMappings() {
 		secondPassCompile();
 	}
 
 	protected void secondPassCompile() throws MappingException {
 		LOG.trace( "Starting secondPassCompile() processing" );
 		
 		// TEMPORARY
 		// Ensure the correct ClassLoader is used in commons-annotations.
 		ClassLoader tccl = Thread.currentThread().getContextClassLoader();
 		Thread.currentThread().setContextClassLoader( ClassLoaderHelper.getContextClassLoader() );
 
 		//process default values first
 		{
 			if ( !isDefaultProcessed ) {
 				//use global delimiters if orm.xml declare it
 				Map defaults = reflectionManager.getDefaults();
 				final Object isDelimited = defaults.get( "delimited-identifier" );
 				if ( isDelimited != null && isDelimited == Boolean.TRUE ) {
 					getProperties().put( Environment.GLOBALLY_QUOTED_IDENTIFIERS, "true" );
 				}
 				// Set default schema name if orm.xml declares it.
 				final String schema = (String) defaults.get( "schema" );
 				if ( StringHelper.isNotEmpty( schema ) ) {
 					getProperties().put( Environment.DEFAULT_SCHEMA, schema );
 				}
 				// Set default catalog name if orm.xml declares it.
 				final String catalog = (String) defaults.get( "catalog" );
 				if ( StringHelper.isNotEmpty( catalog ) ) {
 					getProperties().put( Environment.DEFAULT_CATALOG, catalog );
 				}
 
 				AnnotationBinder.bindDefaults( createMappings() );
 				isDefaultProcessed = true;
 			}
 		}
 
 		// process metadata queue
 		{
 			metadataSourceQueue.syncAnnotatedClasses();
 			metadataSourceQueue.processMetadata( determineMetadataSourcePrecedence() );
 		}
 
 
 
 		try {
 			inSecondPass = true;
 			processSecondPassesOfType( PkDrivenByDefaultMapsIdSecondPass.class );
 			processSecondPassesOfType( SetSimpleValueTypeSecondPass.class );
 			processSecondPassesOfType( CopyIdentifierComponentSecondPass.class );
 			processFkSecondPassInOrder();
 			processSecondPassesOfType( CreateKeySecondPass.class );
 			processSecondPassesOfType( SecondaryTableSecondPass.class );
 
 			originalSecondPassCompile();
 
 			inSecondPass = false;
 		}
 		catch ( RecoverableException e ) {
 			//the exception was not recoverable after all
 			throw ( RuntimeException ) e.getCause();
 		}
 
 		// process cache queue
 		{
 			for ( CacheHolder holder : caches ) {
 				if ( holder.isClass ) {
 					applyCacheConcurrencyStrategy( holder );
 				}
 				else {
 					applyCollectionCacheConcurrencyStrategy( holder );
 				}
 			}
 			caches.clear();
 		}
 
 		for ( Map.Entry<Table, List<UniqueConstraintHolder>> tableListEntry : uniqueConstraintHoldersByTable.entrySet() ) {
 			final Table table = tableListEntry.getKey();
 			final List<UniqueConstraintHolder> uniqueConstraints = tableListEntry.getValue();
 			for ( UniqueConstraintHolder holder : uniqueConstraints ) {
 				buildUniqueKeyFromColumnNames( table, holder.getName(), holder.getColumns() );
 			}
 		}
 		
 		for(Table table : jpaIndexHoldersByTable.keySet()){
 			final List<JPAIndexHolder> jpaIndexHolders = jpaIndexHoldersByTable.get( table );
 			for ( JPAIndexHolder holder : jpaIndexHolders ) {
 				buildUniqueKeyFromColumnNames( table, holder.getName(), holder.getColumns(), holder.getOrdering(), holder.isUnique() );
 			}
 		}
 		
 		Thread.currentThread().setContextClassLoader( tccl );
 	}
 
 	private void processSecondPassesOfType(Class<? extends SecondPass> type) {
 		Iterator iter = secondPasses.iterator();
 		while ( iter.hasNext() ) {
 			SecondPass sp = ( SecondPass ) iter.next();
 			//do the second pass of simple value types first and remove them
 			if ( type.isInstance( sp ) ) {
 				sp.doSecondPass( classes );
 				iter.remove();
 			}
 		}
 	}
 
 	/**
 	 * Processes FKSecondPass instances trying to resolve any
 	 * graph circularity (ie PK made of a many to one linking to
 	 * an entity having a PK made of a ManyToOne ...).
 	 */
 	private void processFkSecondPassInOrder() {
 		LOG.debug("Processing fk mappings (*ToOne and JoinedSubclass)");
 		List<FkSecondPass> fkSecondPasses = getFKSecondPassesOnly();
 
 		if ( fkSecondPasses.size() == 0 ) {
 			return; // nothing to do here
 		}
 
 		// split FkSecondPass instances into primary key and non primary key FKs.
 		// While doing so build a map of class names to FkSecondPass instances depending on this class.
 		Map<String, Set<FkSecondPass>> isADependencyOf = new HashMap<String, Set<FkSecondPass>>();
 		List<FkSecondPass> endOfQueueFkSecondPasses = new ArrayList<FkSecondPass>( fkSecondPasses.size() );
 		for ( FkSecondPass sp : fkSecondPasses ) {
 			if ( sp.isInPrimaryKey() ) {
 				String referenceEntityName = sp.getReferencedEntityName();
 				PersistentClass classMapping = getClassMapping( referenceEntityName );
 				String dependentTable = quotedTableName(classMapping.getTable());
 				if ( !isADependencyOf.containsKey( dependentTable ) ) {
 					isADependencyOf.put( dependentTable, new HashSet<FkSecondPass>() );
 				}
 				isADependencyOf.get( dependentTable ).add( sp );
 			}
 			else {
 				endOfQueueFkSecondPasses.add( sp );
 			}
 		}
 
 		// using the isADependencyOf map we order the FkSecondPass recursively instances into the right order for processing
 		List<FkSecondPass> orderedFkSecondPasses = new ArrayList<FkSecondPass>( fkSecondPasses.size() );
 		for ( String tableName : isADependencyOf.keySet() ) {
 			buildRecursiveOrderedFkSecondPasses( orderedFkSecondPasses, isADependencyOf, tableName, tableName );
 		}
 
 		// process the ordered FkSecondPasses
 		for ( FkSecondPass sp : orderedFkSecondPasses ) {
 			sp.doSecondPass( classes );
 		}
 
 		processEndOfQueue( endOfQueueFkSecondPasses );
 	}
 
 	/**
 	 * @return Returns a list of all <code>secondPasses</code> instances which are a instance of
 	 *         <code>FkSecondPass</code>.
 	 */
 	private List<FkSecondPass> getFKSecondPassesOnly() {
 		Iterator iter = secondPasses.iterator();
 		List<FkSecondPass> fkSecondPasses = new ArrayList<FkSecondPass>( secondPasses.size() );
 		while ( iter.hasNext() ) {
 			SecondPass sp = ( SecondPass ) iter.next();
 			//do the second pass of fk before the others and remove them
 			if ( sp instanceof FkSecondPass ) {
 				fkSecondPasses.add( ( FkSecondPass ) sp );
 				iter.remove();
 			}
 		}
 		return fkSecondPasses;
 	}
 
 	/**
 	 * Recursively builds a list of FkSecondPass instances ready to be processed in this order.
 	 * Checking all dependencies recursively seems quite expensive, but the original code just relied
 	 * on some sort of table name sorting which failed in certain circumstances.
 	 * <p/>
 	 * See <tt>ANN-722</tt> and <tt>ANN-730</tt>
 	 *
 	 * @param orderedFkSecondPasses The list containing the <code>FkSecondPass<code> instances ready
 	 * for processing.
 	 * @param isADependencyOf Our lookup data structure to determine dependencies between tables
 	 * @param startTable Table name to start recursive algorithm.
 	 * @param currentTable The current table name used to check for 'new' dependencies.
 	 */
 	private void buildRecursiveOrderedFkSecondPasses(
 			List<FkSecondPass> orderedFkSecondPasses,
 			Map<String, Set<FkSecondPass>> isADependencyOf,
 			String startTable,
 			String currentTable) {
 
 		Set<FkSecondPass> dependencies = isADependencyOf.get( currentTable );
 
 		// bottom out
 		if ( dependencies == null || dependencies.size() == 0 ) {
 			return;
 		}
 
 		for ( FkSecondPass sp : dependencies ) {
 			String dependentTable = quotedTableName(sp.getValue().getTable());
 			if ( dependentTable.compareTo( startTable ) == 0 ) {
-				StringBuilder sb = new StringBuilder(
-						"Foreign key circularity dependency involving the following tables: "
-				);
-				throw new AnnotationException( sb.toString() );
+				String sb = "Foreign key circularity dependency involving the following tables: ";
+				throw new AnnotationException( sb );
 			}
 			buildRecursiveOrderedFkSecondPasses( orderedFkSecondPasses, isADependencyOf, startTable, dependentTable );
 			if ( !orderedFkSecondPasses.contains( sp ) ) {
 				orderedFkSecondPasses.add( 0, sp );
 			}
 		}
 	}
 
 	private String quotedTableName(Table table) {
 		return Table.qualify( table.getCatalog(), table.getQuotedSchema(), table.getQuotedName() );
 	}
 
 	private void processEndOfQueue(List<FkSecondPass> endOfQueueFkSecondPasses) {
 		/*
 		 * If a second pass raises a recoverableException, queue it for next round
 		 * stop of no pass has to be processed or if the number of pass to processes
 		 * does not diminish between two rounds.
 		 * If some failing pass remain, raise the original exception
 		 */
 		boolean stopProcess = false;
 		RuntimeException originalException = null;
 		while ( !stopProcess ) {
 			List<FkSecondPass> failingSecondPasses = new ArrayList<FkSecondPass>();
 			for ( FkSecondPass pass : endOfQueueFkSecondPasses ) {
 				try {
 					pass.doSecondPass( classes );
 				}
 				catch (RecoverableException e) {
 					failingSecondPasses.add( pass );
 					if ( originalException == null ) {
 						originalException = (RuntimeException) e.getCause();
 					}
 				}
 			}
 			stopProcess = failingSecondPasses.size() == 0 || failingSecondPasses.size() == endOfQueueFkSecondPasses.size();
 			endOfQueueFkSecondPasses = failingSecondPasses;
 		}
 		if ( endOfQueueFkSecondPasses.size() > 0 ) {
 			throw originalException;
 		}
 	}
 
 	private void buildUniqueKeyFromColumnNames(Table table, String keyName, String[] columnNames){
 		buildUniqueKeyFromColumnNames( table, keyName, columnNames, null, true );
 	}
 
 	private void buildUniqueKeyFromColumnNames(Table table, String keyName, String[] columnNames, String[] orderings, boolean unique) {
 		int size = columnNames.length;
 		Column[] columns = new Column[size];
 		Set<Column> unbound = new HashSet<Column>();
 		Set<Column> unboundNoLogical = new HashSet<Column>();
 		for ( int index = 0; index < size; index++ ) {
 			String column = columnNames[index];
 			try {
 				final String columnName = createMappings().getPhysicalColumnName( column, table );
 				columns[index] = new Column( columnName );
 				unbound.add( columns[index] );
 				//column equals and hashcode is based on column name
 			}
 			catch ( MappingException e ) {
 				unboundNoLogical.add( new Column( column ) );
 			}
 		}
 		
 		if ( StringHelper.isEmpty( keyName ) ) {
 			keyName = Constraint.generateName( "UK_", table, columns );
 		}
 		keyName = normalizer.normalizeIdentifierQuoting( keyName );
 		
 		if ( unique ) {
 			UniqueKey uk = table.getOrCreateUniqueKey( keyName );
 			for ( int i = 0; i < columns.length; i++ ) {
 				Column column = columns[i];
 				String order = orderings != null ? orderings[i] : null;
 				if ( table.containsColumn( column ) ) {
 					uk.addColumn( column, order );
 					unbound.remove( column );
 				}
 			}
 		}
 		else {
 			Index index = table.getOrCreateIndex( keyName );
 			for ( int i = 0; i < columns.length; i++ ) {
 				Column column = columns[i];
 				String order = orderings != null ? orderings[i] : null;
 				if ( table.containsColumn( column ) ) {
 					index.addColumn( column, order );
 					unbound.remove( column );
 				}
 			}
 		}
 
 		if ( unbound.size() > 0 || unboundNoLogical.size() > 0 ) {
 			StringBuilder sb = new StringBuilder( "Unable to create unique key constraint (" );
 			for ( String columnName : columnNames ) {
 				sb.append( columnName ).append( ", " );
 			}
 			sb.setLength( sb.length() - 2 );
 			sb.append( ") on table " ).append( table.getName() ).append( ": database column " );
 			for ( Column column : unbound ) {
 				sb.append("'").append( column.getName() ).append( "', " );
 			}
 			for ( Column column : unboundNoLogical ) {
 				sb.append("'").append( column.getName() ).append( "', " );
 			}
 			sb.setLength( sb.length() - 2 );
 			sb.append( " not found. Make sure that you use the correct column name which depends on the naming strategy in use (it may not be the same as the property name in the entity, especially for relational types)" );
 			throw new AnnotationException( sb.toString() );
 		}
 	}
 
 	private void originalSecondPassCompile() throws MappingException {
 		LOG.debug( "Processing extends queue" );
 		processExtendsQueue();
 
 		LOG.debug( "Processing collection mappings" );
 		Iterator itr = secondPasses.iterator();
 		while ( itr.hasNext() ) {
 			SecondPass sp = (SecondPass) itr.next();
 			if ( ! (sp instanceof QuerySecondPass) ) {
 				sp.doSecondPass( classes );
 				itr.remove();
 			}
 		}
 
 		LOG.debug( "Processing native query and ResultSetMapping mappings" );
 		itr = secondPasses.iterator();
 		while ( itr.hasNext() ) {
 			SecondPass sp = (SecondPass) itr.next();
 			sp.doSecondPass( classes );
 			itr.remove();
 		}
 
 		LOG.debug( "Processing association property references" );
 
 		itr = propertyReferences.iterator();
 		while ( itr.hasNext() ) {
 			Mappings.PropertyReference upr = (Mappings.PropertyReference) itr.next();
 
 			PersistentClass clazz = getClassMapping( upr.referencedClass );
 			if ( clazz == null ) {
 				throw new MappingException(
 						"property-ref to unmapped class: " +
 						upr.referencedClass
 					);
 			}
 
 			Property prop = clazz.getReferencedProperty( upr.propertyName );
 			if ( upr.unique ) {
 				( (SimpleValue) prop.getValue() ).setAlternateUniqueKey( true );
 			}
 		}
 		
 		//TODO: Somehow add the newly created foreign keys to the internal collection
 
 		LOG.debug( "Creating tables' unique integer identifiers" );
 		LOG.debug( "Processing foreign key constraints" );
 
 		itr = getTableMappings();
 		int uniqueInteger = 0;
 		Set<ForeignKey> done = new HashSet<ForeignKey>();
 		while ( itr.hasNext() ) {
 			Table table = (Table) itr.next();
 			table.setUniqueInteger( uniqueInteger++ );
 			secondPassCompileForeignKeys( table, done );
 		}
 
 	}
 
 	private int processExtendsQueue() {
 		LOG.debug( "Processing extends queue" );
 		int added = 0;
 		ExtendsQueueEntry extendsQueueEntry = findPossibleExtends();
 		while ( extendsQueueEntry != null ) {
 			metadataSourceQueue.processHbmXml( extendsQueueEntry.getMetadataXml(), extendsQueueEntry.getEntityNames() );
 			extendsQueueEntry = findPossibleExtends();
 		}
 
 		if ( extendsQueue.size() > 0 ) {
 			Iterator iterator = extendsQueue.keySet().iterator();
 			StringBuilder buf = new StringBuilder( "Following super classes referenced in extends not found: " );
 			while ( iterator.hasNext() ) {
 				final ExtendsQueueEntry entry = ( ExtendsQueueEntry ) iterator.next();
 				buf.append( entry.getExplicitName() );
 				if ( entry.getMappingPackage() != null ) {
 					buf.append( "[" ).append( entry.getMappingPackage() ).append( "]" );
 				}
 				if ( iterator.hasNext() ) {
 					buf.append( "," );
 				}
 			}
 			throw new MappingException( buf.toString() );
 		}
 
 		return added;
 	}
 
 	protected ExtendsQueueEntry findPossibleExtends() {
 		Iterator<ExtendsQueueEntry> itr = extendsQueue.keySet().iterator();
 		while ( itr.hasNext() ) {
 			final ExtendsQueueEntry entry = itr.next();
 			boolean found = getClassMapping( entry.getExplicitName() ) != null
 					|| getClassMapping( HbmBinder.getClassName( entry.getExplicitName(), entry.getMappingPackage() ) ) != null;
 			if ( found ) {
 				itr.remove();
 				return entry;
 			}
 		}
 		return null;
 	}
 
 	protected void secondPassCompileForeignKeys(Table table, Set<ForeignKey> done) throws MappingException {
 		table.createForeignKeys();
 		Iterator iter = table.getForeignKeyIterator();
 		while ( iter.hasNext() ) {
 
 			ForeignKey fk = (ForeignKey) iter.next();
 			if ( !done.contains( fk ) ) {
 				done.add( fk );
 				final String referencedEntityName = fk.getReferencedEntityName();
 				if ( referencedEntityName == null ) {
 					throw new MappingException(
 							"An association from the table " +
 							fk.getTable().getName() +
 							" does not specify the referenced entity"
 						);
 				}
 				LOG.debugf( "Resolving reference to class: %s", referencedEntityName );
 				PersistentClass referencedClass = classes.get( referencedEntityName );
 				if ( referencedClass == null ) {
 					throw new MappingException(
 							"An association from the table " +
 							fk.getTable().getName() +
 							" refers to an unmapped class: " +
 							referencedEntityName
 						);
 				}
 				if ( referencedClass.isJoinedSubclass() ) {
 					secondPassCompileForeignKeys( referencedClass.getSuperclass().getTable(), done );
 				}
 				fk.setReferencedTable( referencedClass.getTable() );
 				fk.alignColumns();
 			}
 		}
 	}
 
 	public Map<String, NamedQueryDefinition> getNamedQueries() {
 		return namedQueries;
 	}
 
 	public Map<String, NamedProcedureCallDefinition> getNamedProcedureCallMap() {
 		return namedProcedureCallMap;
 	}
 
 	/**
 	 * Create a {@link SessionFactory} using the properties and mappings in this configuration. The
 	 * {@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} after
 	 * building the {@link SessionFactory} will not affect it.
 	 *
 	 * @param serviceRegistry The registry of services to be used in creating this session factory.
 	 *
 	 * @return The built {@link SessionFactory}
 	 *
 	 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 	 */
 	public SessionFactory buildSessionFactory(ServiceRegistry serviceRegistry) throws HibernateException {
 		LOG.debugf( "Preparing to build session factory with filters : %s", filterDefinitions );
 		
 		buildTypeRegistrations( serviceRegistry );
 		secondPassCompile();
 		if ( !metadataSourceQueue.isEmpty() ) {
 			LOG.incompleteMappingMetadataCacheProcessing();
 		}
 
 		validate();
 
 		Environment.verifyProperties( properties );
 		Properties copy = new Properties();
 		copy.putAll( properties );
 		ConfigurationHelper.resolvePlaceHolders( copy );
 		Settings settings = buildSettings( copy, serviceRegistry );
 
 		return new SessionFactoryImpl(
 				this,
 				mapping,
 				serviceRegistry,
 				settings,
 				sessionFactoryObserver
 			);
 	}
 	
 	private void buildTypeRegistrations(ServiceRegistry serviceRegistry) {
 		final TypeContributions typeContributions = new TypeContributions() {
 			@Override
 			public void contributeType(BasicType type) {
 				typeResolver.registerTypeOverride( type );
 			}
 
 			@Override
 			public void contributeType(UserType type, String[] keys) {
 				typeResolver.registerTypeOverride( type, keys );
 			}
 
 			@Override
 			public void contributeType(CompositeUserType type, String[] keys) {
 				typeResolver.registerTypeOverride( type, keys );
 			}
 		};
 
 		// add Dialect contributed types
 		final Dialect dialect = serviceRegistry.getService( JdbcServices.class ).getDialect();
 		dialect.contributeTypes( typeContributions, serviceRegistry );
 
 		// add TypeContributor contributed types.
 		ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 		for ( TypeContributor contributor : classLoaderService.loadJavaServices( TypeContributor.class ) ) {
 			contributor.contribute( typeContributions, serviceRegistry );
 		}
 		// from app registrations
 		for ( TypeContributor contributor : typeContributorRegistrations ) {
 			contributor.contribute( typeContributions, serviceRegistry );
 		}
 	}
 
 	/**
 	 * Create a {@link SessionFactory} using the properties and mappings in this configuration. The
 	 * {@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} after
 	 * building the {@link SessionFactory} will not affect it.
 	 *
 	 * @return The build {@link SessionFactory}
 	 *
 	 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 	 *
 	 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 	 */
 	public SessionFactory buildSessionFactory() throws HibernateException {
 		Environment.verifyProperties( properties );
 		ConfigurationHelper.resolvePlaceHolders( properties );
 		final ServiceRegistry serviceRegistry =  new StandardServiceRegistryBuilder()
 				.applySettings( properties )
 				.build();
 		setSessionFactoryObserver(
 				new SessionFactoryObserver() {
 					@Override
 					public void sessionFactoryCreated(SessionFactory factory) {
 					}
 
 					@Override
 					public void sessionFactoryClosed(SessionFactory factory) {
 						( (StandardServiceRegistryImpl) serviceRegistry ).destroy();
 					}
 				}
 		);
 		return buildSessionFactory( serviceRegistry );
 	}
 
 	/**
 	 * Retrieve the configured {@link Interceptor}.
 	 *
 	 * @return The current {@link Interceptor}
 	 */
 	public Interceptor getInterceptor() {
 		return interceptor;
 	}
 
 	/**
 	 * Set the current {@link Interceptor}
 	 *
 	 * @param interceptor The {@link Interceptor} to use for the {@link #buildSessionFactory built}
 	 * {@link SessionFactory}.
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setInterceptor(Interceptor interceptor) {
 		this.interceptor = interceptor;
 		return this;
 	}
 
 	/**
 	 * Get all properties
 	 *
 	 * @return all properties
 	 */
 	public Properties getProperties() {
 		return properties;
 	}
 
 	/**
 	 * Get a property value by name
 	 *
 	 * @param propertyName The name of the property
 	 *
 	 * @return The value currently associated with that property name; may be null.
 	 */
 	public String getProperty(String propertyName) {
 		return properties.getProperty( propertyName );
 	}
 
 	/**
 	 * Specify a completely new set of properties
 	 *
 	 * @param properties The new set of properties
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setProperties(Properties properties) {
 		this.properties = properties;
 		return this;
 	}
 
 	/**
 	 * Add the given properties to ours.
 	 *
 	 * @param extraProperties The properties to add.
 	 *
 	 * @return this for method chaining
 	 *
 	 */
 	public Configuration addProperties(Properties extraProperties) {
 		this.properties.putAll( extraProperties );
 		return this;
 	}
 
 	/**
 	 * Adds the incoming properties to the internal properties structure, as long as the internal structure does not
 	 * already contain an entry for the given key.
 	 *
 	 * @param properties The properties to merge
 	 *
 	 * @return this for ethod chaining
 	 */
 	public Configuration mergeProperties(Properties properties) {
 		for ( Map.Entry entry : properties.entrySet() ) {
 			if ( this.properties.containsKey( entry.getKey() ) ) {
 				continue;
 			}
 			this.properties.setProperty( (String) entry.getKey(), (String) entry.getValue() );
 		}
 		return this;
 	}
 
 	/**
 	 * Set a property value by name
 	 *
 	 * @param propertyName The name of the property to set
 	 * @param value The new property value
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setProperty(String propertyName, String value) {
 		properties.setProperty( propertyName, value );
 		return this;
 	}
 
 	private void addProperties(Element parent) {
 		Iterator itr = parent.elementIterator( "property" );
 		while ( itr.hasNext() ) {
 			Element node = (Element) itr.next();
 			String name = node.attributeValue( "name" );
 			String value = node.getText().trim();
 			LOG.debugf( "%s=%s", name, value );
 			properties.setProperty( name, value );
 			if ( !name.startsWith( "hibernate" ) ) {
 				properties.setProperty( "hibernate." + name, value );
 			}
 		}
 		Environment.verifyProperties( properties );
 	}
 
 	/**
 	 * Use the mappings and properties specified in an application resource named <tt>hibernate.cfg.xml</tt>.
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates we cannot find <tt>hibernate.cfg.xml</tt>
 	 *
 	 * @see #configure(String)
 	 */
 	public Configuration configure() throws HibernateException {
 		configure( "/hibernate.cfg.xml" );
 		return this;
 	}
 
 	/**
 	 * Use the mappings and properties specified in the given application resource. The format of the resource is
 	 * defined in <tt>hibernate-configuration-3.0.dtd</tt>.
 	 * <p/>
 	 * The resource is found via {@link #getConfigurationInputStream}
 	 *
 	 * @param resource The resource to use
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates we cannot find the named resource
 	 *
 	 * @see #doConfigure(java.io.InputStream, String)
 	 */
 	public Configuration configure(String resource) throws HibernateException {
 		LOG.configuringFromResource( resource );
 		InputStream stream = getConfigurationInputStream( resource );
 		return doConfigure( stream, resource );
 	}
 
 	/**
 	 * Get the configuration file as an <tt>InputStream</tt>. Might be overridden
 	 * by subclasses to allow the configuration to be located by some arbitrary
 	 * mechanism.
 	 * <p/>
 	 * By default here we use classpath resource resolution
 	 *
 	 * @param resource The resource to locate
 	 *
 	 * @return The stream
 	 *
 	 * @throws HibernateException Generally indicates we cannot find the named resource
 	 */
 	protected InputStream getConfigurationInputStream(String resource) throws HibernateException {
 		LOG.configurationResource( resource );
 		return ConfigHelper.getResourceAsStream( resource );
 	}
 
 	/**
 	 * Use the mappings and properties specified in the given document. The format of the document is defined in
 	 * <tt>hibernate-configuration-3.0.dtd</tt>.
 	 *
 	 * @param url URL from which you wish to load the configuration
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates a problem access the url
 	 *
 	 * @see #doConfigure(java.io.InputStream, String)
 	 */
 	public Configuration configure(URL url) throws HibernateException {
 		LOG.configuringFromUrl( url );
 		try {
 			return doConfigure( url.openStream(), url.toString() );
 		}
 		catch (IOException ioe) {
 			throw new HibernateException( "could not configure from URL: " + url, ioe );
 		}
 	}
 
 	/**
 	 * Use the mappings and properties specified in the given application file. The format of the file is defined in
 	 * <tt>hibernate-configuration-3.0.dtd</tt>.
 	 *
 	 * @param configFile File from which you wish to load the configuration
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates a problem access the file
 	 *
 	 * @see #doConfigure(java.io.InputStream, String)
 	 */
 	public Configuration configure(File configFile) throws HibernateException {
 		LOG.configuringFromFile( configFile.getName() );
 		try {
 			return doConfigure( new FileInputStream( configFile ), configFile.toString() );
 		}
 		catch (FileNotFoundException fnfe) {
 			throw new HibernateException( "could not find file: " + configFile, fnfe );
 		}
 	}
 
 	/**
 	 * Configure this configuration's state from the contents of the given input stream.  The expectation is that
 	 * the stream contents represent an XML document conforming to the Hibernate Configuration DTD.  See
 	 * {@link #doConfigure(Document)} for further details.
 	 *
 	 * @param stream The input stream from which to read
 	 * @param resourceName The name to use in warning/error messages
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Indicates a problem reading the stream contents.
 	 */
 	protected Configuration doConfigure(InputStream stream, String resourceName) throws HibernateException {
 		try {
 			ErrorLogger errorLogger = new ErrorLogger( resourceName );
 			Document document = xmlHelper.createSAXReader( errorLogger,  entityResolver )
 					.read( new InputSource( stream ) );
 			if ( errorLogger.hasErrors() ) {
 				throw new MappingException( "invalid configuration", errorLogger.getErrors().get( 0 ) );
 			}
 			doConfigure( document );
 		}
 		catch (DocumentException e) {
 			throw new HibernateException( "Could not parse configuration: " + resourceName, e );
 		}
 		finally {
 			try {
 				stream.close();
 			}
 			catch (IOException ioe) {
 				LOG.unableToCloseInputStreamForResource( resourceName, ioe );
 			}
 		}
 		return this;
 	}
 
 	/**
 	 * Use the mappings and properties specified in the given XML document.
 	 * The format of the file is defined in
 	 * <tt>hibernate-configuration-3.0.dtd</tt>.
 	 *
 	 * @param document an XML document from which you wish to load the configuration
 	 * @return A configuration configured via the <tt>Document</tt>
 	 * @throws HibernateException if there is problem in accessing the file.
 	 */
 	public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
 		LOG.configuringFromXmlDocument();
 		return doConfigure( xmlHelper.createDOMReader().read( document ) );
 	}
 
 	/**
 	 * Parse a dom4j document conforming to the Hibernate Configuration DTD (<tt>hibernate-configuration-3.0.dtd</tt>)
 	 * and use its information to configure this {@link Configuration}'s state
 	 *
 	 * @param doc The dom4j document
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Indicates a problem performing the configuration task
 	 */
 	protected Configuration doConfigure(Document doc) throws HibernateException {
 		Element sfNode = doc.getRootElement().element( "session-factory" );
 		String name = sfNode.attributeValue( "name" );
 		if ( name != null ) {
 			properties.setProperty( Environment.SESSION_FACTORY_NAME, name );
 		}
 		addProperties( sfNode );
 		parseSessionFactory( sfNode, name );
 
 		Element secNode = doc.getRootElement().element( "security" );
 		if ( secNode != null ) {
 			parseSecurity( secNode );
 		}
 
 		LOG.configuredSessionFactory( name );
 		LOG.debugf( "Properties: %s", properties );
 
 		return this;
 	}
 
 
 	private void parseSessionFactory(Element sfNode, String name) {
 		Iterator elements = sfNode.elementIterator();
 		while ( elements.hasNext() ) {
 			Element subelement = (Element) elements.next();
 			String subelementName = subelement.getName();
 			if ( "mapping".equals( subelementName ) ) {
 				parseMappingElement( subelement, name );
 			}
 			else if ( "class-cache".equals( subelementName ) ) {
 				String className = subelement.attributeValue( "class" );
 				Attribute regionNode = subelement.attribute( "region" );
 				final String region = ( regionNode == null ) ? className : regionNode.getValue();
 				boolean includeLazy = !"non-lazy".equals( subelement.attributeValue( "include" ) );
 				setCacheConcurrencyStrategy( className, subelement.attributeValue( "usage" ), region, includeLazy );
 			}
 			else if ( "collection-cache".equals( subelementName ) ) {
 				String role = subelement.attributeValue( "collection" );
 				Attribute regionNode = subelement.attribute( "region" );
 				final String region = ( regionNode == null ) ? role : regionNode.getValue();
 				setCollectionCacheConcurrencyStrategy( role, subelement.attributeValue( "usage" ), region );
 			}
 		}
 	}
 
 	private void parseMappingElement(Element mappingElement, String name) {
 		final Attribute resourceAttribute = mappingElement.attribute( "resource" );
 		final Attribute fileAttribute = mappingElement.attribute( "file" );
 		final Attribute jarAttribute = mappingElement.attribute( "jar" );
 		final Attribute packageAttribute = mappingElement.attribute( "package" );
 		final Attribute classAttribute = mappingElement.attribute( "class" );
 
 		if ( resourceAttribute != null ) {
 			final String resourceName = resourceAttribute.getValue();
 			LOG.debugf( "Session-factory config [%s] named resource [%s] for mapping", name, resourceName );
 			addResource( resourceName );
 		}
 		else if ( fileAttribute != null ) {
 			final String fileName = fileAttribute.getValue();
 			LOG.debugf( "Session-factory config [%s] named file [%s] for mapping", name, fileName );
 			addFile( fileName );
 		}
 		else if ( jarAttribute != null ) {
 			final String jarFileName = jarAttribute.getValue();
 			LOG.debugf( "Session-factory config [%s] named jar file [%s] for mapping", name, jarFileName );
 			addJar( new File( jarFileName ) );
 		}
 		else if ( packageAttribute != null ) {
 			final String packageName = packageAttribute.getValue();
 			LOG.debugf( "Session-factory config [%s] named package [%s] for mapping", name, packageName );
 			addPackage( packageName );
 		}
 		else if ( classAttribute != null ) {
 			final String className = classAttribute.getValue();
 			LOG.debugf( "Session-factory config [%s] named class [%s] for mapping", name, className );
 			try {
 				addAnnotatedClass( ReflectHelper.classForName( className ) );
 			}
 			catch ( Exception e ) {
 				throw new MappingException(
 						"Unable to load class [ " + className + "] declared in Hibernate configuration <mapping/> entry",
 						e
 				);
 			}
 		}
 		else {
 			throw new MappingException( "<mapping> element in configuration specifies no known attributes" );
 		}
 	}
 
 	private JaccPermissionDeclarations jaccPermissionDeclarations;
 
 	private void parseSecurity(Element secNode) {
 		final String nodeContextId = secNode.attributeValue( "context" );
 
 		final String explicitContextId = getProperty( AvailableSettings.JACC_CONTEXT_ID );
 		if ( explicitContextId == null ) {
 			setProperty( AvailableSettings.JACC_CONTEXT_ID, nodeContextId );
 			LOG.jaccContextId( nodeContextId );
 		}
 		else {
 			// if they dont match, throw an error
 			if ( ! nodeContextId.equals( explicitContextId ) ) {
 				throw new HibernateException( "Non-matching JACC context ids" );
 			}
 		}
 		jaccPermissionDeclarations = new JaccPermissionDeclarations( nodeContextId );
 
 		Iterator grantElements = secNode.elementIterator();
 		while ( grantElements.hasNext() ) {
 			final Element grantElement = (Element) grantElements.next();
 			final String elementName = grantElement.getName();
 			if ( "grant".equals( elementName ) ) {
 				jaccPermissionDeclarations.addPermissionDeclaration(
 						new GrantedPermission(
 								grantElement.attributeValue( "role" ),
 								grantElement.attributeValue( "entity-name" ),
 								grantElement.attributeValue( "actions" )
 						)
 				);
 			}
 		}
 	}
 
 	public JaccPermissionDeclarations getJaccPermissionDeclarations() {
 		return jaccPermissionDeclarations;
 	}
 
 	RootClass getRootClassMapping(String clazz) throws MappingException {
 		try {
 			return (RootClass) getClassMapping( clazz );
 		}
 		catch (ClassCastException cce) {
 			throw new MappingException( "You may only specify a cache for root <class> mappings" );
 		}
 	}
 
 	/**
 	 * Set up a cache for an entity class
 	 *
 	 * @param entityName The name of the entity to which we shoudl associate these cache settings
 	 * @param concurrencyStrategy The cache strategy to use
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy) {
 		setCacheConcurrencyStrategy( entityName, concurrencyStrategy, entityName );
 		return this;
 	}
 
 	/**
 	 * Set up a cache for an entity class, giving an explicit region name
 	 *
 	 * @param entityName The name of the entity to which we should associate these cache settings
 	 * @param concurrencyStrategy The cache strategy to use
 	 * @param region The name of the cache region to use
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy, String region) {
 		setCacheConcurrencyStrategy( entityName, concurrencyStrategy, region, true );
 		return this;
 	}
 
 	public void setCacheConcurrencyStrategy(
 			String entityName,
 			String concurrencyStrategy,
 			String region,
 			boolean cacheLazyProperty) throws MappingException {
 		caches.add( new CacheHolder( entityName, concurrencyStrategy, region, true, cacheLazyProperty ) );
 	}
 
 	private void applyCacheConcurrencyStrategy(CacheHolder holder) {
 		RootClass rootClass = getRootClassMapping( holder.role );
 		if ( rootClass == null ) {
 			throw new MappingException( "Cannot cache an unknown entity: " + holder.role );
 		}
 		rootClass.setCacheConcurrencyStrategy( holder.usage );
 		rootClass.setCacheRegionName( holder.region );
 		rootClass.setLazyPropertiesCacheable( holder.cacheLazy );
 	}
 
 	/**
 	 * Set up a cache for a collection role
 	 *
 	 * @param collectionRole The name of the collection to which we should associate these cache settings
 	 * @param concurrencyStrategy The cache strategy to use
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setCollectionCacheConcurrencyStrategy(String collectionRole, String concurrencyStrategy) {
 		setCollectionCacheConcurrencyStrategy( collectionRole, concurrencyStrategy, collectionRole );
 		return this;
 	}
 
 	/**
 	 * Set up a cache for a collection role, giving an explicit region name
 	 *
 	 * @param collectionRole The name of the collection to which we should associate these cache settings
 	 * @param concurrencyStrategy The cache strategy to use
 	 * @param region The name of the cache region to use
 	 */
 	public void setCollectionCacheConcurrencyStrategy(String collectionRole, String concurrencyStrategy, String region) {
 		caches.add( new CacheHolder( collectionRole, concurrencyStrategy, region, false, false ) );
 	}
 
 	private void applyCollectionCacheConcurrencyStrategy(CacheHolder holder) {
 		Collection collection = getCollectionMapping( holder.role );
 		if ( collection == null ) {
 			throw new MappingException( "Cannot cache an unknown collection: " + holder.role );
 		}
 		collection.setCacheConcurrencyStrategy( holder.usage );
 		collection.setCacheRegionName( holder.region );
 	}
 
 	/**
 	 * Get the query language imports
 	 *
 	 * @return a mapping from "import" names to fully qualified class names
 	 */
 	public Map<String,String> getImports() {
 		return imports;
 	}
 
 	/**
 	 * Create an object-oriented view of the configuration properties
 	 *
 	 * @param serviceRegistry The registry of services to be used in building these settings.
 	 *
 	 * @return The build settings
 	 */
 	public Settings buildSettings(ServiceRegistry serviceRegistry) {
 		Properties clone = ( Properties ) properties.clone();
 		ConfigurationHelper.resolvePlaceHolders( clone );
 		return buildSettingsInternal( clone, serviceRegistry );
 	}
 
 	public Settings buildSettings(Properties props, ServiceRegistry serviceRegistry) throws HibernateException {
 		return buildSettingsInternal( props, serviceRegistry );
 	}
 
 	private Settings buildSettingsInternal(Properties props, ServiceRegistry serviceRegistry) {
 		final Settings settings = settingsFactory.buildSettings( props, serviceRegistry );
 		settings.setEntityTuplizerFactory( this.getEntityTuplizerFactory() );
 //		settings.setComponentTuplizerFactory( this.getComponentTuplizerFactory() );
 		return settings;
 	}
 
 	public Map getNamedSQLQueries() {
 		return namedSqlQueries;
 	}
 
 	public Map getSqlResultSetMappings() {
 		return sqlResultSetMappings;
 	}
 
 	public NamingStrategy getNamingStrategy() {
 		return namingStrategy;
 	}
 
 	/**
 	 * Set a custom naming strategy
 	 *
 	 * @param namingStrategy the NamingStrategy to set
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setNamingStrategy(NamingStrategy namingStrategy) {
 		this.namingStrategy = namingStrategy;
 		return this;
 	}
 
 	/**
 	 * Retrieve the IdentifierGeneratorFactory in effect for this configuration.
 	 *
 	 * @return This configuration's IdentifierGeneratorFactory.
 	 */
 	public MutableIdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 		return identifierGeneratorFactory;
 	}
 
 	public Mapping buildMapping() {
 		return new Mapping() {
 			public IdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 				return identifierGeneratorFactory;
 			}
 
 			/**
 			 * Returns the identifier type of a mapped class
 			 */
 			public Type getIdentifierType(String entityName) throws MappingException {
 				PersistentClass pc = classes.get( entityName );
 				if ( pc == null ) {
 					throw new MappingException( "persistent class not known: " + entityName );
 				}
 				return pc.getIdentifier().getType();
 			}
 
 			public String getIdentifierPropertyName(String entityName) throws MappingException {
 				final PersistentClass pc = classes.get( entityName );
 				if ( pc == null ) {
 					throw new MappingException( "persistent class not known: " + entityName );
 				}
 				if ( !pc.hasIdentifierProperty() ) {
 					return null;
 				}
 				return pc.getIdentifierProperty().getName();
 			}
 
 			public Type getReferencedPropertyType(String entityName, String propertyName) throws MappingException {
 				final PersistentClass pc = classes.get( entityName );
 				if ( pc == null ) {
 					throw new MappingException( "persistent class not known: " + entityName );
 				}
 				Property prop = pc.getReferencedProperty( propertyName );
 				if ( prop == null ) {
 					throw new MappingException(
 							"property not known: " +
 							entityName + '.' + propertyName
 						);
 				}
 				return prop.getType();
 			}
 		};
 	}
 
 	private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
 		//we need  reflectionManager before reading the other components (MetadataSourceQueue in particular)
 		final MetadataProvider metadataProvider = (MetadataProvider) ois.readObject();
 		this.mapping = buildMapping();
 		xmlHelper = new XMLHelper();
 		createReflectionManager(metadataProvider);
 		ois.defaultReadObject();
 	}
 
 	private void writeObject(java.io.ObjectOutputStream out) throws IOException {
 		//We write MetadataProvider first as we need  reflectionManager before reading the other components
 		final MetadataProvider metadataProvider = ( ( MetadataProviderInjector ) reflectionManager ).getMetadataProvider();
 		out.writeObject( metadataProvider );
 		out.defaultWriteObject();
 	}
 
 	private void createReflectionManager() {
 		createReflectionManager( new JPAMetadataProvider() );
 	}
 
 	private void createReflectionManager(MetadataProvider metadataProvider) {
 		reflectionManager = new JavaReflectionManager();
 		( ( MetadataProviderInjector ) reflectionManager ).setMetadataProvider( metadataProvider );
 	}
 
 	public Map getFilterDefinitions() {
 		return filterDefinitions;
 	}
 
 	public void addFilterDefinition(FilterDefinition definition) {
 		filterDefinitions.put( definition.getFilterName(), definition );
 	}
 
 	public Iterator iterateFetchProfiles() {
 		return fetchProfiles.values().iterator();
 	}
 
 	public void addFetchProfile(FetchProfile fetchProfile) {
 		fetchProfiles.put( fetchProfile.getName(), fetchProfile );
 	}
 
 	public void addAuxiliaryDatabaseObject(AuxiliaryDatabaseObject object) {
 		auxiliaryDatabaseObjects.add( object );
 	}
 
 	public Map getSqlFunctions() {
 		return sqlFunctions;
 	}
 
 	public void addSqlFunction(String functionName, SQLFunction function) {
 		// HHH-7721: SQLFunctionRegistry expects all lowercase.  Enforce,
 		// just in case a user's customer dialect uses mixed cases.
 		sqlFunctions.put( functionName.toLowerCase(), function );
 	}
 
 	public TypeResolver getTypeResolver() {
 		return typeResolver;
 	}
 
 	/**
 	 * Allows registration of a type into the type registry.  The phrase 'override' in the method name simply
 	 * reminds that registration *potentially* replaces a previously registered type .
 	 *
 	 * @param type The type to register.
 	 */
 	public void registerTypeOverride(BasicType type) {
 		getTypeResolver().registerTypeOverride( type );
 	}
 
 
 	public void registerTypeOverride(UserType type, String[] keys) {
 		getTypeResolver().registerTypeOverride( type, keys );
 	}
 
 	public void registerTypeOverride(CompositeUserType type, String[] keys) {
 		getTypeResolver().registerTypeOverride( type, keys );
 	}
 
 	public void registerTypeContributor(TypeContributor typeContributor) {
 		typeContributorRegistrations.add( typeContributor );
 	}
 
 	public SessionFactoryObserver getSessionFactoryObserver() {
 		return sessionFactoryObserver;
 	}
 
 	public void setSessionFactoryObserver(SessionFactoryObserver sessionFactoryObserver) {
 		this.sessionFactoryObserver = sessionFactoryObserver;
 	}
 
 	public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver() {
 		return currentTenantIdentifierResolver;
 	}
 
 	public void setCurrentTenantIdentifierResolver(CurrentTenantIdentifierResolver currentTenantIdentifierResolver) {
 		this.currentTenantIdentifierResolver = currentTenantIdentifierResolver;
 	}
 
 	/**
 	 * Adds the AttributeConverter Class to this Configuration.
 	 *
 	 * @param attributeConverterClass The AttributeConverter class.
 	 * @param autoApply Should the AttributeConverter be auto applied to property types as specified
 	 * by its "entity attribute" parameterized type?
 	 */
 	public void addAttributeConverter(Class<? extends AttributeConverter> attributeConverterClass, boolean autoApply) {
 		final AttributeConverter attributeConverter;
 		try {
 			attributeConverter = attributeConverterClass.newInstance();
 		}
 		catch (Exception e) {
 			throw new AnnotationException(
 					"Unable to instantiate AttributeConverter [" + attributeConverterClass.getName() + "]"
 			);
 		}
 		addAttributeConverter( attributeConverter, autoApply );
 	}
 
 	/**
 	 * Adds the AttributeConverter instance to this Configuration.  This form is mainly intended for developers
 	 * to programatically add their own AttributeConverter instance.  HEM, instead, uses the
 	 * {@link #addAttributeConverter(Class, boolean)} form
 	 *
 	 * @param attributeConverter The AttributeConverter instance.
 	 * @param autoApply Should the AttributeConverter be auto applied to property types as specified
 	 * by its "entity attribute" parameterized type?
 	 */
 	public void addAttributeConverter(AttributeConverter attributeConverter, boolean autoApply) {
 		if ( attributeConverterDefinitionsByClass == null ) {
 			attributeConverterDefinitionsByClass = new ConcurrentHashMap<Class, AttributeConverterDefinition>();
 		}
 
 		final Object old = attributeConverterDefinitionsByClass.put(
 				attributeConverter.getClass(),
 				new AttributeConverterDefinition( attributeConverter, autoApply )
 		);
 
 		if ( old != null ) {
 			throw new AssertionFailure(
 					"AttributeConverter class [" + attributeConverter.getClass() + "] registered multiple times"
 			);
 		}
 	}
 
 	public java.util.Collection<NamedEntityGraphDefinition> getNamedEntityGraphs() {
 		return namedEntityGraphMap == null
 				? Collections.<NamedEntityGraphDefinition>emptyList()
 				: namedEntityGraphMap.values();
 	}
 
 
 	// Mappings impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Internal implementation of the Mappings interface giving access to the Configuration's internal
 	 * <tt>metadata repository</tt> state ({@link Configuration#classes}, {@link Configuration#tables}, etc).
 	 */
 	@SuppressWarnings( {"deprecation", "unchecked"})
 	protected class MappingsImpl implements ExtendedMappings, Serializable {
 
 		private String schemaName;
 
 		public String getSchemaName() {
 			return schemaName;
 		}
 
 		public void setSchemaName(String schemaName) {
 			this.schemaName = schemaName;
 		}
 
 
 		private String catalogName;
 
 		public String getCatalogName() {
 			return catalogName;
 		}
 
 		public void setCatalogName(String catalogName) {
 			this.catalogName = catalogName;
 		}
 
 
 		private String defaultPackage;
 
 		public String getDefaultPackage() {
 			return defaultPackage;
 		}
 
 		public void setDefaultPackage(String defaultPackage) {
 			this.defaultPackage = defaultPackage;
 		}
 
 
 		private boolean autoImport;
 
 		public boolean isAutoImport() {
 			return autoImport;
 		}
 
 		public void setAutoImport(boolean autoImport) {
 			this.autoImport = autoImport;
 		}
 
 
 		private boolean defaultLazy;
 
 		public boolean isDefaultLazy() {
 			return defaultLazy;
 		}
 
 		public void setDefaultLazy(boolean defaultLazy) {
 			this.defaultLazy = defaultLazy;
 		}
 
 
 		private String defaultCascade;
 
 		public String getDefaultCascade() {
 			return defaultCascade;
 		}
 
 		public void setDefaultCascade(String defaultCascade) {
 			this.defaultCascade = defaultCascade;
 		}
 
 
 		private String defaultAccess;
 
 		public String getDefaultAccess() {
 			return defaultAccess;
 		}
 
 		public void setDefaultAccess(String defaultAccess) {
 			this.defaultAccess = defaultAccess;
 		}
 
 
 		public NamingStrategy getNamingStrategy() {
 			return namingStrategy;
 		}
 
 		public void setNamingStrategy(NamingStrategy namingStrategy) {
 			Configuration.this.namingStrategy = namingStrategy;
 		}
 
 		public TypeResolver getTypeResolver() {
 			return typeResolver;
 		}
 
 		public Iterator<PersistentClass> iterateClasses() {
 			return classes.values().iterator();
 		}
 
 		public PersistentClass getClass(String entityName) {
 			return classes.get( entityName );
 		}
 
 		public PersistentClass locatePersistentClassByEntityName(String entityName) {
 			PersistentClass persistentClass = classes.get( entityName );
 			if ( persistentClass == null ) {
 				String actualEntityName = imports.get( entityName );
 				if ( StringHelper.isNotEmpty( actualEntityName ) ) {
 					persistentClass = classes.get( actualEntityName );
 				}
 			}
 			return persistentClass;
 		}
 
 		public void addClass(PersistentClass persistentClass) throws DuplicateMappingException {
 			Object old = classes.put( persistentClass.getEntityName(), persistentClass );
 			if ( old != null ) {
 				throw new DuplicateMappingException( "class/entity", persistentClass.getEntityName() );
 			}
 		}
 
 		public void addImport(String entityName, String rename) throws DuplicateMappingException {
 			String existing = imports.put( rename, entityName );
 			if ( existing != null ) {
                 if (existing.equals(entityName)) LOG.duplicateImport(entityName, rename);
                 else throw new DuplicateMappingException("duplicate import: " + rename + " refers to both " + entityName + " and "
                                                          + existing + " (try using auto-import=\"false\")", "import", rename);
 			}
 		}
 
 		public Collection getCollection(String role) {
 			return collections.get( role );
 		}
 
 		public Iterator<Collection> iterateCollections() {
 			return collections.values().iterator();
 		}
 
 		public void addCollection(Collection collection) throws DuplicateMappingException {
 			Object old = collections.put( collection.getRole(), collection );
 			if ( old != null ) {
 				throw new DuplicateMappingException( "collection role", collection.getRole() );
 			}
 		}
 
 		public Table getTable(String schema, String catalog, String name) {
 			String key = Table.qualify(catalog, schema, name);
 			return tables.get( key );
 		}
 
 		public Iterator<Table> iterateTables() {
 			return tables.values().iterator();
 		}
 
 		public Table addTable(
 				String schema,
 				String catalog,
 				String name,
 				String subselect,
 				boolean isAbstract) {
 			name = getObjectNameNormalizer().normalizeIdentifierQuoting( name );
 			schema = getObjectNameNormalizer().normalizeIdentifierQuoting( schema );
 			catalog = getObjectNameNormalizer().normalizeIdentifierQuoting( catalog );
 
 			String key = subselect == null ? Table.qualify( catalog, schema, name ) : subselect;
 			Table table = tables.get( key );
 
 			if ( table == null ) {
 				table = new Table();
 				table.setAbstract( isAbstract );
 				table.setName( name );
 				table.setSchema( schema );
 				table.setCatalog( catalog );
 				table.setSubselect( subselect );
 				tables.put( key, table );
 			}
 			else {
 				if ( !isAbstract ) {
 					table.setAbstract( false );
 				}
 			}
 
 			return table;
 		}
 
 		public Table addDenormalizedTable(
 				String schema,
 				String catalog,
 				String name,
 				boolean isAbstract,
 				String subselect,
 				Table includedTable) throws DuplicateMappingException {
 			name = getObjectNameNormalizer().normalizeIdentifierQuoting( name );
 			schema = getObjectNameNormalizer().normalizeIdentifierQuoting( schema );
 			catalog = getObjectNameNormalizer().normalizeIdentifierQuoting( catalog );
 
 			String key = subselect == null ? Table.qualify(catalog, schema, name) : subselect;
 			if ( tables.containsKey( key ) ) {
 				throw new DuplicateMappingException( "table", name );
 			}
 
 			Table table = new DenormalizedTable( includedTable );
 			table.setAbstract( isAbstract );
 			table.setName( name );
 			table.setSchema( schema );
 			table.setCatalog( catalog );
 			table.setSubselect( subselect );
 
 			tables.put( key, table );
 			return table;
 		}
 
 		public NamedQueryDefinition getQuery(String name) {
 			return namedQueries.get( name );
 		}
 
 		public void addQuery(String name, NamedQueryDefinition query) throws DuplicateMappingException {
 			if ( !defaultNamedQueryNames.contains( name ) ) {
 				applyQuery( name, query );
 			}
 		}
 
 		private void applyQuery(String name, NamedQueryDefinition query) {
 			checkQueryName( name );
 			namedQueries.put( name.intern(), query );
 		}
 
 		private void checkQueryName(String name) throws DuplicateMappingException {
 			if ( namedQueries.containsKey( name ) || namedSqlQueries.containsKey( name ) ) {
 				throw new DuplicateMappingException( "query", name );
 			}
 		}
 
 		public void addDefaultQuery(String name, NamedQueryDefinition query) {
 			applyQuery( name, query );
 			defaultNamedQueryNames.add( name );
 		}
 
 		public NamedSQLQueryDefinition getSQLQuery(String name) {
 			return namedSqlQueries.get( name );
 		}
 
 		public void addSQLQuery(String name, NamedSQLQueryDefinition query) throws DuplicateMappingException {
 			if ( !defaultNamedNativeQueryNames.contains( name ) ) {
 				applySQLQuery( name, query );
 			}
 		}
 
 		private void applySQLQuery(String name, NamedSQLQueryDefinition query) throws DuplicateMappingException {
 			checkQueryName( name );
 			namedSqlQueries.put( name.intern(), query );
 		}
 
 		@Override
 		public void addNamedProcedureCallDefinition(NamedProcedureCallDefinition definition)
 				throws DuplicateMappingException {
 			final String name = definition.getRegisteredName();
 			if ( !defaultNamedProcedure.contains( name ) ) {
 				final NamedProcedureCallDefinition previous = namedProcedureCallMap.put( name, definition );
 				if ( previous != null ) {
 					throw new DuplicateMappingException( "named stored procedure query", name );
 				}
 			}
 		}
 		@Override
 		public void addDefaultNamedProcedureCallDefinition(NamedProcedureCallDefinition definition)
 				throws DuplicateMappingException {
 			addNamedProcedureCallDefinition( definition );
 			defaultNamedProcedure.add( definition.getRegisteredName() );
 		}
 
 		@Override
 		public void addNamedEntityGraphDefintion(NamedEntityGraphDefinition definition)
 				throws DuplicateMappingException {
 			final String name = definition.getRegisteredName();
 
 			final NamedEntityGraphDefinition previous = namedEntityGraphMap.put( name, definition );
 			if ( previous != null ) {
 				throw new DuplicateMappingException( "NamedEntityGraph", name );
 			}
 		}
 
 		public void addDefaultSQLQuery(String name, NamedSQLQueryDefinition query) {
 			applySQLQuery( name, query );
 			defaultNamedNativeQueryNames.add( name );
 		}
 
 		public ResultSetMappingDefinition getResultSetMapping(String name) {
 			return sqlResultSetMappings.get(name);
 		}
 
 		public void addResultSetMapping(ResultSetMappingDefinition sqlResultSetMapping) throws DuplicateMappingException {
 			if ( !defaultSqlResultSetMappingNames.contains( sqlResultSetMapping.getName() ) ) {
 				applyResultSetMapping( sqlResultSetMapping );
 			}
 		}
 
 		public void applyResultSetMapping(ResultSetMappingDefinition sqlResultSetMapping) throws DuplicateMappingException {
 			Object old = sqlResultSetMappings.put( sqlResultSetMapping.getName(), sqlResultSetMapping );
 			if ( old != null ) {
 				throw new DuplicateMappingException( "resultSet",  sqlResultSetMapping.getName() );
 			}
 		}
 
 		public void addDefaultResultSetMapping(ResultSetMappingDefinition definition) {
 			final String name = definition.getName();
 			if ( !defaultSqlResultSetMappingNames.contains( name ) && getResultSetMapping( name ) != null ) {
 				removeResultSetMapping( name );
 			}
 			applyResultSetMapping( definition );
 			defaultSqlResultSetMappingNames.add( name );
 		}
 
 		protected void removeResultSetMapping(String name) {
 			sqlResultSetMappings.remove( name );
 		}
 
 		public TypeDef getTypeDef(String typeName) {
 			return typeDefs.get( typeName );
 		}
 
 		public void addTypeDef(String typeName, String typeClass, Properties paramMap) {
 			TypeDef def = new TypeDef( typeClass, paramMap );
 			typeDefs.put( typeName, def );
 			LOG.debugf( "Added %s with class %s", typeName, typeClass );
 		}
 
 		public Map getFilterDefinitions() {
 			return filterDefinitions;
 		}
 
 		public FilterDefinition getFilterDefinition(String name) {
 			return filterDefinitions.get( name );
 		}
 
 		public void addFilterDefinition(FilterDefinition definition) {
 			filterDefinitions.put( definition.getFilterName(), definition );
 		}
 
 		public FetchProfile findOrCreateFetchProfile(String name, MetadataSource source) {
 			FetchProfile profile = fetchProfiles.get( name );
 			if ( profile == null ) {
 				profile = new FetchProfile( name, source );
 				fetchProfiles.put( name, profile );
 			}
 			return profile;
 		}
 
 		public Iterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjects() {
 			return iterateAuxiliaryDatabaseObjects();
 		}
 
 		public Iterator<AuxiliaryDatabaseObject> iterateAuxiliaryDatabaseObjects() {
 			return auxiliaryDatabaseObjects.iterator();
 		}
 
 		public ListIterator<AuxiliaryDatabaseObject> iterateAuxliaryDatabaseObjectsInReverse() {
 			return iterateAuxiliaryDatabaseObjectsInReverse();
 		}
 
 		public ListIterator<AuxiliaryDatabaseObject> iterateAuxiliaryDatabaseObjectsInReverse() {
 			return auxiliaryDatabaseObjects.listIterator( auxiliaryDatabaseObjects.size() );
 		}
 
 		public void addAuxiliaryDatabaseObject(AuxiliaryDatabaseObject auxiliaryDatabaseObject) {
 			auxiliaryDatabaseObjects.add( auxiliaryDatabaseObject );
 		}
 
 		/**
 		 * Internal struct used to help track physical table names to logical table names.
 		 */
 		private class TableDescription implements Serializable {
 			final String logicalName;
 			final Table denormalizedSupertable;
 
 			TableDescription(String logicalName, Table denormalizedSupertable) {
 				this.logicalName = logicalName;
 				this.denormalizedSupertable = denormalizedSupertable;
 			}
 		}
 
 		public String getLogicalTableName(Table table) throws MappingException {
 			return getLogicalTableName( table.getQuotedSchema(), table.getQuotedCatalog(), table.getQuotedName() );
 		}
 
 		private String getLogicalTableName(String schema, String catalog, String physicalName) throws MappingException {
 			String key = buildTableNameKey( schema, catalog, physicalName );
 			TableDescription descriptor = (TableDescription) tableNameBinding.get( key );
 			if (descriptor == null) {
 				throw new MappingException( "Unable to find physical table: " + physicalName);
 			}
 			return descriptor.logicalName;
 		}
 
 		public void addTableBinding(
 				String schema,
 				String catalog,
 				String logicalName,
 				String physicalName,
 				Table denormalizedSuperTable) throws DuplicateMappingException {
 			String key = buildTableNameKey( schema, catalog, physicalName );
 			TableDescription tableDescription = new TableDescription( logicalName, denormalizedSuperTable );
 			TableDescription oldDescriptor = ( TableDescription ) tableNameBinding.put( key, tableDescription );
 			if ( oldDescriptor != null && ! oldDescriptor.logicalName.equals( logicalName ) ) {
 				//TODO possibly relax that
 				throw new DuplicateMappingException(
 						"Same physical table name [" + physicalName + "] references several logical table names: [" +
 								oldDescriptor.logicalName + "], [" + logicalName + ']',
 						"table",
 						physicalName
 				);
 			}
 		}
 
 		private String buildTableNameKey(String schema, String catalog, String finalName) {
 			StringBuilder keyBuilder = new StringBuilder();
 			if (schema != null) keyBuilder.append( schema );
 			keyBuilder.append( ".");
 			if (catalog != null) keyBuilder.append( catalog );
 			keyBuilder.append( ".");
 			keyBuilder.append( finalName );
 			return keyBuilder.toString();
 		}
 
 		/**
 		 * Internal struct used to maintain xref between physical and logical column
 		 * names for a table.  Mainly this is used to ensure that the defined
 		 * {@link NamingStrategy} is not creating duplicate column names.
 		 */
 		private class TableColumnNameBinding implements Serializable {
 			private final String tableName;
 			private Map/*<String, String>*/ logicalToPhysical = new HashMap();
 			private Map/*<String, String>*/ physicalToLogical = new HashMap();
 
 			private TableColumnNameBinding(String tableName) {
 				this.tableName = tableName;
 			}
 
 			public void addBinding(String logicalName, Column physicalColumn) {
 				bindLogicalToPhysical( logicalName, physicalColumn );
 				bindPhysicalToLogical( logicalName, physicalColumn );
 			}
 
 			private void bindLogicalToPhysical(String logicalName, Column physicalColumn) throws DuplicateMappingException {
 				final String logicalKey = logicalName.toLowerCase();
 				final String physicalName = physicalColumn.getQuotedName();
 				final String existingPhysicalName = ( String ) logicalToPhysical.put( logicalKey, physicalName );
 				if ( existingPhysicalName != null ) {
 					boolean areSamePhysicalColumn = physicalColumn.isQuoted()
 							? existingPhysicalName.equals( physicalName )
 							: existingPhysicalName.equalsIgnoreCase( physicalName );
 					if ( ! areSamePhysicalColumn ) {
 						throw new DuplicateMappingException(
 								" Table [" + tableName + "] contains logical column name [" + logicalName
 										+ "] referenced by multiple physical column names: [" + existingPhysicalName
 										+ "], [" + physicalName + "]",
 								"column-binding",
 								tableName + "." + logicalName
 						);
 					}
 				}
 			}
 
 			private void bindPhysicalToLogical(String logicalName, Column physicalColumn) throws DuplicateMappingException {
 				final String physicalName = physicalColumn.getQuotedName();
 				final String existingLogicalName = ( String ) physicalToLogical.put( physicalName, logicalName );
 				if ( existingLogicalName != null && ! existingLogicalName.equals( logicalName ) ) {
 					throw new DuplicateMappingException(
 							" Table [" + tableName + "] contains phyical column name [" + physicalName
 									+ "] represented by different logical column names: [" + existingLogicalName
 									+ "], [" + logicalName + "]",
 							"column-binding",
 							tableName + "." + physicalName
 					);
 				}
 			}
 		}
 
 		public void addColumnBinding(String logicalName, Column physicalColumn, Table table) throws DuplicateMappingException {
 			TableColumnNameBinding binding = ( TableColumnNameBinding ) columnNameBindingPerTable.get( table );
 			if ( binding == null ) {
 				binding = new TableColumnNameBinding( table.getName() );
 				columnNameBindingPerTable.put( table, binding );
 			}
 			binding.addBinding( logicalName, physicalColumn );
 		}
 
 		public String getPhysicalColumnName(String logicalName, Table table) throws MappingException {
 			logicalName = logicalName.toLowerCase();
 			String finalName = null;
 			Table currentTable = table;
 			do {
 				TableColumnNameBinding binding = ( TableColumnNameBinding ) columnNameBindingPerTable.get( currentTable );
 				if ( binding != null ) {
 					finalName = ( String ) binding.logicalToPhysical.get( logicalName );
 				}
 				String key = buildTableNameKey(
 						currentTable.getQuotedSchema(), currentTable.getQuotedCatalog(), currentTable.getQuotedName()
 				);
 				TableDescription description = ( TableDescription ) tableNameBinding.get( key );
 				if ( description != null ) {
 					currentTable = description.denormalizedSupertable;
 				}
 				else {
 					currentTable = null;
 				}
 			} while ( finalName == null && currentTable != null );
 
 			if ( finalName == null ) {
 				throw new MappingException(
 						"Unable to find column with logical name " + logicalName + " in table " + table.getName()
 				);
 			}
 			return finalName;
 		}
-
+		@Override
 		public String getLogicalColumnName(String physicalName, Table table) throws MappingException {
 			String logical = null;
 			Table currentTable = table;
 			TableDescription description = null;
 			do {
 				TableColumnNameBinding binding = ( TableColumnNameBinding ) columnNameBindingPerTable.get( currentTable );
 				if ( binding != null ) {
 					logical = ( String ) binding.physicalToLogical.get( physicalName );
 				}
 				String key = buildTableNameKey(
 						currentTable.getQuotedSchema(), currentTable.getQuotedCatalog(), currentTable.getQuotedName()
 				);
 				description = ( TableDescription ) tableNameBinding.get( key );
 				if ( description != null ) {
 					currentTable = description.denormalizedSupertable;
 				}
 				else {
 					currentTable = null;
 				}
 			}
-			while ( logical == null && currentTable != null && description != null );
+			while ( logical == null && currentTable != null );
 			if ( logical == null ) {
 				throw new MappingException(
 						"Unable to find logical column name from physical name "
 								+ physicalName + " in table " + table.getName()
 				);
 			}
 			return logical;
 		}
 
 		public void addSecondPass(SecondPass sp) {
 			addSecondPass( sp, false );
 		}
 
 		public void addSecondPass(SecondPass sp, boolean onTopOfTheQueue) {
 			if ( onTopOfTheQueue ) {
 				secondPasses.add( 0, sp );
 			}
 			else {
 				secondPasses.add( sp );
 			}
 		}
 
 		@Override
 		public AttributeConverterDefinition locateAttributeConverter(Class converterClass) {
 			if ( attributeConverterDefinitionsByClass == null ) {
 				return null;
 			}
 			return attributeConverterDefinitionsByClass.get( converterClass );
 		}
 
 		@Override
 		public java.util.Collection<AttributeConverterDefinition> getAttributeConverters() {
 			if ( attributeConverterDefinitionsByClass == null ) {
 				return Collections.emptyList();
 			}
 			return attributeConverterDefinitionsByClass.values();
 		}
 
 		public void addPropertyReference(String referencedClass, String propertyName) {
 			propertyReferences.add( new PropertyReference( referencedClass, propertyName, false ) );
 		}
 
 		public void addUniquePropertyReference(String referencedClass, String propertyName) {
 			propertyReferences.add( new PropertyReference( referencedClass, propertyName, true ) );
 		}
 
 		public void addToExtendsQueue(ExtendsQueueEntry entry) {
 			extendsQueue.put( entry, null );
 		}
 
 		public MutableIdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 			return identifierGeneratorFactory;
 		}
 
 		public void addMappedSuperclass(Class type, MappedSuperclass mappedSuperclass) {
 			mappedSuperClasses.put( type, mappedSuperclass );
 		}
 
 		public MappedSuperclass getMappedSuperclass(Class type) {
 			return mappedSuperClasses.get( type );
 		}
 
 		public ObjectNameNormalizer getObjectNameNormalizer() {
 			return normalizer;
 		}
 
 		public Properties getConfigurationProperties() {
 			return properties;
 		}
 
 		public void addDefaultGenerator(IdGenerator generator) {
 			this.addGenerator( generator );
 			defaultNamedGenerators.add( generator.getName() );
 		}
 
 		public boolean isInSecondPass() {
 			return inSecondPass;
 		}
 
 		public PropertyData getPropertyAnnotatedWithMapsId(XClass entityType, String propertyName) {
 			final Map<String, PropertyData> map = propertiesAnnotatedWithMapsId.get( entityType );
 			return map == null ? null : map.get( propertyName );
 		}
 
 		public void addPropertyAnnotatedWithMapsId(XClass entityType, PropertyData property) {
 			Map<String, PropertyData> map = propertiesAnnotatedWithMapsId.get( entityType );
 			if ( map == null ) {
 				map = new HashMap<String, PropertyData>();
 				propertiesAnnotatedWithMapsId.put( entityType, map );
 			}
 			map.put( property.getProperty().getAnnotation( MapsId.class ).value(), property );
 		}
 
 		public boolean isSpecjProprietarySyntaxEnabled() {
 			return specjProprietarySyntaxEnabled;
 		}
 
 		public void addPropertyAnnotatedWithMapsIdSpecj(XClass entityType, PropertyData property, String mapsIdValue) {
 			Map<String, PropertyData> map = propertiesAnnotatedWithMapsId.get( entityType );
 			if ( map == null ) {
 				map = new HashMap<String, PropertyData>();
 				propertiesAnnotatedWithMapsId.put( entityType, map );
 			}
 			map.put( mapsIdValue, property );
 		}
 
 		public PropertyData getPropertyAnnotatedWithIdAndToOne(XClass entityType, String propertyName) {
 			final Map<String, PropertyData> map = propertiesAnnotatedWithIdAndToOne.get( entityType );
 			return map == null ? null : map.get( propertyName );
 		}
 
 		public void addToOneAndIdProperty(XClass entityType, PropertyData property) {
 			Map<String, PropertyData> map = propertiesAnnotatedWithIdAndToOne.get( entityType );
 			if ( map == null ) {
 				map = new HashMap<String, PropertyData>();
 				propertiesAnnotatedWithIdAndToOne.put( entityType, map );
 			}
 			map.put( property.getPropertyName(), property );
 		}
 
 		private Boolean useNewGeneratorMappings;
-
-		@SuppressWarnings({ "UnnecessaryUnboxing" })
+		@Override
 		public boolean useNewGeneratorMappings() {
 			if ( useNewGeneratorMappings == null ) {
 				final String booleanName = getConfigurationProperties()
 						.getProperty( AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS );
 				useNewGeneratorMappings = Boolean.valueOf( booleanName );
 			}
-			return useNewGeneratorMappings.booleanValue();
+			return useNewGeneratorMappings;
 		}
 
 		private Boolean useNationalizedCharacterData;
 
 		@Override
-		@SuppressWarnings( {"UnnecessaryUnboxing"})
 		public boolean useNationalizedCharacterData() {
 			if ( useNationalizedCharacterData == null ) {
 				final String booleanName = getConfigurationProperties()
 						.getProperty( AvailableSettings.USE_NATIONALIZED_CHARACTER_DATA );
 				useNationalizedCharacterData = Boolean.valueOf( booleanName );
 			}
-			return useNationalizedCharacterData.booleanValue();
+			return useNationalizedCharacterData;
 		}
 
 		private Boolean forceDiscriminatorInSelectsByDefault;
 
 		@Override
-		@SuppressWarnings( {"UnnecessaryUnboxing"})
 		public boolean forceDiscriminatorInSelectsByDefault() {
 			if ( forceDiscriminatorInSelectsByDefault == null ) {
 				final String booleanName = getConfigurationProperties()
 						.getProperty( AvailableSettings.FORCE_DISCRIMINATOR_IN_SELECTS_BY_DEFAULT );
 				forceDiscriminatorInSelectsByDefault = Boolean.valueOf( booleanName );
 			}
-			return forceDiscriminatorInSelectsByDefault.booleanValue();
+			return forceDiscriminatorInSelectsByDefault;
 		}
 
 		public IdGenerator getGenerator(String name) {
 			return getGenerator( name, null );
 		}
 
 		public IdGenerator getGenerator(String name, Map<String, IdGenerator> localGenerators) {
 			if ( localGenerators != null ) {
 				IdGenerator result = localGenerators.get( name );
 				if ( result != null ) {
 					return result;
 				}
 			}
 			return namedGenerators.get( name );
 		}
 
 		public void addGenerator(IdGenerator generator) {
 			if ( !defaultNamedGenerators.contains( generator.getName() ) ) {
 				IdGenerator old = namedGenerators.put( generator.getName(), generator );
 				if ( old != null ) {
 					LOG.duplicateGeneratorName( old.getName() );
 				}
 			}
 		}
 
 		public void addGeneratorTable(String name, Properties params) {
 			Object old = generatorTables.put( name, params );
 			if ( old != null ) {
 				LOG.duplicateGeneratorTable( name );
 			}
 		}
 
 		public Properties getGeneratorTableProperties(String name, Map<String, Properties> localGeneratorTables) {
 			if ( localGeneratorTables != null ) {
 				Properties result = localGeneratorTables.get( name );
 				if ( result != null ) {
 					return result;
 				}
 			}
 			return generatorTables.get( name );
 		}
 
 		public Map<String, Join> getJoins(String entityName) {
 			return joins.get( entityName );
 		}
 
 		public void addJoins(PersistentClass persistentClass, Map<String, Join> joins) {
 			Object old = Configuration.this.joins.put( persistentClass.getEntityName(), joins );
 			if ( old != null ) {
 				LOG.duplicateJoins( persistentClass.getEntityName() );
 			}
 		}
 
 		public AnnotatedClassType getClassType(XClass clazz) {
 			AnnotatedClassType type = classTypes.get( clazz.getName() );
 			if ( type == null ) {
 				return addClassType( clazz );
 			}
 			else {
 				return type;
 			}
 		}
 
 		//FIXME should be private but is part of the ExtendedMapping contract
 
 		public AnnotatedClassType addClassType(XClass clazz) {
 			AnnotatedClassType type;
 			if ( clazz.isAnnotationPresent( Entity.class ) ) {
 				type = AnnotatedClassType.ENTITY;
 			}
 			else if ( clazz.isAnnotationPresent( Embeddable.class ) ) {
 				type = AnnotatedClassType.EMBEDDABLE;
 			}
 			else if ( clazz.isAnnotationPresent( javax.persistence.MappedSuperclass.class ) ) {
 				type = AnnotatedClassType.EMBEDDABLE_SUPERCLASS;
 			}
 			else {
 				type = AnnotatedClassType.NONE;
 			}
 			classTypes.put( clazz.getName(), type );
 			return type;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public Map<Table, List<String[]>> getTableUniqueConstraints() {
 			final Map<Table, List<String[]>> deprecatedStructure = new HashMap<Table, List<String[]>>(
 					CollectionHelper.determineProperSizing( getUniqueConstraintHoldersByTable() ),
 					CollectionHelper.LOAD_FACTOR
 			);
 			for ( Map.Entry<Table, List<UniqueConstraintHolder>> entry : getUniqueConstraintHoldersByTable().entrySet() ) {
 				List<String[]> columnsPerConstraint = new ArrayList<String[]>(
 						CollectionHelper.determineProperSizing( entry.getValue().size() )
 				);
 				deprecatedStructure.put( entry.getKey(), columnsPerConstraint );
 				for ( UniqueConstraintHolder holder : entry.getValue() ) {
 					columnsPerConstraint.add( holder.getColumns() );
 				}
 			}
 			return deprecatedStructure;
 		}
 
 		public Map<Table, List<UniqueConstraintHolder>> getUniqueConstraintHoldersByTable() {
 			return uniqueConstraintHoldersByTable;
 		}
 
 		@SuppressWarnings({ "unchecked" })
 		public void addUniqueConstraints(Table table, List uniqueConstraints) {
 			List<UniqueConstraintHolder> constraintHolders = new ArrayList<UniqueConstraintHolder>(
 					CollectionHelper.determineProperSizing( uniqueConstraints.size() )
 			);
 
 			int keyNameBase = determineCurrentNumberOfUniqueConstraintHolders( table );
 			for ( String[] columns : ( List<String[]> ) uniqueConstraints ) {
 				final String keyName = "key" + keyNameBase++;
 				constraintHolders.add(
 						new UniqueConstraintHolder().setName( keyName ).setColumns( columns )
 				);
 			}
 			addUniqueConstraintHolders( table, constraintHolders );
 		}
 
 		private int determineCurrentNumberOfUniqueConstraintHolders(Table table) {
 			List currentHolders = getUniqueConstraintHoldersByTable().get( table );
 			return currentHolders == null
 					? 0
 					: currentHolders.size();
 		}
 
 		public void addUniqueConstraintHolders(Table table, List<UniqueConstraintHolder> uniqueConstraintHolders) {
 			List<UniqueConstraintHolder> holderList = getUniqueConstraintHoldersByTable().get( table );
 			if ( holderList == null ) {
 				holderList = new ArrayList<UniqueConstraintHolder>();
 				getUniqueConstraintHoldersByTable().put( table, holderList );
 			}
 			holderList.addAll( uniqueConstraintHolders );
 		}
 
 		public void addJpaIndexHolders(Table table, List<JPAIndexHolder> holders) {
 			List<JPAIndexHolder> holderList = jpaIndexHoldersByTable.get( table );
 			if ( holderList == null ) {
 				holderList = new ArrayList<JPAIndexHolder>();
 				jpaIndexHoldersByTable.put( table, holderList );
 			}
 			holderList.addAll( holders );
 		}
 
 		public void addMappedBy(String entityName, String propertyName, String inversePropertyName) {
 			mappedByResolver.put( entityName + "." + propertyName, inversePropertyName );
 		}
 
 		public String getFromMappedBy(String entityName, String propertyName) {
 			return mappedByResolver.get( entityName + "." + propertyName );
 		}
 
 		public void addPropertyReferencedAssociation(String entityName, String propertyName, String propertyRef) {
 			propertyRefResolver.put( entityName + "." + propertyName, propertyRef );
 		}
 
 		public String getPropertyReferencedAssociation(String entityName, String propertyName) {
 			return propertyRefResolver.get( entityName + "." + propertyName );
 		}
 
 		public ReflectionManager getReflectionManager() {
 			return reflectionManager;
 		}
 
 		public Map getClasses() {
 			return classes;
 		}
 
 		public void addAnyMetaDef(AnyMetaDef defAnn) throws AnnotationException {
 			if ( anyMetaDefs.containsKey( defAnn.name() ) ) {
 				throw new AnnotationException( "Two @AnyMetaDef with the same name defined: " + defAnn.name() );
 			}
 			anyMetaDefs.put( defAnn.name(), defAnn );
 		}
 
 		public AnyMetaDef getAnyMetaDef(String name) {
 			return anyMetaDefs.get( name );
 		}
 	}
 
 	final ObjectNameNormalizer normalizer = new ObjectNameNormalizerImpl();
 
 	final class ObjectNameNormalizerImpl extends ObjectNameNormalizer implements Serializable {
 		public boolean isUseQuotedIdentifiersGlobally() {
 			//Do not cache this value as we lazily set it in Hibernate Annotation (AnnotationConfiguration)
 			//TODO use a dedicated protected useQuotedIdentifier flag in Configuration (overriden by AnnotationConfiguration)
 			String setting = (String) properties.get( Environment.GLOBALLY_QUOTED_IDENTIFIERS );
-			return setting != null && Boolean.valueOf( setting ).booleanValue();
+			return setting != null && Boolean.valueOf( setting );
 		}
 
 		public NamingStrategy getNamingStrategy() {
 			return namingStrategy;
 		}
 	}
 
 	protected class MetadataSourceQueue implements Serializable {
 		private LinkedHashMap<XmlDocument, Set<String>> hbmMetadataToEntityNamesMap
 				= new LinkedHashMap<XmlDocument, Set<String>>();
 		private Map<String, XmlDocument> hbmMetadataByEntityNameXRef = new HashMap<String, XmlDocument>();
 
 		//XClass are not serializable by default
 		private transient List<XClass> annotatedClasses = new ArrayList<XClass>();
 		//only used during the secondPhaseCompile pass, hence does not need to be serialized
 		private transient Map<String, XClass> annotatedClassesByEntityNameMap = new HashMap<String, XClass>();
 
 		private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
 			ois.defaultReadObject();
 			annotatedClassesByEntityNameMap = new HashMap<String, XClass>();
 
 			//build back annotatedClasses
 			@SuppressWarnings( "unchecked" )
 			List<Class> serializableAnnotatedClasses = (List<Class>) ois.readObject();
 			annotatedClasses = new ArrayList<XClass>( serializableAnnotatedClasses.size() );
 			for ( Class clazz : serializableAnnotatedClasses ) {
 				annotatedClasses.add( reflectionManager.toXClass( clazz ) );
 			}
 		}
 
 		private void writeObject(java.io.ObjectOutputStream out) throws IOException {
 			out.defaultWriteObject();
 			List<Class> serializableAnnotatedClasses = new ArrayList<Class>( annotatedClasses.size() );
 			for ( XClass xClass : annotatedClasses ) {
 				serializableAnnotatedClasses.add( reflectionManager.toClass( xClass ) );
 			}
 			out.writeObject( serializableAnnotatedClasses );
 		}
 
 		public void add(XmlDocument metadataXml) {
 			final Document document = metadataXml.getDocumentTree();
 			final Element hmNode = document.getRootElement();
 			Attribute packNode = hmNode.attribute( "package" );
 			String defaultPackage = packNode != null ? packNode.getValue() : "";
 			Set<String> entityNames = new HashSet<String>();
 			findClassNames( defaultPackage, hmNode, entityNames );
 			for ( String entity : entityNames ) {
 				hbmMetadataByEntityNameXRef.put( entity, metadataXml );
 			}
 			this.hbmMetadataToEntityNamesMap.put( metadataXml, entityNames );
 		}
 
 		private void findClassNames(String defaultPackage, Element startNode, Set<String> names) {
 			// if we have some extends we need to check if those classes possibly could be inside the
 			// same hbm.xml file...
 			Iterator[] classes = new Iterator[4];
 			classes[0] = startNode.elementIterator( "class" );
 			classes[1] = startNode.elementIterator( "subclass" );
 			classes[2] = startNode.elementIterator( "joined-subclass" );
 			classes[3] = startNode.elementIterator( "union-subclass" );
 
 			Iterator classIterator = new JoinedIterator( classes );
 			while ( classIterator.hasNext() ) {
 				Element element = ( Element ) classIterator.next();
 				String entityName = element.attributeValue( "entity-name" );
 				if ( entityName == null ) {
 					entityName = getClassName( element.attribute( "name" ), defaultPackage );
 				}
 				names.add( entityName );
 				findClassNames( defaultPackage, element, names );
 			}
 		}
 
 		private String getClassName(Attribute name, String defaultPackage) {
 			if ( name == null ) {
 				return null;
 			}
 			String unqualifiedName = name.getValue();
 			if ( unqualifiedName == null ) {
 				return null;
 			}
 			if ( unqualifiedName.indexOf( '.' ) < 0 && defaultPackage != null ) {
 				return defaultPackage + '.' + unqualifiedName;
 			}
 			return unqualifiedName;
 		}
 
 		public void add(XClass annotatedClass) {
 			annotatedClasses.add( annotatedClass );
 		}
 
 		protected void syncAnnotatedClasses() {
 			final Iterator<XClass> itr = annotatedClasses.iterator();
 			while ( itr.hasNext() ) {
 				final XClass annotatedClass = itr.next();
 				if ( annotatedClass.isAnnotationPresent( Entity.class ) ) {
 					annotatedClassesByEntityNameMap.put( annotatedClass.getName(), annotatedClass );
 					continue;
 				}
 
 				if ( !annotatedClass.isAnnotationPresent( javax.persistence.MappedSuperclass.class ) ) {
 					itr.remove();
 				}
 			}
 		}
 
 		protected void processMetadata(List<MetadataSourceType> order) {
 			syncAnnotatedClasses();
 
 			for ( MetadataSourceType type : order ) {
 				if ( MetadataSourceType.HBM.equals( type ) ) {
 					processHbmXmlQueue();
 				}
 				else if ( MetadataSourceType.CLASS.equals( type ) ) {
 					processAnnotatedClassesQueue();
 				}
 			}
 		}
 
 		private void processHbmXmlQueue() {
 			LOG.debug( "Processing hbm.xml files" );
 			for ( Map.Entry<XmlDocument, Set<String>> entry : hbmMetadataToEntityNamesMap.entrySet() ) {
 				// Unfortunately we have to create a Mappings instance for each iteration here
 				processHbmXml( entry.getKey(), entry.getValue() );
 			}
 			hbmMetadataToEntityNamesMap.clear();
 			hbmMetadataByEntityNameXRef.clear();
 		}
 
 		private void processHbmXml(XmlDocument metadataXml, Set<String> entityNames) {
 			try {
 				HbmBinder.bindRoot( metadataXml, createMappings(), Collections.EMPTY_MAP, entityNames );
 			}
 			catch ( MappingException me ) {
 				throw new InvalidMappingException(
 						metadataXml.getOrigin().getType(),
 						metadataXml.getOrigin().getName(),
 						me
 				);
 			}
 
 			for ( String entityName : entityNames ) {
 				if ( annotatedClassesByEntityNameMap.containsKey( entityName ) ) {
 					annotatedClasses.remove( annotatedClassesByEntityNameMap.get( entityName ) );
 					annotatedClassesByEntityNameMap.remove( entityName );
 				}
 			}
 		}
 
 		private void processAnnotatedClassesQueue() {
 			LOG.debug( "Process annotated classes" );
 			//bind classes in the correct order calculating some inheritance state
 			List<XClass> orderedClasses = orderAndFillHierarchy( annotatedClasses );
 			Mappings mappings = createMappings();
 			Map<XClass, InheritanceState> inheritanceStatePerClass = AnnotationBinder.buildInheritanceStates(
 					orderedClasses, mappings
 			);
 
 
 			for ( XClass clazz : orderedClasses ) {
 				AnnotationBinder.bindClass( clazz, inheritanceStatePerClass, mappings );
 
 				final String entityName = clazz.getName();
 				if ( hbmMetadataByEntityNameXRef.containsKey( entityName ) ) {
 					hbmMetadataToEntityNamesMap.remove( hbmMetadataByEntityNameXRef.get( entityName ) );
 					hbmMetadataByEntityNameXRef.remove( entityName );
 				}
 			}
 			annotatedClasses.clear();
 			annotatedClassesByEntityNameMap.clear();
 		}
 
 		private List<XClass> orderAndFillHierarchy(List<XClass> original) {
 			List<XClass> copy = new ArrayList<XClass>( original );
 			insertMappedSuperclasses( original, copy );
 
 			// order the hierarchy
 			List<XClass> workingCopy = new ArrayList<XClass>( copy );
 			List<XClass> newList = new ArrayList<XClass>( copy.size() );
 			while ( workingCopy.size() > 0 ) {
 				XClass clazz = workingCopy.get( 0 );
 				orderHierarchy( workingCopy, newList, copy, clazz );
 			}
 			return newList;
 		}
 
 		private void insertMappedSuperclasses(List<XClass> original, List<XClass> copy) {
 			for ( XClass clazz : original ) {
 				XClass superClass = clazz.getSuperclass();
 				while ( superClass != null
 						&& !reflectionManager.equals( superClass, Object.class )
 						&& !copy.contains( superClass ) ) {
 					if ( superClass.isAnnotationPresent( Entity.class )
 							|| superClass.isAnnotationPresent( javax.persistence.MappedSuperclass.class ) ) {
 						copy.add( superClass );
 					}
 					superClass = superClass.getSuperclass();
 				}
 			}
 		}
 
 		private void orderHierarchy(List<XClass> copy, List<XClass> newList, List<XClass> original, XClass clazz) {
 			if ( clazz == null || reflectionManager.equals( clazz, Object.class ) ) {
 				return;
 			}
 			//process superclass first
 			orderHierarchy( copy, newList, original, clazz.getSuperclass() );
 			if ( original.contains( clazz ) ) {
 				if ( !newList.contains( clazz ) ) {
 					newList.add( clazz );
 				}
 				copy.remove( clazz );
 			}
 		}
 
 		public boolean isEmpty() {
 			return hbmMetadataToEntityNamesMap.isEmpty() && annotatedClasses.isEmpty();
 		}
 
 	}
 
 
 	public static final MetadataSourceType[] DEFAULT_ARTEFACT_PROCESSING_ORDER = new MetadataSourceType[] {
 			MetadataSourceType.HBM,
 			MetadataSourceType.CLASS
 	};
 
 	private List<MetadataSourceType> metadataSourcePrecedence;
 
 	private List<MetadataSourceType> determineMetadataSourcePrecedence() {
 		if ( metadataSourcePrecedence.isEmpty()
 				&& StringHelper.isNotEmpty( getProperties().getProperty( ARTEFACT_PROCESSING_ORDER ) ) ) {
 			metadataSourcePrecedence = parsePrecedence( getProperties().getProperty( ARTEFACT_PROCESSING_ORDER ) );
 		}
 		if ( metadataSourcePrecedence.isEmpty() ) {
 			metadataSourcePrecedence = Arrays.asList( DEFAULT_ARTEFACT_PROCESSING_ORDER );
 		}
 		metadataSourcePrecedence = Collections.unmodifiableList( metadataSourcePrecedence );
 
 		return metadataSourcePrecedence;
 	}
 
 	public void setPrecedence(String precedence) {
 		this.metadataSourcePrecedence = parsePrecedence( precedence );
 	}
 
 	private List<MetadataSourceType> parsePrecedence(String s) {
 		if ( StringHelper.isEmpty( s ) ) {
 			return Collections.emptyList();
 		}
 		StringTokenizer precedences = new StringTokenizer( s, ",; ", false );
 		List<MetadataSourceType> tmpPrecedences = new ArrayList<MetadataSourceType>();
 		while ( precedences.hasMoreElements() ) {
 			tmpPrecedences.add( MetadataSourceType.parsePrecedence( ( String ) precedences.nextElement() ) );
 		}
 		return tmpPrecedences;
 	}
 
 	private static class CacheHolder {
 		public CacheHolder(String role, String usage, String region, boolean isClass, boolean cacheLazy) {
 			this.role = role;
 			this.usage = usage;
 			this.region = region;
 			this.isClass = isClass;
 			this.cacheLazy = cacheLazy;
 		}
 
 		public String role;
 		public String usage;
 		public String region;
 		public boolean isClass;
 		public boolean cacheLazy;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/DefaultNamingStrategy.java b/hibernate-core/src/main/java/org/hibernate/cfg/DefaultNamingStrategy.java
index bea5024f9e..a3922b0c56 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/DefaultNamingStrategy.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/DefaultNamingStrategy.java
@@ -1,132 +1,132 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 import java.io.Serializable;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.internal.util.StringHelper;
 
 /**
  * The default <tt>NamingStrategy</tt>
  * @see ImprovedNamingStrategy a better alternative
  * @author Gavin King
  */
 public class DefaultNamingStrategy implements NamingStrategy, Serializable {
 
 	/**
 	 * The singleton instance
 	 */
 	public static final NamingStrategy INSTANCE = new DefaultNamingStrategy();
 
 	/**
 	 * Return the unqualified class name
 	 */
 	public String classToTableName(String className) {
 		return StringHelper.unqualify(className);
 	}
 	/**
 	 * Return the unqualified property name
 	 */
 	public String propertyToColumnName(String propertyName) {
 		return StringHelper.unqualify(propertyName);
 	}
 	/**
 	 * Return the argument
 	 */
 	public String tableName(String tableName) {
 		return tableName;
 	}
 	/**
 	 * Return the argument
 	 */
 	public String columnName(String columnName) {
 		return columnName;
 	}
 
 	/**
 	 * Return the unqualified property name, not the best strategy but a backward compatible one
 	 */
 	public String collectionTableName(
 			String ownerEntity, String ownerEntityTable, String associatedEntity, String associatedEntityTable,
 			String propertyName
 	) {
 		//use a degenerated strategy for backward compatibility
 		return StringHelper.unqualify(propertyName);
 	}
 
 	/**
 	 * Return the argument
 	 */
 	public String joinKeyColumnName(String joinedColumn, String joinedTable) {
 		return columnName( joinedColumn );
 	}
 
 	/**
 	 * Return the property name or propertyTableName
 	 */
 	public String foreignKeyColumnName(
 			String propertyName, String propertyEntityName, String propertyTableName, String referencedColumnName
 	) {
 		String header = propertyName != null ? StringHelper.unqualify( propertyName ) : propertyTableName;
 		if (header == null) throw new AssertionFailure("NammingStrategy not properly filled");
 		return columnName( header ); //+ "_" + referencedColumnName not used for backward compatibility
 	}
 
 	/**
 	 * Return the column name or the unqualified property name
 	 */
 	public String logicalColumnName(String columnName, String propertyName) {
 		return StringHelper.isNotEmpty( columnName ) ? columnName : StringHelper.unqualify( propertyName );
 	}
 
 	/**
 	 * Returns either the table name if explicit or
 	 * if there is an associated table, the concatenation of owner entity table and associated table
 	 * otherwise the concatenation of owner entity table and the unqualified property name
 	 */
 	public String logicalCollectionTableName(String tableName,
 											 String ownerEntityTable, String associatedEntityTable, String propertyName
 	) {
 		if ( tableName != null ) {
 			return tableName;
 		}
 		else {
 			//use of a stringbuffer to workaround a JDK bug
 			return new StringBuffer(ownerEntityTable).append("_")
 					.append(
 						associatedEntityTable != null ?
 						associatedEntityTable :
 						StringHelper.unqualify( propertyName )
 					).toString();
 		}
 	}
 	/**
 	 * Return the column name if explicit or the concatenation of the property name and the referenced column
 	 *
 	 */
 	public String logicalCollectionColumnName(String columnName, String propertyName, String referencedColumn) {
 		return StringHelper.isNotEmpty( columnName ) ? columnName : propertyName + "_" + referencedColumn;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/ExtendedMappings.java b/hibernate-core/src/main/java/org/hibernate/cfg/ExtendedMappings.java
index e052340569..3cab0107e8 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/ExtendedMappings.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/ExtendedMappings.java
@@ -1,39 +1,39 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 
 /**
  * Allow annotation related mappings
  * <p/>
  * at least for named generators
  *
  * @author Emmanuel Bernard
  * @author Hardy Ferentschik
  *
  * @deprecated All functionality has been moved up to {@link Mappings}
  */
 @Deprecated
 public interface ExtendedMappings extends Mappings {
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java b/hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java
index 358a72893c..5c6ddefbca 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/annotations/CollectionBinder.java
@@ -531,1001 +531,1001 @@ public abstract class CollectionBinder {
 		if ( cascadeStrategy != null && cascadeStrategy.indexOf( "delete-orphan" ) >= 0 ) {
 			collection.setOrphanDelete( true );
 		}
 		binder.setAccessType( accessType );
 		binder.setProperty( property );
 		binder.setInsertable( insertable );
 		binder.setUpdatable( updatable );
 		Property prop = binder.makeProperty();
 		//we don't care about the join stuffs because the column is on the association table.
 		if (! declaringClassSet) throw new AssertionFailure( "DeclaringClass is not set in CollectionBinder while binding" );
 		propertyHolder.addProperty( prop, declaringClass );
 	}
 
 	private void applySortingAndOrdering(Collection collection) {
 		boolean isSorted = isSortedCollection;
 
 		boolean hadOrderBy = false;
 		boolean hadExplicitSort = false;
 
 		Class<? extends Comparator> comparatorClass = null;
 
 		if ( jpaOrderBy == null && sqlOrderBy == null ) {
 			if ( deprecatedSort != null ) {
 				LOG.debug( "Encountered deprecated @Sort annotation; use @SortNatural or @SortComparator instead." );
 				if ( naturalSort != null || comparatorSort != null ) {
 					throw buildIllegalSortCombination();
 				}
 				hadExplicitSort = deprecatedSort.type() != SortType.UNSORTED;
 				if ( deprecatedSort.type() == SortType.NATURAL ) {
 					isSorted = true;
 				}
 				else if ( deprecatedSort.type() == SortType.COMPARATOR ) {
 					isSorted = true;
 					comparatorClass = deprecatedSort.comparator();
 				}
 			}
 			else if ( naturalSort != null ) {
 				if ( comparatorSort != null ) {
 					throw buildIllegalSortCombination();
 				}
 				hadExplicitSort = true;
 			}
 			else if ( comparatorSort != null ) {
 				hadExplicitSort = true;
 				comparatorClass = comparatorSort.value();
 			}
 		}
 		else {
 			if ( jpaOrderBy != null && sqlOrderBy != null ) {
 				throw new AnnotationException(
 						String.format(
 								"Illegal combination of @%s and @%s on %s",
 								javax.persistence.OrderBy.class.getName(),
 								OrderBy.class.getName(),
 								safeCollectionRole()
 						)
 				);
 			}
 
 			hadOrderBy = true;
 			hadExplicitSort = false;
 
 			// we can only apply the sql-based order by up front.  The jpa order by has to wait for second pass
 			if ( sqlOrderBy != null ) {
 				collection.setOrderBy( sqlOrderBy.clause() );
 			}
 		}
 
 		if ( isSortedCollection ) {
 			if ( ! hadExplicitSort && !hadOrderBy ) {
 				throw new AnnotationException(
 						"A sorted collection must define and ordering or sorting : " + safeCollectionRole()
 				);
 			}
 		}
 
 		collection.setSorted( isSortedCollection || hadExplicitSort );
 
 		if ( comparatorClass != null ) {
 			try {
 				collection.setComparator( comparatorClass.newInstance() );
 			}
 			catch (Exception e) {
 				throw new AnnotationException(
 						String.format(
 								"Could not instantiate comparator class [%s] for %s",
 								comparatorClass.getName(),
 								safeCollectionRole()
 						)
 				);
 			}
 		}
 	}
 
 	private AnnotationException buildIllegalSortCombination() {
 		return new AnnotationException(
 				String.format(
 						"Illegal combination of annotations on %s.  Only one of @%s, @%s and @%s can be used",
 						safeCollectionRole(),
 						Sort.class.getName(),
 						SortNatural.class.getName(),
 						SortComparator.class.getName()
 				)
 		);
 	}
 
 	private void defineFetchingStrategy() {
 		LazyCollection lazy = property.getAnnotation( LazyCollection.class );
 		Fetch fetch = property.getAnnotation( Fetch.class );
 		OneToMany oneToMany = property.getAnnotation( OneToMany.class );
 		ManyToMany manyToMany = property.getAnnotation( ManyToMany.class );
 		ElementCollection elementCollection = property.getAnnotation( ElementCollection.class ); //jpa 2
 		ManyToAny manyToAny = property.getAnnotation( ManyToAny.class );
 		FetchType fetchType;
 		if ( oneToMany != null ) {
 			fetchType = oneToMany.fetch();
 		}
 		else if ( manyToMany != null ) {
 			fetchType = manyToMany.fetch();
 		}
 		else if ( elementCollection != null ) {
 			fetchType = elementCollection.fetch();
 		}
 		else if ( manyToAny != null ) {
 			fetchType = FetchType.LAZY;
 		}
 		else {
 			throw new AssertionFailure(
 					"Define fetch strategy on a property not annotated with @ManyToOne nor @OneToMany nor @CollectionOfElements"
 			);
 		}
 		if ( lazy != null ) {
 			collection.setLazy( !( lazy.value() == LazyCollectionOption.FALSE ) );
 			collection.setExtraLazy( lazy.value() == LazyCollectionOption.EXTRA );
 		}
 		else {
 			collection.setLazy( fetchType == FetchType.LAZY );
 			collection.setExtraLazy( false );
 		}
 		if ( fetch != null ) {
 			if ( fetch.value() == org.hibernate.annotations.FetchMode.JOIN ) {
 				collection.setFetchMode( FetchMode.JOIN );
 				collection.setLazy( false );
 			}
 			else if ( fetch.value() == org.hibernate.annotations.FetchMode.SELECT ) {
 				collection.setFetchMode( FetchMode.SELECT );
 			}
 			else if ( fetch.value() == org.hibernate.annotations.FetchMode.SUBSELECT ) {
 				collection.setFetchMode( FetchMode.SELECT );
 				collection.setSubselectLoadable( true );
 				collection.getOwner().setSubselectLoadableCollections( true );
 			}
 			else {
 				throw new AssertionFailure( "Unknown FetchMode: " + fetch.value() );
 			}
 		}
 		else {
 			collection.setFetchMode( AnnotationBinder.getFetchMode( fetchType ) );
 		}
 	}
 
 	private XClass getCollectionType() {
 		if ( AnnotationBinder.isDefault( targetEntity, mappings ) ) {
 			if ( collectionType != null ) {
 				return collectionType;
 			}
 			else {
 				String errorMsg = "Collection has neither generic type or OneToMany.targetEntity() defined: "
 						+ safeCollectionRole();
 				throw new AnnotationException( errorMsg );
 			}
 		}
 		else {
 			return targetEntity;
 		}
 	}
 
 	public SecondPass getSecondPass(
 			final Ejb3JoinColumn[] fkJoinColumns,
 			final Ejb3JoinColumn[] keyColumns,
 			final Ejb3JoinColumn[] inverseColumns,
 			final Ejb3Column[] elementColumns,
 			final Ejb3Column[] mapKeyColumns,
 			final Ejb3JoinColumn[] mapKeyManyToManyColumns,
 			final boolean isEmbedded,
 			final XProperty property,
 			final XClass collType,
 			final boolean ignoreNotFound,
 			final boolean unique,
 			final TableBinder assocTableBinder,
 			final Mappings mappings) {
 		return new CollectionSecondPass( mappings, collection ) {
 			@Override
             public void secondPass(java.util.Map persistentClasses, java.util.Map inheritedMetas) throws MappingException {
 				bindStarToManySecondPass(
 						persistentClasses, collType, fkJoinColumns, keyColumns, inverseColumns, elementColumns,
 						isEmbedded, property, unique, assocTableBinder, ignoreNotFound, mappings
 				);
 			}
 		};
 	}
 
 	/**
 	 * return true if it's a Fk, false if it's an association table
 	 */
 	protected boolean bindStarToManySecondPass(
 			Map persistentClasses,
 			XClass collType,
 			Ejb3JoinColumn[] fkJoinColumns,
 			Ejb3JoinColumn[] keyColumns,
 			Ejb3JoinColumn[] inverseColumns,
 			Ejb3Column[] elementColumns,
 			boolean isEmbedded,
 			XProperty property,
 			boolean unique,
 			TableBinder associationTableBinder,
 			boolean ignoreNotFound,
 			Mappings mappings) {
 		PersistentClass persistentClass = (PersistentClass) persistentClasses.get( collType.getName() );
 		boolean reversePropertyInJoin = false;
 		if ( persistentClass != null && StringHelper.isNotEmpty( this.mappedBy ) ) {
 			try {
 				reversePropertyInJoin = 0 != persistentClass.getJoinNumber(
 						persistentClass.getRecursiveProperty( this.mappedBy )
 				);
 			}
 			catch (MappingException e) {
 				StringBuilder error = new StringBuilder( 80 );
 				error.append( "mappedBy reference an unknown target entity property: " )
 						.append( collType ).append( "." ).append( this.mappedBy )
 						.append( " in " )
 						.append( collection.getOwnerEntityName() )
 						.append( "." )
 						.append( property.getName() );
 				throw new AnnotationException( error.toString() );
 			}
 		}
 		if ( persistentClass != null
 				&& !reversePropertyInJoin
 				&& oneToMany
 				&& !this.isExplicitAssociationTable
 				&& ( joinColumns[0].isImplicit() && !BinderHelper.isEmptyAnnotationValue( this.mappedBy ) //implicit @JoinColumn
 				|| !fkJoinColumns[0].isImplicit() ) //this is an explicit @JoinColumn
 				) {
 			//this is a Foreign key
 			bindOneToManySecondPass(
 					getCollection(),
 					persistentClasses,
 					fkJoinColumns,
 					collType,
 					cascadeDeleteEnabled,
 					ignoreNotFound,
 					mappings,
 					inheritanceStatePerClass
 			);
 			return true;
 		}
 		else {
 			//this is an association table
 			bindManyToManySecondPass(
 					this.collection,
 					persistentClasses,
 					keyColumns,
 					inverseColumns,
 					elementColumns,
 					isEmbedded, collType,
 					ignoreNotFound, unique,
 					cascadeDeleteEnabled,
 					associationTableBinder,
 					property,
 					propertyHolder,
 					mappings
 			);
 			return false;
 		}
 	}
 
 	protected void bindOneToManySecondPass(
 			Collection collection,
 			Map persistentClasses,
 			Ejb3JoinColumn[] fkJoinColumns,
 			XClass collectionType,
 			boolean cascadeDeleteEnabled,
 			boolean ignoreNotFound,
 			Mappings mappings,
 			Map<XClass, InheritanceState> inheritanceStatePerClass) {
 
 		final boolean debugEnabled = LOG.isDebugEnabled();
 		if ( debugEnabled ) {
 			LOG.debugf( "Binding a OneToMany: %s.%s through a foreign key", propertyHolder.getEntityName(), propertyName );
 		}
 		org.hibernate.mapping.OneToMany oneToMany = new org.hibernate.mapping.OneToMany( mappings, collection.getOwner() );
 		collection.setElement( oneToMany );
 		oneToMany.setReferencedEntityName( collectionType.getName() );
 		oneToMany.setIgnoreNotFound( ignoreNotFound );
 
 		String assocClass = oneToMany.getReferencedEntityName();
 		PersistentClass associatedClass = (PersistentClass) persistentClasses.get( assocClass );
 		if ( jpaOrderBy != null ) {
 			final String jpaOrderByFragment = jpaOrderBy.value();
 			if ( StringHelper.isNotEmpty( jpaOrderByFragment ) ) {
 				final String orderByFragment = buildOrderByClauseFromHql(
 						jpaOrderBy.value(),
 						associatedClass,
 						collection.getRole()
 				);
 				if ( StringHelper.isNotEmpty( orderByFragment ) ) {
 					collection.setOrderBy( orderByFragment );
 				}
 			}
 		}
 
 		if ( mappings == null ) {
 			throw new AssertionFailure(
 					"CollectionSecondPass for oneToMany should not be called with null mappings"
 			);
 		}
 		Map<String, Join> joins = mappings.getJoins( assocClass );
 		if ( associatedClass == null ) {
 			throw new MappingException(
 					"Association references unmapped class: " + assocClass
 			);
 		}
 		oneToMany.setAssociatedClass( associatedClass );
 		for (Ejb3JoinColumn column : fkJoinColumns) {
 			column.setPersistentClass( associatedClass, joins, inheritanceStatePerClass );
 			column.setJoins( joins );
 			collection.setCollectionTable( column.getTable() );
 		}
 		if ( debugEnabled ) {
 			LOG.debugf( "Mapping collection: %s -> %s", collection.getRole(), collection.getCollectionTable().getName() );
 		}
 		bindFilters( false );
 		bindCollectionSecondPass( collection, null, fkJoinColumns, cascadeDeleteEnabled, property, mappings );
 		if ( !collection.isInverse()
 				&& !collection.getKey().isNullable() ) {
 			// for non-inverse one-to-many, with a not-null fk, add a backref!
 			String entityName = oneToMany.getReferencedEntityName();
 			PersistentClass referenced = mappings.getClass( entityName );
 			Backref prop = new Backref();
 			prop.setName( '_' + fkJoinColumns[0].getPropertyName() + '_' + fkJoinColumns[0].getLogicalColumnName() + "Backref" );
 			prop.setUpdateable( false );
 			prop.setSelectable( false );
 			prop.setCollectionRole( collection.getRole() );
 			prop.setEntityName( collection.getOwner().getEntityName() );
 			prop.setValue( collection.getKey() );
 			referenced.addProperty( prop );
 		}
 	}
 
 
 	private void bindFilters(boolean hasAssociationTable) {
 		Filter simpleFilter = property.getAnnotation( Filter.class );
 		//set filtering
 		//test incompatible choices
 		//if ( StringHelper.isNotEmpty( where ) ) collection.setWhere( where );
 		if ( simpleFilter != null ) {
 			if ( hasAssociationTable ) {
 				collection.addManyToManyFilter(simpleFilter.name(), getCondition(simpleFilter), simpleFilter.deduceAliasInjectionPoints(),
 						toAliasTableMap(simpleFilter.aliases()), toAliasEntityMap(simpleFilter.aliases()));
 			}
 			else {
 				collection.addFilter(simpleFilter.name(), getCondition(simpleFilter), simpleFilter.deduceAliasInjectionPoints(),
 						toAliasTableMap(simpleFilter.aliases()), toAliasEntityMap(simpleFilter.aliases()));
 			}
 		}
 		Filters filters = property.getAnnotation( Filters.class );
 		if ( filters != null ) {
 			for (Filter filter : filters.value()) {
 				if ( hasAssociationTable ) {
 					collection.addManyToManyFilter( filter.name(), getCondition(filter), filter.deduceAliasInjectionPoints(),
 							toAliasTableMap(filter.aliases()), toAliasEntityMap(filter.aliases()));
 				}
 				else {
 					collection.addFilter(filter.name(), getCondition(filter), filter.deduceAliasInjectionPoints(),
 							toAliasTableMap(filter.aliases()), toAliasEntityMap(filter.aliases()));
 				}
 			}
 		}
 		FilterJoinTable simpleFilterJoinTable = property.getAnnotation( FilterJoinTable.class );
 		if ( simpleFilterJoinTable != null ) {
 			if ( hasAssociationTable ) {
 				collection.addFilter(simpleFilterJoinTable.name(), simpleFilterJoinTable.condition(), 
 						simpleFilterJoinTable.deduceAliasInjectionPoints(), 
 						toAliasTableMap(simpleFilterJoinTable.aliases()), toAliasEntityMap(simpleFilterJoinTable.aliases()));
 					}
 			else {
 				throw new AnnotationException(
 						"Illegal use of @FilterJoinTable on an association without join table:"
 								+ StringHelper.qualify( propertyHolder.getPath(), propertyName )
 				);
 			}
 		}
 		FilterJoinTables filterJoinTables = property.getAnnotation( FilterJoinTables.class );
 		if ( filterJoinTables != null ) {
 			for (FilterJoinTable filter : filterJoinTables.value()) {
 				if ( hasAssociationTable ) {
 					collection.addFilter(filter.name(), filter.condition(), 
 							filter.deduceAliasInjectionPoints(), 
 							toAliasTableMap(filter.aliases()), toAliasEntityMap(filter.aliases()));
 				}
 				else {
 					throw new AnnotationException(
 							"Illegal use of @FilterJoinTable on an association without join table:"
 									+ StringHelper.qualify( propertyHolder.getPath(), propertyName )
 					);
 				}
 			}
 		}
 
 		Where where = property.getAnnotation( Where.class );
 		String whereClause = where == null ? null : where.clause();
 		if ( StringHelper.isNotEmpty( whereClause ) ) {
 			if ( hasAssociationTable ) {
 				collection.setManyToManyWhere( whereClause );
 			}
 			else {
 				collection.setWhere( whereClause );
 			}
 		}
 
 		WhereJoinTable whereJoinTable = property.getAnnotation( WhereJoinTable.class );
 		String whereJoinTableClause = whereJoinTable == null ? null : whereJoinTable.clause();
 		if ( StringHelper.isNotEmpty( whereJoinTableClause ) ) {
 			if ( hasAssociationTable ) {
 				collection.setWhere( whereJoinTableClause );
 			}
 			else {
 				throw new AnnotationException(
 						"Illegal use of @WhereJoinTable on an association without join table:"
 								+ StringHelper.qualify( propertyHolder.getPath(), propertyName )
 				);
 			}
 		}
 //		This cannot happen in annotations since the second fetch is hardcoded to join
 //		if ( ( ! collection.getManyToManyFilterMap().isEmpty() || collection.getManyToManyWhere() != null ) &&
 //		        collection.getFetchMode() == FetchMode.JOIN &&
 //		        collection.getElement().getFetchMode() != FetchMode.JOIN ) {
 //			throw new MappingException(
 //			        "association with join table  defining filter or where without join fetching " +
 //			        "not valid within collection using join fetching [" + collection.getRole() + "]"
 //				);
 //		}
 	}
 	
 	private String getCondition(FilterJoinTable filter) {
 		//set filtering
 		String name = filter.name();
 		String cond = filter.condition();
 		return getCondition( cond, name );
 	}
 	
 	private String getCondition(Filter filter) {
 		//set filtering
 		String name = filter.name();
 		String cond = filter.condition();
 		return getCondition( cond, name );
 	}
 
 	private String getCondition(String cond, String name) {
 		if ( BinderHelper.isEmptyAnnotationValue( cond ) ) {
 			cond = mappings.getFilterDefinition( name ).getDefaultFilterCondition();
 			if ( StringHelper.isEmpty( cond ) ) {
 				throw new AnnotationException(
 						"no filter condition found for filter " + name + " in "
 								+ StringHelper.qualify( propertyHolder.getPath(), propertyName )
 				);
 			}
 		}
 		return cond;
 	}
 
 	public void setCache(Cache cacheAnn) {
 		if ( cacheAnn != null ) {
 			cacheRegionName = BinderHelper.isEmptyAnnotationValue( cacheAnn.region() ) ? null : cacheAnn.region();
 			cacheConcurrencyStrategy = EntityBinder.getCacheConcurrencyStrategy( cacheAnn.usage() );
 		}
 		else {
 			cacheConcurrencyStrategy = null;
 			cacheRegionName = null;
 		}
 	}
 
 	public void setOneToMany(boolean oneToMany) {
 		this.oneToMany = oneToMany;
 	}
 
 	public void setIndexColumn(IndexColumn indexColumn) {
 		this.indexColumn = indexColumn;
 	}
 
 	public void setMapKey(MapKey key) {
 		if ( key != null ) {
 			mapKeyPropertyName = key.name();
 		}
 	}
 
 	private static String buildOrderByClauseFromHql(String orderByFragment, PersistentClass associatedClass, String role) {
 		if ( orderByFragment != null ) {
 			if ( orderByFragment.length() == 0 ) {
 				//order by id
 				return "id asc";
 			}
 			else if ( "desc".equals( orderByFragment ) ) {
 				return "id desc";
 			}
 		}
 		return orderByFragment;
 	}
 
 	private static String adjustUserSuppliedValueCollectionOrderingFragment(String orderByFragment) {
 		if ( orderByFragment != null ) {
 			// NOTE: "$element$" is a specially recognized collection property recognized by the collection persister
 			if ( orderByFragment.length() == 0 ) {
 				//order by element
 				return "$element$ asc";
 			}
 			else if ( "desc".equals( orderByFragment ) ) {
 				return "$element$ desc";
 			}
 		}
 		return orderByFragment;
 	}
 
 	private static SimpleValue buildCollectionKey(
 			Collection collValue,
 			Ejb3JoinColumn[] joinColumns,
 			boolean cascadeDeleteEnabled,
 			XProperty property,
 			Mappings mappings) {
 		//binding key reference using column
 		KeyValue keyVal;
 		//give a chance to override the referenced property name
 		//has to do that here because the referencedProperty creation happens in a FKSecondPass for Many to one yuk!
 		if ( joinColumns.length > 0 && StringHelper.isNotEmpty( joinColumns[0].getMappedBy() ) ) {
 			String entityName = joinColumns[0].getManyToManyOwnerSideEntityName() != null ?
 					"inverse__" + joinColumns[0].getManyToManyOwnerSideEntityName() :
 					joinColumns[0].getPropertyHolder().getEntityName();
 			String propRef = mappings.getPropertyReferencedAssociation(
 					entityName,
 					joinColumns[0].getMappedBy()
 			);
 			if ( propRef != null ) {
 				collValue.setReferencedPropertyName( propRef );
 				mappings.addPropertyReference( collValue.getOwnerEntityName(), propRef );
 			}
 		}
 		String propRef = collValue.getReferencedPropertyName();
 		if ( propRef == null ) {
 			keyVal = collValue.getOwner().getIdentifier();
 		}
 		else {
 			keyVal = (KeyValue) collValue.getOwner()
 					.getReferencedProperty( propRef )
 					.getValue();
 		}
 		DependantValue key = new DependantValue( mappings, collValue.getCollectionTable(), keyVal );
 		key.setTypeName( null );
 		Ejb3Column.checkPropertyConsistency( joinColumns, collValue.getOwnerEntityName() );
 		key.setNullable( joinColumns.length == 0 || joinColumns[0].isNullable() );
 		key.setUpdateable( joinColumns.length == 0 || joinColumns[0].isUpdatable() );
 		key.setCascadeDeleteEnabled( cascadeDeleteEnabled );
 		collValue.setKey( key );
 		ForeignKey fk = property != null ? property.getAnnotation( ForeignKey.class ) : null;
 		String fkName = fk != null ? fk.name() : "";
 		if ( !BinderHelper.isEmptyAnnotationValue( fkName ) ) key.setForeignKeyName( fkName );
 		return key;
 	}
 
 	protected void bindManyToManySecondPass(
 			Collection collValue,
 			Map persistentClasses,
 			Ejb3JoinColumn[] joinColumns,
 			Ejb3JoinColumn[] inverseJoinColumns,
 			Ejb3Column[] elementColumns,
 			boolean isEmbedded,
 			XClass collType,
 			boolean ignoreNotFound, boolean unique,
 			boolean cascadeDeleteEnabled,
 			TableBinder associationTableBinder,
 			XProperty property,
 			PropertyHolder parentPropertyHolder,
 			Mappings mappings) throws MappingException {
 		if ( property == null ) {
 			throw new IllegalArgumentException( "null was passed for argument property" );
 		}
 
 		final PersistentClass collectionEntity = (PersistentClass) persistentClasses.get( collType.getName() );
 		final String hqlOrderBy = extractHqlOrderBy( jpaOrderBy );
 
 		boolean isCollectionOfEntities = collectionEntity != null;
 		ManyToAny anyAnn = property.getAnnotation( ManyToAny.class );
         if (LOG.isDebugEnabled()) {
 			String path = collValue.getOwnerEntityName() + "." + joinColumns[0].getPropertyName();
             if (isCollectionOfEntities && unique) LOG.debugf("Binding a OneToMany: %s through an association table", path);
             else if (isCollectionOfEntities) LOG.debugf("Binding as ManyToMany: %s", path);
             else if (anyAnn != null) LOG.debugf("Binding a ManyToAny: %s", path);
             else LOG.debugf("Binding a collection of element: %s", path);
 		}
 		//check for user error
 		if ( !isCollectionOfEntities ) {
 			if ( property.isAnnotationPresent( ManyToMany.class ) || property.isAnnotationPresent( OneToMany.class ) ) {
 				String path = collValue.getOwnerEntityName() + "." + joinColumns[0].getPropertyName();
 				throw new AnnotationException(
 						"Use of @OneToMany or @ManyToMany targeting an unmapped class: " + path + "[" + collType + "]"
 				);
 			}
 			else if ( anyAnn != null ) {
 				if ( parentPropertyHolder.getJoinTable( property ) == null ) {
 					String path = collValue.getOwnerEntityName() + "." + joinColumns[0].getPropertyName();
 					throw new AnnotationException(
 							"@JoinTable is mandatory when @ManyToAny is used: " + path
 					);
 				}
 			}
 			else {
 				JoinTable joinTableAnn = parentPropertyHolder.getJoinTable( property );
 				if ( joinTableAnn != null && joinTableAnn.inverseJoinColumns().length > 0 ) {
 					String path = collValue.getOwnerEntityName() + "." + joinColumns[0].getPropertyName();
 					throw new AnnotationException(
 							"Use of @JoinTable.inverseJoinColumns targeting an unmapped class: " + path + "[" + collType + "]"
 					);
 				}
 			}
 		}
 
 		boolean mappedBy = !BinderHelper.isEmptyAnnotationValue( joinColumns[0].getMappedBy() );
 		if ( mappedBy ) {
 			if ( !isCollectionOfEntities ) {
 				StringBuilder error = new StringBuilder( 80 )
 						.append(
 								"Collection of elements must not have mappedBy or association reference an unmapped entity: "
 						)
 						.append( collValue.getOwnerEntityName() )
 						.append( "." )
 						.append( joinColumns[0].getPropertyName() );
 				throw new AnnotationException( error.toString() );
 			}
 			Property otherSideProperty;
 			try {
 				otherSideProperty = collectionEntity.getRecursiveProperty( joinColumns[0].getMappedBy() );
 			}
 			catch (MappingException e) {
 				StringBuilder error = new StringBuilder( 80 );
 				error.append( "mappedBy reference an unknown target entity property: " )
 						.append( collType ).append( "." ).append( joinColumns[0].getMappedBy() )
 						.append( " in " )
 						.append( collValue.getOwnerEntityName() )
 						.append( "." )
 						.append( joinColumns[0].getPropertyName() );
 				throw new AnnotationException( error.toString() );
 			}
 			Table table;
 			if ( otherSideProperty.getValue() instanceof Collection ) {
 				//this is a collection on the other side
 				table = ( (Collection) otherSideProperty.getValue() ).getCollectionTable();
 			}
 			else {
 				//This is a ToOne with a @JoinTable or a regular property
 				table = otherSideProperty.getValue().getTable();
 			}
 			collValue.setCollectionTable( table );
 			String entityName = collectionEntity.getEntityName();
 			for (Ejb3JoinColumn column : joinColumns) {
 				//column.setDefaultColumnHeader( joinColumns[0].getMappedBy() ); //seems not to be used, make sense
 				column.setManyToManyOwnerSideEntityName( entityName );
 			}
 		}
 		else {
 			//TODO: only for implicit columns?
 			//FIXME NamingStrategy
 			for (Ejb3JoinColumn column : joinColumns) {
 				String mappedByProperty = mappings.getFromMappedBy(
 						collValue.getOwnerEntityName(), column.getPropertyName()
 				);
 				Table ownerTable = collValue.getOwner().getTable();
 				column.setMappedBy(
 						collValue.getOwner().getEntityName(), mappings.getLogicalTableName( ownerTable ),
 						mappedByProperty
 				);
 //				String header = ( mappedByProperty == null ) ? mappings.getLogicalTableName( ownerTable ) : mappedByProperty;
 //				column.setDefaultColumnHeader( header );
 			}
 			if ( StringHelper.isEmpty( associationTableBinder.getName() ) ) {
 				//default value
 				associationTableBinder.setDefaultName(
 						collValue.getOwner().getEntityName(),
 						mappings.getLogicalTableName( collValue.getOwner().getTable() ),
 						collectionEntity != null ? collectionEntity.getEntityName() : null,
 						collectionEntity != null ? mappings.getLogicalTableName( collectionEntity.getTable() ) : null,
 						joinColumns[0].getPropertyName()
 				);
 			}
 			associationTableBinder.setJPA2ElementCollection( !isCollectionOfEntities && property.isAnnotationPresent( ElementCollection.class ));
 			collValue.setCollectionTable( associationTableBinder.bind() );
 		}
 		bindFilters( isCollectionOfEntities );
 		bindCollectionSecondPass( collValue, collectionEntity, joinColumns, cascadeDeleteEnabled, property, mappings );
 
 		ManyToOne element = null;
 		if ( isCollectionOfEntities ) {
 			element =
 					new ManyToOne( mappings,  collValue.getCollectionTable() );
 			collValue.setElement( element );
 			element.setReferencedEntityName( collType.getName() );
 			//element.setFetchMode( fetchMode );
 			//element.setLazy( fetchMode != FetchMode.JOIN );
 			//make the second join non lazy
 			element.setFetchMode( FetchMode.JOIN );
 			element.setLazy( false );
 			element.setIgnoreNotFound( ignoreNotFound );
 			// as per 11.1.38 of JPA 2.0 spec, default to primary key if no column is specified by @OrderBy.
 			if ( hqlOrderBy != null ) {
 				collValue.setManyToManyOrdering(
 						buildOrderByClauseFromHql( hqlOrderBy, collectionEntity, collValue.getRole() )
 				);
 			}
 			final ForeignKey fk = property.getAnnotation( ForeignKey.class );
 			String fkName = fk != null ? fk.inverseName() : "";
 			if ( !BinderHelper.isEmptyAnnotationValue( fkName ) ) {
 				element.setForeignKeyName( fkName );
 			}
 		}
 		else if ( anyAnn != null ) {
 			//@ManyToAny
 			//Make sure that collTyp is never used during the @ManyToAny branch: it will be set to void.class
 			PropertyData inferredData = new PropertyInferredData(null, property, "unsupported", mappings.getReflectionManager() );
 			//override the table
 			for (Ejb3Column column : inverseJoinColumns) {
 				column.setTable( collValue.getCollectionTable() );
 			}
 			Any any = BinderHelper.buildAnyValue( anyAnn.metaDef(), inverseJoinColumns, anyAnn.metaColumn(),
 					inferredData, cascadeDeleteEnabled, Nullability.NO_CONSTRAINT,
 					propertyHolder, new EntityBinder(), true, mappings );
 			collValue.setElement( any );
 		}
 		else {
 			XClass elementClass;
 			AnnotatedClassType classType;
 
 			PropertyHolder holder = null;
 			if ( BinderHelper.PRIMITIVE_NAMES.contains( collType.getName() ) ) {
 				classType = AnnotatedClassType.NONE;
 				elementClass = null;
 			}
 			else {
 				elementClass = collType;
 				classType = mappings.getClassType( elementClass );
 
 				holder = PropertyHolderBuilder.buildPropertyHolder(
 						collValue,
 						collValue.getRole(),
 						elementClass,
 						property, parentPropertyHolder, mappings
 				);
 				//force in case of attribute override
 				boolean attributeOverride = property.isAnnotationPresent( AttributeOverride.class )
 						|| property.isAnnotationPresent( AttributeOverrides.class );
 				if ( isEmbedded || attributeOverride ) {
 					classType = AnnotatedClassType.EMBEDDABLE;
 				}
 			}
 
 			if ( AnnotatedClassType.EMBEDDABLE.equals( classType ) ) {
 				EntityBinder entityBinder = new EntityBinder();
 				PersistentClass owner = collValue.getOwner();
 				boolean isPropertyAnnotated;
 				//FIXME support @Access for collection of elements
 				//String accessType = access != null ? access.value() : null;
 				if ( owner.getIdentifierProperty() != null ) {
 					isPropertyAnnotated = owner.getIdentifierProperty().getPropertyAccessorName().equals( "property" );
 				}
 				else if ( owner.getIdentifierMapper() != null && owner.getIdentifierMapper().getPropertySpan() > 0 ) {
 					Property prop = (Property) owner.getIdentifierMapper().getPropertyIterator().next();
 					isPropertyAnnotated = prop.getPropertyAccessorName().equals( "property" );
 				}
 				else {
 					throw new AssertionFailure( "Unable to guess collection property accessor name" );
 				}
 
 				PropertyData inferredData;
 				if ( isMap() ) {
 					//"value" is the JPA 2 prefix for map values (used to be "element")
 					if ( isHibernateExtensionMapping() ) {
 						inferredData = new PropertyPreloadedData( AccessType.PROPERTY, "element", elementClass );
 					}
 					else {
 						inferredData = new PropertyPreloadedData( AccessType.PROPERTY, "value", elementClass );
 					}
 				}
 				else {
 					if ( isHibernateExtensionMapping() ) {
 						inferredData = new PropertyPreloadedData( AccessType.PROPERTY, "element", elementClass );
 					}
 					else {
 						//"collection&&element" is not a valid property name => placeholder
 						inferredData = new PropertyPreloadedData( AccessType.PROPERTY, "collection&&element", elementClass );
 					}
 				}
 				//TODO be smart with isNullable
 				Component component = AnnotationBinder.fillComponent(
 						holder, inferredData, isPropertyAnnotated ? AccessType.PROPERTY : AccessType.FIELD, true,
 						entityBinder, false, false,
 						true, mappings, inheritanceStatePerClass
 				);
 
 				collValue.setElement( component );
 
 				if ( StringHelper.isNotEmpty( hqlOrderBy ) ) {
 					String path = collValue.getOwnerEntityName() + "." + joinColumns[0].getPropertyName();
 					String orderBy = adjustUserSuppliedValueCollectionOrderingFragment( hqlOrderBy );
 					if ( orderBy != null ) {
 						collValue.setOrderBy( orderBy );
 					}
 				}
 			}
 			else {
 				SimpleValueBinder elementBinder = new SimpleValueBinder();
 				elementBinder.setMappings( mappings );
 				elementBinder.setReturnedClassName( collType.getName() );
 				if ( elementColumns == null || elementColumns.length == 0 ) {
 					elementColumns = new Ejb3Column[1];
 					Ejb3Column column = new Ejb3Column();
 					column.setImplicit( false );
 					//not following the spec but more clean
 					column.setNullable( true );
 					column.setLength( Ejb3Column.DEFAULT_COLUMN_LENGTH );
 					column.setLogicalColumnName( Collection.DEFAULT_ELEMENT_COLUMN_NAME );
 					//TODO create an EMPTY_JOINS collection
 					column.setJoins( new HashMap<String, Join>() );
 					column.setMappings( mappings );
 					column.bind();
 					elementColumns[0] = column;
 				}
 				//override the table
 				for (Ejb3Column column : elementColumns) {
 					column.setTable( collValue.getCollectionTable() );
 				}
 				elementBinder.setColumns( elementColumns );
 				elementBinder.setType( property, elementClass, collValue.getOwnerEntityName() );
 				elementBinder.setPersistentClassName( propertyHolder.getEntityName() );
 				elementBinder.setAccessType( accessType );
 				collValue.setElement( elementBinder.make() );
 				String orderBy = adjustUserSuppliedValueCollectionOrderingFragment( hqlOrderBy );
 				if ( orderBy != null ) {
 					collValue.setOrderBy( orderBy );
 				}
 			}
 		}
 
 		checkFilterConditions( collValue );
 
 		//FIXME: do optional = false
 		if ( isCollectionOfEntities ) {
 			bindManytoManyInverseFk( collectionEntity, inverseJoinColumns, element, unique, mappings );
 		}
 
 	}
 
 	private String extractHqlOrderBy(javax.persistence.OrderBy jpaOrderBy) {
 		if ( jpaOrderBy != null ) {
 			return jpaOrderBy.value(); // Null not possible. In case of empty expression, apply default ordering.
 		}
 		return null; // @OrderBy not found.
 	}
 
 	private static void checkFilterConditions(Collection collValue) {
 		//for now it can't happen, but sometime soon...
 		if ( ( collValue.getFilters().size() != 0 || StringHelper.isNotEmpty( collValue.getWhere() ) ) &&
 				collValue.getFetchMode() == FetchMode.JOIN &&
 				!( collValue.getElement() instanceof SimpleValue ) && //SimpleValue (CollectionOfElements) are always SELECT but it does not matter
 				collValue.getElement().getFetchMode() != FetchMode.JOIN ) {
 			throw new MappingException(
 					"@ManyToMany or @CollectionOfElements defining filter or where without join fetching "
 							+ "not valid within collection using join fetching[" + collValue.getRole() + "]"
 			);
 		}
 	}
 
 	private static void bindCollectionSecondPass(
 			Collection collValue,
 			PersistentClass collectionEntity,
 			Ejb3JoinColumn[] joinColumns,
 			boolean cascadeDeleteEnabled,
 			XProperty property,
 			Mappings mappings) {
 		BinderHelper.createSyntheticPropertyReference(
 				joinColumns, collValue.getOwner(), collectionEntity, collValue, false, mappings
 		);
 		SimpleValue key = buildCollectionKey( collValue, joinColumns, cascadeDeleteEnabled, property, mappings );
 		if ( property.isAnnotationPresent( ElementCollection.class ) && joinColumns.length > 0 ) {
 			joinColumns[0].setJPA2ElementCollection( true );
 		}
 		TableBinder.bindFk( collValue.getOwner(), collectionEntity, joinColumns, key, false, mappings );
 	}
 
 	public void setCascadeDeleteEnabled(boolean onDeleteCascade) {
 		this.cascadeDeleteEnabled = onDeleteCascade;
 	}
 
 	private String safeCollectionRole() {
 		if ( propertyHolder != null ) {
 			return propertyHolder.getEntityName() + "." + propertyName;
 		}
 		else {
 			return "";
 		}
 	}
 
 
 	/**
 	 * bind the inverse FK of a ManyToMany
 	 * If we are in a mappedBy case, read the columns from the associated
 	 * collection element
 	 * Otherwise delegates to the usual algorithm
 	 */
 	public static void bindManytoManyInverseFk(
 			PersistentClass referencedEntity,
 			Ejb3JoinColumn[] columns,
 			SimpleValue value,
 			boolean unique,
 			Mappings mappings) {
 		final String mappedBy = columns[0].getMappedBy();
 		if ( StringHelper.isNotEmpty( mappedBy ) ) {
 			final Property property = referencedEntity.getRecursiveProperty( mappedBy );
 			Iterator mappedByColumns;
 			if ( property.getValue() instanceof Collection ) {
 				mappedByColumns = ( (Collection) property.getValue() ).getKey().getColumnIterator();
 			}
 			else {
 				//find the appropriate reference key, can be in a join
 				Iterator joinsIt = referencedEntity.getJoinIterator();
 				KeyValue key = null;
 				while ( joinsIt.hasNext() ) {
 					Join join = (Join) joinsIt.next();
 					if ( join.containsProperty( property ) ) {
 						key = join.getKey();
 						break;
 					}
 				}
 				if ( key == null ) key = property.getPersistentClass().getIdentifier();
 				mappedByColumns = key.getColumnIterator();
 			}
 			while ( mappedByColumns.hasNext() ) {
 				Column column = (Column) mappedByColumns.next();
 				columns[0].linkValueUsingAColumnCopy( column, value );
 			}
 			String referencedPropertyName =
 					mappings.getPropertyReferencedAssociation(
 							"inverse__" + referencedEntity.getEntityName(), mappedBy
 					);
 			if ( referencedPropertyName != null ) {
 				//TODO always a many to one?
 				( (ManyToOne) value ).setReferencedPropertyName( referencedPropertyName );
 				mappings.addUniquePropertyReference( referencedEntity.getEntityName(), referencedPropertyName );
 			}
 			( (ManyToOne) value ).setReferenceToPrimaryKey( referencedPropertyName == null );
 			value.createForeignKey();
 		}
 		else {
 			BinderHelper.createSyntheticPropertyReference( columns, referencedEntity, null, value, true, mappings );
 			TableBinder.bindFk( referencedEntity, null, columns, value, unique, mappings );
 		}
 	}
 
 	public void setFkJoinColumns(Ejb3JoinColumn[] ejb3JoinColumns) {
 		this.fkJoinColumns = ejb3JoinColumns;
 	}
 
 	public void setExplicitAssociationTable(boolean explicitAssocTable) {
 		this.isExplicitAssociationTable = explicitAssocTable;
 	}
 
 	public void setElementColumns(Ejb3Column[] elementColumns) {
 		this.elementColumns = elementColumns;
 	}
 
 	public void setEmbedded(boolean annotationPresent) {
 		this.isEmbedded = annotationPresent;
 	}
 
 	public void setProperty(XProperty property) {
 		this.property = property;
 	}
 
 	public void setIgnoreNotFound(boolean ignoreNotFound) {
 		this.ignoreNotFound = ignoreNotFound;
 	}
 
 	public void setMapKeyColumns(Ejb3Column[] mapKeyColumns) {
 		this.mapKeyColumns = mapKeyColumns;
 	}
 
 	public void setMapKeyManyToManyColumns(Ejb3JoinColumn[] mapJoinColumns) {
 		this.mapKeyManyToManyColumns = mapJoinColumns;
 	}
 
 	public void setLocalGenerators(HashMap<String, IdGenerator> localGenerators) {
 		this.localGenerators = localGenerators;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentBag.java b/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentBag.java
index c90245bdf2..c452e9d692 100644
--- a/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentBag.java
+++ b/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentBag.java
@@ -1,591 +1,590 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.collection.internal;
 
 import java.io.Serializable;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.loader.CollectionAliases;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.type.Type;
 
 /**
  * An unordered, unkeyed collection that can contain the same element
  * multiple times. The Java collections API, curiously, has no <tt>Bag</tt>.
  * Most developers seem to use <tt>List</tt>s to represent bag semantics,
  * so Hibernate follows this practice.
  *
  * @author Gavin King
  */
 public class PersistentBag extends AbstractPersistentCollection implements List {
 
 	protected List bag;
 
 	/**
 	 * Constructs a PersistentBag.  Needed for SOAP libraries, etc
 	 */
 	@SuppressWarnings("UnusedDeclaration")
 	public PersistentBag() {
 	}
 
 	/**
 	 * Constructs a PersistentBag
 	 *
 	 * @param session The session
 	 */
 	public PersistentBag(SessionImplementor session) {
 		super( session );
 	}
 
 	/**
 	 * Constructs a PersistentBag
 	 *
 	 * @param session The session
 	 * @param coll The base elements.
 	 */
 	@SuppressWarnings("unchecked")
 	public PersistentBag(SessionImplementor session, Collection coll) {
 		super( session );
 		if ( coll instanceof List ) {
 			bag = (List) coll;
 		}
 		else {
 			bag = new ArrayList();
 			for ( Object element : coll ) {
 				bag.add( element );
 			}
 		}
 		setInitialized();
 		setDirectlyAccessible( true );
 	}
 
 	@Override
 	public boolean isWrapper(Object collection) {
 		return bag==collection;
 	}
 
 	@Override
 	public boolean empty() {
 		return bag.isEmpty();
 	}
 
 	@Override
 	public Iterator entries(CollectionPersister persister) {
 		return bag.iterator();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object readFrom(ResultSet rs, CollectionPersister persister, CollectionAliases descriptor, Object owner)
 			throws HibernateException, SQLException {
 		// note that if we load this collection from a cartesian product
 		// the multiplicity would be broken ... so use an idbag instead
 		final Object element = persister.readElement( rs, owner, descriptor.getSuffixedElementAliases(), getSession() ) ;
 		if ( element != null ) {
 			bag.add( element );
 		}
 		return element;
 	}
 
 	@Override
 	public void beforeInitialize(CollectionPersister persister, int anticipatedSize) {
 		this.bag = (List) persister.getCollectionType().instantiate( anticipatedSize );
 	}
 
 	@Override
 	public boolean equalsSnapshot(CollectionPersister persister) throws HibernateException {
 		final Type elementType = persister.getElementType();
 		final List sn = (List) getSnapshot();
 		if ( sn.size() != bag.size() ) {
 			return false;
 		}
 		for ( Object elt : bag ) {
 			final boolean unequal = countOccurrences( elt, bag, elementType ) != countOccurrences( elt, sn, elementType );
 			if ( unequal ) {
 				return false;
 			}
 		}
 		return true;
 	}
 
 	@Override
 	public boolean isSnapshotEmpty(Serializable snapshot) {
 		return ( (Collection) snapshot ).isEmpty();
 	}
 
 	private int countOccurrences(Object element, List list, Type elementType)
 			throws HibernateException {
 		final Iterator iter = list.iterator();
 		int result = 0;
 		while ( iter.hasNext() ) {
 			if ( elementType.isSame( element, iter.next() ) ) {
 				result++;
 			}
 		}
 		return result;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Serializable getSnapshot(CollectionPersister persister)
 			throws HibernateException {
 		final ArrayList clonedList = new ArrayList( bag.size() );
 		for ( Object item : bag ) {
 			clonedList.add( persister.getElementType().deepCopy( item, persister.getFactory() ) );
 		}
 		return clonedList;
 	}
 
 	@Override
 	public Collection getOrphans(Serializable snapshot, String entityName) throws HibernateException {
 		final List sn = (List) snapshot;
 		return getOrphans( sn, bag, entityName, getSession() );
 	}
 
 	@Override
 	public Serializable disassemble(CollectionPersister persister)
 			throws HibernateException {
 		final int length = bag.size();
 		final Serializable[] result = new Serializable[length];
 		for ( int i=0; i<length; i++ ) {
 			result[i] = persister.getElementType().disassemble( bag.get( i ), getSession(), null );
 		}
 		return result;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public void initializeFromCache(CollectionPersister persister, Serializable disassembled, Object owner)
 			throws HibernateException {
 		final Serializable[] array = (Serializable[]) disassembled;
 		final int size = array.length;
 		beforeInitialize( persister, size );
 		for ( Serializable item : array ) {
 			final Object element = persister.getElementType().assemble( item, getSession(), owner );
 			if ( element != null ) {
 				bag.add( element );
 			}
 		}
 	}
 
 	@Override
 	public boolean needsRecreate(CollectionPersister persister) {
 		return !persister.isOneToMany();
 	}
 
 
 	// For a one-to-many, a <bag> is not really a bag;
 	// it is *really* a set, since it can't contain the
 	// same element twice. It could be considered a bug
 	// in the mapping dtd that <bag> allows <one-to-many>.
 
 	// Anyway, here we implement <set> semantics for a
 	// <one-to-many> <bag>!
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Iterator getDeletes(CollectionPersister persister, boolean indexIsFormula) throws HibernateException {
 		final Type elementType = persister.getElementType();
 		final ArrayList deletes = new ArrayList();
 		final List sn = (List) getSnapshot();
 		final Iterator olditer = sn.iterator();
 		int i=0;
 		while ( olditer.hasNext() ) {
 			final Object old = olditer.next();
 			final Iterator newiter = bag.iterator();
 			boolean found = false;
 			if ( bag.size()>i && elementType.isSame( old, bag.get( i++ ) ) ) {
 			//a shortcut if its location didn't change!
 				found = true;
 			}
 			else {
 				//search for it
 				//note that this code is incorrect for other than one-to-many
 				while ( newiter.hasNext() ) {
 					if ( elementType.isSame( old, newiter.next() ) ) {
 						found = true;
 						break;
 					}
 				}
 			}
 			if ( !found ) {
 				deletes.add( old );
 			}
 		}
 		return deletes.iterator();
 	}
 
 	@Override
 	public boolean needsInserting(Object entry, int i, Type elemType) throws HibernateException {
 		final List sn = (List) getSnapshot();
 		if ( sn.size() > i && elemType.isSame( sn.get( i ), entry ) ) {
 			//a shortcut if its location didn't change!
 			return false;
 		}
 		else {
 			//search for it
 			//note that this code is incorrect for other than one-to-many
 			for ( Object old : sn ) {
 				if ( elemType.isSame( old, entry ) ) {
 					return false;
 				}
 			}
 			return true;
 		}
 	}
 
 	@Override
 	public boolean isRowUpdatePossible() {
 		return false;
 	}
 
 	@Override
 	public boolean needsUpdating(Object entry, int i, Type elemType) {
 		return false;
 	}
 
 	@Override
 	public int size() {
 		return readSize() ? getCachedSize() : bag.size();
 	}
 
 	@Override
 	public boolean isEmpty() {
 		return readSize() ? getCachedSize()==0 : bag.isEmpty();
 	}
 
 	@Override
-	@SuppressWarnings("UnnecessaryUnboxing")
 	public boolean contains(Object object) {
 		final Boolean exists = readElementExistence( object );
-		return exists == null ? bag.contains( object ) : exists.booleanValue();
+		return exists == null ? bag.contains( object ) : exists;
 	}
 
 	@Override
 	public Iterator iterator() {
 		read();
 		return new IteratorProxy( bag.iterator() );
 	}
 
 	@Override
 	public Object[] toArray() {
 		read();
 		return bag.toArray();
 	}
 
 	@Override
 	public Object[] toArray(Object[] a) {
 		read();
 		return bag.toArray( a );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean add(Object object) {
 		if ( !isOperationQueueEnabled() ) {
 			write();
 			return bag.add( object );
 		}
 		else {
 			queueOperation( new SimpleAdd( object ) );
 			return true;
 		}
 	}
 
 	@Override
 	public boolean remove(Object o) {
 		initialize( true );
 		if ( bag.remove( o ) ) {
 			dirty();
 			return true;
 		}
 		else {
 			return false;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean containsAll(Collection c) {
 		read();
 		return bag.containsAll( c );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean addAll(Collection values) {
 		if ( values.size()==0 ) {
 			return false;
 		}
 		if ( !isOperationQueueEnabled() ) {
 			write();
 			return bag.addAll( values );
 		}
 		else {
 			for ( Object value : values ) {
 				queueOperation( new SimpleAdd( value ) );
 			}
 			return values.size()>0;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean removeAll(Collection c) {
 		if ( c.size()>0 ) {
 			initialize( true );
 			if ( bag.removeAll( c ) ) {
 				dirty();
 				return true;
 			}
 			else {
 				return false;
 			}
 		}
 		else {
 			return false;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean retainAll(Collection c) {
 		initialize( true );
 		if ( bag.retainAll( c ) ) {
 			dirty();
 			return true;
 		}
 		else {
 			return false;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public void clear() {
 		if ( isClearQueueEnabled() ) {
 			queueOperation( new Clear() );
 		}
 		else {
 			initialize( true );
 			if ( ! bag.isEmpty() ) {
 				bag.clear();
 				dirty();
 			}
 		}
 	}
 
 	@Override
 	public Object getIndex(Object entry, int i, CollectionPersister persister) {
 		throw new UnsupportedOperationException("Bags don't have indexes");
 	}
 
 	@Override
 	public Object getElement(Object entry) {
 		return entry;
 	}
 
 	@Override
 	public Object getSnapshotElement(Object entry, int i) {
 		final List sn = (List) getSnapshot();
 		return sn.get( i );
 	}
 
 	/**
 	 * Count how many times the given object occurs in the elements
 	 *
 	 * @param o The object to check
 	 *
 	 * @return The number of occurences.
 	 */
 	@SuppressWarnings("UnusedDeclaration")
 	public int occurrences(Object o) {
 		read();
 		final Iterator itr = bag.iterator();
 		int result = 0;
 		while ( itr.hasNext() ) {
 			if ( o.equals( itr.next() ) ) {
 				result++;
 			}
 		}
 		return result;
 	}
 
 	// List OPERATIONS:
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public void add(int i, Object o) {
 		write();
 		bag.add( i, o );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean addAll(int i, Collection c) {
 		if ( c.size() > 0 ) {
 			write();
 			return bag.addAll( i, c );
 		}
 		else {
 			return false;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object get(int i) {
 		read();
 		return bag.get( i );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public int indexOf(Object o) {
 		read();
 		return bag.indexOf( o );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public int lastIndexOf(Object o) {
 		read();
 		return bag.lastIndexOf( o );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public ListIterator listIterator() {
 		read();
 		return new ListIteratorProxy( bag.listIterator() );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public ListIterator listIterator(int i) {
 		read();
 		return new ListIteratorProxy( bag.listIterator( i ) );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object remove(int i) {
 		write();
 		return bag.remove( i );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object set(int i, Object o) {
 		write();
 		return bag.set( i, o );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public List subList(int start, int end) {
 		read();
 		return new ListProxy( bag.subList( start, end ) );
 	}
 
 	@Override
 	public boolean entryExists(Object entry, int i) {
 		return entry!=null;
 	}
 
 	@Override
 	public String toString() {
 		read();
 		return bag.toString();
 	}
 
 	/**
 	 * Bag does not respect the collection API and do an
 	 * JVM instance comparison to do the equals.
 	 * The semantic is broken not to have to initialize a
 	 * collection for a simple equals() operation.
 	 * @see java.lang.Object#equals(java.lang.Object)
 	 *
 	 * {@inheritDoc}
 	 */
 	@Override
 	public boolean equals(Object obj) {
 		return super.equals( obj );
 	}
 
 	@Override
 	public int hashCode() {
 		return super.hashCode();
 	}
 
 	final class Clear implements DelayedOperation {
 		@Override
 		public void operate() {
 			bag.clear();
 		}
 
 		@Override
 		public Object getAddedInstance() {
 			return null;
 		}
 
 		@Override
 		public Object getOrphan() {
 			throw new UnsupportedOperationException("queued clear cannot be used with orphan delete");
 		}
 	}
 
 	final class SimpleAdd implements DelayedOperation {
 		private Object value;
 
 		public SimpleAdd(Object value) {
 			this.value = value;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public void operate() {
 			bag.add( value );
 		}
 
 		@Override
 		public Object getAddedInstance() {
 			return value;
 		}
 
 		@Override
 		public Object getOrphan() {
 			return null;
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentList.java b/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentList.java
index bd24d1ac12..ac096cff95 100644
--- a/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentList.java
+++ b/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentList.java
@@ -1,654 +1,652 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.collection.internal;
 
 import java.io.Serializable;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 import java.util.ListIterator;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.loader.CollectionAliases;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.type.Type;
 
 /**
  * A persistent wrapper for a <tt>java.util.List</tt>. Underlying
  * collection is an <tt>ArrayList</tt>.
  *
  * @see java.util.ArrayList
  * @author Gavin King
  */
 public class PersistentList extends AbstractPersistentCollection implements List {
 	protected List list;
 
 	/**
 	 * Constructs a PersistentList.  This form needed for SOAP libraries, etc
 	 */
 	public PersistentList() {
 	}
 
 	/**
 	 * Constructs a PersistentList.
 	 *
 	 * @param session The session
 	 */
 	public PersistentList(SessionImplementor session) {
 		super( session );
 	}
 
 	/**
 	 * Constructs a PersistentList.
 	 *
 	 * @param session The session
 	 * @param list The raw list
 	 */
 	public PersistentList(SessionImplementor session, List list) {
 		super( session );
 		this.list = list;
 		setInitialized();
 		setDirectlyAccessible( true );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public Serializable getSnapshot(CollectionPersister persister) throws HibernateException {
 		final ArrayList clonedList = new ArrayList( list.size() );
 		for ( Object element : list ) {
 			final Object deepCopy = persister.getElementType().deepCopy( element, persister.getFactory() );
 			clonedList.add( deepCopy );
 		}
 		return clonedList;
 	}
 
 	@Override
 	public Collection getOrphans(Serializable snapshot, String entityName) throws HibernateException {
 		final List sn = (List) snapshot;
 		return getOrphans( sn, list, entityName, getSession() );
 	}
 
 	@Override
 	public boolean equalsSnapshot(CollectionPersister persister) throws HibernateException {
 		final Type elementType = persister.getElementType();
 		final List sn = (List) getSnapshot();
 		if ( sn.size()!=this.list.size() ) {
 			return false;
 		}
 		final Iterator itr = list.iterator();
 		final Iterator snapshotItr = sn.iterator();
 		while ( itr.hasNext() ) {
 			if ( elementType.isDirty( itr.next(), snapshotItr.next(), getSession() ) ) {
 				return false;
 			}
 		}
 		return true;
 	}
 
 	@Override
 	public boolean isSnapshotEmpty(Serializable snapshot) {
 		return ( (Collection) snapshot ).isEmpty();
 	}
 
 	@Override
 	public void beforeInitialize(CollectionPersister persister, int anticipatedSize) {
 		this.list = (List) persister.getCollectionType().instantiate( anticipatedSize );
 	}
 
 	@Override
 	public boolean isWrapper(Object collection) {
 		return list==collection;
 	}
 
 	@Override
 	public int size() {
 		return readSize() ? getCachedSize() : list.size();
 	}
 
 	@Override
 	public boolean isEmpty() {
 		return readSize() ? getCachedSize()==0 : list.isEmpty();
 	}
 
 	@Override
-	@SuppressWarnings("UnnecessaryUnboxing")
 	public boolean contains(Object object) {
 		final Boolean exists = readElementExistence( object );
 		return exists == null
 				? list.contains( object )
-				: exists.booleanValue();
+				: exists;
 	}
 
 	@Override
 	public Iterator iterator() {
 		read();
 		return new IteratorProxy( list.iterator() );
 	}
 
 	@Override
 	public Object[] toArray() {
 		read();
 		return list.toArray();
 	}
 
 	@Override
 	public Object[] toArray(Object[] array) {
 		read();
 		return list.toArray( array );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean add(Object object) {
 		if ( !isOperationQueueEnabled() ) {
 			write();
 			return list.add( object );
 		}
 		else {
 			queueOperation( new SimpleAdd( object ) );
 			return true;
 		}
 	}
 
 	@Override
-	@SuppressWarnings("UnnecessaryUnboxing")
 	public boolean remove(Object value) {
 		final Boolean exists = isPutQueueEnabled() ? readElementExistence( value ) : null;
 		if ( exists == null ) {
 			initialize( true );
 			if ( list.remove( value ) ) {
 				dirty();
 				return true;
 			}
 			else {
 				return false;
 			}
 		}
-		else if ( exists.booleanValue() ) {
+		else if ( exists ) {
 			queueOperation( new SimpleRemove( value ) );
 			return true;
 		}
 		else {
 			return false;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean containsAll(Collection coll) {
 		read();
 		return list.containsAll( coll );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean addAll(Collection values) {
 		if ( values.size()==0 ) {
 			return false;
 		}
 		if ( !isOperationQueueEnabled() ) {
 			write();
 			return list.addAll( values );
 		}
 		else {
 			for ( Object value : values ) {
 				queueOperation( new SimpleAdd( value ) );
 			}
 			return values.size()>0;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean addAll(int index, Collection coll) {
 		if ( coll.size()>0 ) {
 			write();
 			return list.addAll( index,  coll );
 		}
 		else {
 			return false;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean removeAll(Collection coll) {
 		if ( coll.size()>0 ) {
 			initialize( true );
 			if ( list.removeAll( coll ) ) {
 				dirty();
 				return true;
 			}
 			else {
 				return false;
 			}
 		}
 		else {
 			return false;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean retainAll(Collection coll) {
 		initialize( true );
 		if ( list.retainAll( coll ) ) {
 			dirty();
 			return true;
 		}
 		else {
 			return false;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public void clear() {
 		if ( isClearQueueEnabled() ) {
 			queueOperation( new Clear() );
 		}
 		else {
 			initialize( true );
 			if ( ! list.isEmpty() ) {
 				list.clear();
 				dirty();
 			}
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object get(int index) {
 		if ( index < 0 ) {
 			throw new ArrayIndexOutOfBoundsException( "negative index" );
 		}
 		final Object result = readElementByIndex( index );
 		return result == UNKNOWN ? list.get( index ) : result;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object set(int index, Object value) {
 		if (index<0) {
 			throw new ArrayIndexOutOfBoundsException("negative index");
 		}
 
 		final Object old = isPutQueueEnabled() ? readElementByIndex( index ) : UNKNOWN;
 
 		if ( old==UNKNOWN ) {
 			write();
 			return list.set( index, value );
 		}
 		else {
 			queueOperation( new Set( index, value, old ) );
 			return old;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object remove(int index) {
 		if ( index < 0 ) {
 			throw new ArrayIndexOutOfBoundsException( "negative index" );
 		}
 		final Object old = isPutQueueEnabled() ? readElementByIndex( index ) : UNKNOWN;
 		if ( old == UNKNOWN ) {
 			write();
 			return list.remove( index );
 		}
 		else {
 			queueOperation( new Remove( index, old ) );
 			return old;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public void add(int index, Object value) {
 		if ( index < 0 ) {
 			throw new ArrayIndexOutOfBoundsException( "negative index" );
 		}
 		if ( !isOperationQueueEnabled() ) {
 			write();
 			list.add( index, value );
 		}
 		else {
 			queueOperation( new Add( index, value ) );
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public int indexOf(Object value) {
 		read();
 		return list.indexOf( value );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public int lastIndexOf(Object value) {
 		read();
 		return list.lastIndexOf( value );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public ListIterator listIterator() {
 		read();
 		return new ListIteratorProxy( list.listIterator() );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public ListIterator listIterator(int index) {
 		read();
 		return new ListIteratorProxy( list.listIterator( index ) );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public java.util.List subList(int from, int to) {
 		read();
 		return new ListProxy( list.subList( from, to ) );
 	}
 
 	@Override
 	public boolean empty() {
 		return list.isEmpty();
 	}
 
 	@Override
 	public String toString() {
 		read();
 		return list.toString();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object readFrom(ResultSet rs, CollectionPersister persister, CollectionAliases descriptor, Object owner)
 			throws HibernateException, SQLException {
 		final Object element = persister.readElement( rs, owner, descriptor.getSuffixedElementAliases(), getSession() ) ;
 		final int index = (Integer) persister.readIndex( rs, descriptor.getSuffixedIndexAliases(), getSession() );
 
 		//pad with nulls from the current last element up to the new index
 		for ( int i = list.size(); i<=index; i++) {
 			list.add( i, null );
 		}
 
 		list.set( index, element );
 		return element;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Iterator entries(CollectionPersister persister) {
 		return list.iterator();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public void initializeFromCache(CollectionPersister persister, Serializable disassembled, Object owner)
 			throws HibernateException {
 		final Serializable[] array = (Serializable[]) disassembled;
 		final int size = array.length;
 		beforeInitialize( persister, size );
 		for ( Serializable arrayElement : array ) {
 			list.add( persister.getElementType().assemble( arrayElement, getSession(), owner ) );
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Serializable disassemble(CollectionPersister persister) throws HibernateException {
 		final int length = list.size();
 		final Serializable[] result = new Serializable[length];
 		for ( int i=0; i<length; i++ ) {
 			result[i] = persister.getElementType().disassemble( list.get( i ), getSession(), null );
 		}
 		return result;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Iterator getDeletes(CollectionPersister persister, boolean indexIsFormula) throws HibernateException {
 		final List deletes = new ArrayList();
 		final List sn = (List) getSnapshot();
 		int end;
 		if ( sn.size() > list.size() ) {
 			for ( int i=list.size(); i<sn.size(); i++ ) {
 				deletes.add( indexIsFormula ? sn.get( i ) : i );
 			}
 			end = list.size();
 		}
 		else {
 			end = sn.size();
 		}
 		for ( int i=0; i<end; i++ ) {
 			final Object item = list.get( i );
 			final Object snapshotItem = sn.get( i );
 			if ( item == null && snapshotItem != null ) {
 				deletes.add( indexIsFormula ? snapshotItem : i );
 			}
 		}
 		return deletes.iterator();
 	}
 
 	@Override
 	public boolean needsInserting(Object entry, int i, Type elemType) throws HibernateException {
 		final List sn = (List) getSnapshot();
 		return list.get( i ) != null && ( i >= sn.size() || sn.get( i ) == null );
 	}
 
 	@Override
 	public boolean needsUpdating(Object entry, int i, Type elemType) throws HibernateException {
 		final List sn = (List) getSnapshot();
 		return i < sn.size()
 				&& sn.get( i ) != null
 				&& list.get( i ) != null
 				&& elemType.isDirty( list.get( i ), sn.get( i ), getSession() );
 	}
 
 	@Override
 	public Object getIndex(Object entry, int i, CollectionPersister persister) {
 		return i;
 	}
 
 	@Override
 	public Object getElement(Object entry) {
 		return entry;
 	}
 
 	@Override
 	public Object getSnapshotElement(Object entry, int i) {
 		final List sn = (List) getSnapshot();
 		return sn.get( i );
 	}
 
 	@Override
 	@SuppressWarnings("EqualsWhichDoesntCheckParameterClass")
 	public boolean equals(Object other) {
 		read();
 		return list.equals( other );
 	}
 
 	@Override
 	public int hashCode() {
 		read();
 		return list.hashCode();
 	}
 
 	@Override
 	public boolean entryExists(Object entry, int i) {
 		return entry!=null;
 	}
 
 	final class Clear implements DelayedOperation {
 		@Override
 		public void operate() {
 			list.clear();
 		}
 
 		@Override
 		public Object getAddedInstance() {
 			return null;
 		}
 
 		@Override
 		public Object getOrphan() {
 			throw new UnsupportedOperationException( "queued clear cannot be used with orphan delete" );
 		}
 	}
 
 	final class SimpleAdd implements DelayedOperation {
 		private Object value;
 
 		public SimpleAdd(Object value) {
 			this.value = value;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public void operate() {
 			list.add( value );
 		}
 
 		@Override
 		public Object getAddedInstance() {
 			return value;
 		}
 
 		@Override
 		public Object getOrphan() {
 			return null;
 		}
 	}
 
 	final class Add implements DelayedOperation {
 		private int index;
 		private Object value;
 
 		public Add(int index, Object value) {
 			this.index = index;
 			this.value = value;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public void operate() {
 			list.add( index, value );
 		}
 
 		@Override
 		public Object getAddedInstance() {
 			return value;
 		}
 
 		@Override
 		public Object getOrphan() {
 			return null;
 		}
 	}
 
 	final class Set implements DelayedOperation {
 		private int index;
 		private Object value;
 		private Object old;
 
 		public Set(int index, Object value, Object old) {
 			this.index = index;
 			this.value = value;
 			this.old = old;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public void operate() {
 			list.set( index, value );
 		}
 
 		@Override
 		public Object getAddedInstance() {
 			return value;
 		}
 
 		@Override
 		public Object getOrphan() {
 			return old;
 		}
 	}
 
 	final class Remove implements DelayedOperation {
 		private int index;
 		private Object old;
 
 		public Remove(int index, Object old) {
 			this.index = index;
 			this.old = old;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public void operate() {
 			list.remove( index );
 		}
 
 		@Override
 		public Object getAddedInstance() {
 			return null;
 		}
 
 		@Override
 		public Object getOrphan() {
 			return old;
 		}
 	}
 
 	final class SimpleRemove implements DelayedOperation {
 		private Object value;
 
 		public SimpleRemove(Object value) {
 			this.value = value;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public void operate() {
 			list.remove( value );
 		}
 
 		@Override
 		public Object getAddedInstance() {
 			return null;
 		}
 
 		@Override
 		public Object getOrphan() {
 			return value;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentMap.java b/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentMap.java
index 3b1c141c85..88aa3cfc31 100644
--- a/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentMap.java
+++ b/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentMap.java
@@ -1,647 +1,645 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.collection.internal;
 
 import java.io.Serializable;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.loader.CollectionAliases;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.type.Type;
 
 
 /**
  * A persistent wrapper for a <tt>java.util.Map</tt>. Underlying collection
  * is a <tt>HashMap</tt>.
  *
  * @see java.util.HashMap
  * @author Gavin King
  */
 public class PersistentMap extends AbstractPersistentCollection implements Map {
 
 	protected Map map;
 
 	/**
 	 * Empty constructor.
 	 * <p/>
 	 * Note: this form is not ever ever ever used by Hibernate; it is, however,
 	 * needed for SOAP libraries and other such marshalling code.
 	 */
 	public PersistentMap() {
 		// intentionally empty
 	}
 
 	/**
 	 * Instantiates a lazy map (the underlying map is un-initialized).
 	 *
 	 * @param session The session to which this map will belong.
 	 */
 	public PersistentMap(SessionImplementor session) {
 		super( session );
 	}
 
 	/**
 	 * Instantiates a non-lazy map (the underlying map is constructed
 	 * from the incoming map reference).
 	 *
 	 * @param session The session to which this map will belong.
 	 * @param map The underlying map data.
 	 */
 	public PersistentMap(SessionImplementor session, Map map) {
 		super( session );
 		this.map = map;
 		setInitialized();
 		setDirectlyAccessible( true );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public Serializable getSnapshot(CollectionPersister persister) throws HibernateException {
 		final HashMap clonedMap = new HashMap( map.size() );
 		for ( Object o : map.entrySet() ) {
 			final Entry e = (Entry) o;
 			final Object copy = persister.getElementType().deepCopy( e.getValue(), persister.getFactory() );
 			clonedMap.put( e.getKey(), copy );
 		}
 		return clonedMap;
 	}
 
 	@Override
 	public Collection getOrphans(Serializable snapshot, String entityName) throws HibernateException {
 		final Map sn = (Map) snapshot;
 		return getOrphans( sn.values(), map.values(), entityName, getSession() );
 	}
 
 	@Override
 	public boolean equalsSnapshot(CollectionPersister persister) throws HibernateException {
 		final Type elementType = persister.getElementType();
 		final Map snapshotMap = (Map) getSnapshot();
 		if ( snapshotMap.size() != this.map.size() ) {
 			return false;
 		}
 
 		for ( Object o : map.entrySet() ) {
 			final Entry entry = (Entry) o;
 			if ( elementType.isDirty( entry.getValue(), snapshotMap.get( entry.getKey() ), getSession() ) ) {
 				return false;
 			}
 		}
 		return true;
 	}
 
 	@Override
 	public boolean isSnapshotEmpty(Serializable snapshot) {
 		return ( (Map) snapshot ).isEmpty();
 	}
 
 	@Override
 	public boolean isWrapper(Object collection) {
 		return map==collection;
 	}
 
 	@Override
 	public void beforeInitialize(CollectionPersister persister, int anticipatedSize) {
 		this.map = (Map) persister.getCollectionType().instantiate( anticipatedSize );
 	}
 
 	@Override
 	public int size() {
 		return readSize() ? getCachedSize() : map.size();
 	}
 
 	@Override
 	public boolean isEmpty() {
 		return readSize() ? getCachedSize()==0 : map.isEmpty();
 	}
 
 	@Override
-	@SuppressWarnings("UnnecessaryUnboxing")
 	public boolean containsKey(Object key) {
 		final Boolean exists = readIndexExistence( key );
-		return exists == null ? map.containsKey( key ) :  exists.booleanValue();
+		return exists == null ? map.containsKey( key ) : exists;
 	}
 
 	@Override
-	@SuppressWarnings("UnnecessaryUnboxing")
 	public boolean containsValue(Object value) {
 		final Boolean exists = readElementExistence( value );
 		return exists == null
 				? map.containsValue( value )
-				: exists.booleanValue();
+				: exists;
 	}
 
 	@Override
 	public Object get(Object key) {
 		final Object result = readElementByIndex( key );
 		return result == UNKNOWN
 				? map.get( key )
 				: result;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object put(Object key, Object value) {
 		if ( isPutQueueEnabled() ) {
 			final Object old = readElementByIndex( key );
 			if ( old != UNKNOWN ) {
 				queueOperation( new Put( key, value, old ) );
 				return old;
 			}
 		}
 		initialize( true );
 		final Object old = map.put( key, value );
 		// would be better to use the element-type to determine
 		// whether the old and the new are equal here; the problem being
 		// we do not necessarily have access to the element type in all
 		// cases
 		if ( value != old ) {
 			dirty();
 		}
 		return old;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object remove(Object key) {
 		if ( isPutQueueEnabled() ) {
 			final Object old = readElementByIndex( key );
 			if ( old != UNKNOWN ) {
 				queueOperation( new Remove( key, old ) );
 				return old;
 			}
 		}
 		// TODO : safe to interpret "map.remove(key) == null" as non-dirty?
 		initialize( true );
 		if ( map.containsKey( key ) ) {
 			dirty();
 		}
 		return map.remove( key );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public void putAll(Map puts) {
 		if ( puts.size() > 0 ) {
 			initialize( true );
 			for ( Object o : puts.entrySet() ) {
 				final Entry entry = (Entry) o;
 				put( entry.getKey(), entry.getValue() );
 			}
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public void clear() {
 		if ( isClearQueueEnabled() ) {
 			queueOperation( new Clear() );
 		}
 		else {
 			initialize( true );
 			if ( ! map.isEmpty() ) {
 				dirty();
 				map.clear();
 			}
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Set keySet() {
 		read();
 		return new SetProxy( map.keySet() );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Collection values() {
 		read();
 		return new SetProxy( map.values() );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Set entrySet() {
 		read();
 		return new EntrySetProxy( map.entrySet() );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean empty() {
 		return map.isEmpty();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public String toString() {
 		read();
 		return map.toString();
 	}
 
 	private transient List<Object[]> loadingEntries;
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object readFrom(
 			ResultSet rs,
 			CollectionPersister persister,
 			CollectionAliases descriptor,
 			Object owner) throws HibernateException, SQLException {
 		final Object element = persister.readElement( rs, owner, descriptor.getSuffixedElementAliases(), getSession() );
 		if ( element != null ) {
 			final Object index = persister.readIndex( rs, descriptor.getSuffixedIndexAliases(), getSession() );
 			if ( loadingEntries == null ) {
 				loadingEntries = new ArrayList<Object[]>();
 			}
 			loadingEntries.add( new Object[] { index, element } );
 		}
 		return element;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean endRead() {
 		if ( loadingEntries != null ) {
 			for ( Object[] entry : loadingEntries ) {
 				map.put( entry[0], entry[1] );
 			}
 			loadingEntries = null;
 		}
 		return super.endRead();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Iterator entries(CollectionPersister persister) {
 		return map.entrySet().iterator();
 	}
 
 	/**
 	 * a wrapper for Map.Entry sets
 	 */
 	class EntrySetProxy implements Set {
 		private final Set set;
 		EntrySetProxy(Set set) {
 			this.set=set;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public boolean add(Object entry) {
 			//write(); -- doesn't
 			return set.add( entry );
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public boolean addAll(Collection entries) {
 			//write(); -- doesn't
 			return set.addAll( entries );
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public void clear() {
 			write();
 			set.clear();
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public boolean contains(Object entry) {
 			return set.contains( entry );
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public boolean containsAll(Collection entries) {
 			return set.containsAll( entries );
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public boolean isEmpty() {
 			return set.isEmpty();
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public Iterator iterator() {
 			return new EntryIteratorProxy( set.iterator() );
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public boolean remove(Object entry) {
 			write();
 			return set.remove( entry );
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public boolean removeAll(Collection entries) {
 			write();
 			return set.removeAll( entries );
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public boolean retainAll(Collection entries) {
 			write();
 			return set.retainAll( entries );
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public int size() {
 			return set.size();
 		}
 
 		// amazingly, these two will work because AbstractCollection
 		// uses iterator() to fill the array
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public Object[] toArray() {
 			return set.toArray();
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public Object[] toArray(Object[] array) {
 			return set.toArray( array );
 		}
 	}
 
 	final class EntryIteratorProxy implements Iterator {
 		private final Iterator iter;
 		EntryIteratorProxy(Iterator iter) {
 			this.iter=iter;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public boolean hasNext() {
 			return iter.hasNext();
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public Object next() {
 			return new MapEntryProxy( (Map.Entry) iter.next() );
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public void remove() {
 			write();
 			iter.remove();
 		}
 	}
 
 	final class MapEntryProxy implements Map.Entry {
 		private final Map.Entry me;
 		MapEntryProxy( Map.Entry me ) {
 			this.me = me;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public Object getKey() {
 			return me.getKey();
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public Object getValue() {
 			return me.getValue();
 		}
 
 		@Override
 		@SuppressWarnings({"unchecked", "EqualsWhichDoesntCheckParameterClass"})
 		public boolean equals(Object o) {
 			return me.equals( o );
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public int hashCode() {
 			return me.hashCode();
 		}
 
 		// finally, what it's all about...
 		@Override
 		@SuppressWarnings("unchecked")
 		public Object setValue(Object value) {
 			write();
 			return me.setValue( value );
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public void initializeFromCache(CollectionPersister persister, Serializable disassembled, Object owner)
 			throws HibernateException {
 		final Serializable[] array = (Serializable[]) disassembled;
 		final int size = array.length;
 		beforeInitialize( persister, size );
 		for ( int i = 0; i < size; i+=2 ) {
 			map.put(
 					persister.getIndexType().assemble( array[i], getSession(), owner ),
 					persister.getElementType().assemble( array[i+1], getSession(), owner )
 			);
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Serializable disassemble(CollectionPersister persister) throws HibernateException {
 		final Serializable[] result = new Serializable[ map.size() * 2 ];
 		final Iterator itr = map.entrySet().iterator();
 		int i=0;
 		while ( itr.hasNext() ) {
 			final Map.Entry e = (Map.Entry) itr.next();
 			result[i++] = persister.getIndexType().disassemble( e.getKey(), getSession(), null );
 			result[i++] = persister.getElementType().disassemble( e.getValue(), getSession(), null );
 		}
 		return result;
 
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Iterator getDeletes(CollectionPersister persister, boolean indexIsFormula) throws HibernateException {
 		final List deletes = new ArrayList();
 		for ( Object o : ((Map) getSnapshot()).entrySet() ) {
 			final Entry e = (Entry) o;
 			final Object key = e.getKey();
 			if ( e.getValue() != null && map.get( key ) == null ) {
 				deletes.add( indexIsFormula ? e.getValue() : key );
 			}
 		}
 		return deletes.iterator();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean needsInserting(Object entry, int i, Type elemType) throws HibernateException {
 		final Map sn = (Map) getSnapshot();
 		final Map.Entry e = (Map.Entry) entry;
 		return e.getValue() != null && sn.get( e.getKey() ) == null;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean needsUpdating(Object entry, int i, Type elemType) throws HibernateException {
 		final Map sn = (Map) getSnapshot();
 		final Map.Entry e = (Map.Entry) entry;
 		final Object snValue = sn.get( e.getKey() );
 		return e.getValue() != null
 				&& snValue != null
 				&& elemType.isDirty( snValue, e.getValue(), getSession() );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object getIndex(Object entry, int i, CollectionPersister persister) {
 		return ( (Map.Entry) entry ).getKey();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object getElement(Object entry) {
 		return ( (Map.Entry) entry ).getValue();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object getSnapshotElement(Object entry, int i) {
 		final Map sn = (Map) getSnapshot();
 		return sn.get( ( (Map.Entry) entry ).getKey() );
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked", "EqualsWhichDoesntCheckParameterClass"})
 	public boolean equals(Object other) {
 		read();
 		return map.equals( other );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public int hashCode() {
 		read();
 		return map.hashCode();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean entryExists(Object entry, int i) {
 		return ( (Map.Entry) entry ).getValue() != null;
 	}
 
 	final class Clear implements DelayedOperation {
 		@Override
 		public void operate() {
 			map.clear();
 		}
 
 		@Override
 		public Object getAddedInstance() {
 			return null;
 		}
 
 		@Override
 		public Object getOrphan() {
 			throw new UnsupportedOperationException( "queued clear cannot be used with orphan delete" );
 		}
 	}
 
 	final class Put implements DelayedOperation {
 		private Object index;
 		private Object value;
 		private Object old;
 		
 		public Put(Object index, Object value, Object old) {
 			this.index = index;
 			this.value = value;
 			this.old = old;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public void operate() {
 			map.put( index, value );
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public Object getAddedInstance() {
 			return value;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public Object getOrphan() {
 			return old;
 		}
 	}
 
 	final class Remove implements DelayedOperation {
 		private Object index;
 		private Object old;
 		
 		public Remove(Object index, Object old) {
 			this.index = index;
 			this.old = old;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public void operate() {
 			map.remove( index );
 		}
 
 		@Override
 		public Object getAddedInstance() {
 			return null;
 		}
 
 		@Override
 		public Object getOrphan() {
 			return old;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentSet.java b/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentSet.java
index 331d840798..17dbe02be5 100644
--- a/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentSet.java
+++ b/hibernate-core/src/main/java/org/hibernate/collection/internal/PersistentSet.java
@@ -1,530 +1,527 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.collection.internal;
 
 import java.io.Serializable;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.loader.CollectionAliases;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.type.Type;
 
 
 /**
  * A persistent wrapper for a <tt>java.util.Set</tt>. The underlying
  * collection is a <tt>HashSet</tt>.
  *
  * @see java.util.HashSet
  * @author Gavin King
  */
 public class PersistentSet extends AbstractPersistentCollection implements java.util.Set {
 	protected Set set;
 	protected transient List tempList;
 
 	/**
 	 * Empty constructor.
 	 * <p/>
 	 * Note: this form is not ever ever ever used by Hibernate; it is, however,
 	 * needed for SOAP libraries and other such marshalling code.
 	 */
 	public PersistentSet() {
 		// intentionally empty
 	}
 
 	/**
 	 * Constructor matching super.  Instantiates a lazy set (the underlying
 	 * set is un-initialized).
 	 *
 	 * @param session The session to which this set will belong.
 	 */
 	public PersistentSet(SessionImplementor session) {
 		super( session );
 	}
 
 	/**
 	 * Instantiates a non-lazy set (the underlying set is constructed
 	 * from the incoming set reference).
 	 *
 	 * @param session The session to which this set will belong.
 	 * @param set The underlying set data.
 	 */
 	public PersistentSet(SessionImplementor session, java.util.Set set) {
 		super( session );
 		// Sets can be just a view of a part of another collection.
 		// do we need to copy it to be sure it won't be changing
 		// underneath us?
 		// ie. this.set.addAll(set);
 		this.set = set;
 		setInitialized();
 		setDirectlyAccessible( true );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public Serializable getSnapshot(CollectionPersister persister) throws HibernateException {
 		final HashMap clonedSet = new HashMap( set.size() );
 		for ( Object aSet : set ) {
 			final Object copied = persister.getElementType().deepCopy( aSet, persister.getFactory() );
 			clonedSet.put( copied, copied );
 		}
 		return clonedSet;
 	}
 
 	@Override
 	public Collection getOrphans(Serializable snapshot, String entityName) throws HibernateException {
 		final java.util.Map sn = (java.util.Map) snapshot;
 		return getOrphans( sn.keySet(), set, entityName, getSession() );
 	}
 
 	@Override
 	public boolean equalsSnapshot(CollectionPersister persister) throws HibernateException {
 		final Type elementType = persister.getElementType();
 		final java.util.Map sn = (java.util.Map) getSnapshot();
 		if ( sn.size()!=set.size() ) {
 			return false;
 		}
 		else {
 			for ( Object test : set ) {
 				final Object oldValue = sn.get( test );
 				if ( oldValue == null || elementType.isDirty( oldValue, test, getSession() ) ) {
 					return false;
 				}
 			}
 			return true;
 		}
 	}
 
 	@Override
 	public boolean isSnapshotEmpty(Serializable snapshot) {
 		return ( (java.util.Map) snapshot ).isEmpty();
 	}
 
 	@Override
 	public void beforeInitialize(CollectionPersister persister, int anticipatedSize) {
 		this.set = (Set) persister.getCollectionType().instantiate( anticipatedSize );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public void initializeFromCache(CollectionPersister persister, Serializable disassembled, Object owner)
 			throws HibernateException {
 		final Serializable[] array = (Serializable[]) disassembled;
 		final int size = array.length;
 		beforeInitialize( persister, size );
 		for ( Serializable arrayElement : array ) {
 			final Object assembledArrayElement = persister.getElementType().assemble( arrayElement, getSession(), owner );
 			if ( assembledArrayElement != null ) {
 				set.add( assembledArrayElement );
 			}
 		}
 	}
 
 	@Override
 	public boolean empty() {
 		return set.isEmpty();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public int size() {
 		return readSize() ? getCachedSize() : set.size();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean isEmpty() {
 		return readSize() ? getCachedSize()==0 : set.isEmpty();
 	}
 
 	@Override
-	@SuppressWarnings({"unchecked", "UnnecessaryUnboxing"})
 	public boolean contains(Object object) {
 		final Boolean exists = readElementExistence( object );
 		return exists == null
 				? set.contains( object )
-				: exists.booleanValue();
+				: exists;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Iterator iterator() {
 		read();
 		return new IteratorProxy( set.iterator() );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object[] toArray() {
 		read();
 		return set.toArray();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object[] toArray(Object[] array) {
 		read();
 		return set.toArray( array );
 	}
 
 	@Override
-	@SuppressWarnings({"unchecked", "UnnecessaryUnboxing"})
 	public boolean add(Object value) {
 		final Boolean exists = isOperationQueueEnabled() ? readElementExistence( value ) : null;
 		if ( exists == null ) {
 			initialize( true );
 			if ( set.add( value ) ) {
 				dirty();
 				return true;
 			}
 			else {
 				return false;
 			}
 		}
-		else if ( exists.booleanValue() ) {
+		else if ( exists ) {
 			return false;
 		}
 		else {
 			queueOperation( new SimpleAdd( value ) );
 			return true;
 		}
 	}
 
 	@Override
-	@SuppressWarnings({"unchecked", "UnnecessaryUnboxing"})
 	public boolean remove(Object value) {
 		final Boolean exists = isPutQueueEnabled() ? readElementExistence( value ) : null;
 		if ( exists == null ) {
 			initialize( true );
 			if ( set.remove( value ) ) {
 				dirty();
 				return true;
 			}
 			else {
 				return false;
 			}
 		}
-		else if ( exists.booleanValue() ) {
+		else if ( exists ) {
 			queueOperation( new SimpleRemove( value ) );
 			return true;
 		}
 		else {
 			return false;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean containsAll(Collection coll) {
 		read();
 		return set.containsAll( coll );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean addAll(Collection coll) {
 		if ( coll.size() > 0 ) {
 			initialize( true );
 			if ( set.addAll( coll ) ) {
 				dirty();
 				return true;
 			}
 			else {
 				return false;
 			}
 		}
 		else {
 			return false;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean retainAll(Collection coll) {
 		initialize( true );
 		if ( set.retainAll( coll ) ) {
 			dirty();
 			return true;
 		}
 		else {
 			return false;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean removeAll(Collection coll) {
 		if ( coll.size() > 0 ) {
 			initialize( true );
 			if ( set.removeAll( coll ) ) {
 				dirty();
 				return true;
 			}
 			else {
 				return false;
 			}
 		}
 		else {
 			return false;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public void clear() {
 		if ( isClearQueueEnabled() ) {
 			queueOperation( new Clear() );
 		}
 		else {
 			initialize( true );
 			if ( !set.isEmpty() ) {
 				set.clear();
 				dirty();
 			}
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public String toString() {
 		read();
 		return set.toString();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object readFrom(
 			ResultSet rs,
 			CollectionPersister persister,
 			CollectionAliases descriptor,
 			Object owner) throws HibernateException, SQLException {
 		final Object element = persister.readElement( rs, owner, descriptor.getSuffixedElementAliases(), getSession() );
 		if ( element != null ) {
 			tempList.add( element );
 		}
 		return element;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public void beginRead() {
 		super.beginRead();
 		tempList = new ArrayList();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean endRead() {
 		set.addAll( tempList );
 		tempList = null;
 		setInitialized();
 		return true;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Iterator entries(CollectionPersister persister) {
 		return set.iterator();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Serializable disassemble(CollectionPersister persister) throws HibernateException {
 		final Serializable[] result = new Serializable[ set.size() ];
 		final Iterator itr = set.iterator();
 		int i=0;
 		while ( itr.hasNext() ) {
 			result[i++] = persister.getElementType().disassemble( itr.next(), getSession(), null );
 		}
 		return result;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Iterator getDeletes(CollectionPersister persister, boolean indexIsFormula) throws HibernateException {
 		final Type elementType = persister.getElementType();
 		final java.util.Map sn = (java.util.Map) getSnapshot();
 		final ArrayList deletes = new ArrayList( sn.size() );
 
 		Iterator itr = sn.keySet().iterator();
 		while ( itr.hasNext() ) {
 			final Object test = itr.next();
 			if ( !set.contains( test ) ) {
 				// the element has been removed from the set
 				deletes.add( test );
 			}
 		}
 
 		itr = set.iterator();
 		while ( itr.hasNext() ) {
 			final Object test = itr.next();
 			final Object oldValue = sn.get( test );
 			if ( oldValue!=null && elementType.isDirty( test, oldValue, getSession() ) ) {
 				// the element has changed
 				deletes.add( oldValue );
 			}
 		}
 
 		return deletes.iterator();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean needsInserting(Object entry, int i, Type elemType) throws HibernateException {
 		final Object oldValue = ( (java.util.Map) getSnapshot() ).get( entry );
 		// note that it might be better to iterate the snapshot but this is safe,
 		// assuming the user implements equals() properly, as required by the Set
 		// contract!
 		return oldValue == null || elemType.isDirty( oldValue, entry, getSession() );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean needsUpdating(Object entry, int i, Type elemType) {
 		return false;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean isRowUpdatePossible() {
 		return false;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object getIndex(Object entry, int i, CollectionPersister persister) {
 		throw new UnsupportedOperationException("Sets don't have indexes");
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object getElement(Object entry) {
 		return entry;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Object getSnapshotElement(Object entry, int i) {
 		throw new UnsupportedOperationException("Sets don't support updating by element");
 	}
 
 	@Override
 	@SuppressWarnings({"unchecked", "EqualsWhichDoesntCheckParameterClass"})
 	public boolean equals(Object other) {
 		read();
 		return set.equals( other );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public int hashCode() {
 		read();
 		return set.hashCode();
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean entryExists(Object key, int i) {
 		return true;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public boolean isWrapper(Object collection) {
 		return set==collection;
 	}
 
 	final class Clear implements DelayedOperation {
 		@Override
 		public void operate() {
 			set.clear();
 		}
 
 		@Override
 		public Object getAddedInstance() {
 			return null;
 		}
 
 		@Override
 		public Object getOrphan() {
 			throw new UnsupportedOperationException("queued clear cannot be used with orphan delete");
 		}
 	}
 
 	final class SimpleAdd implements DelayedOperation {
 		private Object value;
 		
 		public SimpleAdd(Object value) {
 			this.value = value;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public void operate() {
 			set.add( value );
 		}
 
 		@Override
 		public Object getAddedInstance() {
 			return value;
 		}
 
 		@Override
 		public Object getOrphan() {
 			return null;
 		}
 	}
 
 	final class SimpleRemove implements DelayedOperation {
 		private Object value;
 		
 		public SimpleRemove(Object value) {
 			this.value = value;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public void operate() {
 			set.remove( value );
 		}
 
 		@Override
 		public Object getAddedInstance() {
 			return null;
 		}
 
 		@Override
 		public Object getOrphan() {
 			return value;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/DerbyDialect.java b/hibernate-core/src/main/java/org/hibernate/dialect/DerbyDialect.java
index e59662a49b..95740a318d 100755
--- a/hibernate-core/src/main/java/org/hibernate/dialect/DerbyDialect.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/DerbyDialect.java
@@ -1,261 +1,260 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect;
 
 import java.lang.reflect.Method;
 import java.sql.Types;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.MappingException;
 import org.hibernate.dialect.function.AnsiTrimFunction;
 import org.hibernate.dialect.function.DerbyConcatFunction;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.sql.CaseFragment;
 import org.hibernate.sql.DerbyCaseFragment;
 
 /**
  * Hibernate Dialect for Cloudscape 10 - aka Derby. This implements both an
  * override for the identity column generator as well as for the case statement
  * issue documented at:
  * http://www.jroller.com/comments/kenlars99/Weblog/cloudscape_soon_to_be_derby
  *
  * @author Simon Johnston
  *
  * @deprecated HHH-6073
  */
 @Deprecated
 public class DerbyDialect extends DB2Dialect {
 	@SuppressWarnings("deprecation")
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			DerbyDialect.class.getName()
 	);
 
 	private int driverVersionMajor;
 	private int driverVersionMinor;
 
 	/**
 	 * Constructs a DerbyDialect
 	 */
 	@SuppressWarnings("deprecation")
 	public DerbyDialect() {
 		super();
 		if ( this.getClass() == DerbyDialect.class ) {
 			LOG.deprecatedDerbyDialect();
 		}
 
 		registerFunction( "concat", new DerbyConcatFunction() );
 		registerFunction( "trim", new AnsiTrimFunction() );
 		registerColumnType( Types.BLOB, "blob" );
 		determineDriverVersion();
 
 		if ( driverVersionMajor > 10 || ( driverVersionMajor == 10 && driverVersionMinor >= 7 ) ) {
 			registerColumnType( Types.BOOLEAN, "boolean" );
 		}
 	}
 
-	@SuppressWarnings({"UnnecessaryUnboxing", "unchecked"})
 	private void determineDriverVersion() {
 		try {
 			// locate the derby sysinfo class and query its version info
 			final Class sysinfoClass = ReflectHelper.classForName( "org.apache.derby.tools.sysinfo", this.getClass() );
 			final Method majorVersionGetter = sysinfoClass.getMethod( "getMajorVersion", ReflectHelper.NO_PARAM_SIGNATURE );
 			final Method minorVersionGetter = sysinfoClass.getMethod( "getMinorVersion", ReflectHelper.NO_PARAM_SIGNATURE );
-			driverVersionMajor = ( (Integer) majorVersionGetter.invoke( null, ReflectHelper.NO_PARAMS ) ).intValue();
-			driverVersionMinor = ( (Integer) minorVersionGetter.invoke( null, ReflectHelper.NO_PARAMS ) ).intValue();
+			driverVersionMajor = (Integer) majorVersionGetter.invoke( null, ReflectHelper.NO_PARAMS );
+			driverVersionMinor = (Integer) minorVersionGetter.invoke( null, ReflectHelper.NO_PARAMS );
 		}
 		catch ( Exception e ) {
 			LOG.unableToLoadDerbyDriver( e.getMessage() );
 			driverVersionMajor = -1;
 			driverVersionMinor = -1;
 		}
 	}
 
 	private boolean isTenPointFiveReleaseOrNewer() {
 		return driverVersionMajor > 10 || ( driverVersionMajor == 10 && driverVersionMinor >= 5 );
 	}
 
 	@Override
 	public String getCrossJoinSeparator() {
 		return ", ";
 	}
 
 	@Override
 	public CaseFragment createCaseFragment() {
 		return new DerbyCaseFragment();
 	}
 
 	@Override
 	public boolean dropConstraints() {
 		return true;
 	}
 
 	@Override
 	public boolean supportsSequences() {
 		// technically sequence support was added in 10.6.1.0...
 		//
 		// The problem though is that I am not exactly sure how to differentiate 10.6.1.0 from any other 10.6.x release.
 		//
 		// http://db.apache.org/derby/docs/10.0/publishedapi/org/apache/derby/tools/sysinfo.html seems incorrect.  It
 		// states that derby's versioning scheme is major.minor.maintenance, but obviously 10.6.1.0 has 4 components
 		// to it, not 3.
 		//
 		// Let alone the fact that it states that versions with the matching major.minor are 'feature
 		// compatible' which is clearly not the case here (sequence support is a new feature...)
 		return driverVersionMajor > 10 || ( driverVersionMajor == 10 && driverVersionMinor >= 6 );
 	}
 
 	@Override
 	public String getSequenceNextValString(String sequenceName) {
 		if ( supportsSequences() ) {
 			return "values next value for " + sequenceName;
 		}
 		else {
 			throw new MappingException( "Derby does not support sequence prior to release 10.6.1.0" );
 		}
 	}
 
 	@Override
 	public boolean supportsLimit() {
 		return isTenPointFiveReleaseOrNewer();
 	}
 
 	@Override
 	public boolean supportsCommentOn() {
 		//HHH-4531
 		return false;
 	}
 
 	@Override
 	@SuppressWarnings("deprecation")
 	public boolean supportsLimitOffset() {
 		return isTenPointFiveReleaseOrNewer();
 	}
 
 	@Override
 	public String getForUpdateString() {
 		return " for update with rs";
 	}
 
 	@Override
 	public String getWriteLockString(int timeout) {
 		return " for update with rs";
 	}
 
 	@Override
 	public String getReadLockString(int timeout) {
 		return " for read only with rs";
 	}
 
 
 	/**
 	 * {@inheritDoc}
 	 * <p/>
 	 * From Derby 10.5 Docs:
 	 * <pre>
 	 * Query
 	 * [ORDER BY clause]
 	 * [result offset clause]
 	 * [fetch first clause]
 	 * [FOR UPDATE clause]
 	 * [WITH {RR|RS|CS|UR}]
 	 * </pre>
 	 */
 	@Override
 	public String getLimitString(String query, final int offset, final int limit) {
 		final StringBuilder sb = new StringBuilder(query.length() + 50);
 		final String normalizedSelect = query.toLowerCase().trim();
 		final int forUpdateIndex = normalizedSelect.lastIndexOf( "for update") ;
 
 		if ( hasForUpdateClause( forUpdateIndex ) ) {
 			sb.append( query.substring( 0, forUpdateIndex-1 ) );
 		}
 		else if ( hasWithClause( normalizedSelect ) ) {
 			sb.append( query.substring( 0, getWithIndex( query ) - 1 ) );
 		}
 		else {
 			sb.append( query );
 		}
 
 		if ( offset == 0 ) {
 			sb.append( " fetch first " );
 		}
 		else {
 			sb.append( " offset " ).append( offset ).append( " rows fetch next " );
 		}
 
 		sb.append( limit ).append( " rows only" );
 
 		if ( hasForUpdateClause( forUpdateIndex ) ) {
 			sb.append( ' ' );
 			sb.append( query.substring( forUpdateIndex ) );
 		}
 		else if ( hasWithClause( normalizedSelect ) ) {
 			sb.append( ' ' ).append( query.substring( getWithIndex( query ) ) );
 		}
 		return sb.toString();
 	}
 
 	@Override
 	public boolean supportsVariableLimit() {
 		// we bind the limit and offset values directly into the sql...
 		return false;
 	}
 
 	private boolean hasForUpdateClause(int forUpdateIndex) {
 		return forUpdateIndex >= 0;
 	}
 
 	private boolean hasWithClause(String normalizedSelect){
 		return normalizedSelect.startsWith( "with ", normalizedSelect.length()-7 );
 	}
 
 	private int getWithIndex(String querySelect) {
 		int i = querySelect.lastIndexOf( "with " );
 		if ( i < 0 ) {
 			i = querySelect.lastIndexOf( "WITH " );
 		}
 		return i;
 	}
 
 	@Override
 	public String getQuerySequencesString() {
 		return null ;
 	}
 
 
 	// Overridden informational metadata ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Override
 	public boolean supportsLobValueChangePropogation() {
 		return false;
 	}
 
 	@Override
 	public boolean supportsUnboundedLobLocatorMaterialization() {
 		return false;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/dialect/function/TemplateRenderer.java b/hibernate-core/src/main/java/org/hibernate/dialect/function/TemplateRenderer.java
index b9c7ba7129..ce862cc1e4 100644
--- a/hibernate-core/src/main/java/org/hibernate/dialect/function/TemplateRenderer.java
+++ b/hibernate-core/src/main/java/org/hibernate/dialect/function/TemplateRenderer.java
@@ -1,138 +1,137 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect.function;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 
 /**
  * Delegate for handling function "templates".
  *
  * @author Steve Ebersole
  */
 public class TemplateRenderer {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			TemplateRenderer.class.getName()
 	);
 
 	private final String template;
 	private final String[] chunks;
 	private final int[] paramIndexes;
 
 	/**
 	 * Constructs a template renderer
 	 *
 	 * @param template The template
 	 */
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
 	public TemplateRenderer(String template) {
 		this.template = template;
 
 		final List<String> chunkList = new ArrayList<String>();
 		final List<Integer> paramList = new ArrayList<Integer>();
 		final StringBuilder chunk = new StringBuilder( 10 );
 		final StringBuilder index = new StringBuilder( 2 );
 
 		int i = 0;
 		final int len = template.length();
 		while ( i < len ) {
 			char c = template.charAt( i );
 			if ( c == '?' ) {
 				chunkList.add( chunk.toString() );
 				chunk.delete( 0, chunk.length() );
 
 				while ( ++i < template.length() ) {
 					c = template.charAt( i );
 					if ( Character.isDigit( c ) ) {
 						index.append( c );
 					}
 					else {
 						chunk.append( c );
 						break;
 					}
 				}
 
 				paramList.add( Integer.valueOf( index.toString() ) );
 				index.delete( 0, index.length() );
 			}
 			else {
 				chunk.append( c );
 			}
 			i++;
 		}
 
 		if ( chunk.length() > 0 ) {
 			chunkList.add( chunk.toString() );
 		}
 
 		chunks = chunkList.toArray( new String[chunkList.size()] );
 		paramIndexes = new int[paramList.size()];
 		for ( i = 0; i < paramIndexes.length; ++i ) {
 			paramIndexes[i] = paramList.get( i );
 		}
 	}
 
 	public String getTemplate() {
 		return template;
 	}
 
 	public int getAnticipatedNumberOfArguments() {
 		return paramIndexes.length;
 	}
 
 	/**
 	 * The rendering code.
 	 *
 	 * @param args The arguments to inject into the template
 	 * @param factory The SessionFactory
 	 *
 	 * @return The rendered template with replacements
 	 */
 	@SuppressWarnings({ "UnusedDeclaration" })
 	public String render(List args, SessionFactoryImplementor factory) {
 		final int numberOfArguments = args.size();
 		if ( getAnticipatedNumberOfArguments() > 0 && numberOfArguments != getAnticipatedNumberOfArguments() ) {
 			LOG.missingArguments( getAnticipatedNumberOfArguments(), numberOfArguments );
 		}
 		final StringBuilder buf = new StringBuilder();
 		for ( int i = 0; i < chunks.length; ++i ) {
 			if ( i < paramIndexes.length ) {
 				final int index = paramIndexes[i] - 1;
 				final Object arg =  index < numberOfArguments ? args.get( index ) : null;
 				if ( arg != null ) {
 					buf.append( chunks[i] ).append( arg );
 				}
 			}
 			else {
 				buf.append( chunks[i] );
 			}
 		}
 		return buf.toString();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/internal/ForeignKeys.java b/hibernate-core/src/main/java/org/hibernate/engine/internal/ForeignKeys.java
index d60257e146..2d15ab1f29 100755
--- a/hibernate-core/src/main/java/org/hibernate/engine/internal/ForeignKeys.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/internal/ForeignKeys.java
@@ -1,401 +1,400 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.internal;
 
 import java.io.Serializable;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.TransientObjectException;
 import org.hibernate.bytecode.instrumentation.spi.LazyPropertyInitializer;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.LazyInitializer;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 /**
  * Algorithms related to foreign key constraint transparency
  *
  * @author Gavin King
  */
 public final class ForeignKeys {
 
 	/**
 	 * Delegate for handling nullifying ("null"ing-out) non-cascaded associations
 	 */
 	public static class Nullifier {
 		private final boolean isDelete;
 		private final boolean isEarlyInsert;
 		private final SessionImplementor session;
 		private final Object self;
 
 		/**
 		 * Constructs a Nullifier
 		 *
 		 * @param self The entity
 		 * @param isDelete Are we in the middle of a delete action?
 		 * @param isEarlyInsert Is this an early insert (INSERT generated id strategy)?
 		 * @param session The session
 		 */
 		public Nullifier(Object self, boolean isDelete, boolean isEarlyInsert, SessionImplementor session) {
 			this.isDelete = isDelete;
 			this.isEarlyInsert = isEarlyInsert;
 			this.session = session;
 			this.self = self;
 		}
 
 		/**
 		 * Nullify all references to entities that have not yet been inserted in the database, where the foreign key
 		 * points toward that entity.
 		 *
 		 * @param values The entity attribute values
 		 * @param types The entity attribute types
 		 */
 		public void nullifyTransientReferences(final Object[] values, final Type[] types) {
 			for ( int i = 0; i < types.length; i++ ) {
 				values[i] = nullifyTransientReferences( values[i], types[i] );
 			}
 		}
 
 		/**
 		 * Return null if the argument is an "unsaved" entity (ie. one with no existing database row), or the
 		 * input argument otherwise.  This is how Hibernate avoids foreign key constraint violations.
 		 *
 		 * @param value An entity attribute value
 		 * @param type An entity attribute type
 		 *
 		 * @return {@code null} if the argument is an unsaved entity; otherwise return the argument.
 		 */
 		private Object nullifyTransientReferences(final Object value, final Type type) {
 			if ( value == null ) {
 				return null;
 			}
 			else if ( type.isEntityType() ) {
 				final EntityType entityType = (EntityType) type;
 				if ( entityType.isOneToOne() ) {
 					return value;
 				}
 				else {
 					final String entityName = entityType.getAssociatedEntityName();
 					return isNullifiable( entityName, value ) ? null : value;
 				}
 			}
 			else if ( type.isAnyType() ) {
 				return isNullifiable( null, value ) ? null : value;
 			}
 			else if ( type.isComponentType() ) {
 				final CompositeType actype = (CompositeType) type;
 				final Object[] subvalues = actype.getPropertyValues( value, session );
 				final Type[] subtypes = actype.getSubtypes();
 				boolean substitute = false;
 				for ( int i = 0; i < subvalues.length; i++ ) {
 					final Object replacement = nullifyTransientReferences( subvalues[i], subtypes[i] );
 					if ( replacement != subvalues[i] ) {
 						substitute = true;
 						subvalues[i] = replacement;
 					}
 				}
 				if ( substitute ) {
 					// todo : need to account for entity mode on the CompositeType interface :(
 					actype.setPropertyValues( value, subvalues, EntityMode.POJO );
 				}
 				return value;
 			}
 			else {
 				return value;
 			}
 		}
 
 		/**
 		 * Determine if the object already exists in the database,
 		 * using a "best guess"
 		 *
 		 * @param entityName The name of the entity
 		 * @param object The entity instance
 		 */
 		private boolean isNullifiable(final String entityName, Object object)
 				throws HibernateException {
 			if ( object == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {
 				// this is the best we can do...
 				return false;
 			}
 
 			if ( object instanceof HibernateProxy ) {
 				// if its an uninitialized proxy it can't be transient
 				final LazyInitializer li = ( (HibernateProxy) object ).getHibernateLazyInitializer();
 				if ( li.getImplementation( session ) == null ) {
 					return false;
 					// ie. we never have to null out a reference to
 					// an uninitialized proxy
 				}
 				else {
 					//unwrap it
 					object = li.getImplementation();
 				}
 			}
 
 			// if it was a reference to self, don't need to nullify
 			// unless we are using native id generation, in which
 			// case we definitely need to nullify
 			if ( object == self ) {
 				return isEarlyInsert
 						|| ( isDelete && session.getFactory().getDialect().hasSelfReferentialForeignKeyBug() );
 			}
 
 			// See if the entity is already bound to this session, if not look at the
 			// entity identifier and assume that the entity is persistent if the
 			// id is not "unsaved" (that is, we rely on foreign keys to keep
 			// database integrity)
 
 			final EntityEntry entityEntry = session.getPersistenceContext().getEntry( object );
 			if ( entityEntry == null ) {
 				return isTransient( entityName, object, null, session );
 			}
 			else {
 				return entityEntry.isNullifiable( isEarlyInsert, session );
 			}
 
 		}
 
 	}
 
 	/**
 	 * Is this instance persistent or detached?
 	 * <p/>
 	 * If <tt>assumed</tt> is non-null, don't hit the database to make the determination, instead assume that
 	 * value; the client code must be prepared to "recover" in the case that this assumed result is incorrect.
 	 *
 	 * @param entityName The name of the entity
 	 * @param entity The entity instance
 	 * @param assumed The assumed return value, if avoiding database hit is desired
 	 * @param session The session
 	 *
 	 * @return {@code true} if the given entity is not transient (meaning it is either detached/persistent)
 	 */
 	@SuppressWarnings("SimplifiableIfStatement")
 	public static boolean isNotTransient(String entityName, Object entity, Boolean assumed, SessionImplementor session) {
 		if ( entity instanceof HibernateProxy ) {
 			return true;
 		}
 
 		if ( session.getPersistenceContext().isEntryFor( entity ) ) {
 			return true;
 		}
 
 		// todo : shouldnt assumed be revered here?
 
 		return !isTransient( entityName, entity, assumed, session );
 	}
 
 	/**
 	 * Is this instance, which we know is not persistent, actually transient?
 	 * <p/>
 	 * If <tt>assumed</tt> is non-null, don't hit the database to make the determination, instead assume that
 	 * value; the client code must be prepared to "recover" in the case that this assumed result is incorrect.
 	 *
 	 * @param entityName The name of the entity
 	 * @param entity The entity instance
 	 * @param assumed The assumed return value, if avoiding database hit is desired
 	 * @param session The session
 	 *
 	 * @return {@code true} if the given entity is transient (unsaved)
 	 */
-	@SuppressWarnings("UnnecessaryUnboxing")
 	public static boolean isTransient(String entityName, Object entity, Boolean assumed, SessionImplementor session) {
 		if ( entity == LazyPropertyInitializer.UNFETCHED_PROPERTY ) {
 			// an unfetched association can only point to
 			// an entity that already exists in the db
 			return false;
 		}
 
 		// let the interceptor inspect the instance to decide
 		Boolean isUnsaved = session.getInterceptor().isTransient( entity );
 		if ( isUnsaved != null ) {
-			return isUnsaved.booleanValue();
+			return isUnsaved;
 		}
 
 		// let the persister inspect the instance to decide
 		final EntityPersister persister = session.getEntityPersister( entityName, entity );
 		isUnsaved = persister.isTransient( entity, session );
 		if ( isUnsaved != null ) {
-			return isUnsaved.booleanValue();
+			return isUnsaved;
 		}
 
 		// we use the assumed value, if there is one, to avoid hitting
 		// the database
 		if ( assumed != null ) {
-			return assumed.booleanValue();
+			return assumed;
 		}
 
 		// hit the database, after checking the session cache for a snapshot
 		final Object[] snapshot = session.getPersistenceContext().getDatabaseSnapshot(
 				persister.getIdentifier( entity, session ),
 				persister
 		);
 		return snapshot == null;
 
 	}
 
 	/**
 	 * Return the identifier of the persistent or transient object, or throw
 	 * an exception if the instance is "unsaved"
 	 * <p/>
 	 * Used by OneToOneType and ManyToOneType to determine what id value should
 	 * be used for an object that may or may not be associated with the session.
 	 * This does a "best guess" using any/all info available to use (not just the
 	 * EntityEntry).
 	 *
 	 * @param entityName The name of the entity
 	 * @param object The entity instance
 	 * @param session The session
 	 *
 	 * @return The identifier
 	 *
 	 * @throws TransientObjectException if the entity is transient (does not yet have an identifier)
 	 */
 	public static Serializable getEntityIdentifierIfNotUnsaved(
 			final String entityName,
 			final Object object,
 			final SessionImplementor session) throws TransientObjectException {
 		if ( object == null ) {
 			return null;
 		}
 		else {
 			Serializable id = session.getContextEntityIdentifier( object );
 			if ( id == null ) {
 				// context-entity-identifier returns null explicitly if the entity
 				// is not associated with the persistence context; so make some
 				// deeper checks...
 				if ( isTransient( entityName, object, Boolean.FALSE, session ) ) {
 					throw new TransientObjectException(
 							"object references an unsaved transient instance - save the transient instance before flushing: " +
 									(entityName == null ? session.guessEntityName( object ) : entityName)
 					);
 				}
 				id = session.getEntityPersister( entityName, object ).getIdentifier( object, session );
 			}
 			return id;
 		}
 	}
 
 	/**
 	 * Find all non-nullable references to entities that have not yet
 	 * been inserted in the database, where the foreign key
 	 * is a reference to an unsaved transient entity. .
 	 *
 	 * @param entityName - the entity name
 	 * @param entity - the entity instance
 	 * @param values - insertable properties of the object (including backrefs),
 	 * possibly with substitutions
 	 * @param isEarlyInsert - true if the entity needs to be executed as soon as possible
 	 * (e.g., to generate an ID)
 	 * @param session - the session
 	 *
 	 * @return the transient unsaved entity dependencies that are non-nullable,
 	 *         or null if there are none.
 	 */
 	public static NonNullableTransientDependencies findNonNullableTransientEntities(
 			String entityName,
 			Object entity,
 			Object[] values,
 			boolean isEarlyInsert,
 			SessionImplementor session) {
 		final Nullifier nullifier = new Nullifier( entity, false, isEarlyInsert, session );
 		final EntityPersister persister = session.getEntityPersister( entityName, entity );
 		final String[] propertyNames = persister.getPropertyNames();
 		final Type[] types = persister.getPropertyTypes();
 		final boolean[] nullability = persister.getPropertyNullability();
 		final NonNullableTransientDependencies nonNullableTransientEntities = new NonNullableTransientDependencies();
 		for ( int i = 0; i < types.length; i++ ) {
 			collectNonNullableTransientEntities(
 					nullifier,
 					values[i],
 					propertyNames[i],
 					types[i],
 					nullability[i],
 					session,
 					nonNullableTransientEntities
 			);
 		}
 		return nonNullableTransientEntities.isEmpty() ? null : nonNullableTransientEntities;
 	}
 
 	private static void collectNonNullableTransientEntities(
 			Nullifier nullifier,
 			Object value,
 			String propertyName,
 			Type type,
 			boolean isNullable,
 			SessionImplementor session,
 			NonNullableTransientDependencies nonNullableTransientEntities) {
 		if ( value == null ) {
 			return;
 		}
 
 		if ( type.isEntityType() ) {
 			final EntityType entityType = (EntityType) type;
 			if ( !isNullable
 					&& !entityType.isOneToOne()
 					&& nullifier.isNullifiable( entityType.getAssociatedEntityName(), value ) ) {
 				nonNullableTransientEntities.add( propertyName, value );
 			}
 		}
 		else if ( type.isAnyType() ) {
 			if ( !isNullable && nullifier.isNullifiable( null, value ) ) {
 				nonNullableTransientEntities.add( propertyName, value );
 			}
 		}
 		else if ( type.isComponentType() ) {
 			final CompositeType actype = (CompositeType) type;
 			final boolean[] subValueNullability = actype.getPropertyNullability();
 			if ( subValueNullability != null ) {
 				final String[] subPropertyNames = actype.getPropertyNames();
 				final Object[] subvalues = actype.getPropertyValues( value, session );
 				final Type[] subtypes = actype.getSubtypes();
 				for ( int j = 0; j < subvalues.length; j++ ) {
 					collectNonNullableTransientEntities(
 							nullifier,
 							subvalues[j],
 							subPropertyNames[j],
 							subtypes[j],
 							subValueNullability[j],
 							session,
 							nonNullableTransientEntities
 					);
 				}
 			}
 		}
 	}
 
 	/**
 	 * Disallow instantiation
 	 */
 	private ForeignKeys() {
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/BlobProxy.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/BlobProxy.java
index 102185cbd9..8dfef951a4 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/BlobProxy.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/BlobProxy.java
@@ -1,244 +1,243 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009 by Red Hat Inc and/or its affiliates or by
  * third-party contributors as indicated by either @author tags or express
  * copyright attribution statements applied by the authors.  All
  * third-party contributions are distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.sql.Blob;
 import java.sql.SQLException;
 
 import org.hibernate.engine.jdbc.internal.BinaryStreamImpl;
 import org.hibernate.internal.util.ClassLoaderHelper;
 import org.hibernate.type.descriptor.java.DataHelper;
 
 /**
  * Manages aspects of proxying {@link Blob} references for non-contextual creation, including proxy creation and
  * handling proxy invocations.  We use proxies here solely to avoid JDBC version incompatibilities.
  *
  * @author Gavin King
  * @author Steve Ebersole
  * @author Gail Badner
  */
 public class BlobProxy implements InvocationHandler {
 	private static final Class[] PROXY_INTERFACES = new Class[] { Blob.class, BlobImplementer.class };
 
 	private BinaryStream binaryStream;
 	private boolean needsReset;
 
 	/**
 	 * Constructor used to build {@link Blob} from byte array.
 	 *
 	 * @param bytes The byte array
 	 * @see #generateProxy(byte[])
 	 */
 	private BlobProxy(byte[] bytes) {
 		binaryStream = new BinaryStreamImpl( bytes );
 	}
 
 	/**
 	 * Constructor used to build {@link Blob} from a stream.
 	 *
 	 * @param stream The binary stream
 	 * @param length The length of the stream
 	 * @see #generateProxy(java.io.InputStream, long)
 	 */
 	private BlobProxy(InputStream stream, long length) {
 		this.binaryStream = new StreamBackedBinaryStream( stream, length );
 	}
 
 	private long getLength() {
 		return binaryStream.getLength();
 	}
 
 	private InputStream getStream() throws SQLException {
 		return getUnderlyingStream().getInputStream();
 	}
 
 	private BinaryStream getUnderlyingStream() throws SQLException {
 		resetIfNeeded();
 		return binaryStream;
 	}
 
 	private void resetIfNeeded() throws SQLException {
 		try {
 			if ( needsReset ) {
 				binaryStream.getInputStream().reset();
 			}
 		}
 		catch ( IOException ioe) {
 			throw new SQLException("could not reset reader");
 		}
 		needsReset = true;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 *
 	 * @throws UnsupportedOperationException if any methods other than
 	 * {@link Blob#length}, {@link BlobImplementer#getUnderlyingStream},
 	 * {@link Blob#getBinaryStream}, {@link Blob#getBytes}, {@link Blob#free},
 	 * or toString/equals/hashCode are invoked.
 	 */
 	@Override
-	@SuppressWarnings({ "UnnecessaryBoxing" })
 	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 		final String methodName = method.getName();
 		final int argCount = method.getParameterTypes().length;
 
 		if ( "length".equals( methodName ) && argCount == 0 ) {
-			return Long.valueOf( getLength() );
+			return getLength();
 		}
 		if ( "getUnderlyingStream".equals( methodName ) ) {
 			return getUnderlyingStream(); // Reset stream if needed.
 		}
 		if ( "getBinaryStream".equals( methodName ) ) {
 			if ( argCount == 0 ) {
 				return getStream();
 			}
 			else if ( argCount == 2 ) {
 				final long start = (Long) args[0];
 				if ( start < 1 ) {
 					throw new SQLException( "Start position 1-based; must be 1 or more." );
 				}
 				if ( start > getLength() ) {
 					throw new SQLException( "Start position [" + start + "] cannot exceed overall CLOB length [" + getLength() + "]" );
 				}
 				final int length = (Integer) args[1];
 				if ( length < 0 ) {
 					// java docs specifically say for getBinaryStream(long,int) that the start+length must not exceed the
 					// total length, however that is at odds with the getBytes(long,int) behavior.
 					throw new SQLException( "Length must be great-than-or-equal to zero." );
 				}
 				return DataHelper.subStream( getStream(), start-1, length );
 			}
 		}
 		if ( "getBytes".equals( methodName ) ) {
 			if ( argCount == 2 ) {
 				final long start = (Long) args[0];
 				if ( start < 1 ) {
 					throw new SQLException( "Start position 1-based; must be 1 or more." );
 				}
 				final int length = (Integer) args[1];
 				if ( length < 0 ) {
 					throw new SQLException( "Length must be great-than-or-equal to zero." );
 				}
 				return DataHelper.extractBytes( getStream(), start-1, length );
 			}
 		}
 		if ( "free".equals( methodName ) && argCount == 0 ) {
 			binaryStream.release();
 			return null;
 		}
 		if ( "toString".equals( methodName ) && argCount == 0 ) {
 			return this.toString();
 		}
 		if ( "equals".equals( methodName ) && argCount == 1 ) {
-			return Boolean.valueOf( proxy == args[0] );
+			return proxy == args[0];
 		}
 		if ( "hashCode".equals( methodName ) && argCount == 0 ) {
 			return this.hashCode();
 		}
 
 		throw new UnsupportedOperationException( "Blob may not be manipulated from creating session" );
 	}
 
 	/**
 	 * Generates a BlobImpl proxy using byte data.
 	 *
 	 * @param bytes The data to be created as a Blob.
 	 *
 	 * @return The generated proxy.
 	 */
 	public static Blob generateProxy(byte[] bytes) {
 		return (Blob) Proxy.newProxyInstance( getProxyClassLoader(), PROXY_INTERFACES, new BlobProxy( bytes ) );
 	}
 
 	/**
 	 * Generates a BlobImpl proxy using a given number of bytes from an InputStream.
 	 *
 	 * @param stream The input stream of bytes to be created as a Blob.
 	 * @param length The number of bytes from stream to be written to the Blob.
 	 *
 	 * @return The generated proxy.
 	 */
 	public static Blob generateProxy(InputStream stream, long length) {
 		return (Blob) Proxy.newProxyInstance( getProxyClassLoader(), PROXY_INTERFACES, new BlobProxy( stream, length ) );
 	}
 
 	/**
 	 * Determines the appropriate class loader to which the generated proxy
 	 * should be scoped.
 	 *
 	 * @return The class loader appropriate for proxy construction.
 	 */
 	private static ClassLoader getProxyClassLoader() {
 		ClassLoader cl = ClassLoaderHelper.getContextClassLoader();
 		if ( cl == null ) {
 			cl = BlobImplementer.class.getClassLoader();
 		}
 		return cl;
 	}
 
 	private static class StreamBackedBinaryStream implements BinaryStream {
 		private final InputStream stream;
 		private final long length;
 
 		private byte[] bytes;
 
 		private StreamBackedBinaryStream(InputStream stream, long length) {
 			this.stream = stream;
 			this.length = length;
 		}
 
 		@Override
 		public InputStream getInputStream() {
 			return stream;
 		}
 
 		@Override
 		public byte[] getBytes() {
 			if ( bytes == null ) {
 				bytes = DataHelper.extractBytes( stream );
 			}
 			return bytes;
 		}
 
 		@Override
 		public long getLength() {
 			return (int) length;
 		}
 
 		@Override
 		public void release() {
 			try {
 				stream.close();
 			}
 			catch (IOException ignore) {
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/ClobProxy.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/ClobProxy.java
index d693eb80e7..f1c0a54ed4 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/ClobProxy.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/ClobProxy.java
@@ -1,221 +1,220 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009 by Red Hat Inc and/or its affiliates or by
  * third-party contributors as indicated by either @author tags or express
  * copyright attribution statements applied by the authors.  All
  * third-party contributions are distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.Reader;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.sql.Clob;
 import java.sql.SQLException;
 
 import org.hibernate.engine.jdbc.internal.CharacterStreamImpl;
 import org.hibernate.internal.util.ClassLoaderHelper;
 import org.hibernate.type.descriptor.java.DataHelper;
 
 /**
  * Manages aspects of proxying {@link Clob Clobs} for non-contextual creation, including proxy creation and
  * handling proxy invocations.  We use proxies here solely to avoid JDBC version incompatibilities.
  *
  * @author Gavin King
  * @author Steve Ebersole
  * @author Gail Badner
  */
 public class ClobProxy implements InvocationHandler {
 	private static final Class[] PROXY_INTERFACES = new Class[] { Clob.class, ClobImplementer.class };
 
 	private final CharacterStream characterStream;
 	private boolean needsReset;
 
 	/**
 	 * Constructor used to build {@link Clob} from string data.
 	 *
 	 * @param string The byte array
 	 * @see #generateProxy(String)
 	 */
 	protected ClobProxy(String string) {
 		this.characterStream = new CharacterStreamImpl( string );
 	}
 
 	/**
 	 * Constructor used to build {@link Clob} from a reader.
 	 *
 	 * @param reader The character reader.
 	 * @param length The length of the reader stream.
 	 * @see #generateProxy(java.io.Reader, long)
 	 */
 	protected ClobProxy(Reader reader, long length) {
 		this.characterStream = new CharacterStreamImpl( reader, length );
 	}
 
 	protected long getLength() {
 		return characterStream.getLength();
 	}
 
 	protected InputStream getAsciiStream() throws SQLException {
 		return new ReaderInputStream( getCharacterStream() );
 	}
 
 	protected Reader getCharacterStream() throws SQLException {
 		return getUnderlyingStream().asReader();
 	}
 
 	protected CharacterStream getUnderlyingStream() throws SQLException {
 		resetIfNeeded();
 		return characterStream;
 	}
 
 	protected String getSubString(long start, int length) {
 		final String string = characterStream.asString();
 		// semi-naive implementation
 		final int endIndex = Math.min( ( (int) start ) + length, string.length() );
 		return string.substring( (int) start, endIndex );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 *
 	 * @throws UnsupportedOperationException if any methods other than {@link Clob#length},
 	 * {@link Clob#getAsciiStream}, {@link Clob#getCharacterStream},
 	 * {@link ClobImplementer#getUnderlyingStream}, {@link Clob#getSubString},
 	 * {@link Clob#free}, or toString/equals/hashCode are invoked.
 	 */
 	@Override
-	@SuppressWarnings({ "UnnecessaryBoxing" })
 	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 		final String methodName = method.getName();
 		final int argCount = method.getParameterTypes().length;
 
 		if ( "length".equals( methodName ) && argCount == 0 ) {
-			return Long.valueOf( getLength() );
+			return getLength();
 		}
 		if ( "getUnderlyingStream".equals( methodName ) ) {
 			return getUnderlyingStream(); // Reset stream if needed.
 		}
 		if ( "getAsciiStream".equals( methodName ) && argCount == 0 ) {
 			return getAsciiStream();
 		}
 		if ( "getCharacterStream".equals( methodName ) ) {
 			if ( argCount == 0 ) {
 				return getCharacterStream();
 			}
 			else if ( argCount == 2 ) {
 				final long start = (Long) args[0];
 				if ( start < 1 ) {
 					throw new SQLException( "Start position 1-based; must be 1 or more." );
 				}
 				if ( start > getLength() ) {
 					throw new SQLException( "Start position [" + start + "] cannot exceed overall CLOB length [" + getLength() + "]" );
 				}
 				final int length = (Integer) args[1];
 				if ( length < 0 ) {
 					// java docs specifically say for getCharacterStream(long,int) that the start+length must not exceed the
 					// total length, however that is at odds with the getSubString(long,int) behavior.
 					throw new SQLException( "Length must be great-than-or-equal to zero." );
 				}
 				return DataHelper.subStream( getCharacterStream(), start-1, length );
 			}
 		}
 		if ( "getSubString".equals( methodName ) && argCount == 2 ) {
 			final long start = (Long) args[0];
 			if ( start < 1 ) {
 				throw new SQLException( "Start position 1-based; must be 1 or more." );
 			}
 			if ( start > getLength() ) {
 				throw new SQLException( "Start position [" + start + "] cannot exceed overall CLOB length [" + getLength() + "]" );
 			}
 			final int length = (Integer) args[1];
 			if ( length < 0 ) {
 				throw new SQLException( "Length must be great-than-or-equal to zero." );
 			}
 			return getSubString( start-1, length );
 		}
 		if ( "free".equals( methodName ) && argCount == 0 ) {
 			characterStream.release();
 			return null;
 		}
 		if ( "toString".equals( methodName ) && argCount == 0 ) {
 			return this.toString();
 		}
 		if ( "equals".equals( methodName ) && argCount == 1 ) {
-			return Boolean.valueOf( proxy == args[0] );
+			return proxy == args[0];
 		}
 		if ( "hashCode".equals( methodName ) && argCount == 0 ) {
 			return this.hashCode();
 		}
 
 		throw new UnsupportedOperationException( "Clob may not be manipulated from creating session" );
 	}
 
 	protected void resetIfNeeded() throws SQLException {
 		try {
 			if ( needsReset ) {
 				characterStream.asReader().reset();
 			}
 		}
 		catch ( IOException ioe ) {
 			throw new SQLException( "could not reset reader", ioe );
 		}
 		needsReset = true;
 	}
 
 	/**
 	 * Generates a {@link Clob} proxy using the string data.
 	 *
 	 * @param string The data to be wrapped as a {@link Clob}.
 	 *
 	 * @return The generated proxy.
 	 */
 	public static Clob generateProxy(String string) {
 		return (Clob) Proxy.newProxyInstance( getProxyClassLoader(), PROXY_INTERFACES, new ClobProxy( string ) );
 	}
 
 	/**
 	 * Generates a {@link Clob} proxy using a character reader of given length.
 	 *
 	 * @param reader The character reader
 	 * @param length The length of the character reader
 	 *
 	 * @return The generated proxy.
 	 */
 	public static Clob generateProxy(Reader reader, long length) {
 		return (Clob) Proxy.newProxyInstance( getProxyClassLoader(), PROXY_INTERFACES, new ClobProxy( reader, length ) );
 	}
 
 	/**
 	 * Determines the appropriate class loader to which the generated proxy
 	 * should be scoped.
 	 *
 	 * @return The class loader appropriate for proxy construction.
 	 */
 	protected static ClassLoader getProxyClassLoader() {
 		ClassLoader cl = ClassLoaderHelper.getContextClassLoader();
 		if ( cl == null ) {
 			cl = ClobImplementer.class.getClassLoader();
 		}
 		return cl;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/ResultSetWrapperProxy.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/ResultSetWrapperProxy.java
index d162fbb2a6..51df139d81 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/ResultSetWrapperProxy.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/ResultSetWrapperProxy.java
@@ -1,187 +1,185 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009 by Red Hat Inc and/or its affiliates or by
  * third-party contributors as indicated by either @author tags or express
  * copyright attribution statements applied by the authors.  All
  * third-party contributions are distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc;
 
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ClassLoaderHelper;
 
 /**
  * A proxy for a ResultSet delegate, responsible for locally caching the columnName-to-columnIndex resolution that
  * has been found to be inefficient in a few vendor's drivers (i.e., Oracle and Postgres).
  *
  * @author Steve Ebersole
  * @author Gail Badner
  */
 public class ResultSetWrapperProxy implements InvocationHandler {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			ResultSetWrapperProxy.class.getName()
 	);
 	private static final Class[] PROXY_INTERFACES = new Class[] { ResultSet.class };
 	private static final SqlExceptionHelper SQL_EXCEPTION_HELPER = new SqlExceptionHelper();
 
 	private final ResultSet rs;
 	private final ColumnNameCache columnNameCache;
 
 	private ResultSetWrapperProxy(ResultSet rs, ColumnNameCache columnNameCache) {
 		this.rs = rs;
 		this.columnNameCache = columnNameCache;
 	}
 
 	/**
 	 * Generates a proxy wrapping the ResultSet.
 	 *
 	 * @param resultSet The resultSet to wrap.
 	 * @param columnNameCache The cache storing data for converting column names to column indexes.
 	 * @return The generated proxy.
 	 */
 	public static ResultSet generateProxy(ResultSet resultSet, ColumnNameCache columnNameCache) {
 		return (ResultSet) Proxy.newProxyInstance(
 				getProxyClassLoader(),
 				PROXY_INTERFACES,
 				new ResultSetWrapperProxy( resultSet, columnNameCache )
 		);
 	}
 
 	/**
 	 * Determines the appropriate class loader to which the generated proxy
 	 * should be scoped.
 	 *
 	 * @return The class loader appropriate for proxy construction.
 	 */
 	public static ClassLoader getProxyClassLoader() {
 		ClassLoader cl = ClassLoaderHelper.getContextClassLoader();
 		if ( cl == null ) {
 			cl = ResultSet.class.getClassLoader();
 		}
 		return cl;
 	}
 
 	@Override
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 		if ( "findColumn".equals( method.getName() ) ) {
-			return Integer.valueOf( findColumn( (String) args[0] ) );
+			return findColumn( (String) args[0] );
 		}
 
 		if ( isFirstArgColumnLabel( method, args ) ) {
 			try {
 				final int columnIndex = findColumn( (String) args[0] );
 				return invokeMethod(
 						locateCorrespondingColumnIndexMethod( method ),
 						buildColumnIndexMethodArgs( args, columnIndex )
 				);
 			}
 			catch ( SQLException ex ) {
 				final String msg = "Exception getting column index for column: [" + args[0] +
 						"].\nReverting to using: [" + args[0] +
 						"] as first argument for method: [" + method + "]";
 				SQL_EXCEPTION_HELPER.logExceptions( ex, msg );
 			}
 			catch ( NoSuchMethodException ex ) {
 				LOG.unableToSwitchToMethodUsingColumnIndex( method );
 			}
 		}
 		return invokeMethod( method, args );
 	}
 
 	/**
 	 * Locate the column index corresponding to the given column name via the cache.
 	 *
 	 * @param columnName The column name to resolve into an index.
 	 * @return The column index corresponding to the given column name.
 	 * @throws SQLException if the ResultSet object does not contain columnName or a database access error occurs
 	 */
 	private int findColumn(String columnName) throws SQLException {
 		return columnNameCache.getIndexForColumnName( columnName, rs );
 	}
 
 	private boolean isFirstArgColumnLabel(Method method, Object[] args) {
 		// method name should start with either get or update
 		if ( ! ( method.getName().startsWith( "get" ) || method.getName().startsWith( "update" ) ) ) {
 			return false;
 		}
 
 		// method should have arguments, and have same number as incoming arguments
 		if ( ! ( method.getParameterTypes().length > 0 && args.length == method.getParameterTypes().length ) ) {
 			return false;
 		}
 
 		// The first argument should be a String (the column name)
 		//noinspection RedundantIfStatement
 		if ( ! ( String.class.isInstance( args[0] ) && method.getParameterTypes()[0].equals( String.class ) ) ) {
 			return false;
 		}
 
 		return true;
 	}
 
 	/**
 	 * For a given {@link ResultSet} method passed a column name, locate the corresponding method passed the same
 	 * parameters but the column index.
 	 *
 	 * @param columnNameMethod The method passed the column name
 	 * @return The corresponding method passed the column index.
 	 * @throws NoSuchMethodException Should never happen, but...
 	 */
 	private Method locateCorrespondingColumnIndexMethod(Method columnNameMethod) throws NoSuchMethodException {
 		final Class[] actualParameterTypes = new Class[columnNameMethod.getParameterTypes().length];
 		actualParameterTypes[0] = int.class;
 		System.arraycopy(
 				columnNameMethod.getParameterTypes(),
 				1,
 				actualParameterTypes,
 				1,
 				columnNameMethod.getParameterTypes().length - 1
 		);
 		return columnNameMethod.getDeclaringClass().getMethod( columnNameMethod.getName(), actualParameterTypes );
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	private Object[] buildColumnIndexMethodArgs(Object[] incomingArgs, int columnIndex) {
 		final Object[] actualArgs = new Object[incomingArgs.length];
-		actualArgs[0] = Integer.valueOf( columnIndex );
+		actualArgs[0] = columnIndex;
 		System.arraycopy( incomingArgs, 1, actualArgs, 1, incomingArgs.length - 1 );
 		return actualArgs;
 	}
 
 	private Object invokeMethod(Method method, Object[] args) throws Throwable {
 		try {
 			return method.invoke( rs, args );
 		}
 		catch ( InvocationTargetException e ) {
 			throw e.getTargetException();
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java
index fd718b5357..b21f694879 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java
@@ -1,280 +1,279 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.connections.internal;
 
 import java.sql.Connection;
 import java.sql.Driver;
 import java.sql.DriverManager;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Map;
 import java.util.Properties;
 import java.util.concurrent.atomic.AtomicInteger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.UnknownUnwrapTypeException;
 import org.hibernate.service.spi.Configurable;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.Stoppable;
 import org.jboss.logging.Logger;
 
 /**
  * A connection provider that uses the {@link java.sql.DriverManager} directly to open connections and provides
  * a very rudimentary connection pool.
  * <p/>
  * IMPL NOTE : not intended for production use!
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
-@SuppressWarnings( {"UnnecessaryUnboxing"})
 public class DriverManagerConnectionProviderImpl
 		implements ConnectionProvider, Configurable, Stoppable, ServiceRegistryAwareService {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, DriverManagerConnectionProviderImpl.class.getName() );
 
 	private String url;
 	private Properties connectionProps;
 	private Integer isolation;
 	private int poolSize;
 	private boolean autocommit;
 
 	private final ArrayList<Connection> pool = new ArrayList<Connection>();
 	private final AtomicInteger checkedOut = new AtomicInteger();
 
 	private boolean stopped;
 
 	private transient ServiceRegistryImplementor serviceRegistry;
 	
 	private Driver driver;
 
 	@Override
 	public boolean isUnwrappableAs(Class unwrapType) {
 		return ConnectionProvider.class.equals( unwrapType ) ||
 				DriverManagerConnectionProviderImpl.class.isAssignableFrom( unwrapType );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> T unwrap(Class<T> unwrapType) {
 		if ( ConnectionProvider.class.equals( unwrapType ) ||
 				DriverManagerConnectionProviderImpl.class.isAssignableFrom( unwrapType ) ) {
 			return (T) this;
 		}
 		else {
 			throw new UnknownUnwrapTypeException( unwrapType );
 		}
 	}
 
 	@Override
 	public void configure(Map configurationValues) {
 		LOG.usingHibernateBuiltInConnectionPool();
 
 		final String driverClassName = (String) configurationValues.get( AvailableSettings.DRIVER );
 		if ( driverClassName == null ) {
 			LOG.jdbcDriverNotSpecified( AvailableSettings.DRIVER );
 		}
 		else if ( serviceRegistry != null ) {
 			try {
 				driver = (Driver) serviceRegistry.getService(
 						ClassLoaderService.class ).classForName( driverClassName )
 						.newInstance();
 			}
 			catch ( Exception e ) {
 				throw new ClassLoadingException(
 						"Specified JDBC Driver " + driverClassName
 						+ " could not be loaded", e
 				);
 			}
 		}
 		// guard dog, mostly for making test pass
 		else {
 			try {
 				// trying via forName() first to be as close to DriverManager's semantics
 				driver = (Driver) Class.forName( driverClassName ).newInstance();
 			}
 			catch ( Exception e1 ) {
 				try{
 					driver = (Driver) ReflectHelper.classForName( driverClassName ).newInstance();
 				}
 				catch ( Exception e2 ) {
 					throw new HibernateException( "Specified JDBC Driver " + driverClassName + " could not be loaded", e2 );
 				}
 			}
 		}
 
 		// default pool size 20
 		poolSize = ConfigurationHelper.getInt( AvailableSettings.POOL_SIZE, configurationValues, 20 );
 		LOG.hibernateConnectionPoolSize( poolSize );
 
 		autocommit = ConfigurationHelper.getBoolean( AvailableSettings.AUTOCOMMIT, configurationValues );
 		LOG.autoCommitMode( autocommit );
 
 		isolation = ConfigurationHelper.getInteger( AvailableSettings.ISOLATION, configurationValues );
 		if ( isolation != null ) {
-			LOG.jdbcIsolationLevel( Environment.isolationLevelToString( isolation.intValue() ) );
+			LOG.jdbcIsolationLevel( Environment.isolationLevelToString( isolation ) );
 		}
 
 		url = (String) configurationValues.get( AvailableSettings.URL );
 		if ( url == null ) {
 			final String msg = LOG.jdbcUrlNotSpecified( AvailableSettings.URL );
 			LOG.error( msg );
 			throw new HibernateException( msg );
 		}
 
 		connectionProps = ConnectionProviderInitiator.getConnectionProperties( configurationValues );
 
 		LOG.usingDriver( driverClassName, url );
 		// if debug level is enabled, then log the password, otherwise mask it
 		if ( LOG.isDebugEnabled() ) {
 			LOG.connectionProperties( connectionProps );
 		}
 		else {
 			LOG.connectionProperties( ConfigurationHelper.maskOut( connectionProps, "password" ) );
 		}
 	}
 
 	@Override
 	public void stop() {
 		LOG.cleaningUpConnectionPool( url );
 
 		for ( Connection connection : pool ) {
 			try {
 				connection.close();
 			}
 			catch (SQLException sqle) {
 				LOG.unableToClosePooledConnection( sqle );
 			}
 		}
 		pool.clear();
 		stopped = true;
 	}
 
 	@Override
 	public Connection getConnection() throws SQLException {
 		final boolean traceEnabled = LOG.isTraceEnabled();
 		if ( traceEnabled ) {
 			LOG.tracev( "Total checked-out connections: {0}", checkedOut.intValue() );
 		}
 
 		// essentially, if we have available connections in the pool, use one...
 		synchronized (pool) {
 			if ( !pool.isEmpty() ) {
 				final int last = pool.size() - 1;
 				if ( traceEnabled ) {
 					LOG.tracev( "Using pooled JDBC connection, pool size: {0}", last );
 				}
 				final Connection pooled = pool.remove( last );
 				if ( isolation != null ) {
-					pooled.setTransactionIsolation( isolation.intValue() );
+					pooled.setTransactionIsolation( isolation );
 				}
 				if ( pooled.getAutoCommit() != autocommit ) {
 					pooled.setAutoCommit( autocommit );
 				}
 				checkedOut.incrementAndGet();
 				return pooled;
 			}
 		}
 
 		// otherwise we open a new connection...
 		final boolean debugEnabled = LOG.isDebugEnabled();
 		if ( debugEnabled ) {
 			LOG.debug( "Opening new JDBC connection" );
 		}
 		
 		final Connection conn;
 		if ( driver != null ) {
 			// If a Driver is available, completely circumvent
 			// DriverManager#getConnection.  It attempts to double check
 			// ClassLoaders before using a Driver.  This does not work well in
 			// OSGi environments without wonky workarounds.
 			conn = driver.connect( url, connectionProps );
 		}
 		else {
 			// If no Driver, fall back on the original method.
 			conn = DriverManager.getConnection( url, connectionProps );
 		}
 		
 		if ( isolation != null ) {
-			conn.setTransactionIsolation( isolation.intValue() );
+			conn.setTransactionIsolation( isolation );
 		}
 		if ( conn.getAutoCommit() != autocommit ) {
 			conn.setAutoCommit( autocommit );
 		}
 
 		if ( debugEnabled ) {
 			LOG.debugf( "Created connection to: %s, Isolation Level: %s", url, conn.getTransactionIsolation() );
 		}
 
 		checkedOut.incrementAndGet();
 		return conn;
 	}
 
 	@Override
 	public void closeConnection(Connection conn) throws SQLException {
 		checkedOut.decrementAndGet();
 
 		final boolean traceEnabled = LOG.isTraceEnabled();
 		// add to the pool if the max size is not yet reached.
 		synchronized ( pool ) {
 			final int currentSize = pool.size();
 			if ( currentSize < poolSize ) {
 				if ( traceEnabled ) {
 					LOG.tracev( "Returning connection to pool, pool size: {0}", ( currentSize + 1 ) );
 				}
 				pool.add( conn );
 				return;
 			}
 		}
 
 		LOG.debug( "Closing JDBC connection" );
 		conn.close();
 	}
 
 	@Override
 	protected void finalize() throws Throwable {
 		if ( !stopped ) {
 			stop();
 		}
 		super.finalize();
 	}
 
 	@Override
 	public boolean supportsAggressiveRelease() {
 		return false;
 	}
 
 	@Override
 	public void injectServices(ServiceRegistryImplementor serviceRegistry) {
 		this.serviceRegistry = serviceRegistry;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/cursor/internal/StandardRefCursorSupport.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/cursor/internal/StandardRefCursorSupport.java
index c1c98ac215..c831ee009a 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/cursor/internal/StandardRefCursorSupport.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/cursor/internal/StandardRefCursorSupport.java
@@ -1,247 +1,245 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.cursor.internal;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.sql.CallableStatement;
 import java.sql.DatabaseMetaData;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Types;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.cursor.spi.RefCursorSupport;
 import org.hibernate.service.spi.InjectService;
 
 /**
  * Standard implementation of RefCursorSupport
  *
  * @author Steve Ebersole
  */
 public class StandardRefCursorSupport implements RefCursorSupport {
 	private static final Logger log = Logger.getLogger( StandardRefCursorSupport.class );
 
 	private JdbcServices jdbcServices;
 
 	/**
 	 * Hook for service registry to be able to inject JdbcServices
 	 *
 	 * @param jdbcServices The JdbcServices service
 	 */
 	@InjectService
 	@SuppressWarnings("UnusedDeclaration")
 	public void injectJdbcServices(JdbcServices jdbcServices) {
 		this.jdbcServices = jdbcServices;
 	}
 
 	@Override
 	public void registerRefCursorParameter(CallableStatement statement, int position) {
 		if ( jdbcServices.getExtractedMetaDataSupport().supportsRefCursors() ) {
 			try {
 				statement.registerOutParameter( position, refCursorTypeCode() );
 			}
 			catch (SQLException e) {
 				throw jdbcServices.getSqlExceptionHelper().convert( e, "Error registering REF_CURSOR parameter [" + position + "]" );
 			}
 		}
 		else {
 			try {
 				jdbcServices.getDialect().registerResultSetOutParameter( statement, position );
 			}
 			catch (SQLException e) {
 				throw jdbcServices.getSqlExceptionHelper().convert( e, "Error asking dialect to register ref cursor parameter [" + position + "]" );
 			}
 		}
 	}
 
 	@Override
 	public void registerRefCursorParameter(CallableStatement statement, String name) {
 		if ( jdbcServices.getExtractedMetaDataSupport().supportsRefCursors() ) {
 			try {
 				statement.registerOutParameter( name, refCursorTypeCode() );
 			}
 			catch (SQLException e) {
 				throw jdbcServices.getSqlExceptionHelper().convert( e, "Error registering REF_CURSOR parameter [" + name + "]" );
 			}
 		}
 		else {
 			try {
 				jdbcServices.getDialect().registerResultSetOutParameter( statement, name );
 			}
 			catch (SQLException e) {
 				throw jdbcServices.getSqlExceptionHelper().convert( e, "Error asking dialect to register ref cursor parameter [" + name + "]" );
 			}
 		}
 	}
 
 	@Override
 	public ResultSet getResultSet(CallableStatement statement, int position) {
 		if ( jdbcServices.getExtractedMetaDataSupport().supportsRefCursors() ) {
 			try {
 				return (ResultSet) getResultSetByPositionMethod().invoke( statement, position, ResultSet.class );
 			}
 			catch (InvocationTargetException e) {
 				if ( e.getTargetException() instanceof SQLException ) {
 					throw jdbcServices.getSqlExceptionHelper().convert(
 							(SQLException) e.getTargetException(),
 							"Error extracting REF_CURSOR parameter [" + position + "]"
 					);
 				}
 				else {
 					throw new HibernateException( "Unexpected error extracting REF_CURSOR parameter [" + position + "]", e.getTargetException() );
 				}
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Unexpected error extracting REF_CURSOR parameter [" + position + "]", e );
 			}
 		}
 		else {
 			try {
 				return jdbcServices.getDialect().getResultSet( statement, position );
 			}
 			catch (SQLException e) {
 				throw jdbcServices.getSqlExceptionHelper().convert(
 						e,
 						"Error asking dialect to extract ResultSet from CallableStatement parameter [" + position + "]"
 				);
 			}
 		}
 	}
 
 	@Override
 	public ResultSet getResultSet(CallableStatement statement, String name) {
 		if ( jdbcServices.getExtractedMetaDataSupport().supportsRefCursors() ) {
 			try {
 				return (ResultSet) getResultSetByNameMethod().invoke( statement, name, ResultSet.class );
 			}
 			catch (InvocationTargetException e) {
 				if ( e.getTargetException() instanceof SQLException ) {
 					throw jdbcServices.getSqlExceptionHelper().convert(
 							(SQLException) e.getTargetException(),
 							"Error extracting REF_CURSOR parameter [" + name + "]"
 					);
 				}
 				else {
 					throw new HibernateException( "Unexpected error extracting REF_CURSOR parameter [" + name + "]", e.getTargetException() );
 				}
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Unexpected error extracting REF_CURSOR parameter [" + name + "]", e );
 			}
 		}
 		else {
 			try {
 				return jdbcServices.getDialect().getResultSet( statement, name );
 			}
 			catch (SQLException e) {
 				throw jdbcServices.getSqlExceptionHelper().convert(
 						e,
 						"Error asking dialect to extract ResultSet from CallableStatement parameter [" + name + "]"
 				);
 			}
 		}
 	}
 
 	/**
 	 * Does this JDBC metadata indicate that the driver defines REF_CURSOR support?
 	 *
 	 * @param meta The JDBC metadata
 	 *
 	 * @return {@code true} if the metadata indicates that the driver defines REF_CURSOR support
 	 */
-	@SuppressWarnings("UnnecessaryUnboxing")
 	public static boolean supportsRefCursors(DatabaseMetaData meta) {
 		// Standard JDBC REF_CURSOR support was not added until Java 8, so we need to use reflection to attempt to
 		// access these fields/methods...
 		try {
-			return ( (Boolean) meta.getClass().getMethod( "supportsRefCursors" ).invoke( null ) ).booleanValue();
+			return (Boolean) meta.getClass().getMethod( "supportsRefCursors" ).invoke( null );
 		}
 		catch (NoSuchMethodException e) {
 			log.trace( "JDBC DatabaseMetaData class does not define supportsRefCursors method..." );
 		}
 		catch (Exception e) {
 			log.debug( "Unexpected error trying to gauge level of JDBC REF_CURSOR support : " + e.getMessage() );
 		}
 		return false;
 	}
 
 
 	private static Integer refCursorTypeCode;
 
-	@SuppressWarnings("UnnecessaryUnboxing")
 	private int refCursorTypeCode() {
 		if ( refCursorTypeCode == null ) {
 			try {
 				refCursorTypeCode = (Integer) Types.class.getField( "REF_CURSOR" ).get( null );
 			}
 			catch (NoSuchFieldException e) {
 				throw new HibernateException( "java.sql.Types class does not define REF_CURSOR field..." );
 			}
 			catch (IllegalAccessException e) {
 				throw new HibernateException( "Unexpected error trying to determine REF_CURSOR field value : " + e.getMessage() );
 			}
 		}
 		return refCursorTypeCode;
 	}
 
 
 	private static Method getResultSetByPositionMethod;
 
 	private Method getResultSetByPositionMethod() {
 		if ( getResultSetByPositionMethod == null ) {
 			try {
 				getResultSetByPositionMethod = CallableStatement.class.getMethod( "getObject", int.class, Class.class );
 			}
 			catch (NoSuchMethodException e) {
 				throw new HibernateException( "CallableStatement class does not define getObject(int,Class) method" );
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Unexpected error trying to access CallableStatement#getObject(int,Class)" );
 			}
 		}
 		return getResultSetByPositionMethod;
 	}
 
 
 	private static Method getResultSetByNameMethod;
 
 	private Method getResultSetByNameMethod() {
 		if ( getResultSetByNameMethod == null ) {
 			try {
 				getResultSetByNameMethod = CallableStatement.class.getMethod( "getObject", String.class, Class.class );
 			}
 			catch (NoSuchMethodException e) {
 				throw new HibernateException( "CallableStatement class does not define getObject(String,Class) method" );
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Unexpected error trying to access CallableStatement#getObject(String,Class)" );
 			}
 		}
 		return getResultSetByNameMethod;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/BasicFormatterImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/BasicFormatterImpl.java
index f0fd816b7b..7ac399ef11 100755
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/BasicFormatterImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/BasicFormatterImpl.java
@@ -1,400 +1,398 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.internal;
 
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 import org.hibernate.internal.util.StringHelper;
 
 /**
  * Performs formatting of basic SQL statements (DML + query).
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class BasicFormatterImpl implements Formatter {
 
 	private static final Set<String> BEGIN_CLAUSES = new HashSet<String>();
 	private static final Set<String> END_CLAUSES = new HashSet<String>();
 	private static final Set<String> LOGICAL = new HashSet<String>();
 	private static final Set<String> QUANTIFIERS = new HashSet<String>();
 	private static final Set<String> DML = new HashSet<String>();
 	private static final Set<String> MISC = new HashSet<String>();
 
 	static {
 		BEGIN_CLAUSES.add( "left" );
 		BEGIN_CLAUSES.add( "right" );
 		BEGIN_CLAUSES.add( "inner" );
 		BEGIN_CLAUSES.add( "outer" );
 		BEGIN_CLAUSES.add( "group" );
 		BEGIN_CLAUSES.add( "order" );
 
 		END_CLAUSES.add( "where" );
 		END_CLAUSES.add( "set" );
 		END_CLAUSES.add( "having" );
 		END_CLAUSES.add( "join" );
 		END_CLAUSES.add( "from" );
 		END_CLAUSES.add( "by" );
 		END_CLAUSES.add( "join" );
 		END_CLAUSES.add( "into" );
 		END_CLAUSES.add( "union" );
 
 		LOGICAL.add( "and" );
 		LOGICAL.add( "or" );
 		LOGICAL.add( "when" );
 		LOGICAL.add( "else" );
 		LOGICAL.add( "end" );
 
 		QUANTIFIERS.add( "in" );
 		QUANTIFIERS.add( "all" );
 		QUANTIFIERS.add( "exists" );
 		QUANTIFIERS.add( "some" );
 		QUANTIFIERS.add( "any" );
 
 		DML.add( "insert" );
 		DML.add( "update" );
 		DML.add( "delete" );
 
 		MISC.add( "select" );
 		MISC.add( "on" );
 	}
 
 	private static final String INDENT_STRING = "    ";
 	private static final String INITIAL = "\n    ";
 
 	@Override
 	public String format(String source) {
 		return new FormatProcess( source ).perform();
 	}
 
 	private static class FormatProcess {
 		boolean beginLine = true;
 		boolean afterBeginBeforeEnd;
 		boolean afterByOrSetOrFromOrSelect;
 		boolean afterValues;
 		boolean afterOn;
 		boolean afterBetween;
 		boolean afterInsert;
 		int inFunction;
 		int parensSinceSelect;
 		private LinkedList<Integer> parenCounts = new LinkedList<Integer>();
 		private LinkedList<Boolean> afterByOrFromOrSelects = new LinkedList<Boolean>();
 
 		int indent = 1;
 
 		StringBuilder result = new StringBuilder();
 		StringTokenizer tokens;
 		String lastToken;
 		String token;
 		String lcToken;
 
 		public FormatProcess(String sql) {
 			tokens = new StringTokenizer(
 					sql,
 					"()+*/-=<>'`\"[]," + StringHelper.WHITESPACE,
 					true
 			);
 		}
 
 		public String perform() {
 
 			result.append( INITIAL );
 
 			while ( tokens.hasMoreTokens() ) {
 				token = tokens.nextToken();
 				lcToken = token.toLowerCase();
 
 				if ( "'".equals( token ) ) {
 					String t;
 					do {
 						t = tokens.nextToken();
 						token += t;
 					}
 					// cannot handle single quotes
 					while ( !"'".equals( t ) && tokens.hasMoreTokens() );
 				}
 				else if ( "\"".equals( token ) ) {
 					String t;
 					do {
 						t = tokens.nextToken();
 						token += t;
 					}
 					while ( !"\"".equals( t ) );
 				}
 
 				if ( afterByOrSetOrFromOrSelect && ",".equals( token ) ) {
 					commaAfterByOrFromOrSelect();
 				}
 				else if ( afterOn && ",".equals( token ) ) {
 					commaAfterOn();
 				}
 
 				else if ( "(".equals( token ) ) {
 					openParen();
 				}
 				else if ( ")".equals( token ) ) {
 					closeParen();
 				}
 
 				else if ( BEGIN_CLAUSES.contains( lcToken ) ) {
 					beginNewClause();
 				}
 
 				else if ( END_CLAUSES.contains( lcToken ) ) {
 					endNewClause();
 				}
 
 				else if ( "select".equals( lcToken ) ) {
 					select();
 				}
 
 				else if ( DML.contains( lcToken ) ) {
 					updateOrInsertOrDelete();
 				}
 
 				else if ( "values".equals( lcToken ) ) {
 					values();
 				}
 
 				else if ( "on".equals( lcToken ) ) {
 					on();
 				}
 
 				else if ( afterBetween && lcToken.equals( "and" ) ) {
 					misc();
 					afterBetween = false;
 				}
 
 				else if ( LOGICAL.contains( lcToken ) ) {
 					logical();
 				}
 
 				else if ( isWhitespace( token ) ) {
 					white();
 				}
 
 				else {
 					misc();
 				}
 
 				if ( !isWhitespace( token ) ) {
 					lastToken = lcToken;
 				}
 
 			}
 			return result.toString();
 		}
 
 		private void commaAfterOn() {
 			out();
 			indent--;
 			newline();
 			afterOn = false;
 			afterByOrSetOrFromOrSelect = true;
 		}
 
 		private void commaAfterByOrFromOrSelect() {
 			out();
 			newline();
 		}
 
 		private void logical() {
 			if ( "end".equals( lcToken ) ) {
 				indent--;
 			}
 			newline();
 			out();
 			beginLine = false;
 		}
 
 		private void on() {
 			indent++;
 			afterOn = true;
 			newline();
 			out();
 			beginLine = false;
 		}
 
 		private void misc() {
 			out();
 			if ( "between".equals( lcToken ) ) {
 				afterBetween = true;
 			}
 			if ( afterInsert ) {
 				newline();
 				afterInsert = false;
 			}
 			else {
 				beginLine = false;
 				if ( "case".equals( lcToken ) ) {
 					indent++;
 				}
 			}
 		}
 
 		private void white() {
 			if ( !beginLine ) {
 				result.append( " " );
 			}
 		}
 
 		private void updateOrInsertOrDelete() {
 			out();
 			indent++;
 			beginLine = false;
 			if ( "update".equals( lcToken ) ) {
 				newline();
 			}
 			if ( "insert".equals( lcToken ) ) {
 				afterInsert = true;
 			}
 		}
 
-		@SuppressWarnings( {"UnnecessaryBoxing"})
 		private void select() {
 			out();
 			indent++;
 			newline();
-			parenCounts.addLast( Integer.valueOf( parensSinceSelect ) );
-			afterByOrFromOrSelects.addLast( Boolean.valueOf( afterByOrSetOrFromOrSelect ) );
+			parenCounts.addLast( parensSinceSelect );
+			afterByOrFromOrSelects.addLast( afterByOrSetOrFromOrSelect );
 			parensSinceSelect = 0;
 			afterByOrSetOrFromOrSelect = true;
 		}
 
 		private void out() {
 			result.append( token );
 		}
 
 		private void endNewClause() {
 			if ( !afterBeginBeforeEnd ) {
 				indent--;
 				if ( afterOn ) {
 					indent--;
 					afterOn = false;
 				}
 				newline();
 			}
 			out();
 			if ( !"union".equals( lcToken ) ) {
 				indent++;
 			}
 			newline();
 			afterBeginBeforeEnd = false;
 			afterByOrSetOrFromOrSelect = "by".equals( lcToken )
 					|| "set".equals( lcToken )
 					|| "from".equals( lcToken );
 		}
 
 		private void beginNewClause() {
 			if ( !afterBeginBeforeEnd ) {
 				if ( afterOn ) {
 					indent--;
 					afterOn = false;
 				}
 				indent--;
 				newline();
 			}
 			out();
 			beginLine = false;
 			afterBeginBeforeEnd = true;
 		}
 
 		private void values() {
 			indent--;
 			newline();
 			out();
 			indent++;
 			newline();
 			afterValues = true;
 		}
 
-		@SuppressWarnings( {"UnnecessaryUnboxing"})
 		private void closeParen() {
 			parensSinceSelect--;
 			if ( parensSinceSelect < 0 ) {
 				indent--;
 				parensSinceSelect = parenCounts.removeLast();
-				afterByOrSetOrFromOrSelect = afterByOrFromOrSelects.removeLast().booleanValue();
+				afterByOrSetOrFromOrSelect = afterByOrFromOrSelects.removeLast();
 			}
 			if ( inFunction > 0 ) {
 				inFunction--;
 				out();
 			}
 			else {
 				if ( !afterByOrSetOrFromOrSelect ) {
 					indent--;
 					newline();
 				}
 				out();
 			}
 			beginLine = false;
 		}
 
 		private void openParen() {
 			if ( isFunctionName( lastToken ) || inFunction > 0 ) {
 				inFunction++;
 			}
 			beginLine = false;
 			if ( inFunction > 0 ) {
 				out();
 			}
 			else {
 				out();
 				if ( !afterByOrSetOrFromOrSelect ) {
 					indent++;
 					newline();
 					beginLine = true;
 				}
 			}
 			parensSinceSelect++;
 		}
 
 		private static boolean isFunctionName(String tok) {
 			final char begin = tok.charAt( 0 );
 			final boolean isIdentifier = Character.isJavaIdentifierStart( begin ) || '"' == begin;
 			return isIdentifier &&
 					!LOGICAL.contains( tok ) &&
 					!END_CLAUSES.contains( tok ) &&
 					!QUANTIFIERS.contains( tok ) &&
 					!DML.contains( tok ) &&
 					!MISC.contains( tok );
 		}
 
 		private static boolean isWhitespace(String token) {
 			return StringHelper.WHITESPACE.contains( token );
 		}
 
 		private void newline() {
 			result.append( "\n" );
 			for ( int i = 0; i < indent; i++ ) {
 				result.append( INDENT_STRING );
 			}
 			beginLine = true;
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/HQLQueryPlan.java b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/HQLQueryPlan.java
index 404000ea4b..640d717772 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/HQLQueryPlan.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/HQLQueryPlan.java
@@ -1,403 +1,403 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.query.spi;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.Filter;
 import org.hibernate.HibernateException;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.event.spi.EventSource;
 import org.hibernate.hql.internal.QuerySplitter;
 import org.hibernate.hql.spi.FilterTranslator;
 import org.hibernate.hql.spi.ParameterTranslations;
 import org.hibernate.hql.spi.QueryTranslator;
 import org.hibernate.hql.spi.QueryTranslatorFactory;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.internal.util.collections.EmptyIterator;
 import org.hibernate.internal.util.collections.IdentitySet;
 import org.hibernate.internal.util.collections.JoinedIterator;
 import org.hibernate.type.Type;
 
 /**
  * Defines a query execution plan for an HQL query (or filter).
  *
  * @author Steve Ebersole
  */
 public class HQLQueryPlan implements Serializable {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( HQLQueryPlan.class );
 
     // TODO : keep separate notions of QT[] here for shallow/non-shallow queries...
 
 	private final String sourceQuery;
 	private final QueryTranslator[] translators;
 	private final String[] sqlStrings;
 
 	private final ParameterMetadata parameterMetadata;
 	private final ReturnMetadata returnMetadata;
 	private final Set querySpaces;
 
 	private final Set<String> enabledFilterNames;
 	private final boolean shallow;
 
 	/**
 	 * Constructs a HQLQueryPlan
 	 *
 	 * @param hql The HQL query
 	 * @param shallow Whether the execution is to be shallow or not
 	 * @param enabledFilters The enabled filters (we only keep the names)
 	 * @param factory The factory
 	 */
 	public HQLQueryPlan(String hql, boolean shallow, Map<String,Filter> enabledFilters, SessionFactoryImplementor factory) {
 		this( hql, null, shallow, enabledFilters, factory );
 	}
 
 	@SuppressWarnings("unchecked")
 	protected HQLQueryPlan(
 			String hql,
 			String collectionRole,
 			boolean shallow,
 			Map<String,Filter> enabledFilters,
 			SessionFactoryImplementor factory) {
 		this.sourceQuery = hql;
 		this.shallow = shallow;
 
 		final Set<String> copy = new HashSet<String>();
 		copy.addAll( enabledFilters.keySet() );
 		this.enabledFilterNames = java.util.Collections.unmodifiableSet( copy );
 
 		final String[] concreteQueryStrings = QuerySplitter.concreteQueries( hql, factory );
 		final int length = concreteQueryStrings.length;
 		this.translators = new QueryTranslator[length];
 
 		final List<String> sqlStringList = new ArrayList<String>();
-		final Set combinedQuerySpaces = new HashSet();
+		final Set<Serializable> combinedQuerySpaces = new HashSet<Serializable>();
 
 		final boolean hasCollectionRole = (collectionRole == null);
 		final Map querySubstitutions = factory.getSettings().getQuerySubstitutions();
 		final QueryTranslatorFactory queryTranslatorFactory = factory.getSettings().getQueryTranslatorFactory();
 
 		for ( int i=0; i<length; i++ ) {
 			if ( hasCollectionRole ) {
 				translators[i] = queryTranslatorFactory
 						.createQueryTranslator( hql, concreteQueryStrings[i], enabledFilters, factory );
 				translators[i].compile( querySubstitutions, shallow );
 			}
 			else {
 				translators[i] = queryTranslatorFactory
 						.createFilterTranslator( hql, concreteQueryStrings[i], enabledFilters, factory );
 				( (FilterTranslator) translators[i] ).compile( collectionRole, querySubstitutions, shallow );
 			}
 			combinedQuerySpaces.addAll( translators[i].getQuerySpaces() );
 			sqlStringList.addAll( translators[i].collectSqlStrings() );
 		}
 
 		this.sqlStrings = ArrayHelper.toStringArray( sqlStringList );
 		this.querySpaces = combinedQuerySpaces;
 
 		if ( length == 0 ) {
 			parameterMetadata = new ParameterMetadata( null, null );
 			returnMetadata = null;
 		}
 		else {
 			this.parameterMetadata = buildParameterMetadata( translators[0].getParameterTranslations(), hql );
 			if ( translators[0].isManipulationStatement() ) {
 				returnMetadata = null;
 			}
 			else {
 				final Type[] types = ( length > 1 ) ? new Type[translators[0].getReturnTypes().length] : translators[0].getReturnTypes();
 				returnMetadata = new ReturnMetadata( translators[0].getReturnAliases(), types );
 			}
 		}
 	}
 
 	public String getSourceQuery() {
 		return sourceQuery;
 	}
 
 	public Set getQuerySpaces() {
 		return querySpaces;
 	}
 
 	public ParameterMetadata getParameterMetadata() {
 		return parameterMetadata;
 	}
 
 	public ReturnMetadata getReturnMetadata() {
 		return returnMetadata;
 	}
 
 	public Set getEnabledFilterNames() {
 		return enabledFilterNames;
 	}
 
 	public String[] getSqlStrings() {
 		return sqlStrings;
 	}
 
 	public Set getUtilizedFilterNames() {
 		// TODO : add this info to the translator and aggregate it here...
 		return null;
 	}
 
 	public boolean isShallow() {
 		return shallow;
 	}
 
 	/**
 	 * Coordinates the efforts to perform a list across all the included query translators.
 	 *
 	 * @param queryParameters The query parameters
 	 * @param session The session
 	 *
 	 * @return The query result list
 	 *
 	 * @throws HibernateException Indicates a problem performing the query
 	 */
 	@SuppressWarnings("unchecked")
 	public List performList(
 			QueryParameters queryParameters,
 			SessionImplementor session) throws HibernateException {
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Find: {0}", getSourceQuery() );
 			queryParameters.traceParameters( session.getFactory() );
 		}
 
 		final boolean hasLimit = queryParameters.getRowSelection() != null
 				&& queryParameters.getRowSelection().definesLimits();
 		final boolean needsLimit = hasLimit && translators.length > 1;
 
 		final QueryParameters queryParametersToUse;
 		if ( needsLimit ) {
 			LOG.needsLimit();
 			final RowSelection selection = new RowSelection();
 			selection.setFetchSize( queryParameters.getRowSelection().getFetchSize() );
 			selection.setTimeout( queryParameters.getRowSelection().getTimeout() );
 			queryParametersToUse = queryParameters.createCopyUsing( selection );
 		}
 		else {
 			queryParametersToUse = queryParameters;
 		}
 
 		final List combinedResults = new ArrayList();
 		final IdentitySet distinction = new IdentitySet();
 		int includedCount = -1;
 		translator_loop:
 		for ( QueryTranslator translator : translators ) {
 			final List tmp = translator.list( session, queryParametersToUse );
 			if ( needsLimit ) {
 				// NOTE : firstRow is zero-based
 				final int first = queryParameters.getRowSelection().getFirstRow() == null
 						? 0
 						: queryParameters.getRowSelection().getFirstRow();
 				final int max = queryParameters.getRowSelection().getMaxRows() == null
 						? -1
 						: queryParameters.getRowSelection().getMaxRows();
 				for ( final Object result : tmp ) {
 					if ( !distinction.add( result ) ) {
 						continue;
 					}
 					includedCount++;
 					if ( includedCount < first ) {
 						continue;
 					}
 					combinedResults.add( result );
 					if ( max >= 0 && includedCount > max ) {
 						// break the outer loop !!!
 						break translator_loop;
 					}
 				}
 			}
 			else {
 				combinedResults.addAll( tmp );
 			}
 		}
 		return combinedResults;
 	}
 
 	/**
 	 * Coordinates the efforts to perform an iterate across all the included query translators.
 	 *
 	 * @param queryParameters The query parameters
 	 * @param session The session
 	 *
 	 * @return The query result iterator
 	 *
 	 * @throws HibernateException Indicates a problem performing the query
 	 */
 	@SuppressWarnings("unchecked")
 	public Iterator performIterate(
 			QueryParameters queryParameters,
 			EventSource session) throws HibernateException {
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Iterate: {0}", getSourceQuery() );
 			queryParameters.traceParameters( session.getFactory() );
 		}
 		if ( translators.length == 0 ) {
 			return EmptyIterator.INSTANCE;
 		}
 
 		final boolean many = translators.length > 1;
 		Iterator[] results = null;
 		if ( many ) {
 			results = new Iterator[translators.length];
 		}
 
 		Iterator result = null;
 		for ( int i = 0; i < translators.length; i++ ) {
 			result = translators[i].iterate( queryParameters, session );
 			if ( many ) {
 				results[i] = result;
 			}
 		}
 
 		return many ? new JoinedIterator( results ) : result;
 	}
 
 	/**
 	 * Coordinates the efforts to perform a scroll across all the included query translators.
 	 *
 	 * @param queryParameters The query parameters
 	 * @param session The session
 	 *
 	 * @return The query result iterator
 	 *
 	 * @throws HibernateException Indicates a problem performing the query
 	 */
 	public ScrollableResults performScroll(
 			QueryParameters queryParameters,
 			SessionImplementor session) throws HibernateException {
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Iterate: {0}", getSourceQuery() );
 			queryParameters.traceParameters( session.getFactory() );
 		}
 		if ( translators.length != 1 ) {
 			throw new QueryException( "implicit polymorphism not supported for scroll() queries" );
 		}
 		if ( queryParameters.getRowSelection().definesLimits() && translators[0].containsCollectionFetches() ) {
 			throw new QueryException( "firstResult/maxResults not supported in conjunction with scroll() of a query containing collection fetches" );
 		}
 
 		return translators[0].scroll( queryParameters, session );
 	}
 
 	/**
 	 * Coordinates the efforts to perform an execution across all the included query translators.
 	 *
 	 * @param queryParameters The query parameters
 	 * @param session The session
 	 *
 	 * @return The aggregated "affected row" count
 	 *
 	 * @throws HibernateException Indicates a problem performing the execution
 	 */
 	public int performExecuteUpdate(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException {
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Execute update: {0}", getSourceQuery() );
 			queryParameters.traceParameters( session.getFactory() );
 		}
 		if ( translators.length != 1 ) {
 			LOG.splitQueries( getSourceQuery(), translators.length );
 		}
 		int result = 0;
 		for ( QueryTranslator translator : translators ) {
 			result += translator.executeUpdate( queryParameters, session );
 		}
 		return result;
 	}
 
 	private ParameterMetadata buildParameterMetadata(ParameterTranslations parameterTranslations, String hql) {
 		final long start = System.currentTimeMillis();
 		final ParamLocationRecognizer recognizer = ParamLocationRecognizer.parseLocations( hql );
 		final long end = System.currentTimeMillis();
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "HQL param location recognition took {0} mills ({1})", ( end - start ), hql );
 		}
 
 		int ordinalParamCount = parameterTranslations.getOrdinalParameterCount();
 		final int[] locations = ArrayHelper.toIntArray( recognizer.getOrdinalParameterLocationList() );
 		if ( parameterTranslations.supportsOrdinalParameterMetadata() && locations.length != ordinalParamCount ) {
 			throw new HibernateException( "ordinal parameter mismatch" );
 		}
 		ordinalParamCount = locations.length;
 
 		final OrdinalParameterDescriptor[] ordinalParamDescriptors = new OrdinalParameterDescriptor[ordinalParamCount];
 		for ( int i = 1; i <= ordinalParamCount; i++ ) {
 			ordinalParamDescriptors[ i - 1 ] = new OrdinalParameterDescriptor(
 					i,
 					parameterTranslations.supportsOrdinalParameterMetadata()
 							? parameterTranslations.getOrdinalParameterExpectedType( i )
 							: null,
 					locations[ i - 1 ]
 			);
 		}
 
 		final Map<String, NamedParameterDescriptor> namedParamDescriptorMap = new HashMap<String, NamedParameterDescriptor>();
 		final Map<String, ParamLocationRecognizer.NamedParameterDescription> map = recognizer.getNamedParameterDescriptionMap();
 		for ( final String name : map.keySet() ) {
 			final ParamLocationRecognizer.NamedParameterDescription description = map.get( name );
 			namedParamDescriptorMap.put(
 					name,
 					new NamedParameterDescriptor(
 							name,
 							parameterTranslations.getNamedParameterExpectedType( name ),
 							description.buildPositionsArray(),
 							description.isJpaStyle()
 					)
 			);
 		}
 		return new ParameterMetadata( ordinalParamDescriptors, namedParamDescriptorMap );
 	}
 
 	/**
 	 * Access to the underlying translators associated with this query
 	 *
 	 * @return The translators
 	 */
 	public QueryTranslator[] getTranslators() {
 		final QueryTranslator[] copy = new QueryTranslator[translators.length];
 		System.arraycopy( translators, 0, copy, 0, copy.length );
 		return copy;
 	}
 
 	public Class getDynamicInstantiationResultType() {
 		return translators[0].getDynamicInstantiationResultType();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/ParameterMetadata.java b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/ParameterMetadata.java
index d9c1ce5f26..19b4b77b77 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/ParameterMetadata.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/ParameterMetadata.java
@@ -1,183 +1,183 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.query.spi;
 
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.QueryParameterException;
 import org.hibernate.type.Type;
 
 /**
  * Encapsulates metadata about parameters encountered within a query.
  *
  * @author Steve Ebersole
  */
 public class ParameterMetadata implements Serializable {
 	private static final OrdinalParameterDescriptor[] EMPTY_ORDINALS = new OrdinalParameterDescriptor[0];
 
 	private final OrdinalParameterDescriptor[] ordinalDescriptors;
 	private final Map<String,NamedParameterDescriptor> namedDescriptorMap;
 
 	/**
 	 * Instantiates a ParameterMetadata container.
 	 *
 	 * @param ordinalDescriptors Descriptors of the ordinal parameters
 	 * @param namedDescriptorMap Descriptors of the named parameters
 	 */
 	public ParameterMetadata(
 			OrdinalParameterDescriptor[] ordinalDescriptors,
 			Map<String,NamedParameterDescriptor> namedDescriptorMap) {
 		if ( ordinalDescriptors == null ) {
 			this.ordinalDescriptors = EMPTY_ORDINALS;
 		}
 		else {
 			final OrdinalParameterDescriptor[] copy = new OrdinalParameterDescriptor[ ordinalDescriptors.length ];
 			System.arraycopy( ordinalDescriptors, 0, copy, 0, ordinalDescriptors.length );
 			this.ordinalDescriptors = copy;
 		}
 
 		if ( namedDescriptorMap == null ) {
 			this.namedDescriptorMap = java.util.Collections.emptyMap();
 		}
 		else {
 			final int size = (int) ( ( namedDescriptorMap.size() / .75 ) + 1 );
 			final Map<String,NamedParameterDescriptor> copy = new HashMap<String,NamedParameterDescriptor>( size );
 			copy.putAll( namedDescriptorMap );
 			this.namedDescriptorMap = java.util.Collections.unmodifiableMap( copy );
 		}
 	}
 
 	public int getOrdinalParameterCount() {
 		return ordinalDescriptors.length;
 	}
 
 	/**
 	 * Get the descriptor for an ordinal parameter given its position
 	 *
 	 * @param position The position (1 based)
 	 *
 	 * @return The ordinal parameter descriptor
 	 *
 	 * @throws QueryParameterException If the position is out of range
 	 */
 	public OrdinalParameterDescriptor getOrdinalParameterDescriptor(int position) {
 		if ( position < 1 || position > ordinalDescriptors.length ) {
 			throw new QueryParameterException(
 					"Position beyond number of declared ordinal parameters. " +
 							"Remember that ordinal parameters are 1-based! Position: " + position
 			);
 		}
 		return ordinalDescriptors[position - 1];
 	}
 
 	/**
 	 * Deprecated.
 	 *
 	 * @param position The position
 	 *
 	 * @return The type
 	 *
 	 * @deprecated Use {@link OrdinalParameterDescriptor#getExpectedType()} from the
 	 * {@link #getOrdinalParameterDescriptor} return instead
 	 */
 	@Deprecated
 	public Type getOrdinalParameterExpectedType(int position) {
 		return getOrdinalParameterDescriptor( position ).getExpectedType();
 	}
 
 	/**
 	 * Deprecated.
 	 *
 	 * @param position The position
 	 *
 	 * @return The source location
 	 *
 	 * @deprecated Use {@link OrdinalParameterDescriptor#getSourceLocation()} from the
 	 * {@link #getOrdinalParameterDescriptor} return instead
 	 */
 	@Deprecated
 	public int getOrdinalParameterSourceLocation(int position) {
 		return getOrdinalParameterDescriptor( position ).getSourceLocation();
 	}
 
 	/**
 	 * Access to the names of all named parameters
 	 *
 	 * @return The named parameter names
 	 */
-	public Set getNamedParameterNames() {
+	public Set<String> getNamedParameterNames() {
 		return namedDescriptorMap.keySet();
 	}
 
 	/**
 	 * Get the descriptor for a named parameter given the name
 	 *
 	 * @param name The name of the parameter to locate
 	 *
 	 * @return The named parameter descriptor
 	 *
 	 * @throws QueryParameterException If the name could not be resolved to a named parameter
 	 */
 	public NamedParameterDescriptor getNamedParameterDescriptor(String name) {
 		final NamedParameterDescriptor meta = namedDescriptorMap.get( name );
 		if ( meta == null ) {
 			throw new QueryParameterException( "could not locate named parameter [" + name + "]" );
 		}
 		return meta;
 	}
 
 	/**
 	 * Deprecated.
 	 *
 	 * @param name The name of the parameter
 	 *
 	 * @return The type
 	 *
 	 * @deprecated Use {@link NamedParameterDescriptor#getExpectedType()} from the
 	 * {@link #getNamedParameterDescriptor} return instead
 	 */
 	@Deprecated
 	public Type getNamedParameterExpectedType(String name) {
 		return getNamedParameterDescriptor( name ).getExpectedType();
 	}
 
 	/**
 	 * Deprecated.
 	 *
 	 * @param name The name of the parameter
 	 *
 	 * @return The type
 	 *
 	 * @deprecated Use {@link NamedParameterDescriptor#getSourceLocations()} from the
 	 * {@link #getNamedParameterDescriptor} return instead
 	 */
 	@Deprecated
 	public int[] getNamedParameterSourceLocations(String name) {
 		return getNamedParameterDescriptor( name ).getSourceLocations();
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/QueryPlanCache.java b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/QueryPlanCache.java
index 35c07194e9..19b4e16845 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/query/spi/QueryPlanCache.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/query/spi/QueryPlanCache.java
@@ -1,427 +1,426 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.query.spi;
 
 import java.io.Serializable;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.Filter;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.query.spi.sql.NativeSQLQuerySpecification;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.FilterImpl;
 import org.hibernate.internal.util.collections.BoundedConcurrentHashMap;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 
 /**
  * Acts as a cache for compiled query plans, as well as query-parameter metadata.
  *
  * @see Environment#QUERY_PLAN_CACHE_PARAMETER_METADATA_MAX_SIZE
  * @see Environment#QUERY_PLAN_CACHE_MAX_SIZE
  *
  * @author Steve Ebersole
  */
 public class QueryPlanCache implements Serializable {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( QueryPlanCache.class );
 
 	/**
 	 * The default strong reference count.
 	 */
 	public static final int DEFAULT_PARAMETER_METADATA_MAX_COUNT = 128;
 	/**
 	 * The default soft reference count.
 	 */
 	public static final int DEFAULT_QUERY_PLAN_MAX_COUNT = 2048;
 
 	private final SessionFactoryImplementor factory;
 
 	/**
 	 * the cache of the actual plans...
 	 */
 	private final BoundedConcurrentHashMap queryPlanCache;
 
 	/**
 	 * simple cache of param metadata based on query string.  Ideally, the original "user-supplied query"
 	 * string should be used to obtain this metadata (i.e., not the para-list-expanded query string) to avoid
 	 * unnecessary cache entries.
 	 * <p></p>
 	 * Used solely for caching param metadata for native-sql queries, see {@link #getSQLParameterMetadata} for a
 	 * discussion as to why...
 	 */
 	private final BoundedConcurrentHashMap<String,ParameterMetadata> parameterMetadataCache;
 
 	/**
 	 * Constructs the QueryPlanCache to be used by the given SessionFactory
 	 *
 	 * @param factory The SessionFactory
 	 */
 	@SuppressWarnings("deprecation")
 	public QueryPlanCache(final SessionFactoryImplementor factory) {
 		this.factory = factory;
 
 		Integer maxParameterMetadataCount = ConfigurationHelper.getInteger(
 				Environment.QUERY_PLAN_CACHE_PARAMETER_METADATA_MAX_SIZE,
 				factory.getProperties()
 		);
 		if ( maxParameterMetadataCount == null ) {
 			maxParameterMetadataCount = ConfigurationHelper.getInt(
 					Environment.QUERY_PLAN_CACHE_MAX_STRONG_REFERENCES,
 					factory.getProperties(),
 					DEFAULT_PARAMETER_METADATA_MAX_COUNT
 			);
 		}
 		Integer maxQueryPlanCount = ConfigurationHelper.getInteger(
 				Environment.QUERY_PLAN_CACHE_MAX_SIZE,
 				factory.getProperties()
 		);
 		if ( maxQueryPlanCount == null ) {
 			maxQueryPlanCount = ConfigurationHelper.getInt(
 					Environment.QUERY_PLAN_CACHE_MAX_SOFT_REFERENCES,
 					factory.getProperties(),
 					DEFAULT_QUERY_PLAN_MAX_COUNT
 			);
 		}
 
 		queryPlanCache = new BoundedConcurrentHashMap( maxQueryPlanCount, 20, BoundedConcurrentHashMap.Eviction.LIRS );
 		parameterMetadataCache = new BoundedConcurrentHashMap<String, ParameterMetadata>(
 				maxParameterMetadataCount,
 				20,
 				BoundedConcurrentHashMap.Eviction.LIRS
 		);
 
 	}
 
 	/**
 	 * Obtain the parameter metadata for given native-sql query.
 	 * <p/>
 	 * for native-sql queries, the param metadata is determined outside any relation to a query plan, because
 	 * query plan creation and/or retrieval for a native-sql query depends on all of the return types having been
 	 * set, which might not be the case up-front when param metadata would be most useful
 	 *
 	 * @param query The query
 	 * @return The parameter metadata
 	 */
 	public ParameterMetadata getSQLParameterMetadata(final String query)  {
 		ParameterMetadata value = parameterMetadataCache.get( query );
 		if ( value == null ) {
 			value = buildParameterMetadata( query );
 			parameterMetadataCache.putIfAbsent( query, value );
 		}
 		return value;
 	}
 	
 	private ParameterMetadata buildParameterMetadata(String query){
 		final ParamLocationRecognizer recognizer = ParamLocationRecognizer.parseLocations( query );
 
 		final int size = recognizer.getOrdinalParameterLocationList().size();
 		final OrdinalParameterDescriptor[] ordinalDescriptors = new OrdinalParameterDescriptor[ size ];
 		for ( int i = 0; i < size; i++ ) {
 			final Integer position = recognizer.getOrdinalParameterLocationList().get( i );
 			ordinalDescriptors[i] = new OrdinalParameterDescriptor( i, null, position );
 		}
 
 		final Map<String, NamedParameterDescriptor> namedParamDescriptorMap = new HashMap<String, NamedParameterDescriptor>();
 		final Map<String, ParamLocationRecognizer.NamedParameterDescription> map = recognizer.getNamedParameterDescriptionMap();
 		for ( final String name : map.keySet() ) {
 			final ParamLocationRecognizer.NamedParameterDescription description = map.get( name );
 			namedParamDescriptorMap.put(
 					name,
 					new NamedParameterDescriptor(
 							name,
 							null,
 							description.buildPositionsArray(),
 							description.isJpaStyle()
 					)
 			);
 		}
 		return new ParameterMetadata( ordinalDescriptors, namedParamDescriptorMap );
 	}
 
 	/**
 	 * Get the query plan for the given HQL query, creating it and caching it if not already cached
 	 *
 	 * @param queryString The HQL query string
 	 * @param shallow Whether the execution will be shallow
 	 * @param enabledFilters The filters enabled on the Session
 	 *
 	 * @return The query plan
 	 *
 	 * @throws QueryException Indicates a problem translating the query
 	 * @throws MappingException Indicates a problem translating the query
 	 */
 	@SuppressWarnings("unchecked")
 	public HQLQueryPlan getHQLQueryPlan(String queryString, boolean shallow, Map<String,Filter> enabledFilters)
 			throws QueryException, MappingException {
 		final HQLQueryPlanKey key = new HQLQueryPlanKey( queryString, shallow, enabledFilters );
 		HQLQueryPlan value = (HQLQueryPlan) queryPlanCache.get( key );
 		if ( value == null ) {
 			LOG.tracev( "Unable to locate HQL query plan in cache; generating ({0})", queryString );
 			value = new HQLQueryPlan( queryString, shallow, enabledFilters, factory );
 			queryPlanCache.putIfAbsent( key, value );
 		} else {
 			LOG.tracev( "Located HQL query plan in cache ({0})", queryString );
 		}
 		return value;
 	}
 
 	/**
 	 * Get the query plan for the given collection HQL filter fragment, creating it and caching it if not already cached
 	 *
 	 * @param filterString The HQL filter fragment
 	 * @param collectionRole The collection being filtered
 	 * @param shallow Whether the execution will be shallow
 	 * @param enabledFilters The filters enabled on the Session
 	 *
 	 * @return The query plan
 	 *
 	 * @throws QueryException Indicates a problem translating the query
 	 * @throws MappingException Indicates a problem translating the query
 	 */
 	@SuppressWarnings("unchecked")
 	public FilterQueryPlan getFilterQueryPlan(
 			String filterString,
 			String collectionRole,
 			boolean shallow,
 			Map<String,Filter> enabledFilters) throws QueryException, MappingException {
 		final FilterQueryPlanKey key =  new FilterQueryPlanKey( filterString, collectionRole, shallow, enabledFilters );
 		FilterQueryPlan value = (FilterQueryPlan) queryPlanCache.get( key );
 		if ( value == null ) {
 			LOG.tracev(
 					"Unable to locate collection-filter query plan in cache; generating ({0} : {1} )",
 					collectionRole,
 					filterString
 			);
 			value = new FilterQueryPlan( filterString, collectionRole, shallow, enabledFilters,factory );
 			queryPlanCache.putIfAbsent( key, value );
 		}
 		else {
 			LOG.tracev( "Located collection-filter query plan in cache ({0} : {1})", collectionRole, filterString );
 		}
 		return value;
 	}
 
 	/**
 	 * Get the query plan for a native SQL query, creating it and caching it if not already cached
 	 *
 	 * @param spec The native SQL query specification
 	 *
 	 * @return The query plan
 	 *
 	 * @throws QueryException Indicates a problem translating the query
 	 * @throws MappingException Indicates a problem translating the query
 	 */
 	@SuppressWarnings("unchecked")
 	public NativeSQLQueryPlan getNativeSQLQueryPlan(final NativeSQLQuerySpecification spec) {
 		NativeSQLQueryPlan value = (NativeSQLQueryPlan) queryPlanCache.get( spec );
 		if ( value == null ) {
 			LOG.tracev( "Unable to locate native-sql query plan in cache; generating ({0})", spec.getQueryString() );
 			value = new NativeSQLQueryPlan( spec, factory);
 			queryPlanCache.putIfAbsent( spec, value );
 		}
 		else {
 			LOG.tracev( "Located native-sql query plan in cache ({0})", spec.getQueryString() );
 		}
 		return value;
 	}
 
 	/**
 	 * clean up QueryPlanCache when SessionFactory is closed
 	 */
 	public void cleanup() {
 		LOG.trace( "Cleaning QueryPlan Cache" );
 		queryPlanCache.clear();
 		parameterMetadataCache.clear();
 	}
 
 	private static class HQLQueryPlanKey implements Serializable {
 		private final String query;
 		private final boolean shallow;
 		private final Set<DynamicFilterKey> filterKeys;
 		private final int hashCode;
 
 		public HQLQueryPlanKey(String query, boolean shallow, Map enabledFilters) {
 			this.query = query;
 			this.shallow = shallow;
 			if ( CollectionHelper.isEmpty( enabledFilters ) ) {
 				filterKeys = Collections.emptySet();
 			}
 			else {
 				final Set<DynamicFilterKey> tmp = new HashSet<DynamicFilterKey>(
 						CollectionHelper.determineProperSizing( enabledFilters ),
 						CollectionHelper.LOAD_FACTOR
 				);
 				for ( Object o : enabledFilters.values() ) {
 					tmp.add( new DynamicFilterKey( (FilterImpl) o ) );
 				}
 				this.filterKeys = Collections.unmodifiableSet( tmp );
 			}
 
 			int hash = query.hashCode();
 			hash = 29 * hash + ( shallow ? 1 : 0 );
 			hash = 29 * hash + filterKeys.hashCode();
 			this.hashCode = hash;
 		}
 
 		@Override
 		public boolean equals(Object o) {
 			if ( this == o ) {
 				return true;
 			}
 			if ( o == null || getClass() != o.getClass() ) {
 				return false;
 			}
 
 			final HQLQueryPlanKey that = (HQLQueryPlanKey) o;
 
 			return shallow == that.shallow
 					&& filterKeys.equals( that.filterKeys )
 					&& query.equals( that.query );
 
 		}
 
 		@Override
 		public int hashCode() {
 			return hashCode;
 		}
 	}
 
 	private static class DynamicFilterKey implements Serializable {
 		private final String filterName;
 		private final Map<String,Integer> parameterMetadata;
 		private final int hashCode;
 
-		@SuppressWarnings({ "UnnecessaryBoxing" })
 		private DynamicFilterKey(FilterImpl filter) {
 			this.filterName = filter.getName();
 			if ( filter.getParameters().isEmpty() ) {
 				parameterMetadata = Collections.emptyMap();
 			}
 			else {
 				parameterMetadata = new HashMap<String,Integer>(
 						CollectionHelper.determineProperSizing( filter.getParameters() ),
 						CollectionHelper.LOAD_FACTOR
 				);
 				for ( Object o : filter.getParameters().entrySet() ) {
 					final Map.Entry entry = (Map.Entry) o;
 					final String key = (String) entry.getKey();
 					final Integer valueCount;
 					if ( Collection.class.isInstance( entry.getValue() ) ) {
 						valueCount = ( (Collection) entry.getValue() ).size();
 					}
 					else {
 						valueCount = 1;
 					}
 					parameterMetadata.put( key, valueCount );
 				}
 			}
 
 			int hash = filterName.hashCode();
 			hash = 31 * hash + parameterMetadata.hashCode();
 			this.hashCode = hash;
 		}
 
 		@Override
 		public boolean equals(Object o) {
 			if ( this == o ) {
 				return true;
 			}
 			if ( o == null || getClass() != o.getClass() ) {
 				return false;
 			}
 
 			final DynamicFilterKey that = (DynamicFilterKey) o;
 			return filterName.equals( that.filterName )
 					&& parameterMetadata.equals( that.parameterMetadata );
 
 		}
 
 		@Override
 		public int hashCode() {
 			return hashCode;
 		}
 	}
 
 	private static class FilterQueryPlanKey implements Serializable {
 		private final String query;
 		private final String collectionRole;
 		private final boolean shallow;
 		private final Set<String> filterNames;
 		private final int hashCode;
 
 		@SuppressWarnings({ "unchecked" })
 		public FilterQueryPlanKey(String query, String collectionRole, boolean shallow, Map enabledFilters) {
 			this.query = query;
 			this.collectionRole = collectionRole;
 			this.shallow = shallow;
 
 			if ( CollectionHelper.isEmpty( enabledFilters ) ) {
 				this.filterNames = Collections.emptySet();
 			}
 			else {
 				final Set<String> tmp = new HashSet<String>();
 				tmp.addAll( enabledFilters.keySet() );
 				this.filterNames = Collections.unmodifiableSet( tmp );
 
 			}
 
 			int hash = query.hashCode();
 			hash = 29 * hash + collectionRole.hashCode();
 			hash = 29 * hash + ( shallow ? 1 : 0 );
 			hash = 29 * hash + filterNames.hashCode();
 			this.hashCode = hash;
 		}
 
 		@Override
 		public boolean equals(Object o) {
 			if ( this == o ) {
 				return true;
 			}
 			if ( o == null || getClass() != o.getClass() ) {
 				return false;
 			}
 
 			final FilterQueryPlanKey that = (FilterQueryPlanKey) o;
 			return shallow == that.shallow
 					&& filterNames.equals( that.filterNames )
 					&& query.equals( that.query )
 					&& collectionRole.equals( that.collectionRole );
 
 		}
 
 		@Override
 		public int hashCode() {
 			return hashCode;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/ActionQueue.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/ActionQueue.java
index 99f8dc6933..bc5ad3b20d 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/ActionQueue.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/ActionQueue.java
@@ -1,883 +1,881 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Queue;
 import java.util.Set;
 import java.util.concurrent.ConcurrentLinkedQueue;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.PropertyValueException;
 import org.hibernate.action.internal.AbstractEntityInsertAction;
 import org.hibernate.action.internal.BulkOperationCleanupAction;
 import org.hibernate.action.internal.CollectionAction;
 import org.hibernate.action.internal.CollectionRecreateAction;
 import org.hibernate.action.internal.CollectionRemoveAction;
 import org.hibernate.action.internal.CollectionUpdateAction;
 import org.hibernate.action.internal.EntityAction;
 import org.hibernate.action.internal.EntityDeleteAction;
 import org.hibernate.action.internal.EntityIdentityInsertAction;
 import org.hibernate.action.internal.EntityInsertAction;
 import org.hibernate.action.internal.EntityUpdateAction;
 import org.hibernate.action.internal.QueuedOperationCollectionAction;
 import org.hibernate.action.internal.UnresolvedEntityInsertActions;
 import org.hibernate.action.spi.AfterTransactionCompletionProcess;
 import org.hibernate.action.spi.BeforeTransactionCompletionProcess;
 import org.hibernate.action.spi.Executable;
 import org.hibernate.cache.CacheException;
 import org.hibernate.engine.internal.NonNullableTransientDependencies;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.type.Type;
 
 /**
  * Responsible for maintaining the queue of actions related to events.
  * 
  * The ActionQueue holds the DML operations queued as part of a session's
  * transactional-write-behind semantics.  DML operations are queued here
  * until a flush forces them to be executed against the database.
  *
  * @author Steve Ebersole
  * @author Gail Badner
  */
 public class ActionQueue {
 
 	static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, ActionQueue.class.getName());
 	private static final int INIT_QUEUE_LIST_SIZE = 5;
 
 	private SessionImplementor session;
 
 	// Object insertions, updates, and deletions have list semantics because
 	// they must happen in the right order so as to respect referential
 	// integrity
 	private UnresolvedEntityInsertActions unresolvedInsertions;
 	private ArrayList insertions;
 	private ArrayList<EntityDeleteAction> deletions;
 	private ArrayList updates;
 	// Actually the semantics of the next three are really "Bag"
 	// Note that, unlike objects, collection insertions, updates,
 	// deletions are not really remembered between flushes. We
 	// just re-use the same Lists for convenience.
 	private ArrayList collectionCreations;
 	private ArrayList collectionUpdates;
 	private ArrayList collectionQueuedOps;
 	private ArrayList collectionRemovals;
 
 	private AfterTransactionCompletionProcessQueue afterTransactionProcesses;
 	private BeforeTransactionCompletionProcessQueue beforeTransactionProcesses;
 
 	/**
 	 * Constructs an action queue bound to the given session.
 	 *
 	 * @param session The session "owning" this queue.
 	 */
 	public ActionQueue(SessionImplementor session) {
 		this.session = session;
 		init();
 	}
 
 	private void init() {
 		unresolvedInsertions = new UnresolvedEntityInsertActions();
 		insertions = new ArrayList<AbstractEntityInsertAction>( INIT_QUEUE_LIST_SIZE );
 		deletions = new ArrayList<EntityDeleteAction>( INIT_QUEUE_LIST_SIZE );
 		updates = new ArrayList( INIT_QUEUE_LIST_SIZE );
 
 		collectionCreations = new ArrayList( INIT_QUEUE_LIST_SIZE );
 		collectionRemovals = new ArrayList( INIT_QUEUE_LIST_SIZE );
 		collectionUpdates = new ArrayList( INIT_QUEUE_LIST_SIZE );
 		collectionQueuedOps = new ArrayList( INIT_QUEUE_LIST_SIZE );
 
 		afterTransactionProcesses = new AfterTransactionCompletionProcessQueue( session );
 		beforeTransactionProcesses = new BeforeTransactionCompletionProcessQueue( session );
 	}
 
 	public void clear() {
 		updates.clear();
 		insertions.clear();
 		deletions.clear();
 
 		collectionCreations.clear();
 		collectionRemovals.clear();
 		collectionUpdates.clear();
 		collectionQueuedOps.clear();
 
 		unresolvedInsertions.clear();
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(EntityInsertAction action) {
 		LOG.tracev( "Adding an EntityInsertAction for [{0}] object", action.getEntityName() );
 		addInsertAction( action );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(EntityDeleteAction action) {
 		deletions.add( action );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(EntityUpdateAction action) {
 		updates.add( action );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(CollectionRecreateAction action) {
 		collectionCreations.add( action );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(CollectionRemoveAction action) {
 		collectionRemovals.add( action );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(CollectionUpdateAction action) {
 		collectionUpdates.add( action );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(QueuedOperationCollectionAction action) {
 		collectionQueuedOps.add( action );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void addAction(EntityIdentityInsertAction insert) {
 		LOG.tracev( "Adding an EntityIdentityInsertAction for [{0}] object", insert.getEntityName() );
 		addInsertAction( insert );
 	}
 
 	private void addInsertAction(AbstractEntityInsertAction insert) {
 		if ( insert.isEarlyInsert() ) {
 			// For early inserts, must execute inserts before finding non-nullable transient entities.
 			// TODO: find out why this is necessary
 			LOG.tracev(
 					"Executing inserts before finding non-nullable transient entities for early insert: [{0}]",
 					insert
 			);
 			executeInserts();
 		}
 		NonNullableTransientDependencies nonNullableTransientDependencies = insert.findNonNullableTransientEntities();
 		if ( nonNullableTransientDependencies == null ) {
 			LOG.tracev( "Adding insert with no non-nullable, transient entities: [{0}]", insert);
 			addResolvedEntityInsertAction( insert );
 		}
 		else {
 			if ( LOG.isTraceEnabled() ) {
 				LOG.tracev(
 						"Adding insert with non-nullable, transient entities; insert=[{0}], dependencies=[{1}]",
 						insert,
 						nonNullableTransientDependencies.toLoggableString( insert.getSession() )
 				);
 			}
 			unresolvedInsertions.addUnresolvedEntityInsertAction( insert, nonNullableTransientDependencies );
 		}
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private void addResolvedEntityInsertAction(AbstractEntityInsertAction insert) {
 		if ( insert.isEarlyInsert() ) {
 			LOG.trace( "Executing insertions before resolved early-insert" );
 			executeInserts();
 			LOG.debug( "Executing identity-insert immediately" );
 			execute( insert );
 		}
 		else {
 			LOG.trace( "Adding resolved non-early insert action." );
 			insertions.add( insert );
 		}
 		insert.makeEntityManaged();
 		for ( AbstractEntityInsertAction resolvedAction :
 				unresolvedInsertions.resolveDependentActions( insert.getInstance(), session ) ) {
 			addResolvedEntityInsertAction( resolvedAction );
 		}
 	}
 
 	/**
 	 * Are there unresolved entity insert actions that depend on non-nullable
 	 * associations with a transient entity?
 	 * @return true, if there are unresolved entity insert actions that depend on
 	 *               non-nullable associations with a transient entity;
 	 *         false, otherwise
 	 */
 	public boolean hasUnresolvedEntityInsertActions() {
 		return ! unresolvedInsertions.isEmpty();
 	}
 
 	/**
 	 * Throws {@link org.hibernate.PropertyValueException} if there are any unresolved
 	 * entity insert actions that depend on non-nullable associations with
 	 * a transient entity. This method should be called on completion of
 	 * an operation (after all cascades are completed) that saves an entity.
 	 *
 	 * @throws org.hibernate.PropertyValueException if there are any unresolved entity
 	 * insert actions; {@link org.hibernate.PropertyValueException#getEntityName()}
 	 * and {@link org.hibernate.PropertyValueException#getPropertyName()} will
 	 * return the entity name and property value for the first unresolved
 	 * entity insert action.
 	 */
 	public void checkNoUnresolvedActionsAfterOperation() throws PropertyValueException {
 		unresolvedInsertions.checkNoUnresolvedActionsAfterOperation();
 	}
 
 	public void addAction(BulkOperationCleanupAction cleanupAction) {
 		registerCleanupActions( cleanupAction );
 	}
 
 	public void registerProcess(AfterTransactionCompletionProcess process) {
 		afterTransactionProcesses.register( process );
 	}
 
 	public void registerProcess(BeforeTransactionCompletionProcess process) {
 		beforeTransactionProcesses.register( process );
 	}
 
 	/**
 	 * Perform all currently queued entity-insertion actions.
 	 *
 	 * @throws HibernateException error executing queued insertion actions.
 	 */
 	public void executeInserts() throws HibernateException {
 		executeActions( insertions );
 	}
 
 	/**
 	 * Perform all currently queued actions.
 	 *
 	 * @throws HibernateException error executing queued actions.
 	 */
 	public void executeActions() throws HibernateException {
 		if ( ! unresolvedInsertions.isEmpty() ) {
 			throw new IllegalStateException(
 					"About to execute actions, but there are unresolved entity insert actions."
 			);
 		}
 		executeActions( insertions );
 		executeActions( updates );
 		// do before actions are handled in the other collection queues
 		executeActions( collectionQueuedOps );
 		executeActions( collectionRemovals );
 		executeActions( collectionUpdates );
 		executeActions( collectionCreations );
 		executeActions( deletions );
 	}
 
 	/**
 	 * Prepares the internal action queues for execution.
 	 *
 	 * @throws HibernateException error preparing actions.
 	 */
 	public void prepareActions() throws HibernateException {
 		prepareActions( collectionRemovals );
 		prepareActions( collectionUpdates );
 		prepareActions( collectionCreations );
 		prepareActions( collectionQueuedOps );
 	}
 
 	/**
 	 * Performs cleanup of any held cache softlocks.
 	 *
 	 * @param success Was the transaction successful.
 	 */
 	public void afterTransactionCompletion(boolean success) {
 		afterTransactionProcesses.afterTransactionCompletion( success );
 	}
 
 	/**
 	 * Execute any registered {@link org.hibernate.action.spi.BeforeTransactionCompletionProcess}
 	 */
 	public void beforeTransactionCompletion() {
 		beforeTransactionProcesses.beforeTransactionCompletion();
 	}
 
 	/**
 	 * Check whether the given tables/query-spaces are to be executed against
 	 * given the currently queued actions.
 	 *
 	 * @param tables The table/query-spaces to check.
 	 *
 	 * @return True if we contain pending actions against any of the given
 	 *         tables; false otherwise.
 	 */
 	public boolean areTablesToBeUpdated(Set tables) {
 		return areTablesToUpdated( updates, tables ) ||
 				areTablesToUpdated( insertions, tables ) ||
 				areTablesToUpdated( unresolvedInsertions.getDependentEntityInsertActions(), tables ) ||
 				areTablesToUpdated( deletions, tables ) ||
 				areTablesToUpdated( collectionUpdates, tables ) ||
 				areTablesToUpdated( collectionCreations, tables ) ||
 				areTablesToUpdated( collectionQueuedOps, tables ) ||
 				areTablesToUpdated( collectionRemovals, tables );
 	}
 
 	/**
 	 * Check whether any insertion or deletion actions are currently queued.
 	 *
 	 * @return True if insertions or deletions are currently queued; false otherwise.
 	 */
 	public boolean areInsertionsOrDeletionsQueued() {
 		return ( insertions.size() > 0 || ! unresolvedInsertions.isEmpty() || deletions.size() > 0 );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private static boolean areTablesToUpdated(Iterable actions, Set tableSpaces) {
 		for ( Executable action : (Iterable<Executable>) actions ) {
 			final Serializable[] spaces = action.getPropertySpaces();
 			for ( Serializable space : spaces ) {
 				if ( tableSpaces.contains( space ) ) {
 					LOG.debugf( "Changes must be flushed to space: %s", space );
 					return true;
 				}
 			}
 		}
 		return false;
 	}
 
 	private void executeActions(List list) throws HibernateException {
 		for ( Object aList : list ) {
 			execute( (Executable) aList );
 		}
 		list.clear();
 		session.getTransactionCoordinator().getJdbcCoordinator().executeBatch();
 	}
 
 	public void execute(Executable executable) {
 		try {
 			executable.execute();
 		}
 		finally {
 			registerCleanupActions( executable );
 		}
 	}
 
 	private void registerCleanupActions(Executable executable) {
 		beforeTransactionProcesses.register( executable.getBeforeTransactionCompletionProcess() );
 		if ( session.getFactory().getSettings().isQueryCacheEnabled() ) {
 			final String[] spaces = (String[]) executable.getPropertySpaces();
 			if ( spaces != null && spaces.length > 0 ) { //HHH-6286
 				afterTransactionProcesses.addSpacesToInvalidate( spaces );
 				session.getFactory().getUpdateTimestampsCache().preinvalidate( spaces );
 			}
 		}
 		afterTransactionProcesses.register( executable.getAfterTransactionCompletionProcess() );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private void prepareActions(List queue) throws HibernateException {
 		for ( Executable executable : (List<Executable>) queue ) {
 			executable.beforeExecutions();
 		}
 	}
 
 	/**
 	 * Returns a string representation of the object.
 	 *
 	 * @return a string representation of the object.
 	 */
 	@Override
     public String toString() {
 		return new StringBuilder()
 				.append( "ActionQueue[insertions=" ).append( insertions )
 				.append( " updates=" ).append( updates )
 				.append( " deletions=" ).append( deletions )
 				.append( " collectionCreations=" ).append( collectionCreations )
 				.append( " collectionRemovals=" ).append( collectionRemovals )
 				.append( " collectionUpdates=" ).append( collectionUpdates )
 				.append( " collectionQueuedOps=" ).append( collectionQueuedOps )
 				.append( " unresolvedInsertDependencies=" ).append( unresolvedInsertions )
 				.append( "]" )
 				.toString();
 	}
 
 	public int numberOfCollectionRemovals() {
 		return collectionRemovals.size();
 	}
 
 	public int numberOfCollectionUpdates() {
 		return collectionUpdates.size();
 	}
 
 	public int numberOfCollectionCreations() {
 		return collectionCreations.size();
 	}
 
 	public int numberOfDeletions() {
 		return deletions.size();
 	}
 
 	public int numberOfUpdates() {
 		return updates.size();
 	}
 
 	public int numberOfInsertions() {
 		return insertions.size();
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void sortCollectionActions() {
 		if ( session.getFactory().getSettings().isOrderUpdatesEnabled() ) {
 			//sort the updates by fk
 			java.util.Collections.sort( collectionCreations );
 			java.util.Collections.sort( collectionUpdates );
 			java.util.Collections.sort( collectionQueuedOps );
 			java.util.Collections.sort( collectionRemovals );
 		}
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public void sortActions() {
 		if ( session.getFactory().getSettings().isOrderUpdatesEnabled() ) {
 			//sort the updates by pk
 			java.util.Collections.sort( updates );
 		}
 		if ( session.getFactory().getSettings().isOrderInsertsEnabled() ) {
 			sortInsertActions();
 		}
 	}
 
 	/**
 	 * Order the {@link #insertions} queue such that we group inserts
 	 * against the same entity together (without violating constraints).  The
 	 * original order is generated by cascade order, which in turn is based on
 	 * the directionality of foreign-keys.  So even though we will be changing
 	 * the ordering here, we need to make absolutely certain that we do not
 	 * circumvent this FK ordering to the extent of causing constraint
 	 * violations
 	 */
 	private void sortInsertActions() {
 		new InsertActionSorter().sort();
 	}
 
 	@SuppressWarnings({ "UnusedDeclaration" })
 	public ArrayList cloneDeletions() {
 		return ( ArrayList ) deletions.clone();
 	}
 
 	public void clearFromFlushNeededCheck(int previousCollectionRemovalSize) {
 		collectionCreations.clear();
 		collectionUpdates.clear();
 		collectionQueuedOps.clear();
 		updates.clear();
 		// collection deletions are a special case since update() can add
 		// deletions of collections not loaded by the session.
 		for ( int i = collectionRemovals.size() - 1; i >= previousCollectionRemovalSize; i-- ) {
 			collectionRemovals.remove( i );
 		}
 	}
 
 	@SuppressWarnings({ "UnusedDeclaration" })
 	public boolean hasAfterTransactionActions() {
 		return afterTransactionProcesses.processes.size() > 0;
 	}
 
 	public boolean hasBeforeTransactionActions() {
 		return beforeTransactionProcesses.processes.size() > 0;
 	}
 
 	public boolean hasAnyQueuedActions() {
 		return updates.size() > 0 ||
 				insertions.size() > 0 ||
 				! unresolvedInsertions.isEmpty() ||
 				deletions.size() > 0 ||
 				collectionUpdates.size() > 0 ||
 				collectionQueuedOps.size() > 0 ||
 				collectionRemovals.size() > 0 ||
 				collectionCreations.size() > 0;
 	}
 
 	public void unScheduleDeletion(EntityEntry entry, Object rescuedEntity) {
 		for ( int i = 0; i < deletions.size(); i++ ) {
 			EntityDeleteAction action = deletions.get( i );
 			if ( action.getInstance() == rescuedEntity ) {
 				deletions.remove( i );
 				return;
 			}
 		}
 		throw new AssertionFailure( "Unable to perform un-delete for instance " + entry.getEntityName() );
 	}
 
 	/**
 	 * Used by the owning session to explicitly control serialization of the
 	 * action queue
 	 *
 	 * @param oos The stream to which the action queue should get written
 	 *
 	 * @throws IOException Indicates an error writing to the stream
 	 */
 	public void serialize(ObjectOutputStream oos) throws IOException {
 		LOG.trace( "Serializing action-queue" );
 
 		unresolvedInsertions.serialize( oos );
 
 		int queueSize = insertions.size();
 		LOG.tracev( "Starting serialization of [{0}] insertions entries", queueSize );
 		oos.writeInt( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			oos.writeObject( insertions.get( i ) );
 		}
 
 		queueSize = deletions.size();
 		LOG.tracev( "Starting serialization of [{0}] deletions entries", queueSize );
 		oos.writeInt( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			oos.writeObject( deletions.get( i ) );
 		}
 
 		queueSize = updates.size();
 		LOG.tracev( "Starting serialization of [{0}] updates entries", queueSize );
 		oos.writeInt( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			oos.writeObject( updates.get( i ) );
 		}
 
 		queueSize = collectionUpdates.size();
 		LOG.tracev( "Starting serialization of [{0}] collectionUpdates entries", queueSize );
 		oos.writeInt( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			oos.writeObject( collectionUpdates.get( i ) );
 		}
 
 		queueSize = collectionRemovals.size();
 		LOG.tracev( "Starting serialization of [{0}] collectionRemovals entries", queueSize );
 		oos.writeInt( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			oos.writeObject( collectionRemovals.get( i ) );
 		}
 
 		queueSize = collectionCreations.size();
 		LOG.tracev( "Starting serialization of [{0}] collectionCreations entries", queueSize );
 		oos.writeInt( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			oos.writeObject( collectionCreations.get( i ) );
 		}
 
 		queueSize = collectionQueuedOps.size();
 		LOG.tracev( "Starting serialization of [{0}] collectionQueuedOps entries", queueSize );
 		oos.writeInt( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			oos.writeObject( collectionQueuedOps.get( i ) );
 		}
 	}
 
 	/**
 	 * Used by the owning session to explicitly control deserialization of the
 	 * action queue
 	 *
 	 * @param ois The stream from which to read the action queue
 	 * @param session The session to which the action queue belongs
 	 *
 	 * @return The deserialized action queue
 	 *
 	 * @throws IOException indicates a problem reading from the stream
 	 * @throws ClassNotFoundException Generally means we were unable to locate user classes.
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public static ActionQueue deserialize(
 			ObjectInputStream ois,
 			SessionImplementor session) throws IOException, ClassNotFoundException {
 		LOG.trace( "Dedeserializing action-queue" );
 		ActionQueue rtn = new ActionQueue( session );
 
 		rtn.unresolvedInsertions = UnresolvedEntityInsertActions.deserialize( ois, session );
 
 		int queueSize = ois.readInt();
 		LOG.tracev( "Starting deserialization of [{0}] insertions entries", queueSize );
 		rtn.insertions = new ArrayList<Executable>( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			EntityAction action = ( EntityAction ) ois.readObject();
 			action.afterDeserialize( session );
 			rtn.insertions.add( action );
 		}
 
 		queueSize = ois.readInt();
 		LOG.tracev( "Starting deserialization of [{0}] deletions entries", queueSize );
 		rtn.deletions = new ArrayList<EntityDeleteAction>( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			EntityDeleteAction action = ( EntityDeleteAction ) ois.readObject();
 			action.afterDeserialize( session );
 			rtn.deletions.add( action );
 		}
 
 		queueSize = ois.readInt();
 		LOG.tracev( "Starting deserialization of [{0}] updates entries", queueSize );
 		rtn.updates = new ArrayList<Executable>( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			EntityAction action = ( EntityAction ) ois.readObject();
 			action.afterDeserialize( session );
 			rtn.updates.add( action );
 		}
 
 		queueSize = ois.readInt();
 		LOG.tracev( "Starting deserialization of [{0}] collectionUpdates entries", queueSize );
 		rtn.collectionUpdates = new ArrayList<Executable>( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			CollectionAction action = (CollectionAction) ois.readObject();
 			action.afterDeserialize( session );
 			rtn.collectionUpdates.add( action );
 		}
 
 		queueSize = ois.readInt();
 		LOG.tracev( "Starting deserialization of [{0}] collectionRemovals entries", queueSize );
 		rtn.collectionRemovals = new ArrayList<Executable>( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			CollectionAction action = ( CollectionAction ) ois.readObject();
 			action.afterDeserialize( session );
 			rtn.collectionRemovals.add( action );
 		}
 
 		queueSize = ois.readInt();
 		LOG.tracev( "Starting deserialization of [{0}] collectionCreations entries", queueSize );
 		rtn.collectionCreations = new ArrayList<Executable>( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			CollectionAction action = ( CollectionAction ) ois.readObject();
 			action.afterDeserialize( session );
 			rtn.collectionCreations.add( action );
 		}
 
 		queueSize = ois.readInt();
 		LOG.tracev( "Starting deserialization of [{0}] collectionQueuedOps entries", queueSize );
 		rtn.collectionQueuedOps = new ArrayList<Executable>( queueSize );
 		for ( int i = 0; i < queueSize; i++ ) {
 			CollectionAction action = ( CollectionAction ) ois.readObject();
 			action.afterDeserialize( session );
 			rtn.collectionQueuedOps.add( action );
 		}
 		return rtn;
 	}
 
 	private static class BeforeTransactionCompletionProcessQueue {
 		private SessionImplementor session;
 		// Concurrency handling required when transaction completion process is dynamically registered
 		// inside event listener (HHH-7478).
 		private Queue<BeforeTransactionCompletionProcess> processes = new ConcurrentLinkedQueue<BeforeTransactionCompletionProcess>();
 
 		private BeforeTransactionCompletionProcessQueue(SessionImplementor session) {
 			this.session = session;
 		}
 
 		public void register(BeforeTransactionCompletionProcess process) {
 			if ( process == null ) {
 				return;
 			}
 			processes.add( process );
 		}
 
 		public void beforeTransactionCompletion() {
 			for ( BeforeTransactionCompletionProcess process : processes ) {
 				try {
 					process.doBeforeTransactionCompletion( session );
 				}
 				catch (HibernateException he) {
 					throw he;
 				}
 				catch (Exception e) {
 					throw new AssertionFailure( "Unable to perform beforeTransactionCompletion callback", e );
 				}
 			}
 			processes.clear();
 		}
 	}
 
 	private static class AfterTransactionCompletionProcessQueue {
 		private SessionImplementor session;
 		private Set<String> querySpacesToInvalidate = new HashSet<String>();
 		// Concurrency handling required when transaction completion process is dynamically registered
 		// inside event listener (HHH-7478).
 		private Queue<AfterTransactionCompletionProcess> processes = new ConcurrentLinkedQueue<AfterTransactionCompletionProcess>();
 
 		private AfterTransactionCompletionProcessQueue(SessionImplementor session) {
 			this.session = session;
 		}
 
 		public void addSpacesToInvalidate(String[] spaces) {
 			for ( String space : spaces ) {
 				addSpaceToInvalidate( space );
 			}
 		}
 
 		public void addSpaceToInvalidate(String space) {
 			querySpacesToInvalidate.add( space );
 		}
 
 		public void register(AfterTransactionCompletionProcess process) {
 			if ( process == null ) {
 				return;
 			}
 			processes.add( process );
 		}
 
 		public void afterTransactionCompletion(boolean success) {
 			for ( AfterTransactionCompletionProcess process : processes ) {
 				try {
 					process.doAfterTransactionCompletion( success, session );
 				}
 				catch ( CacheException ce ) {
 					LOG.unableToReleaseCacheLock( ce );
 					// continue loop
 				}
 				catch ( Exception e ) {
 					throw new AssertionFailure( "Exception releasing cache locks", e );
 				}
 			}
 			processes.clear();
 
 			if ( session.getFactory().getSettings().isQueryCacheEnabled() ) {
 				session.getFactory().getUpdateTimestampsCache().invalidate(
 						querySpacesToInvalidate.toArray( new String[ querySpacesToInvalidate.size()] )
 				);
 			}
 			querySpacesToInvalidate.clear();
 		}
 	}
 
 	/**
 	 * Sorts the insert actions using more hashes.
 	 *
 	 * @author Jay Erb
 	 */
 	private class InsertActionSorter {
 		// the mapping of entity names to their latest batch numbers.
 		private HashMap<String,Integer> latestBatches = new HashMap<String,Integer>();
 		private HashMap<Object,Integer> entityBatchNumber;
 
 		// the map of batch numbers to EntityInsertAction lists
 		private HashMap<Integer,List<EntityInsertAction>> actionBatches = new HashMap<Integer,List<EntityInsertAction>>();
 
 		public InsertActionSorter() {
 			//optimize the hash size to eliminate a rehash.
 			entityBatchNumber = new HashMap<Object,Integer>( insertions.size() + 1, 1.0f );
 		}
 
 		/**
 		 * Sort the insert actions.
 		 */
-		@SuppressWarnings({ "unchecked", "UnnecessaryBoxing" })
 		public void sort() {
 			// the list of entity names that indicate the batch number
 			for ( EntityInsertAction action : (List<EntityInsertAction>) insertions ) {
 				// remove the current element from insertions. It will be added back later.
 				String entityName = action.getEntityName();
 
 				// the entity associated with the current action.
 				Object currentEntity = action.getInstance();
 
 				Integer batchNumber;
 				if ( latestBatches.containsKey( entityName ) ) {
 					// There is already an existing batch for this type of entity.
 					// Check to see if the latest batch is acceptable.
 					batchNumber = findBatchNumber( action, entityName );
 				}
 				else {
 					// add an entry for this type of entity.
 					// we can be assured that all referenced entities have already
 					// been processed,
 					// so specify that this entity is with the latest batch.
 					// doing the batch number before adding the name to the list is
 					// a faster way to get an accurate number.
 
 					batchNumber = actionBatches.size();
 					latestBatches.put( entityName, batchNumber );
 				}
 				entityBatchNumber.put( currentEntity, batchNumber );
 				addToBatch( batchNumber, action );
 			}
 			insertions.clear();
 
 			// now rebuild the insertions list. There is a batch for each entry in the name list.
 			for ( int i = 0; i < actionBatches.size(); i++ ) {
 				List<EntityInsertAction> batch = actionBatches.get( i );
 				for ( EntityInsertAction action : batch ) {
 					insertions.add( action );
 				}
 			}
 		}
 
 		/**
 		 * Finds an acceptable batch for this entity to be a member as part of the {@link InsertActionSorter}
 		 *
 		 * @param action The action being sorted
 		 * @param entityName The name of the entity affected by the action
 		 *
 		 * @return An appropriate batch number; todo document this process better
 		 */
-		@SuppressWarnings({ "UnnecessaryBoxing", "unchecked" })
 		private Integer findBatchNumber(
 				EntityInsertAction action,
 				String entityName) {
 			// loop through all the associated entities and make sure they have been
 			// processed before the latest
 			// batch associated with this entity type.
 
 			// the current batch number is the latest batch for this entity type.
 			Integer latestBatchNumberForType = latestBatches.get( entityName );
 
 			// loop through all the associations of the current entity and make sure that they are processed
 			// before the current batch number
 			Object[] propertyValues = action.getState();
 			Type[] propertyTypes = action.getPersister().getClassMetadata()
 					.getPropertyTypes();
 
 			for ( int i = 0; i < propertyValues.length; i++ ) {
 				Object value = propertyValues[i];
 				Type type = propertyTypes[i];
 				if ( type.isEntityType() && value != null ) {
 					// find the batch number associated with the current association, if any.
 					Integer associationBatchNumber = entityBatchNumber.get( value );
 					if ( associationBatchNumber != null && associationBatchNumber.compareTo( latestBatchNumberForType ) > 0 ) {
 						// create a new batch for this type. The batch number is the number of current batches.
 						latestBatchNumberForType = actionBatches.size();
 						latestBatches.put( entityName, latestBatchNumberForType );
 						// since this entity will now be processed in the latest possible batch,
 						// we can be assured that it will come after all other associations,
 						// there's not need to continue checking.
 						break;
 					}
 				}
 			}
 			return latestBatchNumberForType;
 		}
 
 		@SuppressWarnings({ "unchecked" })
 		private void addToBatch(Integer batchNumber, EntityInsertAction action) {
 			List<EntityInsertAction> actions = actionBatches.get( batchNumber );
 
 			if ( actions == null ) {
 				actions = new LinkedList<EntityInsertAction>();
 				actionBatches.put( batchNumber, actions );
 			}
 			actions.add( action );
 		}
 
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/AssociationKey.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/AssociationKey.java
index 90bb0d380d..aad11579f3 100755
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/AssociationKey.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/AssociationKey.java
@@ -1,70 +1,70 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import java.io.Serializable;
 
 /**
  * Identifies a named association belonging to a particular
  * entity instance. Used to record the fact that an association
  * is null during loading.
  * 
  * @author Gavin King
  */
 public final class AssociationKey implements Serializable {
 	private EntityKey ownerKey;
 	private String propertyName;
 
 	/**
 	 * Constructs an AssociationKey
 	 *
 	 * @param ownerKey The EntityKey of the association owner
 	 * @param propertyName The name of the property on the owner which defines the association
 	 */
 	public AssociationKey(EntityKey ownerKey, String propertyName) {
 		this.ownerKey = ownerKey;
 		this.propertyName = propertyName;
 	}
 
 	@Override
 	public boolean equals(Object o) {
 		if ( this == o ) {
 			return true;
 		}
 		if ( o == null || getClass() != o.getClass() ) {
 			return false;
 		}
 
 		final AssociationKey that = (AssociationKey) o;
 		return ownerKey.equals( that.ownerKey )
 				&& propertyName.equals( that.propertyName );
 	}
 
 	@Override
 	public int hashCode() {
 		int result = ownerKey.hashCode();
 		result = 31 * result + propertyName.hashCode();
 		return result;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/CascadingAction.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/CascadingAction.java
index 3a467f5691..e43103eefe 100755
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/CascadingAction.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/CascadingAction.java
@@ -1,104 +1,104 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import java.util.Iterator;
 
 import org.hibernate.HibernateException;
 import org.hibernate.event.spi.EventSource;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.type.CollectionType;
 
 /**
  * A session action that may be cascaded from parent entity to its children
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public interface CascadingAction {
 
 	/**
 	 * Cascade the action to the child object.
 	 *
 	 * @param session The session within which the cascade is occuring.
 	 * @param child The child to which cascading should be performed.
 	 * @param entityName The child's entity name
 	 * @param anything Anything ;)  Typically some form of cascade-local cache
 	 * which is specific to each CascadingAction type
 	 * @param isCascadeDeleteEnabled Are cascading deletes enabled.
 	 * @throws HibernateException
 	 */
 	public void cascade(
 			EventSource session,
 			Object child,
 			String entityName,
 			Object anything,
 			boolean isCascadeDeleteEnabled) throws HibernateException;
 
 	/**
 	 * Given a collection, get an iterator of the children upon which the
 	 * current cascading action should be visited.
 	 *
 	 * @param session The session within which the cascade is occuring.
 	 * @param collectionType The mapping type of the collection.
 	 * @param collection The collection instance.
 	 * @return The children iterator.
 	 */
 	public Iterator getCascadableChildrenIterator(
 			EventSource session,
 			CollectionType collectionType,
 			Object collection);
 
 	/**
 	 * Does this action potentially extrapolate to orphan deletes?
 	 *
 	 * @return True if this action can lead to deletions of orphans.
 	 */
 	public boolean deleteOrphans();
 
 
 	/**
 	 * Does the specified cascading action require verification of no cascade validity?
 	 *
 	 * @return True if this action requires no-cascade verification; false otherwise.
 	 */
 	public boolean requiresNoCascadeChecking();
 
 	/**
 	 * Called (in the case of {@link #requiresNoCascadeChecking} returning true) to validate
 	 * that no cascade on the given property is considered a valid semantic.
 	 *
 	 * @param session The session witin which the cascade is occurring.
 	 * @param child The property value
 	 * @param parent The property value owner
 	 * @param persister The entity persister for the owner
 	 * @param propertyIndex The index of the property within the owner.
 	 */
 	public void noCascade(EventSource session, Object child, Object parent, EntityPersister persister, int propertyIndex);
 
 	/**
 	 * Should this action be performed (or noCascade consulted) in the case of lazy properties.
 	 */
 	public boolean performOnLazyProperty();
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/CollectionKey.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/CollectionKey.java
index 9df614a053..1b0cba1fbf 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/CollectionKey.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/CollectionKey.java
@@ -1,158 +1,158 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 
 import org.hibernate.EntityMode;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.type.Type;
 
 /**
  * Uniquely identifies a collection instance in a particular session.
  *
  * @author Gavin King
  */
 public final class CollectionKey implements Serializable {
 	private final String role;
 	private final Serializable key;
 	private final Type keyType;
 	private final SessionFactoryImplementor factory;
 	private final int hashCode;
 	private EntityMode entityMode;
 
 	public CollectionKey(CollectionPersister persister, Serializable key) {
 		this(
 				persister.getRole(),
 				key,
 				persister.getKeyType(),
 				persister.getOwnerEntityPersister().getEntityMetamodel().getEntityMode(),
 				persister.getFactory()
 		);
 	}
 
 	public CollectionKey(CollectionPersister persister, Serializable key, EntityMode em) {
 		this( persister.getRole(), key, persister.getKeyType(), em, persister.getFactory() );
 	}
 
 	private CollectionKey(
 			String role,
 			Serializable key,
 			Type keyType,
 			EntityMode entityMode,
 			SessionFactoryImplementor factory) {
 		this.role = role;
 		this.key = key;
 		this.keyType = keyType;
 		this.entityMode = entityMode;
 		this.factory = factory;
 		//cache the hash-code
 		this.hashCode = generateHashCode();
 	}
 
 	private int generateHashCode() {
 		int result = 17;
 		result = 37 * result + role.hashCode();
 		result = 37 * result + keyType.getHashCode( key, factory );
 		return result;
 	}
 
 
 	public String getRole() {
 		return role;
 	}
 
 	public Serializable getKey() {
 		return key;
 	}
 
 	@Override
 	public String toString() {
 		return "CollectionKey"
 				+ MessageHelper.collectionInfoString( factory.getCollectionPersister( role ), key, factory );
 	}
 
 	@Override
 	public boolean equals(Object other) {
 		if ( this == other ) {
 			return true;
 		}
 		if ( other == null || getClass() != other.getClass() ) {
 			return false;
 		}
 
 		final CollectionKey that = (CollectionKey) other;
 		return that.role.equals( role )
 				&& keyType.isEqual( that.key, key, factory );
 	}
 
 	@Override
 	public int hashCode() {
 		return hashCode;
 	}
 
 
 	/**
 	 * Custom serialization routine used during serialization of a
 	 * Session/PersistenceContext for increased performance.
 	 *
 	 * @param oos The stream to which we should write the serial data.
 	 *
 	 * @throws java.io.IOException
 	 */
 	public void serialize(ObjectOutputStream oos) throws IOException {
 		oos.writeObject( role );
 		oos.writeObject( key );
 		oos.writeObject( keyType );
 		oos.writeObject( entityMode.toString() );
 	}
 
 	/**
 	 * Custom deserialization routine used during deserialization of a
 	 * Session/PersistenceContext for increased performance.
 	 *
 	 * @param ois The stream from which to read the entry.
 	 * @param session The session being deserialized.
 	 *
 	 * @return The deserialized CollectionKey
 	 *
 	 * @throws IOException
 	 * @throws ClassNotFoundException
 	 */
 	public static CollectionKey deserialize(
 			ObjectInputStream ois,
 			SessionImplementor session) throws IOException, ClassNotFoundException {
 		return new CollectionKey(
 				(String) ois.readObject(),
 				(Serializable) ois.readObject(),
 				(Type) ois.readObject(),
 				EntityMode.parse( (String) ois.readObject() ),
 				(session == null ? null : session.getFactory())
 		);
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/IdentifierValue.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/IdentifierValue.java
index f8dc5e64a6..f52be9eb68 100755
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/IdentifierValue.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/IdentifierValue.java
@@ -1,151 +1,151 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import java.io.Serializable;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.internal.CoreMessageLogger;
 
 /**
  * A strategy for determining if an identifier value is an identifier of
  * a new transient instance or a previously persistent transient instance.
  * The strategy is determined by the <tt>unsaved-value</tt> attribute in
  * the mapping file.
  *
  * @author Gavin King
  */
 public class IdentifierValue implements UnsavedValueStrategy {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, IdentifierValue.class.getName());
 
 	private final Serializable value;
 
 	/**
 	 * Always assume the transient instance is newly instantiated
 	 */
 	public static final IdentifierValue ANY = new IdentifierValue() {
 		@Override
 		public final Boolean isUnsaved(Object id) {
 			LOG.trace( "ID unsaved-value strategy ANY" );
 			return Boolean.TRUE;
 		}
 		@Override
 		public Serializable getDefaultValue(Object currentValue) {
 			return (Serializable) currentValue;
 		}
 		@Override
 		public String toString() {
 			return "SAVE_ANY";
 		}
 	};
 
 	/**
 	 * Never assume the transient instance is newly instantiated
 	 */
 	public static final IdentifierValue NONE = new IdentifierValue() {
 		@Override
 		public final Boolean isUnsaved(Object id) {
 			LOG.trace( "ID unsaved-value strategy NONE" );
 			return Boolean.FALSE;
 		}
 		@Override
 		public Serializable getDefaultValue(Object currentValue) {
 			return (Serializable) currentValue;
 		}
 		@Override
 		public String toString() {
 			return "SAVE_NONE";
 		}
 	};
 
 	/**
 	 * Assume the transient instance is newly instantiated if the identifier
 	 * is null.
 	 */
 	public static final IdentifierValue NULL = new IdentifierValue() {
 		@Override
 		public final Boolean isUnsaved(Object id) {
 			LOG.trace( "ID unsaved-value strategy NULL" );
 			return id==null;
 		}
 		@Override
 		public Serializable getDefaultValue(Object currentValue) {
 			return null;
 		}
 		@Override
 		public String toString() {
 			return "SAVE_NULL";
 		}
 	};
 
 	/**
 	 * Assume nothing.
 	 */
 	public static final IdentifierValue UNDEFINED = new IdentifierValue() {
 		@Override
 		public final Boolean isUnsaved(Object id) {
 			LOG.trace( "ID unsaved-value strategy UNDEFINED" );
 			return null;
 		}
 		@Override
 		public Serializable getDefaultValue(Object currentValue) {
 			return null;
 		}
 		@Override
 		public String toString() {
 			return "UNDEFINED";
 		}
 	};
 
 	protected IdentifierValue() {
 		this.value = null;
 	}
 
 	/**
 	 * Assume the transient instance is newly instantiated if
 	 * its identifier is null or equal to <tt>value</tt>
 	 */
 	public IdentifierValue(Serializable value) {
 		this.value = value;
 	}
 
 	/**
 	 * Does the given identifier belong to a new instance?
 	 */
 	public Boolean isUnsaved(Object id) {
 		LOG.tracev( "ID unsaved-value: {0}", value );
 		return id==null || id.equals(value);
 	}
 
 	public Serializable getDefaultValue(Object currentValue) {
 		return value;
 	}
 
 	@Override
 	public String toString() {
 		return "identifier unsaved-value: " + value;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/NamedQueryDefinitionBuilder.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/NamedQueryDefinitionBuilder.java
index 4a18d82290..46f8fe09bf 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/NamedQueryDefinitionBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/NamedQueryDefinitionBuilder.java
@@ -1,143 +1,143 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import java.util.Map;
 
 import org.hibernate.CacheMode;
 import org.hibernate.FlushMode;
 import org.hibernate.LockOptions;
 
 public class NamedQueryDefinitionBuilder {
 	protected String name;
 	protected String query;
 	protected boolean cacheable;
 	protected String cacheRegion;
 	protected Integer timeout;
 	protected Integer fetchSize;
 	protected FlushMode flushMode;
 	protected CacheMode cacheMode;
 	protected boolean readOnly;
 	protected String comment;
 	protected Map parameterTypes;
 	protected LockOptions lockOptions;
 	protected Integer firstResult;
 	protected Integer maxResults;
 
 	public NamedQueryDefinitionBuilder() {
 	}
 
 	public NamedQueryDefinitionBuilder(String name) {
 		this.name = name;
 	}
 
 	public NamedQueryDefinitionBuilder setName(String name) {
 		this.name = name;
 		return this;
 	}
 
 	public NamedQueryDefinitionBuilder setQuery(String query) {
 		this.query = query;
 		return this;
 	}
 
 	public NamedQueryDefinitionBuilder setCacheable(boolean cacheable) {
 		this.cacheable = cacheable;
 		return this;
 	}
 
 	public NamedQueryDefinitionBuilder setCacheRegion(String cacheRegion) {
 		this.cacheRegion = cacheRegion;
 		return this;
 	}
 
 	public NamedQueryDefinitionBuilder setTimeout(Integer timeout) {
 		this.timeout = timeout;
 		return this;
 	}
 
 	public NamedQueryDefinitionBuilder setFetchSize(Integer fetchSize) {
 		this.fetchSize = fetchSize;
 		return this;
 	}
 
 	public NamedQueryDefinitionBuilder setFlushMode(FlushMode flushMode) {
 		this.flushMode = flushMode;
 		return this;
 	}
 
 	public NamedQueryDefinitionBuilder setCacheMode(CacheMode cacheMode) {
 		this.cacheMode = cacheMode;
 		return this;
 	}
 
 	public NamedQueryDefinitionBuilder setReadOnly(boolean readOnly) {
 		this.readOnly = readOnly;
 		return this;
 	}
 
 	public NamedQueryDefinitionBuilder setComment(String comment) {
 		this.comment = comment;
 		return this;
 	}
 
 	public NamedQueryDefinitionBuilder setParameterTypes(Map parameterTypes) {
 		this.parameterTypes = parameterTypes;
 		return this;
 	}
 
 	public NamedQueryDefinitionBuilder setLockOptions(LockOptions lockOptions) {
 		this.lockOptions = lockOptions;
 		return this;
 	}
 
 	public NamedQueryDefinitionBuilder setFirstResult(Integer firstResult) {
 		this.firstResult = firstResult;
 		return this;
 	}
 
 	public NamedQueryDefinitionBuilder setMaxResults(Integer maxResults) {
 		this.maxResults = maxResults;
 		return this;
 	}
 
 	public NamedQueryDefinition createNamedQueryDefinition() {
 		return new NamedQueryDefinition(
 				name,
 				query,
 				cacheable,
 				cacheRegion,
 				timeout,
 				lockOptions,
 				fetchSize,
 				flushMode,
 				cacheMode,
 				readOnly,
 				comment,
 				parameterTypes,
 				firstResult,
 				maxResults
 		);
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/NamedSQLQueryDefinition.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/NamedSQLQueryDefinition.java
index e1bf517ab8..a5840bdccf 100755
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/NamedSQLQueryDefinition.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/NamedSQLQueryDefinition.java
@@ -1,242 +1,242 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.CacheMode;
 import org.hibernate.FlushMode;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryReturn;
 
 /**
  * Definition of a named native SQL query, defined in the mapping metadata.
  * 
  * @author Max Andersen
  * @author Steve Ebersole
  */
 public class NamedSQLQueryDefinition extends NamedQueryDefinition {
 
 	private NativeSQLQueryReturn[] queryReturns;
 	private final List<String> querySpaces;
 	private final boolean callable;
 	private String resultSetRef;
 
 	/**
 	 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a the
 	 * result-set mapping information is not explicitly  provided in the query definition
 	 * (i.e., no resultset-mapping used).
 	 *
 	 * @param name The name of named query
 	 * @param query The sql query string
 	 * @param queryReturns The in-lined query return definitions
 	 * @param querySpaces Any specified query spaces (used for auto-flushing)
 	 * @param cacheable Whether the query results are cacheable
 	 * @param cacheRegion If cacheable, the region into which to store the results
 	 * @param timeout A JDBC-level timeout to be applied
 	 * @param fetchSize A JDBC-level fetch-size to be applied
 	 * @param flushMode The flush mode to use for this query
 	 * @param cacheMode The cache mode to use during execution and subsequent result loading
 	 * @param readOnly Whether returned entities should be marked as read-only in the session
 	 * @param comment Any sql comment to be applied to the query
 	 * @param parameterTypes parameter type map
 	 * @param callable Does the query string represent a callable object (i.e., proc)
 	 *
 	 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 	 */
 	@Deprecated
 	public NamedSQLQueryDefinition(
 			String name,
 			String query,
 			NativeSQLQueryReturn[] queryReturns,
 			List<String> querySpaces,
 			boolean cacheable,
 			String cacheRegion,
 			Integer timeout,
 			Integer fetchSize,
 			FlushMode flushMode,
 			CacheMode cacheMode,
 			boolean readOnly,
 			String comment,
 			Map parameterTypes,
 			boolean callable) {
 		this(
 				name,
 				query,
 				cacheable,
 				cacheRegion,
 				timeout,
 				fetchSize,
 				flushMode,
 				cacheMode,
 				readOnly,
 				comment,
 				parameterTypes,
 				null,		// firstResult
 				null,		// maxResults
 				null, 		// resultSetRef
 				querySpaces,
 				callable,
 				queryReturns
 		);
 	}
 
 	/**
 	 * This form was initially used to construct a NamedSQLQueryDefinition from the binder code when a
 	 * resultset-mapping reference is used.
 	 *
 	 * @param name The name of named query
 	 * @param query The sql query string
 	 * @param resultSetRef The resultset-mapping name
 	 * @param querySpaces Any specified query spaces (used for auto-flushing)
 	 * @param cacheable Whether the query results are cacheable
 	 * @param cacheRegion If cacheable, the region into which to store the results
 	 * @param timeout A JDBC-level timeout to be applied
 	 * @param fetchSize A JDBC-level fetch-size to be applied
 	 * @param flushMode The flush mode to use for this query
 	 * @param cacheMode The cache mode to use during execution and subsequent result loading
 	 * @param readOnly Whether returned entities should be marked as read-only in the session
 	 * @param comment Any sql comment to be applied to the query
 	 * @param parameterTypes parameter type map
 	 * @param callable Does the query string represent a callable object (i.e., proc)
 	 *
 	 * @deprecated Use {@link NamedSQLQueryDefinitionBuilder} instead.
 	 */
 	@Deprecated
 	public NamedSQLQueryDefinition(
 			String name,
 			String query,
 			String resultSetRef,
 			List<String> querySpaces,
 			boolean cacheable,
 			String cacheRegion,
 			Integer timeout,
 			Integer fetchSize,
 			FlushMode flushMode,
 			CacheMode cacheMode,
 			boolean readOnly,
 			String comment,
 			Map parameterTypes,
 			boolean callable) {
 
 		this(
 				name,
 				query,
 				cacheable,
 				cacheRegion,
 				timeout,
 				fetchSize,
 				flushMode,
 				cacheMode,
 				readOnly,
 				comment,
 				parameterTypes,
 				null,		// firstResult
 				null,		// maxResults
 				resultSetRef,
 				querySpaces,
 				callable,
 				null		// queryReturns
 		);
 	}
 
 	NamedSQLQueryDefinition(
 			String name,
 			String query,
 			boolean cacheable,
 			String cacheRegion,
 			Integer timeout,
 			Integer fetchSize,
 			FlushMode flushMode,
 			CacheMode cacheMode,
 			boolean readOnly,
 			String comment,
 			Map parameterTypes,
 			Integer firstResult,
 			Integer maxResults,
 			String resultSetRef,
 			List<String> querySpaces,
 			boolean callable,
 			NativeSQLQueryReturn[] queryReturns) {
 		super(
 				name,
 				query.trim(), /* trim done to workaround stupid oracle bug that cant handle whitespaces before a { in a sp */
 				cacheable,
 				cacheRegion,
 				timeout,
 				null,		// lockOptions
 				fetchSize,
 				flushMode,
 				cacheMode,
 				readOnly,
 				comment,
 				parameterTypes,
 				firstResult,
 				maxResults
 		);
 		this.resultSetRef = resultSetRef;
 		this.querySpaces = querySpaces;
 		this.callable = callable;
 		this.queryReturns = queryReturns;
 	}
 
 	public NativeSQLQueryReturn[] getQueryReturns() {
 		return queryReturns;
 	}
 
 	public List<String> getQuerySpaces() {
 		return querySpaces;
 	}
 
 	public boolean isCallable() {
 		return callable;
 	}
 
 	public String getResultSetRef() {
 		return resultSetRef;
 	}
 
 	@Override
 	public NamedSQLQueryDefinition makeCopy(String name) {
 		return new NamedSQLQueryDefinition(
 				name,
 				getQuery(),
 				isCacheable(),
 				getCacheRegion(),
 				getTimeout(),
 				getFetchSize(),
 				getFlushMode(),
 				getCacheMode(),
 				isReadOnly(),
 				getComment(),
 				getParameterTypes(),
 				getFirstResult(),
 				getMaxResults(),
 				getResultSetRef(),
 				getQuerySpaces(),
 				isCallable(),
 				getQueryReturns()
 		);
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/NamedSQLQueryDefinitionBuilder.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/NamedSQLQueryDefinitionBuilder.java
index 9917c9b889..61811cbcab 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/NamedSQLQueryDefinitionBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/NamedSQLQueryDefinitionBuilder.java
@@ -1,184 +1,184 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.CacheMode;
 import org.hibernate.FlushMode;
 import org.hibernate.LockOptions;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryReturn;
 
 public class NamedSQLQueryDefinitionBuilder extends NamedQueryDefinitionBuilder {
 	private NativeSQLQueryReturn[] queryReturns;
 	private Collection<String> querySpaces;
 	private boolean callable;
 	private String resultSetRef;
 
 	public NamedSQLQueryDefinitionBuilder() {
 	}
 
 	public NamedSQLQueryDefinitionBuilder(String name) {
 		super( name );
 	}
 
 	public NamedSQLQueryDefinitionBuilder setQueryReturns(NativeSQLQueryReturn[] queryReturns) {
 		this.queryReturns = queryReturns;
 		return this;
 	}
 
 	public NamedSQLQueryDefinitionBuilder setQueryReturns(List<NativeSQLQueryReturn> queryReturns) {
 		if ( queryReturns != null ) {
 			this.queryReturns = queryReturns.toArray( new NativeSQLQueryReturn[ queryReturns.size() ] );
 		}
 		else {
 			this.queryReturns = null;
 		}
 		return this;
 	}
 
 	public NamedSQLQueryDefinitionBuilder setQuerySpaces(List<String> querySpaces) {
 		this.querySpaces = querySpaces;
 		return this;
 	}
 
 	public NamedSQLQueryDefinitionBuilder setQuerySpaces(Collection<String> synchronizedQuerySpaces) {
 		this.querySpaces = synchronizedQuerySpaces;
 		return this;
 	}
 
 	public NamedSQLQueryDefinitionBuilder setResultSetRef(String resultSetRef) {
 		this.resultSetRef = resultSetRef;
 		return this;
 	}
 
 	public NamedSQLQueryDefinitionBuilder setCallable(boolean callable) {
 		this.callable = callable;
 		return this;
 	}
 
 
 	@Override
 	public NamedSQLQueryDefinitionBuilder setName(String name) {
 		return (NamedSQLQueryDefinitionBuilder) super.setName( name );
 	}
 
 	@Override
 	public NamedSQLQueryDefinitionBuilder setQuery(String query) {
 		return (NamedSQLQueryDefinitionBuilder) super.setQuery( query );
 	}
 
 	@Override
 	public NamedSQLQueryDefinitionBuilder setCacheable(boolean cacheable) {
 		return (NamedSQLQueryDefinitionBuilder) super.setCacheable( cacheable );
 	}
 
 	@Override
 	public NamedSQLQueryDefinitionBuilder setCacheRegion(String cacheRegion) {
 		return (NamedSQLQueryDefinitionBuilder) super.setCacheRegion( cacheRegion );
 	}
 
 	@Override
 	public NamedSQLQueryDefinitionBuilder setTimeout(Integer timeout) {
 		return (NamedSQLQueryDefinitionBuilder) super.setTimeout( timeout );
 	}
 
 	@Override
 	public NamedSQLQueryDefinitionBuilder setFetchSize(Integer fetchSize) {
 		return (NamedSQLQueryDefinitionBuilder) super.setFetchSize( fetchSize );
 	}
 
 	@Override
 	public NamedSQLQueryDefinitionBuilder setFlushMode(FlushMode flushMode) {
 		return (NamedSQLQueryDefinitionBuilder) super.setFlushMode( flushMode );
 	}
 
 	@Override
 	public NamedSQLQueryDefinitionBuilder setCacheMode(CacheMode cacheMode) {
 		return (NamedSQLQueryDefinitionBuilder) super.setCacheMode( cacheMode );
 	}
 
 	@Override
 	public NamedSQLQueryDefinitionBuilder setReadOnly(boolean readOnly) {
 		return (NamedSQLQueryDefinitionBuilder) super.setReadOnly( readOnly );
 	}
 
 	@Override
 	public NamedSQLQueryDefinitionBuilder setComment(String comment) {
 		return (NamedSQLQueryDefinitionBuilder) super.setComment( comment );
 	}
 
 	@Override
 	public NamedSQLQueryDefinitionBuilder setParameterTypes(Map parameterTypes) {
 		return (NamedSQLQueryDefinitionBuilder) super.setParameterTypes( parameterTypes );
 	}
 
 	@Override
 	public NamedSQLQueryDefinitionBuilder setLockOptions(LockOptions lockOptions) {
 		// todo : maybe throw an exception here instead? since this is not valid for native-0sql queries?
 		return (NamedSQLQueryDefinitionBuilder) super.setLockOptions( lockOptions );
 	}
 
 	@Override
 	public NamedSQLQueryDefinitionBuilder setFirstResult(Integer firstResult) {
 		return (NamedSQLQueryDefinitionBuilder) super.setFirstResult( firstResult );
 	}
 
 	@Override
 	public NamedSQLQueryDefinitionBuilder setMaxResults(Integer maxResults) {
 		return (NamedSQLQueryDefinitionBuilder) super.setMaxResults( maxResults );
 	}
 
 	@Override
 	public NamedSQLQueryDefinition createNamedQueryDefinition() {
 		return new NamedSQLQueryDefinition(
 				name,
 				query,
 				cacheable,
 				cacheRegion,
 				timeout,
 				fetchSize,
 				flushMode,
 				cacheMode,
 				readOnly,
 				comment,
 				parameterTypes,
 				firstResult,
 				maxResults,
 				resultSetRef,
 				querySpacesCopy(),
 				callable,
 				queryReturns
 		);
 	}
 
 	private List<String> querySpacesCopy() {
 		return querySpaces == null
 				? null
 				: new ArrayList<String>( querySpaces );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/NonFlushedChanges.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/NonFlushedChanges.java
index 5db49c8fe4..5f795bf2dd 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/NonFlushedChanges.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/NonFlushedChanges.java
@@ -1,33 +1,33 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import java.io.Serializable;
 
 public interface NonFlushedChanges extends Serializable {
 	/**
 	 * Remove the non-flushed changes from this NonFlushedChanges object.
 	 */
 	void clear();
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/VersionValue.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/VersionValue.java
index 8b56986347..3b9cda7e6e 100755
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/VersionValue.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/VersionValue.java
@@ -1,138 +1,138 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.MappingException;
 import org.hibernate.id.IdentifierGeneratorHelper;
 import org.hibernate.internal.CoreMessageLogger;
 
 /**
  * A strategy for determining if a version value is an version of
  * a new transient instance or a previously persistent transient instance.
  * The strategy is determined by the <tt>unsaved-value</tt> attribute in
  * the mapping file.
  *
  * @author Gavin King
  */
 public class VersionValue implements UnsavedValueStrategy {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, VersionValue.class.getName());
 
 	private final Object value;
 	/**
 	 * Assume the transient instance is newly instantiated if the version
 	 * is null, otherwise assume it is a detached instance.
 	 */
 	public static final VersionValue NULL = new VersionValue() {
 		@Override
 		public final Boolean isUnsaved(Object version) {
 			LOG.trace( "Version unsaved-value strategy NULL" );
 			return version==null;
 		}
 		@Override
 		public Object getDefaultValue(Object currentValue) {
 			return null;
 		}
 		@Override
 		public String toString() {
 			return "VERSION_SAVE_NULL";
 		}
 	};
 	/**
 	 * Assume the transient instance is newly instantiated if the version
 	 * is null, otherwise defer to the identifier unsaved-value.
 	 */
 	public static final VersionValue UNDEFINED = new VersionValue() {
 		@Override
 		public final Boolean isUnsaved(Object version) {
 			LOG.trace( "Version unsaved-value strategy UNDEFINED" );
 			return version==null ? Boolean.TRUE : null;
 		}
 		@Override
 		public Object getDefaultValue(Object currentValue) {
 			return currentValue;
 		}
 		@Override
 		public String toString() {
 			return "VERSION_UNDEFINED";
 		}
 	};
 	/**
 	 * Assume the transient instance is newly instantiated if the version
 	 * is negative, otherwise assume it is a detached instance.
 	 */
 	public static final VersionValue NEGATIVE = new VersionValue() {
 
 		@Override
 		public final Boolean isUnsaved(Object version) throws MappingException {
 			LOG.trace( "Version unsaved-value strategy NEGATIVE" );
 			if (version==null) return Boolean.TRUE;
 			if ( version instanceof Number ) {
 				return ( (Number) version ).longValue() < 0l;
 			}
 			throw new MappingException( "unsaved-value NEGATIVE may only be used with short, int and long types" );
 		}
 		@Override
 		public Object getDefaultValue(Object currentValue) {
 			return IdentifierGeneratorHelper.getIntegralDataTypeHolder( currentValue.getClass() )
 					.initialize( -1L )
 					.makeValue();
 		}
 		@Override
 		public String toString() {
 			return "VERSION_NEGATIVE";
 		}
 	};
 
 	protected VersionValue() {
 		this.value = null;
 	}
 
 	/**
 	 * Assume the transient instance is newly instantiated if
 	 * its version is null or equal to <tt>value</tt>
 	 * @param value value to compare to
 	 */
 	public VersionValue(Object value) {
 		this.value = value;
 	}
 
 	@Override
 	public Boolean isUnsaved(Object version) throws MappingException  {
 		LOG.tracev( "Version unsaved-value: {0}", value );
 		return version==null || version.equals(value);
 	}
 
 	@Override
 	public Object getDefaultValue(Object currentValue) {
 		return value;
 	}
 
 	@Override
     public String toString() {
 		return "version unsaved-value: " + value;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcTransaction.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcTransaction.java
index 4fb0320546..5614cab280 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcTransaction.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcTransaction.java
@@ -1,208 +1,208 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.transaction.internal.jdbc;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.TransactionException;
 import org.hibernate.engine.transaction.spi.AbstractTransactionImpl;
 import org.hibernate.engine.transaction.spi.IsolationDelegate;
 import org.hibernate.engine.transaction.spi.JoinStatus;
 import org.hibernate.engine.transaction.spi.LocalStatus;
 import org.hibernate.engine.transaction.spi.TransactionCoordinator;
 import org.hibernate.internal.CoreMessageLogger;
 
 /**
  * {@link org.hibernate.Transaction} implementation based on transaction management through a JDBC {@link java.sql.Connection}.
  * <p/>
  * This the default transaction strategy.
  *
  * @author Anton van Straaten
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class JdbcTransaction extends AbstractTransactionImpl {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, JdbcTransaction.class.getName() );
 
 	private Connection managedConnection;
 	private boolean wasInitiallyAutoCommit;
 	private boolean isDriver;
 
 	protected JdbcTransaction(TransactionCoordinator transactionCoordinator) {
 		super( transactionCoordinator );
 	}
 
 	@Override
 	protected void doBegin() {
 		try {
 			if ( managedConnection != null ) {
 				throw new TransactionException( "Already have an associated managed connection" );
 			}
 			managedConnection = transactionCoordinator().getJdbcCoordinator().getLogicalConnection().getConnection();
 			wasInitiallyAutoCommit = managedConnection.getAutoCommit();
 			LOG.debugv( "initial autocommit status: {0}", wasInitiallyAutoCommit );
 			if ( wasInitiallyAutoCommit ) {
 				LOG.debug( "disabling autocommit" );
 				managedConnection.setAutoCommit( false );
 			}
 		}
 		catch( SQLException e ) {
 			throw new TransactionException( "JDBC begin transaction failed: ", e );
 		}
 
 		isDriver = transactionCoordinator().takeOwnership();
 	}
 
 	@Override
 	protected void afterTransactionBegin() {
 		if ( getTimeout() > 0 ) {
 			transactionCoordinator().getJdbcCoordinator().setTransactionTimeOut( getTimeout() );
 		}
 		transactionCoordinator().sendAfterTransactionBeginNotifications( this );
 		if ( isDriver ) {
 			transactionCoordinator().getTransactionContext().afterTransactionBegin( this );
 		}
 	}
 
 	@Override
 	protected void beforeTransactionCommit() {
 		transactionCoordinator().sendBeforeTransactionCompletionNotifications( this );
 
 		// basically, if we are the driver of the transaction perform a managed flush prior to
 		// physically committing the transaction
 		if ( isDriver && !transactionCoordinator().getTransactionContext().isFlushModeNever() ) {
 			// if an exception occurs during flush, user must call rollback()
 			transactionCoordinator().getTransactionContext().managedFlush();
 		}
 
 		if ( isDriver ) {
 			transactionCoordinator().getTransactionContext().beforeTransactionCompletion( this );
 		}
 	}
 
 	@Override
 	protected void doCommit() throws TransactionException {
 		try {
 			managedConnection.commit();
 			LOG.debug( "committed JDBC Connection" );
 		}
 		catch( SQLException e ) {
 			throw new TransactionException( "unable to commit against JDBC connection", e );
 		}
 		finally {
 			releaseManagedConnection();
 		}
 	}
 
 	private void releaseManagedConnection() {
 		try {
 			if ( wasInitiallyAutoCommit ) {
 				LOG.debug( "re-enabling autocommit" );
 				managedConnection.setAutoCommit( true );
 			}
 			managedConnection = null;
 		}
 		catch ( Exception e ) {
 			LOG.debug( "Could not toggle autocommit", e );
 		}
 	}
 
 	@Override
 	protected void afterTransactionCompletion(int status) {
 		transactionCoordinator().afterTransaction( this, status );
 	}
 
 	@Override
 	protected void afterAfterCompletion() {
 		if ( isDriver
 				&& transactionCoordinator().getTransactionContext().shouldAutoClose()
 				&& !transactionCoordinator().getTransactionContext().isClosed() ) {
 			try {
 				transactionCoordinator().getTransactionContext().managedClose();
 			}
 			catch (HibernateException e) {
 				LOG.unableToCloseSessionButSwallowingError( e );
 			}
 		}
 	}
 
 	@Override
 	protected void beforeTransactionRollBack() {
 		// nothing to do here
 	}
 
 	@Override
 	protected void doRollback() throws TransactionException {
 		try {
 			managedConnection.rollback();
 			LOG.debug( "rolled JDBC Connection" );
 		}
 		catch( SQLException e ) {
 			throw new TransactionException( "unable to rollback against JDBC connection", e );
 		}
 		finally {
 			releaseManagedConnection();
 		}
 	}
 
 	@Override
 	public boolean isInitiator() {
 		return isActive();
 	}
 
 	@Override
 	public IsolationDelegate createIsolationDelegate() {
 		return new JdbcIsolationDelegate( transactionCoordinator() );
 	}
 
 	@Override
 	public JoinStatus getJoinStatus() {
 		return isActive() ? JoinStatus.JOINED : JoinStatus.NOT_JOINED;
 	}
 
 	@Override
 	public void markRollbackOnly() {
 		// nothing to do here
 	}
 
 	@Override
 	public void join() {
 		// nothing to do
 	}
 
 	@Override
 	public void resetJoinStatus() {
 		// nothing to do
 	}
 
 	@Override
 	public boolean isActive() throws HibernateException {
 		return getLocalStatus() == LocalStatus.ACTIVE;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcTransactionFactory.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcTransactionFactory.java
index 833c238821..163683db05 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcTransactionFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jdbc/JdbcTransactionFactory.java
@@ -1,63 +1,63 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.transaction.internal.jdbc;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.engine.transaction.spi.TransactionCoordinator;
 import org.hibernate.engine.transaction.spi.TransactionFactory;
 
 /**
  * Factory for {@link org.hibernate.engine.transaction.internal.jdbc.JdbcTransaction} instances.
  *
  * @author Anton van Straaten
  * @author Steve Ebersole
  */
 public final class JdbcTransactionFactory implements TransactionFactory<JdbcTransaction> {
 	public static final String SHORT_NAME = "jdbc";
 
 	@Override
 	public JdbcTransaction createTransaction(TransactionCoordinator transactionCoordinator) {
 		return new JdbcTransaction( transactionCoordinator );
 	}
 
 	@Override
 	public boolean canBeDriver() {
 		return true;
 	}
 
 	@Override
 	public ConnectionReleaseMode getDefaultReleaseMode() {
 		return ConnectionReleaseMode.ON_CLOSE;
 	}
 
 	@Override
 	public boolean compatibleWithJtaSynchronization() {
 		return false;
 	}
 
 	@Override
 	public boolean isJoinableJtaTransaction(TransactionCoordinator transactionCoordinator, JdbcTransaction transaction) {
 		return false;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaTransactionFactory.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaTransactionFactory.java
index f0e50881b9..842cd6a44e 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaTransactionFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaTransactionFactory.java
@@ -1,104 +1,104 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.transaction.internal.jta;
 
 import javax.transaction.SystemException;
 import javax.transaction.UserTransaction;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.TransactionException;
 import org.hibernate.engine.transaction.spi.TransactionCoordinator;
 import org.hibernate.engine.transaction.spi.TransactionFactory;
 import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 
 /**
  * Factory for {@link JtaTransaction} instances.
  *
  * @author Gavin King
  * @author Steve Ebersole
  * @author Les Hazlewood
  */
 public class JtaTransactionFactory implements TransactionFactory<JtaTransaction> {
 	public static final String SHORT_NAME = "jta";
 
 	@Override
 	public JtaTransaction createTransaction(TransactionCoordinator transactionCoordinator) {
 		return new JtaTransaction( transactionCoordinator );
 	}
 
 	@Override
 	public boolean canBeDriver() {
 		return true;
 	}
 
 	@Override
 	public ConnectionReleaseMode getDefaultReleaseMode() {
 		return ConnectionReleaseMode.AFTER_STATEMENT;
 	}
 
 	@Override
 	public boolean compatibleWithJtaSynchronization() {
 		return true;
 	}
 
 	@Override
 	public boolean isJoinableJtaTransaction(TransactionCoordinator transactionCoordinator, JtaTransaction transaction) {
 		try {
 			// Essentially:
 			// 1) If we have a local (Hibernate) transaction in progress
 			//      and it already has the UserTransaction cached, use that
 			//      UserTransaction to determine the status.
 			// 2) If a transaction manager has been located, use
 			//      that transaction manager to determine the status.
 			// 3) Finally, as the last resort, try to lookup the
 			//      UserTransaction via JNDI and use that to determine the
 			//      status.
 			if ( transaction != null ) {
 				UserTransaction ut = transaction.getUserTransaction();
 				if ( ut != null ) {
 					return JtaStatusHelper.isActive( ut );
 				}
 			}
 
 			final JtaPlatform jtaPlatform = transactionCoordinator
 					.getTransactionContext()
 					.getTransactionEnvironment()
 					.getJtaPlatform();
 			if ( jtaPlatform == null ) {
 				throw new TransactionException( "Unable to check transaction status" );
 			}
 			if ( jtaPlatform.retrieveTransactionManager() != null ) {
 				return JtaStatusHelper.isActive( jtaPlatform.retrieveTransactionManager().getStatus() );
 			}
 			else {
 				final UserTransaction ut = jtaPlatform.retrieveUserTransaction();
 				return ut != null && JtaStatusHelper.isActive( ut );
 			}
 		}
 		catch ( SystemException se ) {
 			throw new TransactionException( "Unable to check transaction status", se );
 		}
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/WebSphereExtendedJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/WebSphereExtendedJtaPlatform.java
index 19a81bdde7..9983fd6a9c 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/WebSphereExtendedJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/WebSphereExtendedJtaPlatform.java
@@ -1,255 +1,254 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.transaction.jta.platform.internal;
 
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import javax.transaction.NotSupportedException;
 import javax.transaction.RollbackException;
 import javax.transaction.Status;
 import javax.transaction.Synchronization;
 import javax.transaction.SystemException;
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 import javax.transaction.xa.XAResource;
 
 import org.hibernate.HibernateException;
 
 /**
  * JTA platform implementation intended for use with WebSphere Application Server (WAS).
  * <p/>
  * WAS, unlike every other app server on the planet, does not allow direct access to the JTS TransactionManager.
  * Instead, for common transaction-related tasks users must utilize a proprietary API known as ExtendedJTATransaction.
  * <p/>
  * Even more unfortunate, the exact TransactionManagerLookup to use inside of WAS is highly dependent upon<ul>
  *     <li>WAS version</li>
  *     <li>the WAS container in which Hibernate will be utilized</li>
  * </ul>
  * <p/>
  * This class is reported to work on WAS version 6 in any of the standard J2EE/JEE component containers.
  *
  * @author Gavin King
  * @author <a href="mailto:jesper@udby.com>Jesper Udby</a>
  * @author Steve Ebersole
  */
 public class WebSphereExtendedJtaPlatform extends AbstractJtaPlatform {
 	public static final String UT_NAME = "java:comp/UserTransaction";
 
 	@Override
 	protected boolean canCacheTransactionManager() {
 		return true;
 	}
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		return new TransactionManagerAdapter();
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return (UserTransaction) jndiService().locate( UT_NAME );
 	}
 
 	@Override
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public Object getTransactionIdentifier(Transaction transaction) {
 		// WebSphere, however, is not a sane JEE/JTA container...
-		return Integer.valueOf( transaction.hashCode() );
+		return transaction.hashCode();
 	}
 
 	public class TransactionManagerAdapter implements TransactionManager {
 		private final Class synchronizationCallbackClass;
 		private final Method registerSynchronizationMethod;
 		private final Method getLocalIdMethod;
 		private Object extendedJTATransaction;
 
 		private TransactionManagerAdapter() throws HibernateException {
 			try {
 				synchronizationCallbackClass = Class.forName( "com.ibm.websphere.jtaextensions.SynchronizationCallback" );
 				Class extendedJTATransactionClass = Class.forName( "com.ibm.websphere.jtaextensions.ExtendedJTATransaction" );
 				registerSynchronizationMethod = extendedJTATransactionClass.getMethod(
 						"registerSynchronizationCallbackForCurrentTran",
 						new Class[] { synchronizationCallbackClass }
 				);
 				getLocalIdMethod = extendedJTATransactionClass.getMethod( "getLocalId", (Class[]) null );
 			}
 			catch ( ClassNotFoundException cnfe ) {
 				throw new HibernateException( cnfe );
 			}
 			catch ( NoSuchMethodException nsme ) {
 				throw new HibernateException( nsme );
 			}
 		}
 
 		@Override
 		public void begin() throws NotSupportedException, SystemException {
 			throw new UnsupportedOperationException();
 		}
 
 		@Override
 		public void commit() throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
 		@Override
 		public int getStatus() throws SystemException {
 			return getTransaction() == null ? Status.STATUS_NO_TRANSACTION : getTransaction().getStatus();
 		}
 
 		@Override
 		public Transaction getTransaction() throws SystemException {
 			return new TransactionAdapter();
 		}
 
 		@Override
 		public void resume(Transaction txn) throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
 		@Override
 		public void rollback() throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
 		@Override
 		public void setRollbackOnly() throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
 		@Override
 		public void setTransactionTimeout(int i) throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
 		@Override
 		public Transaction suspend() throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
 		public class TransactionAdapter implements Transaction {
 
 			private TransactionAdapter() {
 				if ( extendedJTATransaction == null ) {
 					extendedJTATransaction = jndiService().locate( "java:comp/websphere/ExtendedJTATransaction" );
 				}
 			}
 
 			@Override
 			public void registerSynchronization(final Synchronization synchronization)
 					throws RollbackException, IllegalStateException,
 					SystemException {
 
 				final InvocationHandler ih = new InvocationHandler() {
 
 					@Override
 					public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 						if ( "afterCompletion".equals( method.getName() ) ) {
 							int status = args[2].equals(Boolean.TRUE) ?
 									Status.STATUS_COMMITTED :
 									Status.STATUS_UNKNOWN;
 							synchronization.afterCompletion(status);
 						}
 						else if ( "beforeCompletion".equals( method.getName() ) ) {
 							synchronization.beforeCompletion();
 						}
 						else if ( "toString".equals( method.getName() ) ) {
 							return synchronization.toString();
 						}
 						return null;
 					}
 
 				};
 
 				final Object synchronizationCallback = Proxy.newProxyInstance(
 						getClass().getClassLoader(),
 						new Class[] {synchronizationCallbackClass},
 						ih
 				);
 
 				try {
 					registerSynchronizationMethod.invoke( extendedJTATransaction, synchronizationCallback );
 				}
 				catch (Exception e) {
 					throw new HibernateException(e);
 				}
 
 			}
 
 			@Override
 			public int hashCode() {
 				return getLocalId().hashCode();
 			}
 
 			@Override
 			public boolean equals(Object other) {
 				if ( !(other instanceof TransactionAdapter) ) return false;
 				TransactionAdapter that = (TransactionAdapter) other;
 				return getLocalId().equals( that.getLocalId() );
 			}
 
 			private Object getLocalId() throws HibernateException {
 				try {
 					return getLocalIdMethod.invoke( extendedJTATransaction, (Object[]) null );
 				}
 				catch ( Exception e ) {
 					throw new HibernateException( e );
 				}
 			}
 
 			@Override
 			public void commit() throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 
 			@Override
 			public boolean delistResource(XAResource resource, int i) throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 
 			@Override
 			public boolean enlistResource(XAResource resource) throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 
 			@Override
 			public int getStatus() {
 				return Integer.valueOf( 0 ).equals( getLocalId() ) ?
 						Status.STATUS_NO_TRANSACTION : Status.STATUS_ACTIVE;
 			}
 
 			@Override
 			public void rollback() throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 
 			@Override
 			public void setRollbackOnly() throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionCoordinator.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionCoordinator.java
index 1babcac641..52f9054be0 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionCoordinator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionCoordinator.java
@@ -1,144 +1,144 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.transaction.spi;
 
 import java.io.Serializable;
 import java.sql.Connection;
 
 import org.hibernate.engine.jdbc.spi.JdbcCoordinator;
 import org.hibernate.engine.transaction.synchronization.spi.SynchronizationCallbackCoordinator;
 
 /**
  * Acts as the coordinator between the Hibernate engine and physical transactions.
  *
  * @author Steve Ebersole
  */
 public interface TransactionCoordinator extends Serializable {
 	/**
 	 * Retrieves the context in which this coordinator operates.
 	 *
 	 * @return The context of the coordinator
 	 */
 	public TransactionContext getTransactionContext();
 
 	/**
 	 * Retrieves the JDBC coordinator currently operating within this transaction coordinator.
 	 *
 	 * @return The JDBC coordinator.
 	 */
 	public JdbcCoordinator getJdbcCoordinator();
 
 	/**
 	 * Get the Hibernate transaction facade object currently associated with this coordinator.
 	 *
 	 * @return The current Hibernate transaction.
 	 */
 	public TransactionImplementor getTransaction();
 
 	/**
 	 * Obtain the {@link javax.transaction.Synchronization} registry associated with this coordinator.
 	 *
 	 * @return The registry
 	 */
 	public SynchronizationRegistry getSynchronizationRegistry();
 
 	/**
 	 * Adds an observer to the coordinator.
 	 * <p/>
 	 * Unlike synchronizations added to the {@link #getSynchronizationRegistry() registry}, observers are not to be
 	 * cleared on transaction completion.
 	 *
 	 * @param observer The observer to add.
 	 */
 	public void addObserver(TransactionObserver observer);
 
 	/**
 	 * Removed an observer from the coordinator.
 	 *
 	 * @param observer The observer to remove.
 	 */
 	public void removeObserver(TransactionObserver observer);
 	
 	/**
 	 * Can we join to the underlying transaction?
 	 *
 	 * @return {@literal true} if the underlying transaction can be joined or is already joined; {@literal false}
 	 * otherwise.
 	 *
 	 * @see TransactionFactory#isJoinableJtaTransaction(TransactionCoordinator, TransactionImplementor)
 	 */
 	public boolean isTransactionJoinable();
 
 	/**
 	 * Is the underlying transaction already joined?
 	 *
 	 * @return {@literal true} if the underlying transaction is already joined; {@literal false} otherwise.
 	 */
 	public boolean isTransactionJoined();
 
 	/**
 	 * Reset the transaction's join status.
 	 */
 	public void resetJoinStatus();
 
 	/**
 	 * Are we "in" an active and joined transaction
 	 *
 	 * @return {@literal true} if there is currently a transaction in progress; {@literal false} otherwise.
 	 */
 	public boolean isTransactionInProgress();
 
 	/**
 	 * Attempts to register JTA synchronization if possible and needed.
 	 */
 	public void pulse();
 
 	/**
 	 * Close the transaction context, returning any user supplied connection from the underlying JDBC coordinator.
 	 *
 	 * @return The user supplied connection (if one).
 	 */
 	public Connection close();
 
 	/**
 	 * Performs actions needed after execution of a non-transactional query.
 	 *
 	 * @param success Was the query successfully performed
 	 */
 	public void afterNonTransactionalQuery(boolean success);
 
 	public void setRollbackOnly();
 
 	public SynchronizationCallbackCoordinator getSynchronizationCallbackCoordinator();
 
 	public boolean isSynchronizationRegistered();
 	public boolean takeOwnership();
 
 	public void afterTransaction(TransactionImplementor hibernateTransaction, int status);
 
 	public void sendAfterTransactionBeginNotifications(TransactionImplementor hibernateTransaction);
 	public void sendBeforeTransactionCompletionNotifications(TransactionImplementor hibernateTransaction);
 	public void sendAfterTransactionCompletionNotifications(TransactionImplementor hibernateTransaction, int status);
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/event/internal/EventCache.java b/hibernate-core/src/main/java/org/hibernate/event/internal/EventCache.java
index 7c4bc9a26a..757863637b 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/internal/EventCache.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/internal/EventCache.java
@@ -1,366 +1,366 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.event.internal;
 
 import java.util.Collection;
 import java.util.Collections;
 import java.util.IdentityHashMap;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.event.spi.EventSource;
 import org.hibernate.pretty.MessageHelper;
 
 /**
  * EventCache is a Map implementation that can be used by an event
  * listener to keep track of entities involved in the operation
  * being performed. This implementation allows entities to be added
  * to the EventCache before the operation has cascaded to that
  * entity.
  * <p/>
  * There are some restriction;
  * <ul>
  *     <li>the same value cannot be associated with more than one key</li>
  *     <li>Methods that return collections (e.g., {@link #keySet()},
  *          {@link #values()}, {@link #entrySet()}) return an
  *          unnmodifiable view of the collection.</li>
  * </ul>
  * <p/>
  * The following methods can be used by event listeners (and other
  * classes) in the same package to add entities to an EventCache
  * and indicate if the operation is being performed on the entity:<p/>
  * {@link EventCache#put(Object entity, Object copy, boolean isOperatedOn)}
  * <p/>
  * The following method can be used by event listeners (and other
  * classes) in the same package to indicate that the operation is being
  * performed on an entity already in the EventCache:
  * {@link EventCache#setOperatedOn(Object entity, boolean isOperatedOn)
  *
  * @author Gail Badner
  */
 class EventCache implements Map {
 	private final EventSource session;
 
 	private Map<Object,Object> entityToCopyMap = new IdentityHashMap<Object,Object>(10);
 		// key is an entity involved with the operation performed by the listener;
 		// value can be either a copy of the entity or the entity itself
 
 	private Map<Object,Object> copyToEntityMap = new IdentityHashMap<Object,Object>( 10 );
 		// maintains the inverse of the entityToCopyMap for performance reasons.
 
 	private Map<Object,Boolean> entityToOperatedOnFlagMap = new IdentityHashMap<Object,Boolean>( 10 );
 	    // key is an entity involved with the operation performed by the listener;
 	    // value is a flag indicating if the listener explicitly operates on the entity
 
 	EventCache(EventSource session) {
 		this.session = session;
 	}
 
 	/**
 	 * Clears the EventCache.
 	 */
 	public void clear() {
 		entityToCopyMap.clear();
 		copyToEntityMap.clear();
 		entityToOperatedOnFlagMap.clear();
 	}
 
 	/**
 	 * Returns true if this EventCache contains a mapping for the specified entity.
 	 * @param entity must be non-null
 	 * @return true if this EventCache contains a mapping for the specified entity
 	 * @throws NullPointerException if entity is null
 	 */
 	public boolean containsKey(Object entity) {
 		if ( entity == null ) {
 			throw new NullPointerException( "null entities are not supported by " + getClass().getName() );
 		}
 		return entityToCopyMap.containsKey( entity );
 	}
 
 	/**
 	 * Returns true if this EventCache maps an entity to the specified copy.
 	 * @param copy must be non-null
 	 * @return true if this EventCache maps an entity to the specified copy
 	 * @throws NullPointerException if copy is null
 	 */
 	public boolean containsValue(Object copy) {
 		if ( copy == null ) {
 			throw new NullPointerException( "null copies are not supported by " + getClass().getName() );
 		}
 		return copyToEntityMap.containsKey( copy );
 	}
 
 	/**
 	 * Returns an unmodifiable set view of the entity-to-copy mappings contained in this EventCache.
 	 * @return an unmodifiable set view of the entity-to-copy mappings contained in this EventCache
 	 *
 	 * @see {@link Collections#unmodifiableSet(java.util.Set)}
 	 */
 	public Set entrySet() {
 		return Collections.unmodifiableSet( entityToCopyMap.entrySet() );
 	}
 
 	/**
 	 * Returns the copy to which this EventCache maps the specified entity.
 	 * @param entity must be non-null
 	 * @return the copy to which this EventCache maps the specified entity
 	 * @throws NullPointerException if entity is null
 	 */
 	public Object get(Object entity) {
 		if ( entity == null ) {
 			throw new NullPointerException( "null entities are not supported by " + getClass().getName() );
 		}
 		return entityToCopyMap.get( entity );
 	}
 
 	/**
 	 * Returns true if this EventCache contains no entity-copy mappings.
 	 * @return true if this EventCache contains no entity-copy mappings
 	 */
 	public boolean isEmpty() {
 		return entityToCopyMap.isEmpty();
 	}
 
 	/**
 	 * Returns an unmodifiable set view of the entities contained in this EventCache
 	 * @return an unmodifiable set view of the entities contained in this EventCache
 	 *
 	 * @see {@link Collections#unmodifiableSet(java.util.Set)}
 	 */
 	public Set keySet() {
 		return Collections.unmodifiableSet( entityToCopyMap.keySet() );
 	}
 
 	/**
 	 * Associates the specified entity with the specified copy in this EventCache;
 	 * @param entity must be non-null
 	 * @param copy must be non- null and must not be associated with any other entity in this EntityCache.
 	 * @return previous copy associated with specified entity, or null if
 	 * there was no mapping for entity.
 	 * @throws NullPointerException if entity or copy is null
 	 * @throws IllegalStateException if the specified copy is already associated with a different entity.
 	 */
 	public Object put(Object entity, Object copy) {
 		return put( entity, copy, Boolean.FALSE );
 	}
 
 	/**
 	 * Associates the specified entity with the specified copy in this EventCache;
 	 * @param entity must be non-null
 	 * @param copy must be non- null and must not be associated with any other entity in this EntityCache.
 	 * @param isOperatedOn indicates if the operation is performed on the entity.
 	 *
 	 * @return previous copy associated with specified entity, or null if
 	 * there was no mapping for entity.
 	 * @throws NullPointerException if entity or copy is null
 	 * @throws IllegalStateException if the specified copy is already associated with a different entity.
 	 */
 	/* package-private */ Object put(Object entity, Object copy, boolean isOperatedOn) {
 		if ( entity == null || copy == null ) {
 			throw new NullPointerException( "null entities and copies are not supported by " + getClass().getName() );
 		}
 
 		Object oldCopy = entityToCopyMap.put( entity, copy );
 		Boolean oldOperatedOn = entityToOperatedOnFlagMap.put( entity, isOperatedOn );
 		Object oldEntity = copyToEntityMap.put( copy, entity );
 
 		if ( oldCopy == null ) {
 			if  ( oldEntity != null ) {
 				throw new IllegalStateException(
 						"Error occurred while storing entity " + printEntity( entity ) + ". An entity copy " + printEntity( copy )
 								+ " was already assigned to a different entity " + printEntity( oldEntity ) + "."
 				);
 			}
 			if ( oldOperatedOn != null ) {
 				throw new IllegalStateException(
 						"EventCache#entityToOperatedOnFlagMap contains an entity " + printEntity( entity )
 								+ ", but EventCache#entityToCopyMap does not."
 				);
 			}
 		}
 		else {
 			if ( oldCopy != copy ) {
 				// Replaced an entity copy with a new copy; need to remove the oldCopy from copyToEntityMap
 				// to synch things up.
 				Object removedEntity = copyToEntityMap.remove( oldCopy );
 				if ( removedEntity != entity ) {
 					throw new IllegalStateException(
 							"Error occurred while storing entity " + printEntity( entity ) + ". An unexpected entity " + printEntity( removedEntity )
 									+ " was associated with the old entity copy " + printEntity( oldCopy ) + "."
 					);
 				}
 				if ( oldEntity != null ) {
 					throw new IllegalStateException(
 							"Error occurred while storing entity " + printEntity( entity ) + ". A new entity copy " + printEntity( copy )
 									+ " is already associated with a different entity " + printEntity( oldEntity ) + "."
 					);
 				}
 			}
 			else {
 				// Replaced an entity copy with the same copy in entityToCopyMap.
 				// Make sure that copy is associated with the same entity in copyToEntityMap.
 				if ( oldEntity != entity ) {
 					throw new IllegalStateException(
 							"An entity copy " + printEntity( copy ) + " was associated with a different entity "
 									+ printEntity( oldEntity ) + " than provided " + printEntity( entity ) + "."
 					);
 				}
 			}
 			if ( oldOperatedOn == null ) {
 				throw new IllegalStateException(
 						"EventCache#entityToCopyMap contained an entity " + printEntity( entity )
 								+ ", but EventCache#entityToOperatedOnFlagMap did not."
 				);
 			}
 		}
 
 		return oldCopy;
 	}
 
 	/**
 	 * Copies all of the mappings from the specified map to this EventCache
 	 * @param map keys and values must be non-null
 	 * @throws NullPointerException if any map keys or values are null
 	 */
 	public void putAll(Map map) {
 		for ( Object o : map.entrySet() ) {
 			Entry entry = (Entry) o;
 			put( entry.getKey(), entry.getValue() );
 		}
 	}
 
 	/**
 	 * Removes the mapping for this entity from this EventCache if it is present
 	 * @param entity must be non-null
 	 * @return previous value associated with specified entity, or null if there was no mapping for entity.
 	 * @throws NullPointerException if entity is null
 	 */
 	public Object remove(Object entity) {
 		if ( entity == null ) {
 			throw new NullPointerException( "null entities are not supported by " + getClass().getName() );
 		}
 		Boolean oldOperatedOn = entityToOperatedOnFlagMap.remove( entity );
 		Object oldCopy = entityToCopyMap.remove( entity );
 		Object oldEntity = oldCopy != null ? copyToEntityMap.remove( oldCopy ) : null;
 
 		if ( oldCopy == null ) {
 			if ( oldOperatedOn != null ) {
 				throw new IllegalStateException(
 						"Removed entity " + printEntity( entity )
 								+ " from EventCache#entityToOperatedOnFlagMap, but EventCache#entityToCopyMap did not contain the entity."
 				);
 			}
 		}
 		else {
 			if ( oldEntity == null ) {
 				throw new IllegalStateException(
 						"Removed entity " + printEntity( entity )
 								+ " from EventCache#entityToCopyMap, but EventCache#copyToEntityMap did not contain the entity."
 				);
 			}
 			if ( oldOperatedOn == null ) {
 				throw new IllegalStateException(
 						"EventCache#entityToCopyMap contained an entity " + printEntity( entity )
 								+ ", but EventCache#entityToOperatedOnFlagMap did not."
 				);
 			}
 			if ( oldEntity != entity ) {
 				throw new IllegalStateException(
 						"An entity copy " + printEntity( oldCopy ) + " was associated with a different entity "
 								+ printEntity( oldEntity ) + " than provided " + printEntity( entity ) + "."
 				);
 			}
 		}
 
 		return oldCopy;
 	}
 
 	/**
 	 * Returns the number of entity-copy mappings in this EventCache
 	 * @return the number of entity-copy mappings in this EventCache
 	 */
 	public int size() {
 		return entityToCopyMap.size();
 	}
 
 	/**
 	 * Returns an unmodifiable set view of the entity copies contained in this EventCache.
 	 * @return an unmodifiable set view of the entity copies contained in this EventCache
 	 *
 	 * @see {@link Collections#unmodifiableSet(java.util.Set)}
 	 */
 	public Collection values() {
 		return Collections.unmodifiableCollection( entityToCopyMap.values() );
 	}
 
 	/**
 	 * Returns true if the listener is performing the operation on the specified entity.
 	 * @param entity must be non-null
 	 * @return true if the listener is performing the operation on the specified entity.
 	 * @throws NullPointerException if entity is null
 	 */
 	public boolean isOperatedOn(Object entity) {
 		if ( entity == null ) {
 			throw new NullPointerException( "null entities are not supported by " + getClass().getName() );
 		}
 		return entityToOperatedOnFlagMap.get( entity );
 	}
 
 	/**
 	 * Set flag to indicate if the listener is performing the operation on the specified entity.
 	 * @param entity must be non-null and this EventCache must contain a mapping for this entity
 	 * @throws NullPointerException if entity is null
 	 * @throws AssertionFailure if this EventCache does not contain a mapping for the specified entity
 	 */
 	/* package-private */ void setOperatedOn(Object entity, boolean isOperatedOn) {
 		if ( entity == null ) {
 			throw new NullPointerException( "null entities are not supported by " + getClass().getName() );
 		}
 		if ( ! entityToOperatedOnFlagMap.containsKey( entity ) ||
 			! entityToCopyMap.containsKey( entity ) ) {
 			throw new AssertionFailure( "called EventCache#setOperatedOn() for entity not found in EventCache" );
 		}
 		entityToOperatedOnFlagMap.put( entity, isOperatedOn );
 	}
 
 	/**
 	 * Returns an unmodifiable map view of the copy-entity mappings
 	 * @return an unmodifiable map view of the copy-entity mappings
 	 *
 	 * @see {@link Collections#unmodifiableMap(java.util.Map)}
 	 */
 	public Map invertMap() {
 		return Collections.unmodifiableMap( copyToEntityMap );
 	}
 
 	private String printEntity(Object entity) {
 		if ( session.getPersistenceContext().getEntry( entity ) != null ) {
 			return MessageHelper.infoString( session.getEntityName( entity ), session.getIdentifier( entity ) );
 		}
 		// Entity was not found in current persistence context. Use Object#toString() method.
 		return "[" + entity + "]";
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerServiceInitiator.java b/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerServiceInitiator.java
index c4eec7b474..76493f43d5 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerServiceInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerServiceInitiator.java
@@ -1,61 +1,61 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.event.service.internal;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceInitiator;
 
 /**
  * Service initiator for {@link EventListenerRegistry}
  *
  * @author Steve Ebersole
  */
 public class EventListenerServiceInitiator implements SessionFactoryServiceInitiator<EventListenerRegistry> {
 	public static final EventListenerServiceInitiator INSTANCE = new EventListenerServiceInitiator();
 
 	@Override
 	public Class<EventListenerRegistry> getServiceInitiated() {
 		return EventListenerRegistry.class;
 	}
 
 	@Override
 	public EventListenerRegistry initiateService(
 			SessionFactoryImplementor sessionFactory,
 			Configuration configuration,
 			ServiceRegistryImplementor registry) {
 		return new EventListenerRegistryImpl();
 	}
 
 	@Override
 	public EventListenerRegistry initiateService(
 			SessionFactoryImplementor sessionFactory,
 			MetadataImplementor metadata,
 			ServiceRegistryImplementor registry) {
 		return new EventListenerRegistryImpl();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlSqlWalker.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlSqlWalker.java
index 8f32783230..81d312c93e 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlSqlWalker.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/HqlSqlWalker.java
@@ -1,1259 +1,1259 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.hql.internal.ast;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import antlr.ASTFactory;
 import antlr.RecognitionException;
 import antlr.SemanticException;
 import antlr.collections.AST;
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.QueryException;
 import org.hibernate.engine.internal.JoinSequence;
 import org.hibernate.engine.internal.ParameterBinder;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.hql.internal.antlr.HqlSqlBaseWalker;
 import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
 import org.hibernate.hql.internal.antlr.HqlTokenTypes;
 import org.hibernate.hql.internal.antlr.SqlTokenTypes;
 import org.hibernate.hql.internal.ast.tree.AggregateNode;
 import org.hibernate.hql.internal.ast.tree.AssignmentSpecification;
 import org.hibernate.hql.internal.ast.tree.CollectionFunction;
 import org.hibernate.hql.internal.ast.tree.ConstructorNode;
 import org.hibernate.hql.internal.ast.tree.DeleteStatement;
 import org.hibernate.hql.internal.ast.tree.DotNode;
 import org.hibernate.hql.internal.ast.tree.FromClause;
 import org.hibernate.hql.internal.ast.tree.FromElement;
 import org.hibernate.hql.internal.ast.tree.FromElementFactory;
 import org.hibernate.hql.internal.ast.tree.FromReferenceNode;
 import org.hibernate.hql.internal.ast.tree.IdentNode;
 import org.hibernate.hql.internal.ast.tree.IndexNode;
 import org.hibernate.hql.internal.ast.tree.InsertStatement;
 import org.hibernate.hql.internal.ast.tree.IntoClause;
 import org.hibernate.hql.internal.ast.tree.MethodNode;
 import org.hibernate.hql.internal.ast.tree.OperatorNode;
 import org.hibernate.hql.internal.ast.tree.ParameterContainer;
 import org.hibernate.hql.internal.ast.tree.ParameterNode;
 import org.hibernate.hql.internal.ast.tree.QueryNode;
 import org.hibernate.hql.internal.ast.tree.ResolvableNode;
 import org.hibernate.hql.internal.ast.tree.RestrictableStatement;
 import org.hibernate.hql.internal.ast.tree.ResultVariableRefNode;
 import org.hibernate.hql.internal.ast.tree.SelectClause;
 import org.hibernate.hql.internal.ast.tree.SelectExpression;
 import org.hibernate.hql.internal.ast.tree.UpdateStatement;
 import org.hibernate.hql.internal.ast.util.ASTPrinter;
 import org.hibernate.hql.internal.ast.util.ASTUtil;
 import org.hibernate.hql.internal.ast.util.AliasGenerator;
 import org.hibernate.hql.internal.ast.util.JoinProcessor;
 import org.hibernate.hql.internal.ast.util.LiteralProcessor;
 import org.hibernate.hql.internal.ast.util.NodeTraverser;
 import org.hibernate.hql.internal.ast.util.SessionFactoryHelper;
 import org.hibernate.hql.internal.ast.util.SyntheticAndFactory;
 import org.hibernate.hql.spi.QueryTranslator;
 import org.hibernate.id.BulkInsertionCapableIdentifierGenerator;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.param.CollectionFilterKeyParameterSpecification;
 import org.hibernate.param.NamedParameterSpecification;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.param.PositionalParameterSpecification;
 import org.hibernate.param.VersionTypeSeedParameterSpecification;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.JoinType;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.ComponentType;
 import org.hibernate.type.DbTimestampType;
 import org.hibernate.type.Type;
 import org.hibernate.type.VersionType;
 import org.hibernate.usertype.UserVersionType;
 
 /**
  * Implements methods used by the HQL->SQL tree transform grammar (a.k.a. the second phase).
  * <ul>
  * <li>Isolates the Hibernate API-specific code from the ANTLR generated code.</li>
  * <li>Handles the SQL fragments generated by the persisters in order to create the SELECT and FROM clauses,
  * taking into account the joins and projections that are implied by the mappings (persister/queryable).</li>
  * <li>Uses SqlASTFactory to create customized AST nodes.</li>
  * </ul>
  *
  * @see SqlASTFactory
  */
 public class HqlSqlWalker extends HqlSqlBaseWalker implements ErrorReporter, ParameterBinder.NamedParameterSource {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, HqlSqlWalker.class.getName());
 
 	private final QueryTranslatorImpl queryTranslatorImpl;
 	private final HqlParser hqlParser;
 	private final SessionFactoryHelper sessionFactoryHelper;
 	private final Map tokenReplacements;
 	private final AliasGenerator aliasGenerator = new AliasGenerator();
 	private final LiteralProcessor literalProcessor;
 	private final ParseErrorHandler parseErrorHandler;
 	private final ASTPrinter printer;
 	private final String collectionFilterRole;
 
 	private FromClause currentFromClause = null;
 	private SelectClause selectClause;
 
 	/**
 	 * Maps each top-level result variable to its SelectExpression;
 	 * (excludes result variables defined in subqueries)
 	 **/
 	private Map<String, SelectExpression> selectExpressionsByResultVariable = new HashMap<String, SelectExpression>();
 
-	private Set querySpaces = new HashSet();
+	private Set<Serializable> querySpaces = new HashSet<Serializable>();
 
 	private int parameterCount;
 	private Map namedParameters = new HashMap();
 	private ArrayList parameters = new ArrayList();
 	private int numberOfParametersInSetClause;
 	private int positionalParameterCount;
 
 	private ArrayList assignmentSpecifications = new ArrayList();
 
 	private JoinType impliedJoinType = JoinType.INNER_JOIN;
 
 	/**
 	 * Create a new tree transformer.
 	 *
 	 * @param qti Back pointer to the query translator implementation that is using this tree transform.
 	 * @param sfi The session factory implementor where the Hibernate mappings can be found.
 	 * @param parser A reference to the phase-1 parser
 	 * @param tokenReplacements Registers the token replacement map with the walker.  This map will
 	 * be used to substitute function names and constants.
 	 * @param collectionRole The collection role name of the collection used as the basis for the
 	 * filter, NULL if this is not a collection filter compilation.
 	 */
 	public HqlSqlWalker(
 			QueryTranslatorImpl qti,
 			SessionFactoryImplementor sfi,
 			HqlParser parser,
 			Map tokenReplacements,
 			String collectionRole) {
 		setASTFactory( new SqlASTFactory( this ) );
 		// Initialize the error handling delegate.
 		this.parseErrorHandler = new ErrorCounter( qti.getQueryString() );
 		this.queryTranslatorImpl = qti;
 		this.sessionFactoryHelper = new SessionFactoryHelper( sfi );
 		this.literalProcessor = new LiteralProcessor( this );
 		this.tokenReplacements = tokenReplacements;
 		this.collectionFilterRole = collectionRole;
 		this.hqlParser = parser;
 		this.printer = new ASTPrinter( SqlTokenTypes.class );
 	}
 
 
 	// handle trace logging ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	private int traceDepth = 0;
 
 	@Override
 	public void traceIn(String ruleName, AST tree) {
 		if ( !LOG.isTraceEnabled() ) return;
 		if ( inputState.guessing > 0 ) return;
 		String prefix = StringHelper.repeat( '-', ( traceDepth++ * 2 ) ) + "-> ";
 		String traceText = ruleName + " (" + buildTraceNodeName( tree ) + ")";
 		LOG.trace( prefix + traceText );
 	}
 
 	private String buildTraceNodeName(AST tree) {
 		return tree == null
 				? "???"
 				: tree.getText() + " [" + printer.getTokenTypeName( tree.getType() ) + "]";
 	}
 
 	@Override
 	public void traceOut(String ruleName, AST tree) {
 		if ( !LOG.isTraceEnabled() ) return;
 		if ( inputState.guessing > 0 ) return;
 		String prefix = "<-" + StringHelper.repeat( '-', ( --traceDepth * 2 ) ) + " ";
 		LOG.trace( prefix + ruleName );
 	}
 
 	@Override
     protected void prepareFromClauseInputTree(AST fromClauseInput) {
 		if ( !isSubQuery() ) {
 //			// inject param specifications to account for dynamic filter param values
 //			if ( ! getEnabledFilters().isEmpty() ) {
 //				Iterator filterItr = getEnabledFilters().values().iterator();
 //				while ( filterItr.hasNext() ) {
 //					FilterImpl filter = ( FilterImpl ) filterItr.next();
 //					if ( ! filter.getFilterDefinition().getParameterNames().isEmpty() ) {
 //						Iterator paramItr = filter.getFilterDefinition().getParameterNames().iterator();
 //						while ( paramItr.hasNext() ) {
 //							String parameterName = ( String ) paramItr.next();
 //							// currently param filters *only* work with single-column parameter types;
 //							// if that limitation is ever lifted, this logic will need to change to account for that
 //							ParameterNode collectionFilterKeyParameter = ( ParameterNode ) astFactory.create( PARAM, "?" );
 //							DynamicFilterParameterSpecification paramSpec = new DynamicFilterParameterSpecification(
 //									filter.getName(),
 //									parameterName,
 //									filter.getFilterDefinition().getParameterType( parameterName ),
 //									 positionalParameterCount++
 //							);
 //							collectionFilterKeyParameter.setHqlParameterSpecification( paramSpec );
 //							parameters.add( paramSpec );
 //						}
 //					}
 //				}
 //			}
 
 			if ( isFilter() ) {
                 // Handle collection-filter compilation.
 				// IMPORTANT NOTE: This is modifying the INPUT (HQL) tree, not the output tree!
 				QueryableCollection persister = sessionFactoryHelper.getCollectionPersister( collectionFilterRole );
 				Type collectionElementType = persister.getElementType();
 				if ( !collectionElementType.isEntityType() ) {
 					throw new QueryException( "collection of values in filter: this" );
 				}
 
 				String collectionElementEntityName = persister.getElementPersister().getEntityName();
 				ASTFactory inputAstFactory = hqlParser.getASTFactory();
 				AST fromElement = ASTUtil.create( inputAstFactory, HqlTokenTypes.FILTER_ENTITY, collectionElementEntityName );
 				ASTUtil.createSibling( inputAstFactory, HqlTokenTypes.ALIAS, "this", fromElement );
 				fromClauseInput.addChild( fromElement );
 				// Show the modified AST.
                 LOG.debug("prepareFromClauseInputTree() : Filter - Added 'this' as a from element...");
 				queryTranslatorImpl.showHqlAst( hqlParser.getAST() );
 
 				// Create a parameter specification for the collection filter...
 				Type collectionFilterKeyType = sessionFactoryHelper.requireQueryableCollection( collectionFilterRole ).getKeyType();
 				ParameterNode collectionFilterKeyParameter = ( ParameterNode ) astFactory.create( PARAM, "?" );
 				CollectionFilterKeyParameterSpecification collectionFilterKeyParameterSpec = new CollectionFilterKeyParameterSpecification(
 						collectionFilterRole, collectionFilterKeyType, positionalParameterCount++
 				);
 				collectionFilterKeyParameter.setHqlParameterSpecification( collectionFilterKeyParameterSpec );
 				parameters.add( collectionFilterKeyParameterSpec );
 			}
 		}
 	}
 
 	public boolean isFilter() {
 		return collectionFilterRole != null;
 	}
 
 	public String getCollectionFilterRole() {
 		return collectionFilterRole;
 	}
 
 	public SessionFactoryHelper getSessionFactoryHelper() {
 		return sessionFactoryHelper;
 	}
 
 	public Map getTokenReplacements() {
 		return tokenReplacements;
 	}
 
 	public AliasGenerator getAliasGenerator() {
 		return aliasGenerator;
 	}
 
 	public FromClause getCurrentFromClause() {
 		return currentFromClause;
 	}
 
 	public ParseErrorHandler getParseErrorHandler() {
 		return parseErrorHandler;
 	}
 
 	@Override
     public void reportError(RecognitionException e) {
 		parseErrorHandler.reportError( e ); // Use the delegate.
 	}
 
 	@Override
     public void reportError(String s) {
 		parseErrorHandler.reportError( s ); // Use the delegate.
 	}
 
 	@Override
     public void reportWarning(String s) {
 		parseErrorHandler.reportWarning( s );
 	}
 
 	/**
 	 * Returns the set of unique query spaces (a.k.a.
 	 * table names) that occurred in the query.
 	 *
 	 * @return A set of table names (Strings).
 	 */
-	public Set getQuerySpaces() {
+	public Set<Serializable> getQuerySpaces() {
 		return querySpaces;
 	}
 
 	@Override
     protected AST createFromElement(String path, AST alias, AST propertyFetch) throws SemanticException {
 		FromElement fromElement = currentFromClause.addFromElement( path, alias );
 		fromElement.setAllPropertyFetch(propertyFetch!=null);
 		return fromElement;
 	}
 
 	@Override
     protected AST createFromFilterElement(AST filterEntity, AST alias) throws SemanticException {
 		FromElement fromElement = currentFromClause.addFromElement( filterEntity.getText(), alias );
 		FromClause fromClause = fromElement.getFromClause();
 		QueryableCollection persister = sessionFactoryHelper.getCollectionPersister( collectionFilterRole );
 		// Get the names of the columns used to link between the collection
 		// owner and the collection elements.
 		String[] keyColumnNames = persister.getKeyColumnNames();
 		String fkTableAlias = persister.isOneToMany()
 				? fromElement.getTableAlias()
 				: fromClause.getAliasGenerator().createName( collectionFilterRole );
 		JoinSequence join = sessionFactoryHelper.createJoinSequence();
 		join.setRoot( persister, fkTableAlias );
 		if ( !persister.isOneToMany() ) {
 			join.addJoin( ( AssociationType ) persister.getElementType(),
 					fromElement.getTableAlias(),
 					JoinType.INNER_JOIN,
 					persister.getElementColumnNames( fkTableAlias ) );
 		}
 		join.addCondition( fkTableAlias, keyColumnNames, " = ?" );
 		fromElement.setJoinSequence( join );
 		fromElement.setFilter( true );
         LOG.debug("createFromFilterElement() : processed filter FROM element.");
 		return fromElement;
 	}
 
 	@Override
     protected void createFromJoinElement(
 	        AST path,
 	        AST alias,
 	        int joinType,
 	        AST fetchNode,
 	        AST propertyFetch,
 	        AST with) throws SemanticException {
 		boolean fetch = fetchNode != null;
 		if ( fetch && isSubQuery() ) {
 			throw new QueryException( "fetch not allowed in subquery from-elements" );
 		}
 		// The path AST should be a DotNode, and it should have been evaluated already.
 		if ( path.getType() != SqlTokenTypes.DOT ) {
 			throw new SemanticException( "Path expected for join!" );
 		}
 		DotNode dot = ( DotNode ) path;
 		JoinType hibernateJoinType = JoinProcessor.toHibernateJoinType( joinType );
 		dot.setJoinType( hibernateJoinType );	// Tell the dot node about the join type.
 		dot.setFetch( fetch );
 		// Generate an explicit join for the root dot node.   The implied joins will be collected and passed up
 		// to the root dot node.
 		dot.resolve( true, false, alias == null ? null : alias.getText() );
 
 		final FromElement fromElement;
 		if ( dot.getDataType() != null && dot.getDataType().isComponentType() ) {
 			FromElementFactory factory = new FromElementFactory(
 					getCurrentFromClause(),
 					dot.getLhs().getFromElement(),
 					dot.getPropertyPath(),
 					alias == null ? null : alias.getText(),
 					null,
 					false
 			);
 			fromElement = factory.createComponentJoin( (ComponentType) dot.getDataType() );
 		}
 		else {
 			fromElement = dot.getImpliedJoin();
 			fromElement.setAllPropertyFetch( propertyFetch != null );
 
 			if ( with != null ) {
 				if ( fetch ) {
 					throw new SemanticException( "with-clause not allowed on fetched associations; use filters" );
 				}
 				handleWithFragment( fromElement, with );
 			}
 		}
 
         if (LOG.isDebugEnabled()) LOG.debugf("createFromJoinElement() : %s",
                                              getASTPrinter().showAsString(fromElement, "-- join tree --"));
 	}
 
 	private void handleWithFragment(FromElement fromElement, AST hqlWithNode) throws SemanticException {
 		try {
 			withClause( hqlWithNode );
 			AST hqlSqlWithNode = returnAST;
             if (LOG.isDebugEnabled()) LOG.debugf("handleWithFragment() : %s",
                                                  getASTPrinter().showAsString(hqlSqlWithNode, "-- with clause --"));
 			WithClauseVisitor visitor = new WithClauseVisitor( fromElement, queryTranslatorImpl );
 			NodeTraverser traverser = new NodeTraverser( visitor );
 			traverser.traverseDepthFirst( hqlSqlWithNode );
 
 			String withClauseJoinAlias = visitor.getJoinAlias();
 			if ( withClauseJoinAlias == null ) {
 				withClauseJoinAlias = fromElement.getCollectionTableAlias();
 			}
 			else {
 				FromElement referencedFromElement = visitor.getReferencedFromElement();
 				if ( referencedFromElement != fromElement ) {
 					throw new InvalidWithClauseException(
 							"with-clause expressions did not reference from-clause element to which the with-clause was associated",
 							queryTranslatorImpl.getQueryString()
 					);
 				}
 			}
 
 			SqlGenerator sql = new SqlGenerator( getSessionFactoryHelper().getFactory() );
 			sql.whereExpr( hqlSqlWithNode.getFirstChild() );
 
 			fromElement.setWithClauseFragment( withClauseJoinAlias, "(" + sql.getSQL() + ")" );
 		}
 		catch( SemanticException e ) {
 			throw e;
 		}
 		catch( InvalidWithClauseException e ) {
 			throw e;
 		}
 		catch ( Exception e) {
 			throw new SemanticException( e.getMessage() );
 		}
 	}
 
 	private static class WithClauseVisitor implements NodeTraverser.VisitationStrategy {
 		private final FromElement joinFragment;
 		private final QueryTranslatorImpl queryTranslatorImpl;
 
 		private FromElement referencedFromElement;
 		private String joinAlias;
 
 		public WithClauseVisitor(FromElement fromElement, QueryTranslatorImpl queryTranslatorImpl) {
 			this.joinFragment = fromElement;
 			this.queryTranslatorImpl = queryTranslatorImpl;
 		}
 
 		public void visit(AST node) {
             // TODO : currently expects that the individual with expressions apply to the same sql table join.
 			//      This may not be the case for joined-subclass where the property values
 			//      might be coming from different tables in the joined hierarchy.  At some
 			//      point we should expand this to support that capability.  However, that has
 			//      some difficulties:
 			//          1) the biggest is how to handle ORs when the individual comparisons are
 			//              linked to different sql joins.
 			//          2) here we would need to track each comparison individually, along with
 			//              the join alias to which it applies and then pass that information
 			//              back to the FromElement so it can pass it along to the JoinSequence
 			if ( node instanceof DotNode ) {
 				DotNode dotNode = ( DotNode ) node;
 				FromElement fromElement = dotNode.getFromElement();
 				if ( referencedFromElement != null ) {
 					if ( fromElement != referencedFromElement ) {
 						throw new HibernateException( "with-clause referenced two different from-clause elements" );
 					}
 				}
 				else {
 					referencedFromElement = fromElement;
 					joinAlias = extractAppliedAlias( dotNode );
                     // TODO : temporary
 					//      needed because currently persister is the one that
                     // creates and renders the join fragments for inheritance
 					//      hierarchies...
 					if ( !joinAlias.equals( referencedFromElement.getTableAlias() ) ) {
 						throw new InvalidWithClauseException(
 								"with clause can only reference columns in the driving table",
 								queryTranslatorImpl.getQueryString()
 						);
 					}
 				}
 			}
 			else if ( node instanceof ParameterNode ) {
 				applyParameterSpecification( ( ( ParameterNode ) node ).getHqlParameterSpecification() );
 			}
 			else if ( node instanceof ParameterContainer ) {
 				applyParameterSpecifications( ( ParameterContainer ) node );
 			}
 		}
 
 		private void applyParameterSpecifications(ParameterContainer parameterContainer) {
 			if ( parameterContainer.hasEmbeddedParameters() ) {
 				ParameterSpecification[] specs = parameterContainer.getEmbeddedParameters();
 				for ( ParameterSpecification spec : specs ) {
 					applyParameterSpecification( spec );
 				}
 			}
 		}
 
 		private void applyParameterSpecification(ParameterSpecification paramSpec) {
 			joinFragment.addEmbeddedParameter( paramSpec );
 		}
 
 		private String extractAppliedAlias(DotNode dotNode) {
 			return dotNode.getText().substring( 0, dotNode.getText().indexOf( '.' ) );
 		}
 
 		public FromElement getReferencedFromElement() {
 			return referencedFromElement;
 		}
 
 		public String getJoinAlias() {
 			return joinAlias;
 		}
 	}
 
 	/**
 	 * Sets the current 'FROM' context.
 	 *
 	 * @param fromNode      The new 'FROM' context.
 	 * @param inputFromNode The from node from the input AST.
 	 */
 	@Override
     protected void pushFromClause(AST fromNode, AST inputFromNode) {
 		FromClause newFromClause = ( FromClause ) fromNode;
 		newFromClause.setParentFromClause( currentFromClause );
 		currentFromClause = newFromClause;
 	}
 
 	/**
 	 * Returns to the previous 'FROM' context.
 	 */
 	private void popFromClause() {
 		currentFromClause = currentFromClause.getParentFromClause();
 	}
 
 	@Override
     protected void lookupAlias(AST aliasRef)
 			throws SemanticException {
 		FromElement alias = currentFromClause.getFromElement( aliasRef.getText() );
 		FromReferenceNode aliasRefNode = ( FromReferenceNode ) aliasRef;
 		aliasRefNode.setFromElement( alias );
 	}
 
 	@Override
     protected void setImpliedJoinType(int joinType) {
 		impliedJoinType = JoinProcessor.toHibernateJoinType( joinType );
 	}
 
 	public JoinType getImpliedJoinType() {
 		return impliedJoinType;
 	}
 
 	@Override
     protected AST lookupProperty(AST dot, boolean root, boolean inSelect) throws SemanticException {
 		DotNode dotNode = ( DotNode ) dot;
 		FromReferenceNode lhs = dotNode.getLhs();
 		AST rhs = lhs.getNextSibling();
 		switch ( rhs.getType() ) {
 			case SqlTokenTypes.ELEMENTS:
 			case SqlTokenTypes.INDICES:
                 if (LOG.isDebugEnabled()) LOG.debugf("lookupProperty() %s => %s(%s)",
                                                      dotNode.getPath(),
                                                      rhs.getText(),
                                                      lhs.getPath());
 				CollectionFunction f = ( CollectionFunction ) rhs;
 				// Re-arrange the tree so that the collection function is the root and the lhs is the path.
 				f.setFirstChild( lhs );
 				lhs.setNextSibling( null );
 				dotNode.setFirstChild( f );
 				resolve( lhs );			// Don't forget to resolve the argument!
 				f.resolve( inSelect );	// Resolve the collection function now.
 				return f;
 			default:
 				// Resolve everything up to this dot, but don't resolve the placeholders yet.
 				dotNode.resolveFirstChild();
 				return dotNode;
 		}
 	}
 
 	@Override
     protected boolean isNonQualifiedPropertyRef(AST ident) {
 		final String identText = ident.getText();
 		if ( currentFromClause.isFromElementAlias( identText ) ) {
 			return false;
 		}
 
 		List fromElements = currentFromClause.getExplicitFromElements();
 		if ( fromElements.size() == 1 ) {
 			final FromElement fromElement = ( FromElement ) fromElements.get( 0 );
 			try {
 				LOG.tracev( "Attempting to resolve property [{0}] as a non-qualified ref", identText );
 				return fromElement.getPropertyMapping( identText ).toType( identText ) != null;
 			}
 			catch( QueryException e ) {
 				// Should mean that no such property was found
 			}
 		}
 
 		return false;
 	}
 
 	@Override
 	protected AST lookupNonQualifiedProperty(AST property) throws SemanticException {
 		final FromElement fromElement = ( FromElement ) currentFromClause.getExplicitFromElements().get( 0 );
 		AST syntheticDotNode = generateSyntheticDotNodeForNonQualifiedPropertyRef( property, fromElement );
 		return lookupProperty( syntheticDotNode, false, getCurrentClauseType() == HqlSqlTokenTypes.SELECT );
 	}
 
 	private AST generateSyntheticDotNodeForNonQualifiedPropertyRef(AST property, FromElement fromElement) {
 		AST dot = getASTFactory().create( DOT, "{non-qualified-property-ref}" );
 		// TODO : better way?!?
 		( ( DotNode ) dot ).setPropertyPath( ( ( FromReferenceNode ) property ).getPath() );
 
 		IdentNode syntheticAlias = ( IdentNode ) getASTFactory().create( IDENT, "{synthetic-alias}" );
 		syntheticAlias.setFromElement( fromElement );
 		syntheticAlias.setResolved();
 
 		dot.setFirstChild( syntheticAlias );
 		dot.addChild( property );
 
 		return dot;
 	}
 
 	@Override
 	protected void processQuery(AST select, AST query) throws SemanticException {
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debugf( "processQuery() : %s", query.toStringTree() );
 		}
 
 		try {
 			QueryNode qn = ( QueryNode ) query;
 
 			// Was there an explicit select expression?
 			boolean explicitSelect = select != null && select.getNumberOfChildren() > 0;
 
 			if ( !explicitSelect ) {
 				// No explicit select expression; render the id and properties
 				// projection lists for every persister in the from clause into
 				// a single 'token node'.
 				//TODO: the only reason we need this stuff now is collection filters,
 				//      we should get rid of derived select clause completely!
 				createSelectClauseFromFromClause( qn );
 			}
 			else {
 				// Use the explicitly declared select expression; determine the
 				// return types indicated by each select token
 				useSelectClause( select );
 			}
 
 			// After that, process the JOINs.
 			// Invoke a delegate to do the work, as this is farily complex.
 			JoinProcessor joinProcessor = new JoinProcessor( this );
 			joinProcessor.processJoins( qn );
 
 			// Attach any mapping-defined "ORDER BY" fragments
 			Iterator itr = qn.getFromClause().getProjectionList().iterator();
 			while ( itr.hasNext() ) {
 				final FromElement fromElement = ( FromElement ) itr.next();
 //			if ( fromElement.isFetch() && fromElement.isCollectionJoin() ) {
 				if ( fromElement.isFetch() && fromElement.getQueryableCollection() != null ) {
 					// Does the collection referenced by this FromElement
 					// specify an order-by attribute?  If so, attach it to
 					// the query's order-by
 					if ( fromElement.getQueryableCollection().hasOrdering() ) {
 						String orderByFragment = fromElement
 								.getQueryableCollection()
 								.getSQLOrderByString( fromElement.getCollectionTableAlias() );
 						qn.getOrderByClause().addOrderFragment( orderByFragment );
 					}
 					if ( fromElement.getQueryableCollection().hasManyToManyOrdering() ) {
 						String orderByFragment = fromElement.getQueryableCollection()
 								.getManyToManyOrderByString( fromElement.getTableAlias() );
 						qn.getOrderByClause().addOrderFragment( orderByFragment );
 					}
 				}
 			}
 		}
 		finally {
 			popFromClause();
 		}
 	}
 
 	protected void postProcessDML(RestrictableStatement statement) throws SemanticException {
 		statement.getFromClause().resolve();
 
 		FromElement fromElement = ( FromElement ) statement.getFromClause().getFromElements().get( 0 );
 		Queryable persister = fromElement.getQueryable();
 		// Make #@%$^#^&# sure no alias is applied to the table name
 		fromElement.setText( persister.getTableName() );
 
 //		// append any filter fragments; the EMPTY_MAP is used under the assumption that
 //		// currently enabled filters should not affect this process
 //		if ( persister.getDiscriminatorType() != null ) {
 //			new SyntheticAndFactory( getASTFactory() ).addDiscriminatorWhereFragment(
 //			        statement,
 //			        persister,
 //			        java.util.Collections.EMPTY_MAP,
 //			        fromElement.getTableAlias()
 //			);
 //		}
 		if ( persister.getDiscriminatorType() != null || ! queryTranslatorImpl.getEnabledFilters().isEmpty() ) {
 			new SyntheticAndFactory( this ).addDiscriminatorWhereFragment(
 			        statement,
 			        persister,
 			        queryTranslatorImpl.getEnabledFilters(),
 			        fromElement.getTableAlias()
 			);
 		}
 
 	}
 
 	@Override
     protected void postProcessUpdate(AST update) throws SemanticException {
 		UpdateStatement updateStatement = ( UpdateStatement ) update;
 
 		postProcessDML( updateStatement );
 	}
 
 	@Override
     protected void postProcessDelete(AST delete) throws SemanticException {
 		postProcessDML( ( DeleteStatement ) delete );
 	}
 
 	@Override
     protected void postProcessInsert(AST insert) throws SemanticException, QueryException {
 		InsertStatement insertStatement = ( InsertStatement ) insert;
 		insertStatement.validate();
 
 		SelectClause selectClause = insertStatement.getSelectClause();
 		Queryable persister = insertStatement.getIntoClause().getQueryable();
 
 		if ( !insertStatement.getIntoClause().isExplicitIdInsertion() ) {
 			// the insert did not explicitly reference the id.  See if
 			//		1) that is allowed
 			//		2) whether we need to alter the SQL tree to account for id
 			final IdentifierGenerator generator = persister.getIdentifierGenerator();
 			if ( !BulkInsertionCapableIdentifierGenerator.class.isInstance( generator ) ) {
 				throw new QueryException(
 						"Invalid identifier generator encountered for implicit id handling as part of bulk insertions"
 				);
 			}
 			final BulkInsertionCapableIdentifierGenerator capableGenerator =
 					BulkInsertionCapableIdentifierGenerator.class.cast( generator );
 			if ( ! capableGenerator.supportsBulkInsertionIdentifierGeneration() ) {
 				throw new QueryException(
 						"Identifier generator reported it does not support implicit id handling as part of bulk insertions"
 				);
 			}
 
             final String fragment = capableGenerator.determineBulkInsertionIdentifierGenerationSelectFragment(
 					sessionFactoryHelper.getFactory().getDialect()
 			);
 			if ( fragment != null ) {
                 // we got a fragment from the generator, so alter the sql tree...
                 //
                 // first, wrap the fragment as a node
                 AST fragmentNode = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, fragment );
                 // next, rearrange the SQL tree to add the fragment node as the first select expression
                 AST originalFirstSelectExprNode = selectClause.getFirstChild();
                 selectClause.setFirstChild( fragmentNode );
                 fragmentNode.setNextSibling( originalFirstSelectExprNode );
                 // finally, prepend the id column name(s) to the insert-spec
                 insertStatement.getIntoClause().prependIdColumnSpec();
 			}
 		}
 
 		final boolean includeVersionProperty = persister.isVersioned() &&
 				!insertStatement.getIntoClause().isExplicitVersionInsertion() &&
 				persister.isVersionPropertyInsertable();
 		if ( includeVersionProperty ) {
 			// We need to seed the version value as part of this bulk insert
 			VersionType versionType = persister.getVersionType();
 			AST versionValueNode = null;
 
 			if ( sessionFactoryHelper.getFactory().getDialect().supportsParametersInInsertSelect() ) {
 				int sqlTypes[] = versionType.sqlTypes( sessionFactoryHelper.getFactory() );
 				if ( sqlTypes == null || sqlTypes.length == 0 ) {
 					throw new IllegalStateException( versionType.getClass() + ".sqlTypes() returns null or empty array" );
 				}
 				if ( sqlTypes.length > 1 ) {
 					throw new IllegalStateException(
 							versionType.getClass() +
 									".sqlTypes() returns > 1 element; only single-valued versions are allowed."
 					);
 				}
 				versionValueNode = getASTFactory().create( HqlSqlTokenTypes.PARAM, "?" );
 				ParameterSpecification paramSpec = new VersionTypeSeedParameterSpecification( versionType );
 				( ( ParameterNode ) versionValueNode ).setHqlParameterSpecification( paramSpec );
 				parameters.add( 0, paramSpec );
 
 				if ( sessionFactoryHelper.getFactory().getDialect().requiresCastingOfParametersInSelectClause() ) {
 					// we need to wrtap the param in a cast()
 					MethodNode versionMethodNode = ( MethodNode ) getASTFactory().create( HqlSqlTokenTypes.METHOD_CALL, "(" );
 					AST methodIdentNode = getASTFactory().create( HqlSqlTokenTypes.IDENT, "cast" );
 					versionMethodNode.addChild( methodIdentNode );
 					versionMethodNode.initializeMethodNode(methodIdentNode, true );
 					AST castExprListNode = getASTFactory().create( HqlSqlTokenTypes.EXPR_LIST, "exprList" );
 					methodIdentNode.setNextSibling( castExprListNode );
 					castExprListNode.addChild( versionValueNode );
 					versionValueNode.setNextSibling(
 							getASTFactory().create(
 									HqlSqlTokenTypes.IDENT,
 									sessionFactoryHelper.getFactory().getDialect().getTypeName( sqlTypes[0] ) )
 					);
 					processFunction( versionMethodNode, true );
 					versionValueNode = versionMethodNode;
 				}
 			}
 			else {
 				if ( isIntegral( versionType ) ) {
 					try {
 						Object seedValue = versionType.seed( null );
 						versionValueNode = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, seedValue.toString() );
 					}
 					catch( Throwable t ) {
 						throw new QueryException( "could not determine seed value for version on bulk insert [" + versionType + "]" );
 					}
 				}
 				else if ( isDatabaseGeneratedTimestamp( versionType ) ) {
 					String functionName = sessionFactoryHelper.getFactory().getDialect().getCurrentTimestampSQLFunctionName();
 					versionValueNode = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, functionName );
 				}
 				else {
 					throw new QueryException( "cannot handle version type [" + versionType + "] on bulk inserts with dialects not supporting parameters in insert-select statements" );
 				}
 			}
 
 			AST currentFirstSelectExprNode = selectClause.getFirstChild();
 			selectClause.setFirstChild( versionValueNode );
 			versionValueNode.setNextSibling( currentFirstSelectExprNode );
 
 			insertStatement.getIntoClause().prependVersionColumnSpec();
 		}
 
 		if ( insertStatement.getIntoClause().isDiscriminated() ) {
 			String sqlValue = insertStatement.getIntoClause().getQueryable().getDiscriminatorSQLValue();
 			AST discrimValue = getASTFactory().create( HqlSqlTokenTypes.SQL_TOKEN, sqlValue );
 			insertStatement.getSelectClause().addChild( discrimValue );
 		}
 
 	}
 
 	private boolean isDatabaseGeneratedTimestamp(Type type) {
 		// currently only the Hibernate-supplied DbTimestampType is supported here
 		return DbTimestampType.class.isAssignableFrom( type.getClass() );
 	}
 
 	private boolean isIntegral(Type type) {
 		return Long.class.isAssignableFrom( type.getReturnedClass() )
 		       || Integer.class.isAssignableFrom( type.getReturnedClass() )
 		       || long.class.isAssignableFrom( type.getReturnedClass() )
 		       || int.class.isAssignableFrom( type.getReturnedClass() );
 	}
 
 	private void useSelectClause(AST select) throws SemanticException {
 		selectClause = ( SelectClause ) select;
 		selectClause.initializeExplicitSelectClause( currentFromClause );
 	}
 
 	private void createSelectClauseFromFromClause(QueryNode qn) throws SemanticException {
 		AST select = astFactory.create( SELECT_CLAUSE, "{derived select clause}" );
 		AST sibling = qn.getFromClause();
 		qn.setFirstChild( select );
 		select.setNextSibling( sibling );
 		selectClause = ( SelectClause ) select;
 		selectClause.initializeDerivedSelectClause( currentFromClause );
 		LOG.debug( "Derived SELECT clause created." );
 	}
 
 	@Override
     protected void resolve(AST node) throws SemanticException {
 		if ( node != null ) {
 			// This is called when it's time to fully resolve a path expression.
 			ResolvableNode r = ( ResolvableNode ) node;
 			if ( isInFunctionCall() ) {
 				r.resolveInFunctionCall( false, true );
 			}
 			else {
 				r.resolve( false, true );	// Generate implicit joins, only if necessary.
 			}
 		}
 	}
 
 	@Override
     protected void resolveSelectExpression(AST node) throws SemanticException {
 		// This is called when it's time to fully resolve a path expression.
 		int type = node.getType();
 		switch ( type ) {
 			case DOT: {
 				DotNode dot = ( DotNode ) node;
 				dot.resolveSelectExpression();
 				break;
 			}
 			case ALIAS_REF: {
 				// Notify the FROM element that it is being referenced by the select.
 				FromReferenceNode aliasRefNode = ( FromReferenceNode ) node;
 				//aliasRefNode.resolve( false, false, aliasRefNode.getText() ); //TODO: is it kosher to do it here?
 				aliasRefNode.resolve( false, false ); //TODO: is it kosher to do it here?
 				FromElement fromElement = aliasRefNode.getFromElement();
 				if ( fromElement != null ) {
 					fromElement.setIncludeSubclasses( true );
 				}
 				break;
 			}
 			default: {
 				break;
 			}
 		}
 	}
 
 	@Override
     protected void beforeSelectClause() throws SemanticException {
 		// Turn off includeSubclasses on all FromElements.
 		FromClause from = getCurrentFromClause();
 		List fromElements = from.getFromElements();
 		for ( Iterator iterator = fromElements.iterator(); iterator.hasNext(); ) {
 			FromElement fromElement = ( FromElement ) iterator.next();
 			fromElement.setIncludeSubclasses( false );
 		}
 	}
 
 	@Override
     protected AST generatePositionalParameter(AST inputNode) throws SemanticException {
 		if ( namedParameters.size() > 0 ) {
 			throw new SemanticException( "cannot define positional parameter after any named parameters have been defined" );
 		}
 		LOG.warnf(
 				"[DEPRECATION] Encountered positional parameter near line %s, column %s.  Positional parameter " +
 						"are considered deprecated; use named parameters or JPA-style positional parameters instead.",
 				inputNode.getLine(),
 				inputNode.getColumn()
 		);
 		ParameterNode parameter = ( ParameterNode ) astFactory.create( PARAM, "?" );
 		PositionalParameterSpecification paramSpec = new PositionalParameterSpecification(
 				inputNode.getLine(),
 		        inputNode.getColumn(),
 				positionalParameterCount++
 		);
 		parameter.setHqlParameterSpecification( paramSpec );
 		parameters.add( paramSpec );
 		return parameter;
 	}
 
 	@Override
     protected AST generateNamedParameter(AST delimiterNode, AST nameNode) throws SemanticException {
 		String name = nameNode.getText();
 		trackNamedParameterPositions( name );
 
 		// create the node initially with the param name so that it shows
 		// appropriately in the "original text" attribute
 		ParameterNode parameter = ( ParameterNode ) astFactory.create( NAMED_PARAM, name );
 		parameter.setText( "?" );
 
 		NamedParameterSpecification paramSpec = new NamedParameterSpecification(
 				delimiterNode.getLine(),
 		        delimiterNode.getColumn(),
 				name
 		);
 		parameter.setHqlParameterSpecification( paramSpec );
 		parameters.add( paramSpec );
 		return parameter;
 	}
 
 	private void trackNamedParameterPositions(String name) {
 		Integer loc = parameterCount++;
 		Object o = namedParameters.get( name );
 		if ( o == null ) {
 			namedParameters.put( name, loc );
 		}
 		else if ( o instanceof Integer ) {
 			ArrayList list = new ArrayList( 4 );
 			list.add( o );
 			list.add( loc );
 			namedParameters.put( name, list );
 		}
 		else {
 			( ( ArrayList ) o ).add( loc );
 		}
 	}
 
 	@Override
     protected void processConstant(AST constant) throws SemanticException {
 		literalProcessor.processConstant( constant, true );  // Use the delegate, resolve identifiers as FROM element aliases.
 	}
 
 	@Override
     protected void processBoolean(AST constant) throws SemanticException {
 		literalProcessor.processBoolean( constant );  // Use the delegate.
 	}
 
 	@Override
     protected void processNumericLiteral(AST literal) {
 		literalProcessor.processNumeric( literal );
 	}
 
 	@Override
     protected void processIndex(AST indexOp) throws SemanticException {
 		IndexNode indexNode = ( IndexNode ) indexOp;
 		indexNode.resolve( true, true );
 	}
 
 	@Override
     protected void processFunction(AST functionCall, boolean inSelect) throws SemanticException {
 		MethodNode methodNode = ( MethodNode ) functionCall;
 		methodNode.resolve( inSelect );
 	}
 
 	@Override
     protected void processAggregation(AST node, boolean inSelect) throws SemanticException {
 		AggregateNode aggregateNode = ( AggregateNode ) node;
 		aggregateNode.resolve();
 	}
 
 	@Override
     protected void processConstructor(AST constructor) throws SemanticException {
 		ConstructorNode constructorNode = ( ConstructorNode ) constructor;
 		constructorNode.prepare();
 	}
 
     @Override
     protected void setAlias(AST selectExpr, AST ident) {
         ((SelectExpression) selectExpr).setAlias(ident.getText());
 		// only put the alias (i.e., result variable) in selectExpressionsByResultVariable
 		// if is not defined in a subquery.
 		if ( ! isSubQuery() ) {
 			selectExpressionsByResultVariable.put( ident.getText(), ( SelectExpression ) selectExpr );
 		}
     }
 
 	@Override
     protected boolean isOrderExpressionResultVariableRef(AST orderExpressionNode) throws SemanticException {
 		// ORDER BY is not supported in a subquery
 		// TODO: should an exception be thrown if an ORDER BY is in a subquery?
 		if ( ! isSubQuery() &&
 				orderExpressionNode.getType() == IDENT &&
 				selectExpressionsByResultVariable.containsKey( orderExpressionNode.getText() ) ) {
 			return true;
 		}
 		return false;
 	}
 
 	@Override
     protected void handleResultVariableRef(AST resultVariableRef) throws SemanticException {
 		if ( isSubQuery() ) {
 			throw new SemanticException(
 					"References to result variables in subqueries are not supported."
 			);
 		}
 		( ( ResultVariableRefNode ) resultVariableRef ).setSelectExpression(
 				selectExpressionsByResultVariable.get( resultVariableRef.getText() )
 		);
 	}
 
 	/**
 	 * Returns the locations of all occurrences of the named parameter.
 	 */
 	public int[] getNamedParameterLocations(String name) throws QueryException {
 		Object o = namedParameters.get( name );
 		if ( o == null ) {
 			throw new QueryException( QueryTranslator.ERROR_NAMED_PARAMETER_DOES_NOT_APPEAR + name, queryTranslatorImpl.getQueryString() );
 		}
 		if ( o instanceof Integer ) {
 			return new int[]{ (Integer) o };
 		}
 		else {
 			return ArrayHelper.toIntArray( (ArrayList) o );
 		}
 	}
 
 	public void addQuerySpaces(Serializable[] spaces) {
 		querySpaces.addAll( Arrays.asList( spaces ) );
 	}
 
 	public Type[] getReturnTypes() {
 		return selectClause.getQueryReturnTypes();
 	}
 
 	public String[] getReturnAliases() {
 		return selectClause.getQueryReturnAliases();
 	}
 
 	public SelectClause getSelectClause() {
 		return selectClause;
 	}
 
 	public FromClause getFinalFromClause() {
 		FromClause top = currentFromClause;
 		while ( top.getParentFromClause() != null ) {
 			top = top.getParentFromClause();
 		}
 		return top;
 	}
 
 	public boolean isShallowQuery() {
 		// select clauses for insert statements should alwasy be treated as shallow
 		return getStatementType() == INSERT || queryTranslatorImpl.isShallowQuery();
 	}
 
 	public Map getEnabledFilters() {
 		return queryTranslatorImpl.getEnabledFilters();
 	}
 
 	public LiteralProcessor getLiteralProcessor() {
 		return literalProcessor;
 	}
 
 	public ASTPrinter getASTPrinter() {
 		return printer;
 	}
 
 	public ArrayList getParameters() {
 		return parameters;
 	}
 
 	public int getNumberOfParametersInSetClause() {
 		return numberOfParametersInSetClause;
 	}
 
 	@Override
     protected void evaluateAssignment(AST eq) throws SemanticException {
 		prepareLogicOperator( eq );
 		Queryable persister = getCurrentFromClause().getFromElement().getQueryable();
 		evaluateAssignment( eq, persister, -1 );
 	}
 
 	private void evaluateAssignment(AST eq, Queryable persister, int targetIndex) {
 		if ( persister.isMultiTable() ) {
 			// no need to even collect this information if the persister is considered multi-table
 			AssignmentSpecification specification = new AssignmentSpecification( eq, persister );
 			if ( targetIndex >= 0 ) {
 				assignmentSpecifications.add( targetIndex, specification );
 			}
 			else {
 				assignmentSpecifications.add( specification );
 			}
 			numberOfParametersInSetClause += specification.getParameters().length;
 		}
 	}
 
 	public ArrayList getAssignmentSpecifications() {
 		return assignmentSpecifications;
 	}
 
 	@Override
     protected AST createIntoClause(String path, AST propertySpec) throws SemanticException {
 		Queryable persister = ( Queryable ) getSessionFactoryHelper().requireClassPersister( path );
 
 		IntoClause intoClause = ( IntoClause ) getASTFactory().create( INTO, persister.getEntityName() );
 		intoClause.setFirstChild( propertySpec );
 		intoClause.initialize( persister );
 
 		addQuerySpaces( persister.getQuerySpaces() );
 
 		return intoClause;
 	}
 
 	@Override
     protected void prepareVersioned(AST updateNode, AST versioned) throws SemanticException {
 		UpdateStatement updateStatement = ( UpdateStatement ) updateNode;
 		FromClause fromClause = updateStatement.getFromClause();
 		if ( versioned != null ) {
 			// Make sure that the persister is versioned
 			Queryable persister = fromClause.getFromElement().getQueryable();
 			if ( !persister.isVersioned() ) {
 				throw new SemanticException( "increment option specified for update of non-versioned entity" );
 			}
 
 			VersionType versionType = persister.getVersionType();
 			if ( versionType instanceof UserVersionType ) {
 				throw new SemanticException( "user-defined version types not supported for increment option" );
 			}
 
 			AST eq = getASTFactory().create( HqlSqlTokenTypes.EQ, "=" );
 			AST versionPropertyNode = generateVersionPropertyNode( persister );
 
 			eq.setFirstChild( versionPropertyNode );
 
 			AST versionIncrementNode = null;
 			if ( isTimestampBasedVersion( versionType ) ) {
 				versionIncrementNode = getASTFactory().create( HqlSqlTokenTypes.PARAM, "?" );
 				ParameterSpecification paramSpec = new VersionTypeSeedParameterSpecification( versionType );
 				( ( ParameterNode ) versionIncrementNode ).setHqlParameterSpecification( paramSpec );
 				parameters.add( 0, paramSpec );
 			}
 			else {
 				// Not possible to simply re-use the versionPropertyNode here as it causes
 				// OOM errors due to circularity :(
 				versionIncrementNode = getASTFactory().create( HqlSqlTokenTypes.PLUS, "+" );
 				versionIncrementNode.setFirstChild( generateVersionPropertyNode( persister ) );
 				versionIncrementNode.addChild( getASTFactory().create( HqlSqlTokenTypes.IDENT, "1" ) );
 			}
 
 			eq.addChild( versionIncrementNode );
 
 			evaluateAssignment( eq, persister, 0 );
 
 			AST setClause = updateStatement.getSetClause();
 			AST currentFirstSetElement = setClause.getFirstChild();
 			setClause.setFirstChild( eq );
 			eq.setNextSibling( currentFirstSetElement );
 		}
 	}
 
 	private boolean isTimestampBasedVersion(VersionType versionType) {
 		final Class javaType = versionType.getReturnedClass();
 		return Date.class.isAssignableFrom( javaType )
 				|| Calendar.class.isAssignableFrom( javaType );
 	}
 
 	private AST generateVersionPropertyNode(Queryable persister) throws SemanticException {
 		String versionPropertyName = persister.getPropertyNames()[ persister.getVersionProperty() ];
 		AST versionPropertyRef = getASTFactory().create( HqlSqlTokenTypes.IDENT, versionPropertyName );
 		AST versionPropertyNode = lookupNonQualifiedProperty( versionPropertyRef );
 		resolve( versionPropertyNode );
 		return versionPropertyNode;
 	}
 
 	@Override
     protected void prepareLogicOperator(AST operator) throws SemanticException {
 		( ( OperatorNode ) operator ).initialize();
 	}
 
 	@Override
     protected void prepareArithmeticOperator(AST operator) throws SemanticException {
 		( ( OperatorNode ) operator ).initialize();
 	}
 
 	@Override
     protected void validateMapPropertyExpression(AST node) throws SemanticException {
 		try {
 			FromReferenceNode fromReferenceNode = (FromReferenceNode) node;
 			QueryableCollection collectionPersister = fromReferenceNode.getFromElement().getQueryableCollection();
 			if ( ! Map.class.isAssignableFrom( collectionPersister.getCollectionType().getReturnedClass() ) ) {
 				throw new SemanticException( "node did not reference a map" );
 			}
 		}
 		catch ( SemanticException se ) {
 			throw se;
 		}
 		catch ( Throwable t ) {
 			throw new SemanticException( "node did not reference a map" );
 		}
 	}
 
 	public static void panic() {
 		throw new QueryException( "TreeWalker: panic" );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/QueryTranslatorImpl.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/QueryTranslatorImpl.java
index da87cb4f12..07f4b6887b 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/QueryTranslatorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/QueryTranslatorImpl.java
@@ -1,613 +1,614 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.hql.internal.ast;
 
+import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import antlr.ANTLRException;
 import antlr.RecognitionException;
 import antlr.TokenStreamException;
 import antlr.collections.AST;
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.event.spi.EventSource;
 import org.hibernate.hql.internal.QueryExecutionRequestException;
 import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
 import org.hibernate.hql.internal.antlr.HqlTokenTypes;
 import org.hibernate.hql.internal.antlr.SqlTokenTypes;
 import org.hibernate.hql.internal.ast.exec.BasicExecutor;
 import org.hibernate.hql.internal.ast.exec.MultiTableDeleteExecutor;
 import org.hibernate.hql.internal.ast.exec.MultiTableUpdateExecutor;
 import org.hibernate.hql.internal.ast.exec.StatementExecutor;
 import org.hibernate.hql.internal.ast.tree.AggregatedSelectExpression;
 import org.hibernate.hql.internal.ast.tree.FromElement;
 import org.hibernate.hql.internal.ast.tree.InsertStatement;
 import org.hibernate.hql.internal.ast.tree.QueryNode;
 import org.hibernate.hql.internal.ast.tree.Statement;
 import org.hibernate.hql.internal.ast.util.ASTPrinter;
 import org.hibernate.hql.internal.ast.util.ASTUtil;
 import org.hibernate.hql.internal.ast.util.NodeTraverser;
 import org.hibernate.hql.spi.FilterTranslator;
 import org.hibernate.hql.spi.ParameterTranslations;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.IdentitySet;
 import org.hibernate.loader.hql.QueryLoader;
 import org.hibernate.param.ParameterSpecification;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.type.Type;
 
 /**
  * A QueryTranslator that uses an Antlr-based parser.
  *
  * @author Joshua Davis (pgmjsd@sourceforge.net)
  */
 public class QueryTranslatorImpl implements FilterTranslator {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			QueryTranslatorImpl.class.getName()
 	);
 
 	private SessionFactoryImplementor factory;
 
 	private final String queryIdentifier;
 	private String hql;
 	private boolean shallowQuery;
 	private Map tokenReplacements;
 
 	//TODO:this is only needed during compilation .. can we eliminate the instvar?
 	private Map enabledFilters;
 
 	private boolean compiled;
 	private QueryLoader queryLoader;
 	private StatementExecutor statementExecutor;
 
 	private Statement sqlAst;
 	private String sql;
 
 	private ParameterTranslations paramTranslations;
 	private List<ParameterSpecification> collectedParameterSpecifications;
 
 
 	/**
 	 * Creates a new AST-based query translator.
 	 *
 	 * @param queryIdentifier The query-identifier (used in stats collection)
 	 * @param query The hql query to translate
 	 * @param enabledFilters Currently enabled filters
 	 * @param factory The session factory constructing this translator instance.
 	 */
 	public QueryTranslatorImpl(
 			String queryIdentifier,
 			String query,
 			Map enabledFilters,
 			SessionFactoryImplementor factory) {
 		this.queryIdentifier = queryIdentifier;
 		this.hql = query;
 		this.compiled = false;
 		this.shallowQuery = false;
 		this.enabledFilters = enabledFilters;
 		this.factory = factory;
 	}
 
 	/**
 	 * Compile a "normal" query. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 *
 	 * @param replacements Defined query substitutions.
 	 * @param shallow      Does this represent a shallow (scalar or entity-id) select?
 	 * @throws QueryException   There was a problem parsing the query string.
 	 * @throws MappingException There was a problem querying defined mappings.
 	 */
 	@Override
 	public void compile(
 			Map replacements,
 			boolean shallow) throws QueryException, MappingException {
 		doCompile( replacements, shallow, null );
 	}
 
 	/**
 	 * Compile a filter. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 *
 	 * @param collectionRole the role name of the collection used as the basis for the filter.
 	 * @param replacements   Defined query substitutions.
 	 * @param shallow        Does this represent a shallow (scalar or entity-id) select?
 	 * @throws QueryException   There was a problem parsing the query string.
 	 * @throws MappingException There was a problem querying defined mappings.
 	 */
 	@Override
 	public void compile(
 			String collectionRole,
 			Map replacements,
 			boolean shallow) throws QueryException, MappingException {
 		doCompile( replacements, shallow, collectionRole );
 	}
 
 	/**
 	 * Performs both filter and non-filter compiling.
 	 *
 	 * @param replacements   Defined query substitutions.
 	 * @param shallow        Does this represent a shallow (scalar or entity-id) select?
 	 * @param collectionRole the role name of the collection used as the basis for the filter, NULL if this
 	 *                       is not a filter.
 	 */
 	private synchronized void doCompile(Map replacements, boolean shallow, String collectionRole) {
 		// If the query is already compiled, skip the compilation.
 		if ( compiled ) {
 			LOG.debug( "compile() : The query is already compiled, skipping..." );
 			return;
 		}
 
 		// Remember the parameters for the compilation.
 		this.tokenReplacements = replacements;
 		if ( tokenReplacements == null ) {
 			tokenReplacements = new HashMap();
 		}
 		this.shallowQuery = shallow;
 
 		try {
 			// PHASE 1 : Parse the HQL into an AST.
 			final HqlParser parser = parse( true );
 
 			// PHASE 2 : Analyze the HQL AST, and produce an SQL AST.
 			final HqlSqlWalker w = analyze( parser, collectionRole );
 
 			sqlAst = (Statement) w.getAST();
 
 			// at some point the generate phase needs to be moved out of here,
 			// because a single object-level DML might spawn multiple SQL DML
 			// command executions.
 			//
 			// Possible to just move the sql generation for dml stuff, but for
 			// consistency-sake probably best to just move responsiblity for
 			// the generation phase completely into the delegates
 			// (QueryLoader/StatementExecutor) themselves.  Also, not sure why
 			// QueryLoader currently even has a dependency on this at all; does
 			// it need it?  Ideally like to see the walker itself given to the delegates directly...
 
 			if ( sqlAst.needsExecutor() ) {
 				statementExecutor = buildAppropriateStatementExecutor( w );
 			}
 			else {
 				// PHASE 3 : Generate the SQL.
 				generate( (QueryNode) sqlAst );
 				queryLoader = new QueryLoader( this, factory, w.getSelectClause() );
 			}
 
 			compiled = true;
 		}
 		catch ( QueryException qe ) {
 			if ( qe.getQueryString() == null ) {
 				throw qe.wrapWithQueryString( hql );
 			}
 			else {
 				throw qe;
 			}
 		}
 		catch ( RecognitionException e ) {
 			// we do not actually propagate ANTLRExceptions as a cause, so
 			// log it here for diagnostic purposes
 			LOG.trace( "Converted antlr.RecognitionException", e );
 			throw QuerySyntaxException.convert( e, hql );
 		}
 		catch ( ANTLRException e ) {
 			// we do not actually propagate ANTLRExceptions as a cause, so
 			// log it here for diagnostic purposes
 			LOG.trace( "Converted antlr.ANTLRException", e );
 			throw new QueryException( e.getMessage(), hql );
 		}
 
 		//only needed during compilation phase...
 		this.enabledFilters = null;
 	}
 
 	private void generate(AST sqlAst) throws QueryException, RecognitionException {
 		if ( sql == null ) {
 			final SqlGenerator gen = new SqlGenerator( factory );
 			gen.statement( sqlAst );
 			sql = gen.getSQL();
 			if ( LOG.isDebugEnabled() ) {
 				LOG.debugf( "HQL: %s", hql );
 				LOG.debugf( "SQL: %s", sql );
 			}
 			gen.getParseErrorHandler().throwQueryException();
 			collectedParameterSpecifications = gen.getCollectedParameters();
 		}
 	}
 
 	private static final ASTPrinter SQL_TOKEN_PRINTER = new ASTPrinter( SqlTokenTypes.class );
 
 	private HqlSqlWalker analyze(HqlParser parser, String collectionRole) throws QueryException, RecognitionException {
 		final HqlSqlWalker w = new HqlSqlWalker( this, factory, parser, tokenReplacements, collectionRole );
 		final AST hqlAst = parser.getAST();
 
 		// Transform the tree.
 		w.statement( hqlAst );
 
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debug( SQL_TOKEN_PRINTER.showAsString( w.getAST(), "--- SQL AST ---" ) );
 		}
 
 		w.getParseErrorHandler().throwQueryException();
 
 		return w;
 	}
 
 	private HqlParser parse(boolean filter) throws TokenStreamException, RecognitionException {
 		// Parse the query string into an HQL AST.
 		final HqlParser parser = HqlParser.getInstance( hql );
 		parser.setFilter( filter );
 
 		LOG.debugf( "parse() - HQL: %s", hql );
 		parser.statement();
 
 		final AST hqlAst = parser.getAST();
 
 		final NodeTraverser walker = new NodeTraverser( new JavaConstantConverter() );
 		walker.traverseDepthFirst( hqlAst );
 
 		showHqlAst( hqlAst );
 
 		parser.getParseErrorHandler().throwQueryException();
 		return parser;
 	}
 
 	private static final ASTPrinter HQL_TOKEN_PRINTER = new ASTPrinter( HqlTokenTypes.class );
 
 	void showHqlAst(AST hqlAst) {
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debug( HQL_TOKEN_PRINTER.showAsString( hqlAst, "--- HQL AST ---" ) );
 		}
 	}
 
 	private void errorIfDML() throws HibernateException {
 		if ( sqlAst.needsExecutor() ) {
 			throw new QueryExecutionRequestException( "Not supported for DML operations", hql );
 		}
 	}
 
 	private void errorIfSelect() throws HibernateException {
 		if ( !sqlAst.needsExecutor() ) {
 			throw new QueryExecutionRequestException( "Not supported for select queries", hql );
 		}
 	}
 	@Override
 	public String getQueryIdentifier() {
 		return queryIdentifier;
 	}
 
 	public Statement getSqlAST() {
 		return sqlAst;
 	}
 
 	private HqlSqlWalker getWalker() {
 		return sqlAst.getWalker();
 	}
 
 	/**
 	 * Types of the return values of an <tt>iterate()</tt> style query.
 	 *
 	 * @return an array of <tt>Type</tt>s.
 	 */
 	@Override
 	public Type[] getReturnTypes() {
 		errorIfDML();
 		return getWalker().getReturnTypes();
 	}
 	@Override
 	public String[] getReturnAliases() {
 		errorIfDML();
 		return getWalker().getReturnAliases();
 	}
 	@Override
 	public String[][] getColumnNames() {
 		errorIfDML();
 		return getWalker().getSelectClause().getColumnNames();
 	}
 	@Override
-	public Set getQuerySpaces() {
+	public Set<Serializable> getQuerySpaces() {
 		return getWalker().getQuerySpaces();
 	}
 
 	@Override
 	public List list(SessionImplementor session, QueryParameters queryParameters)
 			throws HibernateException {
 		// Delegate to the QueryLoader...
 		errorIfDML();
 		QueryNode query = ( QueryNode ) sqlAst;
 		boolean hasLimit = queryParameters.getRowSelection() != null && queryParameters.getRowSelection().definesLimits();
 		boolean needsDistincting = ( query.getSelectClause().isDistinct() || hasLimit ) && containsCollectionFetches();
 
 		QueryParameters queryParametersToUse;
 		if ( hasLimit && containsCollectionFetches() ) {
 			LOG.firstOrMaxResultsSpecifiedWithCollectionFetch();
 			RowSelection selection = new RowSelection();
 			selection.setFetchSize( queryParameters.getRowSelection().getFetchSize() );
 			selection.setTimeout( queryParameters.getRowSelection().getTimeout() );
 			queryParametersToUse = queryParameters.createCopyUsing( selection );
 		}
 		else {
 			queryParametersToUse = queryParameters;
 		}
 
 		List results = queryLoader.list( session, queryParametersToUse );
 
 		if ( needsDistincting ) {
 			int includedCount = -1;
 			// NOTE : firstRow is zero-based
 			int first = !hasLimit || queryParameters.getRowSelection().getFirstRow() == null
 						? 0
 						: queryParameters.getRowSelection().getFirstRow();
 			int max = !hasLimit || queryParameters.getRowSelection().getMaxRows() == null
 						? -1
 						: queryParameters.getRowSelection().getMaxRows();
 			List tmp = new ArrayList();
 			IdentitySet distinction = new IdentitySet();
 			for ( final Object result : results ) {
 				if ( !distinction.add( result ) ) {
 					continue;
 				}
 				includedCount++;
 				if ( includedCount < first ) {
 					continue;
 				}
 				tmp.add( result );
 				// NOTE : ( max - 1 ) because first is zero-based while max is not...
 				if ( max >= 0 && ( includedCount - first ) >= ( max - 1 ) ) {
 					break;
 				}
 			}
 			results = tmp;
 		}
 
 		return results;
 	}
 
 	/**
 	 * Return the query results as an iterator
 	 */
 	@Override
 	public Iterator iterate(QueryParameters queryParameters, EventSource session)
 			throws HibernateException {
 		// Delegate to the QueryLoader...
 		errorIfDML();
 		return queryLoader.iterate( queryParameters, session );
 	}
 
 	/**
 	 * Return the query results, as an instance of <tt>ScrollableResults</tt>
 	 */
 	@Override
 	public ScrollableResults scroll(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException {
 		// Delegate to the QueryLoader...
 		errorIfDML();
 		return queryLoader.scroll( queryParameters, session );
 	}
 	@Override
 	public int executeUpdate(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException {
 		errorIfSelect();
 		return statementExecutor.execute( queryParameters, session );
 	}
 
 	/**
 	 * The SQL query string to be called; implemented by all subclasses
 	 */
 	@Override
 	public String getSQLString() {
 		return sql;
 	}
 	@Override
 	public List<String> collectSqlStrings() {
 		ArrayList<String> list = new ArrayList<String>();
 		if ( isManipulationStatement() ) {
 			String[] sqlStatements = statementExecutor.getSqlStatements();
 			Collections.addAll( list, sqlStatements );
 		}
 		else {
 			list.add( sql );
 		}
 		return list;
 	}
 
 	// -- Package local methods for the QueryLoader delegate --
 
 	public boolean isShallowQuery() {
 		return shallowQuery;
 	}
 	@Override
 	public String getQueryString() {
 		return hql;
 	}
 	@Override
 	public Map getEnabledFilters() {
 		return enabledFilters;
 	}
 
 	public int[] getNamedParameterLocs(String name) {
 		return getWalker().getNamedParameterLocations( name );
 	}
 	@Override
 	public boolean containsCollectionFetches() {
 		errorIfDML();
 		List collectionFetches = ( ( QueryNode ) sqlAst ).getFromClause().getCollectionFetches();
 		return collectionFetches != null && collectionFetches.size() > 0;
 	}
 	@Override
 	public boolean isManipulationStatement() {
 		return sqlAst.needsExecutor();
 	}
 	@Override
 	public void validateScrollability() throws HibernateException {
 		// Impl Note: allows multiple collection fetches as long as the
 		// entire fecthed graph still "points back" to a single
 		// root entity for return
 
 		errorIfDML();
 
 		QueryNode query = ( QueryNode ) sqlAst;
 
 		// If there are no collection fetches, then no further checks are needed
 		List collectionFetches = query.getFromClause().getCollectionFetches();
 		if ( collectionFetches.isEmpty() ) {
 			return;
 		}
 
 		// A shallow query is ok (although technically there should be no fetching here...)
 		if ( isShallowQuery() ) {
 			return;
 		}
 
 		// Otherwise, we have a non-scalar select with defined collection fetch(es).
 		// Make sure that there is only a single root entity in the return (no tuples)
 		if ( getReturnTypes().length > 1 ) {
 			throw new HibernateException( "cannot scroll with collection fetches and returned tuples" );
 		}
 
 		FromElement owner = null;
 		for ( Object o : query.getSelectClause().getFromElementsForLoad() ) {
 			// should be the first, but just to be safe...
 			final FromElement fromElement = (FromElement) o;
 			if ( fromElement.getOrigin() == null ) {
 				owner = fromElement;
 				break;
 			}
 		}
 
 		if ( owner == null ) {
 			throw new HibernateException( "unable to locate collection fetch(es) owner for scrollability checks" );
 		}
 
 		// This is not strictly true.  We actually just need to make sure that
 		// it is ordered by root-entity PK and that that order-by comes before
 		// any non-root-entity ordering...
 
 		AST primaryOrdering = query.getOrderByClause().getFirstChild();
 		if ( primaryOrdering != null ) {
 			// TODO : this is a bit dodgy, come up with a better way to check this (plus see above comment)
 			String [] idColNames = owner.getQueryable().getIdentifierColumnNames();
 			String expectedPrimaryOrderSeq = StringHelper.join(
 			        ", ",
 			        StringHelper.qualify( owner.getTableAlias(), idColNames )
 			);
 			if (  !primaryOrdering.getText().startsWith( expectedPrimaryOrderSeq ) ) {
 				throw new HibernateException( "cannot scroll results with collection fetches which are not ordered primarily by the root entity's PK" );
 			}
 		}
 	}
 
 	private StatementExecutor buildAppropriateStatementExecutor(HqlSqlWalker walker) {
 		Statement statement = ( Statement ) walker.getAST();
 		if ( walker.getStatementType() == HqlSqlTokenTypes.DELETE ) {
 			FromElement fromElement = walker.getFinalFromClause().getFromElement();
 			Queryable persister = fromElement.getQueryable();
 			if ( persister.isMultiTable() ) {
 				return new MultiTableDeleteExecutor( walker );
 			}
 			else {
 				return new BasicExecutor( walker, persister );
 			}
 		}
 		else if ( walker.getStatementType() == HqlSqlTokenTypes.UPDATE ) {
 			FromElement fromElement = walker.getFinalFromClause().getFromElement();
 			Queryable persister = fromElement.getQueryable();
 			if ( persister.isMultiTable() ) {
 				// even here, if only properties mapped to the "base table" are referenced
 				// in the set and where clauses, this could be handled by the BasicDelegate.
 				// TODO : decide if it is better performance-wise to doAfterTransactionCompletion that check, or to simply use the MultiTableUpdateDelegate
 				return new MultiTableUpdateExecutor( walker );
 			}
 			else {
 				return new BasicExecutor( walker, persister );
 			}
 		}
 		else if ( walker.getStatementType() == HqlSqlTokenTypes.INSERT ) {
 			return new BasicExecutor( walker, ( ( InsertStatement ) statement ).getIntoClause().getQueryable() );
 		}
 		else {
 			throw new QueryException( "Unexpected statement type" );
 		}
 	}
 	@Override
 	public ParameterTranslations getParameterTranslations() {
 		if ( paramTranslations == null ) {
 			paramTranslations = new ParameterTranslationsImpl( getWalker().getParameters() );
 		}
 		return paramTranslations;
 	}
 
 	public List<ParameterSpecification> getCollectedParameterSpecifications() {
 		return collectedParameterSpecifications;
 	}
 
 	@Override
 	public Class getDynamicInstantiationResultType() {
 		AggregatedSelectExpression aggregation = queryLoader.getAggregatedSelectExpression();
 		return aggregation == null ? null : aggregation.getAggregationResultType();
 	}
 
 	public static class JavaConstantConverter implements NodeTraverser.VisitationStrategy {
 		private AST dotRoot;
 		@Override
 		public void visit(AST node) {
 			if ( dotRoot != null ) {
 				// we are already processing a dot-structure
                 if (ASTUtil.isSubtreeChild(dotRoot, node)) return;
                 // we are now at a new tree level
                 dotRoot = null;
 			}
 
 			if ( node.getType() == HqlTokenTypes.DOT ) {
 				dotRoot = node;
 				handleDotStructure( dotRoot );
 			}
 		}
 		private void handleDotStructure(AST dotStructureRoot) {
 			String expression = ASTUtil.getPathText( dotStructureRoot );
 			Object constant = ReflectHelper.getConstantValue( expression );
 			if ( constant != null ) {
 				dotStructureRoot.setFirstChild( null );
 				dotStructureRoot.setType( HqlTokenTypes.JAVA_CONSTANT );
 				dotStructureRoot.setText( expression );
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/TypeDiscriminatorMetadata.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/TypeDiscriminatorMetadata.java
index 6d8f78db16..b9b6006bf8 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/TypeDiscriminatorMetadata.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/TypeDiscriminatorMetadata.java
@@ -1,48 +1,48 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.hql.internal.ast;
 import org.hibernate.type.Type;
 
 /**
  * Essentially a wrapper around a {@link org.hibernate.persister.entity.DiscriminatorMetadata}
  * and the proper sql alias to use.
  *
  * @author Steve Ebersole
  */
 public interface TypeDiscriminatorMetadata {
 	/**
 	 * Get the sql fragment that is used to determine the actual discriminator value for a row.
 	 *
 	 * @return The fragment
 	 */
 	public String getSqlFragment();
 
 	/**
 	 * Get the type used to resolve the actual discriminator value resulting from
 	 * {@link #getSqlFragment} back into a {@link Class} reference.
 	 *
 	 * @return The resolution type.
 	 */
 	public Type getResolutionType();
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTPrinter.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTPrinter.java
index ca11a0ecba..3f67c69698 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTPrinter.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/ASTPrinter.java
@@ -1,229 +1,229 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.hql.internal.ast.util;
 
 import java.io.ByteArrayOutputStream;
 import java.io.PrintStream;
 import java.io.PrintWriter;
 import java.util.ArrayList;
 import java.util.Map;
 
 import antlr.collections.AST;
 
 import org.hibernate.hql.internal.ast.tree.DisplayableNode;
 import org.hibernate.internal.util.StringHelper;
 
 /**
  * Utility for generating pretty "ASCII art" representations of syntax trees.
  *
  * @author Joshua Davis
  * @author Steve Ebersole
  */
 public class ASTPrinter {
 	private final Map tokenTypeNameCache;
 	private final boolean showClassNames;
 
 	/**
 	 * Constructs a printer.
 	 * <p/>
 	 * Delegates to {@link #ASTPrinter(Class, boolean)} with {@link #isShowClassNames showClassNames} as <tt>true</tt>
 	 *
 	 * @param tokenTypeConstants The token types to use during printing; typically the {vocabulary}TokenTypes.java
 	 * interface generated by ANTLR.
 	 */
 	public ASTPrinter(Class tokenTypeConstants) {
 		this( ASTUtil.generateTokenNameCache( tokenTypeConstants ), true );
 	}
 
 	public ASTPrinter(boolean showClassNames) {
 		this( ( Map ) null, showClassNames );
 	}
 
 	/**
 	 * Constructs a printer.
 	 *
 	 * @param tokenTypeConstants The token types to use during printing; typically the {vocabulary}TokenTypes.java
 	 * interface generated by ANTLR.
 	 * @param showClassNames Should the AST class names be shown.
 	 */
 	public ASTPrinter(Class tokenTypeConstants, boolean showClassNames) {
 		this( ASTUtil.generateTokenNameCache( tokenTypeConstants ), showClassNames );
 	}
 
 	private ASTPrinter(Map tokenTypeNameCache, boolean showClassNames) {
 		this.tokenTypeNameCache = tokenTypeNameCache;
 		this.showClassNames = showClassNames;
 	}
 
 	/**
 	 * Getter for property 'showClassNames'.
 	 *
 	 * @return Value for property 'showClassNames'.
 	 */
 	public boolean isShowClassNames() {
 		return showClassNames;
 	}
 
 	/**
 	 * Renders the AST into 'ASCII art' form and returns that string representation.
 	 *
 	 * @param ast The AST to display.
 	 * @param header The header for the display.
 	 *
 	 * @return The AST in 'ASCII art' form, as a string.
 	 */
 	public String showAsString(AST ast, String header) {
 		ByteArrayOutputStream baos = new ByteArrayOutputStream();
 		PrintStream ps = new PrintStream( baos );
 		ps.println( header );
 		showAst( ast, ps );
 		ps.flush();
 		return new String( baos.toByteArray() );
 	}
 
 	/**
 	 * Prints the AST in 'ASCII art' form to the specified print stream.
 	 *
 	 * @param ast The AST to print.
 	 * @param out The print stream to which the AST should be printed.
 	 */
 	public void showAst(AST ast, PrintStream out) {
 		showAst( ast, new PrintWriter( out ) );
 	}
 
 	/**
 	 * Prints the AST in 'ASCII art' tree form to the specified print writer.
 	 *
 	 * @param ast The AST to print.
 	 * @param pw The print writer to which the AST should be written.
 	 */
 	public void showAst(AST ast, PrintWriter pw) {
 		ArrayList parents = new ArrayList();
 		showAst( parents, pw, ast );
 		pw.flush();
 	}
 
 	/**
 	 * Returns the token type name for the given token type.
 	 *
 	 * @param type The token type.
 	 * @return String - The token type name from the token type constant class,
 	 *         or just the integer as a string if none exists.
 	 */
 	public String getTokenTypeName(int type) {
 		final Integer typeInteger = type;
 		String value = null;
 		if ( tokenTypeNameCache != null ) {
 			value = ( String ) tokenTypeNameCache.get( typeInteger );
 		}
 		if ( value == null ) {
 			value = typeInteger.toString();
 		}
 		return value;
 	}
 
 	private void showAst(ArrayList parents, PrintWriter pw, AST ast) {
 		if ( ast == null ) {
 			pw.println( "AST is null!" );
 			return;
 		}
 
 		for ( int i = 0; i < parents.size(); i++ ) {
 			AST parent = ( AST ) parents.get( i );
 			if ( parent.getNextSibling() == null ) {
 
 				pw.print( "   " );
 			}
 			else {
 				pw.print( " | " );
 			}
 		}
 
 		if ( ast.getNextSibling() == null ) {
 			pw.print( " \\-" );
 		}
 		else {
 			pw.print( " +-" );
 		}
 
 		showNode( pw, ast );
 
 		ArrayList newParents = new ArrayList( parents );
 		newParents.add( ast );
 		for ( AST child = ast.getFirstChild(); child != null; child = child.getNextSibling() ) {
 			showAst( newParents, pw, child );
 		}
 		newParents.clear();
 	}
 
 	private void showNode(PrintWriter pw, AST ast) {
 		String s = nodeToString( ast, isShowClassNames() );
 		pw.println( s );
 	}
 
 	public String nodeToString(AST ast, boolean showClassName) {
 		if ( ast == null ) {
 			return "{node:null}";
 		}
 		StringBuilder buf = new StringBuilder();
 		buf.append( "[" ).append( getTokenTypeName( ast.getType() ) ).append( "] " );
 		if ( showClassName ) {
 			buf.append( StringHelper.unqualify( ast.getClass().getName() ) ).append( ": " );
 		}
 
         buf.append( "'" );
         String text = ast.getText();
 		if ( text == null ) {
 			text = "{text:null}";
 		}
 		appendEscapedMultibyteChars(text, buf);
         buf.append( "'" );
 		if ( ast instanceof DisplayableNode ) {
 			DisplayableNode displayableNode = ( DisplayableNode ) ast;
 			// Add a space before the display text.
 			buf.append( " " ).append( displayableNode.getDisplayText() );
 		}
 		return buf.toString();
 	}
 
     public static void appendEscapedMultibyteChars(String text, StringBuilder buf) {
         char[] chars = text.toCharArray();
         for (int i = 0; i < chars.length; i++) {
             char aChar = chars[i];
             if (aChar > 256) {
                 buf.append("\\u");
                 buf.append(Integer.toHexString(aChar));
             }
             else
                 buf.append(aChar);
         }
     }
 
     public static String escapeMultibyteChars(String text) {
     	StringBuilder buf = new StringBuilder();
         appendEscapedMultibyteChars(text,buf);
         return buf.toString();
     }
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/LiteralProcessor.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/LiteralProcessor.java
index 25d743d211..bdafcab797 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/LiteralProcessor.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/ast/util/LiteralProcessor.java
@@ -1,342 +1,342 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.hql.internal.ast.util;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.text.DecimalFormat;
 
 import antlr.SemanticException;
 import antlr.collections.AST;
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.hql.internal.antlr.HqlSqlTokenTypes;
 import org.hibernate.hql.internal.antlr.SqlTokenTypes;
 import org.hibernate.hql.internal.ast.HqlSqlWalker;
 import org.hibernate.hql.internal.ast.InvalidPathException;
 import org.hibernate.hql.internal.ast.tree.DotNode;
 import org.hibernate.hql.internal.ast.tree.FromClause;
 import org.hibernate.hql.internal.ast.tree.IdentNode;
 import org.hibernate.hql.spi.QueryTranslator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.InFragment;
 import org.hibernate.type.LiteralType;
 import org.hibernate.type.Type;
 
 /**
  * A delegate that handles literals and constants for HqlSqlWalker, performing the token replacement functions and
  * classifying literals.
  *
  * @author josh
  */
 public class LiteralProcessor implements HqlSqlTokenTypes {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, LiteralProcessor.class.getName());
 
 	/**
 	 * In what format should Float and Double literal values be sent to the database?
 	 */
 	public static DecimalLiteralFormat DECIMAL_LITERAL_FORMAT = DecimalLiteralFormat.EXACT;
 
 	private HqlSqlWalker walker;
 
 	public LiteralProcessor(HqlSqlWalker hqlSqlWalker) {
 		this.walker = hqlSqlWalker;
 	}
 
 	public boolean isAlias(String alias) {
 		FromClause from = walker.getCurrentFromClause();
 		while ( from.isSubQuery() ) {
 			if ( from.containsClassAlias(alias) ) {
 				return true;
 			}
 			from = from.getParentFromClause();
 		}
 		return from.containsClassAlias(alias);
 	}
 
 	public void processConstant(AST constant, boolean resolveIdent) throws SemanticException {
 		// If the constant is an IDENT, figure out what it means...
 		boolean isIdent = ( constant.getType() == IDENT || constant.getType() == WEIRD_IDENT );
 		if ( resolveIdent && isIdent && isAlias( constant.getText() ) ) { // IDENT is a class alias in the FROM.
 			IdentNode ident = ( IdentNode ) constant;
 			// Resolve to an identity column.
 			ident.resolve(false, true);
 		}
 		else {	// IDENT might be the name of a class.
 			Queryable queryable = walker.getSessionFactoryHelper().findQueryableUsingImports( constant.getText() );
 			if ( isIdent && queryable != null ) {
 				constant.setText( queryable.getDiscriminatorSQLValue() );
 			}
 			// Otherwise, it's a literal.
 			else {
 				processLiteral( constant );
 			}
 		}
 	}
 
 	public void lookupConstant(DotNode node) throws SemanticException {
 		String text = ASTUtil.getPathText( node );
 		Queryable persister = walker.getSessionFactoryHelper().findQueryableUsingImports( text );
 		if ( persister != null ) {
 			// the name of an entity class
 			final String discrim = persister.getDiscriminatorSQLValue();
 			node.setDataType( persister.getDiscriminatorType() );
             if (InFragment.NULL.equals(discrim) || InFragment.NOT_NULL.equals(discrim)) throw new InvalidPathException(
                                                                                                                        "subclass test not allowed for null or not null discriminator: '"
                                                                                                                        + text + "'");
             setSQLValue(node, text, discrim); // the class discriminator value
 		}
 		else {
 			Object value = ReflectHelper.getConstantValue( text );
             if (value == null) throw new InvalidPathException("Invalid path: '" + text + "'");
             setConstantValue(node, text, value);
 		}
 	}
 
 	private void setSQLValue(DotNode node, String text, String value) {
 		LOG.debugf( "setSQLValue() %s -> %s", text, value );
 		node.setFirstChild( null );	// Chop off the rest of the tree.
 		node.setType( SqlTokenTypes.SQL_TOKEN );
 		node.setText(value);
 		node.setResolvedConstant( text );
 	}
 
 	private void setConstantValue(DotNode node, String text, Object value) {
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debugf( "setConstantValue() %s -> %s %s", text, value, value.getClass().getName() );
 		}
 		node.setFirstChild( null );	// Chop off the rest of the tree.
 		if ( value instanceof String ) {
 			node.setType( SqlTokenTypes.QUOTED_STRING );
 		}
 		else if ( value instanceof Character ) {
 			node.setType( SqlTokenTypes.QUOTED_STRING );
 		}
 		else if ( value instanceof Byte ) {
 			node.setType( SqlTokenTypes.NUM_INT );
 		}
 		else if ( value instanceof Short ) {
 			node.setType( SqlTokenTypes.NUM_INT );
 		}
 		else if ( value instanceof Integer ) {
 			node.setType( SqlTokenTypes.NUM_INT );
 		}
 		else if ( value instanceof Long ) {
 			node.setType( SqlTokenTypes.NUM_LONG );
 		}
 		else if ( value instanceof Double ) {
 			node.setType( SqlTokenTypes.NUM_DOUBLE );
 		}
 		else if ( value instanceof Float ) {
 			node.setType( SqlTokenTypes.NUM_FLOAT );
 		}
 		else {
 			node.setType( SqlTokenTypes.CONSTANT );
 		}
 		Type type;
 		try {
 			type = walker.getSessionFactoryHelper().getFactory().getTypeResolver().heuristicType( value.getClass().getName() );
 		}
 		catch ( MappingException me ) {
 			throw new QueryException( me );
 		}
 		if ( type == null ) {
 			throw new QueryException( QueryTranslator.ERROR_CANNOT_DETERMINE_TYPE + node.getText() );
 		}
 		try {
 			LiteralType literalType = ( LiteralType ) type;
 			Dialect dialect = walker.getSessionFactoryHelper().getFactory().getDialect();
 			//noinspection unchecked
 			node.setText( literalType.objectToSQLString( value, dialect ) );
 		}
 		catch ( Exception e ) {
 			throw new QueryException( QueryTranslator.ERROR_CANNOT_FORMAT_LITERAL + node.getText(), e );
 		}
 		node.setDataType( type );
 		node.setResolvedConstant( text );
 	}
 
 	public void processBoolean(AST constant) {
 		// TODO: something much better - look at the type of the other expression!
 		// TODO: Have comparisonExpression and/or arithmeticExpression rules complete the resolution of boolean nodes.
 		String replacement = ( String ) walker.getTokenReplacements().get( constant.getText() );
 		if ( replacement != null ) {
 			constant.setText( replacement );
 		}
 		else {
 			boolean bool = "true".equals( constant.getText().toLowerCase() );
 			Dialect dialect = walker.getSessionFactoryHelper().getFactory().getDialect();
 			constant.setText( dialect.toBooleanValueString(bool) );
 		}
 	}
 
 	private void processLiteral(AST constant) {
 		String replacement = ( String ) walker.getTokenReplacements().get( constant.getText() );
 		if ( replacement != null ) {
 			if ( LOG.isDebugEnabled() ) {
 				LOG.debugf("processConstant() : Replacing '%s' with '%s'", constant.getText(), replacement);
 			}
 			constant.setText( replacement );
 		}
 	}
 
 	public void processNumeric(AST literal) {
 		if ( literal.getType() == NUM_INT
 				|| literal.getType() == NUM_LONG
 				|| literal.getType() == NUM_BIG_INTEGER ) {
 			literal.setText( determineIntegerRepresentation( literal.getText(), literal.getType() ) );
         } else if (literal.getType() == NUM_FLOAT
 				|| literal.getType() == NUM_DOUBLE
 				|| literal.getType() == NUM_BIG_DECIMAL ) {
 			literal.setText( determineDecimalRepresentation( literal.getText(), literal.getType() ) );
         } else LOG.unexpectedLiteralTokenType(literal.getType());
 	}
 
 	private String determineIntegerRepresentation(String text, int type) {
 		try {
 			if ( type == NUM_BIG_INTEGER ) {
 				String literalValue = text;
 				if ( literalValue.endsWith( "bi" ) || literalValue.endsWith( "BI" ) ) {
 					literalValue = literalValue.substring( 0, literalValue.length() - 2 );
 				}
 				return new BigInteger( literalValue ).toString();
 			}
 			if ( type == NUM_INT ) {
 				try {
 					return Integer.valueOf( text ).toString();
 				}
 				catch( NumberFormatException e ) {
 					LOG.tracev(
 							"Could not format incoming text [{0}] as a NUM_INT; assuming numeric overflow and attempting as NUM_LONG",
 							text );
 				}
 			}
 			String literalValue = text;
 			if ( literalValue.endsWith( "l" ) || literalValue.endsWith( "L" ) ) {
 				literalValue = literalValue.substring( 0, literalValue.length() - 1 );
 			}
 			return Long.valueOf( literalValue ).toString();
 		}
 		catch( Throwable t ) {
 			throw new HibernateException( "Could not parse literal [" + text + "] as integer", t );
 		}
 	}
 
 	public String determineDecimalRepresentation(String text, int type) {
 		String literalValue = text;
 		if ( type == NUM_FLOAT ) {
 			if ( literalValue.endsWith( "f" ) || literalValue.endsWith( "F" ) ) {
 				literalValue = literalValue.substring( 0, literalValue.length() - 1 );
 			}
 		}
 		else if ( type == NUM_DOUBLE ) {
 			if ( literalValue.endsWith( "d" ) || literalValue.endsWith( "D" ) ) {
 				literalValue = literalValue.substring( 0, literalValue.length() - 1 );
 			}
 		}
 		else if ( type == NUM_BIG_DECIMAL ) {
 			if ( literalValue.endsWith( "bd" ) || literalValue.endsWith( "BD" ) ) {
 				literalValue = literalValue.substring( 0, literalValue.length() - 2 );
 			}
 		}
 
 		final BigDecimal number;
 		try {
 			number = new BigDecimal( literalValue );
 		}
 		catch( Throwable t ) {
 			throw new HibernateException( "Could not parse literal [" + text + "] as big-decimal", t );
 		}
 
 		return DECIMAL_LITERAL_FORMAT.getFormatter().format( number );
 	}
 
 
 	private static interface DecimalFormatter {
 		String format(BigDecimal number);
 	}
 
 	private static class ExactDecimalFormatter implements DecimalFormatter {
 		public static final ExactDecimalFormatter INSTANCE = new ExactDecimalFormatter();
 
 		public String format(BigDecimal number) {
 			return number.toString();
 		}
 	}
 
 	private static class ApproximateDecimalFormatter implements DecimalFormatter {
 		public static final ApproximateDecimalFormatter INSTANCE = new ApproximateDecimalFormatter();
 
 		private static final String FORMAT_STRING = "#0.0E0";
 
 		public String format(BigDecimal number) {
 			try {
 				// TODO : what amount of significant digits need to be supported here?
 				//      - from the DecimalFormat docs:
 				//          [significant digits] = [minimum integer digits] + [maximum fraction digits]
 				DecimalFormat jdkFormatter = new DecimalFormat( FORMAT_STRING );
 				jdkFormatter.setMinimumIntegerDigits( 1 );
 				jdkFormatter.setMaximumFractionDigits( Integer.MAX_VALUE );
 				return jdkFormatter.format( number );
 			}
 			catch( Throwable t ) {
 				throw new HibernateException( "Unable to format decimal literal in approximate format [" + number.toString() + "]", t );
 			}
 		}
 	}
 
 	public static enum DecimalLiteralFormat {
 		/**
 		 * Indicates that Float and Double literal values should
 		 * be treated using the SQL "exact" format (i.e., '.001')
 		 */
 		EXACT {
 			@Override
 			public DecimalFormatter getFormatter() {
 				return ExactDecimalFormatter.INSTANCE;
 			}
 		},
 		/**
 		 * Indicates that Float and Double literal values should
 		 * be treated using the SQL "approximate" format (i.e., '1E-3')
 		 */
 		@SuppressWarnings( {"UnusedDeclaration"})
 		APPROXIMATE {
 			@Override
 			public DecimalFormatter getFormatter() {
 				return ApproximateDecimalFormatter.INSTANCE;
 			}
 		};
 
 		public abstract DecimalFormatter getFormatter();
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/QueryTranslatorImpl.java b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/QueryTranslatorImpl.java
index 79c248c62b..e51d7b0669 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/QueryTranslatorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/internal/classic/QueryTranslatorImpl.java
@@ -1,1244 +1,1245 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.hql.internal.classic;
 
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Arrays;
+import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.internal.JoinSequence;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.event.spi.EventSource;
 import org.hibernate.hql.internal.HolderInstantiator;
 import org.hibernate.hql.internal.NameGenerator;
 import org.hibernate.hql.spi.FilterTranslator;
 import org.hibernate.hql.spi.ParameterTranslations;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.IteratorImpl;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.loader.BasicLoader;
 import org.hibernate.loader.spi.AfterLoadAction;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.PropertyMapping;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.sql.JoinType;
 import org.hibernate.sql.QuerySelect;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 /**
  * An instance of <tt>QueryTranslator</tt> translates a Hibernate
  * query string to SQL.
  */
 public class QueryTranslatorImpl extends BasicLoader implements FilterTranslator {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, QueryTranslatorImpl.class.getName());
 
 	private static final String[] NO_RETURN_ALIASES = new String[] {};
 
 	private final String queryIdentifier;
 	private final String queryString;
 
 	private final Map typeMap = new LinkedHashMap();
 	private final Map collections = new LinkedHashMap();
 	private List returnedTypes = new ArrayList();
 	private final List fromTypes = new ArrayList();
 	private final List scalarTypes = new ArrayList();
 	private final Map namedParameters = new HashMap();
 	private final Map aliasNames = new HashMap();
 	private final Map oneToOneOwnerNames = new HashMap();
 	private final Map uniqueKeyOwnerReferences = new HashMap();
 	private final Map decoratedPropertyMappings = new HashMap();
 
 	private final List scalarSelectTokens = new ArrayList();
 	private final List whereTokens = new ArrayList();
 	private final List havingTokens = new ArrayList();
 	private final Map joins = new LinkedHashMap();
 	private final List orderByTokens = new ArrayList();
 	private final List groupByTokens = new ArrayList();
-	private final Set querySpaces = new HashSet();
+	private final Set<Serializable> querySpaces = new HashSet<Serializable>();
 	private final Set entitiesToFetch = new HashSet();
 
 	private final Map pathAliases = new HashMap();
 	private final Map pathJoins = new HashMap();
 
 	private Queryable[] persisters;
 	private int[] owners;
 	private EntityType[] ownerAssociationTypes;
 	private String[] names;
 	private boolean[] includeInSelect;
 	private int selectLength;
 	private Type[] returnTypes;
 	private Type[] actualReturnTypes;
 	private String[][] scalarColumnNames;
 	private Map tokenReplacements;
 	private int nameCount = 0;
 	private int parameterCount = 0;
 	private boolean distinct = false;
 	private boolean compiled;
 	private String sqlString;
 	private Class holderClass;
 	private Constructor holderConstructor;
 	private boolean hasScalars;
 	private boolean shallowQuery;
 	private QueryTranslatorImpl superQuery;
 
 	private QueryableCollection collectionPersister;
 	private int collectionOwnerColumn = -1;
 	private String collectionOwnerName;
 	private String fetchName;
 
 	private String[] suffixes;
 
 	private Map enabledFilters;
 
 	/**
 	 * Construct a query translator
 	 *
 	 * @param queryIdentifier A unique identifier for the query of which this
 	 * translation is part; typically this is the original, user-supplied query string.
 	 * @param queryString The "preprocessed" query string; at the very least
 	 * already processed by {@link org.hibernate.hql.internal.QuerySplitter}.
 	 * @param enabledFilters Any enabled filters.
 	 * @param factory The session factory.
 	 */
 	public QueryTranslatorImpl(
 			String queryIdentifier,
 	        String queryString,
 	        Map enabledFilters,
 	        SessionFactoryImplementor factory) {
 		super( factory );
 		this.queryIdentifier = queryIdentifier;
 		this.queryString = queryString;
 		this.enabledFilters = enabledFilters;
 	}
 
 	/**
 	 * Construct a query translator; this form used internally.
 	 *
 	 * @param queryString The query string to process.
 	 * @param enabledFilters Any enabled filters.
 	 * @param factory The session factory.
 	 */
 	public QueryTranslatorImpl(
 	        String queryString,
 	        Map enabledFilters,
 	        SessionFactoryImplementor factory) {
 		this( queryString, queryString, enabledFilters, factory );
 	}
 
 	/**
 	 * Compile a subquery.
 	 *
 	 * @param superquery The containing query of the query to be compiled.
 	 *
 	 * @throws org.hibernate.MappingException Indicates problems resolving
 	 * things referenced in the query.
 	 * @throws org.hibernate.QueryException Generally some form of syntatic
 	 * failure.
 	 */
 	void compile(QueryTranslatorImpl superquery) throws QueryException, MappingException {
 		this.tokenReplacements = superquery.tokenReplacements;
 		this.superQuery = superquery;
 		this.shallowQuery = true;
 		this.enabledFilters = superquery.getEnabledFilters();
 		compile();
 	}
 
 
 	/**
 	 * Compile a "normal" query. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 */
 	public synchronized void compile(
 			Map replacements,
 			boolean scalar) throws QueryException, MappingException {
 		if ( !compiled ) {
 			this.tokenReplacements = replacements;
 			this.shallowQuery = scalar;
 			compile();
 		}
 	}
 
 	/**
 	 * Compile a filter. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 */
 	public synchronized void compile(
 			String collectionRole,
 			Map replacements,
 			boolean scalar) throws QueryException, MappingException {
 
 		if ( !isCompiled() ) {
 			addFromAssociation( "this", collectionRole );
 			compile( replacements, scalar );
 		}
 	}
 
 	/**
 	 * Compile the query (generate the SQL).
 	 *
 	 * @throws org.hibernate.MappingException Indicates problems resolving
 	 * things referenced in the query.
 	 * @throws org.hibernate.QueryException Generally some form of syntatic
 	 * failure.
 	 */
 	private void compile() throws QueryException, MappingException {
 		LOG.trace( "Compiling query" );
 		try {
 			ParserHelper.parse( new PreprocessingParser( tokenReplacements ),
 					queryString,
 					ParserHelper.HQL_SEPARATORS,
 					this );
 			renderSQL();
 		}
 		catch ( QueryException qe ) {
 			if ( qe.getQueryString() == null ) {
 				throw qe.wrapWithQueryString( queryString );
 			}
 			else {
 				throw qe;
 			}
 		}
 		catch ( MappingException me ) {
 			throw me;
 		}
 		catch ( Exception e ) {
 			LOG.debug( "Unexpected query compilation problem", e );
 			e.printStackTrace();
 			throw new QueryException( "Incorrect query syntax", queryString, e );
 		}
 
 		postInstantiate();
 
 		compiled = true;
 
 	}
 
 	@Override
     public String getSQLString() {
 		return sqlString;
 	}
 
 	public List<String> collectSqlStrings() {
 		return ArrayHelper.toList( new String[] { sqlString } );
 	}
 
 	public String getQueryString() {
 		return queryString;
 	}
 
 	/**
 	 * Persisters for the return values of a <tt>find()</tt> style query.
 	 *
 	 * @return an array of <tt>EntityPersister</tt>s.
 	 */
 	@Override
     protected Loadable[] getEntityPersisters() {
 		return persisters;
 	}
 
 	/**
 	 * Types of the return values of an <tt>iterate()</tt> style query.
 	 *
 	 * @return an array of <tt>Type</tt>s.
 	 */
 	public Type[] getReturnTypes() {
 		return actualReturnTypes;
 	}
 
 	public String[] getReturnAliases() {
 		// return aliases not supported in classic translator!
 		return NO_RETURN_ALIASES;
 	}
 
 	public String[][] getColumnNames() {
 		return scalarColumnNames;
 	}
 
 	private static void logQuery(String hql, String sql) {
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debugf( "HQL: %s", hql );
 			LOG.debugf( "SQL: %s", sql );
 		}
 	}
 
 	void setAliasName(String alias, String name) {
 		aliasNames.put( alias, name );
 	}
 
 	public String getAliasName(String alias) {
 		String name = ( String ) aliasNames.get( alias );
 		if ( name == null ) {
 			if ( superQuery != null ) {
 				name = superQuery.getAliasName( alias );
 			}
 			else {
 				name = alias;
 			}
 		}
 		return name;
 	}
 
 	String unalias(String path) {
 		String alias = StringHelper.root( path );
 		String name = getAliasName( alias );
         if (name != null) return name + path.substring(alias.length());
         return path;
 	}
 
 	void addEntityToFetch(String name, String oneToOneOwnerName, AssociationType ownerAssociationType) {
 		addEntityToFetch( name );
 		if ( oneToOneOwnerName != null ) oneToOneOwnerNames.put( name, oneToOneOwnerName );
 		if ( ownerAssociationType != null ) uniqueKeyOwnerReferences.put( name, ownerAssociationType );
 	}
 
 	private void addEntityToFetch(String name) {
 		entitiesToFetch.add( name );
 	}
 
 	private int nextCount() {
 		return ( superQuery == null ) ? nameCount++ : superQuery.nameCount++;
 	}
 
 	String createNameFor(String type) {
 		return StringHelper.generateAlias( type, nextCount() );
 	}
 
 	String createNameForCollection(String role) {
 		return StringHelper.generateAlias( role, nextCount() );
 	}
 
 	private String getType(String name) {
 		String type = ( String ) typeMap.get( name );
 		if ( type == null && superQuery != null ) {
 			type = superQuery.getType( name );
 		}
 		return type;
 	}
 
 	private String getRole(String name) {
 		String role = ( String ) collections.get( name );
 		if ( role == null && superQuery != null ) {
 			role = superQuery.getRole( name );
 		}
 		return role;
 	}
 
 	boolean isName(String name) {
 		return aliasNames.containsKey( name ) ||
 				typeMap.containsKey( name ) ||
 				collections.containsKey( name ) || (
 				superQuery != null && superQuery.isName( name )
 				);
 	}
 
 	PropertyMapping getPropertyMapping(String name) throws QueryException {
 		PropertyMapping decorator = getDecoratedPropertyMapping( name );
 		if ( decorator != null ) return decorator;
 
 		String type = getType( name );
 		if ( type == null ) {
 			String role = getRole( name );
 			if ( role == null ) {
 				throw new QueryException( "alias not found: " + name );
 			}
 			return getCollectionPersister( role ); //.getElementPropertyMapping();
 		}
 		else {
 			Queryable persister = getEntityPersister( type );
 			if ( persister == null ) throw new QueryException( "persistent class not found: " + type );
 			return persister;
 		}
 	}
 
 	private PropertyMapping getDecoratedPropertyMapping(String name) {
 		return ( PropertyMapping ) decoratedPropertyMappings.get( name );
 	}
 
 	void decoratePropertyMapping(String name, PropertyMapping mapping) {
 		decoratedPropertyMappings.put( name, mapping );
 	}
 
 	private Queryable getEntityPersisterForName(String name) throws QueryException {
 		String type = getType( name );
 		Queryable persister = getEntityPersister( type );
 		if ( persister == null ) throw new QueryException( "persistent class not found: " + type );
 		return persister;
 	}
 
 	Queryable getEntityPersisterUsingImports(String className) {
 		final String importedClassName = getFactory().getImportedClassName( className );
 		if ( importedClassName == null ) {
 			return null;
 		}
 		try {
 			return ( Queryable ) getFactory().getEntityPersister( importedClassName );
 		}
 		catch ( MappingException me ) {
 			return null;
 		}
 	}
 
 	Queryable getEntityPersister(String entityName) throws QueryException {
 		try {
 			return ( Queryable ) getFactory().getEntityPersister( entityName );
 		}
 		catch ( Exception e ) {
 			throw new QueryException( "persistent class not found: " + entityName );
 		}
 	}
 
 	QueryableCollection getCollectionPersister(String role) throws QueryException {
 		try {
 			return ( QueryableCollection ) getFactory().getCollectionPersister( role );
 		}
 		catch ( ClassCastException cce ) {
 			throw new QueryException( "collection role is not queryable: " + role );
 		}
 		catch ( Exception e ) {
 			throw new QueryException( "collection role not found: " + role );
 		}
 	}
 
 	void addType(String name, String type) {
 		typeMap.put( name, type );
 	}
 
 	void addCollection(String name, String role) {
 		collections.put( name, role );
 	}
 
 	void addFrom(String name, String type, JoinSequence joinSequence)
 			throws QueryException {
 		addType( name, type );
 		addFrom( name, joinSequence );
 	}
 
 	void addFromCollection(String name, String collectionRole, JoinSequence joinSequence)
 			throws QueryException {
 		//register collection role
 		addCollection( name, collectionRole );
 		addJoin( name, joinSequence );
 	}
 
 	void addFrom(String name, JoinSequence joinSequence)
 			throws QueryException {
 		fromTypes.add( name );
 		addJoin( name, joinSequence );
 	}
 
 	void addFromClass(String name, Queryable classPersister)
 			throws QueryException {
 		JoinSequence joinSequence = new JoinSequence( getFactory() )
 				.setRoot( classPersister, name );
 		//crossJoins.add(name);
 		addFrom( name, classPersister.getEntityName(), joinSequence );
 	}
 
 	void addSelectClass(String name) {
 		returnedTypes.add( name );
 	}
 
 	void addSelectScalar(Type type) {
 		scalarTypes.add( type );
 	}
 
 	void appendWhereToken(String token) {
 		whereTokens.add( token );
 	}
 
 	void appendHavingToken(String token) {
 		havingTokens.add( token );
 	}
 
 	void appendOrderByToken(String token) {
 		orderByTokens.add( token );
 	}
 
 	void appendGroupByToken(String token) {
 		groupByTokens.add( token );
 	}
 
 	void appendScalarSelectToken(String token) {
 		scalarSelectTokens.add( token );
 	}
 
 	void appendScalarSelectTokens(String[] tokens) {
 		scalarSelectTokens.add( tokens );
 	}
 
 	void addFromJoinOnly(String name, JoinSequence joinSequence) throws QueryException {
 		addJoin( name, joinSequence.getFromPart() );
 	}
 
 	void addJoin(String name, JoinSequence joinSequence) throws QueryException {
 		if ( !joins.containsKey( name ) ) joins.put( name, joinSequence );
 	}
 
 	void addNamedParameter(String name) {
 		if ( superQuery != null ) superQuery.addNamedParameter( name );
 		Integer loc = parameterCount++;
 		Object o = namedParameters.get( name );
 		if ( o == null ) {
 			namedParameters.put( name, loc );
 		}
 		else if ( o instanceof Integer ) {
 			ArrayList list = new ArrayList( 4 );
 			list.add( o );
 			list.add( loc );
 			namedParameters.put( name, list );
 		}
 		else {
 			( ( ArrayList ) o ).add( loc );
 		}
 	}
 
 	@Override
     public int[] getNamedParameterLocs(String name) throws QueryException {
 		Object o = namedParameters.get( name );
 		if ( o == null ) {
 			throw new QueryException( ERROR_NAMED_PARAMETER_DOES_NOT_APPEAR + name, queryString );
 		}
 		if ( o instanceof Integer ) return new int[] { (Integer) o };
 		else {
 			return ArrayHelper.toIntArray( ( ArrayList ) o );
 		}
 	}
 
 	private void renderSQL() throws QueryException, MappingException {
 
 		final int rtsize;
 		if ( returnedTypes.size() == 0 && scalarTypes.size() == 0 ) {
 			//ie no select clause in HQL
 			returnedTypes = fromTypes;
 			rtsize = returnedTypes.size();
 		}
 		else {
 			rtsize = returnedTypes.size();
 			Iterator iter = entitiesToFetch.iterator();
 			while ( iter.hasNext() ) {
 				returnedTypes.add( iter.next() );
 			}
 		}
 		int size = returnedTypes.size();
 		persisters = new Queryable[size];
 		names = new String[size];
 		owners = new int[size];
 		ownerAssociationTypes = new EntityType[size];
 		suffixes = new String[size];
 		includeInSelect = new boolean[size];
 		for ( int i = 0; i < size; i++ ) {
 			String name = ( String ) returnedTypes.get( i );
 			//if ( !isName(name) ) throw new QueryException("unknown type: " + name);
 			persisters[i] = getEntityPersisterForName( name );
 			// TODO: cannot use generateSuffixes() - it handles the initial suffix differently.
 			suffixes[i] = ( size == 1 ) ? "" : Integer.toString( i ) + '_';
 			names[i] = name;
 			includeInSelect[i] = !entitiesToFetch.contains( name );
 			if ( includeInSelect[i] ) selectLength++;
 			if ( name.equals( collectionOwnerName ) ) collectionOwnerColumn = i;
 			String oneToOneOwner = ( String ) oneToOneOwnerNames.get( name );
 			owners[i] = ( oneToOneOwner == null ) ? -1 : returnedTypes.indexOf( oneToOneOwner );
 			ownerAssociationTypes[i] = (EntityType) uniqueKeyOwnerReferences.get( name );
 		}
 
 		if ( ArrayHelper.isAllNegative( owners ) ) owners = null;
 
 		String scalarSelect = renderScalarSelect(); //Must be done here because of side-effect! yuck...
 
 		int scalarSize = scalarTypes.size();
 		hasScalars = scalarTypes.size() != rtsize;
 
 		returnTypes = new Type[scalarSize];
 		for ( int i = 0; i < scalarSize; i++ ) {
 			returnTypes[i] = ( Type ) scalarTypes.get( i );
 		}
 
 		QuerySelect sql = new QuerySelect( getFactory().getDialect() );
 		sql.setDistinct( distinct );
 
 		if ( !shallowQuery ) {
 			renderIdentifierSelect( sql );
 			renderPropertiesSelect( sql );
 		}
 
 		if ( collectionPersister != null ) {
 			sql.addSelectFragmentString( collectionPersister.selectFragment( fetchName, "__" ) );
 		}
 
 		if ( hasScalars || shallowQuery ) sql.addSelectFragmentString( scalarSelect );
 
 		//TODO: for some dialects it would be appropriate to add the renderOrderByPropertiesSelect() to other select strings
 		mergeJoins( sql.getJoinFragment() );
 
 		sql.setWhereTokens( whereTokens.iterator() );
 
 		sql.setGroupByTokens( groupByTokens.iterator() );
 		sql.setHavingTokens( havingTokens.iterator() );
 		sql.setOrderByTokens( orderByTokens.iterator() );
 
 		if ( collectionPersister != null && collectionPersister.hasOrdering() ) {
 			sql.addOrderBy( collectionPersister.getSQLOrderByString( fetchName ) );
 		}
 
 		scalarColumnNames = NameGenerator.generateColumnNames( returnTypes, getFactory() );
 
 		// initialize the Set of queried identifier spaces (ie. tables)
 		Iterator iter = collections.values().iterator();
 		while ( iter.hasNext() ) {
 			CollectionPersister p = getCollectionPersister( ( String ) iter.next() );
 			addQuerySpaces( p.getCollectionSpaces() );
 		}
 		iter = typeMap.keySet().iterator();
 		while ( iter.hasNext() ) {
 			Queryable p = getEntityPersisterForName( ( String ) iter.next() );
 			addQuerySpaces( p.getQuerySpaces() );
 		}
 
 		sqlString = sql.toQueryString();
 
 		if ( holderClass != null ) holderConstructor = ReflectHelper.getConstructor( holderClass, returnTypes );
 
 		if ( hasScalars ) {
 			actualReturnTypes = returnTypes;
 		}
 		else {
 			actualReturnTypes = new Type[selectLength];
 			int j = 0;
 			for ( int i = 0; i < persisters.length; i++ ) {
 				if ( includeInSelect[i] ) {
 					actualReturnTypes[j++] = getFactory().getTypeResolver()
 							.getTypeFactory()
 							.manyToOne( persisters[i].getEntityName(), shallowQuery );
 				}
 			}
 		}
 
 	}
 
 	private void renderIdentifierSelect(QuerySelect sql) {
 		int size = returnedTypes.size();
 
 		for ( int k = 0; k < size; k++ ) {
 			String name = ( String ) returnedTypes.get( k );
 			String suffix = size == 1 ? "" : Integer.toString( k ) + '_';
 			sql.addSelectFragmentString( persisters[k].identifierSelectFragment( name, suffix ) );
 		}
 
 	}
 
 	/*private String renderOrderByPropertiesSelect() {
 		StringBuffer buf = new StringBuffer(10);
 
 		//add the columns we are ordering by to the select ID select clause
 		Iterator iter = orderByTokens.iterator();
 		while ( iter.hasNext() ) {
 			String token = (String) iter.next();
 			if ( token.lastIndexOf(".") > 0 ) {
 				//ie. it is of form "foo.bar", not of form "asc" or "desc"
 				buf.append(StringHelper.COMMA_SPACE).append(token);
 			}
 		}
 
 		return buf.toString();
 	}*/
 
 	private void renderPropertiesSelect(QuerySelect sql) {
 		int size = returnedTypes.size();
 		for ( int k = 0; k < size; k++ ) {
 			String suffix = size == 1 ? "" : Integer.toString( k ) + '_';
 			String name = ( String ) returnedTypes.get( k );
 			sql.addSelectFragmentString( persisters[k].propertySelectFragment( name, suffix, false ) );
 		}
 	}
 
 	/**
 	 * WARNING: side-effecty
 	 */
 	private String renderScalarSelect() {
 
 		boolean isSubselect = superQuery != null;
 
 		StringBuilder buf = new StringBuilder( 20 );
 
 		if ( scalarTypes.size() == 0 ) {
 			//ie. no select clause
 			int size = returnedTypes.size();
 			for ( int k = 0; k < size; k++ ) {
 
 				scalarTypes.add(
 						getFactory().getTypeResolver().getTypeFactory().manyToOne( persisters[k].getEntityName(), shallowQuery )
 				);
 
 				String[] idColumnNames = persisters[k].getIdentifierColumnNames();
 				for ( int i = 0; i < idColumnNames.length; i++ ) {
 					buf.append( returnedTypes.get( k ) ).append( '.' ).append( idColumnNames[i] );
 					if ( !isSubselect ) buf.append( " as " ).append( NameGenerator.scalarName( k, i ) );
 					if ( i != idColumnNames.length - 1 || k != size - 1 ) buf.append( ", " );
 				}
 
 			}
 
 		}
 		else {
 			//there _was_ a select clause
 			Iterator iter = scalarSelectTokens.iterator();
 			int c = 0;
 			boolean nolast = false; //real hacky...
 			int parenCount = 0; // used to count the nesting of parentheses
 			while ( iter.hasNext() ) {
 				Object next = iter.next();
 				if ( next instanceof String ) {
 					String token = ( String ) next;
 
 					if ( "(".equals( token ) ) {
 						parenCount++;
 					}
 					else if ( ")".equals( token ) ) {
 						parenCount--;
 					}
 
 					String lc = token.toLowerCase();
 					if ( lc.equals( ", " ) ) {
 						if ( nolast ) {
 							nolast = false;
 						}
 						else {
 							if ( !isSubselect && parenCount == 0 ) {
 								int x = c++;
 								buf.append( " as " )
 										.append( NameGenerator.scalarName( x, 0 ) );
 							}
 						}
 					}
 					buf.append( token );
 					if ( lc.equals( "distinct" ) || lc.equals( "all" ) ) {
 						buf.append( ' ' );
 					}
 				}
 				else {
 					nolast = true;
 					String[] tokens = ( String[] ) next;
 					for ( int i = 0; i < tokens.length; i++ ) {
 						buf.append( tokens[i] );
 						if ( !isSubselect ) {
 							buf.append( " as " )
 									.append( NameGenerator.scalarName( c, i ) );
 						}
 						if ( i != tokens.length - 1 ) buf.append( ", " );
 					}
 					c++;
 				}
 			}
 			if ( !isSubselect && !nolast ) {
 				int x = c++;
 				buf.append( " as " )
 						.append( NameGenerator.scalarName( x, 0 ) );
 			}
 
 		}
 
 		return buf.toString();
 	}
 
 	private void mergeJoins(JoinFragment ojf) throws MappingException, QueryException {
 
 		Iterator iter = joins.entrySet().iterator();
 		while ( iter.hasNext() ) {
 			Map.Entry me = ( Map.Entry ) iter.next();
 			String name = ( String ) me.getKey();
 			JoinSequence join = ( JoinSequence ) me.getValue();
 			join.setSelector( new JoinSequence.Selector() {
 				public boolean includeSubclasses(String alias) {
 					boolean include = returnedTypes.contains( alias ) && !isShallowQuery();
 					return include;
 				}
 			} );
 
 			if ( typeMap.containsKey( name ) ) {
 				ojf.addFragment( join.toJoinFragment( enabledFilters, true ) );
 			}
 			else if ( collections.containsKey( name ) ) {
 				ojf.addFragment( join.toJoinFragment( enabledFilters, true ) );
 			}
 			else {
 				//name from a super query (a bit inelegant that it shows up here)
 			}
 
 		}
 
 	}
 
-	public final Set getQuerySpaces() {
+	public final Set<Serializable> getQuerySpaces() {
 		return querySpaces;
 	}
 
 	/**
 	 * Is this query called by scroll() or iterate()?
 	 *
 	 * @return true if it is, false if it is called by find() or list()
 	 */
 	boolean isShallowQuery() {
 		return shallowQuery;
 	}
 
 	void addQuerySpaces(Serializable[] spaces) {
-		for ( int i = 0; i < spaces.length; i++ ) {
-			querySpaces.add( spaces[i] );
-		}
+		Collections.addAll( querySpaces, spaces );
 		if ( superQuery != null ) superQuery.addQuerySpaces( spaces );
 	}
 
 	void setDistinct(boolean distinct) {
 		this.distinct = distinct;
 	}
 
 	boolean isSubquery() {
 		return superQuery != null;
 	}
 
 	/**
 	 * Overrides method from Loader
 	 */
 	@Override
     public CollectionPersister[] getCollectionPersisters() {
 		return collectionPersister == null ? null : new CollectionPersister[] { collectionPersister };
 	}
 
 	@Override
     protected String[] getCollectionSuffixes() {
 		return collectionPersister == null ? null : new String[] { "__" };
 	}
 
 	void setCollectionToFetch(String role, String name, String ownerName, String entityName)
 			throws QueryException {
 		fetchName = name;
 		collectionPersister = getCollectionPersister( role );
 		collectionOwnerName = ownerName;
 		if ( collectionPersister.getElementType().isEntityType() ) {
 			addEntityToFetch( entityName );
 		}
 	}
 
 	@Override
     protected String[] getSuffixes() {
 		return suffixes;
 	}
 
 	@Override
     protected String[] getAliases() {
 		return names;
 	}
 
 	/**
 	 * Used for collection filters
 	 */
 	private void addFromAssociation(final String elementName, final String collectionRole)
 			throws QueryException {
 		//q.addCollection(collectionName, collectionRole);
 		QueryableCollection persister = getCollectionPersister( collectionRole );
 		Type collectionElementType = persister.getElementType();
 		if ( !collectionElementType.isEntityType() ) {
 			throw new QueryException( "collection of values in filter: " + elementName );
 		}
 
 		String[] keyColumnNames = persister.getKeyColumnNames();
 		//if (keyColumnNames.length!=1) throw new QueryException("composite-key collection in filter: " + collectionRole);
 
 		String collectionName;
 		JoinSequence join = new JoinSequence( getFactory() );
 		collectionName = persister.isOneToMany() ?
 				elementName :
 				createNameForCollection( collectionRole );
 		join.setRoot( persister, collectionName );
 		if ( !persister.isOneToMany() ) {
 			//many-to-many
 			addCollection( collectionName, collectionRole );
 			try {
 				join.addJoin( ( AssociationType ) persister.getElementType(),
 						elementName,
 						JoinType.INNER_JOIN,
 						persister.getElementColumnNames(collectionName) );
 			}
 			catch ( MappingException me ) {
 				throw new QueryException( me );
 			}
 		}
 		join.addCondition( collectionName, keyColumnNames, " = ?" );
 		//if ( persister.hasWhere() ) join.addCondition( persister.getSQLWhereString(collectionName) );
 		EntityType elemType = ( EntityType ) collectionElementType;
 		addFrom( elementName, elemType.getAssociatedEntityName(), join );
 
 	}
 
 	String getPathAlias(String path) {
 		return ( String ) pathAliases.get( path );
 	}
 
 	JoinSequence getPathJoin(String path) {
 		return ( JoinSequence ) pathJoins.get( path );
 	}
 
 	void addPathAliasAndJoin(String path, String alias, JoinSequence joinSequence) {
 		pathAliases.put( path, alias );
 		pathJoins.put( path, joinSequence );
 	}
 
+	@Override
 	public List list(SessionImplementor session, QueryParameters queryParameters)
 			throws HibernateException {
 		return list( session, queryParameters, getQuerySpaces(), actualReturnTypes );
 	}
 
 	/**
 	 * Return the query results as an iterator
 	 */
+	@Override
 	public Iterator iterate(QueryParameters queryParameters, EventSource session)
 			throws HibernateException {
 
 		boolean stats = session.getFactory().getStatistics().isStatisticsEnabled();
 		long startTime = 0;
 		if ( stats ) startTime = System.currentTimeMillis();
 
 		try {
 			final List<AfterLoadAction> afterLoadActions = new ArrayList<AfterLoadAction>();
 			final SqlStatementWrapper wrapper = executeQueryStatement( queryParameters, false, afterLoadActions, session );
 			final ResultSet rs = wrapper.getResultSet();
 			final PreparedStatement st = (PreparedStatement) wrapper.getStatement();
 			HolderInstantiator hi = HolderInstantiator.createClassicHolderInstantiator(holderConstructor, queryParameters.getResultTransformer());
 			Iterator result = new IteratorImpl( rs, st, session, queryParameters.isReadOnly( session ), returnTypes, getColumnNames(), hi );
 
 			if ( stats ) {
 				session.getFactory().getStatisticsImplementor().queryExecuted(
 						"HQL: " + queryString,
 						0,
 						System.currentTimeMillis() - startTime
 					);
 			}
 
 			return result;
 
 		}
 		catch ( SQLException sqle ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not execute query using iterate",
 					getSQLString()
 				);
 		}
 
 	}
 
 	public int executeUpdate(QueryParameters queryParameters, SessionImplementor session) throws HibernateException {
 		throw new UnsupportedOperationException( "Not supported!  Use the AST translator...");
 	}
 
 	@Override
     protected boolean[] includeInResultRow() {
 		boolean[] isResultReturned = includeInSelect;
 		if ( hasScalars ) {
 			isResultReturned = new boolean[ returnedTypes.size() ];
 			Arrays.fill( isResultReturned, true );
 		}
 		return isResultReturned;
 	}
 
 
 	@Override
     protected ResultTransformer resolveResultTransformer(ResultTransformer resultTransformer) {
 		return HolderInstantiator.resolveClassicResultTransformer(
 				holderConstructor,
 				resultTransformer
 		);
 	}
 
 	@Override
     protected Object getResultColumnOrRow(Object[] row, ResultTransformer transformer, ResultSet rs, SessionImplementor session)
 			throws SQLException, HibernateException {
 		Object[] resultRow = getResultRow( row, rs, session );
 		return ( holderClass == null && resultRow.length == 1 ?
 				resultRow[ 0 ] :
 				resultRow
 		);
 	}
 
 	@Override
     protected Object[] getResultRow(Object[] row, ResultSet rs, SessionImplementor session)
 			throws SQLException, HibernateException {
 		Object[] resultRow;
 		if ( hasScalars ) {
 			String[][] scalarColumns = getColumnNames();
 			int queryCols = returnTypes.length;
 			resultRow = new Object[queryCols];
 			for ( int i = 0; i < queryCols; i++ ) {
 				resultRow[i] = returnTypes[i].nullSafeGet( rs, scalarColumns[i], session, null );
 			}
 		}
 		else {
 			resultRow = toResultRow( row );
 		}
 		return resultRow;
 	}
 
 	@Override
     protected List getResultList(List results, ResultTransformer resultTransformer) throws QueryException {
 		if ( holderClass != null ) {
 			for ( int i = 0; i < results.size(); i++ ) {
 				Object[] row = ( Object[] ) results.get( i );
 				try {
 					results.set( i, holderConstructor.newInstance( row ) );
 				}
 				catch ( Exception e ) {
 					throw new QueryException( "could not instantiate: " + holderClass, e );
 				}
 			}
 		}
 		return results;
 	}
 
 	private Object[] toResultRow(Object[] row) {
 		if ( selectLength == row.length ) {
 			return row;
 		}
 		else {
 			Object[] result = new Object[selectLength];
 			int j = 0;
 			for ( int i = 0; i < row.length; i++ ) {
 				if ( includeInSelect[i] ) result[j++] = row[i];
 			}
 			return result;
 		}
 	}
 
 	void setHolderClass(Class clazz) {
 		holderClass = clazz;
 	}
 
 	@Override
     protected LockMode[] getLockModes(LockOptions lockOptions) {
 
 		// unfortunately this stuff can't be cached because
 		// it is per-invocation, not constant for the
 		// QueryTranslator instance
 		HashMap nameLockOptions = new HashMap();
 		if ( lockOptions == null) {
 			lockOptions = LockOptions.NONE;
 		}
 
 		if ( lockOptions.getAliasLockCount() > 0 ) {
 			Iterator iter = lockOptions.getAliasLockIterator();
 			while ( iter.hasNext() ) {
 				Map.Entry me = ( Map.Entry ) iter.next();
 				nameLockOptions.put( getAliasName( ( String ) me.getKey() ),
 						me.getValue() );
 			}
 		}
 		LockMode[] lockModesArray = new LockMode[names.length];
 		for ( int i = 0; i < names.length; i++ ) {
 			LockMode lm = ( LockMode ) nameLockOptions.get( names[i] );
 			//if ( lm == null ) lm = LockOptions.NONE;
 			if ( lm == null ) lm = lockOptions.getLockMode();
 			lockModesArray[i] = lm;
 		}
 		return lockModesArray;
 	}
 
 	@Override
     protected String applyLocks(
 			String sql,
 			QueryParameters parameters,
 			Dialect dialect,
 			List<AfterLoadAction> afterLoadActions) throws QueryException {
 		// can't cache this stuff either (per-invocation)
 		final LockOptions lockOptions = parameters.getLockOptions();
 		final String result;
 		if ( lockOptions == null ||
 			( lockOptions.getLockMode() == LockMode.NONE && lockOptions.getAliasLockCount() == 0 ) ) {
 			return sql;
 		}
 		else {
 			LockOptions locks = new LockOptions();
 			locks.setLockMode(lockOptions.getLockMode());
 			locks.setTimeOut(lockOptions.getTimeOut());
 			locks.setScope(lockOptions.getScope());
 			Iterator iter = lockOptions.getAliasLockIterator();
 			while ( iter.hasNext() ) {
 				Map.Entry me = ( Map.Entry ) iter.next();
 				locks.setAliasSpecificLockMode( getAliasName( ( String ) me.getKey() ), (LockMode) me.getValue() );
 			}
 			Map keyColumnNames = null;
 			if ( dialect.forUpdateOfColumns() ) {
 				keyColumnNames = new HashMap();
 				for ( int i = 0; i < names.length; i++ ) {
 					keyColumnNames.put( names[i], persisters[i].getIdentifierColumnNames() );
 				}
 			}
 			result = dialect.applyLocksToSql( sql, locks, keyColumnNames );
 		}
 		logQuery( queryString, result );
 		return result;
 	}
 
 	@Override
     protected boolean upgradeLocks() {
 		return true;
 	}
 
 	@Override
     protected int[] getCollectionOwners() {
 		return new int[] { collectionOwnerColumn };
 	}
 
 	protected boolean isCompiled() {
 		return compiled;
 	}
 
 	@Override
     public String toString() {
 		return queryString;
 	}
 
 	@Override
     protected int[] getOwners() {
 		return owners;
 	}
 
 	@Override
     protected EntityType[] getOwnerAssociationTypes() {
 		return ownerAssociationTypes;
 	}
 
 	public Class getHolderClass() {
 		return holderClass;
 	}
 
 	public Map getEnabledFilters() {
 		return enabledFilters;
 	}
 
 	public ScrollableResults scroll(final QueryParameters queryParameters,
 									final SessionImplementor session)
 			throws HibernateException {
 		HolderInstantiator hi = HolderInstantiator.createClassicHolderInstantiator(
 				holderConstructor, queryParameters.getResultTransformer()
 		);
 		return scroll( queryParameters, returnTypes, hi, session );
 	}
 
 	@Override
     public String getQueryIdentifier() {
 		return queryIdentifier;
 	}
 
 	@Override
     protected boolean isSubselectLoadingEnabled() {
 		return hasSubselectLoadableCollections();
 	}
 
 	public void validateScrollability() throws HibernateException {
 		// This is the legacy behaviour for HQL queries...
 		if ( getCollectionPersisters() != null ) {
 			throw new HibernateException( "Cannot scroll queries which initialize collections" );
 		}
 	}
 
 	public boolean containsCollectionFetches() {
 		return false;
 	}
 
 	public boolean isManipulationStatement() {
 		// classic parser does not support bulk manipulation statements
 		return false;
 	}
 
 	@Override
 	public Class getDynamicInstantiationResultType() {
 		return holderClass;
 	}
 
 	public ParameterTranslations getParameterTranslations() {
 		return new ParameterTranslations() {
 
 			public boolean supportsOrdinalParameterMetadata() {
 				// classic translator does not support collection of ordinal
 				// param metadata
 				return false;
 			}
 
 			public int getOrdinalParameterCount() {
 				return 0; // not known!
 			}
 
 			public int getOrdinalParameterSqlLocation(int ordinalPosition) {
 				return 0; // not known!
 			}
 
 			public Type getOrdinalParameterExpectedType(int ordinalPosition) {
 				return null; // not known!
 			}
 
 			public Set getNamedParameterNames() {
 				return namedParameters.keySet();
 			}
 
 			public int[] getNamedParameterSqlLocations(String name) {
 				return getNamedParameterLocs( name );
 			}
 
 			public Type getNamedParameterExpectedType(String name) {
 				return null; // not known!
 			}
 		};
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/spi/QueryTranslator.java b/hibernate-core/src/main/java/org/hibernate/hql/spi/QueryTranslator.java
index 4caebc6f99..7de8ef02cb 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/spi/QueryTranslator.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/spi/QueryTranslator.java
@@ -1,191 +1,192 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.hql.spi;
 
+import java.io.Serializable;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.event.spi.EventSource;
 import org.hibernate.type.Type;
 
 /**
  * Defines the contract of an HQL->SQL translator.
  *
  * @author josh
  */
 public interface QueryTranslator {
 
 	// Error message constants.
 	public static final String ERROR_CANNOT_FETCH_WITH_ITERATE = "fetch may not be used with scroll() or iterate()";
 	public static final String ERROR_NAMED_PARAMETER_DOES_NOT_APPEAR = "Named parameter does not appear in Query: ";
     public static final String ERROR_CANNOT_DETERMINE_TYPE = "Could not determine type of: ";
 	public static final String ERROR_CANNOT_FORMAT_LITERAL =  "Could not format constant value to SQL literal: ";
 
 	/**
 	 * Compile a "normal" query. This method may be called multiple
 	 * times. Subsequent invocations are no-ops.
 	 *
 	 * @param replacements Defined query substitutions.
 	 * @param shallow      Does this represent a shallow (scalar or entity-id) select?
 	 * @throws QueryException   There was a problem parsing the query string.
 	 * @throws MappingException There was a problem querying defined mappings.
 	 */
 	void compile(Map replacements, boolean shallow) throws QueryException, MappingException;
 
 	/**
 	 * Perform a list operation given the underlying query definition.
 	 *
 	 * @param session         The session owning this query.
 	 * @param queryParameters The query bind parameters.
 	 * @return The query list results.
 	 * @throws HibernateException
 	 */
 	List list(SessionImplementor session, QueryParameters queryParameters)
 			throws HibernateException;
 
 	/**
 	 * Perform an iterate operation given the underlying query definition.
 	 *
 	 * @param queryParameters The query bind parameters.
 	 * @param session         The session owning this query.
 	 * @return An iterator over the query results.
 	 * @throws HibernateException
 	 */
 	Iterator iterate(QueryParameters queryParameters, EventSource session)
 			throws HibernateException;
 
 	/**
 	 * Perform a scroll operation given the underlying query definition.
 	 *
 	 * @param queryParameters The query bind parameters.
 	 * @param session         The session owning this query.
 	 * @return The ScrollableResults wrapper around the query results.
 	 * @throws HibernateException
 	 */
 	ScrollableResults scroll(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException;
 
 	/**
 	 * Perform a bulk update/delete operation given the underlying query definition.
 	 *
 	 * @param queryParameters The query bind parameters.
 	 * @param session         The session owning this query.
 	 * @return The number of entities updated or deleted.
 	 * @throws HibernateException
 	 */
 	int executeUpdate(QueryParameters queryParameters, SessionImplementor session)
 			throws HibernateException;
 
 	/**
 	 * Returns the set of query spaces (table names) that the query refers to.
 	 *
 	 * @return A set of query spaces (table names).
 	 */
-	Set getQuerySpaces();
+	Set<Serializable> getQuerySpaces();
 
 	/**
 	 * Retrieve the query identifier for this translator.  The query identifier is
 	 * used in states collection.
 	 *
 	 * @return the identifier
 	 */
 	String getQueryIdentifier();
 
 	/**
 	 * Returns the SQL string generated by the translator.
 	 *
 	 * @return the SQL string generated by the translator.
 	 */
 	String getSQLString();
 
 	List<String> collectSqlStrings();
 
 	/**
 	 * Returns the HQL string processed by the translator.
 	 *
 	 * @return the HQL string processed by the translator.
 	 */
 	String getQueryString();
 
 	/**
 	 * Returns the filters enabled for this query translator.
 	 *
 	 * @return Filters enabled for this query execution.
 	 */
 	Map getEnabledFilters();
 
 	/**
 	 * Returns an array of Types represented in the query result.
 	 *
 	 * @return Query return types.
 	 */
 	Type[] getReturnTypes();
 	
 	/**
 	 * Returns an array of HQL aliases
 	 */
 	String[] getReturnAliases();
 
 	/**
 	 * Returns the column names in the generated SQL.
 	 *
 	 * @return the column names in the generated SQL.
 	 */
 	String[][] getColumnNames();
 
 	/**
 	 * Return information about any parameters encountered during
 	 * translation.
 	 *
 	 * @return The parameter information.
 	 */
 	ParameterTranslations getParameterTranslations();
 
 	/**
 	 * Validate the scrollability of the translated query.
 	 *
 	 * @throws HibernateException
 	 */
 	void validateScrollability() throws HibernateException;
 
 	/**
 	 * Does the translated query contain collection fetches?
 	 *
 	 * @return true if the query does contain collection fetched;
 	 * false otherwise.
 	 */
 	boolean containsCollectionFetches();
 
 	boolean isManipulationStatement();
 
 	public Class getDynamicInstantiationResultType();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/hql/spi/TemporaryTableBulkIdStrategy.java b/hibernate-core/src/main/java/org/hibernate/hql/spi/TemporaryTableBulkIdStrategy.java
index 08b56cf6b5..44215de51e 100644
--- a/hibernate-core/src/main/java/org/hibernate/hql/spi/TemporaryTableBulkIdStrategy.java
+++ b/hibernate-core/src/main/java/org/hibernate/hql/spi/TemporaryTableBulkIdStrategy.java
@@ -1,264 +1,262 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.hql.spi;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.SQLWarning;
 import java.sql.Statement;
 import java.util.Map;
 
 import org.hibernate.cfg.Mappings;
 import org.hibernate.engine.jdbc.spi.JdbcConnectionAccess;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.hql.internal.ast.HqlSqlWalker;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.jdbc.AbstractWork;
 import org.hibernate.persister.entity.Queryable;
 import org.jboss.logging.Logger;
 
 /**
  * @author Steve Ebersole
  */
 public class TemporaryTableBulkIdStrategy implements MultiTableBulkIdStrategy {
 	public static final TemporaryTableBulkIdStrategy INSTANCE = new TemporaryTableBulkIdStrategy();
 
 	public static final String SHORT_NAME = "temporary";
 
 	private static final CoreMessageLogger log = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			TemporaryTableBulkIdStrategy.class.getName()
 	);
 
 	@Override
 	public void prepare(JdbcServices jdbcServices, JdbcConnectionAccess connectionAccess, Mappings mappings, Mapping mapping, Map settings) {
 		// nothing to do
 	}
 
 	@Override
 	public void release(JdbcServices jdbcServices, JdbcConnectionAccess connectionAccess) {
 		// nothing to do
 	}
 
 	@Override
 	public UpdateHandler buildUpdateHandler(SessionFactoryImplementor factory, HqlSqlWalker walker) {
 		return new TableBasedUpdateHandlerImpl( factory, walker ) {
 			@Override
 			protected void prepareForUse(Queryable persister, SessionImplementor session) {
 				createTempTable( persister, session );
 			}
 
 			@Override
 			protected void releaseFromUse(Queryable persister, SessionImplementor session) {
 				releaseTempTable( persister, session );
 			}
 		};
 	}
 
 	@Override
 	public DeleteHandler buildDeleteHandler(SessionFactoryImplementor factory, HqlSqlWalker walker) {
 		return new TableBasedDeleteHandlerImpl( factory, walker ) {
 			@Override
 			protected void prepareForUse(Queryable persister, SessionImplementor session) {
 				createTempTable( persister, session );
 			}
 
 			@Override
 			protected void releaseFromUse(Queryable persister, SessionImplementor session) {
 				releaseTempTable( persister, session );
 			}
 		};
 	}
 
 
 	protected void createTempTable(Queryable persister, SessionImplementor session) {
 		// Don't really know all the codes required to adequately decipher returned jdbc exceptions here.
 		// simply allow the failure to be eaten and the subsequent insert-selects/deletes should fail
 		TemporaryTableCreationWork work = new TemporaryTableCreationWork( persister );
 		if ( shouldIsolateTemporaryTableDDL( session ) ) {
 			session.getTransactionCoordinator()
 					.getTransaction()
 					.createIsolationDelegate()
 					.delegateWork( work, shouldTransactIsolatedTemporaryTableDDL( session ) );
 		}
 		else {
 			final Connection connection = session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getLogicalConnection()
 					.getConnection();
 			work.execute( connection );
 			session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.afterStatementExecution();
 		}
 	}
 
 	protected void releaseTempTable(Queryable persister, SessionImplementor session) {
 		if ( session.getFactory().getDialect().dropTemporaryTableAfterUse() ) {
 			TemporaryTableDropWork work = new TemporaryTableDropWork( persister, session );
 			if ( shouldIsolateTemporaryTableDDL( session ) ) {
 				session.getTransactionCoordinator()
 						.getTransaction()
 						.createIsolationDelegate()
 						.delegateWork( work, shouldTransactIsolatedTemporaryTableDDL( session ) );
 			}
 			else {
 				final Connection connection = session.getTransactionCoordinator()
 						.getJdbcCoordinator()
 						.getLogicalConnection()
 						.getConnection();
 				work.execute( connection );
 				session.getTransactionCoordinator()
 						.getJdbcCoordinator()
 						.afterStatementExecution();
 			}
 		}
 		else {
 			// at the very least cleanup the data :)
 			PreparedStatement ps = null;
 			try {
 				final String sql = "delete from " + persister.getTemporaryIdTableName();
 				ps = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( sql, false );
 				session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().executeUpdate( ps );
 			}
 			catch( Throwable t ) {
 				log.unableToCleanupTemporaryIdTable(t);
 			}
 			finally {
 				if ( ps != null ) {
 					try {
 						session.getTransactionCoordinator().getJdbcCoordinator().release( ps );
 					}
 					catch( Throwable ignore ) {
 						// ignore
 					}
 				}
 			}
 		}
 	}
 
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
 	protected boolean shouldIsolateTemporaryTableDDL(SessionImplementor session) {
 		Boolean dialectVote = session.getFactory().getDialect().performTemporaryTableDDLInIsolation();
 		if ( dialectVote != null ) {
-			return dialectVote.booleanValue();
+			return dialectVote;
 		}
 		return session.getFactory().getSettings().isDataDefinitionImplicitCommit();
 	}
 
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
 	protected boolean shouldTransactIsolatedTemporaryTableDDL(SessionImplementor session) {
 		// is there ever a time when it makes sense to do this?
 //		return session.getFactory().getSettings().isDataDefinitionInTransactionSupported();
 		return false;
 	}
 
 	private static class TemporaryTableCreationWork extends AbstractWork {
 		private final Queryable persister;
 
 		private TemporaryTableCreationWork(Queryable persister) {
 			this.persister = persister;
 		}
 
 		@Override
 		public void execute(Connection connection) {
 			try {
 				Statement statement = connection.createStatement();
 				try {
 					statement.executeUpdate( persister.getTemporaryIdTableDDL() );
 					persister.getFactory()
 							.getServiceRegistry()
 							.getService( JdbcServices.class )
 							.getSqlExceptionHelper()
 							.handleAndClearWarnings( statement, CREATION_WARNING_HANDLER );
 				}
 				finally {
 					try {
 						statement.close();
 					}
 					catch( Throwable ignore ) {
 						// ignore
 					}
 				}
 			}
 			catch( Exception e ) {
 				log.debug( "unable to create temporary id table [" + e.getMessage() + "]" );
 			}
 		}
 	}
 
 	private static SqlExceptionHelper.WarningHandler CREATION_WARNING_HANDLER = new SqlExceptionHelper.WarningHandlerLoggingSupport() {
 		public boolean doProcess() {
 			return log.isDebugEnabled();
 		}
 
 		public void prepare(SQLWarning warning) {
 			log.warningsCreatingTempTable( warning );
 		}
 
 		@Override
 		protected void logWarning(String description, String message) {
 			log.debug( description );
 			log.debug( message );
 		}
 	};
 
 	private static class TemporaryTableDropWork extends AbstractWork {
 		private final Queryable persister;
 		private final SessionImplementor session;
 
 		private TemporaryTableDropWork(Queryable persister, SessionImplementor session) {
 			this.persister = persister;
 			this.session = session;
 		}
 
 		@Override
 		public void execute(Connection connection) {
 			final String command = session.getFactory().getDialect().getDropTemporaryTableString()
 					+ ' ' + persister.getTemporaryIdTableName();
 			try {
 				Statement statement = connection.createStatement();
 				try {
 					statement.executeUpdate( command );
 				}
 				finally {
 					try {
 						statement.close();
 					}
 					catch( Throwable ignore ) {
 						// ignore
 					}
 				}
 			}
 			catch( Exception e ) {
 				log.warn( "unable to drop temporary id table after use [" + e.getMessage() + "]" );
 			}
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/enhanced/OptimizerFactory.java b/hibernate-core/src/main/java/org/hibernate/id/enhanced/OptimizerFactory.java
index 9d4863655e..9e5b019ed2 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/enhanced/OptimizerFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/enhanced/OptimizerFactory.java
@@ -1,169 +1,167 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.id.enhanced;
 
 import java.lang.reflect.Constructor;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 
 /**
  * Factory for {@link Optimizer} instances.
  *
  * @author Steve Ebersole
  */
 public class OptimizerFactory {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			OptimizerFactory.class.getName()
 	);
 
 	/**
 	 * Does the given optimizer name represent a pooled strategy?
 	 *
 	 * @param optimizerName The name of the optimizer
 	 *
 	 * @return {@code true} indicates the optimizer is a pooled strategy.
 	 */
 	public static boolean isPooledOptimizer(String optimizerName) {
 		final StandardOptimizerDescriptor standardDescriptor = StandardOptimizerDescriptor.fromExternalName( optimizerName );
 		return standardDescriptor != null && standardDescriptor.isPooled();
 	}
 
 	private static final Class[] CTOR_SIG = new Class[] { Class.class, int.class };
 
 	/**
 	 * Builds an optimizer
 	 *
 	 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 	 * @param returnClass The generated value java type
 	 * @param incrementSize The increment size.
 	 *
 	 * @return The built optimizer
 	 *
 	 * @deprecated Use {@link #buildOptimizer(String, Class, int, long)} instead
 	 */
 	@Deprecated
-	@SuppressWarnings( {"UnnecessaryBoxing", "unchecked"})
 	public static Optimizer buildOptimizer(String type, Class returnClass, int incrementSize) {
 		final Class<? extends Optimizer> optimizerClass;
 
 		final StandardOptimizerDescriptor standardDescriptor = StandardOptimizerDescriptor.fromExternalName( type );
 		if ( standardDescriptor != null ) {
 			optimizerClass = standardDescriptor.getOptimizerClass();
 		}
 		else {
 			try {
 				optimizerClass = ReflectHelper.classForName( type );
 			}
 			catch( Throwable ignore ) {
 				LOG.unableToLocateCustomOptimizerClass( type );
 				return buildFallbackOptimizer( returnClass, incrementSize );
 			}
 		}
 
 		try {
 			final Constructor ctor = optimizerClass.getConstructor( CTOR_SIG );
-			return (Optimizer) ctor.newInstance( returnClass, Integer.valueOf( incrementSize ) );
+			return (Optimizer) ctor.newInstance( returnClass, incrementSize );
 		}
 		catch( Throwable ignore ) {
 			LOG.unableToInstantiateOptimizer( type );
 		}
 
 		return buildFallbackOptimizer( returnClass, incrementSize );
 	}
 
 	private static Optimizer buildFallbackOptimizer(Class returnClass, int incrementSize) {
 		return new NoopOptimizer( returnClass, incrementSize );
 	}
 
 	/**
 	 * Builds an optimizer
 	 *
 	 * @param type The optimizer type, either a short-hand name or the {@link Optimizer} class name.
 	 * @param returnClass The generated value java type
 	 * @param incrementSize The increment size.
 	 * @param explicitInitialValue The user supplied initial-value (-1 indicates the user did not specify).
 	 *
 	 * @return The built optimizer
 	 */
-	@SuppressWarnings({ "UnnecessaryBoxing", "deprecation" })
 	public static Optimizer buildOptimizer(String type, Class returnClass, int incrementSize, long explicitInitialValue) {
 		final Optimizer optimizer = buildOptimizer( type, returnClass, incrementSize );
 		if ( InitialValueAwareOptimizer.class.isInstance( optimizer ) ) {
 			( (InitialValueAwareOptimizer) optimizer ).injectInitialValue( explicitInitialValue );
 		}
 		return optimizer;
 	}
 
 	/**
 	 * Deprecated!
 	 *
 	 * @deprecated Use {@link StandardOptimizerDescriptor#getExternalName()} via {@link StandardOptimizerDescriptor#NONE}
 	 */
 	@Deprecated
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public static final String NONE = StandardOptimizerDescriptor.NONE.getExternalName();
 
 	/**
 	 * Deprecated!
 	 *
 	 * @deprecated Use {@link StandardOptimizerDescriptor#getExternalName()} via {@link StandardOptimizerDescriptor#HILO}
 	 */
 	@Deprecated
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public static final String HILO = StandardOptimizerDescriptor.HILO.getExternalName();
 
 	/**
 	 * Deprecated!
 	 *
 	 * @deprecated Use {@link StandardOptimizerDescriptor#getExternalName()} via {@link StandardOptimizerDescriptor#LEGACY_HILO}
 	 */
 	@Deprecated
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public static final String LEGACY_HILO = "legacy-hilo";
 
 	/**
 	 * Deprecated!
 	 *
 	 * @deprecated Use {@link StandardOptimizerDescriptor#getExternalName()} via {@link StandardOptimizerDescriptor#POOLED}
 	 */
 	@Deprecated
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public static final String POOL = "pooled";
 
 	/**
 	 * Deprecated!
 	 *
 	 * @deprecated Use {@link StandardOptimizerDescriptor#getExternalName()} via {@link StandardOptimizerDescriptor#POOLED_LO}
 	 */
 	@Deprecated
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public static final String POOL_LO = "pooled-lo";
 
 	private OptimizerFactory() {
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/AbstractQueryImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/AbstractQueryImpl.java
index a62ea7d243..62cfa9d945 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/AbstractQueryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/AbstractQueryImpl.java
@@ -1,1022 +1,1019 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import java.io.Serializable;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.CacheMode;
 import org.hibernate.FlushMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.NonUniqueResultException;
 import org.hibernate.PropertyNotFoundException;
 import org.hibernate.Query;
 import org.hibernate.QueryException;
 import org.hibernate.Session;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.query.spi.ParameterMetadata;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.RowSelection;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.TypedValue;
 import org.hibernate.hql.internal.classic.ParserHelper;
 import org.hibernate.internal.util.MarkerObject;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.property.Getter;
 import org.hibernate.proxy.HibernateProxyHelper;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.SerializableType;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.Type;
 import org.jboss.logging.Logger;
 
 /**
  * Abstract implementation of the Query interface.
  *
  * @author Gavin King
  * @author Max Andersen
  */
 public abstract class AbstractQueryImpl implements Query {
 	private static final CoreMessageLogger log = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			AbstractQueryImpl.class.getName()
 	);
 
 	private static final Object UNSET_PARAMETER = new MarkerObject("<unset parameter>");
 	private static final Object UNSET_TYPE = new MarkerObject("<unset type>");
 
 	private final String queryString;
 	protected final SessionImplementor session;
 	protected final ParameterMetadata parameterMetadata;
 
 	// parameter bind values...
 	private List values = new ArrayList(4);
 	private List types = new ArrayList(4);
 	private Map<String,TypedValue> namedParameters = new HashMap<String, TypedValue>(4);
-	private Map namedParameterLists = new HashMap(4);
+	private Map<String, TypedValue> namedParameterLists = new HashMap<String, TypedValue>(4);
 
 	private Object optionalObject;
 	private Serializable optionalId;
 	private String optionalEntityName;
 
 	private RowSelection selection;
 	private boolean cacheable;
 	private String cacheRegion;
 	private String comment;
 	private FlushMode flushMode;
 	private CacheMode cacheMode;
 	private FlushMode sessionFlushMode;
 	private CacheMode sessionCacheMode;
 	private Serializable collectionKey;
 	private Boolean readOnly;
 	private ResultTransformer resultTransformer;
 
 	public AbstractQueryImpl(
 			String queryString,
 	        FlushMode flushMode,
 	        SessionImplementor session,
 	        ParameterMetadata parameterMetadata) {
 		this.session = session;
 		this.queryString = queryString;
 		this.selection = new RowSelection();
 		this.flushMode = flushMode;
 		this.cacheMode = null;
 		this.parameterMetadata = parameterMetadata;
 	}
 
 	public ParameterMetadata getParameterMetadata() {
 		return parameterMetadata;
 	}
 
 	@Override
 	public String toString() {
 		return StringHelper.unqualify( getClass().getName() ) + '(' + queryString + ')';
 	}
 
 	@Override
 	public final String getQueryString() {
 		return queryString;
 	}
 
 	@Override
 	public boolean isCacheable() {
 		return cacheable;
 	}
 
 	@Override
 	public Query setCacheable(boolean cacheable) {
 		this.cacheable = cacheable;
 		return this;
 	}
 
 	@Override
 	public String getCacheRegion() {
 		return cacheRegion;
 	}
 
 	@Override
 	public Query setCacheRegion(String cacheRegion) {
 		if (cacheRegion != null) {
 			this.cacheRegion = cacheRegion.trim();
 		}
 		return this;
 	}
 
 	@Override
 	public FlushMode getFlushMode() {
 		return flushMode;
 	}
 
 	@Override
 	public Query setFlushMode(FlushMode flushMode) {
 		this.flushMode = flushMode;
 		return this;
 	}
 
 	@Override
 	public CacheMode getCacheMode() {
 		return cacheMode;
 	}
 
 	@Override
 	public Query setCacheMode(CacheMode cacheMode) {
 		this.cacheMode = cacheMode;
 		return this;
 	}
 
 	@Override
 	public String getComment() {
 		return comment;
 	}
 
 	@Override
 	public Query setComment(String comment) {
 		this.comment = comment;
 		return this;
 	}
 
 	@Override
 	public Integer getFirstResult() {
 		return selection.getFirstRow();
 	}
 
 	@Override
 	public Query setFirstResult(int firstResult) {
 		selection.setFirstRow( firstResult);
 		return this;
 	}
 
 	@Override
 	public Integer getMaxResults() {
 		return selection.getMaxRows();
 	}
 
 	@Override
 	public Query setMaxResults(int maxResults) {
 		if ( maxResults < 0 ) {
 			// treat negatives specically as meaning no limit...
 			selection.setMaxRows( null );
 		}
 		else {
 			selection.setMaxRows( maxResults);
 		}
 		return this;
 	}
 
 	@Override
 	public Integer getTimeout() {
 		return selection.getTimeout();
 	}
 
 	@Override
 	public Query setTimeout(int timeout) {
 		selection.setTimeout( timeout);
 		return this;
 	}
 
 	@Override
 	public Integer getFetchSize() {
 		return selection.getFetchSize();
 	}
 
 	@Override
 	public Query setFetchSize(int fetchSize) {
 		selection.setFetchSize( fetchSize);
 		return this;
 	}
 
 	public Type[] getReturnTypes() throws HibernateException {
 		return session.getFactory().getReturnTypes( queryString );
 	}
 
 	public String[] getReturnAliases() throws HibernateException {
 		return session.getFactory().getReturnAliases( queryString );
 	}
 
 	public Query setCollectionKey(Serializable collectionKey) {
 		this.collectionKey = collectionKey;
 		return this;
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public boolean isReadOnly() {
 		return ( readOnly == null ?
 				getSession().getPersistenceContext().isDefaultReadOnly() :
-				readOnly.booleanValue() 
+				readOnly
 		);
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	@Override
 	public Query setReadOnly(boolean readOnly) {
-		this.readOnly = Boolean.valueOf( readOnly );
+		this.readOnly = readOnly;
 		return this;
 	}
-
+	@Override
 	public Query setResultTransformer(ResultTransformer transformer) {
 		this.resultTransformer = transformer;
 		return this;
 	}
 	
 	public void setOptionalEntityName(String optionalEntityName) {
 		this.optionalEntityName = optionalEntityName;
 	}
 
 	public void setOptionalId(Serializable optionalId) {
 		this.optionalId = optionalId;
 	}
 
 	public void setOptionalObject(Object optionalObject) {
 		this.optionalObject = optionalObject;
 	}
 
 	SessionImplementor getSession() {
 		return session;
 	}
-
+	@Override
 	public abstract LockOptions getLockOptions();
 
 
 	// Parameter handling code ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Returns a shallow copy of the named parameter value map.
 	 *
 	 * @return Shallow copy of the named parameter value map
 	 */
-	protected Map getNamedParams() {
-		return new HashMap( namedParameters );
+	protected Map<String, TypedValue> getNamedParams() {
+		return new HashMap<String, TypedValue>( namedParameters );
 	}
 
 	/**
 	 * Returns an array representing all named parameter names encountered
 	 * during (intial) parsing of the query.
 	 * <p/>
 	 * Note <i>initial</i> here means different things depending on whether
 	 * this is a native-sql query or an HQL/filter query.  For native-sql, a
 	 * precursory inspection of the query string is performed specifically to
 	 * locate defined parameters.  For HQL/filter queries, this is the
 	 * information returned from the query-translator.  This distinction
 	 * holds true for all parameter metadata exposed here.
 	 *
 	 * @return Array of named parameter names.
 	 * @throws HibernateException
 	 */
+	@Override
 	public String[] getNamedParameters() throws HibernateException {
 		return ArrayHelper.toStringArray( parameterMetadata.getNamedParameterNames() );
 	}
 
 	/**
 	 * Does this query contain named parameters?
 	 *
 	 * @return True if the query was found to contain named parameters; false
 	 * otherwise;
 	 */
 	public boolean hasNamedParameters() {
 		return parameterMetadata.getNamedParameterNames().size() > 0;
 	}
 
 	/**
 	 * Retreive the value map for any named parameter lists (i.e., for
 	 * auto-expansion) bound to this query.
 	 *
 	 * @return The parameter list value map.
 	 */
-	protected Map getNamedParameterLists() {
+	protected Map<String, TypedValue> getNamedParameterLists() {
 		return namedParameterLists;
 	}
 
 	/**
 	 * Retreives the list of parameter values bound to this query for
 	 * ordinal parameters.
 	 *
 	 * @return The ordinal parameter values.
 	 */
 	protected List getValues() {
 		return values;
 	}
 
 	/**
 	 * Retreives the list of parameter {@link Type type}s bound to this query for
 	 * ordinal parameters.
 	 *
 	 * @return The ordinal parameter types.
 	 */
 	protected List getTypes() {
 		return types;
 	}
 
 	/**
 	 * Perform parameter validation.  Used prior to executing the encapsulated
 	 * query.
 	 *
 	 * @throws QueryException
 	 */
 	protected void verifyParameters() throws QueryException {
 		verifyParameters(false);
 	}
 
 	/**
 	 * Perform parameter validation.  Used prior to executing the encapsulated
 	 * query.
 	 *
 	 * @param reserveFirstParameter if true, the first ? will not be verified since
 	 * its needed for e.g. callable statements returning a out parameter
 	 * @throws HibernateException
 	 */
 	protected void verifyParameters(boolean reserveFirstParameter) throws HibernateException {
 		if ( parameterMetadata.getNamedParameterNames().size() != namedParameters.size() + namedParameterLists.size() ) {
-			Set missingParams = new HashSet( parameterMetadata.getNamedParameterNames() );
+			Set<String> missingParams = new HashSet<String>( parameterMetadata.getNamedParameterNames() );
 			missingParams.removeAll( namedParameterLists.keySet() );
 			missingParams.removeAll( namedParameters.keySet() );
 			throw new QueryException( "Not all named parameters have been set: " + missingParams, getQueryString() );
 		}
 
 		int positionalValueSpan = 0;
 		for ( int i = 0; i < values.size(); i++ ) {
 			Object object = types.get( i );
 			if( values.get( i ) == UNSET_PARAMETER || object == UNSET_TYPE ) {
 				if ( reserveFirstParameter && i==0 ) {
 					continue;
 				}
 				else {
 					throw new QueryException( "Unset positional parameter at position: " + i, getQueryString() );
 				}
 			}
 			positionalValueSpan += ( (Type) object ).getColumnSpan( session.getFactory() );
 		}
 
 		if ( parameterMetadata.getOrdinalParameterCount() != positionalValueSpan ) {
 			if ( reserveFirstParameter && parameterMetadata.getOrdinalParameterCount() - 1 != positionalValueSpan ) {
 				throw new QueryException(
 				 		"Expected positional parameter count: " +
 				 		(parameterMetadata.getOrdinalParameterCount()-1) +
 				 		", actual parameters: " +
 				 		values,
 				 		getQueryString()
 				 	);
 			}
 			else if ( !reserveFirstParameter ) {
 				throw new QueryException(
 				 		"Expected positional parameter count: " +
 				 		parameterMetadata.getOrdinalParameterCount() +
 				 		", actual parameters: " +
 				 		values,
 				 		getQueryString()
 				 	);
 			}
 		}
 	}
 
 	public Query setParameter(int position, Object val, Type type) {
 		if ( parameterMetadata.getOrdinalParameterCount() == 0 ) {
 			throw new IllegalArgumentException("No positional parameters in query: " + getQueryString() );
 		}
 		if ( position < 0 || position > parameterMetadata.getOrdinalParameterCount() - 1 ) {
 			throw new IllegalArgumentException("Positional parameter does not exist: " + position + " in query: " + getQueryString() );
 		}
 		int size = values.size();
 		if ( position < size ) {
 			values.set( position, val );
 			types.set( position, type );
 		}
 		else {
 			// prepend value and type list with null for any positions before the wanted position.
 			for ( int i = 0; i < position - size; i++ ) {
 				values.add( UNSET_PARAMETER );
 				types.add( UNSET_TYPE );
 			}
 			values.add( val );
 			types.add( type );
 		}
 		return this;
 	}
 
 	public Query setParameter(String name, Object val, Type type) {
 		if ( !parameterMetadata.getNamedParameterNames().contains( name ) ) {
 			throw new IllegalArgumentException("Parameter " + name + " does not exist as a named parameter in [" + getQueryString() + "]");
 		}
 		else {
 			 namedParameters.put( name, new TypedValue( type, val  ) );
 			 return this;
 		}
 	}
 
 	public Query setParameter(int position, Object val) throws HibernateException {
 		if (val == null) {
 			setParameter( position, val, StandardBasicTypes.SERIALIZABLE );
 		}
 		else {
 			setParameter( position, val, determineType( position, val ) );
 		}
 		return this;
 	}
 
 	public Query setParameter(String name, Object val) throws HibernateException {
 		if (val == null) {
 			Type type = parameterMetadata.getNamedParameterExpectedType( name );
 			if ( type == null ) {
 				type = StandardBasicTypes.SERIALIZABLE;
 			}
 			setParameter( name, val, type );
 		}
 		else {
 			setParameter( name, val, determineType( name, val ) );
 		}
 		return this;
 	}
 
 	protected Type determineType(int paramPosition, Object paramValue, Type defaultType) {
 		Type type = parameterMetadata.getOrdinalParameterExpectedType( paramPosition + 1 );
 		if ( type == null ) {
 			type = defaultType;
 		}
 		return type;
 	}
 
 	protected Type determineType(int paramPosition, Object paramValue) throws HibernateException {
 		Type type = parameterMetadata.getOrdinalParameterExpectedType( paramPosition + 1 );
 		if ( type == null ) {
 			type = guessType( paramValue );
 		}
 		return type;
 	}
 
 	protected Type determineType(String paramName, Object paramValue, Type defaultType) {
 		Type type = parameterMetadata.getNamedParameterExpectedType( paramName );
 		if ( type == null ) {
 			type = defaultType;
 		}
 		return type;
 	}
 
 	protected Type determineType(String paramName, Object paramValue) throws HibernateException {
 		Type type = parameterMetadata.getNamedParameterExpectedType( paramName );
 		if ( type == null ) {
 			type = guessType( paramValue );
 		}
 		return type;
 	}
 
 	protected Type determineType(String paramName, Class clazz) throws HibernateException {
 		Type type = parameterMetadata.getNamedParameterExpectedType( paramName );
 		if ( type == null ) {
 			type = guessType( clazz );
 		}
 		return type;
 	}
 
 	private Type guessType(Object param) throws HibernateException {
 		Class clazz = HibernateProxyHelper.getClassWithoutInitializingProxy( param );
 		return guessType( clazz );
 	}
 
 	private Type guessType(Class clazz) throws HibernateException {
 		String typename = clazz.getName();
 		Type type = session.getFactory().getTypeResolver().heuristicType(typename);
 		boolean serializable = type!=null && type instanceof SerializableType;
 		if (type==null || serializable) {
 			try {
 				session.getFactory().getEntityPersister( clazz.getName() );
 			}
 			catch (MappingException me) {
 				if (serializable) {
 					return type;
 				}
 				else {
 					throw new HibernateException("Could not determine a type for class: " + typename);
 				}
 			}
 			return ( (Session) session ).getTypeHelper().entity( clazz );
 		}
 		else {
 			return type;
 		}
 	}
 
 	public Query setString(int position, String val) {
 		setParameter(position, val, StandardBasicTypes.STRING);
 		return this;
 	}
 
 	public Query setCharacter(int position, char val) {
 		setParameter( position, Character.valueOf( val ), StandardBasicTypes.CHARACTER );
 		return this;
 	}
 
 	public Query setBoolean(int position, boolean val) {
 		Boolean valueToUse = val;
 		Type typeToUse = determineType( position, valueToUse, StandardBasicTypes.BOOLEAN );
 		setParameter( position, valueToUse, typeToUse );
 		return this;
 	}
 
 	public Query setByte(int position, byte val) {
 		setParameter(position, val, StandardBasicTypes.BYTE);
 		return this;
 	}
 
 	public Query setShort(int position, short val) {
 		setParameter(position, val, StandardBasicTypes.SHORT);
 		return this;
 	}
 
 	public Query setInteger(int position, int val) {
 		setParameter(position, val, StandardBasicTypes.INTEGER);
 		return this;
 	}
 
 	public Query setLong(int position, long val) {
 		setParameter(position, val, StandardBasicTypes.LONG);
 		return this;
 	}
 
 	public Query setFloat(int position, float val) {
 		setParameter(position, val, StandardBasicTypes.FLOAT);
 		return this;
 	}
 
 	public Query setDouble(int position, double val) {
 		setParameter(position, val, StandardBasicTypes.DOUBLE);
 		return this;
 	}
 
 	public Query setBinary(int position, byte[] val) {
 		setParameter(position, val, StandardBasicTypes.BINARY);
 		return this;
 	}
 
 	public Query setText(int position, String val) {
 		setParameter(position, val, StandardBasicTypes.TEXT);
 		return this;
 	}
 
 	public Query setSerializable(int position, Serializable val) {
 		setParameter(position, val, StandardBasicTypes.SERIALIZABLE);
 		return this;
 	}
 
 	public Query setDate(int position, Date date) {
 		setParameter(position, date, StandardBasicTypes.DATE);
 		return this;
 	}
 
 	public Query setTime(int position, Date date) {
 		setParameter(position, date, StandardBasicTypes.TIME);
 		return this;
 	}
 
 	public Query setTimestamp(int position, Date date) {
 		setParameter(position, date, StandardBasicTypes.TIMESTAMP);
 		return this;
 	}
 
 	public Query setEntity(int position, Object val) {
 		setParameter( position, val, ( (Session) session ).getTypeHelper().entity( resolveEntityName( val ) ) );
 		return this;
 	}
 
 	private String resolveEntityName(Object val) {
 		if ( val == null ) {
 			throw new IllegalArgumentException( "entity for parameter binding cannot be null" );
 		}
 		return session.bestGuessEntityName( val );
 	}
 
 	public Query setLocale(int position, Locale locale) {
 		setParameter(position, locale, StandardBasicTypes.LOCALE);
 		return this;
 	}
 
 	public Query setCalendar(int position, Calendar calendar) {
 		setParameter(position, calendar, StandardBasicTypes.CALENDAR);
 		return this;
 	}
 
 	public Query setCalendarDate(int position, Calendar calendar) {
 		setParameter(position, calendar, StandardBasicTypes.CALENDAR_DATE);
 		return this;
 	}
 
 	public Query setBinary(String name, byte[] val) {
 		setParameter(name, val, StandardBasicTypes.BINARY);
 		return this;
 	}
 
 	public Query setText(String name, String val) {
 		setParameter(name, val, StandardBasicTypes.TEXT);
 		return this;
 	}
 
 	public Query setBoolean(String name, boolean val) {
 		Boolean valueToUse = val;
 		Type typeToUse = determineType( name, valueToUse, StandardBasicTypes.BOOLEAN );
 		setParameter( name, valueToUse, typeToUse );
 		return this;
 	}
 
 	public Query setByte(String name, byte val) {
 		setParameter(name, val, StandardBasicTypes.BYTE);
 		return this;
 	}
 
 	public Query setCharacter(String name, char val) {
 		setParameter(name, val, StandardBasicTypes.CHARACTER);
 		return this;
 	}
 
 	public Query setDate(String name, Date date) {
 		setParameter(name, date, StandardBasicTypes.DATE);
 		return this;
 	}
 
 	public Query setDouble(String name, double val) {
 		setParameter(name, val, StandardBasicTypes.DOUBLE);
 		return this;
 	}
 
 	public Query setEntity(String name, Object val) {
 		setParameter( name, val, ( (Session) session ).getTypeHelper().entity( resolveEntityName( val ) ) );
 		return this;
 	}
 
 	public Query setFloat(String name, float val) {
 		setParameter(name, val, StandardBasicTypes.FLOAT);
 		return this;
 	}
 
 	public Query setInteger(String name, int val) {
 		setParameter(name, val, StandardBasicTypes.INTEGER);
 		return this;
 	}
 
 	public Query setLocale(String name, Locale locale) {
 		setParameter(name, locale, StandardBasicTypes.LOCALE);
 		return this;
 	}
 
 	public Query setCalendar(String name, Calendar calendar) {
 		setParameter(name, calendar, StandardBasicTypes.CALENDAR);
 		return this;
 	}
 
 	public Query setCalendarDate(String name, Calendar calendar) {
 		setParameter(name, calendar, StandardBasicTypes.CALENDAR_DATE);
 		return this;
 	}
 
 	public Query setLong(String name, long val) {
 		setParameter(name, val, StandardBasicTypes.LONG);
 		return this;
 	}
 
 	public Query setSerializable(String name, Serializable val) {
 		setParameter(name, val, StandardBasicTypes.SERIALIZABLE);
 		return this;
 	}
 
 	public Query setShort(String name, short val) {
 		setParameter(name, val, StandardBasicTypes.SHORT);
 		return this;
 	}
 
 	public Query setString(String name, String val) {
 		setParameter(name, val, StandardBasicTypes.STRING);
 		return this;
 	}
 
 	public Query setTime(String name, Date date) {
 		setParameter(name, date, StandardBasicTypes.TIME);
 		return this;
 	}
 
 	public Query setTimestamp(String name, Date date) {
 		setParameter(name, date, StandardBasicTypes.TIMESTAMP);
 		return this;
 	}
 
 	public Query setBigDecimal(int position, BigDecimal number) {
 		setParameter(position, number, StandardBasicTypes.BIG_DECIMAL);
 		return this;
 	}
 
 	public Query setBigDecimal(String name, BigDecimal number) {
 		setParameter(name, number, StandardBasicTypes.BIG_DECIMAL);
 		return this;
 	}
 
 	public Query setBigInteger(int position, BigInteger number) {
 		setParameter(position, number, StandardBasicTypes.BIG_INTEGER);
 		return this;
 	}
 
 	public Query setBigInteger(String name, BigInteger number) {
 		setParameter(name, number, StandardBasicTypes.BIG_INTEGER);
 		return this;
 	}
 
+	@Override
 	public Query setParameterList(String name, Collection vals, Type type) throws HibernateException {
 		if ( !parameterMetadata.getNamedParameterNames().contains( name ) ) {
 			throw new IllegalArgumentException("Parameter " + name + " does not exist as a named parameter in [" + getQueryString() + "]");
 		}
 		namedParameterLists.put( name, new TypedValue( type, vals ) );
 		return this;
 	}
 	
 	/**
 	 * Warning: adds new parameters to the argument by side-effect, as well as
 	 * mutating the query string!
 	 */
 	protected String expandParameterLists(Map namedParamsCopy) {
 		String query = this.queryString;
-		Iterator iter = namedParameterLists.entrySet().iterator();
-		while ( iter.hasNext() ) {
-			Map.Entry me = (Map.Entry) iter.next();
+		for ( Map.Entry<String, TypedValue> stringTypedValueEntry : namedParameterLists.entrySet() ) {
+			Map.Entry me = (Map.Entry) stringTypedValueEntry;
 			query = expandParameterList( query, (String) me.getKey(), (TypedValue) me.getValue(), namedParamsCopy );
 		}
 		return query;
 	}
 
 	/**
 	 * Warning: adds new parameters to the argument by side-effect, as well as
 	 * mutating the query string!
 	 */
 	private String expandParameterList(String query, String name, TypedValue typedList, Map namedParamsCopy) {
 		Collection vals = (Collection) typedList.getValue();
 		
 		// HHH-1123
 		// Some DBs limit number of IN expressions.  For now, warn...
 		final Dialect dialect = session.getFactory().getDialect();
 		final int inExprLimit = dialect.getInExpressionCountLimit();
 		if ( inExprLimit > 0 && vals.size() > inExprLimit ) {
 			log.tooManyInExpressions( dialect.getClass().getName(), inExprLimit, name, vals.size() );
 		}
 
 		Type type = typedList.getType();
 
 		boolean isJpaPositionalParam = parameterMetadata.getNamedParameterDescriptor( name ).isJpaStyle();
 		String paramPrefix = isJpaPositionalParam ? "?" : ParserHelper.HQL_VARIABLE_PREFIX;
 		String placeholder =
 				new StringBuilder( paramPrefix.length() + name.length() )
 						.append( paramPrefix ).append(  name )
 						.toString();
 
 		if ( query == null ) {
 			return query;
 		}
 		int loc = query.indexOf( placeholder );
 
 		if ( loc < 0 ) {
 			return query;
 		}
 
 		String beforePlaceholder = query.substring( 0, loc );
 		String afterPlaceholder =  query.substring( loc + placeholder.length() );
 
 		// check if placeholder is already immediately enclosed in parentheses
 		// (ignoring whitespace)
 		boolean isEnclosedInParens =
 				StringHelper.getLastNonWhitespaceCharacter( beforePlaceholder ) == '(' &&
 				StringHelper.getFirstNonWhitespaceCharacter( afterPlaceholder ) == ')';
 
 		if ( vals.size() == 1  && isEnclosedInParens ) {
 			// short-circuit for performance when only 1 value and the
 			// placeholder is already enclosed in parentheses...
 			namedParamsCopy.put( name, new TypedValue( type, vals.iterator().next() ) );
 			return query;
 		}
 
 		StringBuilder list = new StringBuilder( 16 );
 		Iterator iter = vals.iterator();
 		int i = 0;
 		while ( iter.hasNext() ) {
 			String alias = ( isJpaPositionalParam ? 'x' + name : name ) + i++ + '_';
 			namedParamsCopy.put( alias, new TypedValue( type, iter.next() ) );
 			list.append( ParserHelper.HQL_VARIABLE_PREFIX ).append( alias );
 			if ( iter.hasNext() ) {
 				list.append( ", " );
 			}
 		}
 		return StringHelper.replace(
 				beforePlaceholder,
 				afterPlaceholder,
 				placeholder.toString(),
 				list.toString(),
 				true,
 				true
 		);
 	}
 
 	public Query setParameterList(String name, Collection vals) throws HibernateException {
 		if ( vals == null ) {
 			throw new QueryException( "Collection must be not null!" );
 		}
 
 		if( vals.size() == 0 ) {
 			setParameterList( name, vals, null );
 		}
 		else {
 			setParameterList(name, vals, determineType( name, vals.iterator().next() ) );
 		}
 
 		return this;
 	}
 
 	public Query setParameterList(String name, Object[] vals, Type type) throws HibernateException {
 		return setParameterList( name, Arrays.asList(vals), type );
 	}
 
 	public Query setParameterList(String name, Object[] values) throws HibernateException {
 		return setParameterList( name, Arrays.asList( values ) );
 	}
 
 	public Query setProperties(Map map) throws HibernateException {
 		String[] params = getNamedParameters();
 		for (int i = 0; i < params.length; i++) {
 			String namedParam = params[i];
 				final Object object = map.get(namedParam);
 				if(object==null) {
 					continue;
 				}
 				Class retType = object.getClass();
 				if ( Collection.class.isAssignableFrom( retType ) ) {
 					setParameterList( namedParam, ( Collection ) object );
 				}
 				else if ( retType.isArray() ) {
 					setParameterList( namedParam, ( Object[] ) object );
 				}
 				else {
 					setParameter( namedParam, object, determineType( namedParam, retType ) );
 				}
 
 			
 		}
 		return this;				
 	}
 	
 	public Query setProperties(Object bean) throws HibernateException {
 		Class clazz = bean.getClass();
 		String[] params = getNamedParameters();
 		for (int i = 0; i < params.length; i++) {
 			String namedParam = params[i];
 			try {
 				Getter getter = ReflectHelper.getGetter( clazz, namedParam );
 				Class retType = getter.getReturnType();
 				final Object object = getter.get( bean );
 				if ( Collection.class.isAssignableFrom( retType ) ) {
 					setParameterList( namedParam, ( Collection ) object );
 				}
 				else if ( retType.isArray() ) {
 				 	setParameterList( namedParam, ( Object[] ) object );
 				}
 				else {
 					setParameter( namedParam, object, determineType( namedParam, retType ) );
 				}
 			}
 			catch (PropertyNotFoundException pnfe) {
 				// ignore
 			}
 		}
 		return this;
 	}
 
 	public Query setParameters(Object[] values, Type[] types) {
 		this.values = Arrays.asList(values);
 		this.types = Arrays.asList(types);
 		return this;
 	}
 
 
 	// Execution methods ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public Object uniqueResult() throws HibernateException {
 		return uniqueElement( list() );
 	}
 
 	static Object uniqueElement(List list) throws NonUniqueResultException {
 		int size = list.size();
 		if (size==0) return null;
 		Object first = list.get(0);
 		for ( int i=1; i<size; i++ ) {
 			if ( list.get(i)!=first ) {
 				throw new NonUniqueResultException( list.size() );
 			}
 		}
 		return first;
 	}
 
 	protected RowSelection getRowSelection() {
 		return selection;
 	}
 
 	public Type[] typeArray() {
 		return ArrayHelper.toTypeArray( getTypes() );
 	}
 	
 	public Object[] valueArray() {
 		return getValues().toArray();
 	}
 
 	public QueryParameters getQueryParameters(Map namedParams) {
 		return new QueryParameters(
 				typeArray(),
 				valueArray(),
 				namedParams,
 				getLockOptions(),
 				getRowSelection(),
 				true,
 				isReadOnly(),
 				cacheable,
 				cacheRegion,
 				comment,
 				collectionKey == null ? null : new Serializable[] { collectionKey },
 				optionalObject,
 				optionalEntityName,
 				optionalId,
 				resultTransformer
 		);
 	}
 	
 	protected void before() {
 		if ( flushMode!=null ) {
 			sessionFlushMode = getSession().getFlushMode();
 			getSession().setFlushMode(flushMode);
 		}
 		if ( cacheMode!=null ) {
 			sessionCacheMode = getSession().getCacheMode();
 			getSession().setCacheMode(cacheMode);
 		}
 	}
 	
 	protected void after() {
 		if (sessionFlushMode!=null) {
 			getSession().setFlushMode(sessionFlushMode);
 			sessionFlushMode = null;
 		}
 		if (sessionCacheMode!=null) {
 			getSession().setCacheMode(sessionCacheMode);
 			sessionCacheMode = null;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/AbstractSessionImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/AbstractSessionImpl.java
index 4ed1481626..8ba88d7655 100755
--- a/hibernate-core/src/main/java/org/hibernate/internal/AbstractSessionImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/AbstractSessionImpl.java
@@ -1,401 +1,399 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import java.io.Serializable;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.List;
-import java.util.Map;
 import java.util.UUID;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.MultiTenancyStrategy;
 import org.hibernate.Query;
 import org.hibernate.SQLQuery;
 import org.hibernate.ScrollableResults;
 import org.hibernate.SessionException;
 import org.hibernate.SharedSessionContract;
 import org.hibernate.procedure.ProcedureCall;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.engine.jdbc.LobCreationContext;
 import org.hibernate.engine.jdbc.spi.JdbcConnectionAccess;
 import org.hibernate.engine.query.spi.HQLQueryPlan;
 import org.hibernate.engine.query.spi.NativeSQLQueryPlan;
 import org.hibernate.engine.query.spi.ParameterMetadata;
 import org.hibernate.engine.query.spi.sql.NativeSQLQuerySpecification;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.transaction.spi.TransactionContext;
 import org.hibernate.engine.transaction.spi.TransactionEnvironment;
 import org.hibernate.id.uuid.StandardRandomStrategy;
 import org.hibernate.jdbc.WorkExecutor;
 import org.hibernate.jdbc.WorkExecutorVisitable;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
 import org.hibernate.procedure.ProcedureCallMemento;
 import org.hibernate.procedure.internal.ProcedureCallImpl;
 import org.hibernate.type.Type;
 
 /**
  * Functionality common to stateless and stateful sessions
  *
  * @author Gavin King
  */
 public abstract class AbstractSessionImpl
 		implements Serializable, SharedSessionContract, SessionImplementor, TransactionContext {
 	protected transient SessionFactoryImpl factory;
 	private final String tenantIdentifier;
 	private boolean closed;
 
 	protected AbstractSessionImpl(SessionFactoryImpl factory, String tenantIdentifier) {
 		this.factory = factory;
 		this.tenantIdentifier = tenantIdentifier;
 		if ( MultiTenancyStrategy.NONE == factory.getSettings().getMultiTenancyStrategy() ) {
 			if ( tenantIdentifier != null ) {
 				throw new HibernateException( "SessionFactory was not configured for multi-tenancy" );
 			}
 		}
 		else {
 			if ( tenantIdentifier == null ) {
 				throw new HibernateException( "SessionFactory configured for multi-tenancy, but no tenant identifier specified" );
 			}
 		}
 	}
 
 	public SessionFactoryImplementor getFactory() {
 		return factory;
 	}
 
 	@Override
 	public TransactionEnvironment getTransactionEnvironment() {
 		return factory.getTransactionEnvironment();
 	}
 
 	@Override
 	public <T> T execute(final LobCreationContext.Callback<T> callback) {
 		return getTransactionCoordinator().getJdbcCoordinator().coordinateWork(
 				new WorkExecutorVisitable<T>() {
 					@Override
 					public T accept(WorkExecutor<T> workExecutor, Connection connection) throws SQLException {
 						try {
 							return callback.executeOnConnection( connection );
 						}
 						catch (SQLException e) {
 							throw getFactory().getSQLExceptionHelper().convert(
 									e,
 									"Error creating contextual LOB : " + e.getMessage()
 							);
 						}
 					}
 				}
 		);
 	}
 
 	@Override
 	public boolean isClosed() {
 		return closed;
 	}
 
 	protected void setClosed() {
 		closed = true;
 	}
 
 	protected void errorIfClosed() {
 		if ( closed ) {
 			throw new SessionException( "Session is closed!" );
 		}
 	}
 
 	@Override
 	public Query getNamedQuery(String queryName) throws MappingException {
 		errorIfClosed();
 		NamedQueryDefinition nqd = factory.getNamedQuery( queryName );
 		final Query query;
 		if ( nqd != null ) {
 			String queryString = nqd.getQueryString();
 			query = new QueryImpl(
 					queryString,
 			        nqd.getFlushMode(),
 			        this,
 			        getHQLQueryPlan( queryString, false ).getParameterMetadata()
 			);
 			query.setComment( "named HQL query " + queryName );
 			if ( nqd.getLockOptions() != null ) {
 				query.setLockOptions( nqd.getLockOptions() );
 			}
 		}
 		else {
 			NamedSQLQueryDefinition nsqlqd = factory.getNamedSQLQuery( queryName );
 			if ( nsqlqd==null ) {
 				throw new MappingException( "Named query not known: " + queryName );
 			}
 			ParameterMetadata parameterMetadata = factory.getQueryPlanCache().getSQLParameterMetadata( nsqlqd.getQueryString() );
 			query = new SQLQueryImpl(
 					nsqlqd,
 			        this,
 					parameterMetadata
 			);
 			query.setComment( "named native SQL query " + queryName );
 			nqd = nsqlqd;
 		}
 		initQuery( query, nqd );
 		return query;
 	}
 
 	@Override
 	public Query getNamedSQLQuery(String queryName) throws MappingException {
 		errorIfClosed();
 		NamedSQLQueryDefinition nsqlqd = factory.getNamedSQLQuery( queryName );
 		if ( nsqlqd==null ) {
 			throw new MappingException( "Named SQL query not known: " + queryName );
 		}
 		Query query = new SQLQueryImpl(
 				nsqlqd,
 		        this,
 		        factory.getQueryPlanCache().getSQLParameterMetadata( nsqlqd.getQueryString() )
 		);
 		query.setComment( "named native SQL query " + queryName );
 		initQuery( query, nsqlqd );
 		return query;
 	}
 
-	@SuppressWarnings("UnnecessaryUnboxing")
 	private void initQuery(Query query, NamedQueryDefinition nqd) {
 		// todo : cacheable and readonly should be Boolean rather than boolean...
 		query.setCacheable( nqd.isCacheable() );
 		query.setCacheRegion( nqd.getCacheRegion() );
 		query.setReadOnly( nqd.isReadOnly() );
 
 		if ( nqd.getTimeout() != null ) {
 			query.setTimeout( nqd.getTimeout() );
 		}
 		if ( nqd.getFetchSize() != null ) {
 			query.setFetchSize( nqd.getFetchSize() );
 		}
 		if ( nqd.getCacheMode() != null ) {
 			query.setCacheMode( nqd.getCacheMode() );
 		}
 		if ( nqd.getComment() != null ) {
 			query.setComment( nqd.getComment() );
 		}
 		if ( nqd.getFirstResult() != null ) {
 			query.setFirstResult( nqd.getFirstResult() );
 		}
 		if ( nqd.getMaxResults() != null ) {
 			query.setMaxResults( nqd.getMaxResults() );
 		}
 		if ( nqd.getFlushMode() != null ) {
 			query.setFlushMode( nqd.getFlushMode() );
 		}
 	}
 
 	@Override
 	public Query createQuery(String queryString) {
 		errorIfClosed();
 		final QueryImpl query = new QueryImpl(
 				queryString,
 				this,
 				getHQLQueryPlan( queryString, false ).getParameterMetadata()
 		);
 		query.setComment( queryString );
 		return query;
 	}
 
 	@Override
 	public SQLQuery createSQLQuery(String sql) {
 		errorIfClosed();
 		final SQLQueryImpl query = new SQLQueryImpl(
 				sql,
 				this,
 				factory.getQueryPlanCache().getSQLParameterMetadata( sql )
 		);
 		query.setComment( "dynamic native SQL query" );
 		return query;
 	}
 
 	@Override
 	@SuppressWarnings("UnnecessaryLocalVariable")
 	public ProcedureCall getNamedProcedureCall(String name) {
 		errorIfClosed();
 
 		final ProcedureCallMemento memento = factory.getNamedQueryRepository().getNamedProcedureCallMemento( name );
 		if ( memento == null ) {
 			throw new IllegalArgumentException(
 					"Could not find named stored procedure call with that registration name : " + name
 			);
 		}
 		final ProcedureCall procedureCall = memento.makeProcedureCall( this );
 //		procedureCall.setComment( "Named stored procedure call [" + name + "]" );
 		return procedureCall;
 	}
 
 	@Override
 	@SuppressWarnings("UnnecessaryLocalVariable")
 	public ProcedureCall createStoredProcedureCall(String procedureName) {
 		errorIfClosed();
 		final ProcedureCall procedureCall = new ProcedureCallImpl( this, procedureName );
 //		call.setComment( "Dynamic stored procedure call" );
 		return procedureCall;
 	}
 
 	@Override
 	@SuppressWarnings("UnnecessaryLocalVariable")
 	public ProcedureCall createStoredProcedureCall(String procedureName, Class... resultClasses) {
 		errorIfClosed();
 		final ProcedureCall procedureCall = new ProcedureCallImpl( this, procedureName, resultClasses );
 //		call.setComment( "Dynamic stored procedure call" );
 		return procedureCall;
 	}
 
 	@Override
 	@SuppressWarnings("UnnecessaryLocalVariable")
 	public ProcedureCall createStoredProcedureCall(String procedureName, String... resultSetMappings) {
 		errorIfClosed();
 		final ProcedureCall procedureCall = new ProcedureCallImpl( this, procedureName, resultSetMappings );
 //		call.setComment( "Dynamic stored procedure call" );
 		return procedureCall;
 	}
 
 	protected HQLQueryPlan getHQLQueryPlan(String query, boolean shallow) throws HibernateException {
 		return factory.getQueryPlanCache().getHQLQueryPlan( query, shallow, getEnabledFilters() );
 	}
 
 	protected NativeSQLQueryPlan getNativeSQLQueryPlan(NativeSQLQuerySpecification spec) throws HibernateException {
 		return factory.getQueryPlanCache().getNativeSQLQueryPlan( spec );
 	}
 
 	@Override
 	public List list(NativeSQLQuerySpecification spec, QueryParameters queryParameters)
 			throws HibernateException {
 		return listCustomQuery( getNativeSQLQueryPlan( spec ).getCustomQuery(), queryParameters );
 	}
 
 	@Override
 	public ScrollableResults scroll(NativeSQLQuerySpecification spec, QueryParameters queryParameters)
 			throws HibernateException {
 		return scrollCustomQuery( getNativeSQLQueryPlan( spec ).getCustomQuery(), queryParameters );
 	}
 
 	@Override
 	public String getTenantIdentifier() {
 		return tenantIdentifier;
 	}
 
 	@Override
 	public EntityKey generateEntityKey(Serializable id, EntityPersister persister) {
 		return new EntityKey( id, persister, getTenantIdentifier() );
 	}
 
 	@Override
 	public CacheKey generateCacheKey(Serializable id, Type type, String entityOrRoleName) {
 		return new CacheKey( id, type, entityOrRoleName, getTenantIdentifier(), getFactory() );
 	}
 
 	private transient JdbcConnectionAccess jdbcConnectionAccess;
 
 	@Override
 	public JdbcConnectionAccess getJdbcConnectionAccess() {
 		if ( jdbcConnectionAccess == null ) {
 			if ( MultiTenancyStrategy.NONE == factory.getSettings().getMultiTenancyStrategy() ) {
 				jdbcConnectionAccess = new NonContextualJdbcConnectionAccess(
 						factory.getServiceRegistry().getService( ConnectionProvider.class )
 				);
 			}
 			else {
 				jdbcConnectionAccess = new ContextualJdbcConnectionAccess(
 						factory.getServiceRegistry().getService( MultiTenantConnectionProvider.class )
 				);
 			}
 		}
 		return jdbcConnectionAccess;
 	}
 
 	private UUID sessionIdentifier;
 
 	public UUID getSessionIdentifier() {
 		if ( sessionIdentifier == null ) {
 			sessionIdentifier = StandardRandomStrategy.INSTANCE.generateUUID( this );
 		}
 		return sessionIdentifier;
 	}
 
 	private static class NonContextualJdbcConnectionAccess implements JdbcConnectionAccess, Serializable {
 		private final ConnectionProvider connectionProvider;
 
 		private NonContextualJdbcConnectionAccess(ConnectionProvider connectionProvider) {
 			this.connectionProvider = connectionProvider;
 		}
 
 		@Override
 		public Connection obtainConnection() throws SQLException {
 			return connectionProvider.getConnection();
 		}
 
 		@Override
 		public void releaseConnection(Connection connection) throws SQLException {
 			connectionProvider.closeConnection( connection );
 		}
 
 		@Override
 		public boolean supportsAggressiveRelease() {
 			return connectionProvider.supportsAggressiveRelease();
 		}
 	}
 
 	private class ContextualJdbcConnectionAccess implements JdbcConnectionAccess, Serializable {
 		private final MultiTenantConnectionProvider connectionProvider;
 
 		private ContextualJdbcConnectionAccess(MultiTenantConnectionProvider connectionProvider) {
 			this.connectionProvider = connectionProvider;
 		}
 
 		@Override
 		public Connection obtainConnection() throws SQLException {
 			if ( tenantIdentifier == null ) {
 				throw new HibernateException( "Tenant identifier required!" );
 			}
 			return connectionProvider.getConnection( tenantIdentifier );
 		}
 
 		@Override
 		public void releaseConnection(Connection connection) throws SQLException {
 			if ( tenantIdentifier == null ) {
 				throw new HibernateException( "Tenant identifier required!" );
 			}
 			connectionProvider.releaseConnection( tenantIdentifier, connection );
 		}
 
 		@Override
 		public boolean supportsAggressiveRelease() {
 			return connectionProvider.supportsAggressiveRelease();
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/FilterConfiguration.java b/hibernate-core/src/main/java/org/hibernate/internal/FilterConfiguration.java
index f5bdbed323..633a2113b5 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/FilterConfiguration.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/FilterConfiguration.java
@@ -1,95 +1,95 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.persister.entity.Joinable;
 
 /**
  *
  * @author Rob Worsnop
  */
 public class FilterConfiguration {
 	private final String name;
 	private final String condition;
 	private final boolean autoAliasInjection;
 	private final Map<String, String> aliasTableMap;
 	private final Map<String, String> aliasEntityMap;
 	private final PersistentClass persistentClass;
 	
 	public FilterConfiguration(String name, String condition, boolean autoAliasInjection, Map<String, String> aliasTableMap, Map<String, String> aliasEntityMap, PersistentClass persistentClass) {
 		this.name = name;
 		this.condition = condition;
 		this.autoAliasInjection = autoAliasInjection;
 		this.aliasTableMap = aliasTableMap;
 		this.aliasEntityMap = aliasEntityMap;
 		this.persistentClass = persistentClass;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public String getCondition() {
 		return condition;
 	}
 
 	public boolean useAutoAliasInjection() {
 		return autoAliasInjection;
 	}
 
 	public Map<String, String> getAliasTableMap(SessionFactoryImplementor factory) {
 		Map<String,String> mergedAliasTableMap = mergeAliasMaps(factory);
 		if (!mergedAliasTableMap.isEmpty()){
 			return mergedAliasTableMap;
 		} else if (persistentClass != null){
 			String table = persistentClass.getTable().getQualifiedName(factory.getDialect(), 
 					factory.getSettings().getDefaultCatalogName(),
 					factory.getSettings().getDefaultSchemaName());
 			return Collections.singletonMap(null, table);
 		} else{
 			return Collections.emptyMap();
 		}
 	}
 	
 	private Map<String,String> mergeAliasMaps(SessionFactoryImplementor factory){
 		Map<String,String> ret = new HashMap<String, String>();
 		if (aliasTableMap != null){
 			ret.putAll(aliasTableMap);
 		}
 		if (aliasEntityMap != null){
 			for (Map.Entry<String, String> entry : aliasEntityMap.entrySet()){
 				ret.put(entry.getKey(), 
 						Joinable.class.cast(factory.getEntityPersister(entry.getValue())).getTableName());
 			}
 		}
 		return ret;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/NonFlushedChangesImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/NonFlushedChangesImpl.java
index e811077118..34b8bd886e 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/NonFlushedChangesImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/NonFlushedChangesImpl.java
@@ -1,75 +1,75 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.engine.internal.StatefulPersistenceContext;
 import org.hibernate.engine.spi.ActionQueue;
 import org.hibernate.engine.spi.NonFlushedChanges;
 import org.hibernate.event.spi.EventSource;
 
 public final class NonFlushedChangesImpl implements NonFlushedChanges, Serializable {
     private static final Logger LOG = Logger.getLogger( NonFlushedChangesImpl.class.getName() );
 
 	private transient ActionQueue actionQueue;
 	private transient StatefulPersistenceContext persistenceContext;
 
 	public NonFlushedChangesImpl(EventSource session) {
 		this.actionQueue = session.getActionQueue();
 		this.persistenceContext = ( StatefulPersistenceContext ) session.getPersistenceContext();
 	}
 
 	/* package-protected */
 	ActionQueue getActionQueue() {
 		return actionQueue;
 	}
 
 	/* package-protected */
 	StatefulPersistenceContext getPersistenceContext() {
 		return persistenceContext;
 	}
 
 	public void clear() {
 	}
 
 	private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
 		LOG.trace( "Deserializing NonFlushedChangesImpl" );
 		ois.defaultReadObject();
 		persistenceContext = StatefulPersistenceContext.deserialize( ois, null );
 		actionQueue = ActionQueue.deserialize( ois, null );
 	}
 
 	private void writeObject(ObjectOutputStream oos) throws IOException {
 		LOG.trace( "Serializing NonFlushedChangesImpl" );
 		oos.defaultWriteObject();
 		persistenceContext.serialize( oos );
 		actionQueue.serialize( oos );
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/util/collections/BoundedConcurrentHashMap.java b/hibernate-core/src/main/java/org/hibernate/internal/util/collections/BoundedConcurrentHashMap.java
index f8c39337b6..cc2d847041 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/util/collections/BoundedConcurrentHashMap.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/util/collections/BoundedConcurrentHashMap.java
@@ -1464,1001 +1464,1001 @@ public class BoundedConcurrentHashMap<K, V> extends AbstractMap<K, V>
 
 			HashEntry<K,V>[] newTable = HashEntry.newArray(oldCapacity<<1);
 			threshold = (int)(newTable.length * loadFactor);
 			int sizeMask = newTable.length - 1;
 			for (int i = 0; i < oldCapacity ; i++) {
 				// We need to guarantee that any existing reads of old Map can
 				//  proceed. So we cannot yet null out each bin.
 				HashEntry<K,V> e = oldTable[i];
 
 				if (e != null) {
 					HashEntry<K,V> next = e.next;
 					int idx = e.hash & sizeMask;
 
 					//  Single node on list
 					if (next == null) {
 						newTable[idx] = e;
 					} else {
 						// Reuse trailing consecutive sequence at same slot
 						HashEntry<K,V> lastRun = e;
 						int lastIdx = idx;
 						for (HashEntry<K,V> last = next;
 							 last != null;
 							 last = last.next) {
 							int k = last.hash & sizeMask;
 							if (k != lastIdx) {
 								lastIdx = k;
 								lastRun = last;
 							}
 						}
 						newTable[lastIdx] = lastRun;
 
 						// Clone all remaining nodes
 						for (HashEntry<K,V> p = e; p != lastRun; p = p.next) {
 							int k = p.hash & sizeMask;
 							HashEntry<K,V> n = newTable[k];
 							newTable[k] = eviction.createNewEntry(p.key, p.hash, n, p.value);
 						}
 					}
 				}
 			}
 			table = newTable;
 		}
 
 		/**
 		 * Remove; match on key only if value null, else match both.
 		 */
 		V remove(Object key, int hash, Object value) {
 			lock();
 			try {
 				int c = count - 1;
 				HashEntry<K, V>[] tab = table;
 				int index = hash & tab.length - 1;
 				HashEntry<K, V> first = tab[index];
 				HashEntry<K, V> e = first;
 				while (e != null && (e.hash != hash || !key.equals(e.key))) {
 					e = e.next;
 				}
 
 				V oldValue = null;
 				if (e != null) {
 					V v = e.value;
 					if (value == null || value.equals(v)) {
 						oldValue = v;
 						// All entries following removed node can stay
 						// in list, but all preceding ones need to be
 						// cloned.
 						++modCount;
 
 						// e was removed
 						eviction.onEntryRemove(e);
 
 						HashEntry<K, V> newFirst = e.next;
 						for (HashEntry<K, V> p = first; p != e; p = p.next) {
 							// TODO A remove operation makes the map behave like all the other keys in the bucket were just added???
 							// allow p to be GC-ed
 							eviction.onEntryRemove(p);
 							newFirst = eviction.createNewEntry(p.key, p.hash, newFirst, p.value);
 							// and notify eviction algorithm about new hash entries
 							eviction.onEntryMiss(newFirst);
 						}
 
 						tab[index] = newFirst;
 						count = c; // write-volatile
 					}
 				}
 				return oldValue;
 			} finally {
 				unlock();
 			}
 		}
 
 		void clear() {
 			if (count != 0) {
 				lock();
 				try {
 					HashEntry<K, V>[] tab = table;
 					for (int i = 0; i < tab.length; i++) {
 						tab[i] = null;
 					}
 					++modCount;
 					eviction.clear();
 					count = 0; // write-volatile
 				} finally {
 					unlock();
 				}
 			}
 		}
 
 		private Set<HashEntry<K, V>> attemptEviction(boolean lockedAlready) {
 			Set<HashEntry<K, V>> evicted = null;
 			boolean obtainedLock = lockedAlready || tryLock();
 			if (!obtainedLock && eviction.thresholdExpired()) {
 				lock();
 				obtainedLock = true;
 			}
 			if (obtainedLock) {
 				try {
 					if (eviction.thresholdExpired()) {
 						evicted = eviction.execute();
 					}
 				} finally {
 					if (!lockedAlready) {
 						unlock();
 					}
 				}
 			}
 			return evicted;
 		}
 
 		private void notifyEvictionListener(Set<HashEntry<K, V>> evicted) {
 			// piggyback listener invocation on callers thread outside lock
 			if (evicted != null) {
 				Map<K, V> evictedCopy;
 				if (evicted.size() == 1) {
 					HashEntry<K, V> evictedEntry = evicted.iterator().next();
 					evictedCopy = singletonMap(evictedEntry.key, evictedEntry.value);
 				} else {
 					evictedCopy = new HashMap<K, V>(evicted.size());
 					for (HashEntry<K, V> he : evicted) {
 						evictedCopy.put(he.key, he.value);
 					}
 					evictedCopy = unmodifiableMap(evictedCopy);
 				}
 				evictionListener.onEntryEviction(evictedCopy);
 			}
 		}
 	}
 
 
 	/* ---------------- Public operations -------------- */
 
 
 	/**
 	 * Creates a new, empty map with the specified maximum capacity, load factor and concurrency
 	 * level.
 	 *
 	 * @param capacity
 	 *            is the upper bound capacity for the number of elements in this map
 	 *
 	 * @param concurrencyLevel
 	 *            the estimated number of concurrently updating threads. The implementation performs
 	 *            internal sizing to try to accommodate this many threads.
 	 *
 	 * @param evictionStrategy
 	 *            the algorithm used to evict elements from this map
 	 *
 	 * @param evictionListener
 	 *            the evicton listener callback to be notified about evicted elements
 	 *
 	 * @throws IllegalArgumentException
 	 *             if the initial capacity is negative or the load factor or concurrencyLevel are
 	 *             nonpositive.
 	 */
 	public BoundedConcurrentHashMap(int capacity, int concurrencyLevel,
 									Eviction evictionStrategy, EvictionListener<K, V> evictionListener) {
 		if (capacity < 0 || concurrencyLevel <= 0) {
 			throw new IllegalArgumentException();
 		}
 
 		concurrencyLevel = Math.min(capacity / 2, concurrencyLevel); // concurrencyLevel cannot be > capacity/2
 		concurrencyLevel = Math.max(concurrencyLevel, 1); // concurrencyLevel cannot be less than 1
 
 		// minimum two elements per segment
 		if (capacity < concurrencyLevel * 2 && capacity != 1) {
 			throw new IllegalArgumentException("Maximum capacity has to be at least twice the concurrencyLevel");
 		}
 
 		if (evictionStrategy == null || evictionListener == null) {
 			throw new IllegalArgumentException();
 		}
 
 		if (concurrencyLevel > MAX_SEGMENTS) {
 			concurrencyLevel = MAX_SEGMENTS;
 		}
 
 		// Find power-of-two sizes best matching arguments
 		int sshift = 0;
 		int ssize = 1;
 		while (ssize < concurrencyLevel) {
 			++sshift;
 			ssize <<= 1;
 		}
 		segmentShift = 32 - sshift;
 		segmentMask = ssize - 1;
 		this.segments = Segment.newArray(ssize);
 
 		if (capacity > MAXIMUM_CAPACITY) {
 			capacity = MAXIMUM_CAPACITY;
 		}
 		int c = capacity / ssize;
 		int cap = 1;
 		while (cap < c) {
 			cap <<= 1;
 		}
 
 		for (int i = 0; i < this.segments.length; ++i) {
 			this.segments[i] = new Segment<K, V>(cap, c, DEFAULT_LOAD_FACTOR, evictionStrategy, evictionListener);
 		}
 	}
 
 	/**
 	 * Creates a new, empty map with the specified maximum capacity, load factor, concurrency
 	 * level and LRU eviction policy.
 	 *
 	 * @param capacity
 	 *            is the upper bound capacity for the number of elements in this map
 	 *
 	 * @param concurrencyLevel
 	 *            the estimated number of concurrently updating threads. The implementation performs
 	 *            internal sizing to try to accommodate this many threads.
 	 *
 	 * @throws IllegalArgumentException
 	 *             if the initial capacity is negative or the load factor or concurrencyLevel are
 	 *             nonpositive.
 	 */
 	public BoundedConcurrentHashMap(int capacity, int concurrencyLevel) {
 		this(capacity, concurrencyLevel, Eviction.LRU);
 	}
 
 	/**
 	 * Creates a new, empty map with the specified maximum capacity, load factor, concurrency
 	 * level and eviction strategy.
 	 *
 	 * @param capacity
 	 *            is the upper bound capacity for the number of elements in this map
 	 *
 	 * @param concurrencyLevel
 	 *            the estimated number of concurrently updating threads. The implementation performs
 	 *            internal sizing to try to accommodate this many threads.
 	 *
 	 * @param evictionStrategy
 	 *            the algorithm used to evict elements from this map
 	 *
 	 * @throws IllegalArgumentException
 	 *             if the initial capacity is negative or the load factor or concurrencyLevel are
 	 *             nonpositive.
 	 */
 	public BoundedConcurrentHashMap(int capacity, int concurrencyLevel, Eviction evictionStrategy) {
 		this(capacity, concurrencyLevel, evictionStrategy, new NullEvictionListener<K, V>());
 	}
 
 	/**
 	 * Creates a new, empty map with the specified maximum capacity, default concurrency
 	 * level and LRU eviction policy.
 	 *
 	 *  @param capacity
 	 *            is the upper bound capacity for the number of elements in this map
 	 *
 	 *
 	 * @throws IllegalArgumentException if the initial capacity of
 	 * elements is negative or the load factor is nonpositive
 	 *
 	 * @since 1.6
 	 */
 	public BoundedConcurrentHashMap(int capacity) {
 		this(capacity, DEFAULT_CONCURRENCY_LEVEL);
 	}
 
 	/**
 	 * Creates a new, empty map with the default maximum capacity
 	 */
 	public BoundedConcurrentHashMap() {
 		this(DEFAULT_MAXIMUM_CAPACITY, DEFAULT_CONCURRENCY_LEVEL);
 	}
 
 	/**
 	 * Returns <tt>true</tt> if this map contains no key-value mappings.
 	 *
 	 * @return <tt>true</tt> if this map contains no key-value mappings
 	 */
 	@Override
 	public boolean isEmpty() {
 		final Segment<K,V>[] segments = this.segments;
 		/*
 			   * We keep track of per-segment modCounts to avoid ABA
 			   * problems in which an element in one segment was added and
 			   * in another removed during traversal, in which case the
 			   * table was never actually empty at any point. Note the
 			   * similar use of modCounts in the size() and containsValue()
 			   * methods, which are the only other methods also susceptible
 			   * to ABA problems.
 			   */
 		int[] mc = new int[segments.length];
 		int mcsum = 0;
 		for (int i = 0; i < segments.length; ++i) {
 			if (segments[i].count != 0) {
 				return false;
 			} else {
 				mcsum += mc[i] = segments[i].modCount;
 			}
 		}
 		// If mcsum happens to be zero, then we know we got a snapshot
 		// before any modifications at all were made.  This is
 		// probably common enough to bother tracking.
 		if (mcsum != 0) {
 			for (int i = 0; i < segments.length; ++i) {
 				if (segments[i].count != 0 || mc[i] != segments[i].modCount) {
 					return false;
 				}
 			}
 		}
 		return true;
 	}
 
 	/**
 	 * Returns the number of key-value mappings in this map.  If the
 	 * map contains more than <tt>Integer.MAX_VALUE</tt> elements, returns
 	 * <tt>Integer.MAX_VALUE</tt>.
 	 *
 	 * @return the number of key-value mappings in this map
 	 */
 	@Override
 	public int size() {
 		final Segment<K,V>[] segments = this.segments;
 		long sum = 0;
 		long check = 0;
 		int[] mc = new int[segments.length];
 		// Try a few times to get accurate count. On failure due to
 		// continuous async changes in table, resort to locking.
 		for (int k = 0; k < RETRIES_BEFORE_LOCK; ++ k) {
 			check = 0;
 			sum = 0;
 			int mcsum = 0;
 			for (int i = 0; i < segments.length; ++ i) {
 				sum += segments[i].count;
 				mcsum += mc[i] = segments[i].modCount;
 			}
 			if (mcsum != 0) {
 				for (int i = 0; i < segments.length; ++ i) {
 					check += segments[i].count;
 					if (mc[i] != segments[i].modCount) {
 						check = -1; // force retry
 						break;
 					}
 				}
 			}
 			if (check == sum) {
 				break;
 			}
 		}
 		if (check != sum) { // Resort to locking all segments
 			sum = 0;
 			for (int i = 0; i < segments.length; ++ i) {
 				segments[i].lock();
 			}
 			try {
 				for (int i = 0; i < segments.length; ++ i) {
 					sum += segments[i].count;
 				}
 			} finally {
 				for (int i = 0; i < segments.length; ++ i) {
 					segments[i].unlock();
 				}
 			}
 		}
 		if (sum > Integer.MAX_VALUE) {
 			return Integer.MAX_VALUE;
 		} else {
 			return (int) sum;
 		}
 	}
 
 	/**
 	 * Returns the value to which the specified key is mapped,
 	 * or {@code null} if this map contains no mapping for the key.
 	 *
 	 * <p>More formally, if this map contains a mapping from a key
 	 * {@code k} to a value {@code v} such that {@code key.equals(k)},
 	 * then this method returns {@code v}; otherwise it returns
 	 * {@code null}.  (There can be at most one such mapping.)
 	 *
 	 * @throws NullPointerException if the specified key is null
 	 */
 	@Override
 	public V get(Object key) {
 		int hash = hash(key.hashCode());
 		return segmentFor(hash).get(key, hash);
 	}
 
 	/**
 	 * Tests if the specified object is a key in this table.
 	 *
 	 * @param  key   possible key
 	 * @return <tt>true</tt> if and only if the specified object
 	 *         is a key in this table, as determined by the
 	 *         <tt>equals</tt> method; <tt>false</tt> otherwise.
 	 * @throws NullPointerException if the specified key is null
 	 */
 	@Override
 	public boolean containsKey(Object key) {
 		int hash = hash(key.hashCode());
 		return segmentFor(hash).containsKey(key, hash);
 	}
 
 	/**
 	 * Returns <tt>true</tt> if this map maps one or more keys to the
 	 * specified value. Note: This method requires a full internal
 	 * traversal of the hash table, and so is much slower than
 	 * method <tt>containsKey</tt>.
 	 *
 	 * @param value value whose presence in this map is to be tested
 	 * @return <tt>true</tt> if this map maps one or more keys to the
 	 *         specified value
 	 * @throws NullPointerException if the specified value is null
 	 */
 	@Override
 	public boolean containsValue(Object value) {
 		if (value == null) {
 			throw new NullPointerException();
 		}
 
 		// See explanation of modCount use above
 
 		final Segment<K, V>[] segments = this.segments;
 		int[] mc = new int[segments.length];
 
 		// Try a few times without locking
 		for (int k = 0; k < RETRIES_BEFORE_LOCK; ++ k) {
 			int mcsum = 0;
 			for (int i = 0; i < segments.length; ++ i) {
 				@SuppressWarnings("unused")
 				int c = segments[i].count; // read-volatile
 				mcsum += mc[i] = segments[i].modCount;
 				if (segments[i].containsValue(value)) {
 					return true;
 				}
 			}
 			boolean cleanSweep = true;
 			if (mcsum != 0) {
 				for (int i = 0; i < segments.length; ++ i) {
 					@SuppressWarnings("unused")
 					int c = segments[i].count; // read-volatile
 					if (mc[i] != segments[i].modCount) {
 						cleanSweep = false;
 						break;
 					}
 				}
 			}
 			if (cleanSweep) {
 				return false;
 			}
 		}
 		// Resort to locking all segments
 		for (int i = 0; i < segments.length; ++ i) {
 			segments[i].lock();
 		}
 		boolean found = false;
 		try {
 			for (int i = 0; i < segments.length; ++ i) {
 				if (segments[i].containsValue(value)) {
 					found = true;
 					break;
 				}
 			}
 		} finally {
 			for (int i = 0; i < segments.length; ++ i) {
 				segments[i].unlock();
 			}
 		}
 		return found;
 	}
 
 	/**
 	 * Legacy method testing if some key maps into the specified value
 	 * in this table.  This method is identical in functionality to
 	 * {@link #containsValue}, and exists solely to ensure
 	 * full compatibility with class {@link Hashtable},
 	 * which supported this method prior to introduction of the
 	 * Java Collections framework.
 
 	 * @param  value a value to search for
 	 * @return <tt>true</tt> if and only if some key maps to the
 	 *         <tt>value</tt> argument in this table as
 	 *         determined by the <tt>equals</tt> method;
 	 *         <tt>false</tt> otherwise
 	 * @throws NullPointerException if the specified value is null
 	 */
 	public boolean contains(Object value) {
 		return containsValue(value);
 	}
 
 	/**
 	 * Maps the specified key to the specified value in this table.
 	 * Neither the key nor the value can be null.
 	 *
 	 * <p> The value can be retrieved by calling the <tt>get</tt> method
 	 * with a key that is equal to the original key.
 	 *
 	 * @param key key with which the specified value is to be associated
 	 * @param value value to be associated with the specified key
 	 * @return the previous value associated with <tt>key</tt>, or
 	 *         <tt>null</tt> if there was no mapping for <tt>key</tt>
 	 * @throws NullPointerException if the specified key or value is null
 	 */
 	@Override
 	public V put(K key, V value) {
 		if (value == null) {
 			throw new NullPointerException();
 		}
 		int hash = hash(key.hashCode());
 		return segmentFor(hash).put(key, hash, value, false);
 	}
 
 	/**
 	 * {@inheritDoc}
 	 *
 	 * @return the previous value associated with the specified key,
 	 *         or <tt>null</tt> if there was no mapping for the key
 	 * @throws NullPointerException if the specified key or value is null
 	 */
 	@Override
 	public V putIfAbsent(K key, V value) {
 		if (value == null) {
 			throw new NullPointerException();
 		}
 		int hash = hash(key.hashCode());
 		return segmentFor(hash).put(key, hash, value, true);
 	}
 
 	/**
 	 * Copies all of the mappings from the specified map to this one.
 	 * These mappings replace any mappings that this map had for any of the
 	 * keys currently in the specified map.
 	 *
 	 * @param m mappings to be stored in this map
 	 */
 	@Override
 	public void putAll(Map<? extends K, ? extends V> m) {
 		for (Map.Entry<? extends K, ? extends V> e: m.entrySet()) {
 			put(e.getKey(), e.getValue());
 		}
 	}
 
 	/**
 	 * Removes the key (and its corresponding value) from this map.
 	 * This method does nothing if the key is not in the map.
 	 *
 	 * @param  key the key that needs to be removed
 	 * @return the previous value associated with <tt>key</tt>, or
 	 *         <tt>null</tt> if there was no mapping for <tt>key</tt>
 	 * @throws NullPointerException if the specified key is null
 	 */
 	@Override
 	public V remove(Object key) {
 		int hash = hash(key.hashCode());
 		return segmentFor(hash).remove(key, hash, null);
 	}
 
 	/**
 	 * {@inheritDoc}
 	 *
 	 * @throws NullPointerException if the specified key is null
 	 */
 	@Override
 	public boolean remove(Object key, Object value) {
 		int hash = hash(key.hashCode());
 		if (value == null) {
 			return false;
 		}
 		return segmentFor(hash).remove(key, hash, value) != null;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 *
 	 * @throws NullPointerException if any of the arguments are null
 	 */
 	@Override
 	public boolean replace(K key, V oldValue, V newValue) {
 		if (oldValue == null || newValue == null) {
 			throw new NullPointerException();
 		}
 		int hash = hash(key.hashCode());
 		return segmentFor(hash).replace(key, hash, oldValue, newValue);
 	}
 
 	/**
 	 * {@inheritDoc}
 	 *
 	 * @return the previous value associated with the specified key,
 	 *         or <tt>null</tt> if there was no mapping for the key
 	 * @throws NullPointerException if the specified key or value is null
 	 */
 	@Override
 	public V replace(K key, V value) {
 		if (value == null) {
 			throw new NullPointerException();
 		}
 		int hash = hash(key.hashCode());
 		return segmentFor(hash).replace(key, hash, value);
 	}
 
 	/**
 	 * Removes all of the mappings from this map.
 	 */
 	@Override
 	public void clear() {
 		for (int i = 0; i < segments.length; ++ i) {
 			segments[i].clear();
 		}
 	}
 
 	/**
 	 * Returns a {@link Set} view of the keys contained in this map.
 	 * The set is backed by the map, so changes to the map are
 	 * reflected in the set, and vice-versa.  The set supports element
 	 * removal, which removes the corresponding mapping from this map,
 	 * via the <tt>Iterator.remove</tt>, <tt>Set.remove</tt>,
 	 * <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt>
 	 * operations.  It does not support the <tt>add</tt> or
 	 * <tt>addAll</tt> operations.
 	 *
 	 * <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator
 	 * that will never throw {@link ConcurrentModificationException},
 	 * and guarantees to traverse elements as they existed upon
 	 * construction of the iterator, and may (but is not guaranteed to)
 	 * reflect any modifications subsequent to construction.
 	 */
 	@Override
 	public Set<K> keySet() {
 		Set<K> ks = keySet;
 		return ks != null? ks : (keySet = new KeySet());
 	}
 
 	/**
 	 * Returns a {@link Collection} view of the values contained in this map.
 	 * The collection is backed by the map, so changes to the map are
 	 * reflected in the collection, and vice-versa.  The collection
 	 * supports element removal, which removes the corresponding
 	 * mapping from this map, via the <tt>Iterator.remove</tt>,
 	 * <tt>Collection.remove</tt>, <tt>removeAll</tt>,
 	 * <tt>retainAll</tt>, and <tt>clear</tt> operations.  It does not
 	 * support the <tt>add</tt> or <tt>addAll</tt> operations.
 	 *
 	 * <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator
 	 * that will never throw {@link ConcurrentModificationException},
 	 * and guarantees to traverse elements as they existed upon
 	 * construction of the iterator, and may (but is not guaranteed to)
 	 * reflect any modifications subsequent to construction.
 	 */
 	@Override
 	public Collection<V> values() {
 		Collection<V> vs = values;
 		return vs != null? vs : (values = new Values());
 	}
 
 	/**
 	 * Returns a {@link Set} view of the mappings contained in this map.
 	 * The set is backed by the map, so changes to the map are
 	 * reflected in the set, and vice-versa.  The set supports element
 	 * removal, which removes the corresponding mapping from the map,
 	 * via the <tt>Iterator.remove</tt>, <tt>Set.remove</tt>,
 	 * <tt>removeAll</tt>, <tt>retainAll</tt>, and <tt>clear</tt>
 	 * operations.  It does not support the <tt>add</tt> or
 	 * <tt>addAll</tt> operations.
 	 *
 	 * <p>The view's <tt>iterator</tt> is a "weakly consistent" iterator
 	 * that will never throw {@link ConcurrentModificationException},
 	 * and guarantees to traverse elements as they existed upon
 	 * construction of the iterator, and may (but is not guaranteed to)
 	 * reflect any modifications subsequent to construction.
 	 */
 	@Override
 	public Set<Map.Entry<K, V>> entrySet() {
 		Set<Map.Entry<K, V>> es = entrySet;
 		return es != null? es : (entrySet = new EntrySet());
 	}
 
 	/**
 	 * Returns an enumeration of the keys in this table.
 	 *
 	 * @return an enumeration of the keys in this table
 	 * @see #keySet()
 	 */
 	public Enumeration<K> keys() {
 		return new KeyIterator();
 	}
 
 	/**
 	 * Returns an enumeration of the values in this table.
 	 *
 	 * @return an enumeration of the values in this table
 	 * @see #values()
 	 */
 	public Enumeration<V> elements() {
 		return new ValueIterator();
 	}
 
 	/* ---------------- Iterator Support -------------- */
 
 	abstract class HashIterator {
 		int nextSegmentIndex;
 
 		int nextTableIndex;
 
 		HashEntry<K, V>[] currentTable;
 
 		HashEntry<K, V> nextEntry;
 
 		HashEntry<K, V> lastReturned;
 
 		HashIterator() {
 			nextSegmentIndex = segments.length - 1;
 			nextTableIndex = -1;
 			advance();
 		}
 
 		public boolean hasMoreElements() {
 			return hasNext();
 		}
 
 		final void advance() {
 			if (nextEntry != null && (nextEntry = nextEntry.next) != null) {
 				return;
 			}
 
 			while (nextTableIndex >= 0) {
 				if ((nextEntry = currentTable[nextTableIndex --]) != null) {
 					return;
 				}
 			}
 
 			while (nextSegmentIndex >= 0) {
 				Segment<K, V> seg = segments[nextSegmentIndex --];
 				if (seg.count != 0) {
 					currentTable = seg.table;
 					for (int j = currentTable.length - 1; j >= 0; -- j) {
 						if ((nextEntry = currentTable[j]) != null) {
 							nextTableIndex = j - 1;
 							return;
 						}
 					}
 				}
 			}
 		}
 
 		public boolean hasNext() {
 			return nextEntry != null;
 		}
 
 		HashEntry<K, V> nextEntry() {
 			if (nextEntry == null) {
 				throw new NoSuchElementException();
 			}
 			lastReturned = nextEntry;
 			advance();
 			return lastReturned;
 		}
 
 		public void remove() {
 			if (lastReturned == null) {
 				throw new IllegalStateException();
 			}
 			BoundedConcurrentHashMap.this.remove(lastReturned.key);
 			lastReturned = null;
 		}
 	}
 
 	final class KeyIterator extends HashIterator implements Iterator<K>, Enumeration<K> {
 		@Override
 		public K next() {
 			return super.nextEntry().key;
 		}
 
 		@Override
 		public K nextElement() {
 			return super.nextEntry().key;
 		}
 	}
 
 	final class ValueIterator extends HashIterator implements Iterator<V>, Enumeration<V> {
 		@Override
 		public V next() {
 			return super.nextEntry().value;
 		}
 
 		@Override
 		public V nextElement() {
 			return super.nextEntry().value;
 		}
 	}
 
 	/**
 	 * Custom Entry class used by EntryIterator.next(), that relays
 	 * setValue changes to the underlying map.
 	 */
 	final class WriteThroughEntry extends AbstractMap.SimpleEntry<K, V> {
 
 		private static final long serialVersionUID = -7041346694785573824L;
 
 		WriteThroughEntry(K k, V v) {
 			super(k, v);
 		}
 
 		/**
 		 * Set our entry's value and write through to the map. The
 		 * value to return is somewhat arbitrary here. Since a
 		 * WriteThroughEntry does not necessarily track asynchronous
 		 * changes, the most recent "previous" value could be
 		 * different from what we return (or could even have been
 		 * removed in which case the put will re-establish). We do not
 		 * and cannot guarantee more.
 		 */
 		@Override
 		public V setValue(V value) {
 			if (value == null) {
 				throw new NullPointerException();
 			}
 			V v = super.setValue(value);
 			BoundedConcurrentHashMap.this.put(getKey(), value);
 			return v;
 		}
 	}
 
 	final class EntryIterator extends HashIterator implements Iterator<Entry<K, V>> {
 		@Override
 		public Map.Entry<K, V> next() {
 			HashEntry<K, V> e = super.nextEntry();
 			return new WriteThroughEntry(e.key, e.value);
 		}
 	}
 
 	final class KeySet extends AbstractSet<K> {
 		@Override
 		public Iterator<K> iterator() {
 			return new KeyIterator();
 		}
 
 		@Override
 		public int size() {
 			return BoundedConcurrentHashMap.this.size();
 		}
 
 		@Override
 		public boolean isEmpty() {
 			return BoundedConcurrentHashMap.this.isEmpty();
 		}
 
 		@Override
 		public boolean contains(Object o) {
 			return BoundedConcurrentHashMap.this.containsKey(o);
 		}
 
 		@Override
 		public boolean remove(Object o) {
 			return BoundedConcurrentHashMap.this.remove(o) != null;
 		}
 
 		@Override
 		public void clear() {
 			BoundedConcurrentHashMap.this.clear();
 		}
 	}
 
 	final class Values extends AbstractCollection<V> {
 		@Override
 		public Iterator<V> iterator() {
 			return new ValueIterator();
 		}
 
 		@Override
 		public int size() {
 			return BoundedConcurrentHashMap.this.size();
 		}
 
 		@Override
 		public boolean isEmpty() {
 			return BoundedConcurrentHashMap.this.isEmpty();
 		}
 
 		@Override
 		public boolean contains(Object o) {
 			return BoundedConcurrentHashMap.this.containsValue(o);
 		}
 
 		@Override
 		public void clear() {
 			BoundedConcurrentHashMap.this.clear();
 		}
 	}
 
 	final class EntrySet extends AbstractSet<Map.Entry<K, V>> {
 		@Override
 		public Iterator<Map.Entry<K, V>> iterator() {
 			return new EntryIterator();
 		}
 
 		@Override
 		public boolean contains(Object o) {
 			if (!(o instanceof Map.Entry)) {
 				return false;
 			}
 			Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
 			V v = BoundedConcurrentHashMap.this.get(e.getKey());
 			return v != null && v.equals(e.getValue());
 		}
 
 		@Override
 		public boolean remove(Object o) {
 			if (!(o instanceof Map.Entry)) {
 				return false;
 			}
 			Map.Entry<?, ?> e = (Map.Entry<?, ?>) o;
 			return BoundedConcurrentHashMap.this.remove(e.getKey(), e.getValue());
 		}
 
 		@Override
 		public int size() {
 			return BoundedConcurrentHashMap.this.size();
 		}
 
 		@Override
 		public boolean isEmpty() {
 			return BoundedConcurrentHashMap.this.isEmpty();
 		}
 
 		@Override
 		public void clear() {
 			BoundedConcurrentHashMap.this.clear();
 		}
 	}
 
 	/* ---------------- Serialization Support -------------- */
 
 	/**
 	 * Save the state of the <tt>ConcurrentHashMap</tt> instance to a
 	 * stream (i.e., serialize it).
 	 * @param s the stream
 	 * @serialData
 	 * the key (Object) and value (Object)
 	 * for each key-value mapping, followed by a null pair.
 	 * The key-value mappings are emitted in no particular order.
 	 */
 	private void writeObject(java.io.ObjectOutputStream s) throws IOException {
 		s.defaultWriteObject();
 
 		for (int k = 0; k < segments.length; ++ k) {
 			Segment<K, V> seg = segments[k];
 			seg.lock();
 			try {
 				HashEntry<K, V>[] tab = seg.table;
 				for (int i = 0; i < tab.length; ++ i) {
 					for (HashEntry<K, V> e = tab[i]; e != null; e = e.next) {
 						s.writeObject(e.key);
 						s.writeObject(e.value);
 					}
 				}
 			} finally {
 				seg.unlock();
 			}
 		}
 		s.writeObject(null);
 		s.writeObject(null);
 	}
 
 	/**
 	 * Reconstitute the <tt>ConcurrentHashMap</tt> instance from a
 	 * stream (i.e., deserialize it).
 	 * @param s the stream
 	 */
 	@SuppressWarnings("unchecked")
 	private void readObject(java.io.ObjectInputStream s) throws IOException,
 			ClassNotFoundException {
 		s.defaultReadObject();
 
 		// Initialize each segment to be minimally sized, and let grow.
 		for (int i = 0; i < segments.length; ++ i) {
 			segments[i].setTable(new HashEntry[1]);
 		}
 
 		// Read the keys and values, and put the mappings in the table
 		for (;;) {
 			K key = (K) s.readObject();
 			V value = (V) s.readObject();
 			if (key == null) {
 				break;
 			}
 			put(key, value);
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/util/collections/IdentityMap.java b/hibernate-core/src/main/java/org/hibernate/internal/util/collections/IdentityMap.java
index 6839eb47c0..2bdadd83a5 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/util/collections/IdentityMap.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/util/collections/IdentityMap.java
@@ -1,270 +1,270 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.internal.util.collections;
 
 import java.io.Serializable;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.Map;
 import java.util.Set;
 
 /**
  * A <tt>Map</tt> where keys are compared by object identity,
  * rather than <tt>equals()</tt>.
  */
 public final class IdentityMap<K,V> implements Map<K,V> {
 
 	private final Map<IdentityKey<K>,V> map;
 	@SuppressWarnings( {"unchecked"})
 	private transient Entry<IdentityKey<K>,V>[] entryArray = new Entry[0];
 	private transient boolean dirty = false;
 
 	/**
 	 * Return a new instance of this class, with iteration
 	 * order defined as the order in which entries were added
 	 *
 	 * @param size The size of the map to create
 	 * @return The map
 	 */
 	public static <K,V> IdentityMap<K,V> instantiateSequenced(int size) {
 		return new IdentityMap<K,V>( new LinkedHashMap<IdentityKey<K>,V>( size ) );
 	}
 
 	/**
 	 * Private ctor used in serialization.
 	 *
 	 * @param underlyingMap The delegate map.
 	 */
 	private IdentityMap(Map<IdentityKey<K>,V> underlyingMap) {
 		map = underlyingMap;
 		dirty = true;
 	}
 
 	/**
 	 * Return the map entries (as instances of <tt>Map.Entry</tt> in a collection that
 	 * is safe from concurrent modification). ie. we may safely add new instances to
 	 * the underlying <tt>Map</tt> during iteration of the <tt>entries()</tt>.
 	 *
 	 * @param map The map of entries
 	 * @return Collection
 	 */
 	public static <K,V> Map.Entry<K,V>[] concurrentEntries(Map<K,V> map) {
 		return ( (IdentityMap<K,V>) map ).entryArray();
 	}
 
 	public Iterator<K> keyIterator() {
 		return new KeyIterator<K>( map.keySet().iterator() );
 	}
 
 	@Override
 	public int size() {
 		return map.size();
 	}
 
 	@Override
 	public boolean isEmpty() {
 		return map.isEmpty();
 	}
 
 	@Override
 	@SuppressWarnings({ "unchecked" })
 	public boolean containsKey(Object key) {
 		return map.containsKey( new IdentityKey( key ) );
 	}
 
 	@Override
 	public boolean containsValue(Object val) {
 		return map.containsValue(val);
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public V get(Object key) {
 		return map.get( new IdentityKey(key) );
 	}
 
 	@Override
 	public V put(K key, V value) {
 		dirty = true;
 		return map.put( new IdentityKey<K>(key), value );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public V remove(Object key) {
 		dirty = true;
 		return map.remove( new IdentityKey(key) );
 	}
 
 	@Override
 	public void putAll(Map<? extends K, ? extends V> otherMap) {
 		for ( Entry<? extends K, ? extends V> entry : otherMap.entrySet() ) {
 			put( entry.getKey(), entry.getValue() );
 		}
 	}
 
 	@Override
 	public void clear() {
 		dirty = true;
 		entryArray = null;
 		map.clear();
 	}
 
 	@Override
 	public Set<K> keySet() {
 		// would need an IdentitySet for this!
 		throw new UnsupportedOperationException();
 	}
 
 	@Override
 	public Collection<V> values() {
 		return map.values();
 	}
 
 	@Override
 	public Set<Entry<K,V>> entrySet() {
 		Set<Entry<K,V>> set = new HashSet<Entry<K,V>>( map.size() );
 		for ( Entry<IdentityKey<K>, V> entry : map.entrySet() ) {
 			set.add( new IdentityMapEntry<K,V>( entry.getKey().getRealKey(), entry.getValue() ) );
 		}
 		return set;
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	public Map.Entry[] entryArray() {
 		if (dirty) {
 			entryArray = new Map.Entry[ map.size() ];
 			Iterator itr = map.entrySet().iterator();
 			int i=0;
 			while ( itr.hasNext() ) {
 				Map.Entry me = (Map.Entry) itr.next();
 				entryArray[i++] = new IdentityMapEntry( ( (IdentityKey) me.getKey() ).key, me.getValue() );
 			}
 			dirty = false;
 		}
 		return entryArray;
 	}
 
 	@Override
     public String toString() {
 		return map.toString();
 	}
 
 	static final class KeyIterator<K> implements Iterator<K> {
 		private final Iterator<IdentityKey<K>> identityKeyIterator;
 
 		private KeyIterator(Iterator<IdentityKey<K>> iterator) {
 			identityKeyIterator = iterator;
 		}
 
 		public boolean hasNext() {
 			return identityKeyIterator.hasNext();
 		}
 
 		public K next() {
 			return identityKeyIterator.next().getRealKey();
 		}
 
 		public void remove() {
 			throw new UnsupportedOperationException();
 		}
 
 	}
 		public static final class IdentityMapEntry<K,V> implements java.util.Map.Entry<K,V> {
 		private final K key;
 		private V value;
 
 		IdentityMapEntry(final K key, final V value) {
 			this.key=key;
 			this.value=value;
 		}
 
 		public K getKey() {
 			return key;
 		}
 
 		public V getValue() {
 			return value;
 		}
 
 		public V setValue(final V value) {
 			V result = this.value;
 			this.value = value;
 			return result;
 		}
 	}
 
 	/**
 	 * We need to base the identity on {@link System#identityHashCode(Object)} but
 	 * attempt to lazily initialize and cache this value: being a native invocation
 	 * it is an expensive value to retrieve.
 	 */
 	public static final class IdentityKey<K> implements Serializable {
 
 		private final K key;
 		private int hash = 0;
 
 		IdentityKey(K key) {
 			this.key = key;
 		}
 
 		@SuppressWarnings( {"EqualsWhichDoesntCheckParameterClass"})
 		@Override
 		public boolean equals(Object other) {
 			return key == ( (IdentityKey) other ).key;
 		}
 
 		@Override
 		public int hashCode() {
 			if ( this.hash == 0 ) {
 				//We consider "zero" as non-initialized value
 				final int newHash = System.identityHashCode( key );
 				if ( newHash == 0 ) {
 					//So make sure we don't store zeros as it would trigger initialization again:
 					//any value is fine as long as we're deterministic.
 					this.hash = -1;
 					return -1;
 				}
 				else {
 					this.hash = newHash;
 					return newHash;
 				}
 			}
 			return hash;
 		}
 
 		@Override
 		public String toString() {
 			return key.toString();
 		}
 
 		public K getRealKey() {
 			return key;
 		}
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/Loader.java b/hibernate-core/src/main/java/org/hibernate/loader/Loader.java
index 685c7a778d..34a652cf1e 100644
--- a/hibernate-core/src/main/java/org/hibernate/loader/Loader.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/Loader.java
@@ -1328,1365 +1328,1365 @@ public abstract class Loader {
 
 			persistenceContext.getLoadContexts()
 					.getCollectionLoadContext( rs )
 					.getLoadingCollection( persister, optionalKey ); // handle empty collection
 
 		}
 
 		// else no collection element, but also no owner
 
 	}
 
 	/**
 	 * If this is a collection initializer, we need to tell the session that a collection
 	 * is being initialized, to account for the possibility of the collection having
 	 * no elements (hence no rows in the result set).
 	 */
 	private void handleEmptyCollections(
 	        final Serializable[] keys,
 	        final Object resultSetId,
 	        final SessionImplementor session) {
 
 		if ( keys != null ) {
 			final boolean debugEnabled = LOG.isDebugEnabled();
 			// this is a collection initializer, so we must create a collection
 			// for each of the passed-in keys, to account for the possibility
 			// that the collection is empty and has no rows in the result set
 			CollectionPersister[] collectionPersisters = getCollectionPersisters();
 			for ( int j=0; j<collectionPersisters.length; j++ ) {
 				for ( int i = 0; i < keys.length; i++ ) {
 					//handle empty collections
 
 					if ( debugEnabled ) {
 						LOG.debugf( "Result set contains (possibly empty) collection: %s",
 								MessageHelper.collectionInfoString( collectionPersisters[j], keys[i], getFactory() ) );
 					}
 
 					session.getPersistenceContext()
 							.getLoadContexts()
 							.getCollectionLoadContext( ( ResultSet ) resultSetId )
 							.getLoadingCollection( collectionPersisters[j], keys[i] );
 				}
 			}
 		}
 
 		// else this is not a collection initializer (and empty collections will
 		// be detected by looking for the owner's identifier in the result set)
 	}
 
 	/**
 	 * Read a row of <tt>Key</tt>s from the <tt>ResultSet</tt> into the given array.
 	 * Warning: this method is side-effecty.
 	 * <p/>
 	 * If an <tt>id</tt> is given, don't bother going to the <tt>ResultSet</tt>.
 	 */
 	private EntityKey getKeyFromResultSet(
 	        final int i,
 	        final Loadable persister,
 	        final Serializable id,
 	        final ResultSet rs,
 	        final SessionImplementor session) throws HibernateException, SQLException {
 
 		Serializable resultId;
 
 		// if we know there is exactly 1 row, we can skip.
 		// it would be great if we could _always_ skip this;
 		// it is a problem for <key-many-to-one>
 
 		if ( isSingleRowLoader() && id != null ) {
 			resultId = id;
 		}
 		else {
 
 			Type idType = persister.getIdentifierType();
 			resultId = (Serializable) idType.nullSafeGet(
 					rs,
 					getEntityAliases()[i].getSuffixedKeyAliases(),
 					session,
 					null //problematic for <key-many-to-one>!
 				);
 
 			final boolean idIsResultId = id != null &&
 					resultId != null &&
 					idType.isEqual( id, resultId, factory );
 
 			if ( idIsResultId ) resultId = id; //use the id passed in
 		}
 
 		return resultId == null ? null : session.generateEntityKey( resultId, persister );
 	}
 
 	/**
 	 * Check the version of the object in the <tt>ResultSet</tt> against
 	 * the object version in the session cache, throwing an exception
 	 * if the version numbers are different
 	 */
 	private void checkVersion(
 	        final int i,
 	        final Loadable persister,
 	        final Serializable id,
 	        final Object entity,
 	        final ResultSet rs,
 	        final SessionImplementor session)
 	throws HibernateException, SQLException {
 
 		Object version = session.getPersistenceContext().getEntry( entity ).getVersion();
 
 		if ( version != null ) { //null version means the object is in the process of being loaded somewhere else in the ResultSet
 			VersionType versionType = persister.getVersionType();
 			Object currentVersion = versionType.nullSafeGet(
 					rs,
 					getEntityAliases()[i].getSuffixedVersionAliases(),
 					session,
 					null
 				);
 			if ( !versionType.isEqual(version, currentVersion) ) {
 				if ( session.getFactory().getStatistics().isStatisticsEnabled() ) {
 					session.getFactory().getStatisticsImplementor()
 							.optimisticFailure( persister.getEntityName() );
 				}
 				throw new StaleObjectStateException( persister.getEntityName(), id );
 			}
 		}
 
 	}
 
 	/**
 	 * Resolve any IDs for currently loaded objects, duplications within the
 	 * <tt>ResultSet</tt>, etc. Instantiate empty objects to be initialized from the
 	 * <tt>ResultSet</tt>. Return an array of objects (a row of results) and an
 	 * array of booleans (by side-effect) that determine whether the corresponding
 	 * object should be initialized.
 	 */
 	private Object[] getRow(
 	        final ResultSet rs,
 	        final Loadable[] persisters,
 	        final EntityKey[] keys,
 	        final Object optionalObject,
 	        final EntityKey optionalObjectKey,
 	        final LockMode[] lockModes,
 	        final List hydratedObjects,
 	        final SessionImplementor session)
 	throws HibernateException, SQLException {
 
 		final int cols = persisters.length;
 		final EntityAliases[] descriptors = getEntityAliases();
 
 		if ( LOG.isDebugEnabled() ) LOG.debugf( "Result row: %s", StringHelper.toString( keys ) );
 
 		final Object[] rowResults = new Object[cols];
 
 		for ( int i = 0; i < cols; i++ ) {
 
 			Object object = null;
 			EntityKey key = keys[i];
 
 			if ( keys[i] == null ) {
 				//do nothing
 			}
 			else {
 
 				//If the object is already loaded, return the loaded one
 				object = session.getEntityUsingInterceptor( key );
 				if ( object != null ) {
 					//its already loaded so don't need to hydrate it
 					instanceAlreadyLoaded(
 							rs,
 							i,
 							persisters[i],
 							key,
 							object,
 							lockModes[i],
 							session
 						);
 				}
 				else {
 					object = instanceNotYetLoaded(
 							rs,
 							i,
 							persisters[i],
 							descriptors[i].getRowIdAlias(),
 							key,
 							lockModes[i],
 							optionalObjectKey,
 							optionalObject,
 							hydratedObjects,
 							session
 						);
 				}
 
 			}
 
 			rowResults[i] = object;
 
 		}
 
 		return rowResults;
 	}
 
 	/**
 	 * The entity instance is already in the session cache
 	 */
 	private void instanceAlreadyLoaded(
 			final ResultSet rs,
 	        final int i,
 	        final Loadable persister,
 	        final EntityKey key,
 	        final Object object,
 	        final LockMode lockMode,
 	        final SessionImplementor session)
 			throws HibernateException, SQLException {
 		if ( !persister.isInstance( object ) ) {
 			throw new WrongClassException(
 					"loaded object was of wrong class " + object.getClass(),
 					key.getIdentifier(),
 					persister.getEntityName()
 				);
 		}
 
 		if ( LockMode.NONE != lockMode && upgradeLocks() ) { //no point doing this if NONE was requested
 
 			final boolean isVersionCheckNeeded = persister.isVersioned() &&
 					session.getPersistenceContext().getEntry(object)
 							.getLockMode().lessThan( lockMode );
 			// we don't need to worry about existing version being uninitialized
 			// because this block isn't called by a re-entrant load (re-entrant
 			// loads _always_ have lock mode NONE)
 			if (isVersionCheckNeeded) {
 				//we only check the version when _upgrading_ lock modes
 				checkVersion( i, persister, key.getIdentifier(), object, rs, session );
 				//we need to upgrade the lock mode to the mode requested
 				session.getPersistenceContext().getEntry(object)
 						.setLockMode(lockMode);
 			}
 		}
 	}
 
 	/**
 	 * The entity instance is not in the session cache
 	 */
 	private Object instanceNotYetLoaded(
 	        final ResultSet rs,
 	        final int i,
 	        final Loadable persister,
 	        final String rowIdAlias,
 	        final EntityKey key,
 	        final LockMode lockMode,
 	        final EntityKey optionalObjectKey,
 	        final Object optionalObject,
 	        final List hydratedObjects,
 	        final SessionImplementor session)
 	throws HibernateException, SQLException {
 		final String instanceClass = getInstanceClass(
 				rs,
 				i,
 				persister,
 				key.getIdentifier(),
 				session
 		);
 
 		final Object object;
 		if ( optionalObjectKey != null && key.equals( optionalObjectKey ) ) {
 			//its the given optional object
 			object = optionalObject;
 		}
 		else {
 			// instantiate a new instance
 			object = session.instantiate( instanceClass, key.getIdentifier() );
 		}
 
 		//need to hydrate it.
 
 		// grab its state from the ResultSet and keep it in the Session
 		// (but don't yet initialize the object itself)
 		// note that we acquire LockMode.READ even if it was not requested
 		LockMode acquiredLockMode = lockMode == LockMode.NONE ? LockMode.READ : lockMode;
 		loadFromResultSet(
 				rs,
 				i,
 				object,
 				instanceClass,
 				key,
 				rowIdAlias,
 				acquiredLockMode,
 				persister,
 				session
 			);
 
 		//materialize associations (and initialize the object) later
 		hydratedObjects.add( object );
 
 		return object;
 	}
 
 	private boolean isEagerPropertyFetchEnabled(int i) {
 		boolean[] array = getEntityEagerPropertyFetches();
 		return array!=null && array[i];
 	}
 
 
 	/**
 	 * Hydrate the state an object from the SQL <tt>ResultSet</tt>, into
 	 * an array or "hydrated" values (do not resolve associations yet),
 	 * and pass the hydrates state to the session.
 	 */
 	private void loadFromResultSet(
 	        final ResultSet rs,
 	        final int i,
 	        final Object object,
 	        final String instanceEntityName,
 	        final EntityKey key,
 	        final String rowIdAlias,
 	        final LockMode lockMode,
 	        final Loadable rootPersister,
 	        final SessionImplementor session)
 	throws SQLException, HibernateException {
 
 		final Serializable id = key.getIdentifier();
 
 		// Get the persister for the _subclass_
 		final Loadable persister = (Loadable) getFactory().getEntityPersister( instanceEntityName );
 
 		if ( LOG.isTraceEnabled() )
 			LOG.tracev( "Initializing object from ResultSet: {0}", MessageHelper.infoString( persister, id, getFactory() ) );
 
 		boolean eagerPropertyFetch = isEagerPropertyFetchEnabled(i);
 
 		// add temp entry so that the next step is circular-reference
 		// safe - only needed because some types don't take proper
 		// advantage of two-phase-load (esp. components)
 		TwoPhaseLoad.addUninitializedEntity(
 				key,
 				object,
 				persister,
 				lockMode,
 				!eagerPropertyFetch,
 				session
 			);
 
 		//This is not very nice (and quite slow):
 		final String[][] cols = persister == rootPersister ?
 				getEntityAliases()[i].getSuffixedPropertyAliases() :
 				getEntityAliases()[i].getSuffixedPropertyAliases(persister);
 
 		final Object[] values = persister.hydrate(
 				rs,
 				id,
 				object,
 				rootPersister,
 				cols,
 				eagerPropertyFetch,
 				session
 			);
 
 		final Object rowId = persister.hasRowId() ? rs.getObject(rowIdAlias) : null;
 
 		final AssociationType[] ownerAssociationTypes = getOwnerAssociationTypes();
 		if ( ownerAssociationTypes != null && ownerAssociationTypes[i] != null ) {
 			String ukName = ownerAssociationTypes[i].getRHSUniqueKeyPropertyName();
 			if (ukName!=null) {
 				final int index = ( (UniqueKeyLoadable) persister ).getPropertyIndex(ukName);
 				final Type type = persister.getPropertyTypes()[index];
 
 				// polymorphism not really handled completely correctly,
 				// perhaps...well, actually its ok, assuming that the
 				// entity name used in the lookup is the same as the
 				// the one used here, which it will be
 
 				EntityUniqueKey euk = new EntityUniqueKey(
 						rootPersister.getEntityName(), //polymorphism comment above
 						ukName,
 						type.semiResolve( values[index], session, object ),
 						type,
 						persister.getEntityMode(),
 						session.getFactory()
 				);
 				session.getPersistenceContext().addEntity( euk, object );
 			}
 		}
 
 		TwoPhaseLoad.postHydrate(
 				persister,
 				id,
 				values,
 				rowId,
 				object,
 				lockMode,
 				!eagerPropertyFetch,
 				session
 		);
 
 	}
 
 	/**
 	 * Determine the concrete class of an instance in the <tt>ResultSet</tt>
 	 */
 	private String getInstanceClass(
 	        final ResultSet rs,
 	        final int i,
 	        final Loadable persister,
 	        final Serializable id,
 	        final SessionImplementor session)
 	throws HibernateException, SQLException {
 
 		if ( persister.hasSubclasses() ) {
 
 			// Code to handle subclasses of topClass
 			Object discriminatorValue = persister.getDiscriminatorType().nullSafeGet(
 					rs,
 					getEntityAliases()[i].getSuffixedDiscriminatorAlias(),
 					session,
 					null
 				);
 
 			final String result = persister.getSubclassForDiscriminatorValue( discriminatorValue );
 
 			if ( result == null ) {
 				//woops we got an instance of another class hierarchy branch
 				throw new WrongClassException(
 						"Discriminator: " + discriminatorValue,
 						id,
 						persister.getEntityName()
 					);
 			}
 
 			return result;
 
 		}
 		else {
 			return persister.getEntityName();
 		}
 	}
 
 	/**
 	 * Advance the cursor to the first required row of the <tt>ResultSet</tt>
 	 */
 	private void advance(final ResultSet rs, final RowSelection selection)
 			throws SQLException {
 
 		final int firstRow = LimitHelper.getFirstRow( selection );
 		if ( firstRow != 0 ) {
 			if ( getFactory().getSettings().isScrollableResultSetsEnabled() ) {
 				// we can go straight to the first required row
 				rs.absolute( firstRow );
 			}
 			else {
 				// we need to step through the rows one row at a time (slow)
 				for ( int m = 0; m < firstRow; m++ ) rs.next();
 			}
 		}
 	}
 
 	/**
 	 * Build LIMIT clause handler applicable for given selection criteria. Returns {@link NoopLimitHandler} delegate
 	 * if dialect does not support LIMIT expression or processed query does not use pagination.
 	 *
 	 * @param sql Query string.
 	 * @param selection Selection criteria.
 	 * @return LIMIT clause delegate.
 	 */
 	protected LimitHandler getLimitHandler(String sql, RowSelection selection) {
 		final LimitHandler limitHandler = getFactory().getDialect().buildLimitHandler( sql, selection );
 		return LimitHelper.useLimit( limitHandler, selection ) ? limitHandler : new NoopLimitHandler( sql, selection );
 	}
 
 	private ScrollMode getScrollMode(boolean scroll, boolean hasFirstRow, boolean useLimitOffSet, QueryParameters queryParameters) {
 		final boolean canScroll = getFactory().getSettings().isScrollableResultSetsEnabled();
 		if ( canScroll ) {
 			if ( scroll ) {
 				return queryParameters.getScrollMode();
 			}
 			if ( hasFirstRow && !useLimitOffSet ) {
 				return ScrollMode.SCROLL_INSENSITIVE;
 			}
 		}
 		return null;
 	}
 
 	/**
 	 * Process query string by applying filters, LIMIT clause, locks and comments if necessary.
 	 * Finally execute SQL statement and advance to the first row.
 	 */
 	protected SqlStatementWrapper executeQueryStatement(
 			final QueryParameters queryParameters,
 			final boolean scroll,
 			List<AfterLoadAction> afterLoadActions,
 			final SessionImplementor session) throws SQLException {
 		return executeQueryStatement( getSQLString(), queryParameters, scroll, afterLoadActions, session );
 	}
 
 	protected SqlStatementWrapper executeQueryStatement(
 			String sqlStatement,
 			QueryParameters queryParameters,
 			boolean scroll,
 			List<AfterLoadAction> afterLoadActions,
 			SessionImplementor session) throws SQLException {
 
 		// Processing query filters.
 		queryParameters.processFilters( sqlStatement, session );
 
 		// Applying LIMIT clause.
 		final LimitHandler limitHandler = getLimitHandler(
 				queryParameters.getFilteredSQL(),
 				queryParameters.getRowSelection()
 		);
 		String sql = limitHandler.getProcessedSql();
 
 		// Adding locks and comments.
 		sql = preprocessSQL( sql, queryParameters, getFactory().getDialect(), afterLoadActions );
 
 		final PreparedStatement st = prepareQueryStatement( sql, queryParameters, limitHandler, scroll, session );
 		return new SqlStatementWrapper( st, getResultSet( st, queryParameters.getRowSelection(), limitHandler, queryParameters.hasAutoDiscoverScalarTypes(), session ) );
 	}
 
 	/**
 	 * Obtain a <tt>PreparedStatement</tt> with all parameters pre-bound.
 	 * Bind JDBC-style <tt>?</tt> parameters, named parameters, and
 	 * limit parameters.
 	 */
 	protected final PreparedStatement prepareQueryStatement(
 	        final String sql,
 	        final QueryParameters queryParameters,
 	        final LimitHandler limitHandler,
 	        final boolean scroll,
 	        final SessionImplementor session) throws SQLException, HibernateException {
 		final Dialect dialect = getFactory().getDialect();
 		final RowSelection selection = queryParameters.getRowSelection();
 		boolean useLimit = LimitHelper.useLimit( limitHandler, selection );
 		boolean hasFirstRow = LimitHelper.hasFirstRow( selection );
 		boolean useLimitOffset = hasFirstRow && useLimit && limitHandler.supportsLimitOffset();
 		boolean callable = queryParameters.isCallable();
 		final ScrollMode scrollMode = getScrollMode( scroll, hasFirstRow, useLimitOffset, queryParameters );
 
 		PreparedStatement st = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareQueryStatement(
 				sql,
 				callable,
 				scrollMode
 		);
 
 		try {
 
 			int col = 1;
 			//TODO: can we limit stored procedures ?!
 			col += limitHandler.bindLimitParametersAtStartOfQuery( st, col );
 
 			if (callable) {
 				col = dialect.registerResultSetOutParameter( (CallableStatement)st, col );
 			}
 
 			col += bindParameterValues( st, queryParameters, col, session );
 
 			col += limitHandler.bindLimitParametersAtEndOfQuery( st, col );
 
 			limitHandler.setMaxRows( st );
 
 			if ( selection != null ) {
 				if ( selection.getTimeout() != null ) {
 					st.setQueryTimeout( selection.getTimeout() );
 				}
 				if ( selection.getFetchSize() != null ) {
 					st.setFetchSize( selection.getFetchSize() );
 				}
 			}
 
 			// handle lock timeout...
 			LockOptions lockOptions = queryParameters.getLockOptions();
 			if ( lockOptions != null ) {
 				if ( lockOptions.getTimeOut() != LockOptions.WAIT_FOREVER ) {
 					if ( !dialect.supportsLockTimeouts() ) {
 						if ( LOG.isDebugEnabled() ) {
 							LOG.debugf(
 									"Lock timeout [%s] requested but dialect reported to not support lock timeouts",
 									lockOptions.getTimeOut()
 							);
 						}
 					}
 					else if ( dialect.isLockTimeoutParameterized() ) {
 						st.setInt( col++, lockOptions.getTimeOut() );
 					}
 				}
 			}
 
 			if ( LOG.isTraceEnabled() )
 			   LOG.tracev( "Bound [{0}] parameters total", col );
 		}
 		catch ( SQLException sqle ) {
 			session.getTransactionCoordinator().getJdbcCoordinator().release( st );
 			throw sqle;
 		}
 		catch ( HibernateException he ) {
 			session.getTransactionCoordinator().getJdbcCoordinator().release( st );
 			throw he;
 		}
 
 		return st;
 	}
 
 	/**
 	 * Bind all parameter values into the prepared statement in preparation
 	 * for execution.
 	 *
 	 * @param statement The JDBC prepared statement
 	 * @param queryParameters The encapsulation of the parameter values to be bound.
 	 * @param startIndex The position from which to start binding parameter values.
 	 * @param session The originating session.
 	 * @return The number of JDBC bind positions actually bound during this method execution.
 	 * @throws SQLException Indicates problems performing the binding.
 	 */
 	protected int bindParameterValues(
 			PreparedStatement statement,
 			QueryParameters queryParameters,
 			int startIndex,
 			SessionImplementor session) throws SQLException {
 		int span = 0;
 		span += bindPositionalParameters( statement, queryParameters, startIndex, session );
 		span += bindNamedParameters( statement, queryParameters.getNamedParameters(), startIndex + span, session );
 		return span;
 	}
 
 	/**
 	 * Bind positional parameter values to the JDBC prepared statement.
 	 * <p/>
 	 * Positional parameters are those specified by JDBC-style ? parameters
 	 * in the source query.  It is (currently) expected that these come
 	 * before any named parameters in the source query.
 	 *
 	 * @param statement The JDBC prepared statement
 	 * @param queryParameters The encapsulation of the parameter values to be bound.
 	 * @param startIndex The position from which to start binding parameter values.
 	 * @param session The originating session.
 	 * @return The number of JDBC bind positions actually bound during this method execution.
 	 * @throws SQLException Indicates problems performing the binding.
 	 * @throws org.hibernate.HibernateException Indicates problems delegating binding to the types.
 	 */
 	protected int bindPositionalParameters(
 	        final PreparedStatement statement,
 	        final QueryParameters queryParameters,
 	        final int startIndex,
 	        final SessionImplementor session) throws SQLException, HibernateException {
 		final Object[] values = queryParameters.getFilteredPositionalParameterValues();
 		final Type[] types = queryParameters.getFilteredPositionalParameterTypes();
 		int span = 0;
 		for ( int i = 0; i < values.length; i++ ) {
 			types[i].nullSafeSet( statement, values[i], startIndex + span, session );
 			span += types[i].getColumnSpan( getFactory() );
 		}
 		return span;
 	}
 
 	/**
 	 * Bind named parameters to the JDBC prepared statement.
 	 * <p/>
 	 * This is a generic implementation, the problem being that in the
 	 * general case we do not know enough information about the named
 	 * parameters to perform this in a complete manner here.  Thus this
 	 * is generally overridden on subclasses allowing named parameters to
 	 * apply the specific behavior.  The most usual limitation here is that
 	 * we need to assume the type span is always one...
 	 *
 	 * @param statement The JDBC prepared statement
 	 * @param namedParams A map of parameter names to values
 	 * @param startIndex The position from which to start binding parameter values.
 	 * @param session The originating session.
 	 * @return The number of JDBC bind positions actually bound during this method execution.
 	 * @throws SQLException Indicates problems performing the binding.
 	 * @throws org.hibernate.HibernateException Indicates problems delegating binding to the types.
 	 */
 	protected int bindNamedParameters(
 			final PreparedStatement statement,
 			final Map<String, TypedValue> namedParams,
 			final int startIndex,
 			final SessionImplementor session) throws SQLException, HibernateException {
 		int result = 0;
 		if ( CollectionHelper.isEmpty( namedParams ) ) {
 			return result;
 		}
 
 		for ( String name : namedParams.keySet() ) {
 			TypedValue typedValue = namedParams.get( name );
 			int columnSpan = typedValue.getType().getColumnSpan( getFactory() );
 			int[] locs = getNamedParameterLocs( name );
 			for ( int loc : locs ) {
 				if ( DEBUG_ENABLED ) {
 					LOG.debugf(
 							"bindNamedParameters() %s -> %s [%s]",
 							typedValue.getValue(),
 							name,
 							loc + startIndex
 					);
 				}
 				int start = loc * columnSpan + startIndex;
 				typedValue.getType().nullSafeSet( statement, typedValue.getValue(), start, session );
 			}
 			result += locs.length;
 		}
 		return result;
 	}
 
 	public int[] getNamedParameterLocs(String name) {
 		throw new AssertionFailure("no named parameters");
 	}
 
 	/**
 	 * Execute given <tt>PreparedStatement</tt>, advance to the first result and return SQL <tt>ResultSet</tt>.
 	 */
 	protected final ResultSet getResultSet(
 	        final PreparedStatement st,
 	        final RowSelection selection,
 	        final LimitHandler limitHandler,
 	        final boolean autodiscovertypes,
 	        final SessionImplementor session)
 	throws SQLException, HibernateException {
 
 		try {
 			ResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( st );
 			rs = wrapResultSetIfEnabled( rs , session );
 
 			if ( !limitHandler.supportsLimitOffset() || !LimitHelper.useLimit( limitHandler, selection ) ) {
 				advance( rs, selection );
 			}
 
 			if ( autodiscovertypes ) {
 				autoDiscoverTypes( rs );
 			}
 			return rs;
 		}
 		catch ( SQLException sqle ) {
 			session.getTransactionCoordinator().getJdbcCoordinator().release( st );
 			throw sqle;
 		}
 	}
 
 	protected void autoDiscoverTypes(ResultSet rs) {
 		throw new AssertionFailure("Auto discover types not supported in this loader");
 
 	}
 
 	private synchronized ResultSet wrapResultSetIfEnabled(final ResultSet rs, final SessionImplementor session) {
 		// synchronized to avoid multi-thread access issues; defined as method synch to avoid
 		// potential deadlock issues due to nature of code.
 		if ( session.getFactory().getSettings().isWrapResultSetsEnabled() ) {
 			try {
 			   if ( LOG.isDebugEnabled() )
 			      LOG.debugf( "Wrapping result set [%s]", rs );
 				return session.getFactory()
 						.getJdbcServices()
 						.getResultSetWrapper().wrap( rs, retreiveColumnNameToIndexCache( rs ) );
 			}
 			catch(SQLException e) {
 				LOG.unableToWrapResultSet( e );
 				return rs;
 			}
 		}
 		else {
 			return rs;
 		}
 	}
 
 	private ColumnNameCache retreiveColumnNameToIndexCache(ResultSet rs) throws SQLException {
 		if ( columnNameCache == null ) {
 			LOG.trace( "Building columnName -> columnIndex cache" );
 			columnNameCache = new ColumnNameCache( rs.getMetaData().getColumnCount() );
 		}
 
 		return columnNameCache;
 	}
 
 	/**
 	 * Called by subclasses that load entities
 	 * @param persister only needed for logging
 	 * @param lockOptions
 	 */
 	protected final List loadEntity(
 			final SessionImplementor session,
 			final Object id,
 			final Type identifierType,
 			final Object optionalObject,
 			final String optionalEntityName,
 			final Serializable optionalIdentifier,
 			final EntityPersister persister,
 			LockOptions lockOptions) throws HibernateException {
 
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debugf( "Loading entity: %s", MessageHelper.infoString( persister, id, identifierType, getFactory() ) );
 		}
 
 		List result;
 		try {
 			QueryParameters qp = new QueryParameters();
 			qp.setPositionalParameterTypes( new Type[] { identifierType } );
 			qp.setPositionalParameterValues( new Object[] { id } );
 			qp.setOptionalObject( optionalObject );
 			qp.setOptionalEntityName( optionalEntityName );
 			qp.setOptionalId( optionalIdentifier );
 			qp.setLockOptions( lockOptions );
 			result = doQueryAndInitializeNonLazyCollections( session, qp, false );
 		}
 		catch ( SQLException sqle ) {
 			final Loadable[] persisters = getEntityPersisters();
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not load an entity: " +
 			        MessageHelper.infoString( persisters[persisters.length-1], id, identifierType, getFactory() ),
 			        getSQLString()
 				);
 		}
 
 		LOG.debug( "Done entity load" );
 
 		return result;
 
 	}
 
 	/**
 	 * Called by subclasses that load entities
 	 * @param persister only needed for logging
 	 */
 	protected final List loadEntity(
 	        final SessionImplementor session,
 	        final Object key,
 	        final Object index,
 	        final Type keyType,
 	        final Type indexType,
 	        final EntityPersister persister) throws HibernateException {
 
 		LOG.debug( "Loading collection element by index" );
 
 		List result;
 		try {
 			result = doQueryAndInitializeNonLazyCollections(
 					session,
 					new QueryParameters(
 							new Type[] { keyType, indexType },
 							new Object[] { key, index }
 					),
 					false
 			);
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not collection element by index",
 			        getSQLString()
 				);
 		}
 
 		LOG.debug( "Done entity load" );
 
 		return result;
 
 	}
 
 	/**
 	 * Called by wrappers that batch load entities
 	 * @param persister only needed for logging
 	 * @param lockOptions
 	 */
 	public final List loadEntityBatch(
 			final SessionImplementor session,
 			final Serializable[] ids,
 			final Type idType,
 			final Object optionalObject,
 			final String optionalEntityName,
 			final Serializable optionalId,
 			final EntityPersister persister,
 			LockOptions lockOptions) throws HibernateException {
 
 		if ( LOG.isDebugEnabled() )
 			LOG.debugf( "Batch loading entity: %s", MessageHelper.infoString( persister, ids, getFactory() ) );
 
 		Type[] types = new Type[ids.length];
 		Arrays.fill( types, idType );
 		List result;
 		try {
 			QueryParameters qp = new QueryParameters();
 			qp.setPositionalParameterTypes( types );
 			qp.setPositionalParameterValues( ids );
 			qp.setOptionalObject( optionalObject );
 			qp.setOptionalEntityName( optionalEntityName );
 			qp.setOptionalId( optionalId );
 			qp.setLockOptions( lockOptions );
 			result = doQueryAndInitializeNonLazyCollections( session, qp, false );
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not load an entity batch: " +
 			        MessageHelper.infoString( getEntityPersisters()[0], ids, getFactory() ),
 			        getSQLString()
 				);
 		}
 
 		LOG.debug( "Done entity batch load" );
 
 		return result;
 
 	}
 
 	/**
 	 * Called by subclasses that initialize collections
 	 */
 	public final void loadCollection(
 	        final SessionImplementor session,
 	        final Serializable id,
 	        final Type type) throws HibernateException {
 
 		if ( LOG.isDebugEnabled() )
 			LOG.debugf( "Loading collection: %s",
 					MessageHelper.collectionInfoString( getCollectionPersisters()[0], id, getFactory() ) );
 
 		Serializable[] ids = new Serializable[]{id};
 		try {
 			doQueryAndInitializeNonLazyCollections(
 					session,
 					new QueryParameters( new Type[]{type}, ids, ids ),
 					true
 				);
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 					sqle,
 					"could not initialize a collection: " +
 					MessageHelper.collectionInfoString( getCollectionPersisters()[0], id, getFactory() ),
 					getSQLString()
 				);
 		}
 
 		LOG.debug( "Done loading collection" );
 
 	}
 
 	/**
 	 * Called by wrappers that batch initialize collections
 	 */
 	public final void loadCollectionBatch(
 	        final SessionImplementor session,
 	        final Serializable[] ids,
 	        final Type type) throws HibernateException {
 
 		if ( LOG.isDebugEnabled() )
 			LOG.debugf( "Batch loading collection: %s",
 					MessageHelper.collectionInfoString( getCollectionPersisters()[0], ids, getFactory() ) );
 
 		Type[] idTypes = new Type[ids.length];
 		Arrays.fill( idTypes, type );
 		try {
 			doQueryAndInitializeNonLazyCollections(
 					session,
 					new QueryParameters( idTypes, ids, ids ),
 					true
 				);
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not initialize a collection batch: " +
 			        MessageHelper.collectionInfoString( getCollectionPersisters()[0], ids, getFactory() ),
 			        getSQLString()
 				);
 		}
 
 		LOG.debug( "Done batch load" );
 
 	}
 
 	/**
 	 * Called by subclasses that batch initialize collections
 	 */
 	protected final void loadCollectionSubselect(
 	        final SessionImplementor session,
 	        final Serializable[] ids,
 	        final Object[] parameterValues,
 	        final Type[] parameterTypes,
 	        final Map<String, TypedValue> namedParameters,
 	        final Type type) throws HibernateException {
 
 		Type[] idTypes = new Type[ids.length];
 		Arrays.fill( idTypes, type );
 		try {
 			doQueryAndInitializeNonLazyCollections( session,
 					new QueryParameters( parameterTypes, parameterValues, namedParameters, ids ),
 					true
 				);
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not load collection by subselect: " +
 			        MessageHelper.collectionInfoString( getCollectionPersisters()[0], ids, getFactory() ),
 			        getSQLString()
 				);
 		}
 	}
 
 	/**
 	 * Return the query results, using the query cache, called
 	 * by subclasses that implement cacheable queries
 	 */
 	protected List list(
 	        final SessionImplementor session,
 	        final QueryParameters queryParameters,
-	        final Set querySpaces,
+	        final Set<Serializable> querySpaces,
 	        final Type[] resultTypes) throws HibernateException {
 
 		final boolean cacheable = factory.getSettings().isQueryCacheEnabled() &&
 			queryParameters.isCacheable();
 
 		if ( cacheable ) {
 			return listUsingQueryCache( session, queryParameters, querySpaces, resultTypes );
 		}
 		else {
 			return listIgnoreQueryCache( session, queryParameters );
 		}
 	}
 
 	private List listIgnoreQueryCache(SessionImplementor session, QueryParameters queryParameters) {
 		return getResultList( doList( session, queryParameters ), queryParameters.getResultTransformer() );
 	}
 
 	private List listUsingQueryCache(
 			final SessionImplementor session,
 			final QueryParameters queryParameters,
-			final Set querySpaces,
+			final Set<Serializable> querySpaces,
 			final Type[] resultTypes) {
 
 		QueryCache queryCache = factory.getQueryCache( queryParameters.getCacheRegion() );
 
 		QueryKey key = generateQueryKey( session, queryParameters );
 
 		if ( querySpaces == null || querySpaces.size() == 0 )
 			LOG.tracev( "Unexpected querySpaces is {0}", ( querySpaces == null ? querySpaces : "empty" ) );
 		else {
 			LOG.tracev( "querySpaces is {0}", querySpaces );
 		}
 
 		List result = getResultFromQueryCache(
 				session,
 				queryParameters,
 				querySpaces,
 				resultTypes,
 				queryCache,
 				key
 			);
 
 		if ( result == null ) {
 			result = doList( session, queryParameters, key.getResultTransformer() );
 
 			putResultInQueryCache(
 					session,
 					queryParameters,
 					resultTypes,
 					queryCache,
 					key,
 					result
 			);
 		}
 
 		ResultTransformer resolvedTransformer = resolveResultTransformer( queryParameters.getResultTransformer() );
 		if ( resolvedTransformer != null ) {
 			result = (
 					areResultSetRowsTransformedImmediately() ?
 							key.getResultTransformer().retransformResults(
 									result,
 									getResultRowAliases(),
 									queryParameters.getResultTransformer(),
 									includeInResultRow()
 							) :
 							key.getResultTransformer().untransformToTuples(
 									result
 							)
 			);
 		}
 
 		return getResultList( result, queryParameters.getResultTransformer() );
 	}
 
 	private QueryKey generateQueryKey(
 			SessionImplementor session,
 			QueryParameters queryParameters) {
 		return QueryKey.generateQueryKey(
 				getSQLString(),
 				queryParameters,
 				FilterKey.createFilterKeys( session.getLoadQueryInfluencers().getEnabledFilters() ),
 				session,
 				createCacheableResultTransformer( queryParameters )
 		);
 	}
 
 	private CacheableResultTransformer createCacheableResultTransformer(QueryParameters queryParameters) {
 		return CacheableResultTransformer.create(
 				queryParameters.getResultTransformer(),
 				getResultRowAliases(),
 				includeInResultRow()
 		);
 	}
 
 	private List getResultFromQueryCache(
 			final SessionImplementor session,
 			final QueryParameters queryParameters,
-			final Set querySpaces,
+			final Set<Serializable> querySpaces,
 			final Type[] resultTypes,
 			final QueryCache queryCache,
 			final QueryKey key) {
 		List result = null;
 
 		if ( session.getCacheMode().isGetEnabled() ) {
 			boolean isImmutableNaturalKeyLookup =
 					queryParameters.isNaturalKeyLookup() &&
 							resultTypes.length == 1 &&
 							resultTypes[0].isEntityType() &&
 							getEntityPersister( EntityType.class.cast( resultTypes[0] ) )
 									.getEntityMetamodel()
 									.hasImmutableNaturalId();
 
 			final PersistenceContext persistenceContext = session.getPersistenceContext();
 			boolean defaultReadOnlyOrig = persistenceContext.isDefaultReadOnly();
 			if ( queryParameters.isReadOnlyInitialized() ) {
 				// The read-only/modifiable mode for the query was explicitly set.
 				// Temporarily set the default read-only/modifiable setting to the query's setting.
 				persistenceContext.setDefaultReadOnly( queryParameters.isReadOnly() );
 			}
 			else {
 				// The read-only/modifiable setting for the query was not initialized.
 				// Use the default read-only/modifiable from the persistence context instead.
 				queryParameters.setReadOnly( persistenceContext.isDefaultReadOnly() );
 			}
 			try {
 				result = queryCache.get(
 						key,
 						key.getResultTransformer().getCachedResultTypes( resultTypes ),
 						isImmutableNaturalKeyLookup,
 						querySpaces,
 						session
 				);
 			}
 			finally {
 				persistenceContext.setDefaultReadOnly( defaultReadOnlyOrig );
 			}
 
 			if ( factory.getStatistics().isStatisticsEnabled() ) {
 				if ( result == null ) {
 					factory.getStatisticsImplementor()
 							.queryCacheMiss( getQueryIdentifier(), queryCache.getRegion().getName() );
 				}
 				else {
 					factory.getStatisticsImplementor()
 							.queryCacheHit( getQueryIdentifier(), queryCache.getRegion().getName() );
 				}
 			}
 		}
 
 		return result;
 	}
 
 	private EntityPersister getEntityPersister(EntityType entityType) {
 		return factory.getEntityPersister( entityType.getAssociatedEntityName() );
 	}
 
 	private void putResultInQueryCache(
 			final SessionImplementor session,
 			final QueryParameters queryParameters,
 			final Type[] resultTypes,
 			final QueryCache queryCache,
 			final QueryKey key,
 			final List result) {
 		if ( session.getCacheMode().isPutEnabled() ) {
 			boolean put = queryCache.put(
 					key,
 					key.getResultTransformer().getCachedResultTypes( resultTypes ),
 					result,
 					queryParameters.isNaturalKeyLookup(),
 					session
 			);
 			if ( put && factory.getStatistics().isStatisticsEnabled() ) {
 				factory.getStatisticsImplementor()
 						.queryCachePut( getQueryIdentifier(), queryCache.getRegion().getName() );
 			}
 		}
 	}
 
 	/**
 	 * Actually execute a query, ignoring the query cache
 	 */
 
 	protected List doList(final SessionImplementor session, final QueryParameters queryParameters)
 			throws HibernateException {
 		return doList( session, queryParameters, null);
 	}
 
 	private List doList(final SessionImplementor session,
 						final QueryParameters queryParameters,
 						final ResultTransformer forcedResultTransformer)
 			throws HibernateException {
 
 		final boolean stats = getFactory().getStatistics().isStatisticsEnabled();
 		long startTime = 0;
 		if ( stats ) startTime = System.currentTimeMillis();
 
 		List result;
 		try {
 			result = doQueryAndInitializeNonLazyCollections( session, queryParameters, true, forcedResultTransformer );
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not execute query",
 			        getSQLString()
 				);
 		}
 
 		if ( stats ) {
 			getFactory().getStatisticsImplementor().queryExecuted(
 					getQueryIdentifier(),
 					result.size(),
 					System.currentTimeMillis() - startTime
 				);
 		}
 
 		return result;
 	}
 
 	/**
 	 * Check whether the current loader can support returning ScrollableResults.
 	 *
 	 * @throws HibernateException
 	 */
 	protected void checkScrollability() throws HibernateException {
 		// Allows various loaders (ok mainly the QueryLoader :) to check
 		// whether scrolling of their result set should be allowed.
 		//
 		// By default it is allowed.
 	}
 
 	/**
 	 * Does the result set to be scrolled contain collection fetches?
 	 *
 	 * @return True if it does, and thus needs the special fetching scroll
 	 * functionality; false otherwise.
 	 */
 	protected boolean needsFetchingScroll() {
 		return false;
 	}
 
 	/**
 	 * Return the query results, as an instance of <tt>ScrollableResults</tt>
 	 *
 	 * @param queryParameters The parameters with which the query should be executed.
 	 * @param returnTypes The expected return types of the query
 	 * @param holderInstantiator If the return values are expected to be wrapped
 	 * in a holder, this is the thing that knows how to wrap them.
 	 * @param session The session from which the scroll request originated.
 	 * @return The ScrollableResults instance.
 	 * @throws HibernateException Indicates an error executing the query, or constructing
 	 * the ScrollableResults.
 	 */
 	protected ScrollableResults scroll(
 	        final QueryParameters queryParameters,
 	        final Type[] returnTypes,
 	        final HolderInstantiator holderInstantiator,
 	        final SessionImplementor session) throws HibernateException {
 
 		checkScrollability();
 
 		final boolean stats = getQueryIdentifier() != null &&
 				getFactory().getStatistics().isStatisticsEnabled();
 		long startTime = 0;
 		if ( stats ) startTime = System.currentTimeMillis();
 
 		try {
 			final SqlStatementWrapper wrapper = executeQueryStatement( queryParameters, true, Collections.<AfterLoadAction>emptyList(), session );
 			final ResultSet rs = wrapper.getResultSet();
 			final PreparedStatement st = (PreparedStatement) wrapper.getStatement();
 
 			if ( stats ) {
 				getFactory().getStatisticsImplementor().queryExecuted(
 						getQueryIdentifier(),
 						0,
 						System.currentTimeMillis() - startTime
 					);
 			}
 
 			if ( needsFetchingScroll() ) {
 				return new FetchingScrollableResultsImpl(
 						rs,
 						st,
 						session,
 						this,
 						queryParameters,
 						returnTypes,
 						holderInstantiator
 					);
 			}
 			else {
 				return new ScrollableResultsImpl(
 						rs,
 						st,
 						session,
 						this,
 						queryParameters,
 						returnTypes,
 						holderInstantiator
 					);
 			}
 
 		}
 		catch ( SQLException sqle ) {
 			throw factory.getSQLExceptionHelper().convert(
 			        sqle,
 			        "could not execute query using scroll",
 			        getSQLString()
 				);
 		}
 
 	}
 
 	/**
 	 * Calculate and cache select-clause suffixes. Must be
 	 * called by subclasses after instantiation.
 	 */
 	protected void postInstantiate() {}
 
 	/**
 	 * Get the result set descriptor
 	 */
 	protected abstract EntityAliases[] getEntityAliases();
 
 	protected abstract CollectionAliases[] getCollectionAliases();
 
 	/**
 	 * Identifies the query for statistics reporting, if null,
 	 * no statistics will be reported
 	 */
 	protected String getQueryIdentifier() {
 		return null;
 	}
 
 	public final SessionFactoryImplementor getFactory() {
 		return factory;
 	}
 
 	@Override
     public String toString() {
 		return getClass().getName() + '(' + getSQLString() + ')';
 	}
 
 	/**
 	 * Wrapper class for {@link Statement} and associated {@link ResultSet}.
 	 */
 	protected static class SqlStatementWrapper {
 		private final Statement statement;
 		private final ResultSet resultSet;
 
 		private SqlStatementWrapper(Statement statement, ResultSet resultSet) {
 			this.resultSet = resultSet;
 			this.statement = statement;
 		}
 
 		public ResultSet getResultSet() {
 			return resultSet;
 		}
 
 		public Statement getStatement() {
 			return statement;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/criteria/CriteriaLoader.java b/hibernate-core/src/main/java/org/hibernate/loader/criteria/CriteriaLoader.java
index d973d9c9ae..8bb73cc05a 100644
--- a/hibernate-core/src/main/java/org/hibernate/loader/criteria/CriteriaLoader.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/criteria/CriteriaLoader.java
@@ -1,290 +1,291 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.loader.criteria;
+import java.io.Serializable;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollMode;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.LoadQueryInfluencers;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CriteriaImpl;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.loader.OuterJoinLoader;
 import org.hibernate.loader.spi.AfterLoadAction;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.Lockable;
 import org.hibernate.persister.entity.OuterJoinLoadable;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.Type;
 
 /**
  * A <tt>Loader</tt> for <tt>Criteria</tt> queries. Note that criteria queries are
  * more like multi-object <tt>load()</tt>s than like HQL queries.
  *
  * @author Gavin King
  */
 public class CriteriaLoader extends OuterJoinLoader {
 
 	//TODO: this class depends directly upon CriteriaImpl, 
 	//      in the impl package ... add a CriteriaImplementor 
 	//      interface
 
 	//NOTE: unlike all other Loaders, this one is NOT
 	//      multithreaded, or cacheable!!
 
 	private final CriteriaQueryTranslator translator;
-	private final Set querySpaces;
+	private final Set<Serializable> querySpaces;
 	private final Type[] resultTypes;
 	//the user visible aliases, which are unknown to the superclass,
 	//these are not the actual "physical" SQL aliases
 	private final String[] userAliases;
 	private final boolean[] includeInResultRow;
 	private final int resultRowLength;
 
 	public CriteriaLoader(
 			final OuterJoinLoadable persister, 
 			final SessionFactoryImplementor factory, 
 			final CriteriaImpl criteria, 
 			final String rootEntityName,
 			final LoadQueryInfluencers loadQueryInfluencers) throws HibernateException {
 		super( factory, loadQueryInfluencers );
 
 		translator = new CriteriaQueryTranslator(
 				factory, 
 				criteria, 
 				rootEntityName, 
 				CriteriaQueryTranslator.ROOT_SQL_ALIAS
 			);
 
 		querySpaces = translator.getQuerySpaces();
 		
 		CriteriaJoinWalker walker = new CriteriaJoinWalker(
 				persister, 
 				translator,
 				factory, 
 				criteria, 
 				rootEntityName, 
 				loadQueryInfluencers
 			);
 
 		initFromWalker(walker);
 		
 		userAliases = walker.getUserAliases();
 		resultTypes = walker.getResultTypes();
 		includeInResultRow = walker.includeInResultRow();
 		resultRowLength = ArrayHelper.countTrue( includeInResultRow );
 
 		postInstantiate();
 
 	}
 	
 	public ScrollableResults scroll(SessionImplementor session, ScrollMode scrollMode) 
 	throws HibernateException {
 		QueryParameters qp = translator.getQueryParameters();
 		qp.setScrollMode(scrollMode);
 		return scroll(qp, resultTypes, null, session);
 	}
 
 	public List list(SessionImplementor session) 
 	throws HibernateException {
 		return list( session, translator.getQueryParameters(), querySpaces, resultTypes );
 
 	}
 	@Override
 	protected String[] getResultRowAliases() {
 		return userAliases;
 	}
 	@Override
 	protected ResultTransformer resolveResultTransformer(ResultTransformer resultTransformer) {
 		return translator.getRootCriteria().getResultTransformer();
 	}
 	@Override
 	protected boolean areResultSetRowsTransformedImmediately() {
 		return true;
 	}
 	@Override
 	protected boolean[] includeInResultRow() {
 		return includeInResultRow;
 	}
 	@Override
 	protected Object getResultColumnOrRow(Object[] row, ResultTransformer transformer, ResultSet rs, SessionImplementor session)
 	throws SQLException, HibernateException {
 		return resolveResultTransformer( transformer ).transformTuple(
 				getResultRow( row, rs, session),
 				getResultRowAliases()
 		);
 	}
 	@Override
 	protected Object[] getResultRow(Object[] row, ResultSet rs, SessionImplementor session)
 			throws SQLException, HibernateException {
 		final Object[] result;
 		if ( translator.hasProjection() ) {
 			Type[] types = translator.getProjectedTypes();
 			result = new Object[types.length];
 			String[] columnAliases = translator.getProjectedColumnAliases();
 			for ( int i=0, pos=0; i<result.length; i++ ) {
 				int numColumns = types[i].getColumnSpan( session.getFactory() );
 				if ( numColumns > 1 ) {
 			    	String[] typeColumnAliases = ArrayHelper.slice( columnAliases, pos, numColumns );
 					result[i] = types[i].nullSafeGet(rs, typeColumnAliases, session, null);
 				}
 				else {
 					result[i] = types[i].nullSafeGet(rs, columnAliases[pos], session, null);
 				}
 				pos += numColumns;
 			}
 		}
 		else {
 			result = toResultRow( row );
 		}
 		return result;
 	}
 
 	private Object[] toResultRow(Object[] row) {
 		if ( resultRowLength == row.length ) {
 			return row;
 		}
 		else {
 			Object[] result = new Object[ resultRowLength ];
 			int j = 0;
 			for ( int i = 0; i < row.length; i++ ) {
 				if ( includeInResultRow[i] ) result[j++] = row[i];
 			}
 			return result;
 		}
 	}
 
 	public Set getQuerySpaces() {
 		return querySpaces;
 	}
 
 	@Override
 	protected String applyLocks(
 			String sql,
 			QueryParameters parameters,
 			Dialect dialect,
 			List<AfterLoadAction> afterLoadActions) throws QueryException {
 		final LockOptions lockOptions = parameters.getLockOptions();
 		if ( lockOptions == null ||
 			( lockOptions.getLockMode() == LockMode.NONE && lockOptions.getAliasLockCount() == 0 ) ) {
 			return sql;
 		}
 
 		if ( dialect.useFollowOnLocking() ) {
             final LockMode lockMode = determineFollowOnLockMode( lockOptions );
             if( lockMode != LockMode.UPGRADE_SKIPLOCKED ) {
 				// Dialect prefers to perform locking in a separate step
 				LOG.usingFollowOnLocking();
 
 				final LockOptions lockOptionsToUse = new LockOptions( lockMode );
 				lockOptionsToUse.setTimeOut( lockOptions.getTimeOut() );
 				lockOptionsToUse.setScope( lockOptions.getScope() );
 
 				afterLoadActions.add(
 						new AfterLoadAction() {
 								@Override
 								public void afterLoad(SessionImplementor session, Object entity, Loadable persister) {
 									( (Session) session ).buildLockRequest( lockOptionsToUse )
 										.lock( persister.getEntityName(), entity );
 								}
 				        }
 				);
 				parameters.setLockOptions( new LockOptions() );
 				return sql;
 			}
 		}
 		final LockOptions locks = new LockOptions(lockOptions.getLockMode());
 		locks.setScope( lockOptions.getScope());
 		locks.setTimeOut( lockOptions.getTimeOut());
 
 		final Map keyColumnNames = dialect.forUpdateOfColumns() ? new HashMap() : null;
 		final String[] drivingSqlAliases = getAliases();
 		for ( int i = 0; i < drivingSqlAliases.length; i++ ) {
 			final LockMode lockMode = lockOptions.getAliasSpecificLockMode( drivingSqlAliases[i] );
 			if ( lockMode != null ) {
 				final Lockable drivingPersister = ( Lockable ) getEntityPersisters()[i];
 				final String rootSqlAlias = drivingPersister.getRootTableAlias( drivingSqlAliases[i] );
 				locks.setAliasSpecificLockMode( rootSqlAlias, lockMode );
 				if ( keyColumnNames != null ) {
 					keyColumnNames.put( rootSqlAlias, drivingPersister.getRootTableIdentifierColumnNames() );
 				}
 			}
 		}
 		return dialect.applyLocksToSql( sql, locks, keyColumnNames );
 	}
 
 
 	@Override
 	protected LockMode determineFollowOnLockMode(LockOptions lockOptions) {
 		final LockMode lockModeToUse = lockOptions.findGreatestLockMode();
 
 		if ( lockOptions.getAliasLockCount() > 1 ) {
 			// > 1 here because criteria always uses alias map for the root lock mode (under 'this_')
 			LOG.aliasSpecificLockingWithFollowOnLocking( lockModeToUse );
 		}
 
 		return lockModeToUse;
 	}
 	@Override
 	protected LockMode[] getLockModes(LockOptions lockOptions) {
 		final String[] entityAliases = getAliases();
 		if ( entityAliases == null ) {
 			return null;
 		}
 		final int size = entityAliases.length;
 		LockMode[] lockModesArray = new LockMode[size];
 		for ( int i=0; i<size; i++ ) {
 			LockMode lockMode = lockOptions.getAliasSpecificLockMode( entityAliases[i] );
 			lockModesArray[i] = lockMode==null ? lockOptions.getLockMode() : lockMode;
 		}
 		return lockModesArray;
 	}
 	@Override
 	protected boolean isSubselectLoadingEnabled() {
 		return hasSubselectLoadableCollections();
 	}
 	@Override
 	protected List getResultList(List results, ResultTransformer resultTransformer) {
 		return resolveResultTransformer( resultTransformer ).transformList( results );
 	}
 	@Override
 	protected String getQueryIdentifier() { 
 		return "[CRITERIA] " + getSQLString(); 
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/custom/CustomLoader.java b/hibernate-core/src/main/java/org/hibernate/loader/custom/CustomLoader.java
index e8fd1013c6..77e3f15ebc 100755
--- a/hibernate-core/src/main/java/org/hibernate/loader/custom/CustomLoader.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/custom/CustomLoader.java
@@ -1,702 +1,703 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.loader.custom;
 
+import java.io.Serializable;
 import java.sql.ResultSet;
 import java.sql.ResultSetMetaData;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.hql.internal.HolderInstantiator;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.loader.CollectionAliases;
 import org.hibernate.loader.EntityAliases;
 import org.hibernate.loader.Loader;
 import org.hibernate.loader.spi.AfterLoadAction;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 
 /**
  * Extension point for loaders which use a SQL result set with "unexpected" column aliases.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class CustomLoader extends Loader {
 
 	// Currently *not* cachable if autodiscover types is in effect (e.g. "select * ...")
 
 	private final String sql;
-	private final Set querySpaces = new HashSet();
+	private final Set<Serializable> querySpaces = new HashSet<Serializable>();
 	private final Map namedParameterBindPoints;
 
 	private final Queryable[] entityPersisters;
 	private final int[] entiytOwners;
 	private final EntityAliases[] entityAliases;
 
 	private final QueryableCollection[] collectionPersisters;
 	private final int[] collectionOwners;
 	private final CollectionAliases[] collectionAliases;
 
 	private final LockMode[] lockModes;
 
 	private boolean[] includeInResultRow;
 
 //	private final String[] sqlAliases;
 //	private final String[] sqlAliasSuffixes;
 	private final ResultRowProcessor rowProcessor;
 
 	// this is only needed (afaict) for processing results from the query cache;
 	// however, this cannot possibly work in the case of discovered types...
 	private Type[] resultTypes;
 
 	// this is only needed (afaict) for ResultTransformer processing...
 	private String[] transformerAliases;
 
 	public CustomLoader(CustomQuery customQuery, SessionFactoryImplementor factory) {
 		super( factory );
 
 		this.sql = customQuery.getSQL();
 		this.querySpaces.addAll( customQuery.getQuerySpaces() );
 		this.namedParameterBindPoints = customQuery.getNamedParameterBindPoints();
 
 		List entityPersisters = new ArrayList();
 		List entityOwners = new ArrayList();
 		List entityAliases = new ArrayList();
 
 		List collectionPersisters = new ArrayList();
 		List collectionOwners = new ArrayList();
 		List collectionAliases = new ArrayList();
 
 		List lockModes = new ArrayList();
 		List resultColumnProcessors = new ArrayList();
 		List nonScalarReturnList = new ArrayList();
 		List resultTypes = new ArrayList();
 		List specifiedAliases = new ArrayList();
 		int returnableCounter = 0;
 		boolean hasScalars = false;
 
 		List includeInResultRowList = new ArrayList();
 
 		Iterator itr = customQuery.getCustomQueryReturns().iterator();
 		while ( itr.hasNext() ) {
 			final Return rtn = ( Return ) itr.next();
 			if ( rtn instanceof ScalarReturn ) {
 				ScalarReturn scalarRtn = ( ScalarReturn ) rtn;
 				resultTypes.add( scalarRtn.getType() );
 				specifiedAliases.add( scalarRtn.getColumnAlias() );
 				resultColumnProcessors.add(
 						new ScalarResultColumnProcessor(
 								StringHelper.unquote( scalarRtn.getColumnAlias(), factory.getDialect() ),
 								scalarRtn.getType()
 						)
 				);
 				includeInResultRowList.add( true );
 				hasScalars = true;
 			}
 			else if ( rtn instanceof RootReturn ) {
 				RootReturn rootRtn = ( RootReturn ) rtn;
 				Queryable persister = ( Queryable ) factory.getEntityPersister( rootRtn.getEntityName() );
 				entityPersisters.add( persister );
 				lockModes.add( (rootRtn.getLockMode()) );
 				resultColumnProcessors.add( new NonScalarResultColumnProcessor( returnableCounter++ ) );
 				nonScalarReturnList.add( rtn );
 				entityOwners.add( -1 );
 				resultTypes.add( persister.getType() );
 				specifiedAliases.add( rootRtn.getAlias() );
 				entityAliases.add( rootRtn.getEntityAliases() );
 				ArrayHelper.addAll( querySpaces, persister.getQuerySpaces() );
 				includeInResultRowList.add( true );
 			}
 			else if ( rtn instanceof CollectionReturn ) {
 				CollectionReturn collRtn = ( CollectionReturn ) rtn;
 				String role = collRtn.getOwnerEntityName() + "." + collRtn.getOwnerProperty();
 				QueryableCollection persister = ( QueryableCollection ) factory.getCollectionPersister( role );
 				collectionPersisters.add( persister );
 				lockModes.add( collRtn.getLockMode() );
 				resultColumnProcessors.add( new NonScalarResultColumnProcessor( returnableCounter++ ) );
 				nonScalarReturnList.add( rtn );
 				collectionOwners.add( -1 );
 				resultTypes.add( persister.getType() );
 				specifiedAliases.add( collRtn.getAlias() );
 				collectionAliases.add( collRtn.getCollectionAliases() );
 				// determine if the collection elements are entities...
 				Type elementType = persister.getElementType();
 				if ( elementType.isEntityType() ) {
 					Queryable elementPersister = ( Queryable ) ( ( EntityType ) elementType ).getAssociatedJoinable( factory );
 					entityPersisters.add( elementPersister );
 					entityOwners.add( -1 );
 					entityAliases.add( collRtn.getElementEntityAliases() );
 					ArrayHelper.addAll( querySpaces, elementPersister.getQuerySpaces() );
 				}
 				includeInResultRowList.add( true );
 			}
 			else if ( rtn instanceof EntityFetchReturn ) {
 				EntityFetchReturn fetchRtn = ( EntityFetchReturn ) rtn;
 				NonScalarReturn ownerDescriptor = fetchRtn.getOwner();
 				int ownerIndex = nonScalarReturnList.indexOf( ownerDescriptor );
 				entityOwners.add( ownerIndex );
 				lockModes.add( fetchRtn.getLockMode() );
 				Queryable ownerPersister = determineAppropriateOwnerPersister( ownerDescriptor );
 				EntityType fetchedType = ( EntityType ) ownerPersister.getPropertyType( fetchRtn.getOwnerProperty() );
 				String entityName = fetchedType.getAssociatedEntityName( getFactory() );
 				Queryable persister = ( Queryable ) factory.getEntityPersister( entityName );
 				entityPersisters.add( persister );
 				nonScalarReturnList.add( rtn );
 				specifiedAliases.add( fetchRtn.getAlias() );
 				entityAliases.add( fetchRtn.getEntityAliases() );
 				ArrayHelper.addAll( querySpaces, persister.getQuerySpaces() );
 				includeInResultRowList.add( false );
 			}
 			else if ( rtn instanceof CollectionFetchReturn ) {
 				CollectionFetchReturn fetchRtn = ( CollectionFetchReturn ) rtn;
 				NonScalarReturn ownerDescriptor = fetchRtn.getOwner();
 				int ownerIndex = nonScalarReturnList.indexOf( ownerDescriptor );
 				collectionOwners.add( ownerIndex );
 				lockModes.add( fetchRtn.getLockMode() );
 				Queryable ownerPersister = determineAppropriateOwnerPersister( ownerDescriptor );
 				String role = ownerPersister.getEntityName() + '.' + fetchRtn.getOwnerProperty();
 				QueryableCollection persister = ( QueryableCollection ) factory.getCollectionPersister( role );
 				collectionPersisters.add( persister );
 				nonScalarReturnList.add( rtn );
 				specifiedAliases.add( fetchRtn.getAlias() );
 				collectionAliases.add( fetchRtn.getCollectionAliases() );
 				// determine if the collection elements are entities...
 				Type elementType = persister.getElementType();
 				if ( elementType.isEntityType() ) {
 					Queryable elementPersister = ( Queryable ) ( ( EntityType ) elementType ).getAssociatedJoinable( factory );
 					entityPersisters.add( elementPersister );
 					entityOwners.add( ownerIndex );
 					entityAliases.add( fetchRtn.getElementEntityAliases() );
 					ArrayHelper.addAll( querySpaces, elementPersister.getQuerySpaces() );
 				}
 				includeInResultRowList.add( false );
 			}
 			else {
 				throw new HibernateException( "unexpected custom query return type : " + rtn.getClass().getName() );
 			}
 		}
 
 		this.entityPersisters = new Queryable[ entityPersisters.size() ];
 		for ( int i = 0; i < entityPersisters.size(); i++ ) {
 			this.entityPersisters[i] = ( Queryable ) entityPersisters.get( i );
 		}
 		this.entiytOwners = ArrayHelper.toIntArray( entityOwners );
 		this.entityAliases = new EntityAliases[ entityAliases.size() ];
 		for ( int i = 0; i < entityAliases.size(); i++ ) {
 			this.entityAliases[i] = ( EntityAliases ) entityAliases.get( i );
 		}
 
 		this.collectionPersisters = new QueryableCollection[ collectionPersisters.size() ];
 		for ( int i = 0; i < collectionPersisters.size(); i++ ) {
 			this.collectionPersisters[i] = ( QueryableCollection ) collectionPersisters.get( i );
 		}
 		this.collectionOwners = ArrayHelper.toIntArray( collectionOwners );
 		this.collectionAliases = new CollectionAliases[ collectionAliases.size() ];
 		for ( int i = 0; i < collectionAliases.size(); i++ ) {
 			this.collectionAliases[i] = ( CollectionAliases ) collectionAliases.get( i );
 		}
 
 		this.lockModes = new LockMode[ lockModes.size() ];
 		for ( int i = 0; i < lockModes.size(); i++ ) {
 			this.lockModes[i] = ( LockMode ) lockModes.get( i );
 		}
 
 		this.resultTypes = ArrayHelper.toTypeArray( resultTypes );
 		this.transformerAliases = ArrayHelper.toStringArray( specifiedAliases );
 
 		this.rowProcessor = new ResultRowProcessor(
 				hasScalars,
 		        ( ResultColumnProcessor[] ) resultColumnProcessors.toArray( new ResultColumnProcessor[ resultColumnProcessors.size() ] )
 		);
 
 		this.includeInResultRow = ArrayHelper.toBooleanArray( includeInResultRowList );
 	}
 
 	private Queryable determineAppropriateOwnerPersister(NonScalarReturn ownerDescriptor) {
 		String entityName = null;
 		if ( ownerDescriptor instanceof RootReturn ) {
 			entityName = ( ( RootReturn ) ownerDescriptor ).getEntityName();
 		}
 		else if ( ownerDescriptor instanceof CollectionReturn ) {
 			CollectionReturn collRtn = ( CollectionReturn ) ownerDescriptor;
 			String role = collRtn.getOwnerEntityName() + "." + collRtn.getOwnerProperty();
 			CollectionPersister persister = getFactory().getCollectionPersister( role );
 			EntityType ownerType = ( EntityType ) persister.getElementType();
 			entityName = ownerType.getAssociatedEntityName( getFactory() );
 		}
 		else if ( ownerDescriptor instanceof FetchReturn ) {
 			FetchReturn fetchRtn = ( FetchReturn ) ownerDescriptor;
 			Queryable persister = determineAppropriateOwnerPersister( fetchRtn.getOwner() );
 			Type ownerType = persister.getPropertyType( fetchRtn.getOwnerProperty() );
 			if ( ownerType.isEntityType() ) {
 				entityName = ( ( EntityType ) ownerType ).getAssociatedEntityName( getFactory() );
 			}
 			else if ( ownerType.isCollectionType() ) {
 				Type ownerCollectionElementType = ( ( CollectionType ) ownerType ).getElementType( getFactory() );
 				if ( ownerCollectionElementType.isEntityType() ) {
 					entityName = ( ( EntityType ) ownerCollectionElementType ).getAssociatedEntityName( getFactory() );
 				}
 			}
 		}
 
 		if ( entityName == null ) {
 			throw new HibernateException( "Could not determine fetch owner : " + ownerDescriptor );
 		}
 
 		return ( Queryable ) getFactory().getEntityPersister( entityName );
 	}
 
 	@Override
     protected String getQueryIdentifier() {
 		return sql;
 	}
 
 	@Override
     public String getSQLString() {
 		return sql;
 	}
 
 	public Set getQuerySpaces() {
 		return querySpaces;
 	}
 
 	@Override
     protected LockMode[] getLockModes(LockOptions lockOptions) {
 		return lockModes;
 	}
 
 	@Override
     protected Loadable[] getEntityPersisters() {
 		return entityPersisters;
 	}
 
 	@Override
     protected CollectionPersister[] getCollectionPersisters() {
 		return collectionPersisters;
 	}
 
 	@Override
     protected int[] getCollectionOwners() {
 		return collectionOwners;
 	}
 
 	@Override
     protected int[] getOwners() {
 		return entiytOwners;
 	}
 
 	public List list(SessionImplementor session, QueryParameters queryParameters) throws HibernateException {
 		return list( session, queryParameters, querySpaces, resultTypes );
 	}
 
 	@Override
 	protected String applyLocks(
 			String sql,
 			QueryParameters parameters,
 			Dialect dialect,
 			List<AfterLoadAction> afterLoadActions) throws QueryException {
 		final LockOptions lockOptions = parameters.getLockOptions();
 		if ( lockOptions == null ||
 				( lockOptions.getLockMode() == LockMode.NONE && lockOptions.getAliasLockCount() == 0 ) ) {
 			return sql;
 		}
 
 		// user is request locking, lets see if we can apply locking directly to the SQL...
 
 		// 		some dialects wont allow locking with paging...
 		afterLoadActions.add(
 				new AfterLoadAction() {
 					private final LockOptions originalLockOptions = lockOptions.makeCopy();
 					@Override
 					public void afterLoad(SessionImplementor session, Object entity, Loadable persister) {
 						( (Session) session ).buildLockRequest( originalLockOptions ).lock( persister.getEntityName(), entity );
 					}
 				}
 		);
 		parameters.getLockOptions().setLockMode( LockMode.READ );
 
 		return sql;
 	}
 
 	public ScrollableResults scroll(
 			final QueryParameters queryParameters,
 			final SessionImplementor session) throws HibernateException {
 		return scroll(
 				queryParameters,
 				resultTypes,
 				getHolderInstantiator( queryParameters.getResultTransformer(), getReturnAliasesForTransformer() ),
 				session
 		);
 	}
 
 	static private HolderInstantiator getHolderInstantiator(ResultTransformer resultTransformer, String[] queryReturnAliases) {
 		if ( resultTransformer == null ) {
 			return HolderInstantiator.NOOP_INSTANTIATOR;
 		}
 		else {
 			return new HolderInstantiator(resultTransformer, queryReturnAliases);
 		}
 	}
 
 	@Override
     protected String[] getResultRowAliases() {
 		return transformerAliases;
 	}
 
 	@Override
     protected ResultTransformer resolveResultTransformer(ResultTransformer resultTransformer) {
 		return HolderInstantiator.resolveResultTransformer( null, resultTransformer );
 	}
 
 	@Override
     protected boolean[] includeInResultRow() {
 		return includeInResultRow;
 	}
 
 	@Override
     protected Object getResultColumnOrRow(
 			Object[] row,
 	        ResultTransformer transformer,
 	        ResultSet rs,
 	        SessionImplementor session) throws SQLException, HibernateException {
 		return rowProcessor.buildResultRow( row, rs, transformer != null, session );
 	}
 
 	@Override
     protected Object[] getResultRow(Object[] row, ResultSet rs, SessionImplementor session)
 			throws SQLException, HibernateException {
 		return rowProcessor.buildResultRow( row, rs, session );
 	}
 
 	@Override
     protected List getResultList(List results, ResultTransformer resultTransformer) throws QueryException {
 		// meant to handle dynamic instantiation queries...(Copy from QueryLoader)
 		HolderInstantiator holderInstantiator = HolderInstantiator.getHolderInstantiator(
 				null,
 				resultTransformer,
 				getReturnAliasesForTransformer()
 		);
 		if ( holderInstantiator.isRequired() ) {
 			for ( int i = 0; i < results.size(); i++ ) {
 				Object[] row = ( Object[] ) results.get( i );
 				Object result = holderInstantiator.instantiate(row);
 				results.set( i, result );
 			}
 
 			return resultTransformer.transformList(results);
 		}
 		else {
 			return results;
 		}
 	}
 
 	private String[] getReturnAliasesForTransformer() {
 		return transformerAliases;
 	}
 
 	@Override
     protected EntityAliases[] getEntityAliases() {
 		return entityAliases;
 	}
 
 	@Override
     protected CollectionAliases[] getCollectionAliases() {
 		return collectionAliases;
 	}
 
 	@Override
     public int[] getNamedParameterLocs(String name) throws QueryException {
 		Object loc = namedParameterBindPoints.get( name );
 		if ( loc == null ) {
 			throw new QueryException(
 					"Named parameter does not appear in Query: " + name,
 					sql
 			);
 		}
 		if ( loc instanceof Integer ) {
 			return new int[] { (Integer) loc };
 		}
 		else {
 			return ArrayHelper.toIntArray( ( List ) loc );
 		}
 	}
 
 
 	public class ResultRowProcessor {
 		private final boolean hasScalars;
 		private ResultColumnProcessor[] columnProcessors;
 
 		public ResultRowProcessor(boolean hasScalars, ResultColumnProcessor[] columnProcessors) {
 			this.hasScalars = hasScalars || ( columnProcessors == null || columnProcessors.length == 0 );
 			this.columnProcessors = columnProcessors;
 		}
 
 		public void prepareForAutoDiscovery(Metadata metadata) throws SQLException {
 			if ( columnProcessors == null || columnProcessors.length == 0 ) {
 				int columns = metadata.getColumnCount();
 				columnProcessors = new ResultColumnProcessor[ columns ];
 				for ( int i = 1; i <= columns; i++ ) {
 					columnProcessors[ i - 1 ] = new ScalarResultColumnProcessor( i );
 				}
 
 			}
 		}
 
 		/**
 		 * Build a logical result row.
 		 * <p/>
 		 * At this point, Loader has already processed all non-scalar result data.  We
 		 * just need to account for scalar result data here...
 		 *
 		 * @param data Entity data defined as "root returns" and already handled by the
 		 * normal Loader mechanism.
 		 * @param resultSet The JDBC result set (positioned at the row currently being processed).
 		 * @param hasTransformer Does this query have an associated {@link ResultTransformer}
 		 * @param session The session from which the query request originated.
 		 * @return The logical result row
 		 * @throws SQLException
 		 * @throws HibernateException
 		 */
 		public Object buildResultRow(
 				Object[] data,
 				ResultSet resultSet,
 				boolean hasTransformer,
 				SessionImplementor session) throws SQLException, HibernateException {
 			Object[] resultRow = buildResultRow( data, resultSet, session );
 			return ( hasTransformer )
 			       ? resultRow
 			       : ( resultRow.length == 1 )
 			         ? resultRow[0]
 			         : resultRow;
 		}
 		public Object[] buildResultRow(
 				Object[] data,
 				ResultSet resultSet,
 				SessionImplementor session) throws SQLException, HibernateException {
 			Object[] resultRow;
 			if ( !hasScalars ) {
 				resultRow = data;
 			}
 			else {
 				// build an array with indices equal to the total number
 				// of actual returns in the result Hibernate will return
 				// for this query (scalars + non-scalars)
 				resultRow = new Object[ columnProcessors.length ];
 				for ( int i = 0; i < columnProcessors.length; i++ ) {
 					resultRow[i] = columnProcessors[i].extract( data, resultSet, session );
 				}
 			}
 
 			return resultRow;
 		}
 	}
 
 	private static interface ResultColumnProcessor {
 		public Object extract(Object[] data, ResultSet resultSet, SessionImplementor session) throws SQLException, HibernateException;
 		public void performDiscovery(Metadata metadata, List<Type> types, List<String> aliases) throws SQLException, HibernateException;
 	}
 
 	public class NonScalarResultColumnProcessor implements ResultColumnProcessor {
 		private final int position;
 
 		public NonScalarResultColumnProcessor(int position) {
 			this.position = position;
 		}
 
 		@Override
 		public Object extract(
 				Object[] data,
 				ResultSet resultSet,
 				SessionImplementor session) throws SQLException, HibernateException {
 			return data[ position ];
 		}
 
 		@Override
 		public void performDiscovery(Metadata metadata, List<Type> types, List<String> aliases) {
 		}
 
 	}
 
 	public class ScalarResultColumnProcessor implements ResultColumnProcessor {
 		private int position = -1;
 		private String alias;
 		private Type type;
 
 		public ScalarResultColumnProcessor(int position) {
 			this.position = position;
 		}
 
 		public ScalarResultColumnProcessor(String alias, Type type) {
 			this.alias = alias;
 			this.type = type;
 		}
 
 		@Override
 		public Object extract(
 				Object[] data,
 				ResultSet resultSet,
 				SessionImplementor session) throws SQLException, HibernateException {
 			return type.nullSafeGet( resultSet, alias, session, null );
 		}
 
 		@Override
 		public void performDiscovery(Metadata metadata, List<Type> types, List<String> aliases) throws SQLException {
 			if ( alias == null ) {
 				alias = metadata.getColumnName( position );
 			}
 			else if ( position < 0 ) {
 				position = metadata.resolveColumnPosition( alias );
 			}
 			if ( type == null ) {
 				type = metadata.getHibernateType( position );
 			}
 			types.add( type );
 			aliases.add( alias );
 		}
 	}
 
 	@Override
     protected void autoDiscoverTypes(ResultSet rs) {
 		try {
 			Metadata metadata = new Metadata( getFactory(), rs );
 			rowProcessor.prepareForAutoDiscovery( metadata );
 
 			List<String> aliases = new ArrayList<String>();
 			List<Type> types = new ArrayList<Type>();
 			for ( int i = 0; i < rowProcessor.columnProcessors.length; i++ ) {
 				rowProcessor.columnProcessors[i].performDiscovery( metadata, types, aliases );
 			}
 
 			// lets make sure we did not end up with duplicate aliases.  this can occur when the user supplied query
 			// did not rename same-named columns.  e.g.:
 			//		select u.username, u2.username from t_user u, t_user u2 ...
 			//
 			// the above will lead to an unworkable situation in most cases (the difference is how the driver/db
 			// handle this situation.  But if the 'aliases' variable contains duplicate names, then we have that
 			// troublesome condition, so lets throw an error.  See HHH-5992
 			final HashSet<String> aliasesSet = new HashSet<String>();
 			for ( String alias : aliases ) {
 				boolean alreadyExisted = !aliasesSet.add( alias );
 				if ( alreadyExisted ) {
 					throw new NonUniqueDiscoveredSqlAliasException(
 							"Encountered a duplicated sql alias [" + alias +
 									"] during auto-discovery of a native-sql query"
 					);
 				}
 			}
 
 			resultTypes = ArrayHelper.toTypeArray( types );
 			transformerAliases = ArrayHelper.toStringArray( aliases );
 		}
 		catch ( SQLException e ) {
 			throw new HibernateException( "Exception while trying to autodiscover types.", e );
 		}
 	}
 
 	private static class Metadata {
 		private final SessionFactoryImplementor factory;
 		private final ResultSet resultSet;
 		private final ResultSetMetaData resultSetMetaData;
 
 		public Metadata(SessionFactoryImplementor factory, ResultSet resultSet) throws HibernateException {
 			try {
 				this.factory = factory;
 				this.resultSet = resultSet;
 				this.resultSetMetaData = resultSet.getMetaData();
 			}
 			catch( SQLException e ) {
 				throw new HibernateException( "Could not extract result set metadata", e );
 			}
 		}
 
 		public int getColumnCount() throws HibernateException {
 			try {
 				return resultSetMetaData.getColumnCount();
 			}
 			catch( SQLException e ) {
 				throw new HibernateException( "Could not determine result set column count", e );
 			}
 		}
 
 		public int resolveColumnPosition(String columnName) throws HibernateException {
 			try {
 				return resultSet.findColumn( columnName );
 			}
 			catch( SQLException e ) {
 				throw new HibernateException( "Could not resolve column name in result set [" + columnName + "]", e );
 			}
 		}
 
 		public String getColumnName(int position) throws HibernateException {
 			try {
 				return factory.getDialect().getColumnAliasExtractor().extractColumnAlias( resultSetMetaData, position );
 			}
 			catch( SQLException e ) {
 				throw new HibernateException( "Could not resolve column name [" + position + "]", e );
 			}
 		}
 
 		public Type getHibernateType(int columnPos) throws SQLException {
 			int columnType = resultSetMetaData.getColumnType( columnPos );
 			int scale = resultSetMetaData.getScale( columnPos );
 			int precision = resultSetMetaData.getPrecision( columnPos );
             int length = precision;
             if ( columnType == 1 && precision == 0 ) {
                 length = resultSetMetaData.getColumnDisplaySize( columnPos );
             }
 			return factory.getTypeResolver().heuristicType(
 					factory.getDialect().getHibernateTypeName(
 							columnType,
 							length,
 							precision,
 							scale
 					)
 			);
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/entity/CollectionElementLoader.java b/hibernate-core/src/main/java/org/hibernate/loader/entity/CollectionElementLoader.java
index cfcd015c6c..4a8f68c6ba 100755
--- a/hibernate-core/src/main/java/org/hibernate/loader/entity/CollectionElementLoader.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/entity/CollectionElementLoader.java
@@ -1,135 +1,135 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.loader.entity;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.List;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.LoadQueryInfluencers;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.loader.JoinWalker;
 import org.hibernate.loader.OuterJoinLoader;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.OuterJoinLoadable;
 import org.hibernate.transform.ResultTransformer;
 import org.hibernate.type.Type;
 
 /**
  *
  *
  * @author Gavin King
  */
 public class CollectionElementLoader extends OuterJoinLoader {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, CollectionElementLoader.class.getName() );
 
 	private final OuterJoinLoadable persister;
 	private final Type keyType;
 	private final Type indexType;
 	private final String entityName;
 
 	public CollectionElementLoader(
 			QueryableCollection collectionPersister,
 			SessionFactoryImplementor factory,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		super( factory, loadQueryInfluencers );
 
 		this.keyType = collectionPersister.getKeyType();
 		this.indexType = collectionPersister.getIndexType();
 		this.persister = (OuterJoinLoadable) collectionPersister.getElementPersister();
 		this.entityName = persister.getEntityName();
 
 		JoinWalker walker = new EntityJoinWalker(
 				persister, 
 				ArrayHelper.join(
 						collectionPersister.getKeyColumnNames(),
 						collectionPersister.toColumns("index")
 				),
 				1, 
 				LockMode.NONE, 
 				factory, 
 				loadQueryInfluencers
 			);
 		initFromWalker( walker );
 
 		postInstantiate();
 
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debugf( "Static select for entity %s: %s", entityName, getSQLString() );
 		}
 
 	}
 
 	public Object loadElement(SessionImplementor session, Object key, Object index)
 	throws HibernateException {
 
 		List list = loadEntity(
 				session,
 				key,
 				index,
 				keyType,
 				indexType,
 				persister
 			);
 
 		if ( list.size()==1 ) {
 			return list.get(0);
 		}
 		else if ( list.size()==0 ) {
 			return null;
 		}
 		else {
 			if ( getCollectionOwners()!=null ) {
 				return list.get(0);
 			}
 			else {
 				throw new HibernateException("More than one row was found");
 			}
 		}
 
 	}
 
 	@Override
     protected Object getResultColumnOrRow(
 		Object[] row,
 		ResultTransformer transformer,
 		ResultSet rs, SessionImplementor session)
 	throws SQLException, HibernateException {
 		return row[row.length-1];
 	}
 
 	@Override
     protected boolean isSingleRowLoader() {
 		return true;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/entity/EntityJoinWalker.java b/hibernate-core/src/main/java/org/hibernate/loader/entity/EntityJoinWalker.java
index e7fa8b5f7a..1b8f6fb6d6 100755
--- a/hibernate-core/src/main/java/org/hibernate/loader/entity/EntityJoinWalker.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/entity/EntityJoinWalker.java
@@ -1,258 +1,258 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.loader.entity;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 
 import org.hibernate.FetchMode;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.LoadQueryInfluencers;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.loader.AbstractEntityJoinWalker;
 import org.hibernate.loader.OuterJoinableAssociation;
 import org.hibernate.loader.PropertyPath;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.OuterJoinLoadable;
 import org.hibernate.sql.JoinType;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 
 /**
  * A walker for loaders that fetch entities
  *
  * @see EntityLoader
  * @author Gavin King
  */
 public class EntityJoinWalker extends AbstractEntityJoinWalker {
 	
 	private final LockOptions lockOptions = new LockOptions();
 	private final int[][] compositeKeyManyToOneTargetIndices;
 
 	public EntityJoinWalker(
 			OuterJoinLoadable persister, 
 			String[] uniqueKey, 
 			int batchSize, 
 			LockMode lockMode,
 			final SessionFactoryImplementor factory,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		super( persister, factory, loadQueryInfluencers );
 
 		this.lockOptions.setLockMode(lockMode);
 		
 		StringBuilder whereCondition = whereString( getAlias(), uniqueKey, batchSize )
 				//include the discriminator and class-level where, but not filters
 				.append( persister.filterFragment( getAlias(), Collections.EMPTY_MAP ) );
 
 		AssociationInitCallbackImpl callback = new AssociationInitCallbackImpl( factory );
 		initAll( whereCondition.toString(), "", lockOptions, callback );
 		this.compositeKeyManyToOneTargetIndices = callback.resolve();
 	}
 
 	public EntityJoinWalker(
 			OuterJoinLoadable persister,
 			String[] uniqueKey,
 			int batchSize,
 			LockOptions lockOptions,
 			SessionFactoryImplementor factory,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		super( persister, factory, loadQueryInfluencers );
 		LockOptions.copy(lockOptions, this.lockOptions);
 
 		StringBuilder whereCondition = whereString( getAlias(), uniqueKey, batchSize )
 				//include the discriminator and class-level where, but not filters
 				.append( persister.filterFragment( getAlias(), Collections.EMPTY_MAP ) );
 
 		AssociationInitCallbackImpl callback = new AssociationInitCallbackImpl( factory );
 		initAll( whereCondition.toString(), "", lockOptions, callback );
 		this.compositeKeyManyToOneTargetIndices = callback.resolve();
 	}
 
 	protected JoinType getJoinType(
 			OuterJoinLoadable persister,
 			PropertyPath path,
 			int propertyNumber,
 			AssociationType associationType,
 			FetchMode metadataFetchMode,
 			CascadeStyle metadataCascadeStyle,
 			String lhsTable,
 			String[] lhsColumns,
 			boolean nullable,
 			int currentDepth) throws MappingException {
 		// NOTE : we override this form here specifically to account for
 		// fetch profiles.
 		// TODO : how to best handle criteria queries?
 		if ( lockOptions.getLockMode().greaterThan( LockMode.READ ) ) {
 			return JoinType.NONE;
 		}
 		if ( isTooDeep( currentDepth )
 				|| ( associationType.isCollectionType() && isTooManyCollections() ) ) {
 			return JoinType.NONE;
 		}
 		if ( !isJoinedFetchEnabledInMapping( metadataFetchMode, associationType )
 				&& !isJoinFetchEnabledByProfile( persister, path, propertyNumber ) ) {
 			return JoinType.NONE;
 		}
 		if ( isDuplicateAssociation( lhsTable, lhsColumns, associationType ) ) {
 			return JoinType.NONE;
 		}
 		return getJoinType( nullable, currentDepth );
 	}
 
 	public String getComment() {
 		return "load " + getPersister().getEntityName();
 	}
 
 	public int[][] getCompositeKeyManyToOneTargetIndices() {
 		return compositeKeyManyToOneTargetIndices;
 	}
 
 	private static class AssociationInitCallbackImpl implements AssociationInitCallback {
 		private final SessionFactoryImplementor factory;
 		private final HashMap<String,OuterJoinableAssociation> associationsByAlias
 				= new HashMap<String, OuterJoinableAssociation>();
 		private final HashMap<String,Integer> positionsByAlias = new HashMap<String, Integer>();
 		private final ArrayList<String> aliasesForAssociationsWithCompositesIds
 				= new ArrayList<String>();
 
 		public AssociationInitCallbackImpl(SessionFactoryImplementor factory) {
 			this.factory = factory;
 		}
 
 		public void associationProcessed(OuterJoinableAssociation oja, int position) {
 			associationsByAlias.put( oja.getRhsAlias(), oja );
 			positionsByAlias.put( oja.getRhsAlias(), position );
 			EntityPersister entityPersister = null;
 			if ( oja.getJoinableType().isCollectionType() ) {
 				entityPersister = ( ( QueryableCollection) oja.getJoinable() ).getElementPersister();
 			}
 			else if ( oja.getJoinableType().isEntityType() ) {
 				entityPersister = ( EntityPersister ) oja.getJoinable();
 			}
 			if ( entityPersister != null
 					&& entityPersister.getIdentifierType().isComponentType()
 					&& ! entityPersister.getEntityMetamodel().getIdentifierProperty().isEmbedded()
 					&& hasAssociation( (CompositeType) entityPersister.getIdentifierType() ) ) {
 				aliasesForAssociationsWithCompositesIds.add( oja.getRhsAlias() );
 			}
 		}
 
 		private boolean hasAssociation(CompositeType componentType) {
 			for ( Type subType : componentType.getSubtypes() ) {
 				if ( subType.isEntityType() ) {
 					return true;
 				}
 				else if ( subType.isComponentType() && hasAssociation( ( (CompositeType) subType ) ) ) {
 					return true;
 				}
 			}
 			return false;
 		}
 
 		public int[][] resolve() {
 			int[][] compositeKeyManyToOneTargetIndices = null;
 			for ( final String aliasWithCompositeId : aliasesForAssociationsWithCompositesIds ) {
 				final OuterJoinableAssociation joinWithCompositeId = associationsByAlias.get( aliasWithCompositeId );
 				final ArrayList<Integer> keyManyToOneTargetIndices = new ArrayList<Integer>();
 				// for each association with a composite id containing key-many-to-one(s), find the bidirectional side of
 				// each key-many-to-one (if exists) to see if it is eager as well.  If so, we need to track the indices
 				EntityPersister entityPersister = null;
 				if ( joinWithCompositeId.getJoinableType().isCollectionType() ) {
 					entityPersister = ( ( QueryableCollection) joinWithCompositeId.getJoinable() ).getElementPersister();
 				}
 				else if ( joinWithCompositeId.getJoinableType().isEntityType() ) {
 					entityPersister = ( EntityPersister ) joinWithCompositeId.getJoinable();
 				}
 
 				findKeyManyToOneTargetIndices(
 						keyManyToOneTargetIndices,
 						joinWithCompositeId,
 						(CompositeType) entityPersister.getIdentifierType()
 				);
 
 				if ( ! keyManyToOneTargetIndices.isEmpty() ) {
 					if ( compositeKeyManyToOneTargetIndices == null ) {
 						compositeKeyManyToOneTargetIndices = new int[ associationsByAlias.size() ][];
 					}
 					int position = positionsByAlias.get( aliasWithCompositeId );
 					compositeKeyManyToOneTargetIndices[position] = new int[ keyManyToOneTargetIndices.size() ];
 					int i = 0;
 					for ( int index : keyManyToOneTargetIndices ) {
 						compositeKeyManyToOneTargetIndices[position][i] = index;
 						i++;
 					}
 				}
 			}
 			return compositeKeyManyToOneTargetIndices;
 		}
 
 		private void findKeyManyToOneTargetIndices(
 				ArrayList<Integer> keyManyToOneTargetIndices,
 				OuterJoinableAssociation joinWithCompositeId,
 				CompositeType componentType) {
 			for ( Type subType : componentType.getSubtypes() ) {
 				if ( subType.isEntityType() ) {
 					Integer index = locateKeyManyToOneTargetIndex( joinWithCompositeId, (EntityType) subType );
 					if ( index != null ) {
 						keyManyToOneTargetIndices.add( index );
 					}
 				}
 				else if ( subType.isComponentType() ) {
 					findKeyManyToOneTargetIndices(
 							keyManyToOneTargetIndices,
 							joinWithCompositeId,
 							(CompositeType) subType
 					);
 				}
 			}
 		}
 
 		private Integer locateKeyManyToOneTargetIndex(OuterJoinableAssociation joinWithCompositeId, EntityType keyManyToOneType) {
 			// the lhs (if one) is a likely candidate
 			if ( joinWithCompositeId.getLhsAlias() != null ) {
 				final OuterJoinableAssociation lhs = associationsByAlias.get( joinWithCompositeId.getLhsAlias() );
 				if ( keyManyToOneType.getAssociatedEntityName( factory ).equals( lhs.getJoinableType().getAssociatedEntityName( factory ) ) ) {
 					return positionsByAlias.get( lhs.getRhsAlias() );
 				}
 			}
 			// otherwise, seek out OuterJoinableAssociation which are RHS of given OuterJoinableAssociation
 			// (joinWithCompositeId)
 			for ( OuterJoinableAssociation oja : associationsByAlias.values() ) {
 				if ( oja.getLhsAlias() != null && oja.getLhsAlias().equals( joinWithCompositeId.getRhsAlias() ) ) {
 					if ( keyManyToOneType.equals( oja.getJoinableType() ) ) {
 						return positionsByAlias.get( oja.getLhsAlias() );
 					}
 				}
 			}
 			return null;
 		}
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/entity/EntityLoader.java b/hibernate-core/src/main/java/org/hibernate/loader/entity/EntityLoader.java
index 0230c4c933..5aa490f944 100644
--- a/hibernate-core/src/main/java/org/hibernate/loader/entity/EntityLoader.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/entity/EntityLoader.java
@@ -1,173 +1,173 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.loader.entity;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.LoadQueryInfluencers;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.persister.entity.OuterJoinLoadable;
 import org.hibernate.type.Type;
 
 /**
  * Loads an entity instance using outerjoin fetching to fetch associated entities.
  * <br>
  * The <tt>EntityPersister</tt> must implement <tt>Loadable</tt>. For other entities,
  * create a customized subclass of <tt>Loader</tt>.
  *
  * @author Gavin King
  */
 public class EntityLoader extends AbstractEntityLoader {
 
 	private final boolean batchLoader;
 	private final int[][] compositeKeyManyToOneTargetIndices;
 
 	public EntityLoader(
 			OuterJoinLoadable persister,
 			LockMode lockMode,
 			SessionFactoryImplementor factory,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		this( persister, 1, lockMode, factory, loadQueryInfluencers );
 	}
 
 	public EntityLoader(
 			OuterJoinLoadable persister,
 			LockOptions lockOptions,
 			SessionFactoryImplementor factory,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		this( persister, 1, lockOptions, factory, loadQueryInfluencers );
 	}
 
 	public EntityLoader(
 			OuterJoinLoadable persister,
 			int batchSize,
 			LockMode lockMode,
 			SessionFactoryImplementor factory,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		this(
 				persister,
 				persister.getIdentifierColumnNames(),
 				persister.getIdentifierType(),
 				batchSize,
 				lockMode,
 				factory,
 				loadQueryInfluencers
 			);
 	}
 
 	public EntityLoader(
 			OuterJoinLoadable persister,
 			int batchSize,
 			LockOptions lockOptions,
 			SessionFactoryImplementor factory,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		this(
 				persister,
 				persister.getIdentifierColumnNames(),
 				persister.getIdentifierType(),
 				batchSize,
 				lockOptions,
 				factory,
 				loadQueryInfluencers
 			);
 	}
 
 	public EntityLoader(
 			OuterJoinLoadable persister,
 			String[] uniqueKey,
 			Type uniqueKeyType,
 			int batchSize,
 			LockMode lockMode,
 			SessionFactoryImplementor factory,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		super( persister, uniqueKeyType, factory, loadQueryInfluencers );
 
 		EntityJoinWalker walker = new EntityJoinWalker(
 				persister,
 				uniqueKey,
 				batchSize,
 				lockMode,
 				factory,
 				loadQueryInfluencers
 		);
 		initFromWalker( walker );
 		this.compositeKeyManyToOneTargetIndices = walker.getCompositeKeyManyToOneTargetIndices();
 		postInstantiate();
 
 		batchLoader = batchSize > 1;
 
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debugf( "Static select for entity %s [%s]: %s", entityName, lockMode, getSQLString() );
 		}
 	}
 
 	public EntityLoader(
 			OuterJoinLoadable persister,
 			String[] uniqueKey,
 			Type uniqueKeyType,
 			int batchSize,
 			LockOptions lockOptions,
 			SessionFactoryImplementor factory,
 			LoadQueryInfluencers loadQueryInfluencers) throws MappingException {
 		super( persister, uniqueKeyType, factory, loadQueryInfluencers );
 
 		EntityJoinWalker walker = new EntityJoinWalker(
 				persister,
 				uniqueKey,
 				batchSize,
 				lockOptions,
 				factory,
 				loadQueryInfluencers
 		);
 		initFromWalker( walker );
 		this.compositeKeyManyToOneTargetIndices = walker.getCompositeKeyManyToOneTargetIndices();
 		postInstantiate();
 
 		batchLoader = batchSize > 1;
 
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debugf( "Static select for entity %s [%s:%s]: %s",
 					entityName,
 					lockOptions.getLockMode(),
 					lockOptions.getTimeOut(),
 					getSQLString() );
 		}
 	}
 
 	public Object loadByUniqueKey(SessionImplementor session,Object key) {
 		return load( session, key, null, null, LockOptions.NONE );
 	}
 
 	@Override
     protected boolean isSingleRowLoader() {
 		return !batchLoader;
 	}
 
 	@Override
     public int[][] getCompositeKeyManyToOneTargetIndices() {
 		return compositeKeyManyToOneTargetIndices;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/internal/AbstractLoadQueryImpl.java b/hibernate-core/src/main/java/org/hibernate/loader/internal/AbstractLoadQueryImpl.java
index 37e6a8d3d7..15ba337255 100755
--- a/hibernate-core/src/main/java/org/hibernate/loader/internal/AbstractLoadQueryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/internal/AbstractLoadQueryImpl.java
@@ -1,313 +1,313 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.loader.internal;
 import java.util.List;
 
 import org.hibernate.MappingException;
 import org.hibernate.engine.internal.JoinHelper;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.loader.CollectionAliases;
 import org.hibernate.loader.EntityAliases;
 import org.hibernate.loader.spi.JoinableAssociation;
 import org.hibernate.loader.spi.LoadQueryAliasResolutionContext;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.Joinable;
 import org.hibernate.sql.ConditionFragment;
 import org.hibernate.sql.DisjunctionFragment;
 import org.hibernate.sql.InFragment;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.sql.JoinType;
 
 /**
  * Represents a generic load query used for generating SQL.
  *
  * This code is based on the SQL generation code originally in
  * org.hibernate.loader.JoinWalker.
  *
  * @author Gavin King
  * @author Jon Lipsky
  * @author Gail Badner
  */
 public abstract class AbstractLoadQueryImpl {
 
 	private final List<JoinableAssociation> associations;
 
 	protected AbstractLoadQueryImpl(List<JoinableAssociation> associations) {
 		this.associations = associations;
 	}
 
 	protected String orderBy(final String orderBy, LoadQueryAliasResolutionContext aliasResolutionContext) {
 		return mergeOrderings( orderBy( associations, aliasResolutionContext ), orderBy );
 	}
 
 	protected static String mergeOrderings(String ordering1, String ordering2) {
 		if ( ordering1.length() == 0 ) {
 			return ordering2;
 		}
 		else if ( ordering2.length() == 0 ) {
 			return ordering1;
 		}
 		else {
 			return ordering1 + ", " + ordering2;
 		}
 	}
 
 	/**
 	 * Generate a sequence of <tt>LEFT OUTER JOIN</tt> clauses for the given associations.
 	 */
 	protected final JoinFragment mergeOuterJoins(SessionFactoryImplementor factory, LoadQueryAliasResolutionContext aliasResolutionContext)
 	throws MappingException {
 		JoinFragment joinFragment = factory.getDialect().createOuterJoinFragment();
 		JoinableAssociation previous = null;
 		for ( JoinableAssociation association : associations ) {
 			final String rhsAlias = aliasResolutionContext.resolveAssociationRhsTableAlias( association );
 			final String[] aliasedLhsColumnNames = aliasResolutionContext.resolveAssociationAliasedLhsColumnNames(
 					association
 			);
 			final String[] rhsColumnNames = JoinHelper.getRHSColumnNames( association.getAssociationType(), factory );
 			final String on = resolveOnCondition( factory, association, aliasResolutionContext );
 			if ( previous != null && previous.isManyToManyWith( association ) ) {
 				addManyToManyJoin(
 						joinFragment,
 						association,
 						( QueryableCollection ) previous.getJoinable(),
 						rhsAlias,
 						aliasedLhsColumnNames,
 						rhsColumnNames,
 						on
 				);
 			}
 			else {
 				addJoins(
 						joinFragment,
 						association,
 						rhsAlias,
 						aliasedLhsColumnNames,
 						rhsColumnNames,
 						on
 				);
 			}
 			previous = association;
 		}
 		return joinFragment;
 	}
 
 	/**
 	 * Get the order by string required for collection fetching
 	 */
 	// TODO: why is this static?
 	protected static String orderBy(
 			List<JoinableAssociation> associations,
 			LoadQueryAliasResolutionContext aliasResolutionContext)
 	throws MappingException {
 		StringBuilder buf = new StringBuilder();
 		JoinableAssociation previous = null;
 		for ( JoinableAssociation association : associations ) {
 			final String rhsAlias = aliasResolutionContext.resolveAssociationRhsTableAlias( association );
 			if ( association.getJoinType() == JoinType.LEFT_OUTER_JOIN ) { // why does this matter?
 				if ( association.getJoinable().isCollection() ) {
 					final QueryableCollection queryableCollection = (QueryableCollection) association.getJoinable();
 					if ( queryableCollection.hasOrdering() ) {
 						final String orderByString = queryableCollection.getSQLOrderByString( rhsAlias );
 						buf.append( orderByString ).append(", ");
 					}
 				}
 				else {
 					// it might still need to apply a collection ordering based on a
 					// many-to-many defined order-by...
 					if ( previous != null && previous.getJoinable().isCollection() ) {
 						final QueryableCollection queryableCollection = (QueryableCollection) previous.getJoinable();
 						if ( queryableCollection.isManyToMany() && previous.isManyToManyWith( association ) ) {
 							if ( queryableCollection.hasManyToManyOrdering() ) {
 								final String orderByString = queryableCollection.getManyToManyOrderByString( rhsAlias );
 								buf.append( orderByString ).append(", ");
 							}
 						}
 					}
 				}
 			}
 			previous = association;
 		}
 		if ( buf.length() > 0 ) {
 			buf.setLength( buf.length() - 2 );
 		}
 		return buf.toString();
 	}
 
 	/**
 	 * Render the where condition for a (batch) load by identifier / collection key
 	 */
 	protected StringBuilder whereString(String alias, String[] columnNames, int batchSize) {
 		if ( columnNames.length==1 ) {
 			// if not a composite key, use "foo in (?, ?, ?)" for batching
 			// if no batch, and not a composite key, use "foo = ?"
 			InFragment in = new InFragment().setColumn( alias, columnNames[0] );
 			for ( int i = 0; i < batchSize; i++ ) {
 				in.addValue( "?" );
 			}
 			return new StringBuilder( in.toFragmentString() );
 		}
 		else {
 			//a composite key
 			ConditionFragment byId = new ConditionFragment()
 					.setTableAlias(alias)
 					.setCondition( columnNames, "?" );
 	
 			StringBuilder whereString = new StringBuilder();
 			if ( batchSize==1 ) {
 				// if no batch, use "foo = ? and bar = ?"
 				whereString.append( byId.toFragmentString() );
 			}
 			else {
 				// if a composite key, use "( (foo = ? and bar = ?) or (foo = ? and bar = ?) )" for batching
 				whereString.append('('); //TODO: unnecessary for databases with ANSI-style joins
 				DisjunctionFragment df = new DisjunctionFragment();
 				for ( int i=0; i<batchSize; i++ ) {
 					df.addCondition(byId);
 				}
 				whereString.append( df.toFragmentString() );
 				whereString.append(')'); //TODO: unnecessary for databases with ANSI-style joins
 			}
 			return whereString;
 		}
 	}
 
 	/**
 	 * Generate a select list of columns containing all properties of the entity classes
 	 */
 	protected final String associationSelectString(LoadQueryAliasResolutionContext aliasResolutionContext)
 	throws MappingException {
 
 		if ( associations.size() == 0 ) {
 			return "";
 		}
 		else {
 			StringBuilder buf = new StringBuilder( associations.size() * 100 );
 			for ( int i=0; i<associations.size(); i++ ) {
 				JoinableAssociation association = associations.get( i );
 				JoinableAssociation next = ( i == associations.size() - 1 )
 				        ? null
 				        : associations.get( i + 1 );
 				final Joinable joinable = association.getJoinable();
 				final EntityAliases currentEntityAliases =
 						association.getCurrentEntityReference() == null ?
 								null :
 								aliasResolutionContext.resolveEntityColumnAliases( association.getCurrentEntityReference() );
 				final CollectionAliases currentCollectionAliases =
 						association.getCurrentCollectionReference() == null ?
 								null :
 								aliasResolutionContext.resolveCollectionColumnAliases( association.getCurrentCollectionReference() );
 				final String selectFragment = joinable.selectFragment(
 						next == null ? null : next.getJoinable(),
 						next == null ? null : aliasResolutionContext.resolveAssociationRhsTableAlias( next ),
 						aliasResolutionContext.resolveAssociationRhsTableAlias( association ),
 						currentEntityAliases == null ? null : currentEntityAliases.getSuffix(),
 						currentCollectionAliases == null ? null : currentCollectionAliases.getSuffix(),
 						association.getJoinType()==JoinType.LEFT_OUTER_JOIN
 				);
 				if (selectFragment.trim().length() > 0) {
 					// TODO: shouldn't the append of selectFragment be outside this if statement???
 					buf.append(", ").append( selectFragment );
 				}
 			}
 			return buf.toString();
 		}
 	}
 
 	private void addJoins(
 			JoinFragment joinFragment,
 			JoinableAssociation association,
 			String rhsAlias,
 			String[] aliasedLhsColumnNames,
 			String[] rhsColumnNames,
 			String on) throws MappingException {
 		joinFragment.addJoin(
 				association.getJoinable().getTableName(),
 				rhsAlias,
 				aliasedLhsColumnNames,
 				rhsColumnNames,
 				association.getJoinType(),
 				on
 		);
 		joinFragment.addJoins(
 				association.getJoinable().fromJoinFragment( rhsAlias, false, true ),
 				association.getJoinable().whereJoinFragment( rhsAlias, false, true )
 		);
 	}
 
 	private String resolveOnCondition(
 			SessionFactoryImplementor factory,
 			JoinableAssociation joinableAssociation,
 			LoadQueryAliasResolutionContext aliasResolutionContext) {
 		final String withClause = StringHelper.isEmpty( joinableAssociation.getWithClause() ) ?
 				"" :
 				" and ( " + joinableAssociation.getWithClause() + " )";
 		return joinableAssociation.getAssociationType().getOnCondition(
 				aliasResolutionContext.resolveAssociationRhsTableAlias( joinableAssociation ),
 				factory,
 				joinableAssociation.getEnabledFilters()
 		) + withClause;
 	}
 
 	/*
 	public void validateJoin(String path) throws MappingException {
 		if ( rhsColumns==null || lhsColumns==null
 				|| lhsColumns.length!=rhsColumns.length || lhsColumns.length==0 ) {
 			throw new MappingException("invalid join columns for association: " + path);
 		}
 	}
 	*/
 
 	private void addManyToManyJoin(
 			JoinFragment outerjoin,
 			JoinableAssociation association,
 			QueryableCollection collection,
 			String rhsAlias,
 			String[] aliasedLhsColumnNames,
 			String[] rhsColumnNames,
 			String on) throws MappingException {
 		final String manyToManyFilter = collection.getManyToManyFilterFragment(
 				rhsAlias,
 				association.getEnabledFilters()
 		);
 		String condition = "".equals( manyToManyFilter )
 				? on
 				: "".equals( on )
 				? manyToManyFilter
 				: on + " and " + manyToManyFilter;
 		outerjoin.addJoin(
 				association.getJoinable().getTableName(),
 				rhsAlias,
 				aliasedLhsColumnNames,
 				rhsColumnNames,
 				association.getJoinType(),
 				condition
 		);
 		outerjoin.addJoins(
 				association.getJoinable().fromJoinFragment( rhsAlias, false, true ),
 				association.getJoinable().whereJoinFragment( rhsAlias, false, true )
 		);
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/internal/CollectionJoinableAssociationImpl.java b/hibernate-core/src/main/java/org/hibernate/loader/internal/CollectionJoinableAssociationImpl.java
index 254c1a9c33..9e516a4503 100644
--- a/hibernate-core/src/main/java/org/hibernate/loader/internal/CollectionJoinableAssociationImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/internal/CollectionJoinableAssociationImpl.java
@@ -1,93 +1,93 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.loader.internal;
 
 import java.util.Map;
 
 import org.hibernate.Filter;
 import org.hibernate.MappingException;
 import org.hibernate.loader.plan.spi.CollectionFetch;
 import org.hibernate.loader.plan.spi.EntityReference;
 import org.hibernate.loader.spi.JoinableAssociation;
 import org.hibernate.persister.collection.QueryableCollection;
 import org.hibernate.persister.entity.Joinable;
 import org.hibernate.type.AssociationType;
 
 /**
  * This class represents a joinable collection association.
  *
  * @author Gail Badner
  */
 
 public class CollectionJoinableAssociationImpl extends AbstractJoinableAssociationImpl {
 
 	private final AssociationType joinableType;
 	private final Joinable joinable;
 
 	public CollectionJoinableAssociationImpl(
 			CollectionFetch collectionFetch,
 			EntityReference currentEntityReference,
 			String withClause,
 			boolean hasRestriction,
 			Map<String, Filter> enabledFilters) throws MappingException {
 		super(
 				collectionFetch,
 				currentEntityReference,
 				collectionFetch,
 				withClause,
 				hasRestriction,
 				enabledFilters
 		);
 		this.joinableType = collectionFetch.getCollectionPersister().getCollectionType();
 		this.joinable = (Joinable) collectionFetch.getCollectionPersister();
 	}
 
 	@Override
 	public AssociationType getAssociationType() {
 		return joinableType;
 	}
 
 	@Override
 	public Joinable getJoinable() {
 		return joinable;
 	}
 
 	@Override
 	public boolean isCollection() {
 		return true;
 	}
 
 	@Override
 	public boolean isManyToManyWith(JoinableAssociation other) {
 		QueryableCollection persister = ( QueryableCollection ) joinable;
 		if ( persister.isManyToMany() ) {
 			return persister.getElementType() == other.getAssociationType();
 		}
 		return false;
 	}
 
 	protected boolean isOneToOne() {
 		return false;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/internal/EntityJoinableAssociationImpl.java b/hibernate-core/src/main/java/org/hibernate/loader/internal/EntityJoinableAssociationImpl.java
index 84830547d1..1f6b5aaa32 100644
--- a/hibernate-core/src/main/java/org/hibernate/loader/internal/EntityJoinableAssociationImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/internal/EntityJoinableAssociationImpl.java
@@ -1,89 +1,89 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.loader.internal;
 
 import java.util.Map;
 
 import org.hibernate.Filter;
 import org.hibernate.MappingException;
 import org.hibernate.loader.plan.spi.CollectionReference;
 import org.hibernate.loader.plan.spi.EntityFetch;
 import org.hibernate.loader.spi.JoinableAssociation;
 import org.hibernate.persister.entity.Joinable;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.EntityType;
 
 /**
  * This class represents a joinable entity association.
  *
  * @author Gavin King
  */
 public class EntityJoinableAssociationImpl extends AbstractJoinableAssociationImpl {
 
 	private final AssociationType joinableType;
 	private final Joinable joinable;
 
 	public EntityJoinableAssociationImpl(
 			EntityFetch entityFetch,
 			CollectionReference currentCollectionReference,
 			String withClause,
 			boolean hasRestriction,
 			Map<String, Filter> enabledFilters) throws MappingException {
 		super(
 				entityFetch,
 				entityFetch,
 				currentCollectionReference,
 				withClause,
 				hasRestriction,
 				enabledFilters
 		);
 		this.joinableType = entityFetch.getEntityType();
 		this.joinable = (Joinable) entityFetch.getEntityPersister();
 	}
 
 	@Override
 	public AssociationType getAssociationType() {
 		return joinableType;
 	}
 
 	@Override
 	public Joinable getJoinable() {
 		return joinable;
 	}
 
 	@Override
 	public boolean isCollection() {
 		return false;
 	}
 
 	@Override
 	public boolean isManyToManyWith(JoinableAssociation other) {
 		return false;
 	}
 
 	protected boolean isOneToOne() {
 		EntityType entityType = (EntityType) joinableType;
 		return entityType.isOneToOne() /*&& entityType.isReferenceToPrimaryKey()*/;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/internal/EntityLoadQueryImpl.java b/hibernate-core/src/main/java/org/hibernate/loader/internal/EntityLoadQueryImpl.java
index 148c6126c6..eb1612a68d 100755
--- a/hibernate-core/src/main/java/org/hibernate/loader/internal/EntityLoadQueryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/internal/EntityLoadQueryImpl.java
@@ -1,68 +1,68 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.loader.internal;
 import java.util.Collections;
 import java.util.List;
 
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.loader.plan.spi.EntityReturn;
 import org.hibernate.loader.spi.JoinableAssociation;
 import org.hibernate.loader.spi.LoadQueryAliasResolutionContext;
 
 /**
  * Represents an load query for fetching an entity, used for generating SQL.
  *
  * This code is based on the SQL generation code originally in
  * org.hibernate.loader.EntityJoinWalker.
  *
  * @author Gavin King
  * @author Gail Badner
  */
 public class EntityLoadQueryImpl extends AbstractEntityLoadQueryImpl {
 
 	public EntityLoadQueryImpl(
 			EntityReturn entityReturn,
 			List<JoinableAssociation> associations) throws MappingException {
 		super( entityReturn, associations );
 	}
 
 	public String generateSql(
 			String[] uniqueKey,
 			int batchSize,
 			LockMode lockMode,
 			SessionFactoryImplementor factory,
 			LoadQueryAliasResolutionContext aliasResolutionContext) {
 		StringBuilder whereCondition = whereString( resolveEntityReturnAlias( aliasResolutionContext ), uniqueKey, batchSize )
 				//include the discriminator and class-level where, but not filters
 				.append( getPersister().filterFragment( resolveEntityReturnAlias( aliasResolutionContext ), Collections.EMPTY_MAP ) );
 		return generateSql( whereCondition.toString(), "",  new LockOptions().setLockMode( lockMode ), factory, aliasResolutionContext );
 	}
 
 	protected String getComment() {
 		return "load " + getPersister().getEntityName();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/loader/plan/spi/FetchOwnerDelegate.java b/hibernate-core/src/main/java/org/hibernate/loader/plan/spi/FetchOwnerDelegate.java
index a6b25a91dc..350169dab4 100644
--- a/hibernate-core/src/main/java/org/hibernate/loader/plan/spi/FetchOwnerDelegate.java
+++ b/hibernate-core/src/main/java/org/hibernate/loader/plan/spi/FetchOwnerDelegate.java
@@ -1,69 +1,69 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.loader.plan.spi;
 
 import org.hibernate.type.Type;
 
 /**
  * This interface provides a delegate for a fetch owner to obtain details about an owned fetch.
  *
  * @author Gail Badner
  */
 public interface FetchOwnerDelegate {
 	public static interface FetchMetadata {
 		/**
 		 * Is the fetch nullable?
 		 *
 		 * @return true, if the fetch is nullable; false, otherwise.
 		 */
 		public boolean isNullable();
 
 		/**
 		 * Returns the type of the fetched attribute
 		 *
 		 * @return the type of the fetched attribute.
 		 */
 		public Type getType();
 
 		/**
 		 * Generates the SQL select fragments for the specified fetch.  A select fragment is the column and formula
 		 * references.
 		 *
 		 * @param alias The table alias to apply to the fragments (used to qualify column references)
 		 *
 		 * @return the select fragments
 		 */
 		public String[] toSqlSelectFragments(String alias);
 	}
 
 	/**
 	 * Locate the metadata for the specified Fetch.  Allows easier caching of the resolved information.
 	 *
 	 * @param fetch The fetch for which to locate metadata
 	 *
 	 * @return The metadata; never {@code null}, rather an exception is thrown if the information for the fetch cannot
 	 * be located.
 	 */
 	public FetchMetadata locateFetchMetadata(Fetch fetch);
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/lob/ReaderInputStream.java b/hibernate-core/src/main/java/org/hibernate/lob/ReaderInputStream.java
index ba5d4cc43a..2f96eb9ca8 100644
--- a/hibernate-core/src/main/java/org/hibernate/lob/ReaderInputStream.java
+++ b/hibernate-core/src/main/java/org/hibernate/lob/ReaderInputStream.java
@@ -1,44 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.lob;
 import java.io.IOException;
 import java.io.Reader;
 
 /**
  * Exposes a {@link java.io.Reader} as an {@link java.io.InputStream}.
  *
  * @deprecated Should not be used anymore. 
  */
 public class ReaderInputStream extends org.hibernate.engine.jdbc.ReaderInputStream {
 
 	public ReaderInputStream(Reader reader) {
 		super(reader);
 	}
 
 	public int read() throws IOException {
 		return super.read();
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/Collection.java b/hibernate-core/src/main/java/org/hibernate/mapping/Collection.java
index 22cea240b7..b9fc9304f4 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/Collection.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/Collection.java
@@ -1,670 +1,670 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.mapping;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Properties;
 
 import org.hibernate.FetchMode;
 import org.hibernate.MappingException;
 import org.hibernate.cfg.Mappings;
 import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.internal.FilterConfiguration;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.internal.util.collections.EmptyIterator;
 import org.hibernate.type.CollectionType;
 import org.hibernate.type.Type;
 
 /**
  * Mapping for a collection. Subclasses specialize to particular collection styles.
  * 
  * @author Gavin King
  */
 public abstract class Collection implements Fetchable, Value, Filterable {
 
 	public static final String DEFAULT_ELEMENT_COLUMN_NAME = "elt";
 	public static final String DEFAULT_KEY_COLUMN_NAME = "id";
 
 	private final Mappings mappings;
 	private PersistentClass owner;
 
 	private KeyValue key;
 	private Value element;
 	private Table collectionTable;
 	private String role;
 	private boolean lazy;
 	private boolean extraLazy;
 	private boolean inverse;
 	private boolean mutable = true;
 	private boolean subselectLoadable;
 	private String cacheConcurrencyStrategy;
 	private String cacheRegionName;
 	private String orderBy;
 	private String where;
 	private String manyToManyWhere;
 	private String manyToManyOrderBy;
 	private String referencedPropertyName;
 	private String nodeName;
 	private String elementNodeName;
 	private boolean sorted;
 	private Comparator comparator;
 	private String comparatorClassName;
 	private boolean orphanDelete;
 	private int batchSize = -1;
 	private FetchMode fetchMode;
 	private boolean embedded = true;
 	private boolean optimisticLocked = true;
 	private Class collectionPersisterClass;
 	private String typeName;
 	private Properties typeParameters;
 	private final java.util.List filters = new ArrayList();
 	private final java.util.List manyToManyFilters = new ArrayList();
 	private final java.util.Set synchronizedTables = new HashSet();
 
 	private String customSQLInsert;
 	private boolean customInsertCallable;
 	private ExecuteUpdateResultCheckStyle insertCheckStyle;
 	private String customSQLUpdate;
 	private boolean customUpdateCallable;
 	private ExecuteUpdateResultCheckStyle updateCheckStyle;
 	private String customSQLDelete;
 	private boolean customDeleteCallable;
 	private ExecuteUpdateResultCheckStyle deleteCheckStyle;
 	private String customSQLDeleteAll;
 	private boolean customDeleteAllCallable;
 	private ExecuteUpdateResultCheckStyle deleteAllCheckStyle;
 
 	private String loaderName;
 
 	protected Collection(Mappings mappings, PersistentClass owner) {
 		this.mappings = mappings;
 		this.owner = owner;
 	}
 
 	public Mappings getMappings() {
 		return mappings;
 	}
 
 	public boolean isSet() {
 		return false;
 	}
 
 	public KeyValue getKey() {
 		return key;
 	}
 
 	public Value getElement() {
 		return element;
 	}
 
 	public boolean isIndexed() {
 		return false;
 	}
 
 	public Table getCollectionTable() {
 		return collectionTable;
 	}
 
 	public void setCollectionTable(Table table) {
 		this.collectionTable = table;
 	}
 
 	public boolean isSorted() {
 		return sorted;
 	}
 
 	public Comparator getComparator() {
 		if ( comparator == null && comparatorClassName != null ) {
 			try {
 				setComparator( (Comparator) ReflectHelper.classForName( comparatorClassName ).newInstance() );
 			}
 			catch ( Exception e ) {
 				throw new MappingException(
 						"Could not instantiate comparator class [" + comparatorClassName
 						+ "] for collection " + getRole()  
 				);
 			}
 		}
 		return comparator;
 	}
 
 	public boolean isLazy() {
 		return lazy;
 	}
 
 	public void setLazy(boolean lazy) {
 		this.lazy = lazy;
 	}
 
 	public String getRole() {
 		return role;
 	}
 
 	public abstract CollectionType getDefaultCollectionType() throws MappingException;
 
 	public boolean isPrimitiveArray() {
 		return false;
 	}
 
 	public boolean isArray() {
 		return false;
 	}
 
 	public boolean hasFormula() {
 		return false;
 	}
 
 	public boolean isOneToMany() {
 		return element instanceof OneToMany;
 	}
 
 	public boolean isInverse() {
 		return inverse;
 	}
 
 	public String getOwnerEntityName() {
 		return owner.getEntityName();
 	}
 
 	public String getOrderBy() {
 		return orderBy;
 	}
 
 	public void setComparator(Comparator comparator) {
 		this.comparator = comparator;
 	}
 
 	public void setElement(Value element) {
 		this.element = element;
 	}
 
 	public void setKey(KeyValue key) {
 		this.key = key;
 	}
 
 	public void setOrderBy(String orderBy) {
 		this.orderBy = orderBy;
 	}
 
 	public void setRole(String role) {
 		this.role = role;
 	}
 
 	public void setSorted(boolean sorted) {
 		this.sorted = sorted;
 	}
 
 	public void setInverse(boolean inverse) {
 		this.inverse = inverse;
 	}
 
 	public PersistentClass getOwner() {
 		return owner;
 	}
 
 	/**
 	 * @deprecated Inject the owner into constructor.
 	 *
 	 * @param owner The owner
 	 */
 	@Deprecated
     public void setOwner(PersistentClass owner) {
 		this.owner = owner;
 	}
 
 	public String getWhere() {
 		return where;
 	}
 
 	public void setWhere(String where) {
 		this.where = where;
 	}
 
 	public String getManyToManyWhere() {
 		return manyToManyWhere;
 	}
 
 	public void setManyToManyWhere(String manyToManyWhere) {
 		this.manyToManyWhere = manyToManyWhere;
 	}
 
 	public String getManyToManyOrdering() {
 		return manyToManyOrderBy;
 	}
 
 	public void setManyToManyOrdering(String orderFragment) {
 		this.manyToManyOrderBy = orderFragment;
 	}
 
 	public boolean isIdentified() {
 		return false;
 	}
 
 	public boolean hasOrphanDelete() {
 		return orphanDelete;
 	}
 
 	public void setOrphanDelete(boolean orphanDelete) {
 		this.orphanDelete = orphanDelete;
 	}
 
 	public int getBatchSize() {
 		return batchSize;
 	}
 
 	public void setBatchSize(int i) {
 		batchSize = i;
 	}
 
 	public FetchMode getFetchMode() {
 		return fetchMode;
 	}
 
 	public void setFetchMode(FetchMode fetchMode) {
 		this.fetchMode = fetchMode;
 	}
 
 	public void setCollectionPersisterClass(Class persister) {
 		this.collectionPersisterClass = persister;
 	}
 
 	public Class getCollectionPersisterClass() {
 		return collectionPersisterClass;
 	}
 
 	public void validate(Mapping mapping) throws MappingException {
 		if ( getKey().isCascadeDeleteEnabled() && ( !isInverse() || !isOneToMany() ) ) {
 			throw new MappingException(
 				"only inverse one-to-many associations may use on-delete=\"cascade\": " 
 				+ getRole() );
 		}
 		if ( !getKey().isValid( mapping ) ) {
 			throw new MappingException(
 				"collection foreign key mapping has wrong number of columns: "
 				+ getRole()
 				+ " type: "
 				+ getKey().getType().getName() );
 		}
 		if ( !getElement().isValid( mapping ) ) {
 			throw new MappingException( 
 				"collection element mapping has wrong number of columns: "
 				+ getRole()
 				+ " type: "
 				+ getElement().getType().getName() );
 		}
 
 		checkColumnDuplication();
 		
 		if ( elementNodeName!=null && elementNodeName.startsWith("@") ) {
 			throw new MappingException("element node must not be an attribute: " + elementNodeName );
 		}
 		if ( elementNodeName!=null && elementNodeName.equals(".") ) {
 			throw new MappingException("element node must not be the parent: " + elementNodeName );
 		}
 		if ( nodeName!=null && nodeName.indexOf('@')>-1 ) {
 			throw new MappingException("collection node must not be an attribute: " + elementNodeName );
 		}
 	}
 
 	private void checkColumnDuplication(java.util.Set distinctColumns, Iterator columns)
 			throws MappingException {
 		while ( columns.hasNext() ) {
 			Selectable s = (Selectable) columns.next();
 			if ( !s.isFormula() ) {
 				Column col = (Column) s;
 				if ( !distinctColumns.add( col.getName() ) ) {
 					throw new MappingException( "Repeated column in mapping for collection: "
 						+ getRole()
 						+ " column: "
 						+ col.getName() );
 				}
 			}
 		}
 	}
 
 	private void checkColumnDuplication() throws MappingException {
 		HashSet cols = new HashSet();
 		checkColumnDuplication( cols, getKey().getColumnIterator() );
 		if ( isIndexed() ) {
 			checkColumnDuplication( cols, ( (IndexedCollection) this )
 				.getIndex()
 				.getColumnIterator() );
 		}
 		if ( isIdentified() ) {
 			checkColumnDuplication( cols, ( (IdentifierCollection) this )
 				.getIdentifier()
 				.getColumnIterator() );
 		}
 		if ( !isOneToMany() ) {
 			checkColumnDuplication( cols, getElement().getColumnIterator() );
 		}
 	}
 
 	public Iterator<Selectable> getColumnIterator() {
 		return Collections.<Selectable>emptyList().iterator();
 	}
 
 	public int getColumnSpan() {
 		return 0;
 	}
 
 	public Type getType() throws MappingException {
 		return getCollectionType();
 	}
 
 	public CollectionType getCollectionType() {
 		if ( typeName == null ) {
 			return getDefaultCollectionType();
 		}
 		else {
 			return mappings.getTypeResolver()
 					.getTypeFactory()
 					.customCollection( typeName, typeParameters, role, referencedPropertyName );
 		}
 	}
 
 	public boolean isNullable() {
 		return true;
 	}
 
 	public boolean isAlternateUniqueKey() {
 		return false;
 	}
 
 	public Table getTable() {
 		return owner.getTable();
 	}
 
 	public void createForeignKey() {
 	}
 
 	public boolean isSimpleValue() {
 		return false;
 	}
 
 	public boolean isValid(Mapping mapping) throws MappingException {
 		return true;
 	}
 
 	private void createForeignKeys() throws MappingException {
 		// if ( !isInverse() ) { // for inverse collections, let the "other end" handle it
 		if ( referencedPropertyName == null ) {
 			getElement().createForeignKey();
 			key.createForeignKeyOfEntity( getOwner().getEntityName() );
 		}
 		// }
 	}
 
 	abstract void createPrimaryKey();
 
 	public void createAllKeys() throws MappingException {
 		createForeignKeys();
 		if ( !isInverse() ) createPrimaryKey();
 	}
 
 	public String getCacheConcurrencyStrategy() {
 		return cacheConcurrencyStrategy;
 	}
 
 	public void setCacheConcurrencyStrategy(String cacheConcurrencyStrategy) {
 		this.cacheConcurrencyStrategy = cacheConcurrencyStrategy;
 	}
 
 	public void setTypeUsingReflection(String className, String propertyName) {
 	}
 
 	public String getCacheRegionName() {
 		return cacheRegionName == null ? role : cacheRegionName;
 	}
 
 	public void setCacheRegionName(String cacheRegionName) {
 		this.cacheRegionName = cacheRegionName;
 	}
 
 
 
 	public void setCustomSQLInsert(String customSQLInsert, boolean callable, ExecuteUpdateResultCheckStyle checkStyle) {
 		this.customSQLInsert = customSQLInsert;
 		this.customInsertCallable = callable;
 		this.insertCheckStyle = checkStyle;
 	}
 
 	public String getCustomSQLInsert() {
 		return customSQLInsert;
 	}
 
 	public boolean isCustomInsertCallable() {
 		return customInsertCallable;
 	}
 
 	public ExecuteUpdateResultCheckStyle getCustomSQLInsertCheckStyle() {
 		return insertCheckStyle;
 	}
 
 	public void setCustomSQLUpdate(String customSQLUpdate, boolean callable, ExecuteUpdateResultCheckStyle checkStyle) {
 		this.customSQLUpdate = customSQLUpdate;
 		this.customUpdateCallable = callable;
 		this.updateCheckStyle = checkStyle;
 	}
 
 	public String getCustomSQLUpdate() {
 		return customSQLUpdate;
 	}
 
 	public boolean isCustomUpdateCallable() {
 		return customUpdateCallable;
 	}
 
 	public ExecuteUpdateResultCheckStyle getCustomSQLUpdateCheckStyle() {
 		return updateCheckStyle;
 	}
 
 	public void setCustomSQLDelete(String customSQLDelete, boolean callable, ExecuteUpdateResultCheckStyle checkStyle) {
 		this.customSQLDelete = customSQLDelete;
 		this.customDeleteCallable = callable;
 		this.deleteCheckStyle = checkStyle;
 	}
 
 	public String getCustomSQLDelete() {
 		return customSQLDelete;
 	}
 
 	public boolean isCustomDeleteCallable() {
 		return customDeleteCallable;
 	}
 
 	public ExecuteUpdateResultCheckStyle getCustomSQLDeleteCheckStyle() {
 		return deleteCheckStyle;
 	}
 
 	public void setCustomSQLDeleteAll(String customSQLDeleteAll, boolean callable, ExecuteUpdateResultCheckStyle checkStyle) {
 		this.customSQLDeleteAll = customSQLDeleteAll;
 		this.customDeleteAllCallable = callable;
 		this.deleteAllCheckStyle = checkStyle;
 	}
 
 	public String getCustomSQLDeleteAll() {
 		return customSQLDeleteAll;
 	}
 
 	public boolean isCustomDeleteAllCallable() {
 		return customDeleteAllCallable;
 	}
 
 	public ExecuteUpdateResultCheckStyle getCustomSQLDeleteAllCheckStyle() {
 		return deleteAllCheckStyle;
 	}
 
 	public void addFilter(String name, String condition, boolean autoAliasInjection, java.util.Map<String,String> aliasTableMap, java.util.Map<String,String> aliasEntityMap) {
 		filters.add(new FilterConfiguration(name, condition, autoAliasInjection, aliasTableMap, aliasEntityMap, null));
 	}
 	public java.util.List getFilters() {
 		return filters;
 	}
 
 	public void addManyToManyFilter(String name, String condition, boolean autoAliasInjection, java.util.Map<String,String> aliasTableMap, java.util.Map<String,String> aliasEntityMap) {
 		manyToManyFilters.add(new FilterConfiguration(name, condition, autoAliasInjection, aliasTableMap, aliasEntityMap, null));
 	}
 
 	public java.util.List getManyToManyFilters() {
 		return manyToManyFilters;
 	}
 
 	@Override
     public String toString() {
 		return getClass().getName() + '(' + getRole() + ')';
 	}
 
 	public java.util.Set getSynchronizedTables() {
 		return synchronizedTables;
 	}
 
 	public String getLoaderName() {
 		return loaderName;
 	}
 
 	public void setLoaderName(String name) {
 		this.loaderName = name;
 	}
 
 	public String getReferencedPropertyName() {
 		return referencedPropertyName;
 	}
 
 	public void setReferencedPropertyName(String propertyRef) {
 		this.referencedPropertyName = propertyRef;
 	}
 
 	public boolean isOptimisticLocked() {
 		return optimisticLocked;
 	}
 
 	public void setOptimisticLocked(boolean optimisticLocked) {
 		this.optimisticLocked = optimisticLocked;
 	}
 
 	public boolean isMap() {
 		return false;
 	}
 
 	public String getTypeName() {
 		return typeName;
 	}
 
 	public void setTypeName(String typeName) {
 		this.typeName = typeName;
 	}
 
 	public Properties getTypeParameters() {
 		return typeParameters;
 	}
 
 	public void setTypeParameters(Properties parameterMap) {
 		this.typeParameters = parameterMap;
 	}
 
 	public boolean[] getColumnInsertability() {
 		return ArrayHelper.EMPTY_BOOLEAN_ARRAY;
 	}
 
 	public boolean[] getColumnUpdateability() {
 		return ArrayHelper.EMPTY_BOOLEAN_ARRAY;
 	}
 
 	public String getNodeName() {
 		return nodeName;
 	}
 
 	public void setNodeName(String nodeName) {
 		this.nodeName = nodeName;
 	}
 
 	public String getElementNodeName() {
 		return elementNodeName;
 	}
 
 	public void setElementNodeName(String elementNodeName) {
 		this.elementNodeName = elementNodeName;
 	}
 
 	/**
 	 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.
 	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
 	 */
 	@Deprecated
 	public boolean isEmbedded() {
 		return embedded;
 	}
 
 	/**
 	 * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.
 	 * See Jira issue: <a href="https://hibernate.onjira.com/browse/HHH-7771">HHH-7771</a>
 	 */
 	@Deprecated
 	public void setEmbedded(boolean embedded) {
 		this.embedded = embedded;
 	}
 
 	public boolean isSubselectLoadable() {
 		return subselectLoadable;
 	}
 	
 
 	public void setSubselectLoadable(boolean subqueryLoadable) {
 		this.subselectLoadable = subqueryLoadable;
 	}
 
 	public boolean isMutable() {
 		return mutable;
 	}
 
 	public void setMutable(boolean mutable) {
 		this.mutable = mutable;
 	}
 
 	public boolean isExtraLazy() {
 		return extraLazy;
 	}
 
 	public void setExtraLazy(boolean extraLazy) {
 		this.extraLazy = extraLazy;
 	}
 	
 	public boolean hasOrder() {
 		return orderBy!=null || manyToManyOrderBy!=null;
 	}
 
 	public void setComparatorClassName(String comparatorClassName) {
 		this.comparatorClassName = comparatorClassName;		
 	}
 	
 	public String getComparatorClassName() {
 		return comparatorClassName;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/PersistentClass.java b/hibernate-core/src/main/java/org/hibernate/mapping/PersistentClass.java
index 41f1bb2346..96aef1247a 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/PersistentClass.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/PersistentClass.java
@@ -1,883 +1,883 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.mapping;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 import org.hibernate.EntityMode;
 import org.hibernate.MappingException;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.lock.OptimisticLockingStrategy;
 import org.hibernate.engine.OptimisticLockStyle;
 import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.internal.FilterConfiguration;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.EmptyIterator;
 import org.hibernate.internal.util.collections.JoinedIterator;
 import org.hibernate.internal.util.collections.SingletonIterator;
 import org.hibernate.sql.Alias;
 
 /**
  * Mapping for an entity.
  *
  * @author Gavin King
  */
 public abstract class PersistentClass implements Serializable, Filterable, MetaAttributable {
 
 	private static final Alias PK_ALIAS = new Alias(15, "PK");
 
 	public static final String NULL_DISCRIMINATOR_MAPPING = "null";
 	public static final String NOT_NULL_DISCRIMINATOR_MAPPING = "not null";
 
 	private String entityName;
 
 	private String className;
 	private String proxyInterfaceName;
 	
 	private String nodeName;
 	private String jpaEntityName;
 
 	private String discriminatorValue;
 	private boolean lazy;
 	private ArrayList properties = new ArrayList();
 	private ArrayList declaredProperties = new ArrayList();
 	private final ArrayList subclasses = new ArrayList();
 	private final ArrayList subclassProperties = new ArrayList();
 	private final ArrayList subclassTables = new ArrayList();
 	private boolean dynamicInsert;
 	private boolean dynamicUpdate;
 	private int batchSize=-1;
 	private boolean selectBeforeUpdate;
 	private java.util.Map metaAttributes;
 	private ArrayList joins = new ArrayList();
 	private final ArrayList subclassJoins = new ArrayList();
 	private final java.util.List filters = new ArrayList();
 	protected final java.util.Set synchronizedTables = new HashSet();
 	private String loaderName;
 	private Boolean isAbstract;
 	private boolean hasSubselectLoadableCollections;
 	private Component identifierMapper;
 
 	// Custom SQL
 	private String customSQLInsert;
 	private boolean customInsertCallable;
 	private ExecuteUpdateResultCheckStyle insertCheckStyle;
 	private String customSQLUpdate;
 	private boolean customUpdateCallable;
 	private ExecuteUpdateResultCheckStyle updateCheckStyle;
 	private String customSQLDelete;
 	private boolean customDeleteCallable;
 	private ExecuteUpdateResultCheckStyle deleteCheckStyle;
 
 	private String temporaryIdTableName;
 	private String temporaryIdTableDDL;
 
 	private java.util.Map tuplizerImpls;
 
 	private MappedSuperclass superMappedSuperclass;
 	private Component declaredIdentifierMapper;
 	private OptimisticLockStyle optimisticLockStyle;
 
 	public String getClassName() {
 		return className;
 	}
 
 	public void setClassName(String className) {
 		this.className = className==null ? null : className.intern();
 	}
 
 	public String getProxyInterfaceName() {
 		return proxyInterfaceName;
 	}
 
 	public void setProxyInterfaceName(String proxyInterfaceName) {
 		this.proxyInterfaceName = proxyInterfaceName;
 	}
 
 	public Class getMappedClass() throws MappingException {
 		if (className==null) return null;
 		try {
 			return ReflectHelper.classForName(className);
 		}
 		catch (ClassNotFoundException cnfe) {
 			throw new MappingException("entity class not found: " + className, cnfe);
 		}
 	}
 
 	public Class getProxyInterface() {
 		if (proxyInterfaceName==null) return null;
 		try {
 			return ReflectHelper.classForName( proxyInterfaceName );
 		}
 		catch (ClassNotFoundException cnfe) {
 			throw new MappingException("proxy class not found: " + proxyInterfaceName, cnfe);
 		}
 	}
 	public boolean useDynamicInsert() {
 		return dynamicInsert;
 	}
 
 	abstract int nextSubclassId();
 	public abstract int getSubclassId();
 	
 	public boolean useDynamicUpdate() {
 		return dynamicUpdate;
 	}
 
 	public void setDynamicInsert(boolean dynamicInsert) {
 		this.dynamicInsert = dynamicInsert;
 	}
 
 	public void setDynamicUpdate(boolean dynamicUpdate) {
 		this.dynamicUpdate = dynamicUpdate;
 	}
 
 
 	public String getDiscriminatorValue() {
 		return discriminatorValue;
 	}
 
 	public void addSubclass(Subclass subclass) throws MappingException {
 		// inheritance cycle detection (paranoid check)
 		PersistentClass superclass = getSuperclass();
 		while (superclass!=null) {
 			if( subclass.getEntityName().equals( superclass.getEntityName() ) ) {
 				throw new MappingException(
 					"Circular inheritance mapping detected: " +
 					subclass.getEntityName() +
 					" will have it self as superclass when extending " +
 					getEntityName()
 				);
 			}
 			superclass = superclass.getSuperclass();
 		}
 		subclasses.add(subclass);
 	}
 
 	public boolean hasSubclasses() {
 		return subclasses.size() > 0;
 	}
 
 	public int getSubclassSpan() {
 		int n = subclasses.size();
 		Iterator iter = subclasses.iterator();
 		while ( iter.hasNext() ) {
 			n += ( (Subclass) iter.next() ).getSubclassSpan();
 		}
 		return n;
 	}
 	/**
 	 * Iterate over subclasses in a special 'order', most derived subclasses
 	 * first.
 	 */
 	public Iterator getSubclassIterator() {
 		Iterator[] iters = new Iterator[ subclasses.size() + 1 ];
 		Iterator iter = subclasses.iterator();
 		int i=0;
 		while ( iter.hasNext() ) {
 			iters[i++] = ( (Subclass) iter.next() ).getSubclassIterator();
 		}
 		iters[i] = subclasses.iterator();
 		return new JoinedIterator(iters);
 	}
 
 	public Iterator getSubclassClosureIterator() {
 		ArrayList iters = new ArrayList();
 		iters.add( new SingletonIterator(this) );
 		Iterator iter = getSubclassIterator();
 		while ( iter.hasNext() ) {
 			PersistentClass clazz = (PersistentClass)  iter.next();
 			iters.add( clazz.getSubclassClosureIterator() );
 		}
 		return new JoinedIterator(iters);
 	}
 	
 	public Table getIdentityTable() {
 		return getRootTable();
 	}
 	
 	public Iterator getDirectSubclasses() {
 		return subclasses.iterator();
 	}
 
 	public void addProperty(Property p) {
 		properties.add(p);
 		declaredProperties.add(p);
 		p.setPersistentClass(this);
 	}
 
 	public abstract Table getTable();
 
 	public String getEntityName() {
 		return entityName;
 	}
 
 	public abstract boolean isMutable();
 	public abstract boolean hasIdentifierProperty();
 	public abstract Property getIdentifierProperty();
 	public abstract Property getDeclaredIdentifierProperty();
 	public abstract KeyValue getIdentifier();
 	public abstract Property getVersion();
 	public abstract Property getDeclaredVersion();
 	public abstract Value getDiscriminator();
 	public abstract boolean isInherited();
 	public abstract boolean isPolymorphic();
 	public abstract boolean isVersioned();
 	public abstract String getNaturalIdCacheRegionName();
 	public abstract String getCacheConcurrencyStrategy();
 	public abstract PersistentClass getSuperclass();
 	public abstract boolean isExplicitPolymorphism();
 	public abstract boolean isDiscriminatorInsertable();
 
 	public abstract Iterator getPropertyClosureIterator();
 	public abstract Iterator getTableClosureIterator();
 	public abstract Iterator getKeyClosureIterator();
 
 	protected void addSubclassProperty(Property prop) {
 		subclassProperties.add(prop);
 	}
 	protected void addSubclassJoin(Join join) {
 		subclassJoins.add(join);
 	}
 	protected void addSubclassTable(Table subclassTable) {
 		subclassTables.add(subclassTable);
 	}
 	public Iterator getSubclassPropertyClosureIterator() {
 		ArrayList iters = new ArrayList();
 		iters.add( getPropertyClosureIterator() );
 		iters.add( subclassProperties.iterator() );
 		for ( int i=0; i<subclassJoins.size(); i++ ) {
 			Join join = (Join) subclassJoins.get(i);
 			iters.add( join.getPropertyIterator() );
 		}
 		return new JoinedIterator(iters);
 	}
 	public Iterator getSubclassJoinClosureIterator() {
 		return new JoinedIterator( getJoinClosureIterator(), subclassJoins.iterator() );
 	}
 	public Iterator getSubclassTableClosureIterator() {
 		return new JoinedIterator( getTableClosureIterator(), subclassTables.iterator() );
 	}
 
 	public boolean isClassOrSuperclassJoin(Join join) {
 		return joins.contains(join);
 	}
 
 	public boolean isClassOrSuperclassTable(Table closureTable) {
 		return getTable()==closureTable;
 	}
 
 	public boolean isLazy() {
 		return lazy;
 	}
 
 	public void setLazy(boolean lazy) {
 		this.lazy = lazy;
 	}
 
 	public abstract boolean hasEmbeddedIdentifier();
 	public abstract Class getEntityPersisterClass();
 	public abstract void setEntityPersisterClass(Class classPersisterClass);
 	public abstract Table getRootTable();
 	public abstract RootClass getRootClass();
 	public abstract KeyValue getKey();
 
 	public void setDiscriminatorValue(String discriminatorValue) {
 		this.discriminatorValue = discriminatorValue;
 	}
 
 	public void setEntityName(String entityName) {
 		this.entityName = entityName==null ? null : entityName.intern();
 	}
 
 	public void createPrimaryKey() {
 		//Primary key constraint
 		PrimaryKey pk = new PrimaryKey();
 		Table table = getTable();
 		pk.setTable(table);
 		pk.setName( PK_ALIAS.toAliasString( table.getName() ) );
 		table.setPrimaryKey(pk);
 
 		pk.addColumns( getKey().getColumnIterator() );
 	}
 
 	public abstract String getWhere();
 
 	public int getBatchSize() {
 		return batchSize;
 	}
 
 	public void setBatchSize(int batchSize) {
 		this.batchSize = batchSize;
 	}
 
 	public boolean hasSelectBeforeUpdate() {
 		return selectBeforeUpdate;
 	}
 
 	public void setSelectBeforeUpdate(boolean selectBeforeUpdate) {
 		this.selectBeforeUpdate = selectBeforeUpdate;
 	}
 
 	/**
 	 * Build an iterator of properties which are "referenceable".
 	 *
 	 * @see #getReferencedProperty for a discussion of "referenceable"
 	 * @return The property iterator.
 	 */
 	public Iterator getReferenceablePropertyIterator() {
 		return getPropertyClosureIterator();
 	}
 
 	/**
 	 * Given a property path, locate the appropriate referenceable property reference.
 	 * <p/>
 	 * A referenceable property is a property  which can be a target of a foreign-key
 	 * mapping (an identifier or explcitly named in a property-ref).
 	 *
 	 * @param propertyPath The property path to resolve into a property reference.
 	 * @return The property reference (never null).
 	 * @throws MappingException If the property could not be found.
 	 */
 	public Property getReferencedProperty(String propertyPath) throws MappingException {
 		try {
 			return getRecursiveProperty( propertyPath, getReferenceablePropertyIterator() );
 		}
 		catch ( MappingException e ) {
 			throw new MappingException(
 					"property-ref [" + propertyPath + "] not found on entity [" + getEntityName() + "]", e
 			);
 		}
 	}
 
 	public Property getRecursiveProperty(String propertyPath) throws MappingException {
 		try {
 			return getRecursiveProperty( propertyPath, getPropertyIterator() );
 		}
 		catch ( MappingException e ) {
 			throw new MappingException(
 					"property [" + propertyPath + "] not found on entity [" + getEntityName() + "]", e
 			);
 		}
 	}
 
 	private Property getRecursiveProperty(String propertyPath, Iterator iter) throws MappingException {
 		Property property = null;
 		StringTokenizer st = new StringTokenizer( propertyPath, ".", false );
 		try {
 			while ( st.hasMoreElements() ) {
 				final String element = ( String ) st.nextElement();
 				if ( property == null ) {
 					Property identifierProperty = getIdentifierProperty();
 					if ( identifierProperty != null && identifierProperty.getName().equals( element ) ) {
 						// we have a mapped identifier property and the root of
 						// the incoming property path matched that identifier
 						// property
 						property = identifierProperty;
 					}
 					else if ( identifierProperty == null && getIdentifierMapper() != null ) {
 						// we have an embedded composite identifier
 						try {
 							identifierProperty = getProperty( element, getIdentifierMapper().getPropertyIterator() );
 							if ( identifierProperty != null ) {
 								// the root of the incoming property path matched one
 								// of the embedded composite identifier properties
 								property = identifierProperty;
 							}
 						}
 						catch( MappingException ignore ) {
 							// ignore it...
 						}
 					}
 
 					if ( property == null ) {
 						property = getProperty( element, iter );
 					}
 				}
 				else {
 					//flat recursive algorithm
 					property = ( ( Component ) property.getValue() ).getProperty( element );
 				}
 			}
 		}
 		catch ( MappingException e ) {
 			throw new MappingException( "property [" + propertyPath + "] not found on entity [" + getEntityName() + "]" );
 		}
 
 		return property;
 	}
 
 	private Property getProperty(String propertyName, Iterator iterator) throws MappingException {
 		while ( iterator.hasNext() ) {
 			Property prop = (Property) iterator.next();
 			if ( prop.getName().equals( StringHelper.root(propertyName) ) ) {
 				return prop;
 			}
 		}
 		throw new MappingException( "property [" + propertyName + "] not found on entity [" + getEntityName() + "]" );
 	}
 
 	public Property getProperty(String propertyName) throws MappingException {
 		Iterator iter = getPropertyClosureIterator();
 		Property identifierProperty = getIdentifierProperty();
 		if ( identifierProperty != null
 				&& identifierProperty.getName().equals( StringHelper.root(propertyName) )
 				) {
 			return identifierProperty;
 		}
 		else {
 			return getProperty( propertyName, iter );
 		}
 	}
 
 	@Deprecated
 	public int getOptimisticLockMode() {
 		return getOptimisticLockStyle().getOldCode();
 	}
 
 	@Deprecated
 	public void setOptimisticLockMode(int optimisticLockMode) {
 		setOptimisticLockStyle( OptimisticLockStyle.interpretOldCode( optimisticLockMode ) );
 	}
 
 	public OptimisticLockStyle getOptimisticLockStyle() {
 		return optimisticLockStyle;
 	}
 
 	public void setOptimisticLockStyle(OptimisticLockStyle optimisticLockStyle) {
 		this.optimisticLockStyle = optimisticLockStyle;
 	}
 
 	public void validate(Mapping mapping) throws MappingException {
 		Iterator iter = getPropertyIterator();
 		while ( iter.hasNext() ) {
 			Property prop = (Property) iter.next();
 			if ( !prop.isValid(mapping) ) {
 				throw new MappingException(
 						"property mapping has wrong number of columns: " +
 						StringHelper.qualify( getEntityName(), prop.getName() ) +
 						" type: " +
 						prop.getType().getName()
 					);
 			}
 		}
 		checkPropertyDuplication();
 		checkColumnDuplication();
 	}
 	
 	private void checkPropertyDuplication() throws MappingException {
 		HashSet names = new HashSet();
 		Iterator iter = getPropertyIterator();
 		while ( iter.hasNext() ) {
 			Property prop = (Property) iter.next();
 			if ( !names.add( prop.getName() ) ) {
 				throw new MappingException( "Duplicate property mapping of " + prop.getName() + " found in " + getEntityName());
 			}
 		}
 	}
 
 	public boolean isDiscriminatorValueNotNull() {
 		return NOT_NULL_DISCRIMINATOR_MAPPING.equals( getDiscriminatorValue() );
 	}
 	public boolean isDiscriminatorValueNull() {
 		return NULL_DISCRIMINATOR_MAPPING.equals( getDiscriminatorValue() );
 	}
 
 	public java.util.Map getMetaAttributes() {
 		return metaAttributes;
 	}
 
 	public void setMetaAttributes(java.util.Map metas) {
 		this.metaAttributes = metas;
 	}
 
 	public MetaAttribute getMetaAttribute(String name) {
 		return metaAttributes==null?null:(MetaAttribute) metaAttributes.get(name);
 	}
 
 	@Override
     public String toString() {
 		return getClass().getName() + '(' + getEntityName() + ')';
 	}
 	
 	public Iterator getJoinIterator() {
 		return joins.iterator();
 	}
 
 	public Iterator getJoinClosureIterator() {
 		return joins.iterator();
 	}
 
 	public void addJoin(Join join) {
 		joins.add(join);
 		join.setPersistentClass(this);
 	}
 
 	public int getJoinClosureSpan() {
 		return joins.size();
 	}
 
 	public int getPropertyClosureSpan() {
 		int span = properties.size();
 		for ( int i=0; i<joins.size(); i++ ) {
 			Join join = (Join) joins.get(i);
 			span += join.getPropertySpan();
 		}
 		return span;
 	}
 
 	public int getJoinNumber(Property prop) {
 		int result=1;
 		Iterator iter = getSubclassJoinClosureIterator();
 		while ( iter.hasNext() ) {
 			Join join = (Join) iter.next();
 			if ( join.containsProperty(prop) ) return result;
 			result++;
 		}
 		return 0;
 	}
 
 	/**
 	 * Build an iterator over the properties defined on this class.  The returned
 	 * iterator only accounts for "normal" properties (i.e. non-identifier
 	 * properties).
 	 * <p/>
 	 * Differs from {@link #getUnjoinedPropertyIterator} in that the iterator
 	 * we return here will include properties defined as part of a join.
 	 *
 	 * @return An iterator over the "normal" properties.
 	 */
 	public Iterator getPropertyIterator() {
 		ArrayList iterators = new ArrayList();
 		iterators.add( properties.iterator() );
 		for ( int i = 0; i < joins.size(); i++ ) {
 			Join join = ( Join ) joins.get( i );
 			iterators.add( join.getPropertyIterator() );
 		}
 		return new JoinedIterator( iterators );
 	}
 
 	/**
 	 * Build an iterator over the properties defined on this class <b>which
 	 * are not defined as part of a join</b>.  As with {@link #getPropertyIterator},
 	 * the returned iterator only accounts for non-identifier properties.
 	 *
 	 * @return An iterator over the non-joined "normal" properties.
 	 */
 	public Iterator getUnjoinedPropertyIterator() {
 		return properties.iterator();
 	}
 
 	public void setCustomSQLInsert(String customSQLInsert, boolean callable, ExecuteUpdateResultCheckStyle checkStyle) {
 		this.customSQLInsert = customSQLInsert;
 		this.customInsertCallable = callable;
 		this.insertCheckStyle = checkStyle;
 	}
 
 	public String getCustomSQLInsert() {
 		return customSQLInsert;
 	}
 
 	public boolean isCustomInsertCallable() {
 		return customInsertCallable;
 	}
 
 	public ExecuteUpdateResultCheckStyle getCustomSQLInsertCheckStyle() {
 		return insertCheckStyle;
 	}
 
 	public void setCustomSQLUpdate(String customSQLUpdate, boolean callable, ExecuteUpdateResultCheckStyle checkStyle) {
 		this.customSQLUpdate = customSQLUpdate;
 		this.customUpdateCallable = callable;
 		this.updateCheckStyle = checkStyle;
 	}
 
 	public String getCustomSQLUpdate() {
 		return customSQLUpdate;
 	}
 
 	public boolean isCustomUpdateCallable() {
 		return customUpdateCallable;
 	}
 
 	public ExecuteUpdateResultCheckStyle getCustomSQLUpdateCheckStyle() {
 		return updateCheckStyle;
 	}
 
 	public void setCustomSQLDelete(String customSQLDelete, boolean callable, ExecuteUpdateResultCheckStyle checkStyle) {
 		this.customSQLDelete = customSQLDelete;
 		this.customDeleteCallable = callable;
 		this.deleteCheckStyle = checkStyle;
 	}
 
 	public String getCustomSQLDelete() {
 		return customSQLDelete;
 	}
 
 	public boolean isCustomDeleteCallable() {
 		return customDeleteCallable;
 	}
 
 	public ExecuteUpdateResultCheckStyle getCustomSQLDeleteCheckStyle() {
 		return deleteCheckStyle;
 	}
 
 	public void addFilter(String name, String condition, boolean autoAliasInjection, java.util.Map<String,String> aliasTableMap, java.util.Map<String,String> aliasEntityMap) {
 		filters.add(new FilterConfiguration(name, condition, autoAliasInjection, aliasTableMap, aliasEntityMap,  this));
 	}
 
 	public java.util.List getFilters() {
 		return filters;
 	}
 
 	public boolean isForceDiscriminator() {
 		return false;
 	}
 
 	public abstract boolean isJoinedSubclass();
 
 	public String getLoaderName() {
 		return loaderName;
 	}
 
 	public void setLoaderName(String loaderName) {
 		this.loaderName = loaderName==null ? null : loaderName.intern();
 	}
 
 	public abstract java.util.Set getSynchronizedTables();
 	
 	public void addSynchronizedTable(String table) {
 		synchronizedTables.add(table);
 	}
 
 	public Boolean isAbstract() {
 		return isAbstract;
 	}
 
 	public void setAbstract(Boolean isAbstract) {
 		this.isAbstract = isAbstract;
 	}
 
 	protected void checkColumnDuplication(Set distinctColumns, Iterator columns) 
 	throws MappingException {
 		while ( columns.hasNext() ) {
 			Selectable columnOrFormula = (Selectable) columns.next();
 			if ( !columnOrFormula.isFormula() ) {
 				Column col = (Column) columnOrFormula;
 				if ( !distinctColumns.add( col.getName() ) ) {
 					throw new MappingException( 
 							"Repeated column in mapping for entity: " +
 							getEntityName() +
 							" column: " +
 							col.getName() + 
 							" (should be mapped with insert=\"false\" update=\"false\")"
 						);
 				}
 			}
 		}
 	}
 	
 	protected void checkPropertyColumnDuplication(Set distinctColumns, Iterator properties) 
 	throws MappingException {
 		while ( properties.hasNext() ) {
 			Property prop = (Property) properties.next();
 			if ( prop.getValue() instanceof Component ) { //TODO: remove use of instanceof!
 				Component component = (Component) prop.getValue();
 				checkPropertyColumnDuplication( distinctColumns, component.getPropertyIterator() );
 			}
 			else {
 				if ( prop.isUpdateable() || prop.isInsertable() ) {
 					checkColumnDuplication( distinctColumns, prop.getColumnIterator() );
 				}
 			}
 		}
 	}
 	
 	protected Iterator getNonDuplicatedPropertyIterator() {
 		return getUnjoinedPropertyIterator();
 	}
 	
 	protected Iterator getDiscriminatorColumnIterator() {
 		return EmptyIterator.INSTANCE;
 	}
 	
 	protected void checkColumnDuplication() {
 		HashSet cols = new HashSet();
 		if (getIdentifierMapper() == null ) {
 			//an identifier mapper => getKey will be included in the getNonDuplicatedPropertyIterator()
 			//and checked later, so it needs to be excluded
 			checkColumnDuplication( cols, getKey().getColumnIterator() );
 		}
 		checkColumnDuplication( cols, getDiscriminatorColumnIterator() );
 		checkPropertyColumnDuplication( cols, getNonDuplicatedPropertyIterator() );
 		Iterator iter = getJoinIterator();
 		while ( iter.hasNext() ) {
 			cols.clear();
 			Join join = (Join) iter.next();
 			checkColumnDuplication( cols, join.getKey().getColumnIterator() );
 			checkPropertyColumnDuplication( cols, join.getPropertyIterator() );
 		}
 	}
 	
 	public abstract Object accept(PersistentClassVisitor mv);
 	
 	public String getNodeName() {
 		return nodeName;
 	}
 	
 	public void setNodeName(String nodeName) {
 		this.nodeName = nodeName;
 	}
 
 	public String getJpaEntityName() {
 		return jpaEntityName;
 	}
 	
 	public void setJpaEntityName(String jpaEntityName) {
 		this.jpaEntityName = jpaEntityName;
 	}
 	
 	public boolean hasPojoRepresentation() {
 		return getClassName()!=null;
 	}
 
 	public boolean hasDom4jRepresentation() {
 		return getNodeName()!=null;
 	}
 
 	public boolean hasSubselectLoadableCollections() {
 		return hasSubselectLoadableCollections;
 	}
 	
 	public void setSubselectLoadableCollections(boolean hasSubselectCollections) {
 		this.hasSubselectLoadableCollections = hasSubselectCollections;
 	}
 
 	public void prepareTemporaryTables(Mapping mapping, Dialect dialect) {
 		temporaryIdTableName = dialect.generateTemporaryTableName( getTable().getName() );
 		if ( dialect.supportsTemporaryTables() ) {
 			Table table = new Table();
 			table.setName( temporaryIdTableName );
 			Iterator itr = getTable().getPrimaryKey().getColumnIterator();
 			while( itr.hasNext() ) {
 				Column column = (Column) itr.next();
 				table.addColumn( column.clone()  );
 			}
 			temporaryIdTableDDL = table.sqlTemporaryTableCreateString( dialect, mapping );
 		}
 	}
 
 	public String getTemporaryIdTableName() {
 		return temporaryIdTableName;
 	}
 
 	public String getTemporaryIdTableDDL() {
 		return temporaryIdTableDDL;
 	}
 
 	public Component getIdentifierMapper() {
 		return identifierMapper;
 	}
 
 	public Component getDeclaredIdentifierMapper() {
 		return declaredIdentifierMapper;
 	}
 
 	public void setDeclaredIdentifierMapper(Component declaredIdentifierMapper) {
 		this.declaredIdentifierMapper = declaredIdentifierMapper;
 	}
 
 	public boolean hasIdentifierMapper() {
 		return identifierMapper != null;
 	}
 
 	public void setIdentifierMapper(Component handle) {
 		this.identifierMapper = handle;
 	}
 
 	public void addTuplizer(EntityMode entityMode, String implClassName) {
 		if ( tuplizerImpls == null ) {
 			tuplizerImpls = new HashMap();
 		}
 		tuplizerImpls.put( entityMode, implClassName );
 	}
 
 	public String getTuplizerImplClassName(EntityMode mode) {
 		if ( tuplizerImpls == null ) return null;
 		return ( String ) tuplizerImpls.get( mode );
 	}
 
 	public java.util.Map getTuplizerMap() {
 		if ( tuplizerImpls == null ) {
 			return null;
 		}
 		return java.util.Collections.unmodifiableMap( tuplizerImpls );
 	}
 
 	public boolean hasNaturalId() {
 		Iterator props = getRootClass().getPropertyIterator();
 		while ( props.hasNext() ) {
 			if ( ( (Property) props.next() ).isNaturalIdentifier() ) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	public abstract boolean isLazyPropertiesCacheable();
 
 	// The following methods are added to support @MappedSuperclass in the metamodel
 	public Iterator getDeclaredPropertyIterator() {
 		ArrayList iterators = new ArrayList();
 		iterators.add( declaredProperties.iterator() );
 		for ( int i = 0; i < joins.size(); i++ ) {
 			Join join = ( Join ) joins.get( i );
 			iterators.add( join.getDeclaredPropertyIterator() );
 		}
 		return new JoinedIterator( iterators );
 	}
 
 	public void addMappedsuperclassProperty(Property p) {
 		properties.add(p);
 		p.setPersistentClass(this);
 	}
 
 	public MappedSuperclass getSuperMappedSuperclass() {
 		return superMappedSuperclass;
 	}
 
 	public void setSuperMappedSuperclass(MappedSuperclass superMappedSuperclass) {
 		this.superMappedSuperclass = superMappedSuperclass;
 	}
 
 	// End of @Mappedsuperclass support
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java b/hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java
index a9bbdb3619..57220006eb 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/SimpleValue.java
@@ -1,611 +1,611 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.mapping;
 
 import javax.persistence.AttributeConverter;
 import java.lang.annotation.Annotation;
 import java.lang.reflect.TypeVariable;
 import java.sql.CallableStatement;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Properties;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.FetchMode;
 import org.hibernate.MappingException;
 import org.hibernate.annotations.common.reflection.XProperty;
 import org.hibernate.cfg.AttributeConverterDefinition;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.Mappings;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.IdentityGenerator;
 import org.hibernate.id.PersistentIdentifierGenerator;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.type.AbstractSingleColumnStandardBasicType;
 import org.hibernate.type.Type;
 import org.hibernate.type.descriptor.ValueBinder;
 import org.hibernate.type.descriptor.ValueExtractor;
 import org.hibernate.type.descriptor.WrapperOptions;
 import org.hibernate.type.descriptor.java.JavaTypeDescriptor;
 import org.hibernate.type.descriptor.java.JavaTypeDescriptorRegistry;
 import org.hibernate.type.descriptor.sql.BasicBinder;
 import org.hibernate.type.descriptor.sql.BasicExtractor;
 import org.hibernate.type.descriptor.sql.JdbcTypeJavaClassMappings;
 import org.hibernate.type.descriptor.sql.SqlTypeDescriptor;
 import org.hibernate.type.descriptor.sql.SqlTypeDescriptorRegistry;
 import org.hibernate.usertype.DynamicParameterizedType;
 
 /**
  * Any value that maps to columns.
  * @author Gavin King
  */
 public class SimpleValue implements KeyValue {
 	private static final Logger log = Logger.getLogger( SimpleValue.class );
 
 	public static final String DEFAULT_ID_GEN_STRATEGY = "assigned";
 
 	private final Mappings mappings;
 
 	private final List<Selectable> columns = new ArrayList<Selectable>();
 
 	private String typeName;
 	private Properties identifierGeneratorProperties;
 	private String identifierGeneratorStrategy = DEFAULT_ID_GEN_STRATEGY;
 	private String nullValue;
 	private Table table;
 	private String foreignKeyName;
 	private boolean alternateUniqueKey;
 	private Properties typeParameters;
 	private boolean cascadeDeleteEnabled;
 
 	private AttributeConverterDefinition jpaAttributeConverterDefinition;
 	private Type type;
 
 	public SimpleValue(Mappings mappings) {
 		this.mappings = mappings;
 	}
 
 	public SimpleValue(Mappings mappings, Table table) {
 		this( mappings );
 		this.table = table;
 	}
 
 	public Mappings getMappings() {
 		return mappings;
 	}
 
 	public boolean isCascadeDeleteEnabled() {
 		return cascadeDeleteEnabled;
 	}
 
 	public void setCascadeDeleteEnabled(boolean cascadeDeleteEnabled) {
 		this.cascadeDeleteEnabled = cascadeDeleteEnabled;
 	}
 	
 	public void addColumn(Column column) {
 		if ( !columns.contains(column) ) columns.add(column);
 		column.setValue(this);
 		column.setTypeIndex( columns.size()-1 );
 	}
 	
 	public void addFormula(Formula formula) {
 		columns.add(formula);
 	}
 	
 	public boolean hasFormula() {
 		Iterator iter = getColumnIterator();
 		while ( iter.hasNext() ) {
 			Object o = iter.next();
 			if (o instanceof Formula) return true;
 		}
 		return false;
 	}
 
 	public int getColumnSpan() {
 		return columns.size();
 	}
 	public Iterator<Selectable> getColumnIterator() {
 		return columns.iterator();
 	}
 	public List getConstraintColumns() {
 		return columns;
 	}
 	public String getTypeName() {
 		return typeName;
 	}
 	public void setTypeName(String type) {
 		this.typeName = type;
 	}
 	public void setTable(Table table) {
 		this.table = table;
 	}
 
 	public void createForeignKey() throws MappingException {}
 
 	public void createForeignKeyOfEntity(String entityName) {
 		if ( !hasFormula() && !"none".equals(getForeignKeyName())) {
 			ForeignKey fk = table.createForeignKey( getForeignKeyName(), getConstraintColumns(), entityName );
 			fk.setCascadeDeleteEnabled(cascadeDeleteEnabled);
 		}
 	}
 
 	public IdentifierGenerator createIdentifierGenerator(
 			IdentifierGeneratorFactory identifierGeneratorFactory,
 			Dialect dialect, 
 			String defaultCatalog, 
 			String defaultSchema, 
 			RootClass rootClass) throws MappingException {
 		
 		Properties params = new Properties();
 		
 		//if the hibernate-mapping did not specify a schema/catalog, use the defaults
 		//specified by properties - but note that if the schema/catalog were specified
 		//in hibernate-mapping, or as params, they will already be initialized and
 		//will override the values set here (they are in identifierGeneratorProperties)
 		if ( defaultSchema!=null ) {
 			params.setProperty(PersistentIdentifierGenerator.SCHEMA, defaultSchema);
 		}
 		if ( defaultCatalog!=null ) {
 			params.setProperty(PersistentIdentifierGenerator.CATALOG, defaultCatalog);
 		}
 		
 		//pass the entity-name, if not a collection-id
 		if (rootClass!=null) {
 			params.setProperty( IdentifierGenerator.ENTITY_NAME, rootClass.getEntityName() );
 			params.setProperty( IdentifierGenerator.JPA_ENTITY_NAME, rootClass.getJpaEntityName() );
 		}
 		
 		//init the table here instead of earlier, so that we can get a quoted table name
 		//TODO: would it be better to simply pass the qualified table name, instead of
 		//      splitting it up into schema/catalog/table names
 		String tableName = getTable().getQuotedName(dialect);
 		params.setProperty( PersistentIdentifierGenerator.TABLE, tableName );
 		
 		//pass the column name (a generated id almost always has a single column)
 		String columnName = ( (Column) getColumnIterator().next() ).getQuotedName(dialect);
 		params.setProperty( PersistentIdentifierGenerator.PK, columnName );
 		
 		if (rootClass!=null) {
 			StringBuilder tables = new StringBuilder();
 			Iterator iter = rootClass.getIdentityTables().iterator();
 			while ( iter.hasNext() ) {
 				Table table= (Table) iter.next();
 				tables.append( table.getQuotedName(dialect) );
 				if ( iter.hasNext() ) tables.append(", ");
 			}
 			params.setProperty( PersistentIdentifierGenerator.TABLES, tables.toString() );
 		}
 		else {
 			params.setProperty( PersistentIdentifierGenerator.TABLES, tableName );
 		}
 
 		if (identifierGeneratorProperties!=null) {
 			params.putAll(identifierGeneratorProperties);
 		}
 
 		// TODO : we should pass along all settings once "config lifecycle" is hashed out...
 		params.put(
 				Environment.PREFER_POOLED_VALUES_LO,
 				mappings.getConfigurationProperties().getProperty( Environment.PREFER_POOLED_VALUES_LO, "false" )
 		);
 
 		identifierGeneratorFactory.setDialect( dialect );
 		return identifierGeneratorFactory.createIdentifierGenerator( identifierGeneratorStrategy, getType(), params );
 		
 	}
 
 	public boolean isUpdateable() {
 		//needed to satisfy KeyValue
 		return true;
 	}
 	
 	public FetchMode getFetchMode() {
 		return FetchMode.SELECT;
 	}
 
 	public Properties getIdentifierGeneratorProperties() {
 		return identifierGeneratorProperties;
 	}
 
 	public String getNullValue() {
 		return nullValue;
 	}
 
 	public Table getTable() {
 		return table;
 	}
 
 	/**
 	 * Returns the identifierGeneratorStrategy.
 	 * @return String
 	 */
 	public String getIdentifierGeneratorStrategy() {
 		return identifierGeneratorStrategy;
 	}
 	
 	public boolean isIdentityColumn(IdentifierGeneratorFactory identifierGeneratorFactory, Dialect dialect) {
 		identifierGeneratorFactory.setDialect( dialect );
 		return identifierGeneratorFactory.getIdentifierGeneratorClass( identifierGeneratorStrategy )
 				.equals( IdentityGenerator.class );
 	}
 
 	/**
 	 * Sets the identifierGeneratorProperties.
 	 * @param identifierGeneratorProperties The identifierGeneratorProperties to set
 	 */
 	public void setIdentifierGeneratorProperties(Properties identifierGeneratorProperties) {
 		this.identifierGeneratorProperties = identifierGeneratorProperties;
 	}
 
 	/**
 	 * Sets the identifierGeneratorStrategy.
 	 * @param identifierGeneratorStrategy The identifierGeneratorStrategy to set
 	 */
 	public void setIdentifierGeneratorStrategy(String identifierGeneratorStrategy) {
 		this.identifierGeneratorStrategy = identifierGeneratorStrategy;
 	}
 
 	/**
 	 * Sets the nullValue.
 	 * @param nullValue The nullValue to set
 	 */
 	public void setNullValue(String nullValue) {
 		this.nullValue = nullValue;
 	}
 
 	public String getForeignKeyName() {
 		return foreignKeyName;
 	}
 
 	public void setForeignKeyName(String foreignKeyName) {
 		this.foreignKeyName = foreignKeyName;
 	}
 
 	public boolean isAlternateUniqueKey() {
 		return alternateUniqueKey;
 	}
 
 	public void setAlternateUniqueKey(boolean unique) {
 		this.alternateUniqueKey = unique;
 	}
 
 	public boolean isNullable() {
 		if ( hasFormula() ) return true;
 		boolean nullable = true;
 		Iterator iter = getColumnIterator();
 		while ( iter.hasNext() ) {
 			if ( !( (Column) iter.next() ).isNullable() ) {
 				nullable = false;
 				return nullable; //shortcut
 			}
 		}
 		return nullable;
 	}
 
 	public boolean isSimpleValue() {
 		return true;
 	}
 
 	public boolean isValid(Mapping mapping) throws MappingException {
 		return getColumnSpan()==getType().getColumnSpan(mapping);
 	}
 
 	public Type getType() throws MappingException {
 		if ( type != null ) {
 			return type;
 		}
 
 		if ( typeName == null ) {
 			throw new MappingException( "No type name" );
 		}
 		if ( typeParameters != null
 				&& Boolean.valueOf( typeParameters.getProperty( DynamicParameterizedType.IS_DYNAMIC ) )
 				&& typeParameters.get( DynamicParameterizedType.PARAMETER_TYPE ) == null ) {
 			createParameterImpl();
 		}
 
 		Type result = mappings.getTypeResolver().heuristicType( typeName, typeParameters );
 		if ( result == null ) {
 			String msg = "Could not determine type for: " + typeName;
 			if ( table != null ) {
 				msg += ", at table: " + table.getName();
 			}
 			if ( columns != null && columns.size() > 0 ) {
 				msg += ", for columns: " + columns;
 			}
 			throw new MappingException( msg );
 		}
 
 		return result;
 	}
 
 	@SuppressWarnings("unchecked")
 	public void setTypeUsingReflection(String className, String propertyName) throws MappingException {
 		// NOTE : this is called as the last piece in setting SimpleValue type information, and implementations
 		// rely on that fact, using it as a signal that all information it is going to get is defined at this point...
 
 		if ( typeName != null ) {
 			// assume either (a) explicit type was specified or (b) determine was already performed
 			return;
 		}
 
 		if ( type != null ) {
 			return;
 		}
 
 		if ( jpaAttributeConverterDefinition == null ) {
 			// this is here to work like legacy.  This should change when we integrate with metamodel to
 			// look for SqlTypeDescriptor and JavaTypeDescriptor individually and create the BasicType (well, really
 			// keep a registry of [SqlTypeDescriptor,JavaTypeDescriptor] -> BasicType...)
 			if ( className == null ) {
 				throw new MappingException( "you must specify types for a dynamic entity: " + propertyName );
 			}
 			typeName = ReflectHelper.reflectedPropertyClass( className, propertyName ).getName();
 			return;
 		}
 
 		// we had an AttributeConverter...
 
 		// todo : we should validate the number of columns present
 		// todo : ultimately I want to see attributeConverterJavaType and attributeConverterJdbcTypeCode specify-able separately
 		//		then we can "play them against each other" in terms of determining proper typing
 		// todo : see if we already have previously built a custom on-the-fly BasicType for this AttributeConverter; see note below about caching
 
 		// AttributeConverter works totally in memory, meaning it converts between one Java representation (the entity
 		// attribute representation) and another (the value bound into JDBC statements or extracted from results).
 		// However, the Hibernate Type system operates at the lower level of actually dealing with those JDBC objects.
 		// So even though we have an AttributeConverter, we still need to "fill out" the rest of the BasicType
 		// data.  For the JavaTypeDescriptor portion we simply resolve the "entity attribute representation" part of
 		// the AttributeConverter to resolve the corresponding descriptor.  For the SqlTypeDescriptor portion we use the
 		// "database column representation" part of the AttributeConverter to resolve the "recommended" JDBC type-code
 		// and use that type-code to resolve the SqlTypeDescriptor to use.
 		final Class entityAttributeJavaType = jpaAttributeConverterDefinition.getEntityAttributeType();
 		final Class databaseColumnJavaType = jpaAttributeConverterDefinition.getDatabaseColumnType();
 		final int jdbcTypeCode = JdbcTypeJavaClassMappings.INSTANCE.determineJdbcTypeCodeForJavaClass( databaseColumnJavaType );
 
 		final JavaTypeDescriptor javaTypeDescriptor = JavaTypeDescriptorRegistry.INSTANCE.getDescriptor( entityAttributeJavaType );
 		final SqlTypeDescriptor sqlTypeDescriptor = SqlTypeDescriptorRegistry.INSTANCE.getDescriptor( jdbcTypeCode );
 		// the adapter here injects the AttributeConverter calls into the binding/extraction process...
 		final SqlTypeDescriptor sqlTypeDescriptorAdapter = new AttributeConverterSqlTypeDescriptorAdapter(
 				jpaAttributeConverterDefinition.getAttributeConverter(),
 				sqlTypeDescriptor
 		);
 
 		final String name = "BasicType adapter for AttributeConverter<" + entityAttributeJavaType + "," + databaseColumnJavaType + ">";
 		type = new AbstractSingleColumnStandardBasicType( sqlTypeDescriptorAdapter, javaTypeDescriptor ) {
 			@Override
 			public String getName() {
 				return name;
 			}
 		};
 		log.debug( "Created : " + name );
 
 		// todo : cache the BasicType we just created in case that AttributeConverter is applied multiple times.
 	}
 
 	private Class extractType(TypeVariable typeVariable) {
 		java.lang.reflect.Type[] boundTypes = typeVariable.getBounds();
 		if ( boundTypes == null || boundTypes.length != 1 ) {
 			return null;
 		}
 
 		return (Class) boundTypes[0];
 	}
 
 	public boolean isTypeSpecified() {
 		return typeName!=null;
 	}
 
 	public void setTypeParameters(Properties parameterMap) {
 		this.typeParameters = parameterMap;
 	}
 	
 	public Properties getTypeParameters() {
 		return typeParameters;
 	}
 
 	@Override
     public String toString() {
 		return getClass().getName() + '(' + columns.toString() + ')';
 	}
 
 	public Object accept(ValueVisitor visitor) {
 		return visitor.accept(this);
 	}
 	
 	public boolean[] getColumnInsertability() {
 		boolean[] result = new boolean[ getColumnSpan() ];
 		int i = 0;
 		Iterator iter = getColumnIterator();
 		while ( iter.hasNext() ) {
 			Selectable s = (Selectable) iter.next();
 			result[i++] = !s.isFormula();
 		}
 		return result;
 	}
 	
 	public boolean[] getColumnUpdateability() {
 		return getColumnInsertability();
 	}
 
 	public void setJpaAttributeConverterDefinition(AttributeConverterDefinition jpaAttributeConverterDefinition) {
 		this.jpaAttributeConverterDefinition = jpaAttributeConverterDefinition;
 	}
 
 	public static class AttributeConverterSqlTypeDescriptorAdapter implements SqlTypeDescriptor {
 		private final AttributeConverter converter;
 		private final SqlTypeDescriptor delegate;
 
 		public AttributeConverterSqlTypeDescriptorAdapter(AttributeConverter converter, SqlTypeDescriptor delegate) {
 			this.converter = converter;
 			this.delegate = delegate;
 		}
 
 		@Override
 		public int getSqlType() {
 			return delegate.getSqlType();
 		}
 
 		@Override
 		public boolean canBeRemapped() {
 			return delegate.canBeRemapped();
 		}
 
 		@Override
 		public <X> ValueBinder<X> getBinder(JavaTypeDescriptor<X> javaTypeDescriptor) {
 			final ValueBinder realBinder = delegate.getBinder( javaTypeDescriptor );
 			return new BasicBinder<X>( javaTypeDescriptor, this ) {
 				@Override
 				@SuppressWarnings("unchecked")
 				protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options)
 						throws SQLException {
 					realBinder.bind( st, converter.convertToDatabaseColumn( value ), index, options );
 				}
 			};
 		}
 
 		@Override
 		public <X> ValueExtractor<X> getExtractor(JavaTypeDescriptor<X> javaTypeDescriptor) {
 			final ValueExtractor realExtractor = delegate.getExtractor( javaTypeDescriptor );
 			return new BasicExtractor<X>( javaTypeDescriptor, this ) {
 				@Override
 				@SuppressWarnings("unchecked")
 				protected X doExtract(ResultSet rs, String name, WrapperOptions options) throws SQLException {
 					return (X) converter.convertToEntityAttribute( realExtractor.extract( rs, name, options ) );
 				}
 
 				@Override
 				@SuppressWarnings("unchecked")
 				protected X doExtract(CallableStatement statement, int index, WrapperOptions options)
 						throws SQLException {
 					return (X) converter.convertToEntityAttribute( realExtractor.extract( statement, index, options ) );
 				}
 
 				@Override
 				@SuppressWarnings("unchecked")
 				protected X doExtract(CallableStatement statement, String name, WrapperOptions options) throws SQLException {
 					return (X) converter.convertToEntityAttribute( realExtractor.extract( statement, new String[] {name}, options ) );
 				}
 			};
 		}
 	}
 
 	private void createParameterImpl() {
 		try {
 			String[] columnsNames = new String[columns.size()];
 			for ( int i = 0; i < columns.size(); i++ ) {
 				columnsNames[i] = ( (Column) columns.get( i ) ).getName();
 			}
 
 			final XProperty xProperty = (XProperty) typeParameters.get( DynamicParameterizedType.XPROPERTY );
 			// todo : not sure this works for handling @MapKeyEnumerated
 			final Annotation[] annotations = xProperty == null
 					? null
 					: xProperty.getAnnotations();
 
 			typeParameters.put(
 					DynamicParameterizedType.PARAMETER_TYPE,
 					new ParameterTypeImpl(
 							ReflectHelper.classForName(
 									typeParameters.getProperty( DynamicParameterizedType.RETURNED_CLASS )
 							),
 							annotations,
 							table.getCatalog(),
 							table.getSchema(),
 							table.getName(),
 							Boolean.valueOf( typeParameters.getProperty( DynamicParameterizedType.IS_PRIMARY_KEY ) ),
 							columnsNames
 					)
 			);
 		}
 		catch ( ClassNotFoundException cnfe ) {
 			throw new MappingException( "Could not create DynamicParameterizedType for type: " + typeName, cnfe );
 		}
 	}
 
 	private final class ParameterTypeImpl implements DynamicParameterizedType.ParameterType {
 
 		private final Class returnedClass;
 		private final Annotation[] annotationsMethod;
 		private final String catalog;
 		private final String schema;
 		private final String table;
 		private final boolean primaryKey;
 		private final String[] columns;
 
 		private ParameterTypeImpl(Class returnedClass, Annotation[] annotationsMethod, String catalog, String schema,
 				String table, boolean primaryKey, String[] columns) {
 			this.returnedClass = returnedClass;
 			this.annotationsMethod = annotationsMethod;
 			this.catalog = catalog;
 			this.schema = schema;
 			this.table = table;
 			this.primaryKey = primaryKey;
 			this.columns = columns;
 		}
 
 		@Override
 		public Class getReturnedClass() {
 			return returnedClass;
 		}
 
 		@Override
 		public Annotation[] getAnnotationsMethod() {
 			return annotationsMethod;
 		}
 
 		@Override
 		public String getCatalog() {
 			return catalog;
 		}
 
 		@Override
 		public String getSchema() {
 			return schema;
 		}
 
 		@Override
 		public String getTable() {
 			return table;
 		}
 
 		@Override
 		public boolean isPrimaryKey() {
 			return primaryKey;
 		}
 
 		@Override
 		public String[] getColumns() {
 			return columns;
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/mapping/Value.java b/hibernate-core/src/main/java/org/hibernate/mapping/Value.java
index 731216baf1..9a80b0d531 100644
--- a/hibernate-core/src/main/java/org/hibernate/mapping/Value.java
+++ b/hibernate-core/src/main/java/org/hibernate/mapping/Value.java
@@ -1,58 +1,58 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.mapping;
 import java.io.Serializable;
 import java.util.Iterator;
 
 import org.hibernate.FetchMode;
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.type.Type;
 
 /**
  * A value is anything that is persisted by value, instead of
  * by reference. It is essentially a Hibernate Type, together
  * with zero or more columns. Values are wrapped by things with
  * higher level semantics, for example properties, collections,
  * classes.
  *
  * @author Gavin King
  */
 public interface Value extends Serializable {
 	public int getColumnSpan();
 	public Iterator<Selectable> getColumnIterator();
 	public Type getType() throws MappingException;
 	public FetchMode getFetchMode();
 	public Table getTable();
 	public boolean hasFormula();
 	public boolean isAlternateUniqueKey();
 	public boolean isNullable();
 	public boolean[] getColumnUpdateability();
 	public boolean[] getColumnInsertability();
 	public void createForeignKey() throws MappingException;
 	public boolean isSimpleValue();
 	public boolean isValid(Mapping mapping) throws MappingException;
 	public void setTypeUsingReflection(String className, String propertyName) throws MappingException;
 	public Object accept(ValueVisitor visitor);
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ManyToOneAttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ManyToOneAttributeBinding.java
index 798ff70184..66a9f5376b 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ManyToOneAttributeBinding.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/ManyToOneAttributeBinding.java
@@ -1,241 +1,241 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.binding;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.FetchMode;
 import org.hibernate.engine.FetchStyle;
 import org.hibernate.engine.FetchTiming;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.CascadeStyles;
 import org.hibernate.metamodel.domain.SingularAttribute;
 
 /**
  * TODO : javadoc
  *
  * @author Gail Badner
  * @author Steve Ebersole
  */
 public class ManyToOneAttributeBinding extends BasicAttributeBinding implements SingularAssociationAttributeBinding {
 	private String referencedEntityName;
 	private String referencedAttributeName;
 	private AttributeBinding referencedAttributeBinding;
 
 	private boolean isLogicalOneToOne;
 	private String foreignKeyName;
 
 	private CascadeStyle cascadeStyle;
 	private FetchTiming fetchTiming;
 	private FetchStyle fetchStyle;
 
 	ManyToOneAttributeBinding(AttributeBindingContainer container, SingularAttribute attribute) {
 		super( container, attribute, false, false );
 	}
 
 	@Override
 	public boolean isAssociation() {
 		return true;
 	}
 
 	@Override
 	public final boolean isPropertyReference() {
 		return referencedAttributeName != null;
 	}
 
 	@Override
 	public final String getReferencedEntityName() {
 		return referencedEntityName;
 	}
 
 	@Override
 	public void setReferencedEntityName(String referencedEntityName) {
 		this.referencedEntityName = referencedEntityName;
 	}
 
 	@Override
 	public final String getReferencedAttributeName() {
 		return referencedAttributeName;
 	}
 
 	@Override
 	public void setReferencedAttributeName(String referencedEntityAttributeName) {
 		this.referencedAttributeName = referencedEntityAttributeName;
 	}
 
 	@Override
 	public CascadeStyle getCascadeStyle() {
 		return cascadeStyle;
 	}
 
 	@Override
 	public void setCascadeStyles(Iterable<CascadeStyle> cascadeStyles) {
 		List<CascadeStyle> cascadeStyleList = new ArrayList<CascadeStyle>();
 		for ( CascadeStyle style : cascadeStyles ) {
 			if ( style != CascadeStyles.NONE ) {
 				cascadeStyleList.add( style );
 			}
 		}
 		if ( cascadeStyleList.isEmpty() ) {
 			cascadeStyle = CascadeStyles.NONE;
 		}
 		else if ( cascadeStyleList.size() == 1 ) {
 			cascadeStyle = cascadeStyleList.get( 0 );
 		}
 		else {
 			cascadeStyle = new CascadeStyles.MultipleCascadeStyle(
 					cascadeStyleList.toArray( new CascadeStyle[ cascadeStyleList.size() ] )
 			);
 		}
 	}
 
 	@Override
 	public FetchTiming getFetchTiming() {
 		return fetchTiming;
 	}
 
 	@Override
 	public void setFetchTiming(FetchTiming fetchTiming) {
 		this.fetchTiming = fetchTiming;
 	}
 
 	@Override
 	public FetchStyle getFetchStyle() {
 		return fetchStyle;
 	}
 
 	@Override
 	public void setFetchStyle(FetchStyle fetchStyle) {
 		if ( fetchStyle == FetchStyle.SUBSELECT ) {
 			throw new AssertionFailure( "Subselect fetching not yet supported for singular associations" );
 		}
 		this.fetchStyle = fetchStyle;
 	}
 
 	@Override
 	public FetchMode getFetchMode() {
 		if ( fetchStyle == FetchStyle.JOIN ) {
 			return FetchMode.JOIN;
 		}
 		else if ( fetchStyle == FetchStyle.SELECT ) {
 			return FetchMode.SELECT;
 		}
 		else if ( fetchStyle == FetchStyle.BATCH ) {
 			// we need the subsequent select...
 			return FetchMode.SELECT;
 		}
 
 		throw new AssertionFailure( "Unexpected fetch style : " + fetchStyle.name() );
 	}
 
 	@Override
 	public final boolean isReferenceResolved() {
 		return referencedAttributeBinding != null;
 	}
 
 	@Override
 	public final void resolveReference(AttributeBinding referencedAttributeBinding) {
 		if ( ! EntityBinding.class.isInstance( referencedAttributeBinding.getContainer() ) ) {
 			throw new AssertionFailure( "Illegal attempt to resolve many-to-one reference based on non-entity attribute" );
 		}
 		final EntityBinding entityBinding = (EntityBinding) referencedAttributeBinding.getContainer();
 		if ( !referencedEntityName.equals( entityBinding.getEntity().getName() ) ) {
 			throw new IllegalStateException(
 					"attempt to set EntityBinding with name: [" +
 							entityBinding.getEntity().getName() +
 							"; entity name should be: " + referencedEntityName
 			);
 		}
 		if ( referencedAttributeName == null ) {
 			referencedAttributeName = referencedAttributeBinding.getAttribute().getName();
 		}
 		else if ( !referencedAttributeName.equals( referencedAttributeBinding.getAttribute().getName() ) ) {
 			throw new IllegalStateException(
 					"Inconsistent attribute name; expected: " + referencedAttributeName +
 							"actual: " + referencedAttributeBinding.getAttribute().getName()
 			);
 		}
 		this.referencedAttributeBinding = referencedAttributeBinding;
 //		buildForeignKey();
 	}
 
 	@Override
 	public AttributeBinding getReferencedAttributeBinding() {
 		if ( !isReferenceResolved() ) {
 			throw new IllegalStateException( "Referenced AttributeBiding has not been resolved." );
 		}
 		return referencedAttributeBinding;
 	}
 
 	@Override
 	public final EntityBinding getReferencedEntityBinding() {
 		return (EntityBinding) referencedAttributeBinding.getContainer();
 	}
 
 //	private void buildForeignKey() {
 //		// TODO: move this stuff to relational model
 //		ForeignKey foreignKey = getValue().getTable()
 //				.createForeignKey( referencedAttributeBinding.getValue().getTable(), foreignKeyName );
 //		Iterator<SimpleValue> referencingValueIterator = getSimpleValues().iterator();
 //		Iterator<SimpleValue> targetValueIterator = referencedAttributeBinding.getSimpleValues().iterator();
 //		while ( referencingValueIterator.hasNext() ) {
 //			if ( !targetValueIterator.hasNext() ) {
 //				// TODO: improve this message
 //				throw new MappingException(
 //						"number of values in many-to-one reference is greater than number of values in target"
 //				);
 //			}
 //			SimpleValue referencingValue = referencingValueIterator.next();
 //			SimpleValue targetValue = targetValueIterator.next();
 //			if ( Column.class.isInstance( referencingValue ) ) {
 //				if ( !Column.class.isInstance( targetValue ) ) {
 //					// TODO improve this message
 //					throw new MappingException( "referencing value is a column, but target is not a column" );
 //				}
 //				foreignKey.addColumnMapping( Column.class.cast( referencingValue ), Column.class.cast( targetValue ) );
 //			}
 //			else if ( Column.class.isInstance( targetValue ) ) {
 //				// TODO: improve this message
 //				throw new MappingException( "referencing value is not a column, but target is a column." );
 //			}
 //		}
 //		if ( targetValueIterator.hasNext() ) {
 //			throw new MappingException( "target value has more simple values than referencing value" );
 //		}
 //	}
 //
 //	public void validate() {
 //		// can't check this until both the domain and relational states are initialized...
 //		if ( getCascadeTypes().contains( CascadeType.DELETE_ORPHAN ) ) {
 //			if ( !isLogicalOneToOne ) {
 //				throw new MappingException(
 //						"many-to-one attribute [" + locateAttribute().getName() + "] does not support orphan delete as it is not unique"
 //				);
 //			}
 //		}
 //		//TODO: validate that the entity reference is resolved
 //	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SingularAssociationAttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SingularAssociationAttributeBinding.java
index 73b7631558..eb1e60c88d 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SingularAssociationAttributeBinding.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SingularAssociationAttributeBinding.java
@@ -1,65 +1,65 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.binding;
 
 /**
  * Contract describing the attribute binding for singular associations ({@code many-to-one}, {@code one-to-one}).
  *
  * @author Gail Badner
  * @author Steve Ebersole
  */
 @SuppressWarnings( {"JavaDoc", "UnusedDeclaration"})
 public interface SingularAssociationAttributeBinding extends SingularAttributeBinding, AssociationAttributeBinding {
 	/**
 	 * Is this association based on a property reference (non PK column(s) as target of FK)?
 	 * <p/>
 	 * Convenience form of checking {@link #getReferencedAttributeName()} for {@code null}.
 	 * 
 	 * @return
 	 */
 	public boolean isPropertyReference();
 
 	/**
 	 * Obtain the name of the referenced entity.
 	 *
 	 * @return The referenced entity name
 	 */
 	public String getReferencedEntityName();
 
 	/**
 	 * Set the name of the
 	 * @param referencedEntityName
 	 */
 	public void setReferencedEntityName(String referencedEntityName);
 
 	public String getReferencedAttributeName();
 	public void setReferencedAttributeName(String referencedAttributeName);
 
 
 	// "resolvable"
 	public void resolveReference(AttributeBinding attributeBinding);
 	public boolean isReferenceResolved();
 	public EntityBinding getReferencedEntityBinding();
 	public AttributeBinding getReferencedAttributeBinding();
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AbstractAttributeContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AbstractAttributeContainer.java
index d8bb0f35c1..3258f7de70 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AbstractAttributeContainer.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AbstractAttributeContainer.java
@@ -1,308 +1,308 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.domain;
 
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashSet;
 import java.util.Set;
 
 import org.hibernate.cfg.NotYetImplementedException;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.ValueHolder;
 
 /**
  * Convenient base class for {@link AttributeContainer}.  Because in our model all
  * {@link AttributeContainer AttributeContainers} are also {@link Hierarchical} we also implement that here
  * as well.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractAttributeContainer implements AttributeContainer, Hierarchical {
 	private final String name;
 	private final String className;
 	private final ValueHolder<Class<?>> classReference;
 	private final Hierarchical superType;
 	private LinkedHashSet<Attribute> attributeSet = new LinkedHashSet<Attribute>();
 	private HashMap<String, Attribute> attributeMap = new HashMap<String, Attribute>();
 
 	public AbstractAttributeContainer(String name, String className, ValueHolder<Class<?>> classReference, Hierarchical superType) {
 		this.name = name;
 		this.className = className;
 		this.classReference = classReference;
 		this.superType = superType;
 	}
 
 	@Override
 	public String getName() {
 		return name;
 	}
 
 	@Override
 	public String getClassName() {
 		return className;
 	}
 
 	@Override
 	public Class<?> getClassReference() {
 		return classReference.getValue();
 	}
 
 	@Override
 	public ValueHolder<Class<?>> getClassReferenceUnresolved() {
 		return classReference;
 	}
 
 	@Override
 	public Hierarchical getSuperType() {
 		return superType;
 	}
 
 	@Override
 	public Set<Attribute> attributes() {
 		return Collections.unmodifiableSet( attributeSet );
 	}
 
 	@Override
 	public String getRoleBaseName() {
 		return getClassName();
 	}
 
 	@Override
 	public Attribute locateAttribute(String name) {
 		return attributeMap.get( name );
 	}
 
 	@Override
 	public SingularAttribute locateSingularAttribute(String name) {
 		return (SingularAttribute) locateAttribute( name );
 	}
 
 	@Override
 	public SingularAttribute createSingularAttribute(String name) {
 		SingularAttribute attribute = new SingularAttributeImpl( name, this );
 		addAttribute( attribute );
 		return attribute;
 	}
 
 	@Override
 	public SingularAttribute createVirtualSingularAttribute(String name) {
 		throw new NotYetImplementedException();
 	}
 
 	@Override
 	public SingularAttribute locateComponentAttribute(String name) {
 		return (SingularAttributeImpl) locateAttribute( name );
 	}
 
 	@Override
 	public SingularAttribute createComponentAttribute(String name, Component component) {
 		SingularAttributeImpl attribute = new SingularAttributeImpl( name, this );
 		attribute.resolveType( component );
 		addAttribute( attribute );
 		return attribute;
 	}
 
 	@Override
 	public PluralAttribute locatePluralAttribute(String name) {
 		return (PluralAttribute) locateAttribute( name );
 	}
 
 	protected PluralAttribute createPluralAttribute(String name, PluralAttributeNature nature) {
 		PluralAttribute attribute = nature.isIndexed()
 				? new IndexedPluralAttributeImpl( name, nature, this )
 				: new PluralAttributeImpl( name, nature, this );
 		addAttribute( attribute );
 		return attribute;
 	}
 
 	@Override
 	public PluralAttribute locateBag(String name) {
 		return locatePluralAttribute( name );
 	}
 
 	@Override
 	public PluralAttribute createBag(String name) {
 		return createPluralAttribute( name, PluralAttributeNature.BAG );
 	}
 
 	@Override
 	public PluralAttribute locateSet(String name) {
 		return locatePluralAttribute( name );
 	}
 
 	@Override
 	public PluralAttribute createSet(String name) {
 		return createPluralAttribute( name, PluralAttributeNature.SET );
 	}
 
 	@Override
 	public IndexedPluralAttribute locateList(String name) {
 		return (IndexedPluralAttribute) locatePluralAttribute( name );
 	}
 
 	@Override
 	public IndexedPluralAttribute createList(String name) {
 		return (IndexedPluralAttribute) createPluralAttribute( name, PluralAttributeNature.LIST );
 	}
 
 	@Override
 	public IndexedPluralAttribute locateMap(String name) {
 		return (IndexedPluralAttribute) locatePluralAttribute( name );
 	}
 
 	@Override
 	public IndexedPluralAttribute createMap(String name) {
 		return (IndexedPluralAttribute) createPluralAttribute( name, PluralAttributeNature.MAP );
 	}
 
 	@Override
 	public String toString() {
 		final StringBuilder sb = new StringBuilder();
 		sb.append( "AbstractAttributeContainer" );
 		sb.append( "{name='" ).append( name ).append( '\'' );
 		sb.append( ", superType=" ).append( superType );
 		sb.append( '}' );
 		return sb.toString();
 	}
 
 	protected void addAttribute(Attribute attribute) {
 		// todo : how to best "secure" this?
 		if ( attributeMap.put( attribute.getName(), attribute ) != null ) {
 			throw new IllegalArgumentException( "Attribute with name [" + attribute.getName() + "] already registered" );
 		}
 		attributeSet.add( attribute );
 	}
 
 	// todo : inner classes for now..
 
 	public static class SingularAttributeImpl implements SingularAttribute {
 		private final AttributeContainer attributeContainer;
 		private final String name;
 		private Type type;
 
 		public SingularAttributeImpl(String name, AttributeContainer attributeContainer) {
 			this.name = name;
 			this.attributeContainer = attributeContainer;
 		}
 
 		public boolean isTypeResolved() {
 			return type != null;
 		}
 
 		public void resolveType(Type type) {
 			if ( type == null ) {
 				throw new IllegalArgumentException( "Attempt to resolve with null type" );
 			}
 			this.type = type;
 		}
 
 		@Override
 		public Type getSingularAttributeType() {
 			return type;
 		}
 
 		@Override
 		public String getName() {
 			return name;
 		}
 
 		@Override
 		public AttributeContainer getAttributeContainer() {
 			return attributeContainer;
 		}
 
 		@Override
 		public boolean isSingular() {
 			return true;
 		}
 	}
 
 	public static class PluralAttributeImpl implements PluralAttribute {
 		private final AttributeContainer attributeContainer;
 		private final PluralAttributeNature nature;
 		private final String name;
 
 		private Type elementType;
 
 		public PluralAttributeImpl(String name, PluralAttributeNature nature, AttributeContainer attributeContainer) {
 			this.name = name;
 			this.nature = nature;
 			this.attributeContainer = attributeContainer;
 		}
 
 		@Override
 		public AttributeContainer getAttributeContainer() {
 			return attributeContainer;
 		}
 
 		@Override
 		public boolean isSingular() {
 			return false;
 		}
 
 		@Override
 		public PluralAttributeNature getNature() {
 			return nature;
 		}
 
 		@Override
 		public String getName() {
 			return name;
 		}
 
 		@Override
 		public String getRole() {
 			return StringHelper.qualify( attributeContainer.getRoleBaseName(), name );
 		}
 
 		@Override
 		public Type getElementType() {
 			return elementType;
 		}
 
 		@Override
 		public void setElementType(Type elementType) {
 			this.elementType = elementType;
 		}
 	}
 
 	public static class IndexedPluralAttributeImpl extends PluralAttributeImpl implements IndexedPluralAttribute {
 		private Type indexType;
 
 		public IndexedPluralAttributeImpl(String name, PluralAttributeNature nature, AttributeContainer attributeContainer) {
 			super( name, nature, attributeContainer );
 		}
 
 		@Override
 		public Type getIndexType() {
 			return indexType;
 		}
 
 		@Override
 		public void setIndexType(Type indexType) {
 			this.indexType = indexType;
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/package-info.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/package-info.java
index 399dad768c..7a0ab7ea6a 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/package-info.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/package-info.java
@@ -1,28 +1,28 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.attribute;
 
 /**
  * This package contains binding code for attributes.
- */
\ No newline at end of file
+ */
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/package-info.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/package-info.java
index 98888c4dcb..b7331a26aa 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/package-info.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/type/package-info.java
@@ -1,28 +1,28 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.attribute.type;
 
 /**
  * This package contains type binding code for basic attributes.
- */
\ No newline at end of file
+ */
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/AbstractAnnotationFilter.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/AbstractAnnotationFilter.java
index 6e0fc9e300..103b5cea36 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/AbstractAnnotationFilter.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/AbstractAnnotationFilter.java
@@ -1,79 +1,79 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.xml.filter;
 
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.DotName;
 
 import org.hibernate.metamodel.source.annotations.xml.mocker.IndexBuilder;
 
 /**
  * @author Strong Liu
  */
 abstract class AbstractAnnotationFilter implements IndexedAnnotationFilter {
 	protected static final DotName[] EMPTY_DOTNAME_ARRAY = new DotName[0];
 	private Set<DotName> candidates;
 
 	private boolean match(DotName annName) {
 		if ( candidates == null ) {
 			candidates = new HashSet<DotName>();
 			candidates.addAll( Arrays.asList( targetAnnotation() ) );
 		}
 		return candidates.contains( annName );
 	}
 
 	@Override
 	public void beforePush(IndexBuilder indexBuilder, DotName classDotName, AnnotationInstance annotationInstance) {
 		DotName annName = annotationInstance.name();
 		if ( !match( annName ) ) {
 			return;
 		}
 		Map<DotName, List<AnnotationInstance>> map = indexBuilder.getIndexedAnnotations( classDotName );
 		overrideIndexedAnnotationMap( annName, annotationInstance, map );
 	}
 
 	protected void overrideIndexedAnnotationMap(DotName annName, AnnotationInstance annotationInstance, Map<DotName, List<AnnotationInstance>> map) {
 		if ( !map.containsKey( annName ) ) {
 			return;
 		}
 		List<AnnotationInstance> indexedAnnotationInstanceList = map.get( annName );
 		if ( indexedAnnotationInstanceList.isEmpty() ) {
 			return;
 		}
 		process( annName, annotationInstance, indexedAnnotationInstanceList );
 	}
 
 	protected void process(DotName annName, AnnotationInstance annotationInstance, List<AnnotationInstance> indexedAnnotationInstanceList) {
 	}
 
 	protected DotName[] targetAnnotation() {
 		return EMPTY_DOTNAME_ARRAY;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractAttributesBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractAttributesBuilder.java
index 0c7dc1cfe3..af1ad00d1d 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractAttributesBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractAttributesBuilder.java
@@ -1,127 +1,127 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.List;
 
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.internal.jaxb.mapping.orm.JaxbBasic;
 import org.hibernate.internal.jaxb.mapping.orm.JaxbElementCollection;
 import org.hibernate.internal.jaxb.mapping.orm.JaxbEmbedded;
 import org.hibernate.internal.jaxb.mapping.orm.JaxbEmbeddedId;
 import org.hibernate.internal.jaxb.mapping.orm.JaxbId;
 import org.hibernate.internal.jaxb.mapping.orm.JaxbManyToMany;
 import org.hibernate.internal.jaxb.mapping.orm.JaxbManyToOne;
 import org.hibernate.internal.jaxb.mapping.orm.JaxbOneToMany;
 import org.hibernate.internal.jaxb.mapping.orm.JaxbOneToOne;
 import org.hibernate.internal.jaxb.mapping.orm.JaxbTransient;
 import org.hibernate.internal.jaxb.mapping.orm.JaxbVersion;
 
 /**
  * Abstract Parser to handle {@link org.hibernate.internal.jaxb.mapping.orm.JaxbAttributes JaxbAttributes}
  * and {@link org.hibernate.internal.jaxb.mapping.orm.JaxbEmbeddableAttributes JaxbEmbeddableAttributes}.
  *
  * It would be really helpful if these two classes can implement an interface with those abstract methods in this class.
  *
  * @author Strong Liu
  */
 abstract class AbstractAttributesBuilder {
 
 	private ClassInfo classInfo;
 	private EntityMappingsMocker.Default defaults;
 	private IndexBuilder indexBuilder;
 
 	AbstractAttributesBuilder(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults) {
 		this.indexBuilder = indexBuilder;
 		this.classInfo = classInfo;
 		this.defaults = defaults;
 	}
 
 	final void parser() {
 		for ( JaxbId id : getId() ) {
 			new IdMocker( indexBuilder, classInfo, defaults, id ).process();
 		}
 		for ( JaxbTransient transientObj : getTransient() ) {
 			new TransientMocker( indexBuilder, classInfo, defaults, transientObj ).process();
 		}
 		for ( JaxbVersion version : getVersion() ) {
 			new VersionMocker( indexBuilder, classInfo, defaults, version ).process();
 		}
 
 		for ( JaxbBasic basic : getBasic() ) {
 			new BasicMocker( indexBuilder, classInfo, defaults, basic ).process();
 		}
 		for ( JaxbElementCollection elementCollection : getElementCollection() ) {
 			new ElementCollectionMocker(
 					indexBuilder, classInfo, defaults, elementCollection
 			).process();
 		}
 		for ( JaxbEmbedded embedded : getEmbedded() ) {
 			new EmbeddedMocker( indexBuilder, classInfo, defaults, embedded ).process();
 		}
 		for ( JaxbManyToMany manyToMany : getManyToMany() ) {
 			new ManyToManyMocker( indexBuilder, classInfo, defaults, manyToMany ).process();
 		}
 
 		for ( JaxbManyToOne manyToOne : getManyToOne() ) {
 			new ManyToOneMocker( indexBuilder, classInfo, defaults, manyToOne ).process();
 		}
 		for ( JaxbOneToMany oneToMany : getOneToMany() ) {
 			new OneToManyMocker(
 					indexBuilder, classInfo, defaults, oneToMany
 			).process();
 		}
 		for ( JaxbOneToOne oneToOne : getOneToOne() ) {
 			new OneToOneMocker( indexBuilder, classInfo, defaults, oneToOne ).process();
 		}
 		if ( getEmbeddedId() != null ) {
 			new EmbeddedIdMocker(
 					indexBuilder, classInfo, defaults, getEmbeddedId()
 			).process();
 		}
 	}
 
 	abstract List<JaxbId> getId();
 
 	abstract List<JaxbTransient> getTransient();
 
 	abstract List<JaxbVersion> getVersion();
 
 	abstract List<JaxbBasic> getBasic();
 
 	abstract List<JaxbElementCollection> getElementCollection();
 
 	abstract List<JaxbEmbedded> getEmbedded();
 
 	abstract List<JaxbManyToMany> getManyToMany();
 
 	abstract List<JaxbManyToOne> getManyToOne();
 
 	abstract List<JaxbOneToMany> getOneToMany();
 
 	abstract List<JaxbOneToOne> getOneToOne();
 
 	abstract JaxbEmbeddedId getEmbeddedId();
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HibernateMappingProcessor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HibernateMappingProcessor.java
index b7a4644b3b..1c40d99c1d 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HibernateMappingProcessor.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HibernateMappingProcessor.java
@@ -1,287 +1,287 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.hbm;
 
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.internal.jaxb.Origin;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbFetchProfileElement;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbHibernateMapping;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbParamElement;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbQueryElement;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbSqlQueryElement;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.ValueHolder;
 import org.hibernate.metamodel.binding.FetchProfile;
 import org.hibernate.metamodel.binding.TypeDef;
 import org.hibernate.metamodel.relational.AuxiliaryDatabaseObject;
 import org.hibernate.metamodel.relational.BasicAuxiliaryDatabaseObjectImpl;
 import org.hibernate.metamodel.source.MappingException;
 import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.type.Type;
 
 /**
  * Responsible for processing a {@code <hibernate-mapping/>} element.  Allows processing to be coordinated across
  * all hbm files in an ordered fashion.  The order is essentially the same as defined in
  * {@link org.hibernate.metamodel.source.MetadataSourceProcessor}
  *
  * @author Steve Ebersole
  */
 public class HibernateMappingProcessor {
 	private final MetadataImplementor metadata;
 	private final MappingDocument mappingDocument;
 
 	private ValueHolder<ClassLoaderService> classLoaderService = new ValueHolder<ClassLoaderService>(
 			new ValueHolder.DeferredInitializer<ClassLoaderService>() {
 				@Override
 				public ClassLoaderService initialize() {
 					return metadata.getServiceRegistry().getService( ClassLoaderService.class );
 				}
 			}
 	);
 
 	public HibernateMappingProcessor(MetadataImplementor metadata, MappingDocument mappingDocument) {
 		this.metadata = metadata;
 		this.mappingDocument = mappingDocument;
 	}
 
 	private JaxbHibernateMapping mappingRoot() {
 		return mappingDocument.getMappingRoot();
 	}
 
 	private Origin origin() {
 		return mappingDocument.getOrigin();
 	}
 
 	private HbmBindingContext bindingContext() {
 		return mappingDocument.getMappingLocalBindingContext();
 	}
 
 	private <T> Class<T> classForName(String name) {
 		return classLoaderService.getValue().classForName( bindingContext().qualifyClassName( name ) );
 	}
 
 	public void processIndependentMetadata() {
 		processDatabaseObjectDefinitions();
 		processTypeDefinitions();
 	}
 
 	private void processDatabaseObjectDefinitions() {
 		if ( mappingRoot().getDatabaseObject() == null ) {
 			return;
 		}
 
 		for ( JaxbHibernateMapping.JaxbDatabaseObject databaseObjectElement : mappingRoot().getDatabaseObject() ) {
 			final AuxiliaryDatabaseObject auxiliaryDatabaseObject;
 			if ( databaseObjectElement.getDefinition() != null ) {
 				final String className = databaseObjectElement.getDefinition().getClazz();
 				try {
 					auxiliaryDatabaseObject = (AuxiliaryDatabaseObject) classForName( className ).newInstance();
 				}
 				catch (ClassLoadingException e) {
 					throw e;
 				}
 				catch (Exception e) {
 					throw new MappingException(
 							"could not instantiate custom database object class [" + className + "]",
 							origin()
 					);
 				}
 			}
 			else {
 				Set<String> dialectScopes = new HashSet<String>();
 				if ( databaseObjectElement.getDialectScope() != null ) {
 					for ( JaxbHibernateMapping.JaxbDatabaseObject.JaxbDialectScope dialectScope : databaseObjectElement.getDialectScope() ) {
 						dialectScopes.add( dialectScope.getName() );
 					}
 				}
 				auxiliaryDatabaseObject = new BasicAuxiliaryDatabaseObjectImpl(
 						metadata.getDatabase().getDefaultSchema(),
 						databaseObjectElement.getCreate(),
 						databaseObjectElement.getDrop(),
 						dialectScopes
 				);
 			}
 			metadata.getDatabase().addAuxiliaryDatabaseObject( auxiliaryDatabaseObject );
 		}
 	}
 
 	private void processTypeDefinitions() {
 		if ( mappingRoot().getTypedef() == null ) {
 			return;
 		}
 
 		for ( JaxbHibernateMapping.JaxbTypedef typedef : mappingRoot().getTypedef() ) {
 			final Map<String, String> parameters = new HashMap<String, String>();
 			for ( JaxbParamElement paramElement : typedef.getParam() ) {
 				parameters.put( paramElement.getName(), paramElement.getValue() );
 			}
 			metadata.addTypeDefinition(
 					new TypeDef(
 							typedef.getName(),
 							typedef.getClazz(),
 							parameters
 					)
 			);
 		}
 	}
 
 	public void processTypeDependentMetadata() {
 		processFilterDefinitions();
 		processIdentifierGenerators();
 	}
 
 	private void processFilterDefinitions() {
 		if ( mappingRoot().getFilterDef() == null ) {
 			return;
 		}
 
 		for ( JaxbHibernateMapping.JaxbFilterDef filterDefinition : mappingRoot().getFilterDef() ) {
 			final String name = filterDefinition.getName();
 			final Map<String,Type> parameters = new HashMap<String, Type>();
 			String condition = null;
 			for ( Object o : filterDefinition.getContent() ) {
 				if ( o instanceof String ) {
 					// represents the condition
 					if ( condition != null ) {
 						// log?
 					}
 					condition = (String) o;
 				}
 				else if ( o instanceof JaxbHibernateMapping.JaxbFilterDef.JaxbFilterParam ) {
 					final JaxbHibernateMapping.JaxbFilterDef.JaxbFilterParam paramElement =
 							JaxbHibernateMapping.JaxbFilterDef.JaxbFilterParam.class.cast( o );
 					// todo : should really delay this resolution until later to allow typedef names
 					parameters.put(
 							paramElement.getName(),
 							metadata.getTypeResolver().heuristicType( paramElement.getType() )
 					);
 				}
 				else {
 					throw new MappingException( "Unrecognized nested filter content", origin() );
 				}
 			}
 			if ( condition == null ) {
 				condition = filterDefinition.getCondition();
 			}
 			metadata.addFilterDefinition( new FilterDefinition( name, condition, parameters ) );
 		}
 	}
 
 	private void processIdentifierGenerators() {
 		if ( mappingRoot().getIdentifierGenerator() == null ) {
 			return;
 		}
 
 		for ( JaxbHibernateMapping.JaxbIdentifierGenerator identifierGeneratorElement : mappingRoot().getIdentifierGenerator() ) {
 			metadata.registerIdentifierGenerator(
 					identifierGeneratorElement.getName(),
 					identifierGeneratorElement.getClazz()
 			);
 		}
 	}
 
 	public void processMappingDependentMetadata() {
 		processFetchProfiles();
 		processImports();
 		processResultSetMappings();
 		processNamedQueries();
 	}
 
 	private void processFetchProfiles(){
 		if ( mappingRoot().getFetchProfile() == null ) {
 			return;
 		}
 
 		processFetchProfiles( mappingRoot().getFetchProfile(), null );
 	}
 
 	public void processFetchProfiles(List<JaxbFetchProfileElement> fetchProfiles, String containingEntityName) {
 		for ( JaxbFetchProfileElement fetchProfile : fetchProfiles ) {
 			String profileName = fetchProfile.getName();
 			Set<FetchProfile.Fetch> fetches = new HashSet<FetchProfile.Fetch>();
 			for ( JaxbFetchProfileElement.JaxbFetch fetch : fetchProfile.getFetch() ) {
 				String entityName = fetch.getEntity() == null ? containingEntityName : fetch.getEntity();
 				if ( entityName == null ) {
 					throw new MappingException(
 							"could not determine entity for fetch-profile fetch [" + profileName + "]:[" +
 									fetch.getAssociation() + "]",
 							origin()
 					);
 				}
 				fetches.add( new FetchProfile.Fetch( entityName, fetch.getAssociation(), fetch.getStyle() ) );
 			}
 			metadata.addFetchProfile( new FetchProfile( profileName, fetches ) );
 		}
 	}
 
 	private void processImports() {
 		if ( mappingRoot().getImport() == null ) {
 			return;
 		}
 
 		for ( JaxbHibernateMapping.JaxbImport importValue : mappingRoot().getImport() ) {
 			String className = mappingDocument.getMappingLocalBindingContext().qualifyClassName( importValue.getClazz() );
 			String rename = importValue.getRename();
 			rename = ( rename == null ) ? StringHelper.unqualify( className ) : rename;
 			metadata.addImport( className, rename );
 		}
 	}
 
 	private void processResultSetMappings() {
 		if ( mappingRoot().getResultset() == null ) {
 			return;
 		}
 
 //			bindResultSetMappingDefinitions( element, null, mappings );
 	}
 
 	private void processNamedQueries() {
 		if ( mappingRoot().getQueryOrSqlQuery() == null ) {
 			return;
 		}
 
 		for ( Object queryOrSqlQuery : mappingRoot().getQueryOrSqlQuery() ) {
 			if ( JaxbQueryElement.class.isInstance( queryOrSqlQuery ) ) {
 //					bindNamedQuery( element, null, mappings );
 			}
 			else if ( JaxbSqlQueryElement.class.isInstance( queryOrSqlQuery ) ) {
 //				bindNamedSQLQuery( element, null, mappings );
 			}
 			else {
 				throw new MappingException(
 						"unknown type of query: " +
 								queryOrSqlQuery.getClass().getName(), origin()
 				);
 			}
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImpl.java
index 2a1f3cf45f..85a700a8af 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImpl.java
@@ -1,99 +1,99 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.internal;
 
 import java.io.Serializable;
 
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.Interceptor;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.SessionFactory;
 import org.hibernate.boot.registry.StandardServiceRegistry;
 import org.hibernate.internal.SessionFactoryImpl;
 import org.hibernate.metamodel.SessionFactoryBuilder;
 import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 
 /**
  * @author Gail Badner
  */
 public class SessionFactoryBuilderImpl implements SessionFactoryBuilder {
 	SessionFactoryOptionsImpl options;
 
 	private final MetadataImplementor metadata;
 
 	/* package-protected */
 	SessionFactoryBuilderImpl(MetadataImplementor metadata) {
 		this.metadata = metadata;
 		options = new SessionFactoryOptionsImpl( metadata.getOptions().getServiceRegistry() );
 	}
 
 	@Override
 	public SessionFactoryBuilder with(Interceptor interceptor) {
 		this.options.interceptor = interceptor;
 		return this;
 	}
 
 	@Override
 	public SessionFactoryBuilder with(EntityNotFoundDelegate entityNotFoundDelegate) {
 		this.options.entityNotFoundDelegate = entityNotFoundDelegate;
 		return this;
 	}
 
 	@Override
 	public SessionFactory build() {
 		return new SessionFactoryImpl(metadata, options, null );
 	}
 
 	private static class SessionFactoryOptionsImpl implements SessionFactory.SessionFactoryOptions {
 		private final StandardServiceRegistry serviceRegistry;
 		private Interceptor interceptor = EmptyInterceptor.INSTANCE;
 		
 		public SessionFactoryOptionsImpl(StandardServiceRegistry serviceRegistry) {
 			this.serviceRegistry = serviceRegistry;
 		}
 
 		// TODO: should there be a DefaultEntityNotFoundDelegate.INSTANCE?
 		private EntityNotFoundDelegate entityNotFoundDelegate = new EntityNotFoundDelegate() {
 				public void handleEntityNotFound(String entityName, Serializable id) {
 					throw new ObjectNotFoundException( id, entityName );
 				}
 		};
 
 		@Override
 		public StandardServiceRegistry getServiceRegistry() {
 			return serviceRegistry;
 		}
 
 		@Override
 		public Interceptor getInterceptor() {
 			return interceptor;
 		}
 
 		@Override
 		public EntityNotFoundDelegate getEntityNotFoundDelegate() {
 			return entityNotFoundDelegate;
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/collection/ElementPropertyMapping.java b/hibernate-core/src/main/java/org/hibernate/persister/collection/ElementPropertyMapping.java
index 495ac8a773..54b9012897 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/collection/ElementPropertyMapping.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/collection/ElementPropertyMapping.java
@@ -1,75 +1,75 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.persister.collection;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.persister.entity.PropertyMapping;
 import org.hibernate.type.Type;
 
 /**
  * @author Gavin King
  */
 public class ElementPropertyMapping implements PropertyMapping {
 
 	private final String[] elementColumns;
 	private final Type type;
 
 	public ElementPropertyMapping(String[] elementColumns, Type type)
 	throws MappingException {
 		this.elementColumns = elementColumns;
 		this.type = type;
 	}
 
 	public Type toType(String propertyName) throws QueryException {
 		if ( propertyName==null || "id".equals(propertyName) ) {
 			return type;
 		}
 		else {
 			throw new QueryException("cannot dereference scalar collection element: " + propertyName);
 		}
 	}
 
 	public String[] toColumns(String alias, String propertyName) throws QueryException {
 		if (propertyName==null || "id".equals(propertyName) ) {
 			return StringHelper.qualify( alias, elementColumns );
 		}
 		else {
 			throw new QueryException("cannot dereference scalar collection element: " + propertyName);
 		}
 	}
 
 	/**
 	 * Given a property path, return the corresponding column name(s).
 	 */
 	public String[] toColumns(String propertyName) throws QueryException, UnsupportedOperationException {
 		throw new UnsupportedOperationException( "References to collections must be define a SQL alias" );
 	}
 
 	public Type getType() {
 		return type;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/collection/NamedQueryCollectionInitializer.java b/hibernate-core/src/main/java/org/hibernate/persister/collection/NamedQueryCollectionInitializer.java
index 335c5cb270..0a097d3377 100755
--- a/hibernate-core/src/main/java/org/hibernate/persister/collection/NamedQueryCollectionInitializer.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/collection/NamedQueryCollectionInitializer.java
@@ -1,77 +1,77 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.persister.collection;
 import java.io.Serializable;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.FlushMode;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.AbstractQueryImpl;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.loader.collection.CollectionInitializer;
 
 /**
  * A wrapper around a named query.
  * @author Gavin King
  */
 public final class NamedQueryCollectionInitializer implements CollectionInitializer {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        NamedQueryCollectionInitializer.class.getName());
 
     private final String queryName;
 	private final CollectionPersister persister;
 
 	public NamedQueryCollectionInitializer(String queryName, CollectionPersister persister) {
 		super();
 		this.queryName = queryName;
 		this.persister = persister;
 	}
 
 	public void initialize(Serializable key, SessionImplementor session)
 	throws HibernateException {
 
         LOG.debugf("Initializing collection: %s using named query: %s", persister.getRole(), queryName);
 
 		//TODO: is there a more elegant way than downcasting?
 		AbstractQueryImpl query = (AbstractQueryImpl) session.getNamedSQLQuery(queryName);
 		if ( query.getNamedParameters().length>0 ) {
 			query.setParameter(
 					query.getNamedParameters()[0],
 					key,
 					persister.getKeyType()
 				);
 		}
 		else {
 			query.setParameter( 0, key, persister.getKeyType() );
 		}
 		query.setCollectionKey( key )
 				.setFlushMode( FlushMode.MANUAL )
 				.list();
 
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java b/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
index 9552291f79..3ad089ffe0 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/entity/AbstractEntityPersister.java
@@ -1,1774 +1,1774 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.entity;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.EntityMode;
 import org.hibernate.FetchMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.StaleStateException;
 import org.hibernate.bytecode.instrumentation.spi.FieldInterceptor;
 import org.hibernate.bytecode.instrumentation.spi.LazyPropertyInitializer;
 import org.hibernate.bytecode.spi.EntityInstrumentationMetadata;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.access.NaturalIdRegionAccessStrategy;
 import org.hibernate.cache.spi.entry.CacheEntry;
 import org.hibernate.cache.spi.entry.CacheEntryStructure;
 import org.hibernate.cache.spi.entry.ReferenceCacheEntryImpl;
 import org.hibernate.cache.spi.entry.StandardCacheEntryImpl;
 import org.hibernate.cache.spi.entry.StructuredCacheEntry;
 import org.hibernate.cache.spi.entry.UnstructuredCacheEntry;
 import org.hibernate.dialect.lock.LockingStrategy;
 import org.hibernate.engine.OptimisticLockStyle;
 import org.hibernate.engine.internal.StatefulPersistenceContext;
 import org.hibernate.engine.internal.Versioning;
 import org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;
 import org.hibernate.engine.spi.CachedNaturalIdValueSource;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.CascadeStyles;
 import org.hibernate.engine.spi.CascadingActions;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.engine.spi.LoadQueryInfluencers;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.PersistenceContext.NaturalIdHelper;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.spi.ValueInclusion;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.PostInsertIdentifierGenerator;
 import org.hibernate.id.PostInsertIdentityPersister;
 import org.hibernate.id.insert.Binder;
 import org.hibernate.id.insert.InsertGeneratedIdentifierDelegate;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.FilterConfiguration;
 import org.hibernate.internal.FilterHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.jdbc.Expectation;
 import org.hibernate.jdbc.Expectations;
 import org.hibernate.jdbc.TooManyRowsAffectedException;
 import org.hibernate.loader.entity.BatchingEntityLoaderBuilder;
 import org.hibernate.loader.entity.CascadeEntityLoader;
 import org.hibernate.loader.entity.EntityLoader;
 import org.hibernate.loader.entity.UniqueEntityLoader;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Selectable;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.metamodel.binding.AssociationAttributeBinding;
 import org.hibernate.metamodel.binding.AttributeBinding;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.binding.SimpleValueBinding;
 import org.hibernate.metamodel.binding.SingularAttributeBinding;
 import org.hibernate.metamodel.relational.DerivedValue;
 import org.hibernate.metamodel.relational.Value;
 import org.hibernate.persister.walking.internal.EntityIdentifierDefinitionHelper;
 import org.hibernate.persister.walking.spi.AttributeDefinition;
 import org.hibernate.persister.walking.spi.EntityIdentifierDefinition;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.property.BackrefPropertyAccessor;
 import org.hibernate.sql.Alias;
 import org.hibernate.sql.Delete;
 import org.hibernate.sql.Insert;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.sql.JoinType;
 import org.hibernate.sql.Select;
 import org.hibernate.sql.SelectFragment;
 import org.hibernate.sql.SimpleSelect;
 import org.hibernate.sql.Template;
 import org.hibernate.sql.Update;
 import org.hibernate.tuple.entity.EntityMetamodel;
 import org.hibernate.tuple.entity.EntityTuplizer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.CompositeType;
 import org.hibernate.type.EntityType;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeHelper;
 import org.hibernate.type.VersionType;
 import org.jboss.logging.Logger;
 
 /**
  * Basic functionality for persisting an entity via JDBC
  * through either generated or custom SQL
  *
  * @author Gavin King
  */
 public abstract class AbstractEntityPersister
 		implements OuterJoinLoadable, Queryable, ClassMetadata, UniqueKeyLoadable,
 				   SQLLoadable, LazyPropertyInitializer, PostInsertIdentityPersister, Lockable {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        AbstractEntityPersister.class.getName());
 
 	public static final String ENTITY_CLASS = "class";
 
 	// moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	private final SessionFactoryImplementor factory;
 	private final EntityRegionAccessStrategy cacheAccessStrategy;
 	private final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy;
 	private final boolean isLazyPropertiesCacheable;
 	private final CacheEntryHelper cacheEntryHelper;
 	private final EntityMetamodel entityMetamodel;
 	private final EntityTuplizer entityTuplizer;
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	private final String[] rootTableKeyColumnNames;
 	private final String[] rootTableKeyColumnReaders;
 	private final String[] rootTableKeyColumnReaderTemplates;
 	private final String[] identifierAliases;
 	private final int identifierColumnSpan;
 	private final String versionColumnName;
 	private final boolean hasFormulaProperties;
 	private final int batchSize;
 	private final boolean hasSubselectLoadableCollections;
 	protected final String rowIdName;
 
 	private final Set lazyProperties;
 
 	// The optional SQL string defined in the where attribute
 	private final String sqlWhereString;
 	private final String sqlWhereStringTemplate;
 
 	//information about properties of this class,
 	//including inherited properties
 	//(only really needed for updatable/insertable properties)
 	private final int[] propertyColumnSpans;
 	private final String[] propertySubclassNames;
 	private final String[][] propertyColumnAliases;
 	private final String[][] propertyColumnNames;
 	private final String[][] propertyColumnFormulaTemplates;
 	private final String[][] propertyColumnReaderTemplates;
 	private final String[][] propertyColumnWriters;
 	private final boolean[][] propertyColumnUpdateable;
 	private final boolean[][] propertyColumnInsertable;
 	private final boolean[] propertyUniqueness;
 	private final boolean[] propertySelectable;
 	
 	private final List<Integer> lobProperties = new ArrayList<Integer>();
 
 	//information about lazy properties of this class
 	private final String[] lazyPropertyNames;
 	private final int[] lazyPropertyNumbers;
 	private final Type[] lazyPropertyTypes;
 	private final String[][] lazyPropertyColumnAliases;
 
 	//information about all properties in class hierarchy
 	private final String[] subclassPropertyNameClosure;
 	private final String[] subclassPropertySubclassNameClosure;
 	private final Type[] subclassPropertyTypeClosure;
 	private final String[][] subclassPropertyFormulaTemplateClosure;
 	private final String[][] subclassPropertyColumnNameClosure;
 	private final String[][] subclassPropertyColumnReaderClosure;
 	private final String[][] subclassPropertyColumnReaderTemplateClosure;
 	private final FetchMode[] subclassPropertyFetchModeClosure;
 	private final boolean[] subclassPropertyNullabilityClosure;
 	private final boolean[] propertyDefinedOnSubclass;
 	private final int[][] subclassPropertyColumnNumberClosure;
 	private final int[][] subclassPropertyFormulaNumberClosure;
 	private final CascadeStyle[] subclassPropertyCascadeStyleClosure;
 
 	//information about all columns/formulas in class hierarchy
 	private final String[] subclassColumnClosure;
 	private final boolean[] subclassColumnLazyClosure;
 	private final String[] subclassColumnAliasClosure;
 	private final boolean[] subclassColumnSelectableClosure;
 	private final String[] subclassColumnReaderTemplateClosure;
 	private final String[] subclassFormulaClosure;
 	private final String[] subclassFormulaTemplateClosure;
 	private final String[] subclassFormulaAliasClosure;
 	private final boolean[] subclassFormulaLazyClosure;
 
 	// dynamic filters attached to the class-level
 	private final FilterHelper filterHelper;
 
 	private final Set affectingFetchProfileNames = new HashSet();
 
 	private final Map uniqueKeyLoaders = new HashMap();
 	private final Map lockers = new HashMap();
 	private final Map loaders = new HashMap();
 
 	// SQL strings
 	private String sqlVersionSelectString;
 	private String sqlSnapshotSelectString;
 	private String sqlLazySelectString;
 
 	private String sqlIdentityInsertString;
 	private String sqlUpdateByRowIdString;
 	private String sqlLazyUpdateByRowIdString;
 
 	private String[] sqlDeleteStrings;
 	private String[] sqlInsertStrings;
 	private String[] sqlUpdateStrings;
 	private String[] sqlLazyUpdateStrings;
 
 	private String sqlInsertGeneratedValuesSelectString;
 	private String sqlUpdateGeneratedValuesSelectString;
 
 	//Custom SQL (would be better if these were private)
 	protected boolean[] insertCallable;
 	protected boolean[] updateCallable;
 	protected boolean[] deleteCallable;
 	protected String[] customSQLInsert;
 	protected String[] customSQLUpdate;
 	protected String[] customSQLDelete;
 	protected ExecuteUpdateResultCheckStyle[] insertResultCheckStyles;
 	protected ExecuteUpdateResultCheckStyle[] updateResultCheckStyles;
 	protected ExecuteUpdateResultCheckStyle[] deleteResultCheckStyles;
 
 	private InsertGeneratedIdentifierDelegate identityDelegate;
 
 	private boolean[] tableHasColumns;
 
 	private final String loaderName;
 
 	private UniqueEntityLoader queryLoader;
 
 	private final String temporaryIdTableName;
 	private final String temporaryIdTableDDL;
 
 	private final Map subclassPropertyAliases = new HashMap();
 	private final Map subclassPropertyColumnNames = new HashMap();
 
 	protected final BasicEntityPropertyMapping propertyMapping;
 
 	protected void addDiscriminatorToInsert(Insert insert) {}
 
 	protected void addDiscriminatorToSelect(SelectFragment select, String name, String suffix) {}
 
 	protected abstract int[] getSubclassColumnTableNumberClosure();
 
 	protected abstract int[] getSubclassFormulaTableNumberClosure();
 
 	public abstract String getSubclassTableName(int j);
 
 	protected abstract String[] getSubclassTableKeyColumns(int j);
 
 	protected abstract boolean isClassOrSuperclassTable(int j);
 
 	protected abstract int getSubclassTableSpan();
 
 	protected abstract int getTableSpan();
 
 	protected abstract boolean isTableCascadeDeleteEnabled(int j);
 
 	protected abstract String getTableName(int j);
 
 	protected abstract String[] getKeyColumns(int j);
 
 	protected abstract boolean isPropertyOfTable(int property, int j);
 
 	protected abstract int[] getPropertyTableNumbersInSelect();
 
 	protected abstract int[] getPropertyTableNumbers();
 
 	protected abstract int getSubclassPropertyTableNumber(int i);
 
 	protected abstract String filterFragment(String alias) throws MappingException;
 
 	private static final String DISCRIMINATOR_ALIAS = "clazz_";
 
 	public String getDiscriminatorColumnName() {
 		return DISCRIMINATOR_ALIAS;
 	}
 
 	public String getDiscriminatorColumnReaders() {
 		return DISCRIMINATOR_ALIAS;
 	}
 
 	public String getDiscriminatorColumnReaderTemplate() {
 		return DISCRIMINATOR_ALIAS;
 	}
 
 	protected String getDiscriminatorAlias() {
 		return DISCRIMINATOR_ALIAS;
 	}
 
 	protected String getDiscriminatorFormulaTemplate() {
 		return null;
 	}
 
 	protected boolean isInverseTable(int j) {
 		return false;
 	}
 
 	protected boolean isNullableTable(int j) {
 		return false;
 	}
 
 	protected boolean isNullableSubclassTable(int j) {
 		return false;
 	}
 
 	protected boolean isInverseSubclassTable(int j) {
 		return false;
 	}
 
 	public boolean isSubclassEntityName(String entityName) {
 		return entityMetamodel.getSubclassEntityNames().contains(entityName);
 	}
 
 	private boolean[] getTableHasColumns() {
 		return tableHasColumns;
 	}
 
 	public String[] getRootTableKeyColumnNames() {
 		return rootTableKeyColumnNames;
 	}
 
 	protected String[] getSQLUpdateByRowIdStrings() {
 		if ( sqlUpdateByRowIdString == null ) {
 			throw new AssertionFailure( "no update by row id" );
 		}
 		String[] result = new String[getTableSpan() + 1];
 		result[0] = sqlUpdateByRowIdString;
 		System.arraycopy( sqlUpdateStrings, 0, result, 1, getTableSpan() );
 		return result;
 	}
 
 	protected String[] getSQLLazyUpdateByRowIdStrings() {
 		if ( sqlLazyUpdateByRowIdString == null ) {
 			throw new AssertionFailure( "no update by row id" );
 		}
 		String[] result = new String[getTableSpan()];
 		result[0] = sqlLazyUpdateByRowIdString;
 		for ( int i = 1; i < getTableSpan(); i++ ) {
 			result[i] = sqlLazyUpdateStrings[i];
 		}
 		return result;
 	}
 
 	protected String getSQLSnapshotSelectString() {
 		return sqlSnapshotSelectString;
 	}
 
 	protected String getSQLLazySelectString() {
 		return sqlLazySelectString;
 	}
 
 	protected String[] getSQLDeleteStrings() {
 		return sqlDeleteStrings;
 	}
 
 	protected String[] getSQLInsertStrings() {
 		return sqlInsertStrings;
 	}
 
 	protected String[] getSQLUpdateStrings() {
 		return sqlUpdateStrings;
 	}
 
 	protected String[] getSQLLazyUpdateStrings() {
 		return sqlLazyUpdateStrings;
 	}
 
 	/**
 	 * The query that inserts a row, letting the database generate an id
 	 *
 	 * @return The IDENTITY-based insertion query.
 	 */
 	protected String getSQLIdentityInsertString() {
 		return sqlIdentityInsertString;
 	}
 
 	protected String getVersionSelectString() {
 		return sqlVersionSelectString;
 	}
 
 	protected boolean isInsertCallable(int j) {
 		return insertCallable[j];
 	}
 
 	protected boolean isUpdateCallable(int j) {
 		return updateCallable[j];
 	}
 
 	protected boolean isDeleteCallable(int j) {
 		return deleteCallable[j];
 	}
 
 	protected boolean isSubclassPropertyDeferred(String propertyName, String entityName) {
 		return false;
 	}
 
 	protected boolean isSubclassTableSequentialSelect(int j) {
 		return false;
 	}
 
 	public boolean hasSequentialSelect() {
 		return false;
 	}
 
 	/**
 	 * Decide which tables need to be updated.
 	 * <p/>
 	 * The return here is an array of boolean values with each index corresponding
 	 * to a given table in the scope of this persister.
 	 *
 	 * @param dirtyProperties The indices of all the entity properties considered dirty.
 	 * @param hasDirtyCollection Whether any collections owned by the entity which were considered dirty.
 	 *
 	 * @return Array of booleans indicating which table require updating.
 	 */
 	protected boolean[] getTableUpdateNeeded(final int[] dirtyProperties, boolean hasDirtyCollection) {
 
 		if ( dirtyProperties == null ) {
 			return getTableHasColumns(); // for objects that came in via update()
 		}
 		else {
 			boolean[] updateability = getPropertyUpdateability();
 			int[] propertyTableNumbers = getPropertyTableNumbers();
 			boolean[] tableUpdateNeeded = new boolean[ getTableSpan() ];
 			for ( int i = 0; i < dirtyProperties.length; i++ ) {
 				int property = dirtyProperties[i];
 				int table = propertyTableNumbers[property];
 				tableUpdateNeeded[table] = tableUpdateNeeded[table] ||
 						( getPropertyColumnSpan(property) > 0 && updateability[property] );
 			}
 			if ( isVersioned() ) {
 				tableUpdateNeeded[0] = tableUpdateNeeded[0] ||
 					Versioning.isVersionIncrementRequired( dirtyProperties, hasDirtyCollection, getPropertyVersionability() );
 			}
 			return tableUpdateNeeded;
 		}
 	}
 
 	public boolean hasRowId() {
 		return rowIdName != null;
 	}
 
 	protected boolean[][] getPropertyColumnUpdateable() {
 		return propertyColumnUpdateable;
 	}
 
 	protected boolean[][] getPropertyColumnInsertable() {
 		return propertyColumnInsertable;
 	}
 
 	protected boolean[] getPropertySelectable() {
 		return propertySelectable;
 	}
 
 	public AbstractEntityPersister(
 			final PersistentClass persistentClass,
 			final EntityRegionAccessStrategy cacheAccessStrategy,
 			final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
 			final SessionFactoryImplementor factory) throws HibernateException {
 
 		// moved up from AbstractEntityPersister ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		this.factory = factory;
 		this.cacheAccessStrategy = cacheAccessStrategy;
 		this.naturalIdRegionAccessStrategy = naturalIdRegionAccessStrategy;
 		isLazyPropertiesCacheable = persistentClass.isLazyPropertiesCacheable();
 
 		this.entityMetamodel = new EntityMetamodel( persistentClass, this, factory );
 		this.entityTuplizer = this.entityMetamodel.getTuplizer();
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 		int batch = persistentClass.getBatchSize();
 		if ( batch == -1 ) {
 			batch = factory.getSettings().getDefaultBatchFetchSize();
 		}
 		batchSize = batch;
 		hasSubselectLoadableCollections = persistentClass.hasSubselectLoadableCollections();
 
 		propertyMapping = new BasicEntityPropertyMapping( this );
 
 		// IDENTIFIER
 
 		identifierColumnSpan = persistentClass.getIdentifier().getColumnSpan();
 		rootTableKeyColumnNames = new String[identifierColumnSpan];
 		rootTableKeyColumnReaders = new String[identifierColumnSpan];
 		rootTableKeyColumnReaderTemplates = new String[identifierColumnSpan];
 		identifierAliases = new String[identifierColumnSpan];
 
 		rowIdName = persistentClass.getRootTable().getRowId();
 
 		loaderName = persistentClass.getLoaderName();
 
 		Iterator iter = persistentClass.getIdentifier().getColumnIterator();
 		int i = 0;
 		while ( iter.hasNext() ) {
 			Column col = ( Column ) iter.next();
 			rootTableKeyColumnNames[i] = col.getQuotedName( factory.getDialect() );
 			rootTableKeyColumnReaders[i] = col.getReadExpr( factory.getDialect() );
 			rootTableKeyColumnReaderTemplates[i] = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 			identifierAliases[i] = col.getAlias( factory.getDialect(), persistentClass.getRootTable() );
 			i++;
 		}
 
 		// VERSION
 
 		if ( persistentClass.isVersioned() ) {
 			versionColumnName = ( ( Column ) persistentClass.getVersion().getColumnIterator().next() ).getQuotedName( factory.getDialect() );
 		}
 		else {
 			versionColumnName = null;
 		}
 
 		//WHERE STRING
 
 		sqlWhereString = StringHelper.isNotEmpty( persistentClass.getWhere() ) ? "( " + persistentClass.getWhere() + ") " : null;
 		sqlWhereStringTemplate = sqlWhereString == null ?
 				null :
 				Template.renderWhereStringTemplate( sqlWhereString, factory.getDialect(), factory.getSqlFunctionRegistry() );
 
 		// PROPERTIES
 
 		final boolean lazyAvailable = isInstrumented();
 
 		int hydrateSpan = entityMetamodel.getPropertySpan();
 		propertyColumnSpans = new int[hydrateSpan];
 		propertySubclassNames = new String[hydrateSpan];
 		propertyColumnAliases = new String[hydrateSpan][];
 		propertyColumnNames = new String[hydrateSpan][];
 		propertyColumnFormulaTemplates = new String[hydrateSpan][];
 		propertyColumnReaderTemplates = new String[hydrateSpan][];
 		propertyColumnWriters = new String[hydrateSpan][];
 		propertyUniqueness = new boolean[hydrateSpan];
 		propertySelectable = new boolean[hydrateSpan];
 		propertyColumnUpdateable = new boolean[hydrateSpan][];
 		propertyColumnInsertable = new boolean[hydrateSpan][];
 		HashSet thisClassProperties = new HashSet();
 
 		lazyProperties = new HashSet();
 		ArrayList lazyNames = new ArrayList();
 		ArrayList lazyNumbers = new ArrayList();
 		ArrayList lazyTypes = new ArrayList();
 		ArrayList lazyColAliases = new ArrayList();
 
 		iter = persistentClass.getPropertyClosureIterator();
 		i = 0;
 		boolean foundFormula = false;
 		while ( iter.hasNext() ) {
 			Property prop = ( Property ) iter.next();
 			thisClassProperties.add( prop );
 
 			int span = prop.getColumnSpan();
 			propertyColumnSpans[i] = span;
 			propertySubclassNames[i] = prop.getPersistentClass().getEntityName();
 			String[] colNames = new String[span];
 			String[] colAliases = new String[span];
 			String[] colReaderTemplates = new String[span];
 			String[] colWriters = new String[span];
 			String[] formulaTemplates = new String[span];
 			Iterator colIter = prop.getColumnIterator();
 			int k = 0;
 			while ( colIter.hasNext() ) {
 				Selectable thing = ( Selectable ) colIter.next();
 				colAliases[k] = thing.getAlias( factory.getDialect() , prop.getValue().getTable() );
 				if ( thing.isFormula() ) {
 					foundFormula = true;
 					formulaTemplates[k] = thing.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 				}
 				else {
 					Column col = (Column)thing;
 					colNames[k] = col.getQuotedName( factory.getDialect() );
 					colReaderTemplates[k] = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 					colWriters[k] = col.getWriteExpr();
 				}
 				k++;
 			}
 			propertyColumnNames[i] = colNames;
 			propertyColumnFormulaTemplates[i] = formulaTemplates;
 			propertyColumnReaderTemplates[i] = colReaderTemplates;
 			propertyColumnWriters[i] = colWriters;
 			propertyColumnAliases[i] = colAliases;
 
 			if ( lazyAvailable && prop.isLazy() ) {
 				lazyProperties.add( prop.getName() );
 				lazyNames.add( prop.getName() );
 				lazyNumbers.add( i );
 				lazyTypes.add( prop.getValue().getType() );
 				lazyColAliases.add( colAliases );
 			}
 
 			propertyColumnUpdateable[i] = prop.getValue().getColumnUpdateability();
 			propertyColumnInsertable[i] = prop.getValue().getColumnInsertability();
 
 			propertySelectable[i] = prop.isSelectable();
 
 			propertyUniqueness[i] = prop.getValue().isAlternateUniqueKey();
 			
 			if (prop.isLob() && getFactory().getDialect().forceLobAsLastValue() ) {
 				lobProperties.add( i );
 			}
 
 			i++;
 
 		}
 		hasFormulaProperties = foundFormula;
 		lazyPropertyColumnAliases = ArrayHelper.to2DStringArray( lazyColAliases );
 		lazyPropertyNames = ArrayHelper.toStringArray( lazyNames );
 		lazyPropertyNumbers = ArrayHelper.toIntArray( lazyNumbers );
 		lazyPropertyTypes = ArrayHelper.toTypeArray( lazyTypes );
 
 		// SUBCLASS PROPERTY CLOSURE
 
 		ArrayList columns = new ArrayList();
 		ArrayList columnsLazy = new ArrayList();
 		ArrayList columnReaderTemplates = new ArrayList();
 		ArrayList aliases = new ArrayList();
 		ArrayList formulas = new ArrayList();
 		ArrayList formulaAliases = new ArrayList();
 		ArrayList formulaTemplates = new ArrayList();
 		ArrayList formulasLazy = new ArrayList();
 		ArrayList types = new ArrayList();
 		ArrayList names = new ArrayList();
 		ArrayList classes = new ArrayList();
 		ArrayList templates = new ArrayList();
 		ArrayList propColumns = new ArrayList();
 		ArrayList propColumnReaders = new ArrayList();
 		ArrayList propColumnReaderTemplates = new ArrayList();
 		ArrayList joinedFetchesList = new ArrayList();
 		ArrayList cascades = new ArrayList();
 		ArrayList definedBySubclass = new ArrayList();
 		ArrayList propColumnNumbers = new ArrayList();
 		ArrayList propFormulaNumbers = new ArrayList();
 		ArrayList columnSelectables = new ArrayList();
 		ArrayList propNullables = new ArrayList();
 
 		iter = persistentClass.getSubclassPropertyClosureIterator();
 		while ( iter.hasNext() ) {
 			Property prop = ( Property ) iter.next();
 			names.add( prop.getName() );
 			classes.add( prop.getPersistentClass().getEntityName() );
 			boolean isDefinedBySubclass = !thisClassProperties.contains( prop );
 			definedBySubclass.add( Boolean.valueOf( isDefinedBySubclass ) );
 			propNullables.add( Boolean.valueOf( prop.isOptional() || isDefinedBySubclass ) ); //TODO: is this completely correct?
 			types.add( prop.getType() );
 
 			Iterator colIter = prop.getColumnIterator();
 			String[] cols = new String[prop.getColumnSpan()];
 			String[] readers = new String[prop.getColumnSpan()];
 			String[] readerTemplates = new String[prop.getColumnSpan()];
 			String[] forms = new String[prop.getColumnSpan()];
 			int[] colnos = new int[prop.getColumnSpan()];
 			int[] formnos = new int[prop.getColumnSpan()];
 			int l = 0;
 			Boolean lazy = Boolean.valueOf( prop.isLazy() && lazyAvailable );
 			while ( colIter.hasNext() ) {
 				Selectable thing = ( Selectable ) colIter.next();
 				if ( thing.isFormula() ) {
 					String template = thing.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 					formnos[l] = formulaTemplates.size();
 					colnos[l] = -1;
 					formulaTemplates.add( template );
 					forms[l] = template;
 					formulas.add( thing.getText( factory.getDialect() ) );
 					formulaAliases.add( thing.getAlias( factory.getDialect() ) );
 					formulasLazy.add( lazy );
 				}
 				else {
 					Column col = (Column)thing;
 					String colName = col.getQuotedName( factory.getDialect() );
 					colnos[l] = columns.size(); //before add :-)
 					formnos[l] = -1;
 					columns.add( colName );
 					cols[l] = colName;
 					aliases.add( thing.getAlias( factory.getDialect(), prop.getValue().getTable() ) );
 					columnsLazy.add( lazy );
 					columnSelectables.add( Boolean.valueOf( prop.isSelectable() ) );
 
 					readers[l] = col.getReadExpr( factory.getDialect() );
 					String readerTemplate = col.getTemplate( factory.getDialect(), factory.getSqlFunctionRegistry() );
 					readerTemplates[l] = readerTemplate;
 					columnReaderTemplates.add( readerTemplate );
 				}
 				l++;
 			}
 			propColumns.add( cols );
 			propColumnReaders.add( readers );
 			propColumnReaderTemplates.add( readerTemplates );
 			templates.add( forms );
 			propColumnNumbers.add( colnos );
 			propFormulaNumbers.add( formnos );
 
 			joinedFetchesList.add( prop.getValue().getFetchMode() );
 			cascades.add( prop.getCascadeStyle() );
 		}
 		subclassColumnClosure = ArrayHelper.toStringArray( columns );
 		subclassColumnAliasClosure = ArrayHelper.toStringArray( aliases );
 		subclassColumnLazyClosure = ArrayHelper.toBooleanArray( columnsLazy );
 		subclassColumnSelectableClosure = ArrayHelper.toBooleanArray( columnSelectables );
 		subclassColumnReaderTemplateClosure = ArrayHelper.toStringArray( columnReaderTemplates );
 
 		subclassFormulaClosure = ArrayHelper.toStringArray( formulas );
 		subclassFormulaTemplateClosure = ArrayHelper.toStringArray( formulaTemplates );
 		subclassFormulaAliasClosure = ArrayHelper.toStringArray( formulaAliases );
 		subclassFormulaLazyClosure = ArrayHelper.toBooleanArray( formulasLazy );
 
 		subclassPropertyNameClosure = ArrayHelper.toStringArray( names );
 		subclassPropertySubclassNameClosure = ArrayHelper.toStringArray( classes );
 		subclassPropertyTypeClosure = ArrayHelper.toTypeArray( types );
 		subclassPropertyNullabilityClosure = ArrayHelper.toBooleanArray( propNullables );
 		subclassPropertyFormulaTemplateClosure = ArrayHelper.to2DStringArray( templates );
 		subclassPropertyColumnNameClosure = ArrayHelper.to2DStringArray( propColumns );
 		subclassPropertyColumnReaderClosure = ArrayHelper.to2DStringArray( propColumnReaders );
 		subclassPropertyColumnReaderTemplateClosure = ArrayHelper.to2DStringArray( propColumnReaderTemplates );
 		subclassPropertyColumnNumberClosure = ArrayHelper.to2DIntArray( propColumnNumbers );
 		subclassPropertyFormulaNumberClosure = ArrayHelper.to2DIntArray( propFormulaNumbers );
 
 		subclassPropertyCascadeStyleClosure = new CascadeStyle[cascades.size()];
 		iter = cascades.iterator();
 		int j = 0;
 		while ( iter.hasNext() ) {
 			subclassPropertyCascadeStyleClosure[j++] = ( CascadeStyle ) iter.next();
 		}
 		subclassPropertyFetchModeClosure = new FetchMode[joinedFetchesList.size()];
 		iter = joinedFetchesList.iterator();
 		j = 0;
 		while ( iter.hasNext() ) {
 			subclassPropertyFetchModeClosure[j++] = ( FetchMode ) iter.next();
 		}
 
 		propertyDefinedOnSubclass = new boolean[definedBySubclass.size()];
 		iter = definedBySubclass.iterator();
 		j = 0;
 		while ( iter.hasNext() ) {
-			propertyDefinedOnSubclass[j++] = ( ( Boolean ) iter.next() ).booleanValue();
+			propertyDefinedOnSubclass[j++] = (Boolean) iter.next();
 		}
 
 		// Handle any filters applied to the class level
 		filterHelper = new FilterHelper( persistentClass.getFilters(), factory );
 
 		temporaryIdTableName = persistentClass.getTemporaryIdTableName();
 		temporaryIdTableDDL = persistentClass.getTemporaryIdTableDDL();
 
 		this.cacheEntryHelper = buildCacheEntryHelper();
 	}
 
 	protected CacheEntryHelper buildCacheEntryHelper() {
 		if ( cacheAccessStrategy == null ) {
 			// the entity defined no caching...
 			return NoopCacheEntryHelper.INSTANCE;
 		}
 
 		if ( canUseReferenceCacheEntries() ) {
 			entityMetamodel.setLazy( false );
 			// todo : do we also need to unset proxy factory?
 			return new ReferenceCacheEntryHelper( this );
 		}
 
 		return factory.getSettings().isStructuredCacheEntriesEnabled()
 				? new StructuredCacheEntryHelper( this )
 				: new StandardCacheEntryHelper( this );
 	}
 
 	protected boolean canUseReferenceCacheEntries() {
 		// todo : should really validate that the cache access type is read-only
 
 		if ( ! factory.getSettings().isDirectReferenceCacheEntriesEnabled() ) {
 			return false;
 		}
 
 		// for now, limit this to just entities that:
 		// 		1) are immutable
 		if ( entityMetamodel.isMutable() ) {
 			return false;
 		}
 
 		//		2)  have no associations.  Eventually we want to be a little more lenient with associations.
 		for ( Type type : getSubclassPropertyTypeClosure() ) {
 			if ( type.isAssociationType() ) {
 				return false;
 			}
 		}
 
 		return true;
 	}
 
 
 	public AbstractEntityPersister(
 			final EntityBinding entityBinding,
 			final EntityRegionAccessStrategy cacheAccessStrategy,
 			final NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
 			final SessionFactoryImplementor factory) throws HibernateException {
 		this.factory = factory;
 		this.cacheAccessStrategy = cacheAccessStrategy;
 		this.naturalIdRegionAccessStrategy = naturalIdRegionAccessStrategy;
 		this.isLazyPropertiesCacheable =
 				entityBinding.getHierarchyDetails().getCaching() == null ?
 						false :
 						entityBinding.getHierarchyDetails().getCaching().isCacheLazyProperties();
 		this.entityMetamodel = new EntityMetamodel( entityBinding, this, factory );
 		this.entityTuplizer = this.entityMetamodel.getTuplizer();
 		int batch = entityBinding.getBatchSize();
 		if ( batch == -1 ) {
 			batch = factory.getSettings().getDefaultBatchFetchSize();
 		}
 		batchSize = batch;
 		hasSubselectLoadableCollections = entityBinding.hasSubselectLoadableCollections();
 
 		propertyMapping = new BasicEntityPropertyMapping( this );
 
 		// IDENTIFIER
 
 		identifierColumnSpan = entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding().getSimpleValueSpan();
 		rootTableKeyColumnNames = new String[identifierColumnSpan];
 		rootTableKeyColumnReaders = new String[identifierColumnSpan];
 		rootTableKeyColumnReaderTemplates = new String[identifierColumnSpan];
 		identifierAliases = new String[identifierColumnSpan];
 
 		rowIdName = entityBinding.getRowId();
 
 		loaderName = entityBinding.getCustomLoaderName();
 
 		int i = 0;
 		for ( org.hibernate.metamodel.relational.Column col : entityBinding.getPrimaryTable().getPrimaryKey().getColumns() ) {
 			rootTableKeyColumnNames[i] = col.getColumnName().encloseInQuotesIfQuoted( factory.getDialect() );
 			if ( col.getReadFragment() == null ) {
 				rootTableKeyColumnReaders[i] = rootTableKeyColumnNames[i];
 				rootTableKeyColumnReaderTemplates[i] = getTemplateFromColumn( col, factory );
 			}
 			else {
 				rootTableKeyColumnReaders[i] = col.getReadFragment();
 				rootTableKeyColumnReaderTemplates[i] = getTemplateFromString( rootTableKeyColumnReaders[i], factory );
 			}
 			identifierAliases[i] = col.getAlias( factory.getDialect() );
 			i++;
 		}
 
 		// VERSION
 
 		if ( entityBinding.isVersioned() ) {
 			final Value versioningValue = entityBinding.getHierarchyDetails().getVersioningAttributeBinding().getValue();
 			if ( ! org.hibernate.metamodel.relational.Column.class.isInstance( versioningValue ) ) {
 				throw new AssertionFailure( "Bad versioning attribute binding : " + versioningValue );
 			}
 			org.hibernate.metamodel.relational.Column versionColumn = org.hibernate.metamodel.relational.Column.class.cast( versioningValue );
 			versionColumnName = versionColumn.getColumnName().encloseInQuotesIfQuoted( factory.getDialect() );
 		}
 		else {
 			versionColumnName = null;
 		}
 
 		//WHERE STRING
 
 		sqlWhereString = StringHelper.isNotEmpty( entityBinding.getWhereFilter() ) ? "( " + entityBinding.getWhereFilter() + ") " : null;
 		sqlWhereStringTemplate = getTemplateFromString( sqlWhereString, factory );
 
 		// PROPERTIES
 
 		final boolean lazyAvailable = isInstrumented();
 
 		int hydrateSpan = entityMetamodel.getPropertySpan();
 		propertyColumnSpans = new int[hydrateSpan];
 		propertySubclassNames = new String[hydrateSpan];
 		propertyColumnAliases = new String[hydrateSpan][];
 		propertyColumnNames = new String[hydrateSpan][];
 		propertyColumnFormulaTemplates = new String[hydrateSpan][];
 		propertyColumnReaderTemplates = new String[hydrateSpan][];
 		propertyColumnWriters = new String[hydrateSpan][];
 		propertyUniqueness = new boolean[hydrateSpan];
 		propertySelectable = new boolean[hydrateSpan];
 		propertyColumnUpdateable = new boolean[hydrateSpan][];
 		propertyColumnInsertable = new boolean[hydrateSpan][];
 		HashSet thisClassProperties = new HashSet();
 
 		lazyProperties = new HashSet();
 		ArrayList lazyNames = new ArrayList();
 		ArrayList lazyNumbers = new ArrayList();
 		ArrayList lazyTypes = new ArrayList();
 		ArrayList lazyColAliases = new ArrayList();
 
 		i = 0;
 		boolean foundFormula = false;
 		for ( AttributeBinding attributeBinding : entityBinding.getAttributeBindingClosure() ) {
 			if ( attributeBinding == entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding() ) {
 				// entity identifier is not considered a "normal" property
 				continue;
 			}
 
 			if ( ! attributeBinding.getAttribute().isSingular() ) {
 				// collections handled separately
 				continue;
 			}
 
 			final SingularAttributeBinding singularAttributeBinding = (SingularAttributeBinding) attributeBinding;
 
 			thisClassProperties.add( singularAttributeBinding );
 
 			propertySubclassNames[i] = ( (EntityBinding) singularAttributeBinding.getContainer() ).getEntity().getName();
 
 			int span = singularAttributeBinding.getSimpleValueSpan();
 			propertyColumnSpans[i] = span;
 
 			String[] colNames = new String[span];
 			String[] colAliases = new String[span];
 			String[] colReaderTemplates = new String[span];
 			String[] colWriters = new String[span];
 			String[] formulaTemplates = new String[span];
 			boolean[] propertyColumnInsertability = new boolean[span];
 			boolean[] propertyColumnUpdatability = new boolean[span];
 
 			int k = 0;
 
 			for ( SimpleValueBinding valueBinding : singularAttributeBinding.getSimpleValueBindings() ) {
 				colAliases[k] = valueBinding.getSimpleValue().getAlias( factory.getDialect() );
 				if ( valueBinding.isDerived() ) {
 					foundFormula = true;
 					formulaTemplates[ k ] = getTemplateFromString( ( (DerivedValue) valueBinding.getSimpleValue() ).getExpression(), factory );
 				}
 				else {
 					org.hibernate.metamodel.relational.Column col = ( org.hibernate.metamodel.relational.Column ) valueBinding.getSimpleValue();
 					colNames[k] = col.getColumnName().encloseInQuotesIfQuoted( factory.getDialect() );
 					colReaderTemplates[k] = getTemplateFromColumn( col, factory );
 					colWriters[k] = col.getWriteFragment() == null ? "?" : col.getWriteFragment();
 				}
 				propertyColumnInsertability[k] = valueBinding.isIncludeInInsert();
 				propertyColumnUpdatability[k] = valueBinding.isIncludeInUpdate();
 				k++;
 			}
 			propertyColumnNames[i] = colNames;
 			propertyColumnFormulaTemplates[i] = formulaTemplates;
 			propertyColumnReaderTemplates[i] = colReaderTemplates;
 			propertyColumnWriters[i] = colWriters;
 			propertyColumnAliases[i] = colAliases;
 
 			propertyColumnUpdateable[i] = propertyColumnUpdatability;
 			propertyColumnInsertable[i] = propertyColumnInsertability;
 
 			if ( lazyAvailable && singularAttributeBinding.isLazy() ) {
 				lazyProperties.add( singularAttributeBinding.getAttribute().getName() );
 				lazyNames.add( singularAttributeBinding.getAttribute().getName() );
 				lazyNumbers.add( i );
 				lazyTypes.add( singularAttributeBinding.getHibernateTypeDescriptor().getResolvedTypeMapping());
 				lazyColAliases.add( colAliases );
 			}
 
 
 			// TODO: fix this when backrefs are working
 			//propertySelectable[i] = singularAttributeBinding.isBackRef();
 			propertySelectable[i] = true;
 
 			propertyUniqueness[i] = singularAttributeBinding.isAlternateUniqueKey();
 			
 			// TODO: Does this need AttributeBindings wired into lobProperties?  Currently in Property only.
 
 			i++;
 
 		}
 		hasFormulaProperties = foundFormula;
 		lazyPropertyColumnAliases = ArrayHelper.to2DStringArray( lazyColAliases );
 		lazyPropertyNames = ArrayHelper.toStringArray( lazyNames );
 		lazyPropertyNumbers = ArrayHelper.toIntArray( lazyNumbers );
 		lazyPropertyTypes = ArrayHelper.toTypeArray( lazyTypes );
 
 		// SUBCLASS PROPERTY CLOSURE
 
 		List<String> columns = new ArrayList<String>();
 		List<Boolean> columnsLazy = new ArrayList<Boolean>();
 		List<String> columnReaderTemplates = new ArrayList<String>();
 		List<String> aliases = new ArrayList<String>();
 		List<String> formulas = new ArrayList<String>();
 		List<String> formulaAliases = new ArrayList<String>();
 		List<String> formulaTemplates = new ArrayList<String>();
 		List<Boolean> formulasLazy = new ArrayList<Boolean>();
 		List<Type> types = new ArrayList<Type>();
 		List<String> names = new ArrayList<String>();
 		List<String> classes = new ArrayList<String>();
 		List<String[]> templates = new ArrayList<String[]>();
 		List<String[]> propColumns = new ArrayList<String[]>();
 		List<String[]> propColumnReaders = new ArrayList<String[]>();
 		List<String[]> propColumnReaderTemplates = new ArrayList<String[]>();
 		List<FetchMode> joinedFetchesList = new ArrayList<FetchMode>();
 		List<CascadeStyle> cascades = new ArrayList<CascadeStyle>();
 		List<Boolean> definedBySubclass = new ArrayList<Boolean>();
 		List<int[]> propColumnNumbers = new ArrayList<int[]>();
 		List<int[]> propFormulaNumbers = new ArrayList<int[]>();
 		List<Boolean> columnSelectables = new ArrayList<Boolean>();
 		List<Boolean> propNullables = new ArrayList<Boolean>();
 
 		for ( AttributeBinding attributeBinding : entityBinding.getSubEntityAttributeBindingClosure() ) {
 			if ( attributeBinding == entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding() ) {
 				// entity identifier is not considered a "normal" property
 				continue;
 			}
 
 			if ( ! attributeBinding.getAttribute().isSingular() ) {
 				// collections handled separately
 				continue;
 			}
 
 			final SingularAttributeBinding singularAttributeBinding = (SingularAttributeBinding) attributeBinding;
 
 			names.add( singularAttributeBinding.getAttribute().getName() );
 			classes.add( ( (EntityBinding) singularAttributeBinding.getContainer() ).getEntity().getName() );
 			boolean isDefinedBySubclass = ! thisClassProperties.contains( singularAttributeBinding );
 			definedBySubclass.add( isDefinedBySubclass );
 			propNullables.add( singularAttributeBinding.isNullable() || isDefinedBySubclass ); //TODO: is this completely correct?
 			types.add( singularAttributeBinding.getHibernateTypeDescriptor().getResolvedTypeMapping() );
 
 			final int span = singularAttributeBinding.getSimpleValueSpan();
 			String[] cols = new String[ span ];
 			String[] readers = new String[ span ];
 			String[] readerTemplates = new String[ span ];
 			String[] forms = new String[ span ];
 			int[] colnos = new int[ span ];
 			int[] formnos = new int[ span ];
 			int l = 0;
 			Boolean lazy = singularAttributeBinding.isLazy() && lazyAvailable;
 			for ( SimpleValueBinding valueBinding : singularAttributeBinding.getSimpleValueBindings() ) {
 				if ( valueBinding.isDerived() ) {
 					DerivedValue derivedValue = DerivedValue.class.cast( valueBinding.getSimpleValue() );
 					String template = getTemplateFromString( derivedValue.getExpression(), factory );
 					formnos[l] = formulaTemplates.size();
 					colnos[l] = -1;
 					formulaTemplates.add( template );
 					forms[l] = template;
 					formulas.add( derivedValue.getExpression() );
 					formulaAliases.add( derivedValue.getAlias( factory.getDialect() ) );
 					formulasLazy.add( lazy );
 				}
 				else {
 					org.hibernate.metamodel.relational.Column col = org.hibernate.metamodel.relational.Column.class.cast( valueBinding.getSimpleValue() );
 					String colName = col.getColumnName().encloseInQuotesIfQuoted( factory.getDialect() );
 					colnos[l] = columns.size(); //before add :-)
 					formnos[l] = -1;
 					columns.add( colName );
 					cols[l] = colName;
 					aliases.add( col.getAlias( factory.getDialect() ) );
 					columnsLazy.add( lazy );
 					// TODO: properties only selectable if they are non-plural???
 					columnSelectables.add( singularAttributeBinding.getAttribute().isSingular() );
 
 					readers[l] =
 							col.getReadFragment() == null ?
 									col.getColumnName().encloseInQuotesIfQuoted( factory.getDialect() ) :
 									col.getReadFragment();
 					String readerTemplate = getTemplateFromColumn( col, factory );
 					readerTemplates[l] = readerTemplate;
 					columnReaderTemplates.add( readerTemplate );
 				}
 				l++;
 			}
 			propColumns.add( cols );
 			propColumnReaders.add( readers );
 			propColumnReaderTemplates.add( readerTemplates );
 			templates.add( forms );
 			propColumnNumbers.add( colnos );
 			propFormulaNumbers.add( formnos );
 
 			if ( singularAttributeBinding.isAssociation() ) {
 				AssociationAttributeBinding associationAttributeBinding =
 						( AssociationAttributeBinding ) singularAttributeBinding;
 				cascades.add( associationAttributeBinding.getCascadeStyle() );
 				joinedFetchesList.add( associationAttributeBinding.getFetchMode() );
 			}
 			else {
 				cascades.add( CascadeStyles.NONE );
 				joinedFetchesList.add( FetchMode.SELECT );
 			}
 		}
 
 		subclassColumnClosure = ArrayHelper.toStringArray( columns );
 		subclassColumnAliasClosure = ArrayHelper.toStringArray( aliases );
 		subclassColumnLazyClosure = ArrayHelper.toBooleanArray( columnsLazy );
 		subclassColumnSelectableClosure = ArrayHelper.toBooleanArray( columnSelectables );
 		subclassColumnReaderTemplateClosure = ArrayHelper.toStringArray( columnReaderTemplates );
 
 		subclassFormulaClosure = ArrayHelper.toStringArray( formulas );
 		subclassFormulaTemplateClosure = ArrayHelper.toStringArray( formulaTemplates );
 		subclassFormulaAliasClosure = ArrayHelper.toStringArray( formulaAliases );
 		subclassFormulaLazyClosure = ArrayHelper.toBooleanArray( formulasLazy );
 
 		subclassPropertyNameClosure = ArrayHelper.toStringArray( names );
 		subclassPropertySubclassNameClosure = ArrayHelper.toStringArray( classes );
 		subclassPropertyTypeClosure = ArrayHelper.toTypeArray( types );
 		subclassPropertyNullabilityClosure = ArrayHelper.toBooleanArray( propNullables );
 		subclassPropertyFormulaTemplateClosure = ArrayHelper.to2DStringArray( templates );
 		subclassPropertyColumnNameClosure = ArrayHelper.to2DStringArray( propColumns );
 		subclassPropertyColumnReaderClosure = ArrayHelper.to2DStringArray( propColumnReaders );
 		subclassPropertyColumnReaderTemplateClosure = ArrayHelper.to2DStringArray( propColumnReaderTemplates );
 		subclassPropertyColumnNumberClosure = ArrayHelper.to2DIntArray( propColumnNumbers );
 		subclassPropertyFormulaNumberClosure = ArrayHelper.to2DIntArray( propFormulaNumbers );
 
 		subclassPropertyCascadeStyleClosure = cascades.toArray( new CascadeStyle[ cascades.size() ] );
 		subclassPropertyFetchModeClosure = joinedFetchesList.toArray( new FetchMode[ joinedFetchesList.size() ] );
 
 		propertyDefinedOnSubclass = ArrayHelper.toBooleanArray( definedBySubclass );
 
 		List<FilterConfiguration> filterDefaultConditions = new ArrayList<FilterConfiguration>();
 		for ( FilterDefinition filterDefinition : entityBinding.getFilterDefinitions() ) {
 			filterDefaultConditions.add(new FilterConfiguration(filterDefinition.getFilterName(), 
 						filterDefinition.getDefaultFilterCondition(), true, null, null, null));
 		}
 		filterHelper = new FilterHelper( filterDefaultConditions, factory);
 
 		temporaryIdTableName = null;
 		temporaryIdTableDDL = null;
 
 		this.cacheEntryHelper = buildCacheEntryHelper();
 	}
 
 	protected static String getTemplateFromString(String string, SessionFactoryImplementor factory) {
 		return string == null ?
 				null :
 				Template.renderWhereStringTemplate( string, factory.getDialect(), factory.getSqlFunctionRegistry() );
 	}
 
 	public String getTemplateFromColumn(org.hibernate.metamodel.relational.Column column, SessionFactoryImplementor factory) {
 		String templateString;
 		if ( column.getReadFragment() != null ) {
 			templateString = getTemplateFromString( column.getReadFragment(), factory );
 		}
 		else {
 			String columnName = column.getColumnName().encloseInQuotesIfQuoted( factory.getDialect() );
 			templateString = Template.TEMPLATE + '.' + columnName;
 		}
 		return templateString;
 	}
 
 	protected String generateLazySelectString() {
 
 		if ( !entityMetamodel.hasLazyProperties() ) {
 			return null;
 		}
 
 		HashSet tableNumbers = new HashSet();
 		ArrayList columnNumbers = new ArrayList();
 		ArrayList formulaNumbers = new ArrayList();
 		for ( int i = 0; i < lazyPropertyNames.length; i++ ) {
 			// all this only really needs to consider properties
 			// of this class, not its subclasses, but since we
 			// are reusing code used for sequential selects, we
 			// use the subclass closure
 			int propertyNumber = getSubclassPropertyIndex( lazyPropertyNames[i] );
 
 			int tableNumber = getSubclassPropertyTableNumber( propertyNumber );
 			tableNumbers.add(  tableNumber );
 
 			int[] colNumbers = subclassPropertyColumnNumberClosure[propertyNumber];
 			for ( int j = 0; j < colNumbers.length; j++ ) {
 				if ( colNumbers[j]!=-1 ) {
 					columnNumbers.add( colNumbers[j] );
 				}
 			}
 			int[] formNumbers = subclassPropertyFormulaNumberClosure[propertyNumber];
 			for ( int j = 0; j < formNumbers.length; j++ ) {
 				if ( formNumbers[j]!=-1 ) {
 					formulaNumbers.add( formNumbers[j] );
 				}
 			}
 		}
 
 		if ( columnNumbers.size()==0 && formulaNumbers.size()==0 ) {
 			// only one-to-one is lazy fetched
 			return null;
 		}
 
 		return renderSelect( ArrayHelper.toIntArray( tableNumbers ),
 				ArrayHelper.toIntArray( columnNumbers ),
 				ArrayHelper.toIntArray( formulaNumbers ) );
 
 	}
 
 	public Object initializeLazyProperty(String fieldName, Object entity, SessionImplementor session)
 			throws HibernateException {
 
 		final Serializable id = session.getContextEntityIdentifier( entity );
 
 		final EntityEntry entry = session.getPersistenceContext().getEntry( entity );
 		if ( entry == null ) {
 			throw new HibernateException( "entity is not associated with the session: " + id );
 		}
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Initializing lazy properties of: {0}, field access: {1}", MessageHelper.infoString( this, id, getFactory() ), fieldName );
 		}
 
 		if ( hasCache() ) {
 			CacheKey cacheKey = session.generateCacheKey( id, getIdentifierType(), getEntityName() );
 			Object ce = getCacheAccessStrategy().get( cacheKey, session.getTimestamp() );
 			if (ce!=null) {
 				CacheEntry cacheEntry = (CacheEntry) getCacheEntryStructure().destructure(ce, factory);
 				if ( !cacheEntry.areLazyPropertiesUnfetched() ) {
 					//note early exit here:
 					return initializeLazyPropertiesFromCache( fieldName, entity, session, entry, cacheEntry );
 				}
 			}
 		}
 
 		return initializeLazyPropertiesFromDatastore( fieldName, entity, session, id, entry );
 
 	}
 
 	private Object initializeLazyPropertiesFromDatastore(
 			final String fieldName,
 			final Object entity,
 			final SessionImplementor session,
 			final Serializable id,
 			final EntityEntry entry) {
 
 		if ( !hasLazyProperties() ) throw new AssertionFailure( "no lazy properties" );
 
 		LOG.trace( "Initializing lazy properties from datastore" );
 
 		try {
 
 			Object result = null;
 			PreparedStatement ps = null;
 			try {
 				final String lazySelect = getSQLLazySelectString();
 				ResultSet rs = null;
 				try {
 					if ( lazySelect != null ) {
 						// null sql means that the only lazy properties
 						// are shared PK one-to-one associations which are
 						// handled differently in the Type#nullSafeGet code...
 						ps = session.getTransactionCoordinator()
 								.getJdbcCoordinator()
 								.getStatementPreparer()
 								.prepareStatement( lazySelect );
 						getIdentifierType().nullSafeSet( ps, id, 1, session );
 						rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( ps );
 						rs.next();
 					}
 					final Object[] snapshot = entry.getLoadedState();
 					for ( int j = 0; j < lazyPropertyNames.length; j++ ) {
 						Object propValue = lazyPropertyTypes[j].nullSafeGet( rs, lazyPropertyColumnAliases[j], session, entity );
 						if ( initializeLazyProperty( fieldName, entity, session, snapshot, j, propValue ) ) {
 							result = propValue;
 						}
 					}
 				}
 				finally {
 					if ( rs != null ) {
 						session.getTransactionCoordinator().getJdbcCoordinator().release( rs, ps );
 					}
 				}
 			}
 			finally {
 				if ( ps != null ) {
 					session.getTransactionCoordinator().getJdbcCoordinator().release( ps );
 				}
 			}
 
 			LOG.trace( "Done initializing lazy properties" );
 
 			return result;
 
 		}
 		catch ( SQLException sqle ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					sqle,
 					"could not initialize lazy properties: " +
 					MessageHelper.infoString( this, id, getFactory() ),
 					getSQLLazySelectString()
 				);
 		}
 	}
 
 	private Object initializeLazyPropertiesFromCache(
 			final String fieldName,
 			final Object entity,
 			final SessionImplementor session,
 			final EntityEntry entry,
 			final CacheEntry cacheEntry
 	) {
 
 		LOG.trace( "Initializing lazy properties from second-level cache" );
 
 		Object result = null;
 		Serializable[] disassembledValues = cacheEntry.getDisassembledState();
 		final Object[] snapshot = entry.getLoadedState();
 		for ( int j = 0; j < lazyPropertyNames.length; j++ ) {
 			final Object propValue = lazyPropertyTypes[j].assemble(
 					disassembledValues[ lazyPropertyNumbers[j] ],
 					session,
 					entity
 				);
 			if ( initializeLazyProperty( fieldName, entity, session, snapshot, j, propValue ) ) {
 				result = propValue;
 			}
 		}
 
 		LOG.trace( "Done initializing lazy properties" );
 
 		return result;
 	}
 
 	private boolean initializeLazyProperty(
 			final String fieldName,
 			final Object entity,
 			final SessionImplementor session,
 			final Object[] snapshot,
 			final int j,
 			final Object propValue) {
 		setPropertyValue( entity, lazyPropertyNumbers[j], propValue );
 		if ( snapshot != null ) {
 			// object have been loaded with setReadOnly(true); HHH-2236
 			snapshot[ lazyPropertyNumbers[j] ] = lazyPropertyTypes[j].deepCopy( propValue, factory );
 		}
 		return fieldName.equals( lazyPropertyNames[j] );
 	}
 
 	public boolean isBatchable() {
 		return optimisticLockStyle() == OptimisticLockStyle.NONE
 				|| ( !isVersioned() && optimisticLockStyle() == OptimisticLockStyle.VERSION )
 				|| getFactory().getSettings().isJdbcBatchVersionedData();
 	}
 
 	public Serializable[] getQuerySpaces() {
 		return getPropertySpaces();
 	}
 
 	protected Set getLazyProperties() {
 		return lazyProperties;
 	}
 
 	public boolean isBatchLoadable() {
 		return batchSize > 1;
 	}
 
 	public String[] getIdentifierColumnNames() {
 		return rootTableKeyColumnNames;
 	}
 
 	public String[] getIdentifierColumnReaders() {
 		return rootTableKeyColumnReaders;
 	}
 
 	public String[] getIdentifierColumnReaderTemplates() {
 		return rootTableKeyColumnReaderTemplates;
 	}
 
 	protected int getIdentifierColumnSpan() {
 		return identifierColumnSpan;
 	}
 
 	protected String[] getIdentifierAliases() {
 		return identifierAliases;
 	}
 
 	public String getVersionColumnName() {
 		return versionColumnName;
 	}
 
 	protected String getVersionedTableName() {
 		return getTableName( 0 );
 	}
 
 	protected boolean[] getSubclassColumnLazyiness() {
 		return subclassColumnLazyClosure;
 	}
 
 	protected boolean[] getSubclassFormulaLazyiness() {
 		return subclassFormulaLazyClosure;
 	}
 
 	/**
 	 * We can't immediately add to the cache if we have formulas
 	 * which must be evaluated, or if we have the possibility of
 	 * two concurrent updates to the same item being merged on
 	 * the database. This can happen if (a) the item is not
 	 * versioned and either (b) we have dynamic update enabled
 	 * or (c) we have multiple tables holding the state of the
 	 * item.
 	 */
 	public boolean isCacheInvalidationRequired() {
 		return hasFormulaProperties() ||
 				( !isVersioned() && ( entityMetamodel.isDynamicUpdate() || getTableSpan() > 1 ) );
 	}
 
 	public boolean isLazyPropertiesCacheable() {
 		return isLazyPropertiesCacheable;
 	}
 
 	public String selectFragment(String alias, String suffix) {
 		return identifierSelectFragment( alias, suffix ) +
 				propertySelectFragment( alias, suffix, false );
 	}
 
 	public String[] getIdentifierAliases(String suffix) {
 		// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!
 		// was toUnqotedAliasStrings( getIdentiferColumnNames() ) before - now tried
 		// to remove that unqoting and missing aliases..
 		return new Alias( suffix ).toAliasStrings( getIdentifierAliases() );
 	}
 
 	public String[] getPropertyAliases(String suffix, int i) {
 		// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!
 		return new Alias( suffix ).toUnquotedAliasStrings( propertyColumnAliases[i] );
 	}
 
 	public String getDiscriminatorAlias(String suffix) {
 		// NOTE: this assumes something about how propertySelectFragment is implemented by the subclass!
 		// was toUnqotedAliasStrings( getdiscriminatorColumnName() ) before - now tried
 		// to remove that unqoting and missing aliases..
 		return entityMetamodel.hasSubclasses() ?
 				new Alias( suffix ).toAliasString( getDiscriminatorAlias() ) :
 				null;
 	}
 
 	public String identifierSelectFragment(String name, String suffix) {
 		return new SelectFragment()
 				.setSuffix( suffix )
 				.addColumns( name, getIdentifierColumnNames(), getIdentifierAliases() )
 				.toFragmentString()
 				.substring( 2 ); //strip leading ", "
 	}
 
 
 	public String propertySelectFragment(String tableAlias, String suffix, boolean allProperties) {
 		return propertySelectFragmentFragment( tableAlias, suffix, allProperties ).toFragmentString();
 	}
 
 	public SelectFragment propertySelectFragmentFragment(
 			String tableAlias,
 			String suffix,
 			boolean allProperties) {
 		SelectFragment select = new SelectFragment()
 				.setSuffix( suffix )
 				.setUsedAliases( getIdentifierAliases() );
 
 		int[] columnTableNumbers = getSubclassColumnTableNumberClosure();
 		String[] columnAliases = getSubclassColumnAliasClosure();
 		String[] columnReaderTemplates = getSubclassColumnReaderTemplateClosure();
 		for ( int i = 0; i < getSubclassColumnClosure().length; i++ ) {
 			boolean selectable = ( allProperties || !subclassColumnLazyClosure[i] ) &&
 				!isSubclassTableSequentialSelect( columnTableNumbers[i] ) &&
 				subclassColumnSelectableClosure[i];
 			if ( selectable ) {
 				String subalias = generateTableAlias( tableAlias, columnTableNumbers[i] );
 				select.addColumnTemplate( subalias, columnReaderTemplates[i], columnAliases[i] );
 			}
 		}
 
 		int[] formulaTableNumbers = getSubclassFormulaTableNumberClosure();
 		String[] formulaTemplates = getSubclassFormulaTemplateClosure();
 		String[] formulaAliases = getSubclassFormulaAliasClosure();
 		for ( int i = 0; i < getSubclassFormulaTemplateClosure().length; i++ ) {
 			boolean selectable = ( allProperties || !subclassFormulaLazyClosure[i] )
 				&& !isSubclassTableSequentialSelect( formulaTableNumbers[i] );
 			if ( selectable ) {
 				String subalias = generateTableAlias( tableAlias, formulaTableNumbers[i] );
 				select.addFormula( subalias, formulaTemplates[i], formulaAliases[i] );
 			}
 		}
 
 		if ( entityMetamodel.hasSubclasses() ) {
 			addDiscriminatorToSelect( select, tableAlias, suffix );
 		}
 
 		if ( hasRowId() ) {
 			select.addColumn( tableAlias, rowIdName, ROWID_ALIAS );
 		}
 
 		return select;
 	}
 
 	public Object[] getDatabaseSnapshot(Serializable id, SessionImplementor session)
 			throws HibernateException {
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Getting current persistent state for: {0}", MessageHelper.infoString( this, id, getFactory() ) );
 		}
 
 		try {
 			PreparedStatement ps = session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getStatementPreparer()
 					.prepareStatement( getSQLSnapshotSelectString() );
 			try {
 				getIdentifierType().nullSafeSet( ps, id, 1, session );
 				//if ( isVersioned() ) getVersionType().nullSafeSet( ps, version, getIdentifierColumnSpan()+1, session );
 				ResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( ps );
 				try {
 					//if there is no resulting row, return null
 					if ( !rs.next() ) {
 						return null;
 					}
 					//otherwise return the "hydrated" state (ie. associations are not resolved)
 					Type[] types = getPropertyTypes();
 					Object[] values = new Object[types.length];
 					boolean[] includeProperty = getPropertyUpdateability();
 					for ( int i = 0; i < types.length; i++ ) {
 						if ( includeProperty[i] ) {
 							values[i] = types[i].hydrate( rs, getPropertyAliases( "", i ), session, null ); //null owner ok??
 						}
 					}
 					return values;
 				}
 				finally {
 					session.getTransactionCoordinator().getJdbcCoordinator().release( rs, ps );
 				}
 			}
 			finally {
 				session.getTransactionCoordinator().getJdbcCoordinator().release( ps );
 			}
 		}
 		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					"could not retrieve snapshot: " + MessageHelper.infoString( this, id, getFactory() ),
 			        getSQLSnapshotSelectString()
 			);
 		}
 
 	}
 
 	@Override
 	public Serializable getIdByUniqueKey(Serializable key, String uniquePropertyName, SessionImplementor session) throws HibernateException {
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracef(
 					"resolving unique key [%s] to identifier for entity [%s]",
 					key,
 					getEntityName()
 			);
 		}
 
 		int propertyIndex = getSubclassPropertyIndex( uniquePropertyName );
 		if ( propertyIndex < 0 ) {
 			throw new HibernateException(
 					"Could not determine Type for property [" + uniquePropertyName + "] on entity [" + getEntityName() + "]"
 			);
 		}
 		Type propertyType = getSubclassPropertyType( propertyIndex );
 
 		try {
 			PreparedStatement ps = session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getStatementPreparer()
 					.prepareStatement( generateIdByUniqueKeySelectString( uniquePropertyName ) );
 			try {
 				propertyType.nullSafeSet( ps, key, 1, session );
 				ResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( ps );
 				try {
 					//if there is no resulting row, return null
 					if ( !rs.next() ) {
 						return null;
 					}
 					return (Serializable) getIdentifierType().nullSafeGet( rs, getIdentifierAliases(), session, null );
 				}
 				finally {
 					session.getTransactionCoordinator().getJdbcCoordinator().release( rs, ps );
 				}
 			}
 			finally {
 				session.getTransactionCoordinator().getJdbcCoordinator().release( ps );
 			}
 		}
 		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					String.format(
 							"could not resolve unique property [%s] to identifier for entity [%s]",
 							uniquePropertyName,
 							getEntityName()
 					),
 					getSQLSnapshotSelectString()
 			);
 		}
 
 	}
 
 	protected String generateIdByUniqueKeySelectString(String uniquePropertyName) {
 		Select select = new Select( getFactory().getDialect() );
 
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "resolve id by unique property [" + getEntityName() + "." + uniquePropertyName + "]" );
 		}
 
 		final String rooAlias = getRootAlias();
 
 		select.setFromClause( fromTableFragment( rooAlias ) + fromJoinFragment( rooAlias, true, false ) );
 
 		SelectFragment selectFragment = new SelectFragment();
 		selectFragment.addColumns( rooAlias, getIdentifierColumnNames(), getIdentifierAliases() );
 		select.setSelectClause( selectFragment );
 
 		StringBuilder whereClauseBuffer = new StringBuilder();
 		final int uniquePropertyIndex = getSubclassPropertyIndex( uniquePropertyName );
 		final String uniquePropertyTableAlias = generateTableAlias(
 				rooAlias,
 				getSubclassPropertyTableNumber( uniquePropertyIndex )
 		);
 		String sep = "";
 		for ( String columnTemplate : getSubclassPropertyColumnReaderTemplateClosure()[uniquePropertyIndex] ) {
 			if ( columnTemplate == null ) {
 				continue;
 			}
 			final String columnReference = StringHelper.replace( columnTemplate, Template.TEMPLATE, uniquePropertyTableAlias );
 			whereClauseBuffer.append( sep ).append( columnReference ).append( "=?" );
 			sep = " and ";
 		}
 		for ( String formulaTemplate : getSubclassPropertyFormulaTemplateClosure()[uniquePropertyIndex] ) {
 			if ( formulaTemplate == null ) {
 				continue;
 			}
 			final String formulaReference = StringHelper.replace( formulaTemplate, Template.TEMPLATE, uniquePropertyTableAlias );
 			whereClauseBuffer.append( sep ).append( formulaReference ).append( "=?" );
 			sep = " and ";
 		}
 		whereClauseBuffer.append( whereJoinFragment( rooAlias, true, false ) );
 
 		select.setWhereClause( whereClauseBuffer.toString() );
 
 		return select.setOuterJoins( "", "" ).toStatementString();
 	}
 
 
 	/**
 	 * Generate the SQL that selects the version number by id
 	 */
 	protected String generateSelectVersionString() {
 		SimpleSelect select = new SimpleSelect( getFactory().getDialect() )
 				.setTableName( getVersionedTableName() );
 		if ( isVersioned() ) {
 			select.addColumn( versionColumnName );
 		}
 		else {
 			select.addColumns( rootTableKeyColumnNames );
 		}
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "get version " + getEntityName() );
 		}
 		return select.addCondition( rootTableKeyColumnNames, "=?" ).toStatementString();
 	}
 
 	public boolean[] getPropertyUniqueness() {
 		return propertyUniqueness;
 	}
 
 	protected String generateInsertGeneratedValuesSelectString() {
 		return generateGeneratedValuesSelectString( getPropertyInsertGenerationInclusions() );
 	}
 
 	protected String generateUpdateGeneratedValuesSelectString() {
 		return generateGeneratedValuesSelectString( getPropertyUpdateGenerationInclusions() );
 	}
 
 	private String generateGeneratedValuesSelectString(ValueInclusion[] inclusions) {
 		Select select = new Select( getFactory().getDialect() );
 
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "get generated state " + getEntityName() );
 		}
 
 		String[] aliasedIdColumns = StringHelper.qualify( getRootAlias(), getIdentifierColumnNames() );
 
 		// Here we render the select column list based on the properties defined as being generated.
 		// For partial component generation, we currently just re-select the whole component
 		// rather than trying to handle the individual generated portions.
 		String selectClause = concretePropertySelectFragment( getRootAlias(), inclusions );
 		selectClause = selectClause.substring( 2 );
 
 		String fromClause = fromTableFragment( getRootAlias() ) +
 				fromJoinFragment( getRootAlias(), true, false );
 
 		String whereClause = new StringBuilder()
 			.append( StringHelper.join( "=? and ", aliasedIdColumns ) )
 			.append( "=?" )
 			.append( whereJoinFragment( getRootAlias(), true, false ) )
 			.toString();
 
 		return select.setSelectClause( selectClause )
 				.setFromClause( fromClause )
 				.setOuterJoins( "", "" )
 				.setWhereClause( whereClause )
 				.toStatementString();
 	}
 
 	protected static interface InclusionChecker {
 		public boolean includeProperty(int propertyNumber);
 	}
 
 	protected String concretePropertySelectFragment(String alias, final ValueInclusion[] inclusions) {
 		return concretePropertySelectFragment(
 				alias,
 				new InclusionChecker() {
 					// TODO : currently we really do not handle ValueInclusion.PARTIAL...
 					// ValueInclusion.PARTIAL would indicate parts of a component need to
 					// be included in the select; currently we then just render the entire
 					// component into the select clause in that case.
 					public boolean includeProperty(int propertyNumber) {
 						return inclusions[propertyNumber] != ValueInclusion.NONE;
 					}
 				}
 		);
 	}
 
 	protected String concretePropertySelectFragment(String alias, final boolean[] includeProperty) {
 		return concretePropertySelectFragment(
 				alias,
 				new InclusionChecker() {
 					public boolean includeProperty(int propertyNumber) {
 						return includeProperty[propertyNumber];
 					}
 				}
 		);
 	}
 
 	protected String concretePropertySelectFragment(String alias, InclusionChecker inclusionChecker) {
 		int propertyCount = getPropertyNames().length;
 		int[] propertyTableNumbers = getPropertyTableNumbersInSelect();
 		SelectFragment frag = new SelectFragment();
 		for ( int i = 0; i < propertyCount; i++ ) {
 			if ( inclusionChecker.includeProperty( i ) ) {
 				frag.addColumnTemplates(
 						generateTableAlias( alias, propertyTableNumbers[i] ),
 						propertyColumnReaderTemplates[i],
 						propertyColumnAliases[i]
 				);
 				frag.addFormulas(
 						generateTableAlias( alias, propertyTableNumbers[i] ),
 						propertyColumnFormulaTemplates[i],
 						propertyColumnAliases[i]
 				);
 			}
 		}
 		return frag.toFragmentString();
 	}
 
 	protected String generateSnapshotSelectString() {
 
 		//TODO: should we use SELECT .. FOR UPDATE?
 
 		Select select = new Select( getFactory().getDialect() );
@@ -3878,1289 +3878,1288 @@ public abstract class AbstractEntityPersister
 						createEntityLoader( LockMode.FORCE )
 			);
 		loaders.put(
 				LockMode.PESSIMISTIC_READ,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.PESSIMISTIC_READ )
 			);
 		loaders.put(
 				LockMode.PESSIMISTIC_WRITE,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.PESSIMISTIC_WRITE )
 			);
 		loaders.put(
 				LockMode.PESSIMISTIC_FORCE_INCREMENT,
 				disableForUpdate ?
 						readLoader :
 						createEntityLoader( LockMode.PESSIMISTIC_FORCE_INCREMENT )
 			);
 		loaders.put( LockMode.OPTIMISTIC, createEntityLoader( LockMode.OPTIMISTIC) );
 		loaders.put( LockMode.OPTIMISTIC_FORCE_INCREMENT, createEntityLoader(LockMode.OPTIMISTIC_FORCE_INCREMENT) );
 
 		loaders.put(
 				"merge",
 				new CascadeEntityLoader( this, CascadingActions.MERGE, getFactory() )
 			);
 		loaders.put(
 				"refresh",
 				new CascadeEntityLoader( this, CascadingActions.REFRESH, getFactory() )
 			);
 	}
 
 	protected void createQueryLoader() {
 		if ( loaderName != null ) {
 			queryLoader = new NamedQueryLoader( loaderName, this );
 		}
 	}
 
 	/**
 	 * Load an instance using either the <tt>forUpdateLoader</tt> or the outer joining <tt>loader</tt>,
 	 * depending upon the value of the <tt>lock</tt> parameter
 	 */
 	public Object load(Serializable id, Object optionalObject, LockMode lockMode, SessionImplementor session) {
 		return load( id, optionalObject, new LockOptions().setLockMode(lockMode), session );
 	}
 
 	/**
 	 * Load an instance using either the <tt>forUpdateLoader</tt> or the outer joining <tt>loader</tt>,
 	 * depending upon the value of the <tt>lock</tt> parameter
 	 */
 	public Object load(Serializable id, Object optionalObject, LockOptions lockOptions, SessionImplementor session)
 			throws HibernateException {
 
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Fetching entity: {0}", MessageHelper.infoString( this, id, getFactory() ) );
 		}
 
 		final UniqueEntityLoader loader = getAppropriateLoader(lockOptions, session );
 		return loader.load( id, optionalObject, session, lockOptions );
 	}
 
 	public void registerAffectingFetchProfile(String fetchProfileName) {
 		affectingFetchProfileNames.add( fetchProfileName );
 	}
 
 	private boolean isAffectedByEnabledFetchProfiles(SessionImplementor session) {
 		Iterator itr = session.getLoadQueryInfluencers().getEnabledFetchProfileNames().iterator();
 		while ( itr.hasNext() ) {
 			if ( affectingFetchProfileNames.contains( itr.next() ) ) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	private boolean isAffectedByEnabledFilters(SessionImplementor session) {
 		return session.getLoadQueryInfluencers().hasEnabledFilters()
 				&& filterHelper.isAffectedBy( session.getLoadQueryInfluencers().getEnabledFilters() );
 	}
 
 	private UniqueEntityLoader getAppropriateLoader(LockOptions lockOptions, SessionImplementor session) {
 		if ( queryLoader != null ) {
 			// if the user specified a custom query loader we need to that
 			// regardless of any other consideration
 			return queryLoader;
 		}
 		else if ( isAffectedByEnabledFilters( session ) ) {
 			// because filters affect the rows returned (because they add
 			// restrictions) these need to be next in precedence
 			return createEntityLoader(lockOptions, session.getLoadQueryInfluencers() );
 		}
 		else if ( session.getLoadQueryInfluencers().getInternalFetchProfile() != null && LockMode.UPGRADE.greaterThan( lockOptions.getLockMode() ) ) {
 			// Next, we consider whether an 'internal' fetch profile has been set.
 			// This indicates a special fetch profile Hibernate needs applied
 			// (for its merge loading process e.g.).
 			return ( UniqueEntityLoader ) getLoaders().get( session.getLoadQueryInfluencers().getInternalFetchProfile() );
 		}
 		else if ( isAffectedByEnabledFetchProfiles( session ) ) {
 			// If the session has associated influencers we need to adjust the
 			// SQL query used for loading based on those influencers
 			return createEntityLoader(lockOptions, session.getLoadQueryInfluencers() );
 		}
 		else if ( lockOptions.getTimeOut() != LockOptions.WAIT_FOREVER ) {
 			return createEntityLoader( lockOptions, session.getLoadQueryInfluencers() );
 		}
 		else {
 			return ( UniqueEntityLoader ) getLoaders().get( lockOptions.getLockMode() );
 		}
 	}
 
 	private boolean isAllNull(Object[] array, int tableNumber) {
 		for ( int i = 0; i < array.length; i++ ) {
 			if ( isPropertyOfTable( i, tableNumber ) && array[i] != null ) {
 				return false;
 			}
 		}
 		return true;
 	}
 
 	public boolean isSubclassPropertyNullable(int i) {
 		return subclassPropertyNullabilityClosure[i];
 	}
 
 	/**
 	 * Transform the array of property indexes to an array of booleans,
 	 * true when the property is dirty
 	 */
 	protected final boolean[] getPropertiesToUpdate(final int[] dirtyProperties, final boolean hasDirtyCollection) {
 		final boolean[] propsToUpdate = new boolean[ entityMetamodel.getPropertySpan() ];
 		final boolean[] updateability = getPropertyUpdateability(); //no need to check laziness, dirty checking handles that
 		for ( int j = 0; j < dirtyProperties.length; j++ ) {
 			int property = dirtyProperties[j];
 			if ( updateability[property] ) {
 				propsToUpdate[property] = true;
 			}
 		}
 		if ( isVersioned() && updateability[getVersionProperty() ]) {
 			propsToUpdate[ getVersionProperty() ] =
 				Versioning.isVersionIncrementRequired( dirtyProperties, hasDirtyCollection, getPropertyVersionability() );
 		}
 		return propsToUpdate;
 	}
 
 	/**
 	 * Transform the array of property indexes to an array of booleans,
 	 * true when the property is insertable and non-null
 	 */
 	protected boolean[] getPropertiesToInsert(Object[] fields) {
 		boolean[] notNull = new boolean[fields.length];
 		boolean[] insertable = getPropertyInsertability();
 		for ( int i = 0; i < fields.length; i++ ) {
 			notNull[i] = insertable[i] && fields[i] != null;
 		}
 		return notNull;
 	}
 
 	/**
 	 * Locate the property-indices of all properties considered to be dirty.
 	 *
 	 * @param currentState The current state of the entity (the state to be checked).
 	 * @param previousState The previous state of the entity (the state to be checked against).
 	 * @param entity The entity for which we are checking state dirtiness.
 	 * @param session The session in which the check is occurring.
 	 * @return <tt>null</tt> or the indices of the dirty properties
 	 * @throws HibernateException
 	 */
 	public int[] findDirty(Object[] currentState, Object[] previousState, Object entity, SessionImplementor session)
 	throws HibernateException {
 		int[] props = TypeHelper.findDirty(
 				entityMetamodel.getProperties(),
 				currentState,
 				previousState,
 				propertyColumnUpdateable,
 				hasUninitializedLazyProperties( entity ),
 				session
 			);
 		if ( props == null ) {
 			return null;
 		}
 		else {
 			logDirtyProperties( props );
 			return props;
 		}
 	}
 
 	/**
 	 * Locate the property-indices of all properties considered to be dirty.
 	 *
 	 * @param old The old state of the entity.
 	 * @param current The current state of the entity.
 	 * @param entity The entity for which we are checking state modification.
 	 * @param session The session in which the check is occurring.
 	 * @return <tt>null</tt> or the indices of the modified properties
 	 * @throws HibernateException
 	 */
 	public int[] findModified(Object[] old, Object[] current, Object entity, SessionImplementor session)
 	throws HibernateException {
 		int[] props = TypeHelper.findModified(
 				entityMetamodel.getProperties(),
 				current,
 				old,
 				propertyColumnUpdateable,
 				hasUninitializedLazyProperties( entity ),
 				session
 			);
 		if ( props == null ) {
 			return null;
 		}
 		else {
 			logDirtyProperties( props );
 			return props;
 		}
 	}
 
 	/**
 	 * Which properties appear in the SQL update?
 	 * (Initialized, updateable ones!)
 	 */
 	protected boolean[] getPropertyUpdateability(Object entity) {
 		return hasUninitializedLazyProperties( entity )
 				? getNonLazyPropertyUpdateability()
 				: getPropertyUpdateability();
 	}
 
 	private void logDirtyProperties(int[] props) {
 		if ( LOG.isTraceEnabled() ) {
 			for ( int i = 0; i < props.length; i++ ) {
 				String propertyName = entityMetamodel.getProperties()[ props[i] ].getName();
 				LOG.trace( StringHelper.qualify( getEntityName(), propertyName ) + " is dirty" );
 			}
 		}
 	}
 
 	public SessionFactoryImplementor getFactory() {
 		return factory;
 	}
 
 	public EntityMetamodel getEntityMetamodel() {
 		return entityMetamodel;
 	}
 
 	public boolean hasCache() {
 		return cacheAccessStrategy != null;
 	}
 
 	public EntityRegionAccessStrategy getCacheAccessStrategy() {
 		return cacheAccessStrategy;
 	}
 
 	@Override
 	public CacheEntryStructure getCacheEntryStructure() {
 		return cacheEntryHelper.getCacheEntryStructure();
 	}
 
 	@Override
 	public CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SessionImplementor session) {
 		return cacheEntryHelper.buildCacheEntry( entity, state, version, session );
 	}
 
 	public boolean hasNaturalIdCache() {
 		return naturalIdRegionAccessStrategy != null;
 	}
 	
 	public NaturalIdRegionAccessStrategy getNaturalIdCacheAccessStrategy() {
 		return naturalIdRegionAccessStrategy;
 	}
 
 	public Comparator getVersionComparator() {
 		return isVersioned() ? getVersionType().getComparator() : null;
 	}
 
 	// temporary ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	public final String getEntityName() {
 		return entityMetamodel.getName();
 	}
 
 	public EntityType getEntityType() {
 		return entityMetamodel.getEntityType();
 	}
 
 	public boolean isPolymorphic() {
 		return entityMetamodel.isPolymorphic();
 	}
 
 	public boolean isInherited() {
 		return entityMetamodel.isInherited();
 	}
 
 	public boolean hasCascades() {
 		return entityMetamodel.hasCascades();
 	}
 
 	public boolean hasIdentifierProperty() {
 		return !entityMetamodel.getIdentifierProperty().isVirtual();
 	}
 
 	public VersionType getVersionType() {
 		return ( VersionType ) locateVersionType();
 	}
 
 	private Type locateVersionType() {
 		return entityMetamodel.getVersionProperty() == null ?
 				null :
 				entityMetamodel.getVersionProperty().getType();
 	}
 
 	public int getVersionProperty() {
 		return entityMetamodel.getVersionPropertyIndex();
 	}
 
 	public boolean isVersioned() {
 		return entityMetamodel.isVersioned();
 	}
 
 	public boolean isIdentifierAssignedByInsert() {
 		return entityMetamodel.getIdentifierProperty().isIdentifierAssignedByInsert();
 	}
 
 	public boolean hasLazyProperties() {
 		return entityMetamodel.hasLazyProperties();
 	}
 
 //	public boolean hasUninitializedLazyProperties(Object entity) {
 //		if ( hasLazyProperties() ) {
 //			InterceptFieldCallback callback = ( ( InterceptFieldEnabled ) entity ).getInterceptFieldCallback();
 //			return callback != null && !( ( FieldInterceptor ) callback ).isInitialized();
 //		}
 //		else {
 //			return false;
 //		}
 //	}
 
 	public void afterReassociate(Object entity, SessionImplementor session) {
 		if ( getEntityMetamodel().getInstrumentationMetadata().isInstrumented() ) {
 			FieldInterceptor interceptor = getEntityMetamodel().getInstrumentationMetadata().extractInterceptor( entity );
 			if ( interceptor != null ) {
 				interceptor.setSession( session );
 			}
 			else {
 				FieldInterceptor fieldInterceptor = getEntityMetamodel().getInstrumentationMetadata().injectInterceptor(
 						entity,
 						getEntityName(),
 						null,
 						session
 				);
 				fieldInterceptor.dirty();
 			}
 		}
 
 		handleNaturalIdReattachment( entity, session );
 	}
 
 	private void handleNaturalIdReattachment(Object entity, SessionImplementor session) {
 		if ( ! hasNaturalIdentifier() ) {
 			return;
 		}
 
 		if ( getEntityMetamodel().hasImmutableNaturalId() ) {
 			// we assume there were no changes to natural id during detachment for now, that is validated later
 			// during flush.
 			return;
 		}
 
 		final NaturalIdHelper naturalIdHelper = session.getPersistenceContext().getNaturalIdHelper();
 		final Serializable id = getIdentifier( entity, session );
 
 		// for reattachment of mutable natural-ids, we absolutely positively have to grab the snapshot from the
 		// database, because we have no other way to know if the state changed while detached.
 		final Object[] naturalIdSnapshot;
 		final Object[] entitySnapshot = session.getPersistenceContext().getDatabaseSnapshot( id, this );
 		if ( entitySnapshot == StatefulPersistenceContext.NO_ROW ) {
 			naturalIdSnapshot = null;
 		}
 		else {
 			naturalIdSnapshot = naturalIdHelper.extractNaturalIdValues( entitySnapshot, this );
 		}
 
 		naturalIdHelper.removeSharedNaturalIdCrossReference( this, id, naturalIdSnapshot );
 		naturalIdHelper.manageLocalNaturalIdCrossReference(
 				this,
 				id,
 				naturalIdHelper.extractNaturalIdValues( entity, this ),
 				naturalIdSnapshot,
 				CachedNaturalIdValueSource.UPDATE
 		);
 	}
 
 	public Boolean isTransient(Object entity, SessionImplementor session) throws HibernateException {
 		final Serializable id;
 		if ( canExtractIdOutOfEntity() ) {
 			id = getIdentifier( entity, session );
 		}
 		else {
 			id = null;
 		}
 		// we *always* assume an instance with a null
 		// identifier or no identifier property is unsaved!
 		if ( id == null ) {
 			return Boolean.TRUE;
 		}
 
 		// check the version unsaved-value, if appropriate
 		final Object version = getVersion( entity );
 		if ( isVersioned() ) {
 			// let this take precedence if defined, since it works for
 			// assigned identifiers
 			Boolean result = entityMetamodel.getVersionProperty()
 					.getUnsavedValue().isUnsaved( version );
 			if ( result != null ) {
 				return result;
 			}
 		}
 
 		// check the id unsaved-value
 		Boolean result = entityMetamodel.getIdentifierProperty()
 				.getUnsavedValue().isUnsaved( id );
 		if ( result != null ) {
 			return result;
 		}
 
 		// check to see if it is in the second-level cache
 		if ( hasCache() ) {
 			CacheKey ck = session.generateCacheKey( id, getIdentifierType(), getRootEntityName() );
 			if ( getCacheAccessStrategy().get( ck, session.getTimestamp() ) != null ) {
 				return Boolean.FALSE;
 			}
 		}
 
 		return null;
 	}
 
 	public boolean hasCollections() {
 		return entityMetamodel.hasCollections();
 	}
 
 	public boolean hasMutableProperties() {
 		return entityMetamodel.hasMutableProperties();
 	}
 
 	public boolean isMutable() {
 		return entityMetamodel.isMutable();
 	}
 
 	private boolean isModifiableEntity(EntityEntry entry) {
 
 		return ( entry == null ? isMutable() : entry.isModifiableEntity() );
 	}
 
 	public boolean isAbstract() {
 		return entityMetamodel.isAbstract();
 	}
 
 	public boolean hasSubclasses() {
 		return entityMetamodel.hasSubclasses();
 	}
 
 	public boolean hasProxy() {
 		return entityMetamodel.isLazy();
 	}
 
 	public IdentifierGenerator getIdentifierGenerator() throws HibernateException {
 		return entityMetamodel.getIdentifierProperty().getIdentifierGenerator();
 	}
 
 	public String getRootEntityName() {
 		return entityMetamodel.getRootName();
 	}
 
 	public ClassMetadata getClassMetadata() {
 		return this;
 	}
 
 	public String getMappedSuperclass() {
 		return entityMetamodel.getSuperclass();
 	}
 
 	public boolean isExplicitPolymorphism() {
 		return entityMetamodel.isExplicitPolymorphism();
 	}
 
 	protected boolean useDynamicUpdate() {
 		return entityMetamodel.isDynamicUpdate();
 	}
 
 	protected boolean useDynamicInsert() {
 		return entityMetamodel.isDynamicInsert();
 	}
 
 	protected boolean hasEmbeddedCompositeIdentifier() {
 		return entityMetamodel.getIdentifierProperty().isEmbedded();
 	}
 
 	public boolean canExtractIdOutOfEntity() {
 		return hasIdentifierProperty() || hasEmbeddedCompositeIdentifier() || hasIdentifierMapper();
 	}
 
 	private boolean hasIdentifierMapper() {
 		return entityMetamodel.getIdentifierProperty().hasIdentifierMapper();
 	}
 
 	public String[] getKeyColumnNames() {
 		return getIdentifierColumnNames();
 	}
 
 	public String getName() {
 		return getEntityName();
 	}
 
 	public boolean isCollection() {
 		return false;
 	}
 
 	public boolean consumesEntityAlias() {
 		return true;
 	}
 
 	public boolean consumesCollectionAlias() {
 		return false;
 	}
 
 	public Type getPropertyType(String propertyName) throws MappingException {
 		return propertyMapping.toType( propertyName );
 	}
 
 	public Type getType() {
 		return entityMetamodel.getEntityType();
 	}
 
 	public boolean isSelectBeforeUpdateRequired() {
 		return entityMetamodel.isSelectBeforeUpdate();
 	}
 
 	protected final OptimisticLockStyle optimisticLockStyle() {
 		return entityMetamodel.getOptimisticLockStyle();
 	}
 
 	public Object createProxy(Serializable id, SessionImplementor session) throws HibernateException {
 		return entityMetamodel.getTuplizer().createProxy( id, session );
 	}
 
 	public String toString() {
 		return StringHelper.unqualify( getClass().getName() ) +
 				'(' + entityMetamodel.getName() + ')';
 	}
 
 	public final String selectFragment(
 			Joinable rhs,
 			String rhsAlias,
 			String lhsAlias,
 			String entitySuffix,
 			String collectionSuffix,
 			boolean includeCollectionColumns) {
 		return selectFragment( lhsAlias, entitySuffix );
 	}
 
 	public boolean isInstrumented() {
 		return entityMetamodel.isInstrumented();
 	}
 
 	public boolean hasInsertGeneratedProperties() {
 		return entityMetamodel.hasInsertGeneratedValues();
 	}
 
 	public boolean hasUpdateGeneratedProperties() {
 		return entityMetamodel.hasUpdateGeneratedValues();
 	}
 
 	public boolean isVersionPropertyGenerated() {
 		return isVersioned() && ( getPropertyUpdateGenerationInclusions() [ getVersionProperty() ] != ValueInclusion.NONE );
 	}
 
 	public boolean isVersionPropertyInsertable() {
 		return isVersioned() && getPropertyInsertability() [ getVersionProperty() ];
 	}
 
 	public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session) {
 		getEntityTuplizer().afterInitialize( entity, lazyPropertiesAreUnfetched, session );
 	}
 
 	public String[] getPropertyNames() {
 		return entityMetamodel.getPropertyNames();
 	}
 
 	public Type[] getPropertyTypes() {
 		return entityMetamodel.getPropertyTypes();
 	}
 
 	public boolean[] getPropertyLaziness() {
 		return entityMetamodel.getPropertyLaziness();
 	}
 
 	public boolean[] getPropertyUpdateability() {
 		return entityMetamodel.getPropertyUpdateability();
 	}
 
 	public boolean[] getPropertyCheckability() {
 		return entityMetamodel.getPropertyCheckability();
 	}
 
 	public boolean[] getNonLazyPropertyUpdateability() {
 		return entityMetamodel.getNonlazyPropertyUpdateability();
 	}
 
 	public boolean[] getPropertyInsertability() {
 		return entityMetamodel.getPropertyInsertability();
 	}
 
 	public ValueInclusion[] getPropertyInsertGenerationInclusions() {
 		return entityMetamodel.getPropertyInsertGenerationInclusions();
 	}
 
 	public ValueInclusion[] getPropertyUpdateGenerationInclusions() {
 		return entityMetamodel.getPropertyUpdateGenerationInclusions();
 	}
 
 	public boolean[] getPropertyNullability() {
 		return entityMetamodel.getPropertyNullability();
 	}
 
 	public boolean[] getPropertyVersionability() {
 		return entityMetamodel.getPropertyVersionability();
 	}
 
 	public CascadeStyle[] getPropertyCascadeStyles() {
 		return entityMetamodel.getCascadeStyles();
 	}
 
 	public final Class getMappedClass() {
 		return getEntityTuplizer().getMappedClass();
 	}
 
 	public boolean implementsLifecycle() {
 		return getEntityTuplizer().isLifecycleImplementor();
 	}
 
 	public Class getConcreteProxyClass() {
 		return getEntityTuplizer().getConcreteProxyClass();
 	}
 
 	public void setPropertyValues(Object object, Object[] values) {
 		getEntityTuplizer().setPropertyValues( object, values );
 	}
 
 	public void setPropertyValue(Object object, int i, Object value) {
 		getEntityTuplizer().setPropertyValue( object, i, value );
 	}
 
 	public Object[] getPropertyValues(Object object) {
 		return getEntityTuplizer().getPropertyValues( object );
 	}
 
 	@Override
 	public Object getPropertyValue(Object object, int i) {
 		return getEntityTuplizer().getPropertyValue( object, i );
 	}
 
 	@Override
 	public Object getPropertyValue(Object object, String propertyName) {
 		return getEntityTuplizer().getPropertyValue( object, propertyName );
 	}
 
 	@Override
 	public Serializable getIdentifier(Object object) {
 		return getEntityTuplizer().getIdentifier( object, null );
 	}
 
 	@Override
 	public Serializable getIdentifier(Object entity, SessionImplementor session) {
 		return getEntityTuplizer().getIdentifier( entity, session );
 	}
 
 	@Override
 	public void setIdentifier(Object entity, Serializable id, SessionImplementor session) {
 		getEntityTuplizer().setIdentifier( entity, id, session );
 	}
 
 	@Override
 	public Object getVersion(Object object) {
 		return getEntityTuplizer().getVersion( object );
 	}
 
 	@Override
 	public Object instantiate(Serializable id, SessionImplementor session) {
 		return getEntityTuplizer().instantiate( id, session );
 	}
 
 	@Override
 	public boolean isInstance(Object object) {
 		return getEntityTuplizer().isInstance( object );
 	}
 
 	@Override
 	public boolean hasUninitializedLazyProperties(Object object) {
 		return getEntityTuplizer().hasUninitializedLazyProperties( object );
 	}
 
 	@Override
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, SessionImplementor session) {
 		getEntityTuplizer().resetIdentifier( entity, currentId, currentVersion, session );
 	}
 
 	@Override
 	public EntityPersister getSubclassEntityPersister(Object instance, SessionFactoryImplementor factory) {
 		if ( !hasSubclasses() ) {
 			return this;
 		}
 		else {
 			final String concreteEntityName = getEntityTuplizer().determineConcreteSubclassEntityName(
 					instance,
 					factory
 			);
 			if ( concreteEntityName == null || getEntityName().equals( concreteEntityName ) ) {
 				// the contract of EntityTuplizer.determineConcreteSubclassEntityName says that returning null
 				// is an indication that the specified entity-name (this.getEntityName) should be used.
 				return this;
 			}
 			else {
 				return factory.getEntityPersister( concreteEntityName );
 			}
 		}
 	}
 
 	public boolean isMultiTable() {
 		return false;
 	}
 
 	public String getTemporaryIdTableName() {
 		return temporaryIdTableName;
 	}
 
 	public String getTemporaryIdTableDDL() {
 		return temporaryIdTableDDL;
 	}
 
 	protected int getPropertySpan() {
 		return entityMetamodel.getPropertySpan();
 	}
 
 	public Object[] getPropertyValuesToInsert(Object object, Map mergeMap, SessionImplementor session) throws HibernateException {
 		return getEntityTuplizer().getPropertyValuesToInsert( object, mergeMap, session );
 	}
 
 	public void processInsertGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session) {
 		if ( !hasInsertGeneratedProperties() ) {
 			throw new AssertionFailure("no insert-generated properties");
 		}
 		processGeneratedProperties( id, entity, state, session, sqlInsertGeneratedValuesSelectString, getPropertyInsertGenerationInclusions() );
 	}
 
 	public void processUpdateGeneratedProperties(Serializable id, Object entity, Object[] state, SessionImplementor session) {
 		if ( !hasUpdateGeneratedProperties() ) {
 			throw new AssertionFailure("no update-generated properties");
 		}
 		processGeneratedProperties( id, entity, state, session, sqlUpdateGeneratedValuesSelectString, getPropertyUpdateGenerationInclusions() );
 	}
 
 	private void processGeneratedProperties(
 			Serializable id,
 	        Object entity,
 	        Object[] state,
 	        SessionImplementor session,
 	        String selectionSQL,
 	        ValueInclusion[] includeds) {
 		// force immediate execution of the insert batch (if one)
 		session.getTransactionCoordinator().getJdbcCoordinator().executeBatch();
 
 		try {
 			PreparedStatement ps = session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getStatementPreparer()
 					.prepareStatement( selectionSQL );
 			try {
 				getIdentifierType().nullSafeSet( ps, id, 1, session );
 				ResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( ps );
 				try {
 					if ( !rs.next() ) {
 						throw new HibernateException(
 								"Unable to locate row for retrieval of generated properties: " +
 								MessageHelper.infoString( this, id, getFactory() )
 							);
 					}
 					for ( int i = 0; i < getPropertySpan(); i++ ) {
 						if ( includeds[i] != ValueInclusion.NONE ) {
 							Object hydratedState = getPropertyTypes()[i].hydrate( rs, getPropertyAliases( "", i ), session, entity );
 							state[i] = getPropertyTypes()[i].resolve( hydratedState, session, entity );
 							setPropertyValue( entity, i, state[i] );
 						}
 					}
 				}
 				finally {
 					if ( rs != null ) {
 						session.getTransactionCoordinator().getJdbcCoordinator().release( rs, ps );
 					}
 				}
 			}
 			finally {
 				session.getTransactionCoordinator().getJdbcCoordinator().release( ps );
 			}
 		}
 		catch( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					"unable to select generated column values",
 					selectionSQL
 			);
 		}
 
 	}
 
 	public String getIdentifierPropertyName() {
 		return entityMetamodel.getIdentifierProperty().getName();
 	}
 
 	public Type getIdentifierType() {
 		return entityMetamodel.getIdentifierProperty().getType();
 	}
 
 	public boolean hasSubselectLoadableCollections() {
 		return hasSubselectLoadableCollections;
 	}
 
 	public int[] getNaturalIdentifierProperties() {
 		return entityMetamodel.getNaturalIdentifierProperties();
 	}
 
 	public Object[] getNaturalIdentifierSnapshot(Serializable id, SessionImplementor session) throws HibernateException {
 		if ( !hasNaturalIdentifier() ) {
 			throw new MappingException( "persistent class did not define a natural-id : " + MessageHelper.infoString( this ) );
 		}
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Getting current natural-id snapshot state for: {0}",
 					MessageHelper.infoString( this, id, getFactory() ) );
 		}
 
 		int[] naturalIdPropertyIndexes = getNaturalIdentifierProperties();
 		int naturalIdPropertyCount = naturalIdPropertyIndexes.length;
 		boolean[] naturalIdMarkers = new boolean[ getPropertySpan() ];
 		Type[] extractionTypes = new Type[ naturalIdPropertyCount ];
 		for ( int i = 0; i < naturalIdPropertyCount; i++ ) {
 			extractionTypes[i] = getPropertyTypes()[ naturalIdPropertyIndexes[i] ];
 			naturalIdMarkers[ naturalIdPropertyIndexes[i] ] = true;
 		}
 
 		///////////////////////////////////////////////////////////////////////
 		// TODO : look at perhaps caching this...
 		Select select = new Select( getFactory().getDialect() );
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "get current natural-id state " + getEntityName() );
 		}
 		select.setSelectClause( concretePropertySelectFragmentSansLeadingComma( getRootAlias(), naturalIdMarkers ) );
 		select.setFromClause( fromTableFragment( getRootAlias() ) + fromJoinFragment( getRootAlias(), true, false ) );
 
 		String[] aliasedIdColumns = StringHelper.qualify( getRootAlias(), getIdentifierColumnNames() );
 		String whereClause = new StringBuilder()
 			.append( StringHelper.join( "=? and ",
 					aliasedIdColumns ) )
 			.append( "=?" )
 			.append( whereJoinFragment( getRootAlias(), true, false ) )
 			.toString();
 
 		String sql = select.setOuterJoins( "", "" )
 				.setWhereClause( whereClause )
 				.toStatementString();
 		///////////////////////////////////////////////////////////////////////
 
 		Object[] snapshot = new Object[ naturalIdPropertyCount ];
 		try {
 			PreparedStatement ps = session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getStatementPreparer()
 					.prepareStatement( sql );
 			try {
 				getIdentifierType().nullSafeSet( ps, id, 1, session );
 				ResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( ps );
 				try {
 					//if there is no resulting row, return null
 					if ( !rs.next() ) {
 						return null;
 					}
 					final EntityKey key = session.generateEntityKey( id, this );
 					Object owner = session.getPersistenceContext().getEntity( key );
 					for ( int i = 0; i < naturalIdPropertyCount; i++ ) {
 						snapshot[i] = extractionTypes[i].hydrate( rs, getPropertyAliases( "", naturalIdPropertyIndexes[i] ), session, null );
 						if (extractionTypes[i].isEntityType()) {
 							snapshot[i] = extractionTypes[i].resolve(snapshot[i], session, owner);
 						}
 					}
 					return snapshot;
 				}
 				finally {
 					session.getTransactionCoordinator().getJdbcCoordinator().release( rs, ps );
 				}
 			}
 			finally {
 				session.getTransactionCoordinator().getJdbcCoordinator().release( ps );
 			}
 		}
 		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					"could not retrieve snapshot: " + MessageHelper.infoString( this, id, getFactory() ),
 			        sql
 			);
 		}
 	}
 
 	@Override
 	public Serializable loadEntityIdByNaturalId(
 			Object[] naturalIdValues,
 			LockOptions lockOptions,
 			SessionImplementor session) {
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracef(
 					"Resolving natural-id [%s] to id : %s ",
 					naturalIdValues,
 					MessageHelper.infoString( this )
 			);
 		}
 
 		final boolean[] valueNullness = determineValueNullness( naturalIdValues );
 		final String sqlEntityIdByNaturalIdString = determinePkByNaturalIdQuery( valueNullness );
 
 		try {
 			PreparedStatement ps = session.getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getStatementPreparer()
 					.prepareStatement( sqlEntityIdByNaturalIdString );
 			try {
 				int positions = 1;
 				int loop = 0;
 				for ( int idPosition : getNaturalIdentifierProperties() ) {
 					final Object naturalIdValue = naturalIdValues[loop++];
 					if ( naturalIdValue != null ) {
 						final Type type = getPropertyTypes()[idPosition];
 						type.nullSafeSet( ps, naturalIdValue, positions, session );
 						positions += type.getColumnSpan( session.getFactory() );
 					}
 				}
 				ResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( ps );
 				try {
 					// if there is no resulting row, return null
 					if ( !rs.next() ) {
 						return null;
 					}
 
 					return (Serializable) getIdentifierType().hydrate( rs, getIdentifierAliases(), session, null );
 				}
 				finally {
 					session.getTransactionCoordinator().getJdbcCoordinator().release( rs, ps );
 				}
 			}
 			finally {
 				session.getTransactionCoordinator().getJdbcCoordinator().release( ps );
 			}
 		}
 		catch ( SQLException e ) {
 			throw getFactory().getSQLExceptionHelper().convert(
 					e,
 					String.format(
 							"could not resolve natural-id [%s] to id : %s",
 							naturalIdValues,
 							MessageHelper.infoString( this )
 					),
 					sqlEntityIdByNaturalIdString
 			);
 		}
 	}
 
 	private boolean[] determineValueNullness(Object[] naturalIdValues) {
 		boolean[] nullness = new boolean[ naturalIdValues.length ];
 		for ( int i = 0; i < naturalIdValues.length; i++ ) {
 			nullness[i] = naturalIdValues[i] == null;
 		}
 		return nullness;
 	}
 
 	private Boolean naturalIdIsNonNullable;
 	private String cachedPkByNonNullableNaturalIdQuery;
 
 	private String determinePkByNaturalIdQuery(boolean[] valueNullness) {
 		if ( ! hasNaturalIdentifier() ) {
 			throw new HibernateException( "Attempt to build natural-id -> PK resolution query for entity that does not define natural id" );
 		}
 
 		// performance shortcut for cases where the natural-id is defined as completely non-nullable
 		if ( isNaturalIdNonNullable() ) {
 			if ( valueNullness != null && ! ArrayHelper.isAllFalse( valueNullness ) ) {
 				throw new HibernateException( "Null value(s) passed to lookup by non-nullable natural-id" );
 			}
 			if ( cachedPkByNonNullableNaturalIdQuery == null ) {
 				cachedPkByNonNullableNaturalIdQuery = generateEntityIdByNaturalIdSql( null );
 			}
 			return cachedPkByNonNullableNaturalIdQuery;
 		}
 
 		// Otherwise, regenerate it each time
 		return generateEntityIdByNaturalIdSql( valueNullness );
 	}
 
-	@SuppressWarnings("UnnecessaryUnboxing")
 	protected boolean isNaturalIdNonNullable() {
 		if ( naturalIdIsNonNullable == null ) {
 			naturalIdIsNonNullable = determineNaturalIdNullability();
 		}
-		return naturalIdIsNonNullable.booleanValue();
+		return naturalIdIsNonNullable;
 	}
 
 	private boolean determineNaturalIdNullability() {
 		boolean[] nullability = getPropertyNullability();
 		for ( int position : getNaturalIdentifierProperties() ) {
 			// if any individual property is nullable, return false
 			if ( nullability[position] ) {
 				return false;
 			}
 		}
 		// return true if we found no individually nullable properties
 		return true;
 	}
 
 	private String generateEntityIdByNaturalIdSql(boolean[] valueNullness) {
 		EntityPersister rootPersister = getFactory().getEntityPersister( getRootEntityName() );
 		if ( rootPersister != this ) {
 			if ( rootPersister instanceof AbstractEntityPersister ) {
 				return ( (AbstractEntityPersister) rootPersister ).generateEntityIdByNaturalIdSql( valueNullness );
 			}
 		}
 
 		Select select = new Select( getFactory().getDialect() );
 		if ( getFactory().getSettings().isCommentsEnabled() ) {
 			select.setComment( "get current natural-id->entity-id state " + getEntityName() );
 		}
 
 		final String rootAlias = getRootAlias();
 
 		select.setSelectClause( identifierSelectFragment( rootAlias, "" ) );
 		select.setFromClause( fromTableFragment( rootAlias ) + fromJoinFragment( rootAlias, true, false ) );
 
 		final StringBuilder whereClause = new StringBuilder();
 		final int[] propertyTableNumbers = getPropertyTableNumbers();
 		final int[] naturalIdPropertyIndexes = this.getNaturalIdentifierProperties();
 		int valuesIndex = -1;
 		for ( int propIdx = 0; propIdx < naturalIdPropertyIndexes.length; propIdx++ ) {
 			valuesIndex++;
 			if ( propIdx > 0 ) {
 				whereClause.append( " and " );
 			}
 
 			final int naturalIdIdx = naturalIdPropertyIndexes[propIdx];
 			final String tableAlias = generateTableAlias( rootAlias, propertyTableNumbers[naturalIdIdx] );
 			final String[] propertyColumnNames = getPropertyColumnNames( naturalIdIdx );
 			final String[] aliasedPropertyColumns = StringHelper.qualify( tableAlias, propertyColumnNames );
 
 			if ( valueNullness != null && valueNullness[valuesIndex] ) {
 				whereClause.append( StringHelper.join( " is null and ", aliasedPropertyColumns ) ).append( " is null" );
 			}
 			else {
 				whereClause.append( StringHelper.join( "=? and ", aliasedPropertyColumns ) ).append( "=?" );
 			}
 		}
 
 		whereClause.append( whereJoinFragment( getRootAlias(), true, false ) );
 
 		return select.setOuterJoins( "", "" ).setWhereClause( whereClause.toString() ).toStatementString();
 	}
 
 	protected String concretePropertySelectFragmentSansLeadingComma(String alias, boolean[] include) {
 		String concretePropertySelectFragment = concretePropertySelectFragment( alias, include );
 		int firstComma = concretePropertySelectFragment.indexOf( ", " );
 		if ( firstComma == 0 ) {
 			concretePropertySelectFragment = concretePropertySelectFragment.substring( 2 );
 		}
 		return concretePropertySelectFragment;
 	}
 
 	public boolean hasNaturalIdentifier() {
 		return entityMetamodel.hasNaturalIdentifier();
 	}
 
 	public void setPropertyValue(Object object, String propertyName, Object value) {
 		getEntityTuplizer().setPropertyValue( object, propertyName, value );
 	}
 	
 	public static int getTableId(String tableName, String[] tables) {
 		for ( int j = 0; j < tables.length; j++ ) {
 			if ( tableName.equalsIgnoreCase( tables[j] ) ) {
 				return j;
 			}
 		}
 		throw new AssertionFailure( "Table " + tableName + " not found" );
 	}
 	
 	@Override
 	public EntityMode getEntityMode() {
 		return entityMetamodel.getEntityMode();
 	}
 
 	@Override
 	public EntityTuplizer getEntityTuplizer() {
 		return entityTuplizer;
 	}
 
 	@Override
 	public EntityInstrumentationMetadata getInstrumentationMetadata() {
 		return entityMetamodel.getInstrumentationMetadata();
 	}
 
 	@Override
 	public String getTableAliasForColumn(String columnName, String rootAlias) {
 		return generateTableAlias( rootAlias, determineTableNumberForColumn( columnName ) );
 	}
 
 	public int determineTableNumberForColumn(String columnName) {
 		return 0;
 	}
 
 	/**
 	 * Consolidated these onto a single helper because the 2 pieces work in tandem.
 	 */
 	public static interface CacheEntryHelper {
 		public CacheEntryStructure getCacheEntryStructure();
 
 		public CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SessionImplementor session);
 	}
 
 	private static class StandardCacheEntryHelper implements CacheEntryHelper {
 		private final EntityPersister persister;
 
 		private StandardCacheEntryHelper(EntityPersister persister) {
 			this.persister = persister;
 		}
 
 		@Override
 		public CacheEntryStructure getCacheEntryStructure() {
 			return UnstructuredCacheEntry.INSTANCE;
 		}
 
 		@Override
 		public CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SessionImplementor session) {
 			return new StandardCacheEntryImpl(
 					state,
 					persister,
 					persister.hasUninitializedLazyProperties( entity ),
 					version,
 					session,
 					entity
 			);
 		}
 	}
 
 	private static class ReferenceCacheEntryHelper implements CacheEntryHelper {
 		private final EntityPersister persister;
 
 		private ReferenceCacheEntryHelper(EntityPersister persister) {
 			this.persister = persister;
 		}
 
 		@Override
 		public CacheEntryStructure getCacheEntryStructure() {
 			return UnstructuredCacheEntry.INSTANCE;
 		}
 
 		@Override
 		public CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SessionImplementor session) {
 			return new ReferenceCacheEntryImpl( entity, persister.getEntityName() );
 		}
 	}
 
 	private static class StructuredCacheEntryHelper implements CacheEntryHelper {
 		private final EntityPersister persister;
 		private final StructuredCacheEntry structure;
 
 		private StructuredCacheEntryHelper(EntityPersister persister) {
 			this.persister = persister;
 			this.structure = new StructuredCacheEntry( persister );
 		}
 
 		@Override
 		public CacheEntryStructure getCacheEntryStructure() {
 			return structure;
 		}
 
 		@Override
 		public CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SessionImplementor session) {
 			return new StandardCacheEntryImpl(
 					state,
 					persister,
 					persister.hasUninitializedLazyProperties( entity ),
 					version,
 					session,
 					entity
 			);
 		}
 	}
 
 	private static class NoopCacheEntryHelper implements CacheEntryHelper {
 		public static final NoopCacheEntryHelper INSTANCE = new NoopCacheEntryHelper();
 
 		@Override
 		public CacheEntryStructure getCacheEntryStructure() {
 			return UnstructuredCacheEntry.INSTANCE;
 		}
 
 		@Override
 		public CacheEntry buildCacheEntry(Object entity, Object[] state, Object version, SessionImplementor session) {
 			throw new HibernateException( "Illegal attempt to build cache entry for non-cached entity" );
 		}
 	}
 
 
 	// EntityDefinition impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	private EntityIdentifierDefinition entityIdentifierDefinition;
 	private Iterable<AttributeDefinition> embeddedCompositeIdentifierAttributes;
 	private Iterable<AttributeDefinition> attributeDefinitions;
 
 	protected void generateEntityDefinition() {
 		prepareEntityIdentifierDefinition();
 		collectAttributeDefinitions();
 	}
 
 	@Override
 	public EntityPersister getEntityPersister() {
 		return this;
 	}
 
 	@Override
 	public EntityIdentifierDefinition getEntityKeyDefinition() {
 		return entityIdentifierDefinition;
 	}
 
 	@Override
 	public Iterable<AttributeDefinition> getAttributes() {
 		return attributeDefinitions;
 	}
 
 
 	private void prepareEntityIdentifierDefinition() {
 		final Type idType = getIdentifierType();
 
 		if ( !idType.isComponentType() ) {
 			entityIdentifierDefinition =
 					EntityIdentifierDefinitionHelper.buildSimpleEncapsulatedIdentifierDefinition( this );
 			return;
 		}
 
 		final CompositeType cidType = (CompositeType) idType;
 		if ( !cidType.isEmbedded() ) {
 			entityIdentifierDefinition =
 					EntityIdentifierDefinitionHelper.buildEncapsulatedCompositeIdentifierDefinition( this );
 			return;
 		}
 
 		entityIdentifierDefinition =
 				EntityIdentifierDefinitionHelper.buildNonEncapsulatedCompositeIdentifierDefinition( this );
 	}
 
 	private void collectAttributeDefinitions() {
 		// todo : leverage the attribute definitions housed on EntityMetamodel
 		// 		for that to work, we'd have to be able to walk our super entity persister(s)
 		attributeDefinitions = new Iterable<AttributeDefinition>() {
 			@Override
 			public Iterator<AttributeDefinition> iterator() {
 				return new Iterator<AttributeDefinition>() {
 //					private final int numberOfAttributes = countSubclassProperties();
 					private final int numberOfAttributes = entityMetamodel.getPropertySpan();
 					private int currentAttributeNumber = 0;
 
 					@Override
 					public boolean hasNext() {
 						return currentAttributeNumber < numberOfAttributes;
 					}
 
 					@Override
 					public AttributeDefinition next() {
 						final int attributeNumber = currentAttributeNumber;
 						currentAttributeNumber++;
 						return entityMetamodel.getProperties()[ attributeNumber ];
 					}
 
 					@Override
 					public void remove() {
 						throw new UnsupportedOperationException( "Remove operation not supported here" );
 					}
 				};
 			}
 		};
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/entity/NamedQueryLoader.java b/hibernate-core/src/main/java/org/hibernate/persister/entity/NamedQueryLoader.java
index 4c61041cac..c112420896 100755
--- a/hibernate-core/src/main/java/org/hibernate/persister/entity/NamedQueryLoader.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/entity/NamedQueryLoader.java
@@ -1,95 +1,95 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.entity;
 
 import java.io.Serializable;
 
 import org.hibernate.FlushMode;
 import org.hibernate.LockOptions;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.AbstractQueryImpl;
 import org.hibernate.internal.CoreLogging;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.loader.entity.UniqueEntityLoader;
 
 /**
  * Not really a Loader, just a wrapper around a named query.  Used when the metadata has named a query to use for
  * loading an entity (using {@link org.hibernate.annotations.Loader} or {@code <loader/>}).
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public final class NamedQueryLoader implements UniqueEntityLoader {
 	private static final CoreMessageLogger LOG = CoreLogging.messageLogger( NamedQueryLoader.class );
 
 	private final String queryName;
 	private final EntityPersister persister;
 
 	/**
 	 * Constructs the NamedQueryLoader
 	 *
 	 * @param queryName The name of the named query to use
 	 * @param persister The corresponding persister for the entity we are loading
 	 */
 	public NamedQueryLoader(String queryName, EntityPersister persister) {
 		super();
 		this.queryName = queryName;
 		this.persister = persister;
 	}
 
 	@Override
 	public Object load(Serializable id, Object optionalObject, SessionImplementor session, LockOptions lockOptions) {
 		if ( lockOptions != null ) {
 			LOG.debug( "Ignoring lock-options passed to named query loader" );
 		}
 		return load( id, optionalObject, session );
 	}
 
 	@Override
 	public Object load(Serializable id, Object optionalObject, SessionImplementor session) {
 		LOG.debugf( "Loading entity: %s using named query: %s", persister.getEntityName(), queryName );
 
 		// IMPL NOTE: essentially we perform the named query (which loads the entity into the PC), and then
 		// do an internal lookup of the entity from the PC.
 
 		final AbstractQueryImpl query = (AbstractQueryImpl) session.getNamedQuery( queryName );
 		if ( query.hasNamedParameters() ) {
 			query.setParameter( query.getNamedParameters()[0], id, persister.getIdentifierType() );
 		}
 		else {
 			query.setParameter( 0, id, persister.getIdentifierType() );
 		}
 
 		query.setOptionalId( id );
 		query.setOptionalEntityName( persister.getEntityName() );
 		query.setOptionalObject( optionalObject );
 		query.setFlushMode( FlushMode.MANUAL );
 		query.list();
 
 		// now look up the object we are really interested in!
 		// (this lets us correctly handle proxies and multi-row or multi-column queries)
 		return session.getPersistenceContext().getEntity( session.generateEntityKey( id, persister ) );
 
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/walking/internal/EntityIdentifierDefinitionHelper.java b/hibernate-core/src/main/java/org/hibernate/persister/walking/internal/EntityIdentifierDefinitionHelper.java
index bec4320dc2..6e6e7f5a2f 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/walking/internal/EntityIdentifierDefinitionHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/walking/internal/EntityIdentifierDefinitionHelper.java
@@ -1,153 +1,153 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.walking.internal;
 
 import org.hibernate.persister.entity.AbstractEntityPersister;
 import org.hibernate.persister.walking.spi.AttributeDefinition;
 import org.hibernate.persister.walking.spi.AttributeSource;
 import org.hibernate.persister.walking.spi.CompositionDefinition;
 import org.hibernate.persister.walking.spi.EncapsulatedEntityIdentifierDefinition;
 import org.hibernate.persister.walking.spi.EntityDefinition;
 import org.hibernate.persister.walking.spi.EntityIdentifierDefinition;
 import org.hibernate.persister.walking.spi.NonEncapsulatedEntityIdentifierDefinition;
 import org.hibernate.type.Type;
 
 /**
  * @author Gail Badner
  */
 public class EntityIdentifierDefinitionHelper {
 
 	public static EntityIdentifierDefinition buildSimpleEncapsulatedIdentifierDefinition(final AbstractEntityPersister entityPersister) {
 		return new EncapsulatedEntityIdentifierDefinition() {
 			@Override
 			public AttributeDefinition getAttributeDefinition() {
 				return new AttributeDefinitionAdapter( entityPersister);
 			}
 
 			@Override
 			public boolean isEncapsulated() {
 				return true;
 			}
 
 			@Override
 			public EntityDefinition getEntityDefinition() {
 				return entityPersister;
 			}
 		};
 	}
 
 	public static EntityIdentifierDefinition buildEncapsulatedCompositeIdentifierDefinition(
 			final AbstractEntityPersister entityPersister) {
 
 		return new EncapsulatedEntityIdentifierDefinition() {
 			@Override
 			public AttributeDefinition getAttributeDefinition() {
 				return new CompositionDefinitionAdapter( entityPersister );
 			}
 
 			@Override
 			public boolean isEncapsulated() {
 				return true;
 			}
 
 			@Override
 			public EntityDefinition getEntityDefinition() {
 				return entityPersister;
 			}
 		};
 	}
 
 	public static EntityIdentifierDefinition buildNonEncapsulatedCompositeIdentifierDefinition(final AbstractEntityPersister entityPersister) {
 		return new NonEncapsulatedEntityIdentifierDefinition() {
 			@Override
 			public Iterable<AttributeDefinition> getAttributes() {
 				return CompositionSingularSubAttributesHelper.getIdentifierSubAttributes( entityPersister );
 			}
 
 			@Override
 			public Class getSeparateIdentifierMappingClass() {
 				return entityPersister.getEntityMetamodel().getIdentifierProperty().getType().getReturnedClass();
 			}
 
 			@Override
 			public boolean isEncapsulated() {
 				return false;
 			}
 
 			@Override
 			public EntityDefinition getEntityDefinition() {
 				return entityPersister;
 			}
 		};
 	}
 
 	private static class AttributeDefinitionAdapter implements AttributeDefinition {
 		private final AbstractEntityPersister entityPersister;
 
 		AttributeDefinitionAdapter(AbstractEntityPersister entityPersister) {
 			this.entityPersister = entityPersister;
 		}
 
 		@Override
 		public String getName() {
 			return entityPersister.getEntityMetamodel().getIdentifierProperty().getName();
 		}
 
 		@Override
 		public Type getType() {
 			return entityPersister.getEntityMetamodel().getIdentifierProperty().getType();
 		}
 
 		@Override
 		public AttributeSource getSource() {
 			return entityPersister;
 		}
 
 		@Override
 		public String toString() {
 			return "<identifier-property:" + getName() + ">";
 		}
 
 		protected AbstractEntityPersister getEntityPersister() {
 			return entityPersister;
 		}
 	}
 
 	private static class CompositionDefinitionAdapter extends AttributeDefinitionAdapter implements CompositionDefinition {
 
 		CompositionDefinitionAdapter(AbstractEntityPersister entityPersister) {
 			super( entityPersister );
 		}
 
 		@Override
 		public String toString() {
 			return "<identifier-property:" + getName() + ">";
 		}
 
 		@Override
 		public Iterable<AttributeDefinition> getAttributes() {
 			return  CompositionSingularSubAttributesHelper.getIdentifierSubAttributes( getEntityPersister() );
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/walking/spi/package-info.java b/hibernate-core/src/main/java/org/hibernate/persister/walking/spi/package-info.java
index 90d0cd8faf..9c5f4e0a14 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/walking/spi/package-info.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/walking/spi/package-info.java
@@ -1,6 +1,6 @@
 package org.hibernate.persister.walking.spi;
 
 /**
  * Package for "walking" associations through metadata definition.  Ultimately want {@link org.hibernate.persister.walking.spi.AttributeDefinition} and
  * {@link AttributeSource} etc to become part of the persister model.
- */
\ No newline at end of file
+ */
diff --git a/hibernate-core/src/main/java/org/hibernate/procedure/package-info.java b/hibernate-core/src/main/java/org/hibernate/procedure/package-info.java
index dea61abc24..0ce80e69e9 100644
--- a/hibernate-core/src/main/java/org/hibernate/procedure/package-info.java
+++ b/hibernate-core/src/main/java/org/hibernate/procedure/package-info.java
@@ -1,37 +1,37 @@
 package org.hibernate.procedure;
 
 /**
  * Defines support for executing database stored procedures and functions and accessing its outputs.
  * <p/>
  * First a reference to  {@link ProcedureCall} is obtained through one of the overloaded
  * {@link org.hibernate.Session#createStoredProcedureCall} methods.  The ProcedureCall reference is then used to "configure"
  * the procedure call (set timeouts, etc) and to perform parameter registration.  All procedure parameters that the
  * application wants to use must be registered.  For all IN and INOUT parameters, values can then be bound.
  * <p/>
  * At this point we are ready to execute the procedure call and start accessing the outputs.  This is done by first
  * calling the {@link ProcedureCall#getResult()} method.  The underlying JDBC call is executed as needed.  The pattern to
  * access the returns is iterating through the outputs while {@link ProcedureResult#hasMoreReturns()} returns {@code true} and
  * calling {@link ProcedureResult#getNextReturn()} during iteration:
  * <code>
  *     ProcedureCall call = session.createStoredProcedureCall( "some_procedure" );
  *     ...
  *     ProcedureResult result = call.getResult();
  *     while ( result.hasMoreReturns() ) {
  *         final Return rtn = result.getNextReturn();
  *         if ( rtn.isResultSet() ) {
  *             handleResultSetReturn( (ResultSetReturn) rtn );
  *         }
  *         else {
  *             handleUpdateCountReturn( (UpdateCountReturn) rtn );
  *         }
  *     }
  * </code>
  * <p/>
  * Finally output parameters can be accessed using the overloaded {@link ProcedureResult#getOutputParameterValue} methods.
  * For portability amongst databases, it is advised to access the output parameters after all returns have been
  * processed.
  *
  * @see org.hibernate.Session#createStoredProcedureCall(String)
  * @see org.hibernate.Session#createStoredProcedureCall(String, Class[])
  * @see org.hibernate.Session#createStoredProcedureCall(String, String...)
- */
\ No newline at end of file
+ */
diff --git a/hibernate-core/src/main/java/org/hibernate/proxy/AbstractLazyInitializer.java b/hibernate-core/src/main/java/org/hibernate/proxy/AbstractLazyInitializer.java
index cb8b81da89..19865c66a1 100755
--- a/hibernate-core/src/main/java/org/hibernate/proxy/AbstractLazyInitializer.java
+++ b/hibernate-core/src/main/java/org/hibernate/proxy/AbstractLazyInitializer.java
@@ -1,408 +1,408 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.proxy;
 
 import java.io.Serializable;
 
 import javax.naming.NamingException;
 
 import org.hibernate.HibernateException;
 import org.hibernate.LazyInitializationException;
 import org.hibernate.Session;
 import org.hibernate.SessionException;
 import org.hibernate.TransientObjectException;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.SessionFactoryRegistry;
 import org.hibernate.persister.entity.EntityPersister;
 import org.jboss.logging.Logger;
 
 /**
  * Convenience base class for lazy initialization handlers.  Centralizes the basic plumbing of doing lazy
  * initialization freeing subclasses to acts as essentially adapters to their intended entity mode and/or
  * proxy generation strategy.
  *
  * @author Gavin King
  */
 public abstract class AbstractLazyInitializer implements LazyInitializer {
 	private static final Logger log = Logger.getLogger( AbstractLazyInitializer.class );
 
 	private String entityName;
 	private Serializable id;
 	private Object target;
 	private boolean initialized;
 	private boolean readOnly;
 	private boolean unwrap;
 	private transient SessionImplementor session;
 	private Boolean readOnlyBeforeAttachedToSession;
 
 	private String sessionFactoryUuid;
 	private boolean specjLazyLoad = false;
 
 	/**
 	 * For serialization from the non-pojo initializers (HHH-3309)
 	 */
 	protected AbstractLazyInitializer() {
 	}
 
 	/**
 	 * Main constructor.
 	 *
 	 * @param entityName The name of the entity being proxied.
 	 * @param id The identifier of the entity being proxied.
 	 * @param session The session owning the proxy.
 	 */
 	protected AbstractLazyInitializer(String entityName, Serializable id, SessionImplementor session) {
 		this.entityName = entityName;
 		this.id = id;
 		// initialize other fields depending on session state
 		if ( session == null ) {
 			unsetSession();
 		}
 		else {
 			setSession( session );
 		}
 	}
 
 	@Override
 	public final String getEntityName() {
 		return entityName;
 	}
 
 	@Override
 	public final Serializable getIdentifier() {
 		return id;
 	}
 
 	@Override
 	public final void setIdentifier(Serializable id) {
 		this.id = id;
 	}
 
 	@Override
 	public final boolean isUninitialized() {
 		return !initialized;
 	}
 
 	@Override
 	public final SessionImplementor getSession() {
 		return session;
 	}
 
 	@Override
 	public final void setSession(SessionImplementor s) throws HibernateException {
 		if ( s != session ) {
 			// check for s == null first, since it is least expensive
 			if ( s == null ) {
 				unsetSession();
 			}
 			else if ( isConnectedToSession() ) {
 				//TODO: perhaps this should be some other RuntimeException...
 				throw new HibernateException( "illegally attempted to associate a proxy with two open Sessions" );
 			}
 			else {
 				// s != null
 				session = s;
 				if ( readOnlyBeforeAttachedToSession == null ) {
 					// use the default read-only/modifiable setting
 					final EntityPersister persister = s.getFactory().getEntityPersister( entityName );
 					setReadOnly( s.getPersistenceContext().isDefaultReadOnly() || !persister.isMutable() );
 				}
 				else {
 					// use the read-only/modifiable setting indicated during deserialization
-					setReadOnly( readOnlyBeforeAttachedToSession.booleanValue() );
+					setReadOnly( readOnlyBeforeAttachedToSession );
 					readOnlyBeforeAttachedToSession = null;
 				}
 			}
 		}
 	}
 
 	private static EntityKey generateEntityKeyOrNull(Serializable id, SessionImplementor s, String entityName) {
 		if ( id == null || s == null || entityName == null ) {
 			return null;
 		}
 		return s.generateEntityKey( id, s.getFactory().getEntityPersister( entityName ) );
 	}
 
 	@Override
 	public final void unsetSession() {
 		prepareForPossibleSpecialSpecjInitialization();
 		session = null;
 		readOnly = false;
 		readOnlyBeforeAttachedToSession = null;
 	}
 
 	@Override
 	public final void initialize() throws HibernateException {
 		if ( !initialized ) {
 			if ( specjLazyLoad ) {
 				specialSpecjInitialization();
 			}
 			else if ( session == null ) {
 				throw new LazyInitializationException( "could not initialize proxy - no Session" );
 			}
 			else if ( !session.isOpen() ) {
 				throw new LazyInitializationException( "could not initialize proxy - the owning Session was closed" );
 			}
 			else if ( !session.isConnected() ) {
 				throw new LazyInitializationException( "could not initialize proxy - the owning Session is disconnected" );
 			}
 			else {
 				target = session.immediateLoad( entityName, id );
 				initialized = true;
 				checkTargetState();
 			}
 		}
 		else {
 			checkTargetState();
 		}
 	}
 
 	protected void specialSpecjInitialization() {
 		if ( session == null ) {
 			//we have a detached collection thats set to null, reattach
 			if ( sessionFactoryUuid == null ) {
 				throw new LazyInitializationException( "could not initialize proxy - no Session" );
 			}
 			try {
 				SessionFactoryImplementor sf = (SessionFactoryImplementor)
 						SessionFactoryRegistry.INSTANCE.getSessionFactory( sessionFactoryUuid );
 				SessionImplementor session = (SessionImplementor) sf.openSession();
 				
 				// TODO: On the next major release, add an
 				// 'isJTA' or 'getTransactionFactory' method to Session.
 				boolean isJTA = session.getTransactionCoordinator()
 						.getTransactionContext().getTransactionEnvironment()
 						.getTransactionFactory()
 						.compatibleWithJtaSynchronization();
 				
 				if ( !isJTA ) {
 					// Explicitly handle the transactions only if we're not in
 					// a JTA environment.  A lazy loading temporary session can
 					// be created even if a current session and transaction are
 					// open (ex: session.clear() was used).  We must prevent
 					// multiple transactions.
 					( ( Session) session ).beginTransaction();
 				}
 
 				try {
 					target = session.immediateLoad( entityName, id );
 				}
 				finally {
 					// make sure the just opened temp session gets closed!
 					try {
 						if ( !isJTA ) {
 							( ( Session) session ).getTransaction().commit();
 						}
 						( (Session) session ).close();
 					}
 					catch (Exception e) {
 						log.warn( "Unable to close temporary session used to load lazy proxy associated to no session" );
 					}
 				}
 				initialized = true;
 				checkTargetState();
 			}
 			catch (Exception e) {
 				e.printStackTrace();
 				throw new LazyInitializationException( e.getMessage() );
 			}
 		}
 		else if ( session.isOpen() && session.isConnected() ) {
 			target = session.immediateLoad( entityName, id );
 			initialized = true;
 			checkTargetState();
 		}
 		else {
 			throw new LazyInitializationException( "could not initialize proxy - Session was closed or disced" );
 		}
 	}
 
 	protected void prepareForPossibleSpecialSpecjInitialization() {
 		if ( session != null ) {
 			specjLazyLoad = session.getFactory().getSettings().isInitializeLazyStateOutsideTransactionsEnabled();
 
 			if ( specjLazyLoad && sessionFactoryUuid == null ) {
 				try {
 					sessionFactoryUuid = (String) session.getFactory().getReference().get( "uuid" ).getContent();
 				}
 				catch (NamingException e) {
 					//not much we can do if this fails...
 				}
 			}
 		}
 	}
 
 	private void checkTargetState() {
 		if ( !unwrap ) {
 			if ( target == null ) {
 				getSession().getFactory().getEntityNotFoundDelegate().handleEntityNotFound( entityName, id );
 			}
 		}
 	}
 
 	/**
 	 * Getter for property 'connectedToSession'.
 	 *
 	 * @return Value for property 'connectedToSession'.
 	 */
 	protected final boolean isConnectedToSession() {
 		return getProxyOrNull() != null;
 	}
 
 	private Object getProxyOrNull() {
 		final EntityKey entityKey = generateEntityKeyOrNull( getIdentifier(), session, getEntityName() );
 		if ( entityKey != null && session != null && session.isOpen() ) {
 			return session.getPersistenceContext().getProxy( entityKey );
 		}
 		return null;
 	}
 
 	@Override
 	public final Object getImplementation() {
 		initialize();
 		return target;
 	}
 
 	@Override
 	public final void setImplementation(Object target) {
 		this.target = target;
 		initialized = true;
 	}
 
 	@Override
 	public final Object getImplementation(SessionImplementor s) throws HibernateException {
 		final EntityKey entityKey = generateEntityKeyOrNull( getIdentifier(), s, getEntityName() );
 		return (entityKey == null ? null : s.getPersistenceContext().getEntity( entityKey ));
 	}
 
 	/**
 	 * Getter for property 'target'.
 	 * <p/>
 	 * Same as {@link #getImplementation()} except that this method will not force initialization.
 	 *
 	 * @return Value for property 'target'.
 	 */
 	protected final Object getTarget() {
 		return target;
 	}
 
 	@Override
 	public final boolean isReadOnlySettingAvailable() {
 		return (session != null && !session.isClosed());
 	}
 
 	private void errorIfReadOnlySettingNotAvailable() {
 		if ( session == null ) {
 			throw new TransientObjectException(
 					"Proxy is detached (i.e, session is null). The read-only/modifiable setting is only accessible when the proxy is associated with an open session."
 			);
 		}
 		if ( session.isClosed() ) {
 			throw new SessionException(
 					"Session is closed. The read-only/modifiable setting is only accessible when the proxy is associated with an open session."
 			);
 		}
 	}
 
 	@Override
 	public final boolean isReadOnly() {
 		errorIfReadOnlySettingNotAvailable();
 		return readOnly;
 	}
 
 	@Override
 	public final void setReadOnly(boolean readOnly) {
 		errorIfReadOnlySettingNotAvailable();
 		// only update if readOnly is different from current setting
 		if ( this.readOnly != readOnly ) {
 			final EntityPersister persister = session.getFactory().getEntityPersister( entityName );
 			if ( !persister.isMutable() && !readOnly ) {
 				throw new IllegalStateException( "cannot make proxies for immutable entities modifiable" );
 			}
 			this.readOnly = readOnly;
 			if ( initialized ) {
 				EntityKey key = generateEntityKeyOrNull( getIdentifier(), session, getEntityName() );
 				if ( key != null && session.getPersistenceContext().containsEntity( key ) ) {
 					session.getPersistenceContext().setReadOnly( target, readOnly );
 				}
 			}
 		}
 	}
 
 	/**
 	 * Get the read-only/modifiable setting that should be put in affect when it is
 	 * attached to a session.
 	 * <p/>
 	 * This method should only be called during serialization when read-only/modifiable setting
 	 * is not available (i.e., isReadOnlySettingAvailable() == false)
 	 *
 	 * @return null, if the default setting should be used;
 	 *         true, for read-only;
 	 *         false, for modifiable
 	 *
 	 * @throws IllegalStateException if isReadOnlySettingAvailable() == true
 	 */
 	protected final Boolean isReadOnlyBeforeAttachedToSession() {
 		if ( isReadOnlySettingAvailable() ) {
 			throw new IllegalStateException(
 					"Cannot call isReadOnlyBeforeAttachedToSession when isReadOnlySettingAvailable == true"
 			);
 		}
 		return readOnlyBeforeAttachedToSession;
 	}
 
 	/**
 	 * Set the read-only/modifiable setting that should be put in affect when it is
 	 * attached to a session.
 	 * <p/>
 	 * This method should only be called during deserialization, before associating
 	 * the proxy with a session.
 	 *
 	 * @param readOnlyBeforeAttachedToSession, the read-only/modifiable setting to use when
 	 * associated with a session; null indicates that the default should be used.
 	 *
 	 * @throws IllegalStateException if isReadOnlySettingAvailable() == true
 	 */
 	/* package-private */
 	final void setReadOnlyBeforeAttachedToSession(Boolean readOnlyBeforeAttachedToSession) {
 		if ( isReadOnlySettingAvailable() ) {
 			throw new IllegalStateException(
 					"Cannot call setReadOnlyBeforeAttachedToSession when isReadOnlySettingAvailable == true"
 			);
 		}
 		this.readOnlyBeforeAttachedToSession = readOnlyBeforeAttachedToSession;
 	}
 
 	@Override
 	public boolean isUnwrap() {
 		return unwrap;
 	}
 
 	@Override
 	public void setUnwrap(boolean unwrap) {
 		this.unwrap = unwrap;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/proxy/pojo/BasicLazyInitializer.java b/hibernate-core/src/main/java/org/hibernate/proxy/pojo/BasicLazyInitializer.java
index 309be39f14..4ac2e9eca2 100644
--- a/hibernate-core/src/main/java/org/hibernate/proxy/pojo/BasicLazyInitializer.java
+++ b/hibernate-core/src/main/java/org/hibernate/proxy/pojo/BasicLazyInitializer.java
@@ -1,138 +1,137 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.proxy.pojo;
 
 import java.io.Serializable;
 import java.lang.reflect.Method;
 
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.MarkerObject;
 import org.hibernate.proxy.AbstractLazyInitializer;
 import org.hibernate.type.CompositeType;
 
 /**
  * Lazy initializer for POJOs
  *
  * @author Gavin King
  */
 public abstract class BasicLazyInitializer extends AbstractLazyInitializer {
 
 	protected static final Object INVOKE_IMPLEMENTATION = new MarkerObject("INVOKE_IMPLEMENTATION");
 
 	protected final Class persistentClass;
 	protected final Method getIdentifierMethod;
 	protected final Method setIdentifierMethod;
 	protected final boolean overridesEquals;
 	protected final CompositeType componentIdType;
 
 	private Object replacement;
 
 	protected BasicLazyInitializer(
 			String entityName,
 	        Class persistentClass,
 	        Serializable id,
 	        Method getIdentifierMethod,
 	        Method setIdentifierMethod,
 	        CompositeType componentIdType,
 	        SessionImplementor session,
 	        boolean overridesEquals) {
 		super(entityName, id, session);
 		this.persistentClass = persistentClass;
 		this.getIdentifierMethod = getIdentifierMethod;
 		this.setIdentifierMethod = setIdentifierMethod;
 		this.componentIdType = componentIdType;
 		this.overridesEquals = overridesEquals;
 	}
 
 	protected abstract Object serializableProxy();
 
-	@SuppressWarnings({ "UnnecessaryBoxing" })
 	protected final Object invoke(Method method, Object[] args, Object proxy) throws Throwable {
 		String methodName = method.getName();
 		int params = args.length;
 
 		if ( params==0 ) {
 			if ( "writeReplace".equals(methodName) ) {
 				return getReplacement();
 			}
 			else if ( !overridesEquals && "hashCode".equals(methodName) ) {
-				return Integer.valueOf( System.identityHashCode(proxy) );
+				return System.identityHashCode(proxy);
 			}
 			else if ( isUninitialized() && method.equals(getIdentifierMethod) ) {
 				return getIdentifier();
 			}
 			else if ( "getHibernateLazyInitializer".equals(methodName) ) {
 				return this;
 			}
 		}
 		else if ( params==1 ) {
 			if ( !overridesEquals && "equals".equals(methodName) ) {
 				return args[0]==proxy;
 			}
 			else if ( method.equals(setIdentifierMethod) ) {
 				initialize();
 				setIdentifier( (Serializable) args[0] );
 				return INVOKE_IMPLEMENTATION;
 			}
 		}
 
 		//if it is a property of an embedded component, invoke on the "identifier"
 		if ( componentIdType!=null && componentIdType.isMethodOf(method) ) {
 			return method.invoke( getIdentifier(), args );
 		}
 
 		// otherwise:
 		return INVOKE_IMPLEMENTATION;
 
 	}
 
 	private Object getReplacement() {
 		final SessionImplementor session = getSession();
 		if ( isUninitialized() && session != null && session.isOpen()) {
 			final EntityKey key = session.generateEntityKey(
 					getIdentifier(),
 					session.getFactory().getEntityPersister( getEntityName() )
 			);
 			final Object entity = session.getPersistenceContext().getEntity(key);
 			if (entity!=null) setImplementation( entity );
 		}
 
 		if ( isUninitialized() ) {
 			if (replacement==null) {
 				replacement = serializableProxy();
 			}
 			return replacement;
 		}
 		else {
 			return getTarget();
 		}
 
 	}
 
 	public final Class getPersistentClass() {
 		return persistentClass;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/result/package-info.java b/hibernate-core/src/main/java/org/hibernate/result/package-info.java
index 8aa9877fa3..4e7282e0a1 100644
--- a/hibernate-core/src/main/java/org/hibernate/result/package-info.java
+++ b/hibernate-core/src/main/java/org/hibernate/result/package-info.java
@@ -1,24 +1,24 @@
 package org.hibernate.result;
 
 /**
  * Defines support for dealing with database results, accounting for mixed result sets and update counts hiding the
  * complexity (IMO) of how this is exposed in the JDBC API.
  *
  * {@link Result} represents the overall group of results.
  *
  * {@link Return} represents the mixed individual outcomes, which might be either a {@link ResultSetReturn} or
  * a {@link UpdateCountReturn}.
  *
  * <code>
  *     Result result = ...;
  *     while ( result.hasMoreReturns() ) {
  *         final Return rtn = result.getNextReturn();
  *         if ( rtn.isResultSet() ) {
  *             handleResultSetReturn( (ResultSetReturn) rtn );
  *         }
  *         else {
  *             handleUpdateCountReturn( (UpdateCountReturn) rtn );
  *         }
  *     }
  * </code>
- */
\ No newline at end of file
+ */
diff --git a/hibernate-core/src/main/java/org/hibernate/secure/package-info.java b/hibernate-core/src/main/java/org/hibernate/secure/package-info.java
index 31a9b0b7ff..d9e366287f 100644
--- a/hibernate-core/src/main/java/org/hibernate/secure/package-info.java
+++ b/hibernate-core/src/main/java/org/hibernate/secure/package-info.java
@@ -1,5 +1,5 @@
 package org.hibernate.secure;
 
 /**
  * Package defining support for declarative security of CRUD operations via JACC.
- */
\ No newline at end of file
+ */
diff --git a/hibernate-core/src/main/java/org/hibernate/service/internal/ServiceDependencyException.java b/hibernate-core/src/main/java/org/hibernate/service/internal/ServiceDependencyException.java
index e8cbe4cfa8..cfccd540e4 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/internal/ServiceDependencyException.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/internal/ServiceDependencyException.java
@@ -1,40 +1,40 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.internal;
 import org.hibernate.HibernateException;
 
 /**
  * Indictes a problem processing service dependencies.
  *
  * @author Steve Ebersole
  */
 public class ServiceDependencyException extends HibernateException {
 	public ServiceDependencyException(String string, Throwable root) {
 		super( string, root );
 	}
 
 	public ServiceDependencyException(String s) {
 		super( s );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/sql/DecodeCaseFragment.java b/hibernate-core/src/main/java/org/hibernate/sql/DecodeCaseFragment.java
index abe84f8088..dd9c4a3acc 100644
--- a/hibernate-core/src/main/java/org/hibernate/sql/DecodeCaseFragment.java
+++ b/hibernate-core/src/main/java/org/hibernate/sql/DecodeCaseFragment.java
@@ -1,69 +1,69 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.sql;
 import java.util.Iterator;
 import java.util.Map;
 
 /**
  * An Oracle-style DECODE function.
  * <br>
  * <code>decode(pkvalue, key1, 1, key2, 2, ..., 0)</code>
  *
  * @author Simon Harris
  */
 public class DecodeCaseFragment extends CaseFragment {
 
 	public String toFragmentString() {
 		
 		StringBuilder buf = new StringBuilder( cases.size() * 15 + 10 )
 			.append("decode(");
 
 		Iterator iter = cases.entrySet().iterator();
 		while ( iter.hasNext() ) {
 			Map.Entry me = (Map.Entry) iter.next();
 
 			if ( iter.hasNext() ) {
 				buf.append(", ")
 					.append( me.getKey() )
 					.append(", ")
 					.append( me.getValue() );
 			}
 			else {
 				buf.insert( 7, me.getKey() )
 					.append(", ")
 					.append( me.getValue() );
 			}
 		}
 
 		buf.append(')');
 		
 		if (returnColumnName!=null) {
 			buf.append(" as ")
 				.append(returnColumnName);
 		}
 		
 		return buf.toString();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/stat/Statistics.java b/hibernate-core/src/main/java/org/hibernate/stat/Statistics.java
index f870e18f17..24e0d199f8 100755
--- a/hibernate-core/src/main/java/org/hibernate/stat/Statistics.java
+++ b/hibernate-core/src/main/java/org/hibernate/stat/Statistics.java
@@ -1,275 +1,275 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.stat;
 
 /**
  * Exposes statistics for a particular {@link org.hibernate.SessionFactory}.  Beware of milliseconds metrics, they
  * are dependent of the JVM precision: you may then encounter a 10 ms approximation depending on you OS platform.
  * Please refer to the JVM documentation for more information.
  * 
  * @author Emmanuel Bernard
  */
 public interface Statistics {
 	/**
 	 * reset all statistics
 	 */
 	public void clear();
 
     /**
 	 * find entity statistics per name
 	 * 
 	 * @param entityName entity name
 	 * @return EntityStatistics object
 	 */
 	public EntityStatistics getEntityStatistics(String entityName);
 	/**
 	 * Get collection statistics per role
 	 * 
 	 * @param role collection role
 	 * @return CollectionStatistics
 	 */
 	public CollectionStatistics getCollectionStatistics(String role);
 
     /**
 	 * Second level cache statistics per region
 	 * 
 	 * @param regionName region name
 	 * @return SecondLevelCacheStatistics
 	 */
 	public SecondLevelCacheStatistics getSecondLevelCacheStatistics(String regionName);
 
     /**
 	 * Natural id cache statistics per region
 	 * 
 	 * @param regionName region name
 	 * @return NaturalIdCacheStatistics
 	 */
 	public NaturalIdCacheStatistics getNaturalIdCacheStatistics(String regionName);
 
     /**
 	 * Query statistics from query string (HQL or SQL)
 	 * 
 	 * @param queryString query string
 	 * @return QueryStatistics
 	 */
 	public QueryStatistics getQueryStatistics(String queryString);
 
     /**
      * Get global number of entity deletes
 	 * @return entity deletion count
 	 */
 	public long getEntityDeleteCount();
 
     /**
      * Get global number of entity inserts
 	 * @return entity insertion count
 	 */
 	public long getEntityInsertCount();
 
     /**
      * Get global number of entity loads
 	 * @return entity load (from DB)
 	 */
 	public long getEntityLoadCount();
 	/**
      * Get global number of entity fetchs
 	 * @return entity fetch (from DB)
 	 */
 	public long getEntityFetchCount();
 
 	/**
      * Get global number of entity updates
 	 * @return entity update
 	 */
 	public long getEntityUpdateCount();
 
     /**
      * Get global number of executed queries
 	 * @return query execution count
 	 */
 	public long getQueryExecutionCount();
 
     /**
      * Get the time in milliseconds of the slowest query.
      */
 	public long getQueryExecutionMaxTime();
 	/**
 	 * Get the query string for the slowest query.
 	 */
 	public String getQueryExecutionMaxTimeQueryString();
 
     /**
      * Get the global number of cached queries successfully retrieved from cache
      */
 	public long getQueryCacheHitCount();
     /**
      * Get the global number of cached queries *not* found in cache
      */
 	public long getQueryCacheMissCount();
     /**
      * Get the global number of cacheable queries put in cache
      */
 	public long getQueryCachePutCount();
 	/**
 	 * Get the global number of naturalId queries executed against the database
 	 */
 	public long getNaturalIdQueryExecutionCount();
 	/**
 	 * Get the global maximum query time for naturalId queries executed against the database
 	 */
 	public long getNaturalIdQueryExecutionMaxTime();
 	/**
 	 * Get the region for the maximum naturalId query time 
 	 */
 	public String getNaturalIdQueryExecutionMaxTimeRegion();
     /**
      * Get the global number of cached naturalId lookups successfully retrieved from cache
      */
 	public long getNaturalIdCacheHitCount();
     /**
      * Get the global number of cached naturalId lookups *not* found in cache
      */
 	public long getNaturalIdCacheMissCount();
     /**
      * Get the global number of cacheable naturalId lookups put in cache
      */
 	public long getNaturalIdCachePutCount();
     /**
      * Get the global number of timestamps successfully retrieved from cache
      */
 	public long getUpdateTimestampsCacheHitCount();
     /**
      * Get the global number of tables for which no update timestamps was *not* found in cache
      */
 	public long getUpdateTimestampsCacheMissCount();
     /**
      * Get the global number of timestamps put in cache
      */
 	public long getUpdateTimestampsCachePutCount();
 	/**
      * Get the global number of flush executed by sessions (either implicit or explicit)
      */
 	public long getFlushCount();
 	/**
 	 * Get the global number of connections asked by the sessions
      * (the actual number of connections used may be much smaller depending
      * whether you use a connection pool or not)
 	 */
 	public long getConnectCount();
 	/**
      * Global number of cacheable entities/collections successfully retrieved from the cache
      */
 	public long getSecondLevelCacheHitCount();
 	/**
      * Global number of cacheable entities/collections not found in the cache and loaded from the database.
      */
 	public long getSecondLevelCacheMissCount();
 	/**
 	 * Global number of cacheable entities/collections put in the cache
 	 */
 	public long getSecondLevelCachePutCount();
 	/**
 	 * Global number of sessions closed
 	 */
 	public long getSessionCloseCount();
 	/**
 	 * Global number of sessions opened
 	 */
 	public long getSessionOpenCount();
 	/**
 	 * Global number of collections loaded
 	 */
 	public long getCollectionLoadCount();
 	/**
 	 * Global number of collections fetched
 	 */
 	public long getCollectionFetchCount();
 	/**
 	 * Global number of collections updated
 	 */
 	public long getCollectionUpdateCount();
 	/**
 	 * Global number of collections removed
 	 */
     //even on inverse="true"
 	public long getCollectionRemoveCount();
 	/**
 	 * Global number of collections recreated
 	 */
 	public long getCollectionRecreateCount();
 	/**
 	 * @return start time in ms (JVM standards {@link System#currentTimeMillis()})
 	 */
 	public long getStartTime();
 	/**
 	 * log in info level the main statistics
 	 */
 	public void logSummary();
 	/**
 	 * Are statistics logged
 	 */
 	public boolean isStatisticsEnabled();
 	/**
 	 * Enable statistics logs (this is a dynamic parameter)
 	 */
 	public void setStatisticsEnabled(boolean b);
 
 	/**
 	 * Get all executed query strings
 	 */
 	public String[] getQueries();
 	/**
 	 * Get the names of all entities
 	 */
 	public String[] getEntityNames();
 	/**
 	 * Get the names of all collection roles
 	 */
 	public String[] getCollectionRoleNames();
 	/**
 	 * Get all second-level cache region names
 	 */
 	public String[] getSecondLevelCacheRegionNames();
 	/**
 	 * The number of transactions we know to have been successful
 	 */
 	public long getSuccessfulTransactionCount();
 	/**
 	 * The number of transactions we know to have completed
 	 */
 	public long getTransactionCount();
 	/**
 	 * The number of prepared statements that were acquired
 	 */
 	public long getPrepareStatementCount();
 	/**
 	 * The number of prepared statements that were released
 	 */
 	public long getCloseStatementCount();
 	/**
 	 * The number of <tt>StaleObjectStateException</tt>s 
 	 * that occurred
 	 */
 	public long getOptimisticFailureCount();
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/stat/internal/ConcurrentStatisticsImpl.java b/hibernate-core/src/main/java/org/hibernate/stat/internal/ConcurrentStatisticsImpl.java
index e89e7c0384..7cc8b01e1e 100644
--- a/hibernate-core/src/main/java/org/hibernate/stat/internal/ConcurrentStatisticsImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/stat/internal/ConcurrentStatisticsImpl.java
@@ -1,880 +1,907 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.stat.internal;
 
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.cache.spi.Region;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.service.Service;
 import org.hibernate.stat.CollectionStatistics;
 import org.hibernate.stat.EntityStatistics;
 import org.hibernate.stat.NaturalIdCacheStatistics;
 import org.hibernate.stat.QueryStatistics;
 import org.hibernate.stat.SecondLevelCacheStatistics;
 import org.hibernate.stat.spi.StatisticsImplementor;
 
 /**
  * Implementation of {@link org.hibernate.stat.Statistics} based on the {@link java.util.concurrent} package.
  *
  * @author Alex Snaps
  */
 @SuppressWarnings({ "unchecked" })
 public class ConcurrentStatisticsImpl implements StatisticsImplementor, Service {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, ConcurrentStatisticsImpl.class.getName());
 
 	private SessionFactoryImplementor sessionFactory;
 
 	private volatile boolean isStatisticsEnabled;
 	private volatile long startTime;
 	private AtomicLong sessionOpenCount = new AtomicLong();
 	private AtomicLong sessionCloseCount = new AtomicLong();
 	private AtomicLong flushCount = new AtomicLong();
 	private AtomicLong connectCount = new AtomicLong();
 
 	private AtomicLong prepareStatementCount = new AtomicLong();
 	private AtomicLong closeStatementCount = new AtomicLong();
 
 	private AtomicLong entityLoadCount = new AtomicLong();
 	private AtomicLong entityUpdateCount = new AtomicLong();
 	private AtomicLong entityInsertCount = new AtomicLong();
 	private AtomicLong entityDeleteCount = new AtomicLong();
 	private AtomicLong entityFetchCount = new AtomicLong();
 	private AtomicLong collectionLoadCount = new AtomicLong();
 	private AtomicLong collectionUpdateCount = new AtomicLong();
 	private AtomicLong collectionRemoveCount = new AtomicLong();
 	private AtomicLong collectionRecreateCount = new AtomicLong();
 	private AtomicLong collectionFetchCount = new AtomicLong();
 
 	private AtomicLong secondLevelCacheHitCount = new AtomicLong();
 	private AtomicLong secondLevelCacheMissCount = new AtomicLong();
 	private AtomicLong secondLevelCachePutCount = new AtomicLong();
 	
 	private AtomicLong naturalIdCacheHitCount = new AtomicLong();
 	private AtomicLong naturalIdCacheMissCount = new AtomicLong();
 	private AtomicLong naturalIdCachePutCount = new AtomicLong();
 	private AtomicLong naturalIdQueryExecutionCount = new AtomicLong();
 	private AtomicLong naturalIdQueryExecutionMaxTime = new AtomicLong();
 	private volatile String naturalIdQueryExecutionMaxTimeRegion;
 	
 	private AtomicLong queryExecutionCount = new AtomicLong();
 	private AtomicLong queryExecutionMaxTime = new AtomicLong();
 	private volatile String queryExecutionMaxTimeQueryString;
 	private AtomicLong queryCacheHitCount = new AtomicLong();
 	private AtomicLong queryCacheMissCount = new AtomicLong();
 	private AtomicLong queryCachePutCount = new AtomicLong();
 
 	private AtomicLong updateTimestampsCacheHitCount = new AtomicLong();
 	private AtomicLong updateTimestampsCacheMissCount = new AtomicLong();
 	private AtomicLong updateTimestampsCachePutCount = new AtomicLong();
 
 	private AtomicLong committedTransactionCount = new AtomicLong();
 	private AtomicLong transactionCount = new AtomicLong();
 
 	private AtomicLong optimisticFailureCount = new AtomicLong();
 
 	/**
 	 * natural id cache statistics per region
 	 */
 	private final ConcurrentMap naturalIdCacheStatistics = new ConcurrentHashMap();
 	/**
 	 * second level cache statistics per region
 	 */
 	private final ConcurrentMap secondLevelCacheStatistics = new ConcurrentHashMap();
 	/**
 	 * entity statistics per name
 	 */
 	private final ConcurrentMap entityStatistics = new ConcurrentHashMap();
 	/**
 	 * collection statistics per name
 	 */
 	private final ConcurrentMap collectionStatistics = new ConcurrentHashMap();
 	/**
 	 * entity statistics per query string (HQL or SQL)
 	 */
 	private final ConcurrentMap queryStatistics = new ConcurrentHashMap();
 
 	@SuppressWarnings({ "UnusedDeclaration" })
 	public ConcurrentStatisticsImpl() {
 		clear();
 	}
 
 	public ConcurrentStatisticsImpl(SessionFactoryImplementor sessionFactory) {
 		clear();
 		this.sessionFactory = sessionFactory;
 	}
 
 	/**
 	 * reset all statistics
 	 */
 	public void clear() {
 		secondLevelCacheHitCount.set( 0 );
 		secondLevelCacheMissCount.set( 0 );
 		secondLevelCachePutCount.set( 0 );
 		
 		naturalIdCacheHitCount.set( 0 );
 		naturalIdCacheMissCount.set( 0 );
 		naturalIdCachePutCount.set( 0 );
 		naturalIdQueryExecutionCount.set( 0 );
 		naturalIdQueryExecutionMaxTime.set( 0 );
 		naturalIdQueryExecutionMaxTimeRegion = null;
 
 		sessionCloseCount.set( 0 );
 		sessionOpenCount.set( 0 );
 		flushCount.set( 0 );
 		connectCount.set( 0 );
 
 		prepareStatementCount.set( 0 );
 		closeStatementCount.set( 0 );
 
 		entityDeleteCount.set( 0 );
 		entityInsertCount.set( 0 );
 		entityUpdateCount.set( 0 );
 		entityLoadCount.set( 0 );
 		entityFetchCount.set( 0 );
 
 		collectionRemoveCount.set( 0 );
 		collectionUpdateCount.set( 0 );
 		collectionRecreateCount.set( 0 );
 		collectionLoadCount.set( 0 );
 		collectionFetchCount.set( 0 );
 
 		queryExecutionCount.set( 0 );
 		queryCacheHitCount.set( 0 );
 		queryExecutionMaxTime.set( 0 );
 		queryExecutionMaxTimeQueryString = null;
 		queryCacheMissCount.set( 0 );
 		queryCachePutCount.set( 0 );
 
 		updateTimestampsCacheMissCount.set( 0 );
 		updateTimestampsCacheHitCount.set( 0 );
 		updateTimestampsCachePutCount.set( 0 );
 
 		transactionCount.set( 0 );
 		committedTransactionCount.set( 0 );
 
 		optimisticFailureCount.set( 0 );
 
 		secondLevelCacheStatistics.clear();
 		entityStatistics.clear();
 		collectionStatistics.clear();
 		queryStatistics.clear();
 
 		startTime = System.currentTimeMillis();
 	}
 
 	public void openSession() {
 		sessionOpenCount.getAndIncrement();
 	}
 
 	public void closeSession() {
 		sessionCloseCount.getAndIncrement();
 	}
 
 	public void flush() {
 		flushCount.getAndIncrement();
 	}
 
 	public void connect() {
 		connectCount.getAndIncrement();
 	}
 
 	public void loadEntity(String entityName) {
 		entityLoadCount.getAndIncrement();
 		( (ConcurrentEntityStatisticsImpl) getEntityStatistics( entityName ) ).incrementLoadCount();
 	}
 
 	public void fetchEntity(String entityName) {
 		entityFetchCount.getAndIncrement();
 		( (ConcurrentEntityStatisticsImpl) getEntityStatistics( entityName ) ).incrementFetchCount();
 	}
 
 	/**
 	 * find entity statistics per name
 	 *
 	 * @param entityName entity name
 	 *
 	 * @return EntityStatistics object
 	 */
 	public EntityStatistics getEntityStatistics(String entityName) {
 		ConcurrentEntityStatisticsImpl es = (ConcurrentEntityStatisticsImpl) entityStatistics.get( entityName );
 		if ( es == null ) {
 			es = new ConcurrentEntityStatisticsImpl( entityName );
 			ConcurrentEntityStatisticsImpl previous;
 			if ( ( previous = (ConcurrentEntityStatisticsImpl) entityStatistics.putIfAbsent(
 					entityName, es
 			) ) != null ) {
 				es = previous;
 			}
 		}
 		return es;
 	}
 
 	public void updateEntity(String entityName) {
 		entityUpdateCount.getAndIncrement();
 		ConcurrentEntityStatisticsImpl es = (ConcurrentEntityStatisticsImpl) getEntityStatistics( entityName );
 		es.incrementUpdateCount();
 	}
 
 	public void insertEntity(String entityName) {
 		entityInsertCount.getAndIncrement();
 		ConcurrentEntityStatisticsImpl es = (ConcurrentEntityStatisticsImpl) getEntityStatistics( entityName );
 		es.incrementInsertCount();
 	}
 
 	public void deleteEntity(String entityName) {
 		entityDeleteCount.getAndIncrement();
 		ConcurrentEntityStatisticsImpl es = (ConcurrentEntityStatisticsImpl) getEntityStatistics( entityName );
 		es.incrementDeleteCount();
 	}
 
 	/**
 	 * Get collection statistics per role
 	 *
 	 * @param role collection role
 	 *
 	 * @return CollectionStatistics
 	 */
 	public CollectionStatistics getCollectionStatistics(String role) {
 		ConcurrentCollectionStatisticsImpl cs = (ConcurrentCollectionStatisticsImpl) collectionStatistics.get( role );
 		if ( cs == null ) {
 			cs = new ConcurrentCollectionStatisticsImpl( role );
 			ConcurrentCollectionStatisticsImpl previous;
 			if ( ( previous = (ConcurrentCollectionStatisticsImpl) collectionStatistics.putIfAbsent(
 					role, cs
 			) ) != null ) {
 				cs = previous;
 			}
 		}
 		return cs;
 	}
 
 	public void loadCollection(String role) {
 		collectionLoadCount.getAndIncrement();
 		( (ConcurrentCollectionStatisticsImpl) getCollectionStatistics( role ) ).incrementLoadCount();
 	}
 
 	public void fetchCollection(String role) {
 		collectionFetchCount.getAndIncrement();
 		( (ConcurrentCollectionStatisticsImpl) getCollectionStatistics( role ) ).incrementFetchCount();
 	}
 
 	public void updateCollection(String role) {
 		collectionUpdateCount.getAndIncrement();
 		( (ConcurrentCollectionStatisticsImpl) getCollectionStatistics( role ) ).incrementUpdateCount();
 	}
 
 	public void recreateCollection(String role) {
 		collectionRecreateCount.getAndIncrement();
 		( (ConcurrentCollectionStatisticsImpl) getCollectionStatistics( role ) ).incrementRecreateCount();
 	}
 
 	public void removeCollection(String role) {
 		collectionRemoveCount.getAndIncrement();
 		( (ConcurrentCollectionStatisticsImpl) getCollectionStatistics( role ) ).incrementRemoveCount();
 	}
 	
 
 	@Override
 	public NaturalIdCacheStatistics getNaturalIdCacheStatistics(String regionName) {
 		ConcurrentNaturalIdCacheStatisticsImpl nics =
 				(ConcurrentNaturalIdCacheStatisticsImpl) naturalIdCacheStatistics.get( regionName );
 		
 		if ( nics == null ) {
 			if ( sessionFactory == null ) {
 				return null;
 			}
 			Region region = sessionFactory.getNaturalIdCacheRegion( regionName );
 			if ( region == null ) {
 				return null;
 			}
 			nics = new ConcurrentNaturalIdCacheStatisticsImpl( region );
 			ConcurrentNaturalIdCacheStatisticsImpl previous;
 			if ( ( previous = (ConcurrentNaturalIdCacheStatisticsImpl) naturalIdCacheStatistics.putIfAbsent(
 					regionName, nics
 			) ) != null ) {
 				nics = previous;
 			}
 		}
 		return nics;
 	}
 
 	/**
 	 * Second level cache statistics per region
 	 *
 	 * @param regionName region name
 	 *
 	 * @return SecondLevelCacheStatistics
 	 */
 	public SecondLevelCacheStatistics getSecondLevelCacheStatistics(String regionName) {
 		ConcurrentSecondLevelCacheStatisticsImpl slcs
 				= (ConcurrentSecondLevelCacheStatisticsImpl) secondLevelCacheStatistics.get( regionName );
 		if ( slcs == null ) {
 			if ( sessionFactory == null ) {
 				return null;
 			}
 			Region region = sessionFactory.getSecondLevelCacheRegion( regionName );
 			if ( region == null ) {
 				return null;
 			}
 			slcs = new ConcurrentSecondLevelCacheStatisticsImpl( region );
 			ConcurrentSecondLevelCacheStatisticsImpl previous;
 			if ( ( previous = (ConcurrentSecondLevelCacheStatisticsImpl) secondLevelCacheStatistics.putIfAbsent(
 					regionName, slcs
 			) ) != null ) {
 				slcs = previous;
 			}
 		}
 		return slcs;
 	}
 
 	public void secondLevelCachePut(String regionName) {
 		secondLevelCachePutCount.getAndIncrement();
 		( (ConcurrentSecondLevelCacheStatisticsImpl) getSecondLevelCacheStatistics( regionName ) ).incrementPutCount();
 	}
 
 	public void secondLevelCacheHit(String regionName) {
 		secondLevelCacheHitCount.getAndIncrement();
 		( (ConcurrentSecondLevelCacheStatisticsImpl) getSecondLevelCacheStatistics( regionName ) ).incrementHitCount();
 	}
 
 	public void secondLevelCacheMiss(String regionName) {
 		secondLevelCacheMissCount.getAndIncrement();
 		( (ConcurrentSecondLevelCacheStatisticsImpl) getSecondLevelCacheStatistics( regionName ) ).incrementMissCount();
 	}
 	
 	@Override
 	public void naturalIdCachePut(String regionName) {
 		naturalIdCachePutCount.getAndIncrement();
 		( (ConcurrentNaturalIdCacheStatisticsImpl) getNaturalIdCacheStatistics( regionName ) ).incrementPutCount();
 	}
 
 	@Override
 	public void naturalIdCacheHit(String regionName) {
 		naturalIdCacheHitCount.getAndIncrement();
 		( (ConcurrentNaturalIdCacheStatisticsImpl) getNaturalIdCacheStatistics( regionName ) ).incrementHitCount();
 	}
 
 	@Override
 	public void naturalIdCacheMiss(String regionName) {
 		naturalIdCacheMissCount.getAndIncrement();
 		( (ConcurrentNaturalIdCacheStatisticsImpl) getNaturalIdCacheStatistics( regionName ) ).incrementMissCount();
 	}
 	
 	@Override
 	public void naturalIdQueryExecuted(String regionName, long time) {
 		naturalIdQueryExecutionCount.getAndIncrement();
 		boolean isLongestQuery = false;
 		for ( long old = naturalIdQueryExecutionMaxTime.get();
 			  ( isLongestQuery = time > old ) && ( !naturalIdQueryExecutionMaxTime.compareAndSet( old, time ) );
 			  old = naturalIdQueryExecutionMaxTime.get() ) {
 			// nothing to do here given the odd loop structure...
 		}
 		if ( isLongestQuery && regionName != null ) {
 			naturalIdQueryExecutionMaxTimeRegion = regionName;
 		}
 		if ( regionName != null ) {
 			( (ConcurrentNaturalIdCacheStatisticsImpl) getNaturalIdCacheStatistics( regionName ) ).queryExecuted( time );
 		}
 	}
 
-	@SuppressWarnings({ "UnnecessaryBoxing" })
+	@Override
 	public void queryExecuted(String hql, int rows, long time) {
-        LOG.hql(hql, Long.valueOf(time), Long.valueOf(rows));
+        LOG.hql(hql, time, (long) rows );
 		queryExecutionCount.getAndIncrement();
 		boolean isLongestQuery = false;
 		for ( long old = queryExecutionMaxTime.get();
 			  ( isLongestQuery = time > old ) && ( !queryExecutionMaxTime.compareAndSet( old, time ) );
 			  old = queryExecutionMaxTime.get() ) {
 			// nothing to do here given the odd loop structure...
 		}
 		if ( isLongestQuery ) {
 			queryExecutionMaxTimeQueryString = hql;
 		}
 		if ( hql != null ) {
 			ConcurrentQueryStatisticsImpl qs = (ConcurrentQueryStatisticsImpl) getQueryStatistics( hql );
 			qs.executed( rows, time );
 		}
 	}
-
+	@Override
 	public void queryCacheHit(String hql, String regionName) {
 		queryCacheHitCount.getAndIncrement();
 		if ( hql != null ) {
 			ConcurrentQueryStatisticsImpl qs = (ConcurrentQueryStatisticsImpl) getQueryStatistics( hql );
 			qs.incrementCacheHitCount();
 		}
 		ConcurrentSecondLevelCacheStatisticsImpl slcs = (ConcurrentSecondLevelCacheStatisticsImpl) getSecondLevelCacheStatistics(
 				regionName
 		);
 		slcs.incrementHitCount();
 	}
-
+	@Override
 	public void queryCacheMiss(String hql, String regionName) {
 		queryCacheMissCount.getAndIncrement();
 		if ( hql != null ) {
 			ConcurrentQueryStatisticsImpl qs = (ConcurrentQueryStatisticsImpl) getQueryStatistics( hql );
 			qs.incrementCacheMissCount();
 		}
 		ConcurrentSecondLevelCacheStatisticsImpl slcs = (ConcurrentSecondLevelCacheStatisticsImpl) getSecondLevelCacheStatistics(
 				regionName
 		);
 		slcs.incrementMissCount();
 	}
-
+	@Override
 	public void queryCachePut(String hql, String regionName) {
 		queryCachePutCount.getAndIncrement();
 		if ( hql != null ) {
 			ConcurrentQueryStatisticsImpl qs = (ConcurrentQueryStatisticsImpl) getQueryStatistics( hql );
 			qs.incrementCachePutCount();
 		}
 		ConcurrentSecondLevelCacheStatisticsImpl slcs = (ConcurrentSecondLevelCacheStatisticsImpl) getSecondLevelCacheStatistics(
 				regionName
 		);
 		slcs.incrementPutCount();
 	}
 
 	@Override
 	public void updateTimestampsCacheHit() {
 		updateTimestampsCacheHitCount.getAndIncrement();
 	}
 
 	@Override
 	public void updateTimestampsCacheMiss() {
 		updateTimestampsCacheMissCount.getAndIncrement();
 	}
 
 	@Override
 	public void updateTimestampsCachePut() {
 		updateTimestampsCachePutCount.getAndIncrement();
 	}
 
 	/**
 	 * Query statistics from query string (HQL or SQL)
 	 *
 	 * @param queryString query string
 	 *
 	 * @return QueryStatistics
 	 */
+	@Override
 	public QueryStatistics getQueryStatistics(String queryString) {
 		ConcurrentQueryStatisticsImpl qs = (ConcurrentQueryStatisticsImpl) queryStatistics.get( queryString );
 		if ( qs == null ) {
 			qs = new ConcurrentQueryStatisticsImpl( queryString );
 			ConcurrentQueryStatisticsImpl previous;
 			if ( ( previous = (ConcurrentQueryStatisticsImpl) queryStatistics.putIfAbsent(
 					queryString, qs
 			) ) != null ) {
 				qs = previous;
 			}
 		}
 		return qs;
 	}
 
 	/**
 	 * @return entity deletion count
 	 */
+	@Override
 	public long getEntityDeleteCount() {
 		return entityDeleteCount.get();
 	}
 
 	/**
 	 * @return entity insertion count
 	 */
+	@Override
 	public long getEntityInsertCount() {
 		return entityInsertCount.get();
 	}
 
 	/**
 	 * @return entity load (from DB)
 	 */
+	@Override
 	public long getEntityLoadCount() {
 		return entityLoadCount.get();
 	}
 
 	/**
 	 * @return entity fetch (from DB)
 	 */
+	@Override
 	public long getEntityFetchCount() {
 		return entityFetchCount.get();
 	}
 
 	/**
 	 * @return entity update
 	 */
+	@Override
 	public long getEntityUpdateCount() {
 		return entityUpdateCount.get();
 	}
-
+	@Override
 	public long getQueryExecutionCount() {
 		return queryExecutionCount.get();
 	}
-
+	@Override
 	public long getQueryCacheHitCount() {
 		return queryCacheHitCount.get();
 	}
-
+	@Override
 	public long getQueryCacheMissCount() {
 		return queryCacheMissCount.get();
 	}
-
+	@Override
 	public long getQueryCachePutCount() {
 		return queryCachePutCount.get();
 	}
-
+	@Override
 	public long getUpdateTimestampsCacheHitCount() {
 		return updateTimestampsCacheHitCount.get();
 	}
-
+	@Override
 	public long getUpdateTimestampsCacheMissCount() {
 		return updateTimestampsCacheMissCount.get();
 	}
-
+	@Override
 	public long getUpdateTimestampsCachePutCount() {
 		return updateTimestampsCachePutCount.get();
 	}
 
 	/**
 	 * @return flush
 	 */
+	@Override
 	public long getFlushCount() {
 		return flushCount.get();
 	}
 
 	/**
 	 * @return session connect
 	 */
+	@Override
 	public long getConnectCount() {
 		return connectCount.get();
 	}
 
 	/**
 	 * @return second level cache hit
 	 */
+	@Override
 	public long getSecondLevelCacheHitCount() {
 		return secondLevelCacheHitCount.get();
 	}
 
 	/**
 	 * @return second level cache miss
 	 */
+	@Override
 	public long getSecondLevelCacheMissCount() {
 		return secondLevelCacheMissCount.get();
 	}
 
 	/**
 	 * @return second level cache put
 	 */
+	@Override
 	public long getSecondLevelCachePutCount() {
 		return secondLevelCachePutCount.get();
 	}
 
 	@Override
 	public long getNaturalIdQueryExecutionCount() {
 		return naturalIdQueryExecutionCount.get();
 	}
 
 	@Override
 	public long getNaturalIdQueryExecutionMaxTime() {
 		return naturalIdQueryExecutionMaxTime.get();
 	}
 	
 	@Override
 	public String getNaturalIdQueryExecutionMaxTimeRegion() {
 		return naturalIdQueryExecutionMaxTimeRegion;
 	}
 	
 	@Override
 	public long getNaturalIdCacheHitCount() {
 		return naturalIdCacheHitCount.get();
 	}
 
 	@Override
 	public long getNaturalIdCacheMissCount() {
 		return naturalIdCacheMissCount.get();
 	}
 
 	@Override
 	public long getNaturalIdCachePutCount() {
 		return naturalIdCachePutCount.get();
 	}
 
 	/**
 	 * @return session closing
 	 */
+	@Override
 	public long getSessionCloseCount() {
 		return sessionCloseCount.get();
 	}
 
 	/**
 	 * @return session opening
 	 */
+	@Override
 	public long getSessionOpenCount() {
 		return sessionOpenCount.get();
 	}
 
 	/**
 	 * @return collection loading (from DB)
 	 */
+	@Override
 	public long getCollectionLoadCount() {
 		return collectionLoadCount.get();
 	}
 
 	/**
 	 * @return collection fetching (from DB)
 	 */
+	@Override
 	public long getCollectionFetchCount() {
 		return collectionFetchCount.get();
 	}
 
 	/**
 	 * @return collection update
 	 */
+	@Override
 	public long getCollectionUpdateCount() {
 		return collectionUpdateCount.get();
 	}
 
 	/**
 	 * @return collection removal
 	 *         FIXME: even if isInverse="true"?
 	 */
+	@Override
 	public long getCollectionRemoveCount() {
 		return collectionRemoveCount.get();
 	}
 
 	/**
 	 * @return collection recreation
 	 */
+	@Override
 	public long getCollectionRecreateCount() {
 		return collectionRecreateCount.get();
 	}
 
 	/**
 	 * @return start time in ms (JVM standards {@link System#currentTimeMillis()})
 	 */
+	@Override
 	public long getStartTime() {
 		return startTime;
 	}
 
 	/**
 	 * log in info level the main statistics
 	 */
+	@Override
 	public void logSummary() {
 		LOG.loggingStatistics();
 		LOG.startTime( startTime );
 		LOG.sessionsOpened( sessionOpenCount.get() );
 		LOG.sessionsClosed( sessionCloseCount.get() );
 		LOG.transactions( transactionCount.get() );
 		LOG.successfulTransactions( committedTransactionCount.get() );
 		LOG.optimisticLockFailures( optimisticFailureCount.get() );
 		LOG.flushes( flushCount.get() );
 		LOG.connectionsObtained( connectCount.get() );
 		LOG.statementsPrepared( prepareStatementCount.get() );
 		LOG.statementsClosed( closeStatementCount.get() );
 		LOG.secondLevelCachePuts( secondLevelCachePutCount.get() );
 		LOG.secondLevelCacheHits( secondLevelCacheHitCount.get() );
 		LOG.secondLevelCacheMisses( secondLevelCacheMissCount.get() );
 		LOG.entitiesLoaded( entityLoadCount.get() );
 		LOG.entitiesUpdated( entityUpdateCount.get() );
 		LOG.entitiesInserted( entityInsertCount.get() );
 		LOG.entitiesDeleted( entityDeleteCount.get() );
 		LOG.entitiesFetched( entityFetchCount.get() );
 		LOG.collectionsLoaded( collectionLoadCount.get() );
 		LOG.collectionsUpdated( collectionUpdateCount.get() );
 		LOG.collectionsRemoved( collectionRemoveCount.get() );
 		LOG.collectionsRecreated( collectionRecreateCount.get() );
 		LOG.collectionsFetched( collectionFetchCount.get() );
 		LOG.naturalIdCachePuts( naturalIdCachePutCount.get() );
 		LOG.naturalIdCacheHits( naturalIdCacheHitCount.get() );
 		LOG.naturalIdCacheMisses( naturalIdCacheMissCount.get() );
 		LOG.naturalIdMaxQueryTime( naturalIdQueryExecutionMaxTime.get() );
 		LOG.naturalIdQueriesExecuted( naturalIdQueryExecutionCount.get() );
 		LOG.queriesExecuted( queryExecutionCount.get() );
 		LOG.queryCachePuts( queryCachePutCount.get() );
 		LOG.timestampCachePuts( updateTimestampsCachePutCount.get() );
 		LOG.timestampCacheHits( updateTimestampsCacheHitCount.get() );
 		LOG.timestampCacheMisses( updateTimestampsCacheMissCount.get() );
 		LOG.queryCacheHits( queryCacheHitCount.get() );
 		LOG.queryCacheMisses( queryCacheMissCount.get() );
 		LOG.maxQueryTime( queryExecutionMaxTime.get() );
 	}
 
 	/**
 	 * Are statistics logged
 	 */
+	@Override
 	public boolean isStatisticsEnabled() {
 		return isStatisticsEnabled;
 	}
 
 	/**
 	 * Enable statistics logs (this is a dynamic parameter)
 	 */
+	@Override
 	public void setStatisticsEnabled(boolean b) {
 		isStatisticsEnabled = b;
 	}
 
 	/**
 	 * @return Returns the max query execution time,
 	 *         for all queries
 	 */
+	@Override
 	public long getQueryExecutionMaxTime() {
 		return queryExecutionMaxTime.get();
 	}
 
 	/**
 	 * Get all executed query strings
 	 */
+	@Override
 	public String[] getQueries() {
 		return ArrayHelper.toStringArray( queryStatistics.keySet() );
 	}
 
 	/**
 	 * Get the names of all entities
 	 */
+	@Override
 	public String[] getEntityNames() {
 		if ( sessionFactory == null ) {
 			return ArrayHelper.toStringArray( entityStatistics.keySet() );
 		}
 		else {
 			return ArrayHelper.toStringArray( sessionFactory.getAllClassMetadata().keySet() );
 		}
 	}
 
 	/**
 	 * Get the names of all collection roles
 	 */
+	@Override
 	public String[] getCollectionRoleNames() {
 		if ( sessionFactory == null ) {
 			return ArrayHelper.toStringArray( collectionStatistics.keySet() );
 		}
 		else {
 			return ArrayHelper.toStringArray( sessionFactory.getAllCollectionMetadata().keySet() );
 		}
 	}
 
 	/**
 	 * Get all second-level cache region names
 	 */
+	@Override
 	public String[] getSecondLevelCacheRegionNames() {
 		if ( sessionFactory == null ) {
 			return ArrayHelper.toStringArray( secondLevelCacheStatistics.keySet() );
 		}
 		else {
 			return ArrayHelper.toStringArray( sessionFactory.getAllSecondLevelCacheRegions().keySet() );
 		}
 	}
-
+	@Override
 	public void endTransaction(boolean success) {
 		transactionCount.getAndIncrement();
 		if ( success ) {
 			committedTransactionCount.getAndIncrement();
 		}
 	}
-
+	@Override
 	public long getSuccessfulTransactionCount() {
 		return committedTransactionCount.get();
 	}
-
+	@Override
 	public long getTransactionCount() {
 		return transactionCount.get();
 	}
-
+	@Override
 	public void closeStatement() {
 		closeStatementCount.getAndIncrement();
 	}
-
+	@Override
 	public void prepareStatement() {
 		prepareStatementCount.getAndIncrement();
 	}
-
+	@Override
 	public long getCloseStatementCount() {
 		return closeStatementCount.get();
 	}
-
+	@Override
 	public long getPrepareStatementCount() {
 		return prepareStatementCount.get();
 	}
-
+	@Override
 	public void optimisticFailure(String entityName) {
 		optimisticFailureCount.getAndIncrement();
 		( (ConcurrentEntityStatisticsImpl) getEntityStatistics( entityName ) ).incrementOptimisticFailureCount();
 	}
-
+	@Override
 	public long getOptimisticFailureCount() {
 		return optimisticFailureCount.get();
 	}
 
 	@Override
     public String toString() {
 		return new StringBuilder()
 				.append( "Statistics[" )
 				.append( "start time=" ).append( startTime )
 				.append( ",sessions opened=" ).append( sessionOpenCount )
 				.append( ",sessions closed=" ).append( sessionCloseCount )
 				.append( ",transactions=" ).append( transactionCount )
 				.append( ",successful transactions=" ).append( committedTransactionCount )
 				.append( ",optimistic lock failures=" ).append( optimisticFailureCount )
 				.append( ",flushes=" ).append( flushCount )
 				.append( ",connections obtained=" ).append( connectCount )
 				.append( ",statements prepared=" ).append( prepareStatementCount )
 				.append( ",statements closed=" ).append( closeStatementCount )
 				.append( ",second level cache puts=" ).append( secondLevelCachePutCount )
 				.append( ",second level cache hits=" ).append( secondLevelCacheHitCount )
 				.append( ",second level cache misses=" ).append( secondLevelCacheMissCount )
 				.append( ",entities loaded=" ).append( entityLoadCount )
 				.append( ",entities updated=" ).append( entityUpdateCount )
 				.append( ",entities inserted=" ).append( entityInsertCount )
 				.append( ",entities deleted=" ).append( entityDeleteCount )
 				.append( ",entities fetched=" ).append( entityFetchCount )
 				.append( ",collections loaded=" ).append( collectionLoadCount )
 				.append( ",collections updated=" ).append( collectionUpdateCount )
 				.append( ",collections removed=" ).append( collectionRemoveCount )
 				.append( ",collections recreated=" ).append( collectionRecreateCount )
 				.append( ",collections fetched=" ).append( collectionFetchCount )
 				.append( ",naturalId queries executed to database=" ).append( naturalIdQueryExecutionCount )
 				.append( ",naturalId cache puts=" ).append( naturalIdCachePutCount )
 				.append( ",naturalId cache hits=" ).append( naturalIdCacheHitCount )
 				.append( ",naturalId cache misses=" ).append( naturalIdCacheMissCount )
 				.append( ",naturalId max query time=" ).append( naturalIdQueryExecutionMaxTime )
 				.append( ",queries executed to database=" ).append( queryExecutionCount )
 				.append( ",query cache puts=" ).append( queryCachePutCount )
 				.append( ",query cache hits=" ).append( queryCacheHitCount )
 				.append( ",query cache misses=" ).append( queryCacheMissCount )
 				.append(",update timestamps cache puts=").append(updateTimestampsCachePutCount)
 				.append(",update timestamps cache hits=").append(updateTimestampsCacheHitCount)
 				.append(",update timestamps cache misses=").append(updateTimestampsCacheMissCount)
 				.append( ",max query time=" ).append( queryExecutionMaxTime )
 				.append( ']' )
 				.toString();
 	}
-
+	@Override
 	public String getQueryExecutionMaxTimeQueryString() {
 		return queryExecutionMaxTimeQueryString;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/stat/spi/StatisticsImplementor.java b/hibernate-core/src/main/java/org/hibernate/stat/spi/StatisticsImplementor.java
index 4373587f80..59b3f92ea8 100644
--- a/hibernate-core/src/main/java/org/hibernate/stat/spi/StatisticsImplementor.java
+++ b/hibernate-core/src/main/java/org/hibernate/stat/spi/StatisticsImplementor.java
@@ -1,252 +1,252 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.stat.spi;
 
 import org.hibernate.service.Service;
 import org.hibernate.stat.Statistics;
 
 /**
  * Statistics SPI for the Hibernate core.  This is essentially the "statistic collector" API, its the contract
  * called to collect various stats.
  * 
  * @author Emmanuel Bernard
  */
 public interface StatisticsImplementor extends Statistics, Service {
 	/**
 	 * Callback about a session being opened.
 	 */
 	public void openSession();
 
 	/**
 	 * Callback about a session being closed.
 	 */
 	public void closeSession();
 
 	/**
 	 * Callback about a flush occurring
 	 */
 	public void flush();
 
 	/**
 	 * Callback about a connection being obtained from {@link org.hibernate.engine.jdbc.connections.spi.ConnectionProvider}
 	 */
 	public void connect();
 
 	/**
 	 * Callback about a statement being prepared.
 	 */
 	public void prepareStatement();
 
 	/**
 	 * Callback about a statement being closed.
 	 */
 	public void closeStatement();
 
 	/**
 	 * Callback about a transaction completing.
 	 *
 	 * @param success Was the transaction successful?
 	 */
 	public void endTransaction(boolean success);
 
 	/**
 	 * Callback about an entity being loaded.  This might indicate a proxy or a fully initialized entity, but in either
 	 * case it means without a separate SQL query being needed.
 	 *
 	 * @param entityName The name of the entity loaded.
 	 */
 	public void loadEntity(String entityName);
 
 	/**
 	 * Callback about an entity being fetched.  Unlike {@link #loadEntity} this indicates a separate query being
 	 * performed.
 	 *
 	 * @param entityName The name of the entity fetched.
 	 */
 	public void fetchEntity(String entityName);
 
 	/**
 	 * Callback about an entity being updated.
 	 *
 	 * @param entityName The name of the entity updated.
 	 */
 	public void updateEntity(String entityName);
 
 	/**
 	 * Callback about an entity being inserted
 	 *
 	 * @param entityName The name of the entity inserted
 	 */
 	public void insertEntity(String entityName);
 
 	/**
 	 * Callback about an entity being deleted.
 	 *
 	 * @param entityName The name of the entity deleted.
 	 */
 	public void deleteEntity(String entityName);
 
 	/**
 	 * Callback about an optimistic lock failure on an entity
 	 *
 	 * @param entityName The name of the entity.
 	 */
 	public void optimisticFailure(String entityName);
 
 	/**
 	 * Callback about a collection loading.  This might indicate a lazy collection or an initialized collection being
 	 * created, but in either case it means without a separate SQL query being needed.
 	 *
 	 * @param role The collection role.
 	 */
 	public void loadCollection(String role);
 
 	/**
 	 * Callback to indicate a collection being fetched.  Unlike {@link #loadCollection}, this indicates a separate
 	 * query was needed.
 	 *
 	 * @param role The collection role.
 	 */
 	public void fetchCollection(String role);
 
 	/**
 	 * Callback indicating a collection was updated.
 	 *
 	 * @param role The collection role.
 	 */
 	public void updateCollection(String role);
 
 	/**
 	 * Callback indicating a collection recreation (full deletion + full (re-)insertion).
 	 *
 	 * @param role The collection role.
 	 */
 	public void recreateCollection(String role);
 
 	/**
 	 * Callback indicating a collection removal.
 	 *
 	 * @param role The collection role.
 	 */
 	public void removeCollection(String role);
 
 	/**
 	 * Callback indicating a put into second level cache.
 	 *
 	 * @param regionName The name of the cache region
 	 */
 	public void secondLevelCachePut(String regionName);
 
 	/**
 	 * Callback indicating a get from second level cache resulted in a hit.
 	 *
 	 * @param regionName The name of the cache region
 	 */
 	public void secondLevelCacheHit(String regionName);
 
 	/**
 	 * Callback indicating a get from second level cache resulted in a miss.
 	 *
 	 * @param regionName The name of the cache region
 	 */
 	public void secondLevelCacheMiss(String regionName);
 	
 	/**
 	 * Callback indicating a put into natural id cache.
 	 *
 	 * @param regionName The name of the cache region
 	 */
 	public void naturalIdCachePut(String regionName);
 	
 	/**
 	 * Callback indicating a get from natural id cache resulted in a hit.
 	 *
 	 * @param regionName The name of the cache region
 	 */
 	public void naturalIdCacheHit(String regionName);
 	
 	/**
 	 * Callback indicating a get from natural id cache resulted in a miss.
 	 *
 	 * @param regionName The name of the cache region
 	 */
 	public void naturalIdCacheMiss(String regionName);
 
 	/**
 	 * Callback indicating execution of a natural id query
 	 *
 	 * @param regionName The name of the cache region
 	 * @param time execution time
 	 */
 	public void naturalIdQueryExecuted(String regionName, long time);
 
 	/**
 	 * Callback indicating a put into the query cache.
 	 *
 	 * @param hql The query
 	 * @param regionName The cache region
 	 */
 	public void queryCachePut(String hql, String regionName);
 
 	/**
 	 * Callback indicating a get from the query cache resulted in a hit.
 	 *
 	 * @param hql The query
 	 * @param regionName The name of the cache region
 	 */
 	public void queryCacheHit(String hql, String regionName);
 
 	/**
 	 * Callback indicating a get from the query cache resulted in a miss.
 	 *
 	 * @param hql The query
 	 * @param regionName The name of the cache region
 	 */
 	public void queryCacheMiss(String hql, String regionName);
 
 	/**
 	 * Callback indicating execution of a sql/hql query
 	 *
 	 * @param hql The query
 	 * @param rows Number of rows returned
 	 * @param time execution time
 	 */
 	public void queryExecuted(String hql, int rows, long time);
 
 
 	/**
 	 * Callback indicating a hit to the timestamp cache
 	 */
 	public void updateTimestampsCacheHit();
 
 	/**
 	 * Callback indicating a miss to the timestamp cache
 	 */
 	public void updateTimestampsCacheMiss();
 
 	/**
 	 * Callback indicating a put to the timestamp cache
 	 */
 	public void updateTimestampsCachePut();
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/transform/AliasedTupleSubsetResultTransformer.java b/hibernate-core/src/main/java/org/hibernate/transform/AliasedTupleSubsetResultTransformer.java
index aeec27ee45..daadf88441 100644
--- a/hibernate-core/src/main/java/org/hibernate/transform/AliasedTupleSubsetResultTransformer.java
+++ b/hibernate-core/src/main/java/org/hibernate/transform/AliasedTupleSubsetResultTransformer.java
@@ -1,59 +1,59 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.transform;
 
 
 /**
  * An implementation of TupleSubsetResultTransformer that ignores a
  * tuple element if its corresponding alias is null.
  *
  * @author Gail Badner
  */
 public abstract class AliasedTupleSubsetResultTransformer
 		extends BasicTransformerAdapter
 		implements TupleSubsetResultTransformer {
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public boolean[] includeInTransform(String[] aliases, int tupleLength) {
 		if ( aliases == null ) {
 			throw new IllegalArgumentException( "aliases cannot be null" );
 		}
 		if ( aliases.length != tupleLength ) {
 			throw new IllegalArgumentException(
 					"aliases and tupleLength must have the same length; " +
 							"aliases.length=" + aliases.length + "tupleLength=" + tupleLength
 			);
 		}
 		boolean[] includeInTransform = new boolean[tupleLength];
 		for ( int i = 0 ; i < aliases.length ; i++ ) {
 			if ( aliases[ i ] != null ) {
 				includeInTransform[ i ] = true;
 			}
 		}
 		return includeInTransform;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/transform/TupleSubsetResultTransformer.java b/hibernate-core/src/main/java/org/hibernate/transform/TupleSubsetResultTransformer.java
index 4f6c0fb309..aebe2c77ce 100644
--- a/hibernate-core/src/main/java/org/hibernate/transform/TupleSubsetResultTransformer.java
+++ b/hibernate-core/src/main/java/org/hibernate/transform/TupleSubsetResultTransformer.java
@@ -1,85 +1,85 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.transform;
 
 
 /**
  * A ResultTransformer that operates on "well-defined" and consistent
  * subset of a tuple's elements.
  *
  * "Well-defined" means that:
  * <ol>
  *     <li>
  *         the indexes of tuple elements accessed by a
  *         TupleSubsetResultTransformer depends only on the aliases
  *         and the number of elements in the tuple; i.e, it does
  *         not depend on the value of the tuple being transformed;
  *     </li>
  *     <li>
  *         any tuple elements included in the transformed value are
  *         unmodified by the transformation;
  *     </li>
  *     <li>
  *         transforming equivalent tuples with the same aliases multiple
  *         times results in transformed values that are equivalent;
  *     </li>
  *     <li>
  *         the result of transforming the tuple subset (only those
  *         elements accessed by the transformer) using only the
  *         corresponding aliases is equivalent to transforming the
  *         full tuple with the full array of aliases;
  *     </li>
  *     <li>
  *         the result of transforming a tuple with non-accessed tuple
  *         elements and corresponding aliases set to null
  *         is equivalent to transforming the full tuple with the
  *         full array of aliases;
  *     </li>
  * </ol>
  *
  * @author Gail Badner
  */
 public interface TupleSubsetResultTransformer extends ResultTransformer {
 	/**
 	 * When a tuple is transformed, is the result a single element of the tuple?
 	 *
 	 * @param aliases - the aliases that correspond to the tuple
 	 * @param tupleLength - the number of elements in the tuple
 	 * @return true, if the transformed value is a single element of the tuple;
 	 *         false, otherwise.
 	 */
 	boolean isTransformedValueATupleElement(String[] aliases, int tupleLength);
 
 	/**
 	 * Returns an array with the i-th element indicating whether the i-th
 	 * element of the tuple is included in the transformed value.
 	 *
 	 * @param aliases - the aliases that correspond to the tuple
 	 * @param tupleLength - the number of elements in the tuple
 	 * @return array with the i-th element indicating whether the i-th
 	 *         element of the tuple is included in the transformed value.
 	 */
 	boolean[] includeInTransform(String[] aliases, int tupleLength);
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/Dom4jInstantiator.java b/hibernate-core/src/main/java/org/hibernate/tuple/Dom4jInstantiator.java
index a00c4bea5e..38d2d4d65c 100755
--- a/hibernate-core/src/main/java/org/hibernate/tuple/Dom4jInstantiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/Dom4jInstantiator.java
@@ -1,77 +1,77 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.tuple;
 import java.io.Serializable;
 import java.util.HashSet;
 import java.util.Iterator;
 
 import org.dom4j.Element;
 
 import org.hibernate.internal.util.xml.XMLHelper;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 
 /**
  * Performs "instantiation" based on DOM4J elements.
  */
 public class Dom4jInstantiator implements Instantiator {
 	private final String nodeName;
 	private final HashSet isInstanceNodeNames = new HashSet();
 
 	public Dom4jInstantiator(Component component) {
 		this.nodeName = component.getNodeName();
 		isInstanceNodeNames.add( nodeName );
 	}
 
 	public Dom4jInstantiator(PersistentClass mappingInfo) {
 		this.nodeName = mappingInfo.getNodeName();
 		isInstanceNodeNames.add( nodeName );
 
 		if ( mappingInfo.hasSubclasses() ) {
 			Iterator itr = mappingInfo.getSubclassClosureIterator();
 			while ( itr.hasNext() ) {
 				final PersistentClass subclassInfo = ( PersistentClass ) itr.next();
 				isInstanceNodeNames.add( subclassInfo.getNodeName() );
 			}
 		}
 	}
 	
 	public Object instantiate(Serializable id) {
 		return instantiate();
 	}
 	
 	public Object instantiate() {
 		return XMLHelper.generateDom4jElement( nodeName );
 	}
 
 	public boolean isInstance(Object object) {
 		if ( object instanceof Element ) {
 			return isInstanceNodeNames.contains( ( ( Element ) object ).getName() );
 		}
 		else {
 			return false;
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/DynamicMapInstantiator.java b/hibernate-core/src/main/java/org/hibernate/tuple/DynamicMapInstantiator.java
index 66627e064d..2b3b7ad8a2 100755
--- a/hibernate-core/src/main/java/org/hibernate/tuple/DynamicMapInstantiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/DynamicMapInstantiator.java
@@ -1,95 +1,95 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.tuple;
 import java.io.Serializable;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.metamodel.binding.EntityBinding;
 
 
 public class DynamicMapInstantiator implements Instantiator {
 	public static final String KEY = "$type$";
 
 	private String entityName;
 	private Set isInstanceEntityNames = new HashSet();
 
 	public DynamicMapInstantiator() {
 		this.entityName = null;
 	}
 
 	public DynamicMapInstantiator(PersistentClass mappingInfo) {
 		this.entityName = mappingInfo.getEntityName();
 		isInstanceEntityNames.add( entityName );
 		if ( mappingInfo.hasSubclasses() ) {
 			Iterator itr = mappingInfo.getSubclassClosureIterator();
 			while ( itr.hasNext() ) {
 				final PersistentClass subclassInfo = ( PersistentClass ) itr.next();
 				isInstanceEntityNames.add( subclassInfo.getEntityName() );
 			}
 		}
 	}
 
 	public DynamicMapInstantiator(EntityBinding mappingInfo) {
 		this.entityName = mappingInfo.getEntity().getName();
 		isInstanceEntityNames.add( entityName );
 		for ( EntityBinding subEntityBinding : mappingInfo.getPostOrderSubEntityBindingClosure() ) {
 			isInstanceEntityNames.add( subEntityBinding.getEntity().getName() );
 		}
 	}
 
 	public final Object instantiate(Serializable id) {
 		return instantiate();
 	}
 
 	public final Object instantiate() {
 		Map map = generateMap();
 		if ( entityName!=null ) {
 			map.put( KEY, entityName );
 		}
 		return map;
 	}
 
 	public final boolean isInstance(Object object) {
 		if ( object instanceof Map ) {
 			if ( entityName == null ) {
 				return true;
 			}
 			String type = ( String ) ( ( Map ) object ).get( KEY );
 			return type == null || isInstanceEntityNames.contains( type );
 		}
 		else {
 			return false;
 		}
 	}
 
 	protected Map generateMap() {
 		return new HashMap();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/PojoInstantiator.java b/hibernate-core/src/main/java/org/hibernate/tuple/PojoInstantiator.java
index 2e107733ac..dcd5669072 100755
--- a/hibernate-core/src/main/java/org/hibernate/tuple/PojoInstantiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/PojoInstantiator.java
@@ -1,143 +1,143 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.tuple;
 
 import java.io.IOException;
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.InstantiationException;
 import org.hibernate.PropertyNotFoundException;
 import org.hibernate.bytecode.spi.ReflectionOptimizer;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.metamodel.binding.EntityBinding;
 
 /**
  * Defines a POJO-based instantiator for use from the tuplizers.
  */
 public class PojoInstantiator implements Instantiator, Serializable {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, PojoInstantiator.class.getName());
 
 	private transient Constructor constructor;
 
 	private final Class mappedClass;
 	private final transient ReflectionOptimizer.InstantiationOptimizer optimizer;
 	private final boolean embeddedIdentifier;
 	private final Class proxyInterface;
 	private final boolean isAbstract;
 
 	public PojoInstantiator(Component component, ReflectionOptimizer.InstantiationOptimizer optimizer) {
 		this.mappedClass = component.getComponentClass();
 		this.isAbstract = ReflectHelper.isAbstractClass( mappedClass );
 		this.optimizer = optimizer;
 
 		this.proxyInterface = null;
 		this.embeddedIdentifier = false;
 
 		try {
 			constructor = ReflectHelper.getDefaultConstructor(mappedClass);
 		}
 		catch ( PropertyNotFoundException pnfe ) {
 			LOG.noDefaultConstructor(mappedClass.getName());
 			constructor = null;
 		}
 	}
 
 	public PojoInstantiator(PersistentClass persistentClass, ReflectionOptimizer.InstantiationOptimizer optimizer) {
 		this.mappedClass = persistentClass.getMappedClass();
 		this.isAbstract = ReflectHelper.isAbstractClass( mappedClass );
 		this.proxyInterface = persistentClass.getProxyInterface();
 		this.embeddedIdentifier = persistentClass.hasEmbeddedIdentifier();
 		this.optimizer = optimizer;
 
 		try {
 			constructor = ReflectHelper.getDefaultConstructor( mappedClass );
 		}
 		catch ( PropertyNotFoundException pnfe ) {
 			LOG.noDefaultConstructor(mappedClass.getName());
 			constructor = null;
 		}
 	}
 
 	public PojoInstantiator(EntityBinding entityBinding, ReflectionOptimizer.InstantiationOptimizer optimizer) {
 		this.mappedClass = entityBinding.getEntity().getClassReference();
 		this.isAbstract = ReflectHelper.isAbstractClass( mappedClass );
 		this.proxyInterface = entityBinding.getProxyInterfaceType().getValue();
 		this.embeddedIdentifier = entityBinding.getHierarchyDetails().getEntityIdentifier().isEmbedded();
 		this.optimizer = optimizer;
 
 		try {
 			constructor = ReflectHelper.getDefaultConstructor( mappedClass );
 		}
 		catch ( PropertyNotFoundException pnfe ) {
 			LOG.noDefaultConstructor(mappedClass.getName());
 			constructor = null;
 		}
 	}
 
 	private void readObject(java.io.ObjectInputStream stream)
 	throws ClassNotFoundException, IOException {
 		stream.defaultReadObject();
 		constructor = ReflectHelper.getDefaultConstructor( mappedClass );
 	}
 
 	public Object instantiate() {
 		if ( isAbstract ) {
 			throw new InstantiationException( "Cannot instantiate abstract class or interface: ", mappedClass );
 		}
 		else if ( optimizer != null ) {
 			return optimizer.newInstance();
 		}
 		else if ( constructor == null ) {
 			throw new InstantiationException( "No default constructor for entity: ", mappedClass );
 		}
 		else {
 			try {
 				return constructor.newInstance( (Object[]) null );
 			}
 			catch ( Exception e ) {
 				throw new InstantiationException( "Could not instantiate entity: ", mappedClass, e );
 			}
 		}
 	}
 
 	public Object instantiate(Serializable id) {
 		final boolean useEmbeddedIdentifierInstanceAsEntity = embeddedIdentifier &&
 				id != null &&
 				id.getClass().equals(mappedClass);
 		return useEmbeddedIdentifierInstanceAsEntity ? id : instantiate();
 	}
 
 	public boolean isInstance(Object object) {
 		return mappedClass.isInstance(object) ||
 				( proxyInterface!=null && proxyInterface.isInstance(object) ); //this one needed only for guessEntityMode()
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/component/ComponentTuplizerFactory.java b/hibernate-core/src/main/java/org/hibernate/tuple/component/ComponentTuplizerFactory.java
index 5910eb6b48..c912708b3a 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/component/ComponentTuplizerFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/component/ComponentTuplizerFactory.java
@@ -1,160 +1,160 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tuple.component;
 
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.mapping.Component;
 
 /**
  * A registry allowing users to define the default {@link ComponentTuplizer} class to use per {@link EntityMode}.
  *
  * @author Steve Ebersole
  */
 public class ComponentTuplizerFactory implements Serializable {
 	private static final Class[] COMPONENT_TUP_CTOR_SIG = new Class[] { Component.class };
 
 	private Map<EntityMode,Class<? extends ComponentTuplizer>> defaultImplClassByMode = buildBaseMapping();
 
 	/**
 	 * Method allowing registration of the tuplizer class to use as default for a particular entity-mode.
 	 *
 	 * @param entityMode The entity-mode for which to register the tuplizer class
 	 * @param tuplizerClass The class to use as the default tuplizer for the given entity-mode.
 	 */
 	@SuppressWarnings({ "UnusedDeclaration" })
 	public void registerDefaultTuplizerClass(EntityMode entityMode, Class<? extends ComponentTuplizer> tuplizerClass) {
 		assert isComponentTuplizerImplementor( tuplizerClass )
 				: "Specified tuplizer class [" + tuplizerClass.getName() + "] does not implement " + ComponentTuplizer.class.getName();
 		assert hasProperConstructor( tuplizerClass )
 				: "Specified tuplizer class [" + tuplizerClass.getName() + "] is not properly instantiatable";
 
 		defaultImplClassByMode.put( entityMode, tuplizerClass );
 	}
 
 	/**
 	 * Construct an instance of the given tuplizer class.
 	 *
 	 * @param tuplizerClassName The name of the tuplizer class to instantiate
 	 * @param metadata The metadata for the component.
 	 *
 	 * @return The instantiated tuplizer
 	 *
 	 * @throws HibernateException If class name cannot be resolved to a class reference, or if the
 	 * {@link Constructor#newInstance} call fails.
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public ComponentTuplizer constructTuplizer(String tuplizerClassName, Component metadata) {
 		try {
 			Class<? extends ComponentTuplizer> tuplizerClass = ReflectHelper.classForName( tuplizerClassName );
 			return constructTuplizer( tuplizerClass, metadata );
 		}
 		catch ( ClassNotFoundException e ) {
 			throw new HibernateException( "Could not locate specified tuplizer class [" + tuplizerClassName + "]" );
 		}
 	}
 
 	/**
 	 * Construct an instance of the given tuplizer class.
 	 *
 	 * @param tuplizerClass The tuplizer class to instantiate
 	 * @param metadata The metadata for the component.
 	 *
 	 * @return The instantiated tuplizer
 	 *
 	 * @throws HibernateException if the {@link java.lang.reflect.Constructor#newInstance} call fails.
 	 */
 	public ComponentTuplizer constructTuplizer(Class<? extends ComponentTuplizer> tuplizerClass, Component metadata) {
 		Constructor<? extends ComponentTuplizer> constructor = getProperConstructor( tuplizerClass );
 		assert constructor != null : "Unable to locate proper constructor for tuplizer [" + tuplizerClass.getName() + "]";
 		try {
 			return constructor.newInstance( metadata );
 		}
 		catch ( Throwable t ) {
 			throw new HibernateException( "Unable to instantiate default tuplizer [" + tuplizerClass.getName() + "]", t );
 		}
 	}
 
 	/**
 	 * Construct am instance of the default tuplizer for the given entity-mode.
 	 *
 	 * @param entityMode The entity mode for which to build a default tuplizer.
 	 * @param metadata The metadata for the component.
 	 *
 	 * @return The instantiated tuplizer
 	 *
 	 * @throws HibernateException If no default tuplizer found for that entity-mode; may be re-thrown from
 	 * {@link #constructTuplizer} too.
 	 */
 	public ComponentTuplizer constructDefaultTuplizer(EntityMode entityMode, Component metadata) {
 		Class<? extends ComponentTuplizer> tuplizerClass = defaultImplClassByMode.get( entityMode );
 		if ( tuplizerClass == null ) {
 			throw new HibernateException( "could not determine default tuplizer class to use [" + entityMode + "]" );
 		}
 
 		return constructTuplizer( tuplizerClass, metadata );
 	}
 
 	private boolean isComponentTuplizerImplementor(Class tuplizerClass) {
 		return ReflectHelper.implementsInterface( tuplizerClass, ComponentTuplizer.class );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private boolean hasProperConstructor(Class tuplizerClass) {
 		return getProperConstructor( tuplizerClass ) != null;
 	}
 
 	private Constructor<? extends ComponentTuplizer> getProperConstructor(Class<? extends ComponentTuplizer> clazz) {
 		Constructor<? extends ComponentTuplizer> constructor = null;
 		try {
 			constructor = clazz.getDeclaredConstructor( COMPONENT_TUP_CTOR_SIG );
 			if ( ! ReflectHelper.isPublic( constructor ) ) {
 				try {
 					// found a constructor, but it was not publicly accessible so try to request accessibility
 					constructor.setAccessible( true );
 				}
 				catch ( SecurityException e ) {
 					constructor = null;
 				}
 			}
 		}
 		catch ( NoSuchMethodException ignore ) {
 		}
 
 		return constructor;
 	}
 
 	private static Map<EntityMode,Class<? extends ComponentTuplizer>> buildBaseMapping() {
 		Map<EntityMode,Class<? extends ComponentTuplizer>> map = new ConcurrentHashMap<EntityMode,Class<? extends ComponentTuplizer>>();
 		map.put( EntityMode.POJO, PojoComponentTuplizer.class );
 		map.put( EntityMode.MAP, DynamicMapComponentTuplizer.class );
 		return map;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizer.java
index b652105468..229656949b 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/EntityTuplizer.java
@@ -1,305 +1,305 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.tuple.entity;
 import java.io.Serializable;
 import java.util.Map;
 
 import org.hibernate.EntityMode;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.property.Getter;
 import org.hibernate.tuple.Tuplizer;
 
 /**
  * Defines further responsibilities reagarding tuplization based on
  * a mapped entity.
  * <p/>
  * EntityTuplizer implementations should have the following constructor signatures:
  *      (org.hibernate.tuple.entity.EntityMetamodel, org.hibernate.mapping.PersistentClass)
  *      (org.hibernate.tuple.entity.EntityMetamodel, org.hibernate.metamodel.binding.EntityBinding)
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public interface EntityTuplizer extends Tuplizer {
 	/**
 	 * Return the entity-mode handled by this tuplizer instance.
 	 *
 	 * @return The entity-mode
 	 */
 	public EntityMode getEntityMode();
 
     /**
      * Create an entity instance initialized with the given identifier.
      *
      * @param id The identifier value for the entity to be instantiated.
      * @return The instantiated entity.
      * @throws HibernateException
 	 *
 	 * @deprecated Use {@link #instantiate(Serializable, SessionImplementor)} instead.
      */
 	@SuppressWarnings( {"JavaDoc"})
 	public Object instantiate(Serializable id) throws HibernateException;
 
     /**
      * Create an entity instance initialized with the given identifier.
      *
      * @param id The identifier value for the entity to be instantiated.
 	 * @param session The session from which is requests originates
 	 *
      * @return The instantiated entity.
      */
 	public Object instantiate(Serializable id, SessionImplementor session);
 
     /**
      * Extract the identifier value from the given entity.
      *
      * @param entity The entity from which to extract the identifier value.
 	 *
      * @return The identifier value.
 	 *
      * @throws HibernateException If the entity does not define an identifier property, or an
      * error occurs accessing its value.
 	 *
 	 * @deprecated Use {@link #getIdentifier(Object,SessionImplementor)} instead.
      */
 	public Serializable getIdentifier(Object entity) throws HibernateException;
 
     /**
      * Extract the identifier value from the given entity.
      *
      * @param entity The entity from which to extract the identifier value.
 	 * @param session The session from which is requests originates
 	 *
      * @return The identifier value.
      */
 	public Serializable getIdentifier(Object entity, SessionImplementor session);
 
     /**
      * Inject the identifier value into the given entity.
      * </p>
      * Has no effect if the entity does not define an identifier property
      *
      * @param entity The entity to inject with the identifier value.
      * @param id The value to be injected as the identifier.
 	 *
 	 * @deprecated Use {@link #setIdentifier(Object, Serializable, SessionImplementor)} instead.
      */
 	@SuppressWarnings( {"JavaDoc"})
 	public void setIdentifier(Object entity, Serializable id) throws HibernateException;
 
     /**
      * Inject the identifier value into the given entity.
      * </p>
      * Has no effect if the entity does not define an identifier property
      *
      * @param entity The entity to inject with the identifier value.
      * @param id The value to be injected as the identifier.
 	 * @param session The session from which is requests originates
      */
 	public void setIdentifier(Object entity, Serializable id, SessionImplementor session);
 
 	/**
 	 * Inject the given identifier and version into the entity, in order to
 	 * "roll back" to their original values.
 	 *
 	 * @param entity The entity for which to reset the id/version values
 	 * @param currentId The identifier value to inject into the entity.
 	 * @param currentVersion The version value to inject into the entity.
 	 *
 	 * @deprecated Use {@link #resetIdentifier(Object, Serializable, Object, SessionImplementor)} instead
 	 */
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion);
 
 	/**
 	 * Inject the given identifier and version into the entity, in order to
 	 * "roll back" to their original values.
 	 *
 	 * @param entity The entity for which to reset the id/version values
 	 * @param currentId The identifier value to inject into the entity.
 	 * @param currentVersion The version value to inject into the entity.
 	 * @param session The session from which the request originated
 	 */
 	public void resetIdentifier(Object entity, Serializable currentId, Object currentVersion, SessionImplementor session);
 
     /**
      * Extract the value of the version property from the given entity.
      *
      * @param entity The entity from which to extract the version value.
      * @return The value of the version property, or null if not versioned.
 	 * @throws HibernateException Indicates a problem accessing the version property
      */
 	public Object getVersion(Object entity) throws HibernateException;
 
 	/**
 	 * Inject the value of a particular property.
 	 *
 	 * @param entity The entity into which to inject the value.
 	 * @param i The property's index.
 	 * @param value The property value to inject.
 	 * @throws HibernateException Indicates a problem access the property
 	 */
 	public void setPropertyValue(Object entity, int i, Object value) throws HibernateException;
 
 	/**
 	 * Inject the value of a particular property.
 	 *
 	 * @param entity The entity into which to inject the value.
 	 * @param propertyName The name of the property.
 	 * @param value The property value to inject.
 	 * @throws HibernateException Indicates a problem access the property
 	 */
 	public void setPropertyValue(Object entity, String propertyName, Object value) throws HibernateException;
 
 	/**
 	 * Extract the values of the insertable properties of the entity (including backrefs)
 	 *
 	 * @param entity The entity from which to extract.
 	 * @param mergeMap a map of instances being merged to merged instances
 	 * @param session The session in which the resuest is being made.
 	 * @return The insertable property values.
 	 * @throws HibernateException Indicates a problem access the properties
 	 */
 	public Object[] getPropertyValuesToInsert(Object entity, Map mergeMap, SessionImplementor session)
 	throws HibernateException;
 
 	/**
 	 * Extract the value of a particular property from the given entity.
 	 *
 	 * @param entity The entity from which to extract the property value.
 	 * @param propertyName The name of the property for which to extract the value.
 	 * @return The current value of the given property on the given entity.
 	 * @throws HibernateException Indicates a problem access the property
 	 */
 	public Object getPropertyValue(Object entity, String propertyName) throws HibernateException;
 
     /**
      * Called just after the entities properties have been initialized.
      *
      * @param entity The entity being initialized.
      * @param lazyPropertiesAreUnfetched Are defined lazy properties currently unfecthed
      * @param session The session initializing this entity.
      */
 	public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session);
 
 	/**
 	 * Does this entity, for this mode, present a possibility for proxying?
 	 *
 	 * @return True if this tuplizer can generate proxies for this entity.
 	 */
 	public boolean hasProxy();
 
 	/**
 	 * Generates an appropriate proxy representation of this entity for this
 	 * entity-mode.
 	 *
 	 * @param id The id of the instance for which to generate a proxy.
 	 * @param session The session to which the proxy should be bound.
 	 * @return The generate proxies.
 	 * @throws HibernateException Indicates an error generating the proxy.
 	 */
 	public Object createProxy(Serializable id, SessionImplementor session) throws HibernateException;
 
 	/**
 	 * Does the {@link #getMappedClass() class} managed by this tuplizer implement
 	 * the {@link org.hibernate.classic.Lifecycle} interface.
 	 *
 	 * @return True if the Lifecycle interface is implemented; false otherwise.
 	 */
 	public boolean isLifecycleImplementor();
 
 	/**
 	 * Returns the java class to which generated proxies will be typed.
 	 * <p/>
 	 * todo : look at fully encapsulating {@link org.hibernate.engine.spi.PersistenceContext#narrowProxy} here,
 	 * since that is the only external use of this method
 	 *
 	 * @return The java class to which generated proxies will be typed
 	 */
 	public Class getConcreteProxyClass();
 	
     /**
      * Does the given entity instance have any currently uninitialized lazy properties?
      *
      * @param entity The entity to be check for uninitialized lazy properties.
      * @return True if uninitialized lazy properties were found; false otherwise.
      */
 	public boolean hasUninitializedLazyProperties(Object entity);
 	
 	/**
 	 * Is it an instrumented POJO?
 	 *
 	 * @return {@code true} if the entity class is instrumented; {@code false} otherwise.
 	 */
 	public boolean isInstrumented();
 
 	/**
 	 * Get any {@link EntityNameResolver EntityNameResolvers} associated with this {@link Tuplizer}.
 	 *
 	 * @return The associated resolvers.  May be null or empty.
 	 */
 	public EntityNameResolver[] getEntityNameResolvers();
 
 	/**
 	 * Given an entity instance, determine the most appropriate (most targeted) entity-name which represents it.
 	 * This is called in situations where we already know an entity name for the given entityInstance; we are being
 	 * asked to determine if there is a more appropriate entity-name to use, specifically within an inheritence
 	 * hierarchy.
 	 * <p/>
 	 * For example, consider a case where a user calls <tt>session.update( "Animal", cat );</tt>.  Here, the
 	 * user has explicitly provided <tt>Animal</tt> as the entity-name.  However, they have passed in an instance
 	 * of <tt>Cat</tt> which is a subclass of <tt>Animal</tt>.  In this case, we would return <tt>Cat</tt> as the
 	 * entity-name.
 	 * <p/>
 	 * <tt>null</tt> may be returned from calls to this method.  The meaining of <tt>null</tt> in that case is assumed
 	 * to be that we should use whatever explicit entity-name the user provided (<tt>Animal</tt> rather than <tt>Cat</tt>
 	 * in the example above).
 	 *
 	 * @param entityInstance The entity instance.
 	 * @param factory Reference to the SessionFactory.
 	 *
 	 * @return The most appropriate entity name to use.
 	 *
 	 * @throws HibernateException If we are unable to determine an entity-name within the inheritence hierarchy.
 	 */
 	public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory);
 
 	/**
 	 * Retrieve the getter for the identifier property.  May return null.
 	 *
 	 * @return The getter for the identifier property.
 	 */
 	public Getter getIdentifierGetter();
 
 	/**
 	 * Retrieve the getter for the version property.  May return null.
 	 *
 	 * @return The getter for the version property.
 	 */
 	public Getter getVersionGetter();
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/type/AbstractLongBinaryType.java b/hibernate-core/src/main/java/org/hibernate/type/AbstractLongBinaryType.java
index 197dbc0143..1c6927fc19 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/AbstractLongBinaryType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/AbstractLongBinaryType.java
@@ -1,47 +1,47 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 
 /**
  * An abstract type for mapping long binary SQL types to Java byte[].
  *
  * @author Gail Badner
  *
  * @deprecated Use the {@link AbstractStandardBasicType} approach instead
  */
 public abstract class AbstractLongBinaryType extends AbstractBynaryType {
 
 	public Class getReturnedClass() {
 		return byte[].class;
 	}
 
 	protected Object toExternalFormat(byte[] bytes) {
 		return bytes;
 	}
 
 	protected byte[] toInternalFormat(Object bytes) {
 		return ( byte[] ) bytes;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/type/AbstractLongStringType.java b/hibernate-core/src/main/java/org/hibernate/type/AbstractLongStringType.java
index 9e46bd8162..0c4ec658a6 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/AbstractLongStringType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/AbstractLongStringType.java
@@ -1,94 +1,94 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.IOException;
 import java.io.Reader;
 import java.io.StringReader;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 import org.hibernate.HibernateException;
 
 /**
  * An abstract type for mapping long string SQL types to a Java String.
  * @author Gavin King, Bertrand Renuart (from TextType)
  *
  * @deprecated Use the {@link AbstractStandardBasicType} approach instead
  */
 public abstract class AbstractLongStringType extends ImmutableType {
 
 	public void set(PreparedStatement st, Object value, int index) throws HibernateException, SQLException {
 		String str = (String) value;
 		st.setCharacterStream( index, new StringReader(str), str.length() );
 	}
 
 	public Object get(ResultSet rs, String name) throws HibernateException, SQLException {
 
 			// Retrieve the value of the designated column in the current row of this
 			// ResultSet object as a java.io.Reader object
 			Reader charReader = rs.getCharacterStream(name);
 
 			// if the corresponding SQL value is NULL, the reader we got is NULL as well
 			if (charReader==null) return null;
 
 			// Fetch Reader content up to the end - and put characters in a StringBuilder
 			StringBuilder sb = new StringBuilder();
 			try {
 				char[] buffer = new char[2048];
 				while (true) {
 					int amountRead = charReader.read(buffer, 0, buffer.length);
 					if ( amountRead == -1 ) break;
 					sb.append(buffer, 0, amountRead);
 				}
 			}
 			catch (IOException ioe) {
 				throw new HibernateException( "IOException occurred reading text", ioe );
 			}
 			finally {
 				try {
 					charReader.close();
 				}
 				catch (IOException e) {
 					throw new HibernateException( "IOException occurred closing stream", e );
 				}
 			}
 
 			// Return StringBuilder content as a large String
 			return sb.toString();
 	}
 
 	public Class getReturnedClass() {
 		return String.class;
 	}
 
 	public String toString(Object val) {
 		return (String) val;
 	}
 	public Object fromStringValue(String xml) {
 		return xml;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/type/AbstractSingleColumnStandardBasicType.java b/hibernate-core/src/main/java/org/hibernate/type/AbstractSingleColumnStandardBasicType.java
index 64b6467684..88e69f7fcd 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/AbstractSingleColumnStandardBasicType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/AbstractSingleColumnStandardBasicType.java
@@ -1,59 +1,59 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.type.descriptor.java.JavaTypeDescriptor;
 import org.hibernate.type.descriptor.sql.SqlTypeDescriptor;
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractSingleColumnStandardBasicType<T>
 		extends AbstractStandardBasicType<T>
 		implements SingleColumnType<T> {
 
 	public AbstractSingleColumnStandardBasicType(SqlTypeDescriptor sqlTypeDescriptor, JavaTypeDescriptor<T> javaTypeDescriptor) {
 		super( sqlTypeDescriptor, javaTypeDescriptor );
 	}
 
 	@Override
 	public final int sqlType() {
 		return getSqlTypeDescriptor().getSqlType();
 	}
 
 	@Override
 	public final void nullSafeSet(PreparedStatement st, Object value, int index, boolean[] settable, SessionImplementor session)
 			throws HibernateException, SQLException {
 		if ( settable[0] ) {
 			nullSafeSet( st, value, index, session );
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/type/BigDecimalType.java b/hibernate-core/src/main/java/org/hibernate/type/BigDecimalType.java
index aa9279f2c6..86fd6173d2 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/BigDecimalType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/BigDecimalType.java
@@ -1,56 +1,56 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.math.BigDecimal;
 import java.sql.Types;
 
 import org.hibernate.type.descriptor.java.BigDecimalTypeDescriptor;
 import org.hibernate.type.descriptor.sql.NumericTypeDescriptor;
 
 /**
  * A type that maps between a {@link Types#NUMERIC NUMERIC} and {@link BigDecimal}.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class BigDecimalType extends AbstractSingleColumnStandardBasicType<BigDecimal> {
 	public static final BigDecimalType INSTANCE = new BigDecimalType();
 
 	public BigDecimalType() {
 		super( NumericTypeDescriptor.INSTANCE, BigDecimalTypeDescriptor.INSTANCE );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public String getName() {
 		return "big_decimal";
 	}
 
 	@Override
 	protected boolean registerUnderJavaType() {
 		return true;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/type/BooleanType.java b/hibernate-core/src/main/java/org/hibernate/type/BooleanType.java
index d568fa3f02..765a60f1b2 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/BooleanType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/BooleanType.java
@@ -1,81 +1,81 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.type.descriptor.java.BooleanTypeDescriptor;
 import org.hibernate.type.descriptor.sql.SqlTypeDescriptor;
 
 /**
  * A type that maps between {@link java.sql.Types#BOOLEAN BOOLEAN} and {@link Boolean}
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class BooleanType
 		extends AbstractSingleColumnStandardBasicType<Boolean>
 		implements PrimitiveType<Boolean>, DiscriminatorType<Boolean> {
 	public static final BooleanType INSTANCE = new BooleanType();
 
 	public BooleanType() {
 		this( org.hibernate.type.descriptor.sql.BooleanTypeDescriptor.INSTANCE, BooleanTypeDescriptor.INSTANCE );
 	}
 
 	protected BooleanType(SqlTypeDescriptor sqlTypeDescriptor, BooleanTypeDescriptor javaTypeDescriptor) {
 		super( sqlTypeDescriptor, javaTypeDescriptor );
 	}
-
+	@Override
 	public String getName() {
 		return "boolean";
 	}
 
 	@Override
 	public String[] getRegistrationKeys() {
 		return new String[] { getName(), boolean.class.getName(), Boolean.class.getName() };
 	}
-
+	@Override
 	public Class getPrimitiveClass() {
 		return boolean.class;
 	}
-
+	@Override
 	public Serializable getDefaultValue() {
 		return Boolean.FALSE;
 	}
-
+	@Override
 	public Boolean stringToObject(String string) {
 		return fromString( string );
 	}
 
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
+	@Override
 	public String objectToSQLString(Boolean value, Dialect dialect) {
-		return dialect.toBooleanValueString( value.booleanValue() );
+		return dialect.toBooleanValueString( value );
 	}
 }
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/type/ByteType.java b/hibernate-core/src/main/java/org/hibernate/type/ByteType.java
index 93847f0600..60aa975425 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/ByteType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/ByteType.java
@@ -1,94 +1,92 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.util.Comparator;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.type.descriptor.java.ByteTypeDescriptor;
 import org.hibernate.type.descriptor.sql.TinyIntTypeDescriptor;
 
 /**
  * A type that maps between {@link java.sql.Types#TINYINT TINYINT} and {@link Byte}
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
-@SuppressWarnings({ "UnnecessaryBoxing" })
 public class ByteType
 		extends AbstractSingleColumnStandardBasicType<Byte>
 		implements PrimitiveType<Byte>, DiscriminatorType<Byte>, VersionType<Byte> {
 
 	public static final ByteType INSTANCE = new ByteType();
 
-	private static final Byte ZERO = Byte.valueOf( (byte)0 );
+	private static final Byte ZERO = (byte) 0;
 
 	public ByteType() {
 		super( TinyIntTypeDescriptor.INSTANCE, ByteTypeDescriptor.INSTANCE );
 	}
-
+	@Override
 	public String getName() {
 		return "byte";
 	}
 
 	@Override
 	public String[] getRegistrationKeys() {
 		return new String[] { getName(), byte.class.getName(), Byte.class.getName() };
 	}
-
+	@Override
 	public Serializable getDefaultValue() {
 		return ZERO;
 	}
-
+	@Override
 	public Class getPrimitiveClass() {
 		return byte.class;
 	}
-
+	@Override
 	public String objectToSQLString(Byte value, Dialect dialect) {
 		return toString( value );
 	}
-
+	@Override
 	public Byte stringToObject(String xml) {
 		return fromString( xml );
 	}
-
+	@Override
 	public Byte fromStringValue(String xml) {
 		return fromString( xml );
 	}
-
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
+	@Override
 	public Byte next(Byte current, SessionImplementor session) {
-		return Byte.valueOf( (byte) ( current.byteValue() + 1 ) );
+		return (byte) ( current + 1 );
 	}
-
+	@Override
 	public Byte seed(SessionImplementor session) {
 		return ZERO;
 	}
-
+	@Override
 	public Comparator<Byte> getComparator() {
 		return getJavaTypeDescriptor().getComparator();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/DoubleType.java b/hibernate-core/src/main/java/org/hibernate/type/DoubleType.java
index 961aa41966..916eb5706b 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/DoubleType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/DoubleType.java
@@ -1,67 +1,66 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.type.descriptor.java.DoubleTypeDescriptor;
 
 /**
  * A type that maps between {@link java.sql.Types#DOUBLE DOUBLE} and {@link Double}
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class DoubleType extends AbstractSingleColumnStandardBasicType<Double> implements PrimitiveType<Double> {
 	public static final DoubleType INSTANCE = new DoubleType();
 
-	@SuppressWarnings({ "UnnecessaryBoxing" })
-	public static final Double ZERO = Double.valueOf( 0.0 );
+	public static final Double ZERO = 0.0;
 
 	public DoubleType() {
 		super( org.hibernate.type.descriptor.sql.DoubleTypeDescriptor.INSTANCE, DoubleTypeDescriptor.INSTANCE );
 	}
-
+	@Override
 	public String getName() {
 		return "double";
 	}
 
 	@Override
 	public String[] getRegistrationKeys() {
 		return new String[] { getName(), double.class.getName(), Double.class.getName() };
 	}
-
+	@Override
 	public Serializable getDefaultValue() {
 		return ZERO;
 	}
-
+	@Override
 	public Class getPrimitiveClass() {
 		return double.class;
 	}
-
+	@Override
 	public String objectToSQLString(Double value, Dialect dialect) throws Exception {
 		return toString( value );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/FloatType.java b/hibernate-core/src/main/java/org/hibernate/type/FloatType.java
index 089d554e25..30ccbc5e88 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/FloatType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/FloatType.java
@@ -1,72 +1,71 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.type.descriptor.java.FloatTypeDescriptor;
 
 /**
  * A type that maps between {@link java.sql.Types#FLOAT FLOAT} and {@link Float}
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class FloatType extends AbstractSingleColumnStandardBasicType<Float> implements PrimitiveType<Float> {
 	public static final FloatType INSTANCE = new FloatType();
 
-	@SuppressWarnings({ "UnnecessaryBoxing" })
-	public static final Float ZERO = Float.valueOf( 0.0f );
+	public static final Float ZERO = 0.0f;
 
 	public FloatType() {
 		super( org.hibernate.type.descriptor.sql.FloatTypeDescriptor.INSTANCE, FloatTypeDescriptor.INSTANCE );
 	}
-
+	@Override
 	public String getName() {
 		return "float";
 	}
 
 	@Override
 	public String[] getRegistrationKeys() {
 		return new String[] { getName(), float.class.getName(), Float.class.getName() };
 	}
-
+	@Override
 	public Serializable getDefaultValue() {
 		return ZERO;
 	}
-
+	@Override
 	public Class getPrimitiveClass() {
 		return float.class;
 	}
-
+	@Override
 	public String objectToSQLString(Float value, Dialect dialect) throws Exception {
 		return toString( value );
 	}
 }
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/type/IntegerType.java b/hibernate-core/src/main/java/org/hibernate/type/IntegerType.java
index 5a83d9b298..279f41d86a 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/IntegerType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/IntegerType.java
@@ -1,88 +1,86 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.util.Comparator;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.type.descriptor.java.IntegerTypeDescriptor;
 
 /**
  * A type that maps between {@link java.sql.Types#INTEGER INTEGER} and @link Integer}
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class IntegerType extends AbstractSingleColumnStandardBasicType<Integer>
 		implements PrimitiveType<Integer>, DiscriminatorType<Integer>, VersionType<Integer> {
 
 	public static final IntegerType INSTANCE = new IntegerType();
 
-	@SuppressWarnings({ "UnnecessaryBoxing" })
-	public static final Integer ZERO = Integer.valueOf( 0 );
+	public static final Integer ZERO = 0;
 
 	public IntegerType() {
 		super( org.hibernate.type.descriptor.sql.IntegerTypeDescriptor.INSTANCE, IntegerTypeDescriptor.INSTANCE );
 	}
-
+	@Override
 	public String getName() {
 		return "integer";
 	}
 
 	@Override
 	public String[] getRegistrationKeys() {
 		return new String[] { getName(), int.class.getName(), Integer.class.getName() };
 	}
-
+	@Override
 	public Serializable getDefaultValue() {
 		return ZERO;
 	}
-
+	@Override
 	public Class getPrimitiveClass() {
 		return int.class;
 	}
-
+	@Override
 	public String objectToSQLString(Integer value, Dialect dialect) throws Exception {
 		return toString( value );
 	}
-
+	@Override
 	public Integer stringToObject(String xml) {
 		return fromString( xml );
 	}
-
+	@Override
 	public Integer seed(SessionImplementor session) {
 		return ZERO;
 	}
-
-	@SuppressWarnings({ "UnnecessaryBoxing", "UnnecessaryUnboxing" })
+	@Override
 	public Integer next(Integer current, SessionImplementor session) {
 		return current+1;
 	}
-
+	@Override
 	public Comparator<Integer> getComparator() {
 		return getJavaTypeDescriptor().getComparator();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/LongType.java b/hibernate-core/src/main/java/org/hibernate/type/LongType.java
index f0e526f48b..4ce675a82f 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/LongType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/LongType.java
@@ -1,90 +1,88 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.util.Comparator;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.type.descriptor.java.LongTypeDescriptor;
 import org.hibernate.type.descriptor.sql.BigIntTypeDescriptor;
 
 /**
  * A type that maps between {@link java.sql.Types#BIGINT BIGINT} and {@link Long}
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class LongType
 		extends AbstractSingleColumnStandardBasicType<Long>
 		implements PrimitiveType<Long>, DiscriminatorType<Long>, VersionType<Long> {
 
 	public static final LongType INSTANCE = new LongType();
 
-	@SuppressWarnings({ "UnnecessaryBoxing" })
-	private static final Long ZERO = Long.valueOf( 0 );
+	private static final Long ZERO = (long) 0;
 
 	public LongType() {
 		super( BigIntTypeDescriptor.INSTANCE, LongTypeDescriptor.INSTANCE );
 	}
-
+	@Override
 	public String getName() {
 		return "long";
 	}
 
 	@Override
 	public String[] getRegistrationKeys() {
 		return new String[] { getName(), long.class.getName(), Long.class.getName() };
 	}
-
+	@Override
 	public Serializable getDefaultValue() {
 		return ZERO;
 	}
-
+	@Override
 	public Class getPrimitiveClass() {
 		return long.class;
 	}
-
+	@Override
 	public Long stringToObject(String xml) throws Exception {
 		return Long.valueOf( xml );
 	}
-
-	@SuppressWarnings({ "UnnecessaryBoxing", "UnnecessaryUnboxing" })
+	@Override
 	public Long next(Long current, SessionImplementor session) {
 		return current + 1l;
 	}
-
+	@Override
 	public Long seed(SessionImplementor session) {
 		return ZERO;
 	}
-
+	@Override
 	public Comparator<Long> getComparator() {
 		return getJavaTypeDescriptor().getComparator();
 	}
-	
+	@Override
 	public String objectToSQLString(Long value, Dialect dialect) throws Exception {
 		return value.toString();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/MaterializedClobType.java b/hibernate-core/src/main/java/org/hibernate/type/MaterializedClobType.java
index 569c5e0c60..bfb002291c 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/MaterializedClobType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/MaterializedClobType.java
@@ -1,45 +1,45 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 import org.hibernate.type.descriptor.java.StringTypeDescriptor;
 import org.hibernate.type.descriptor.sql.ClobTypeDescriptor;
 
 /**
  * A type that maps between {@link java.sql.Types#CLOB CLOB} and {@link String}
  *
  * @author Gavin King
  * @author Gail Badner
  * @author Steve Ebersole
  */
 public class MaterializedClobType extends AbstractSingleColumnStandardBasicType<String> {
 	public static final MaterializedClobType INSTANCE = new MaterializedClobType();
 
 	public MaterializedClobType() {
 		super( ClobTypeDescriptor.DEFAULT, StringTypeDescriptor.INSTANCE );
 	}
 
 	public String getName() {
 		return "materialized_clob";
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/type/MaterializedNClobType.java b/hibernate-core/src/main/java/org/hibernate/type/MaterializedNClobType.java
index 4a6de4ecd0..d558cf62a8 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/MaterializedNClobType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/MaterializedNClobType.java
@@ -1,46 +1,46 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import org.hibernate.type.descriptor.java.StringTypeDescriptor;
 import org.hibernate.type.descriptor.sql.NClobTypeDescriptor;
 
 /**
  * A type that maps between {@link java.sql.Types#CLOB CLOB} and {@link String}
  *
  * @author Gavin King
  * @author Gail Badner
  * @author Steve Ebersole
  */
 public class MaterializedNClobType extends AbstractSingleColumnStandardBasicType<String> {
 	public static final MaterializedNClobType INSTANCE = new MaterializedNClobType();
 
 	public MaterializedNClobType() {
 		super( NClobTypeDescriptor.DEFAULT, StringTypeDescriptor.INSTANCE );
 	}
 
 	public String getName() {
 		return "materialized_nclob";
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/type/NumericBooleanType.java b/hibernate-core/src/main/java/org/hibernate/type/NumericBooleanType.java
index 83397a198a..261bff0b3d 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/NumericBooleanType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/NumericBooleanType.java
@@ -1,67 +1,66 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.type.descriptor.java.BooleanTypeDescriptor;
 import org.hibernate.type.descriptor.sql.IntegerTypeDescriptor;
 
 /**
  * A type that maps between {@link java.sql.Types#INTEGER INTEGER} and {@link Boolean} (using 1 and 0)
  *
  * @author Steve Ebersole
  */
 public class NumericBooleanType 
 		extends AbstractSingleColumnStandardBasicType<Boolean>
 		implements PrimitiveType<Boolean>, DiscriminatorType<Boolean> {
 
 	public static final NumericBooleanType INSTANCE = new NumericBooleanType();
 
 	public NumericBooleanType() {
 		super( IntegerTypeDescriptor.INSTANCE, BooleanTypeDescriptor.INSTANCE );
 	}
-
+	@Override
 	public String getName() {
 		return "numeric_boolean";
 	}
-
+	@Override
 	public Class getPrimitiveClass() {
 		return boolean.class;
 	}
-
+	@Override
 	public Serializable getDefaultValue() {
 		return Boolean.FALSE;
 	}
-
+	@Override
 	public Boolean stringToObject(String string) {
 		return fromString( string );
 	}
-
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
+	@Override
 	public String objectToSQLString(Boolean value, Dialect dialect) {
-		return value.booleanValue() ? "1" : "0";
+		return value ? "1" : "0";
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/ShortType.java b/hibernate-core/src/main/java/org/hibernate/type/ShortType.java
index 296448d411..1ad220d6d7 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/ShortType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/ShortType.java
@@ -1,91 +1,89 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 import java.util.Comparator;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.type.descriptor.java.ShortTypeDescriptor;
 import org.hibernate.type.descriptor.sql.SmallIntTypeDescriptor;
 
 /**
  * A type that maps between {@link java.sql.Types#SMALLINT SMALLINT} and {@link Short}
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class ShortType
 		extends AbstractSingleColumnStandardBasicType<Short>
 		implements PrimitiveType<Short>, DiscriminatorType<Short>, VersionType<Short> {
 
 	public static final ShortType INSTANCE = new ShortType();
 
-	@SuppressWarnings({ "UnnecessaryBoxing" })
-	private static final Short ZERO = Short.valueOf( (short) 0 );
+	private static final Short ZERO = (short) 0;
 
 	public ShortType() {
 		super( SmallIntTypeDescriptor.INSTANCE, ShortTypeDescriptor.INSTANCE );
 	}
-
+	@Override
 	public String getName() {
 		return "short";
 	}
 
 	@Override
 	public String[] getRegistrationKeys() {
 		return new String[] { getName(), short.class.getName(), Short.class.getName() };
 	}
-
+	@Override
 	public Serializable getDefaultValue() {
 		return ZERO;
 	}
-	
+	@Override
 	public Class getPrimitiveClass() {
 		return short.class;
 	}
-
+	@Override
 	public String objectToSQLString(Short value, Dialect dialect) throws Exception {
 		return value.toString();
 	}
-
+	@Override
 	public Short stringToObject(String xml) throws Exception {
 		return Short.valueOf( xml );
 	}
-
-	@SuppressWarnings({ "UnnecessaryBoxing", "UnnecessaryUnboxing" })
+	@Override
 	public Short next(Short current, SessionImplementor session) {
-		return Short.valueOf( (short) ( current.shortValue() + 1 ) );
+		return (short) ( current + 1 );
 	}
-
+	@Override
 	public Short seed(SessionImplementor session) {
 		return ZERO;
 	}
-
+	@Override
 	public Comparator<Short> getComparator() {
 		return getJavaTypeDescriptor().getComparator();
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/TrueFalseType.java b/hibernate-core/src/main/java/org/hibernate/type/TrueFalseType.java
index 01e3ce8c66..a39c8b5e11 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/TrueFalseType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/TrueFalseType.java
@@ -1,69 +1,68 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.type.descriptor.java.BooleanTypeDescriptor;
 import org.hibernate.type.descriptor.sql.CharTypeDescriptor;
 
 /**
  * A type that maps between {@link java.sql.Types#CHAR CHAR(1)} and {@link Boolean} (using 'T' and 'F')
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class TrueFalseType
 		extends AbstractSingleColumnStandardBasicType<Boolean>
 		implements PrimitiveType<Boolean>, DiscriminatorType<Boolean> {
 
 	public static final TrueFalseType INSTANCE = new TrueFalseType();
 
 	public TrueFalseType() {
 		super( CharTypeDescriptor.INSTANCE, new BooleanTypeDescriptor( 'T', 'F' ) );
 	}
-
+	@Override
 	public String getName() {
 		return "true_false";
 	}
-
+	@Override
 	public Class getPrimitiveClass() {
 		return boolean.class;
 	}
-
+	@Override
 	public Boolean stringToObject(String xml) throws Exception {
 		return fromString( xml );
 	}
-
+	@Override
 	public Serializable getDefaultValue() {
 		return Boolean.FALSE;
 	}
-
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
+	@Override
 	public String objectToSQLString(Boolean value, Dialect dialect) throws Exception {
-		return StringType.INSTANCE.objectToSQLString( value.booleanValue() ? "T" : "F", dialect );
+		return StringType.INSTANCE.objectToSQLString( value ? "T" : "F", dialect );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/YesNoType.java b/hibernate-core/src/main/java/org/hibernate/type/YesNoType.java
index 6dbba3379d..bccd32cdd1 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/YesNoType.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/YesNoType.java
@@ -1,68 +1,67 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type;
 
 import java.io.Serializable;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.type.descriptor.java.BooleanTypeDescriptor;
 import org.hibernate.type.descriptor.sql.CharTypeDescriptor;
 
 /**
  * A type that maps between {@link java.sql.Types#CHAR CHAR(1)} and {@link Boolean} (using 'Y' and 'N')
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class YesNoType
 		extends AbstractSingleColumnStandardBasicType<Boolean>
 		implements PrimitiveType<Boolean>, DiscriminatorType<Boolean> {
 
 	public static final YesNoType INSTANCE = new YesNoType();
 
 	public YesNoType() {
 		super( CharTypeDescriptor.INSTANCE, BooleanTypeDescriptor.INSTANCE );
 	}
-
+	@Override
 	public String getName() {
 		return "yes_no";
 	}
-
+	@Override
 	public Class getPrimitiveClass() {
 		return boolean.class;
 	}
-
+	@Override
 	public Boolean stringToObject(String xml) throws Exception {
 		return fromString( xml );
 	}
-
+	@Override
 	public Serializable getDefaultValue() {
 		return Boolean.FALSE;
 	}
-
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
+	@Override
 	public String objectToSQLString(Boolean value, Dialect dialect) throws Exception {
-		return StringType.INSTANCE.objectToSQLString( value.booleanValue() ? "Y" : "N", dialect );
+		return StringType.INSTANCE.objectToSQLString( value ? "Y" : "N", dialect );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/BooleanTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/BooleanTypeDescriptor.java
index a220af0d17..85e0fe231d 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/BooleanTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/BooleanTypeDescriptor.java
@@ -1,147 +1,143 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 
 import org.hibernate.type.descriptor.WrapperOptions;
 
 import static java.lang.Boolean.FALSE;
 import static java.lang.Boolean.TRUE;
 
 /**
  * Descriptor for {@link Boolean} handling.
  *
  * @author Steve Ebersole
  */
 public class BooleanTypeDescriptor extends AbstractTypeDescriptor<Boolean> {
 	public static final BooleanTypeDescriptor INSTANCE = new BooleanTypeDescriptor();
 
 	private final char characterValueTrue;
 	private final char characterValueFalse;
 
 	private final char characterValueTrueLC;
 
 	private final String stringValueTrue;
 	private final String stringValueFalse;
 
 	public BooleanTypeDescriptor() {
 		this( 'Y', 'N' );
 	}
 
 	public BooleanTypeDescriptor(char characterValueTrue, char characterValueFalse) {
 		super( Boolean.class );
 		this.characterValueTrue = Character.toUpperCase( characterValueTrue );
 		this.characterValueFalse = Character.toUpperCase( characterValueFalse );
 
 		characterValueTrueLC = Character.toLowerCase( characterValueTrue );
 
 		stringValueTrue = String.valueOf( characterValueTrue );
 		stringValueFalse = String.valueOf( characterValueFalse );
 	}
-
+	@Override
 	public String toString(Boolean value) {
 		return value == null ? null : value.toString();
 	}
-
+	@Override
 	public Boolean fromString(String string) {
 		return Boolean.valueOf( string );
 	}
 
 	@SuppressWarnings({ "unchecked" })
+	@Override
 	public <X> X unwrap(Boolean value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Boolean.class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( Byte.class.isAssignableFrom( type ) ) {
 			return (X) toByte( value );
 		}
 		if ( Short.class.isAssignableFrom( type ) ) {
 			return (X) toShort( value );
 		}
 		if ( Integer.class.isAssignableFrom( type ) ) {
 			return (X) toInteger( value );
 		}
 		if ( Long.class.isAssignableFrom( type ) ) {
 			return (X) toInteger( value );
 		}
 		if ( Character.class.isAssignableFrom( type ) ) {
 			return (X) Character.valueOf( value ? characterValueTrue : characterValueFalse );
 		}
 		if ( String.class.isAssignableFrom( type ) ) {
 			return (X) (value ? stringValueTrue : stringValueFalse);
 		}
 		throw unknownUnwrap( type );
 	}
-
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
+	@Override
 	public <X> Boolean wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Boolean.class.isInstance( value ) ) {
 			return (Boolean) value;
 		}
 		if ( Number.class.isInstance( value ) ) {
 			final int intValue = ( (Number) value ).intValue();
 			return intValue == 0 ? FALSE : TRUE;
 		}
 		if ( Character.class.isInstance( value ) ) {
-			return isTrue( ( (Character) value ).charValue() ) ? TRUE : FALSE;
+			return isTrue( (Character) value ) ? TRUE : FALSE;
 		}
 		if ( String.class.isInstance( value ) ) {
 			return isTrue( ( (String) value ).charAt( 0 ) ) ? TRUE : FALSE;
 		}
 		throw unknownWrap( value.getClass() );
 	}
 
 	private boolean isTrue(char charValue) {
 		return charValue == characterValueTrue || charValue == characterValueTrueLC;
 	}
 
 	public int toInt(Boolean value) {
 		return value ? 1 : 0;
 	}
 
-	@SuppressWarnings({ "UnnecessaryBoxing" })
 	public Byte toByte(Boolean value) {
-		return Byte.valueOf( (byte) toInt( value ) );
+		return (byte) toInt( value );
 	}
 
-	@SuppressWarnings({ "UnnecessaryBoxing" })
 	public Short toShort(Boolean value) {
-		return Short.valueOf( (short ) toInt( value ) );
+		return (short) toInt( value );
 	}
 
-	@SuppressWarnings({ "UnnecessaryBoxing" })
 	public Integer toInteger(Boolean value) {
-		return Integer.valueOf( toInt( value ) );
+		return toInt( value );
 	}
 
-	@SuppressWarnings({ "UnnecessaryBoxing" })
 	public Long toLong(Boolean value) {
-		return Long.valueOf( toInt( value ) );
+		return (long) toInt( value );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/ByteArrayTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/ByteArrayTypeDescriptor.java
index 9c15fdf719..c4a48f4bb2 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/ByteArrayTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/ByteArrayTypeDescriptor.java
@@ -1,150 +1,147 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 
 import java.io.ByteArrayInputStream;
 import java.io.InputStream;
 import java.sql.Blob;
 import java.sql.SQLException;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.jdbc.BinaryStream;
 import org.hibernate.engine.jdbc.internal.BinaryStreamImpl;
 import org.hibernate.type.descriptor.WrapperOptions;
 
 /**
  * Descriptor for {@code Byte[]} handling.
  *
  * @author Steve Ebersole
  */
 public class ByteArrayTypeDescriptor extends AbstractTypeDescriptor<Byte[]> {
 	public static final ByteArrayTypeDescriptor INSTANCE = new ByteArrayTypeDescriptor();
 
 	@SuppressWarnings({ "unchecked" })
 	public ByteArrayTypeDescriptor() {
 		super( Byte[].class, ArrayMutabilityPlan.INSTANCE );
 	}
-
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
+	@Override
 	public String toString(Byte[] bytes) {
 		final StringBuilder buf = new StringBuilder();
 		for ( Byte aByte : bytes ) {
-			final String hexStr = Integer.toHexString( aByte.byteValue() - Byte.MIN_VALUE );
+			final String hexStr = Integer.toHexString( aByte - Byte.MIN_VALUE );
 			if ( hexStr.length() == 1 ) {
 				buf.append( '0' );
 			}
 			buf.append( hexStr );
 		}
 		return buf.toString();
 	}
-
-	@SuppressWarnings({ "UnnecessaryBoxing" })
+	@Override
 	public Byte[] fromString(String string) {
 		if ( string == null ) {
 			return null;
 		}
 		if ( string.length() % 2 != 0 ) {
 			throw new IllegalArgumentException( "The string is not a valid string representation of a binary content." );
 		}
 		Byte[] bytes = new Byte[string.length() / 2];
 		for ( int i = 0; i < bytes.length; i++ ) {
 			final String hexStr = string.substring( i * 2, (i + 1) * 2 );
-			bytes[i] = Byte.valueOf( (byte) (Integer.parseInt(hexStr, 16) + Byte.MIN_VALUE) );
+			bytes[i] = (byte) ( Integer.parseInt( hexStr, 16 ) + Byte.MIN_VALUE );
 		}
 		return bytes;
 	}
 
 	@SuppressWarnings({ "unchecked" })
+	@Override
 	public <X> X unwrap(Byte[] value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Byte[].class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( byte[].class.isAssignableFrom( type ) ) {
 			return (X) unwrapBytes( value );
 		}
 		if ( InputStream.class.isAssignableFrom( type ) ) {
 			return (X) new ByteArrayInputStream( unwrapBytes( value ) );
 		}
 		if ( BinaryStream.class.isAssignableFrom( type ) ) {
 			return (X) new BinaryStreamImpl( unwrapBytes( value ) );
 		}
 		if ( Blob.class.isAssignableFrom( type ) ) {
 			return (X) options.getLobCreator().createBlob( unwrapBytes( value ) );
 		}
 
 		throw unknownUnwrap( type );
 	}
-
+	@Override
 	public <X> Byte[] wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Byte[].class.isInstance( value ) ) {
 			return (Byte[]) value;
 		}
 		if ( byte[].class.isInstance( value ) ) {
 			return wrapBytes( (byte[]) value );
 		}
 		if ( InputStream.class.isInstance( value ) ) {
 			return wrapBytes( DataHelper.extractBytes( (InputStream) value ) );
 		}
 		if ( Blob.class.isInstance( value ) || DataHelper.isNClob( value.getClass() ) ) {
 			try {
 				return wrapBytes( DataHelper.extractBytes( ( (Blob) value ).getBinaryStream() ) );
 			}
 			catch ( SQLException e ) {
 				throw new HibernateException( "Unable to access lob stream", e );
 			}
 		}
 
 		throw unknownWrap( value.getClass() );
 	}
 
-	@SuppressWarnings({ "UnnecessaryBoxing" })
 	private Byte[] wrapBytes(byte[] bytes) {
 		if ( bytes == null ) {
 			return null;
 		}
 		final Byte[] result = new Byte[bytes.length];
 		for ( int i = 0; i < bytes.length; i++ ) {
-			result[i] = Byte.valueOf( bytes[i] );
+			result[i] = bytes[i];
 		}
 		return result;
 	}
 
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
 	private byte[] unwrapBytes(Byte[] bytes) {
 		if ( bytes == null ) {
 			return null;
 		}
 		final byte[] result = new byte[bytes.length];
 		for ( int i = 0; i < bytes.length; i++ ) {
-			result[i] = bytes[i].byteValue();
+			result[i] = bytes[i];
 		}
 		return result;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/ByteTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/ByteTypeDescriptor.java
index c86d9cfdb3..95523bf51f 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/ByteTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/ByteTypeDescriptor.java
@@ -1,93 +1,94 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 import org.hibernate.type.descriptor.WrapperOptions;
 
 /**
  * Descriptor for {@link Byte} handling.
  *
  * @author Steve Ebersole
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public class ByteTypeDescriptor extends AbstractTypeDescriptor<Byte> {
 	public static final ByteTypeDescriptor INSTANCE = new ByteTypeDescriptor();
 
 	public ByteTypeDescriptor() {
 		super( Byte.class );
 	}
 
+	@Override
 	public String toString(Byte value) {
 		return value == null ? null : value.toString();
 	}
-
+	@Override
 	public Byte fromString(String string) {
 		return Byte.valueOf( string );
 	}
 
 	@SuppressWarnings({ "unchecked" })
+	@Override
 	public <X> X unwrap(Byte value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Byte.class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( Short.class.isAssignableFrom( type ) ) {
 			return (X) Short.valueOf( value.shortValue() );
 		}
 		if ( Integer.class.isAssignableFrom( type ) ) {
 			return (X) Integer.valueOf( value.intValue() );
 		}
 		if ( Long.class.isAssignableFrom( type ) ) {
 			return (X) Long.valueOf( value.longValue() );
 		}
 		if ( Double.class.isAssignableFrom( type ) ) {
 			return (X) Double.valueOf( value.doubleValue() );
 		}
 		if ( Float.class.isAssignableFrom( type ) ) {
 			return (X) Float.valueOf( value.floatValue() );
 		}
 		if ( String.class.isAssignableFrom( type ) ) {
 			return (X) value.toString();
 		}
 		throw unknownUnwrap( type );
 	}
-
-	@SuppressWarnings({ "UnnecessaryBoxing" })
+	@Override
 	public <X> Byte wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Byte.class.isInstance( value ) ) {
 			return (Byte) value;
 		}
 		if ( Number.class.isInstance( value ) ) {
-			return Byte.valueOf( ( (Number) value ).byteValue() );
+			return ( (Number) value ).byteValue();
 		}
 		if ( String.class.isInstance( value ) ) {
 			return Byte.valueOf( ( (String) value ) );
 		}
 		throw unknownWrap( value.getClass() );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/CalendarDateTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/CalendarDateTypeDescriptor.java
index 0a8f5d6346..6cb12139bc 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/CalendarDateTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/CalendarDateTypeDescriptor.java
@@ -1,133 +1,133 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 
 import java.util.Calendar;
 import java.util.Comparator;
 import java.util.Date;
 import java.util.GregorianCalendar;
 
 import org.hibernate.cfg.Environment;
 import org.hibernate.internal.util.compare.CalendarComparator;
 import org.hibernate.type.descriptor.WrapperOptions;
 
 /**
  * Descriptor for {@link java.util.Calendar} handling, but just for the date (month, day, year) portion.
  *
  * @author Steve Ebersole
  */
 public class CalendarDateTypeDescriptor extends AbstractTypeDescriptor<Calendar> {
 	public static final CalendarDateTypeDescriptor INSTANCE = new CalendarDateTypeDescriptor();
 
 	protected CalendarDateTypeDescriptor() {
 		super( Calendar.class, CalendarTypeDescriptor.CalendarMutabilityPlan.INSTANCE );
 	}
 
 	public String toString(Calendar value) {
 		return DateTypeDescriptor.INSTANCE.toString( value.getTime() );
 	}
 
 	public Calendar fromString(String string) {
 		Calendar result = new GregorianCalendar();
 		result.setTime( DateTypeDescriptor.INSTANCE.fromString( string ) );
 		return result;
 	}
 
 	@Override
 	public boolean areEqual(Calendar one, Calendar another) {
 		if ( one == another ) {
 			return true;
 		}
 		if ( one == null || another == null ) {
 			return false;
 		}
 
 		return one.get(Calendar.DAY_OF_MONTH) == another.get(Calendar.DAY_OF_MONTH)
 			&& one.get(Calendar.MONTH) == another.get(Calendar.MONTH)
 			&& one.get(Calendar.YEAR) == another.get(Calendar.YEAR);
 	}
 
 	@Override
 	public int extractHashCode(Calendar value) {
 		int hashCode = 1;
 		hashCode = 31 * hashCode + value.get(Calendar.DAY_OF_MONTH);
 		hashCode = 31 * hashCode + value.get(Calendar.MONTH);
 		hashCode = 31 * hashCode + value.get(Calendar.YEAR);
 		return hashCode;
 	}
 
 	@Override
 	public Comparator<Calendar> getComparator() {
 		return CalendarComparator.INSTANCE;
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	public <X> X unwrap(Calendar value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Calendar.class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( java.sql.Date.class.isAssignableFrom( type ) ) {
 			return (X) new java.sql.Date( value.getTimeInMillis() );
 		}
 		if ( java.sql.Time.class.isAssignableFrom( type ) ) {
 			return (X) new java.sql.Time( value.getTimeInMillis() );
 		}
 		if ( java.sql.Timestamp.class.isAssignableFrom( type ) ) {
 			return (X) new java.sql.Timestamp( value.getTimeInMillis() );
 		}
 		if ( Date.class.isAssignableFrom( type ) ) {
 			return (X) new  Date( value.getTimeInMillis() );
 		}
 		throw unknownUnwrap( type );
 	}
 
 	public <X> Calendar wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Calendar.class.isInstance( value ) ) {
 			return (Calendar) value;
 		}
 
 		if ( ! Date.class.isInstance( value ) ) {
 			throw unknownWrap( value.getClass() );
 		}
 
 		Calendar cal = new GregorianCalendar();
 		if ( Environment.jvmHasTimestampBug() ) {
 			final long milliseconds = ( (Date) value ).getTime();
 			final long nanoseconds = java.sql.Timestamp.class.isInstance( value )
 					? ( (java.sql.Timestamp) value ).getNanos()
 					: 0;
 			cal.setTime( new Date( milliseconds + nanoseconds / 1000000 ) );
 		}
 		else {
 			cal.setTime( (Date) value );
 		}
 		return cal;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/CharacterArrayTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/CharacterArrayTypeDescriptor.java
index 59ee39666f..ac74e6b7de 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/CharacterArrayTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/CharacterArrayTypeDescriptor.java
@@ -1,136 +1,135 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 
 import java.io.Reader;
 import java.io.StringReader;
 import java.sql.Clob;
 import java.util.Arrays;
 
 import org.hibernate.engine.jdbc.CharacterStream;
 import org.hibernate.engine.jdbc.internal.CharacterStreamImpl;
 import org.hibernate.type.descriptor.WrapperOptions;
 
 /**
  * Descriptor for {@code Character[]} handling.
  *
  * @author Steve Ebersole
  */
 public class CharacterArrayTypeDescriptor extends AbstractTypeDescriptor<Character[]> {
 	public static final CharacterArrayTypeDescriptor INSTANCE = new CharacterArrayTypeDescriptor();
 
 	@SuppressWarnings({ "unchecked" })
 	public CharacterArrayTypeDescriptor() {
 		super( Character[].class, ArrayMutabilityPlan.INSTANCE );
 	}
-
+	@Override
 	public String toString(Character[] value) {
 		return new String( unwrapChars( value ) );
 	}
-
+	@Override
 	public Character[] fromString(String string) {
 		return wrapChars( string.toCharArray() );
 	}
 
 	@Override
 	public boolean areEqual(Character[] one, Character[] another) {
 		return one == another
 				|| ( one != null && another != null && Arrays.equals( one, another ) );
 	}
 
 	@Override
 	public int extractHashCode(Character[] chars) {
 		int hashCode = 1;
 		for ( Character aChar : chars ) {
 			hashCode = 31 * hashCode + aChar;
 		}
 		return hashCode;
 	}
 
 	@SuppressWarnings({ "unchecked" })
+	@Override
 	public <X> X unwrap(Character[] value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Character[].class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( String.class.isAssignableFrom( type ) ) {
 			return (X) new String( unwrapChars( value ) );
 		}
 		if ( Clob.class.isAssignableFrom( type ) ) {
 			return (X) options.getLobCreator().createClob( new String( unwrapChars( value ) ) );
 		}
 		if ( Reader.class.isAssignableFrom( type ) ) {
 			return (X) new StringReader( new String( unwrapChars( value ) ) );
 		}
 		if ( CharacterStream.class.isAssignableFrom( type ) ) {
 			return (X) new CharacterStreamImpl( new String( unwrapChars( value ) ) );
 		}
 		throw unknownUnwrap( type );
 	}
-
+	@Override
 	public <X> Character[] wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Character[].class.isInstance( value ) ) {
 			return (Character[]) value;
 		}
 		if ( String.class.isInstance( value ) ) {
 			return wrapChars( ( (String) value ).toCharArray() );
 		}
 		if ( Clob.class.isInstance( value ) ) {
 			return wrapChars( DataHelper.extractString( ( (Clob) value ) ).toCharArray() );
 		}
 		if ( Reader.class.isInstance( value ) ) {
 			return wrapChars( DataHelper.extractString( (Reader) value ).toCharArray() );
 		}
 		throw unknownWrap( value.getClass() );
 	}
 
-	@SuppressWarnings({ "UnnecessaryBoxing" })
 	private Character[] wrapChars(char[] chars) {
 		if ( chars == null ) {
 			return null;
 		}
 		final Character[] result = new Character[chars.length];
 		for ( int i = 0; i < chars.length; i++ ) {
-			result[i] = Character.valueOf( chars[i] );
+			result[i] = chars[i];
 		}
 		return result;
 	}
 
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
 	private char[] unwrapChars(Character[] chars) {
 		if ( chars == null ) {
 			return null;
 		}
 		final char[] result = new char[chars.length];
 		for ( int i = 0; i < chars.length; i++ ) {
-			result[i] = chars[i].charValue();
+			result[i] = chars[i];
 		}
 		return result;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/CharacterTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/CharacterTypeDescriptor.java
index f9e90a66fa..0c3148caac 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/CharacterTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/CharacterTypeDescriptor.java
@@ -1,87 +1,86 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 import org.hibernate.HibernateException;
 import org.hibernate.type.descriptor.WrapperOptions;
 
 /**
  * Descriptor for {@link Character} handling.
  *
  * @author Steve Ebersole
  */
 public class CharacterTypeDescriptor extends AbstractTypeDescriptor<Character> {
 	public static final CharacterTypeDescriptor INSTANCE = new CharacterTypeDescriptor();
 
 	public CharacterTypeDescriptor() {
 		super( Character.class );
 	}
-
+	@Override
 	public String toString(Character value) {
 		return value.toString();
 	}
-
-	@SuppressWarnings({ "UnnecessaryBoxing" })
+	@Override
 	public Character fromString(String string) {
 		if ( string.length() != 1 ) {
 			throw new HibernateException( "multiple or zero characters found parsing string" );
 		}
-		return Character.valueOf( string.charAt( 0 ) );
+		return string.charAt( 0 );
 	}
 
 	@SuppressWarnings({ "unchecked" })
+	@Override
 	public <X> X unwrap(Character value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Character.class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( String.class.isAssignableFrom( type ) ) {
 			return (X) value.toString();
 		}
 		if ( Number.class.isAssignableFrom( type ) ) {
 			return (X) Short.valueOf( (short)value.charValue() );
 		}
 		throw unknownUnwrap( type );
 	}
-
-	@SuppressWarnings({ "UnnecessaryBoxing" })
+	@Override
 	public <X> Character wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Character.class.isInstance( value ) ) {
 			return (Character) value;
 		}
 		if ( String.class.isInstance( value ) ) {
 			final String str = (String) value;
-			return Character.valueOf( str.charAt(0) );
+			return str.charAt( 0 );
 		}
 		if ( Number.class.isInstance( value ) ) {
 			final Number nbr = (Number) value;
-			return Character.valueOf( (char)nbr.shortValue() );
+			return (char) nbr.shortValue();
 		}
 		throw unknownWrap( value.getClass() );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/DateTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/DateTypeDescriptor.java
index 1882c725cd..17e90e49aa 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/DateTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/DateTypeDescriptor.java
@@ -1,144 +1,141 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.GregorianCalendar;
 
 import org.hibernate.HibernateException;
 import org.hibernate.type.descriptor.WrapperOptions;
 
 /**
  * Descriptor for {@link Date} handling.
  *
  * @author Steve Ebersole
  */
 public class DateTypeDescriptor extends AbstractTypeDescriptor<Date> {
 	public static final DateTypeDescriptor INSTANCE = new DateTypeDescriptor();
 	public static final String DATE_FORMAT = "dd MMMM yyyy";
 
 	public static class DateMutabilityPlan extends MutableMutabilityPlan<Date> {
 		public static final DateMutabilityPlan INSTANCE = new DateMutabilityPlan();
-
+		@Override
 		public Date deepCopyNotNull(Date value) {
 			return new Date( value.getTime() );
 		}
 	}
 
 	public DateTypeDescriptor() {
 		super( Date.class, DateMutabilityPlan.INSTANCE );
 	}
-
+	@Override
 	public String toString(Date value) {
 		return new SimpleDateFormat( DATE_FORMAT ).format( value );
 	}
-
+	@Override
 	public Date fromString(String string) {
 		try {
 			return new SimpleDateFormat(DATE_FORMAT).parse( string );
 		}
 		catch ( ParseException pe) {
 			throw new HibernateException( "could not parse date string" + string, pe );
 		}
 	}
 
 	@Override
 	public boolean areEqual(Date one, Date another) {
 		if ( one == another) {
 			return true;
 		}
-		if ( one == null || another == null ) {
-			return false;
-		}
+		return !( one == null || another == null ) && one.getTime() == another.getTime();
 
-		return one.getTime() == another.getTime();
 	}
 
 	@Override
 	public int extractHashCode(Date value) {
 		Calendar calendar = java.util.Calendar.getInstance();
 		calendar.setTime( value );
 		return CalendarTypeDescriptor.INSTANCE.extractHashCode( calendar );
 	}
 
 	@SuppressWarnings({ "unchecked" })
+	@Override
 	public <X> X unwrap(Date value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( java.sql.Date.class.isAssignableFrom( type ) ) {
 			final java.sql.Date rtn = java.sql.Date.class.isInstance( value )
 					? ( java.sql.Date ) value
 					: new java.sql.Date( value.getTime() );
 			return (X) rtn;
 		}
 		if ( java.sql.Time.class.isAssignableFrom( type ) ) {
 			final java.sql.Time rtn = java.sql.Time.class.isInstance( value )
 					? ( java.sql.Time ) value
 					: new java.sql.Time( value.getTime() );
 			return (X) rtn;
 		}
 		if ( java.sql.Timestamp.class.isAssignableFrom( type ) ) {
 			final java.sql.Timestamp rtn = java.sql.Timestamp.class.isInstance( value )
 					? ( java.sql.Timestamp ) value
 					: new java.sql.Timestamp( value.getTime() );
 			return (X) rtn;
 		}
 		if ( Date.class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( Calendar.class.isAssignableFrom( type ) ) {
 			final GregorianCalendar cal = new GregorianCalendar();
 			cal.setTimeInMillis( value.getTime() );
 			return (X) cal;
 		}
 		if ( Long.class.isAssignableFrom( type ) ) {
 			return (X) Long.valueOf( value.getTime() );
 		}
 		throw unknownUnwrap( type );
 	}
-
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
+	@Override
 	public <X> Date wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Date.class.isInstance( value ) ) {
 			return (Date) value;
 		}
 
 		if ( Long.class.isInstance( value ) ) {
-			return new Date( ( (Long) value ).longValue() );
+			return new Date( (Long) value );
 		}
 
 		if ( Calendar.class.isInstance( value ) ) {
 			return new Date( ( (Calendar) value ).getTimeInMillis() );
 		}
 
 		throw unknownWrap( value.getClass() );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/DoubleTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/DoubleTypeDescriptor.java
index ffcdcb429f..546cb8e4ef 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/DoubleTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/DoubleTypeDescriptor.java
@@ -1,102 +1,102 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 
 import org.hibernate.type.descriptor.WrapperOptions;
 
 /**
  * Descriptor for {@link Double} handling.
  *
  * @author Steve Ebersole
  */
 public class DoubleTypeDescriptor extends AbstractTypeDescriptor<Double> {
 	public static final DoubleTypeDescriptor INSTANCE = new DoubleTypeDescriptor();
 
 	public DoubleTypeDescriptor() {
 		super( Double.class );
 	}
-
+	@Override
 	public String toString(Double value) {
 		return value == null ? null : value.toString();
 	}
-
+	@Override
 	public Double fromString(String string) {
 		return Double.valueOf( string );
 	}
 
 	@SuppressWarnings({ "unchecked" })
+	@Override
 	public <X> X unwrap(Double value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Double.class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( Byte.class.isAssignableFrom( type ) ) {
 			return (X) Byte.valueOf( value.byteValue() );
 		}
 		if ( Short.class.isAssignableFrom( type ) ) {
 			return (X) Short.valueOf( value.shortValue() );
 		}
 		if ( Integer.class.isAssignableFrom( type ) ) {
 			return (X) Integer.valueOf( value.intValue() );
 		}
 		if ( Long.class.isAssignableFrom( type ) ) {
 			return (X) Long.valueOf( value.longValue() );
 		}
 		if ( Float.class.isAssignableFrom( type ) ) {
 			return (X) Float.valueOf( value.floatValue() );
 		}
 		if ( BigInteger.class.isAssignableFrom( type ) ) {
 			return (X) BigInteger.valueOf( value.longValue() );
 		}
 		if ( BigDecimal.class.isAssignableFrom( type ) ) {
 			return (X) BigDecimal.valueOf( value );
 		}
 		if ( String.class.isAssignableFrom( type ) ) {
 			return (X) value.toString();
 		}
 		throw unknownUnwrap( type );
 	}
-
-	@SuppressWarnings({ "UnnecessaryBoxing" })
+	@Override
 	public <X> Double wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Double.class.isInstance( value ) ) {
 			return (Double) value;
 		}
 		if ( Number.class.isInstance( value ) ) {
-			return Double.valueOf( ( (Number) value ).doubleValue() );
+			return ( (Number) value ).doubleValue();
 		}
 		else if ( String.class.isInstance( value ) ) {
 			return Double.valueOf( ( (String) value ) );
 		}
 		throw unknownWrap( value.getClass() );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/FloatTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/FloatTypeDescriptor.java
index 69bd4537a8..b1f271307f 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/FloatTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/FloatTypeDescriptor.java
@@ -1,102 +1,102 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 
 import org.hibernate.type.descriptor.WrapperOptions;
 
 /**
  * Descriptor for {@link Float} handling.
  *
  * @author Steve Ebersole
  */
 public class FloatTypeDescriptor extends AbstractTypeDescriptor<Float> {
 	public static final FloatTypeDescriptor INSTANCE = new FloatTypeDescriptor();
 
 	public FloatTypeDescriptor() {
 		super( Float.class );
 	}
-
+	@Override
 	public String toString(Float value) {
 		return value == null ? null : value.toString();
 	}
-
+	@Override
 	public Float fromString(String string) {
 		return Float.valueOf( string );
 	}
 
 	@SuppressWarnings({ "unchecked" })
+	@Override
 	public <X> X unwrap(Float value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Float.class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( Byte.class.isAssignableFrom( type ) ) {
 			return (X) Byte.valueOf( value.byteValue() );
 		}
 		if ( Short.class.isAssignableFrom( type ) ) {
 			return (X) Short.valueOf( value.shortValue() );
 		}
 		if ( Integer.class.isAssignableFrom( type ) ) {
 			return (X) Integer.valueOf( value.intValue() );
 		}
 		if ( Long.class.isAssignableFrom( type ) ) {
 			return (X) Long.valueOf( value.longValue() );
 		}
 		if ( Double.class.isAssignableFrom( type ) ) {
 			return (X) Double.valueOf( value.doubleValue() );
 		}
 		if ( BigInteger.class.isAssignableFrom( type ) ) {
 			return (X) BigInteger.valueOf( value.longValue() );
 		}
 		if ( BigDecimal.class.isAssignableFrom( type ) ) {
 			return (X) BigDecimal.valueOf( value );
 		}
 		if ( String.class.isAssignableFrom( type ) ) {
 			return (X) value.toString();
 		}
 		throw unknownUnwrap( type );
 	}
-
-	@SuppressWarnings({ "UnnecessaryBoxing" })
+	@Override
 	public <X> Float wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Float.class.isInstance( value ) ) {
 			return (Float) value;
 		}
 		if ( Number.class.isInstance( value ) ) {
-			return Float.valueOf( ( (Number) value ).floatValue() );
+			return ( (Number) value ).floatValue();
 		}
 		else if ( String.class.isInstance( value ) ) {
 			return Float.valueOf( ( (String) value ) );
 		}
 		throw unknownWrap( value.getClass() );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/IntegerTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/IntegerTypeDescriptor.java
index 3fd7bf1d57..a009483333 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/IntegerTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/IntegerTypeDescriptor.java
@@ -1,102 +1,102 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 
 import org.hibernate.type.descriptor.WrapperOptions;
 
 /**
  * Descriptor for {@link Integer} handling.
  *
  * @author Steve Ebersole
  */
 public class IntegerTypeDescriptor extends AbstractTypeDescriptor<Integer> {
 	public static final IntegerTypeDescriptor INSTANCE = new IntegerTypeDescriptor();
 
 	public IntegerTypeDescriptor() {
 		super( Integer.class );
 	}
-
+	@Override
 	public String toString(Integer value) {
 		return value == null ? null : value.toString();
 	}
-
+	@Override
 	public Integer fromString(String string) {
 		return string == null ? null : Integer.valueOf( string );
 	}
 
 	@SuppressWarnings({ "unchecked" })
+	@Override
 	public <X> X unwrap(Integer value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Integer.class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( Byte.class.isAssignableFrom( type ) ) {
 			return (X) Byte.valueOf( value.byteValue() );
 		}
 		if ( Short.class.isAssignableFrom( type ) ) {
 			return (X) Short.valueOf( value.shortValue() );
 		}
 		if ( Long.class.isAssignableFrom( type ) ) {
 			return (X) Long.valueOf( value.longValue() );
 		}
 		if ( Double.class.isAssignableFrom( type ) ) {
 			return (X) Double.valueOf( value.doubleValue() );
 		}
 		if ( Float.class.isAssignableFrom( type ) ) {
 			return (X) Float.valueOf( value.floatValue() );
 		}
 		if ( BigInteger.class.isAssignableFrom( type ) ) {
 			return (X) BigInteger.valueOf( value );
 		}
 		if ( BigDecimal.class.isAssignableFrom( type ) ) {
 			return (X) BigDecimal.valueOf( value );
 		}
 		if ( String.class.isAssignableFrom( type ) ) {
 			return (X) value.toString();
 		}
 		throw unknownUnwrap( type );
 	}
-
-	@SuppressWarnings({ "UnnecessaryBoxing" })
+	@Override
 	public <X> Integer wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Integer.class.isInstance( value ) ) {
 			return (Integer) value;
 		}
 		if ( Number.class.isInstance( value ) ) {
-			return Integer.valueOf( ( (Number) value ).intValue() );
+			return ( (Number) value ).intValue();
 		}
 		if ( String.class.isInstance( value ) ) {
 			return Integer.valueOf( ( (String) value ) );
 		}
 		throw unknownWrap( value.getClass() );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/JdbcDateTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/JdbcDateTypeDescriptor.java
index bc52ffba83..d7d293ac8a 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/JdbcDateTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/JdbcDateTypeDescriptor.java
@@ -1,165 +1,165 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.GregorianCalendar;
 
 import org.hibernate.HibernateException;
 import org.hibernate.type.descriptor.WrapperOptions;
 
 /**
  * Descriptor for {@link java.sql.Date} handling.
  *
  * @author Steve Ebersole
  */
 public class JdbcDateTypeDescriptor extends AbstractTypeDescriptor<Date> {
 	public static final JdbcDateTypeDescriptor INSTANCE = new JdbcDateTypeDescriptor();
 	public static final String DATE_FORMAT = "dd MMMM yyyy";
 
 	public static class DateMutabilityPlan extends MutableMutabilityPlan<Date> {
 		public static final DateMutabilityPlan INSTANCE = new DateMutabilityPlan();
-
+		@Override
 		public Date deepCopyNotNull(Date value) {
 			return java.sql.Date.class.isInstance( value )
 					? new java.sql.Date( value.getTime() )
 					: new Date( value.getTime() );
 		}
 	}
 
 	public JdbcDateTypeDescriptor() {
 		super( Date.class, DateMutabilityPlan.INSTANCE );
 	}
-
+	@Override
 	public String toString(Date value) {
 		return new SimpleDateFormat( DATE_FORMAT ).format( value );
 	}
-
+	@Override
 	public Date fromString(String string) {
 		try {
 			return new Date( new SimpleDateFormat(DATE_FORMAT).parse( string ).getTime() );
 		}
 		catch ( ParseException pe) {
 			throw new HibernateException( "could not parse date string" + string, pe );
 		}
 	}
 
 	@Override
 	public boolean areEqual(Date one, Date another) {
 		if ( one == another ) {
 			return true;
 		}
 		if ( one == null || another == null ) {
 			return false;
 		}
 
 		if ( one.getTime() == another.getTime() ) {
 			return true;
 		}
 
 		Calendar calendar1 = Calendar.getInstance();
 		Calendar calendar2 = Calendar.getInstance();
 		calendar1.setTime( one );
 		calendar2.setTime( another );
 
 		return calendar1.get( Calendar.MONTH ) == calendar2.get( Calendar.MONTH )
 				&& calendar1.get( Calendar.DAY_OF_MONTH ) == calendar2.get( Calendar.DAY_OF_MONTH )
 				&& calendar1.get( Calendar.YEAR ) == calendar2.get( Calendar.YEAR );
 	}
 
 	@Override
 	public int extractHashCode(Date value) {
 		Calendar calendar = Calendar.getInstance();
 		calendar.setTime( value );
 		int hashCode = 1;
 		hashCode = 31 * hashCode + calendar.get( Calendar.MONTH );
 		hashCode = 31 * hashCode + calendar.get( Calendar.DAY_OF_MONTH );
 		hashCode = 31 * hashCode + calendar.get( Calendar.YEAR );
 		return hashCode;
 	}
 
 	@SuppressWarnings({ "unchecked" })
+	@Override
 	public <X> X unwrap(Date value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( java.sql.Date.class.isAssignableFrom( type ) ) {
 			final java.sql.Date rtn = java.sql.Date.class.isInstance( value )
 					? ( java.sql.Date ) value
 					: new java.sql.Date( value.getTime() );
 			return (X) rtn;
 		}
 		if ( java.sql.Time.class.isAssignableFrom( type ) ) {
 			final java.sql.Time rtn = java.sql.Time.class.isInstance( value )
 					? ( java.sql.Time ) value
 					: new java.sql.Time( value.getTime() );
 			return (X) rtn;
 		}
 		if ( java.sql.Timestamp.class.isAssignableFrom( type ) ) {
 			final java.sql.Timestamp rtn = java.sql.Timestamp.class.isInstance( value )
 					? ( java.sql.Timestamp ) value
 					: new java.sql.Timestamp( value.getTime() );
 			return (X) rtn;
 		}
 		if ( Date.class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( Calendar.class.isAssignableFrom( type ) ) {
 			final GregorianCalendar cal = new GregorianCalendar();
 			cal.setTimeInMillis( value.getTime() );
 			return (X) cal;
 		}
 		if ( Long.class.isAssignableFrom( type ) ) {
 			return (X) Long.valueOf( value.getTime() );
 		}
 		throw unknownUnwrap( type );
 	}
-
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
+	@Override
 	public <X> Date wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Date.class.isInstance( value ) ) {
 			return (Date) value;
 		}
 
 		if ( Long.class.isInstance( value ) ) {
 			return new java.sql.Date( ( (Long) value ).longValue() );
 		}
 
 		if ( Calendar.class.isInstance( value ) ) {
 			return new java.sql.Date( ( (Calendar) value ).getTimeInMillis() );
 		}
 
 		if ( java.util.Date.class.isInstance( value ) ) {
 			return new java.sql.Date( ( (java.util.Date) value ).getTime() );
 		}
 
 		throw unknownWrap( value.getClass() );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/JdbcTimeTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/JdbcTimeTypeDescriptor.java
index d68fd029a2..6ef506b69e 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/JdbcTimeTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/JdbcTimeTypeDescriptor.java
@@ -1,168 +1,168 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 
 import java.sql.Time;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.GregorianCalendar;
 
 import org.hibernate.HibernateException;
 import org.hibernate.type.descriptor.WrapperOptions;
 
 /**
  * Descriptor for {@link Time} handling.
  *
  * @author Steve Ebersole
  */
 public class JdbcTimeTypeDescriptor extends AbstractTypeDescriptor<Date> {
 	public static final JdbcTimeTypeDescriptor INSTANCE = new JdbcTimeTypeDescriptor();
 	public static final String TIME_FORMAT = "HH:mm:ss";
 
 	public static class TimeMutabilityPlan extends MutableMutabilityPlan<Date> {
 		public static final TimeMutabilityPlan INSTANCE = new TimeMutabilityPlan();
-
+		@Override
 		public Date deepCopyNotNull(Date value) {
 			return Time.class.isInstance( value )
 					? new Time( value.getTime() )
 					: new Date( value.getTime() );
 		}
 	}
 
 	public JdbcTimeTypeDescriptor() {
 		super( Date.class, TimeMutabilityPlan.INSTANCE );
 	}
-
+	@Override
 	public String toString(Date value) {
 		return new SimpleDateFormat( TIME_FORMAT ).format( value );
 	}
-
+	@Override
 	public java.util.Date fromString(String string) {
 		try {
 			return new Time( new SimpleDateFormat( TIME_FORMAT ).parse( string ).getTime() );
 		}
 		catch ( ParseException pe ) {
 			throw new HibernateException( "could not parse time string" + string, pe );
 		}
 	}
 
 	@Override
 	public int extractHashCode(Date value) {
 		Calendar calendar = Calendar.getInstance();
 		calendar.setTime( value );
 		int hashCode = 1;
 		hashCode = 31 * hashCode + calendar.get( Calendar.HOUR_OF_DAY );
 		hashCode = 31 * hashCode + calendar.get( Calendar.MINUTE );
 		hashCode = 31 * hashCode + calendar.get( Calendar.SECOND );
 		hashCode = 31 * hashCode + calendar.get( Calendar.MILLISECOND );
 		return hashCode;
 	}
 
 	@Override
 	public boolean areEqual(Date one, Date another) {
 		if ( one == another ) {
 			return true;
 		}
 		if ( one == null || another == null ) {
 			return false;
 		}
 
 		if ( one.getTime() == another.getTime() ) {
 			return true;
 		}
 
 		Calendar calendar1 = Calendar.getInstance();
 		Calendar calendar2 = Calendar.getInstance();
 		calendar1.setTime( one );
 		calendar2.setTime( another );
 
 		return calendar1.get( Calendar.HOUR_OF_DAY ) == calendar2.get( Calendar.HOUR_OF_DAY )
 				&& calendar1.get( Calendar.MINUTE ) == calendar2.get( Calendar.MINUTE )
 				&& calendar1.get( Calendar.SECOND ) == calendar2.get( Calendar.SECOND )
 				&& calendar1.get( Calendar.MILLISECOND ) == calendar2.get( Calendar.MILLISECOND );
 	}
 
 	@SuppressWarnings({ "unchecked" })
+	@Override
 	public <X> X unwrap(Date value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Time.class.isAssignableFrom( type ) ) {
 			final Time rtn = Time.class.isInstance( value )
 					? ( Time ) value
 					: new Time( value.getTime() );
 			return (X) rtn;
 		}
 		if ( java.sql.Date.class.isAssignableFrom( type ) ) {
 			final java.sql.Date rtn = java.sql.Date.class.isInstance( value )
 					? ( java.sql.Date ) value
 					: new java.sql.Date( value.getTime() );
 			return (X) rtn;
 		}
 		if ( java.sql.Timestamp.class.isAssignableFrom( type ) ) {
 			final java.sql.Timestamp rtn = java.sql.Timestamp.class.isInstance( value )
 					? ( java.sql.Timestamp ) value
 					: new java.sql.Timestamp( value.getTime() );
 			return (X) rtn;
 		}
 		if ( java.util.Date.class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( Calendar.class.isAssignableFrom( type ) ) {
 			final GregorianCalendar cal = new GregorianCalendar();
 			cal.setTimeInMillis( value.getTime() );
 			return (X) cal;
 		}
 		if ( Long.class.isAssignableFrom( type ) ) {
 			return (X) Long.valueOf( value.getTime() );
 		}
 		throw unknownUnwrap( type );
 	}
-
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
+	@Override
 	public <X> Date wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Time.class.isInstance( value ) ) {
 			return (Time) value;
 		}
 
 		if ( Long.class.isInstance( value ) ) {
-			return new Time( ( (Long) value ).longValue() );
+			return new Time( (Long) value );
 		}
 
 		if ( Calendar.class.isInstance( value ) ) {
 			return new Time( ( (Calendar) value ).getTimeInMillis() );
 		}
 
 		if ( Date.class.isInstance( value ) ) {
 			return (Date) value;
 		}
 
 		throw unknownWrap( value.getClass() );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/JdbcTimestampTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/JdbcTimestampTypeDescriptor.java
index bdb8732b2b..eba62a79b8 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/JdbcTimestampTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/JdbcTimestampTypeDescriptor.java
@@ -1,177 +1,177 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 
 import java.sql.Timestamp;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.GregorianCalendar;
 
 import org.hibernate.HibernateException;
 import org.hibernate.type.descriptor.WrapperOptions;
 
 /**
  * Descriptor for {@link Timestamp} handling.
  *
  * @author Steve Ebersole
  */
 public class JdbcTimestampTypeDescriptor extends AbstractTypeDescriptor<Date> {
 	public static final JdbcTimestampTypeDescriptor INSTANCE = new JdbcTimestampTypeDescriptor();
 	public static final String TIMESTAMP_FORMAT = "yyyy-MM-dd HH:mm:ss";
 
 	public static class TimestampMutabilityPlan extends MutableMutabilityPlan<Date> {
 		public static final TimestampMutabilityPlan INSTANCE = new TimestampMutabilityPlan();
-
+		@Override
 		public Date deepCopyNotNull(Date value) {
 			if ( value instanceof Timestamp ) {
 				Timestamp orig = (Timestamp) value;
 				Timestamp ts = new Timestamp( orig.getTime() );
 				ts.setNanos( orig.getNanos() );
 				return ts;
 			}
 			else {
 				return new Date( value.getTime() );
 			}
 		}
 	}
 
 	public JdbcTimestampTypeDescriptor() {
 		super( Date.class, TimestampMutabilityPlan.INSTANCE );
 	}
-
+	@Override
 	public String toString(Date value) {
 		return new SimpleDateFormat( TIMESTAMP_FORMAT ).format( value );
 	}
-
+	@Override
 	public Date fromString(String string) {
 		try {
 			return new Timestamp( new SimpleDateFormat( TIMESTAMP_FORMAT ).parse( string ).getTime() );
 		}
 		catch ( ParseException pe) {
 			throw new HibernateException( "could not parse timestamp string" + string, pe );
 		}
 	}
 
 	@Override
 	public boolean areEqual(Date one, Date another) {
 		if ( one == another ) {
 			return true;
 		}
 		if ( one == null || another == null) {
 			return false;
 		}
 
 		long t1 = one.getTime();
 		long t2 = another.getTime();
 
 		boolean oneIsTimestamp = Timestamp.class.isInstance( one );
 		boolean anotherIsTimestamp = Timestamp.class.isInstance( another );
 
 		int n1 = oneIsTimestamp ? ( (Timestamp) one ).getNanos() : 0;
 		int n2 = anotherIsTimestamp ? ( (Timestamp) another ).getNanos() : 0;
 
 		if ( t1 != t2 ) {
 			return false;
 		}
 
 		if ( oneIsTimestamp && anotherIsTimestamp ) {
 			// both are Timestamps
 			int nn1 = n1 % 1000000;
 			int nn2 = n2 % 1000000;
 			return nn1 == nn2;
 		}
 		else {
 			// at least one is a plain old Date
 			return true;
 		}
 	}
 
 	@Override
 	public int extractHashCode(Date value) {
 		return Long.valueOf( value.getTime() / 1000 ).hashCode();
 	}
 
 	@SuppressWarnings({ "unchecked" })
+	@Override
 	public <X> X unwrap(Date value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Timestamp.class.isAssignableFrom( type ) ) {
 			final Timestamp rtn = Timestamp.class.isInstance( value )
 					? ( Timestamp ) value
 					: new Timestamp( value.getTime() );
 			return (X) rtn;
 		}
 		if ( java.sql.Date.class.isAssignableFrom( type ) ) {
 			final java.sql.Date rtn = java.sql.Date.class.isInstance( value )
 					? ( java.sql.Date ) value
 					: new java.sql.Date( value.getTime() );
 			return (X) rtn;
 		}
 		if ( java.sql.Time.class.isAssignableFrom( type ) ) {
 			final java.sql.Time rtn = java.sql.Time.class.isInstance( value )
 					? ( java.sql.Time ) value
 					: new java.sql.Time( value.getTime() );
 			return (X) rtn;
 		}
 		if ( Date.class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( Calendar.class.isAssignableFrom( type ) ) {
 			final GregorianCalendar cal = new GregorianCalendar();
 			cal.setTimeInMillis( value.getTime() );
 			return (X) cal;
 		}
 		if ( Long.class.isAssignableFrom( type ) ) {
 			return (X) Long.valueOf( value.getTime() );
 		}
 		throw unknownUnwrap( type );
 	}
-
-	@SuppressWarnings({ "UnnecessaryUnboxing" })
+	@Override
 	public <X> Date wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Timestamp.class.isInstance( value ) ) {
 			return (Timestamp) value;
 		}
 
 		if ( Long.class.isInstance( value ) ) {
-			return new Timestamp( ( (Long) value ).longValue() );
+			return new Timestamp( (Long) value );
 		}
 
 		if ( Calendar.class.isInstance( value ) ) {
 			return new Timestamp( ( (Calendar) value ).getTimeInMillis() );
 		}
 
 		if ( Date.class.isInstance( value ) ) {
 			return (Date) value;
 		}
 
 		throw unknownWrap( value.getClass() );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/LongTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/LongTypeDescriptor.java
index c881386140..e2ab576119 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/LongTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/LongTypeDescriptor.java
@@ -1,102 +1,102 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 
 import java.math.BigDecimal;
 import java.math.BigInteger;
 
 import org.hibernate.type.descriptor.WrapperOptions;
 
 /**
  * Descriptor for {@link Long} handling.
  *
  * @author Steve Ebersole
  */
 public class LongTypeDescriptor extends AbstractTypeDescriptor<Long> {
 	public static final LongTypeDescriptor INSTANCE = new LongTypeDescriptor();
 
 	public LongTypeDescriptor() {
 		super( Long.class );
 	}
-
+	@Override
 	public String toString(Long value) {
 		return value == null ? null : value.toString();
 	}
-
+	@Override
 	public Long fromString(String string) {
 		return Long.valueOf( string );
 	}
 
 	@SuppressWarnings({ "unchecked" })
+	@Override
 	public <X> X unwrap(Long value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Long.class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( Byte.class.isAssignableFrom( type ) ) {
 			return (X) Byte.valueOf( value.byteValue() );
 		}
 		if ( Short.class.isAssignableFrom( type ) ) {
 			return (X) Short.valueOf( value.shortValue() );
 		}
 		if ( Integer.class.isAssignableFrom( type ) ) {
 			return (X) Integer.valueOf( value.intValue() );
 		}
 		if ( Double.class.isAssignableFrom( type ) ) {
 			return (X) Double.valueOf( value.doubleValue() );
 		}
 		if ( Float.class.isAssignableFrom( type ) ) {
 			return (X) Float.valueOf( value.floatValue() );
 		}
 		if ( BigInteger.class.isAssignableFrom( type ) ) {
 			return (X) BigInteger.valueOf( value );
 		}
 		if ( BigDecimal.class.isAssignableFrom( type ) ) {
 			return (X) BigDecimal.valueOf( value );
 		}
 		if ( String.class.isAssignableFrom( type ) ) {
 			return (X) value.toString();
 		}
 		throw unknownUnwrap( type );
 	}
-
-	@SuppressWarnings({ "UnnecessaryBoxing" })
+	@Override
 	public <X> Long wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Long.class.isInstance( value ) ) {
 			return (Long) value;
 		}
 		if ( Number.class.isInstance( value ) ) {
-			return Long.valueOf( ( (Number) value ).longValue() );
+			return ( (Number) value ).longValue();
 		}
 		else if ( String.class.isInstance( value ) ) {
 			return Long.valueOf( ( (String) value ) );
 		}
 		throw unknownWrap( value.getClass() );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/ShortTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/ShortTypeDescriptor.java
index d914554c40..722259542e 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/ShortTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/java/ShortTypeDescriptor.java
@@ -1,92 +1,92 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.java;
 import org.hibernate.type.descriptor.WrapperOptions;
 
 /**
  * Descriptor for {@link Short} handling.
  *
  * @author Steve Ebersole
  */
 public class ShortTypeDescriptor extends AbstractTypeDescriptor<Short> {
 	public static final ShortTypeDescriptor INSTANCE = new ShortTypeDescriptor();
 
 	public ShortTypeDescriptor() {
 		super( Short.class );
 	}
-
+	@Override
 	public String toString(Short value) {
 		return value == null ? null : value.toString();
 	}
-
+	@Override
 	public Short fromString(String string) {
 		return Short.valueOf( string );
 	}
 
 	@SuppressWarnings({ "unchecked" })
+	@Override
 	public <X> X unwrap(Short value, Class<X> type, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Short.class.isAssignableFrom( type ) ) {
 			return (X) value;
 		}
 		if ( Byte.class.isAssignableFrom( type ) ) {
 			return (X) Byte.valueOf( value.byteValue() );
 		}
 		if ( Integer.class.isAssignableFrom( type ) ) {
 			return (X) Integer.valueOf( value.intValue() );
 		}
 		if ( Long.class.isAssignableFrom( type ) ) {
 			return (X) Long.valueOf( value.longValue() );
 		}
 		if ( Double.class.isAssignableFrom( type ) ) {
 			return (X) Double.valueOf( value.doubleValue() );
 		}
 		if ( Float.class.isAssignableFrom( type ) ) {
 			return (X) Float.valueOf( value.floatValue() );
 		}
 		if ( String.class.isAssignableFrom( type ) ) {
 			return (X) value.toString();
 		}
 		throw unknownUnwrap( type );
 	}
-
-	@SuppressWarnings({ "UnnecessaryBoxing" })
+	@Override
 	public <X> Short wrap(X value, WrapperOptions options) {
 		if ( value == null ) {
 			return null;
 		}
 		if ( Short.class.isInstance( value ) ) {
 			return (Short) value;
 		}
 		if ( Number.class.isInstance( value ) ) {
-			return Short.valueOf( ( (Number) value ).shortValue() );
+			return ( (Number) value ).shortValue();
 		}
 		if ( String.class.isInstance( value ) ) {
 			return Short.valueOf( ( (String) value ) );
 		}
 		throw unknownWrap( value.getClass() );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/JdbcTypeFamilyInformation.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/JdbcTypeFamilyInformation.java
index 670cf7b3b4..e6799296e0 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/JdbcTypeFamilyInformation.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/JdbcTypeFamilyInformation.java
@@ -1,75 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.sql;
 
 import java.sql.Types;
 import java.util.concurrent.ConcurrentHashMap;
 
 /**
  * Information pertaining to JDBC type families.
  *
  * @author Steve Ebersole
  */
 public class JdbcTypeFamilyInformation {
 	public static final JdbcTypeFamilyInformation INSTANCE = new JdbcTypeFamilyInformation();
 
 	// todo : make Family non-enum so it can be expanded by Dialects?
 
 	public static enum Family {
 		BINARY( Types.BINARY, Types.VARBINARY, Types.LONGVARBINARY ),
 		NUMERIC( Types.BIGINT, Types.DECIMAL, Types.DOUBLE, Types.FLOAT, Types.INTEGER, Types.NUMERIC, Types.REAL, Types.SMALLINT, Types.TINYINT ),
 		CHARACTER( Types.CHAR, Types.LONGNVARCHAR, Types.LONGVARCHAR, Types.NCHAR, Types.NVARCHAR, Types.VARCHAR ),
 		DATETIME( Types.DATE, Types.TIME, Types.TIMESTAMP ),
 		CLOB( Types.CLOB, Types.NCLOB );
 
 		private final int[] typeCodes;
 
-		@SuppressWarnings("UnnecessaryBoxing")
 		private Family(int... typeCodes) {
 			this.typeCodes = typeCodes;
 
-			for ( int typeCode : typeCodes ) {
-				JdbcTypeFamilyInformation.INSTANCE.typeCodeToFamilyMap.put( Integer.valueOf( typeCode ), this );
+			for ( final int typeCode : typeCodes ) {
+				JdbcTypeFamilyInformation.INSTANCE.typeCodeToFamilyMap.put( typeCode, this );
 			}
 		}
 
 		public int[] getTypeCodes() {
 			return typeCodes;
 		}
 	}
 
 	private ConcurrentHashMap<Integer,Family> typeCodeToFamilyMap = new ConcurrentHashMap<Integer, Family>();
 
 	/**
 	 * Will return {@code null} if no match is found.
 	 *
 	 * @param typeCode The JDBC type code.
 	 *
 	 * @return The family of datatypes the type code belongs to, or {@code null} if it belongs to no known families.
 	 */
-	@SuppressWarnings("UnnecessaryBoxing")
 	public Family locateJdbcTypeFamilyByTypeCode(int typeCode) {
 		return typeCodeToFamilyMap.get( Integer.valueOf( typeCode ) );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/JdbcTypeJavaClassMappings.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/JdbcTypeJavaClassMappings.java
index d7dd1c7cbd..9d894b5343 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/JdbcTypeJavaClassMappings.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/JdbcTypeJavaClassMappings.java
@@ -1,134 +1,132 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.sql;
 
 import java.math.BigDecimal;
 import java.sql.Blob;
 import java.sql.Clob;
 import java.sql.Date;
 import java.sql.Ref;
 import java.sql.Struct;
 import java.sql.Time;
 import java.sql.Timestamp;
 import java.sql.Types;
 import java.util.Calendar;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.mapping.Array;
 
 /**
  * Presents recommended {@literal JDCB typecode <-> Java Class} mappings.  Currently the recommendations
  * contained here come from the JDBC spec itself, as outlined at <a href="http://docs.oracle.com/javase/1.5.0/docs/guide/jdbc/getstart/mapping.html#1034737"/>
  * Eventually, the plan is to have {@link org.hibernate.dialect.Dialect} contribute this information.
  *
  * @author Steve Ebersole
  */
 public class JdbcTypeJavaClassMappings {
 	private static final Logger log = Logger.getLogger( JdbcTypeJavaClassMappings.class );
 
 	private static final ConcurrentHashMap<Class, Integer> javaClassToJdbcTypeCodeMap = buildJdbcJavaClassMappings();
 	private static final ConcurrentHashMap<Integer, Class> jdbcTypeCodeToJavaClassMap = transpose( javaClassToJdbcTypeCodeMap );
 
 	public static final JdbcTypeJavaClassMappings INSTANCE = new JdbcTypeJavaClassMappings();
 
 	private JdbcTypeJavaClassMappings() {
 	}
 
-	@SuppressWarnings("UnnecessaryUnboxing")
 	public int determineJdbcTypeCodeForJavaClass(Class cls) {
 		Integer typeCode = JdbcTypeJavaClassMappings.javaClassToJdbcTypeCodeMap.get( cls );
 		if ( typeCode != null ) {
 			return typeCode;
 		}
 
 		int specialCode = cls.hashCode();
 		log.debug(
 				"JDBC type code mapping not known for class [" + cls.getName() + "]; using custom code [" + specialCode + "]"
 		);
 		return specialCode;
 	}
 
-	@SuppressWarnings("UnnecessaryUnboxing")
 	public Class determineJavaClassForJdbcTypeCode(int typeCode) {
 		Class cls = jdbcTypeCodeToJavaClassMap.get( Integer.valueOf( typeCode ) );
 		if ( cls != null ) {
 			return cls;
 		}
 
 		log.debugf(
 				"Java Class mapping not known for JDBC type code [%s]; using java.lang.Object",
 				typeCode
 		);
 		return Object.class;
 	}
 
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	private static ConcurrentHashMap<Class, Integer> buildJdbcJavaClassMappings() {
 		ConcurrentHashMap<Class, Integer> jdbcJavaClassMappings = new ConcurrentHashMap<Class, Integer>();
 
 		// these mappings are the ones outlined specifically in the spec
 		jdbcJavaClassMappings.put( String.class, Types.VARCHAR );
 		jdbcJavaClassMappings.put( BigDecimal.class, Types.NUMERIC );
 		jdbcJavaClassMappings.put( Boolean.class, Types.BIT );
 		jdbcJavaClassMappings.put( Integer.class, Types.INTEGER );
 		jdbcJavaClassMappings.put( Long.class, Types.BIGINT );
 		jdbcJavaClassMappings.put( Float.class, Types.REAL );
 		jdbcJavaClassMappings.put( Double.class, Types.DOUBLE );
 		jdbcJavaClassMappings.put( byte[].class, Types.LONGVARBINARY );
 		jdbcJavaClassMappings.put( Date.class, Types.DATE );
 		jdbcJavaClassMappings.put( Time.class, Types.TIME );
 		jdbcJavaClassMappings.put( Timestamp.class, Types.TIMESTAMP );
 		jdbcJavaClassMappings.put( Blob.class, Types.BLOB );
 		jdbcJavaClassMappings.put( Clob.class, Types.CLOB );
 		jdbcJavaClassMappings.put( Array.class, Types.ARRAY );
 		jdbcJavaClassMappings.put( Struct.class, Types.STRUCT );
 		jdbcJavaClassMappings.put( Ref.class, Types.REF );
 		jdbcJavaClassMappings.put( Class.class, Types.JAVA_OBJECT );
 
 		// additional "common sense" registrations
 		jdbcJavaClassMappings.put( Character.class, Types.CHAR );
 		jdbcJavaClassMappings.put( char[].class, Types.VARCHAR );
 		jdbcJavaClassMappings.put( Character[].class, Types.VARCHAR );
 		jdbcJavaClassMappings.put( Byte[].class, Types.LONGVARBINARY );
 		jdbcJavaClassMappings.put( Date.class, Types.TIMESTAMP );
 		jdbcJavaClassMappings.put( Calendar.class, Types.TIMESTAMP );
 
 		return jdbcJavaClassMappings;
 	}
 
 	private static ConcurrentHashMap<Integer, Class> transpose(ConcurrentHashMap<Class, Integer> javaClassToJdbcTypeCodeMap) {
 		final ConcurrentHashMap<Integer, Class> transposed = new ConcurrentHashMap<Integer, Class>();
 
 		for ( Map.Entry<Class,Integer> entry : javaClassToJdbcTypeCodeMap.entrySet() ) {
 			transposed.put( entry.getValue(), entry.getKey() );
 		}
 
 		return transposed;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/SqlTypeDescriptorRegistry.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/SqlTypeDescriptorRegistry.java
index d9bceb0387..c0a6b1bbc7 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/SqlTypeDescriptorRegistry.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/SqlTypeDescriptorRegistry.java
@@ -1,156 +1,154 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.sql;
 
 import java.io.Serializable;
 import java.sql.CallableStatement;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.type.descriptor.JdbcTypeNameMapper;
 import org.hibernate.type.descriptor.ValueBinder;
 import org.hibernate.type.descriptor.ValueExtractor;
 import org.hibernate.type.descriptor.WrapperOptions;
 import org.hibernate.type.descriptor.java.JavaTypeDescriptor;
 
 /**
  * Basically a map from JDBC type code (int) -> {@link SqlTypeDescriptor}
  *
  * @author Steve Ebersole
  */
 public class SqlTypeDescriptorRegistry {
 	public static final SqlTypeDescriptorRegistry INSTANCE = new SqlTypeDescriptorRegistry();
 
 	private static final Logger log = Logger.getLogger( SqlTypeDescriptorRegistry.class );
 
 	private ConcurrentHashMap<Integer,SqlTypeDescriptor> descriptorMap = new ConcurrentHashMap<Integer, SqlTypeDescriptor>();
 
-	@SuppressWarnings("UnnecessaryBoxing")
 	public void addDescriptor(SqlTypeDescriptor sqlTypeDescriptor) {
-		descriptorMap.put( Integer.valueOf( sqlTypeDescriptor.getSqlType() ), sqlTypeDescriptor );
+		descriptorMap.put( sqlTypeDescriptor.getSqlType(), sqlTypeDescriptor );
 	}
 
-	@SuppressWarnings("UnnecessaryBoxing")
 	public SqlTypeDescriptor getDescriptor(int jdbcTypeCode) {
 		SqlTypeDescriptor descriptor = descriptorMap.get( Integer.valueOf( jdbcTypeCode ) );
 		if ( descriptor != null ) {
 			return descriptor;
 		}
 
 		if ( JdbcTypeNameMapper.isStandardTypeCode( jdbcTypeCode ) ) {
 			log.debugf(
 					"A standard JDBC type code [%s] was not defined in SqlTypeDescriptorRegistry",
 					jdbcTypeCode
 			);
 		}
 
 		// see if the typecode is part of a known type family...
 		JdbcTypeFamilyInformation.Family family = JdbcTypeFamilyInformation.INSTANCE.locateJdbcTypeFamilyByTypeCode( jdbcTypeCode );
 		if ( family != null ) {
 			for ( int potentialAlternateTypeCode : family.getTypeCodes() ) {
 				if ( potentialAlternateTypeCode != jdbcTypeCode ) {
 					final SqlTypeDescriptor potentialAlternateDescriptor = descriptorMap.get( Integer.valueOf( potentialAlternateTypeCode ) );
 					if ( potentialAlternateDescriptor != null ) {
 						// todo : add a SqlTypeDescriptor.canBeAssignedFrom method...
 						return potentialAlternateDescriptor;
 					}
 
 					if ( JdbcTypeNameMapper.isStandardTypeCode( potentialAlternateTypeCode ) ) {
 						log.debugf(
 								"A standard JDBC type code [%s] was not defined in SqlTypeDescriptorRegistry",
 								potentialAlternateTypeCode
 						);
 					}
 				}
 			}
 		}
 
 		// finally, create a new descriptor mapping to getObject/setObject for this type code...
 		final ObjectSqlTypeDescriptor fallBackDescriptor = new ObjectSqlTypeDescriptor( jdbcTypeCode );
 		addDescriptor( fallBackDescriptor );
 		return fallBackDescriptor;
 	}
 
 	public static class ObjectSqlTypeDescriptor implements SqlTypeDescriptor {
 		private final int jdbcTypeCode;
 
 		public ObjectSqlTypeDescriptor(int jdbcTypeCode) {
 			this.jdbcTypeCode = jdbcTypeCode;
 		}
 
 		@Override
 		public int getSqlType() {
 			return jdbcTypeCode;
 		}
 
 		@Override
 		public boolean canBeRemapped() {
 			return true;
 		}
 
 		@Override
 		public <X> ValueBinder<X> getBinder(JavaTypeDescriptor<X> javaTypeDescriptor) {
 			if ( Serializable.class.isAssignableFrom( javaTypeDescriptor.getJavaTypeClass() ) ) {
 				return VarbinaryTypeDescriptor.INSTANCE.getBinder( javaTypeDescriptor );
 			}
 
 			return new BasicBinder<X>( javaTypeDescriptor, this ) {
 				@Override
 				protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options)
 						throws SQLException {
 					st.setObject( index, value, jdbcTypeCode );
 				}
 			};
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public ValueExtractor getExtractor(JavaTypeDescriptor javaTypeDescriptor) {
 			if ( Serializable.class.isAssignableFrom( javaTypeDescriptor.getJavaTypeClass() ) ) {
 				return VarbinaryTypeDescriptor.INSTANCE.getExtractor( javaTypeDescriptor );
 			}
 
 			return new BasicExtractor( javaTypeDescriptor, this ) {
 				@Override
 				protected Object doExtract(ResultSet rs, String name, WrapperOptions options) throws SQLException {
 					return rs.getObject( name );
 				}
 
 				@Override
 				protected Object doExtract(CallableStatement statement, int index, WrapperOptions options) throws SQLException {
 					return statement.getObject( index );
 				}
 
 				@Override
 				protected Object doExtract(CallableStatement statement, String name, WrapperOptions options) throws SQLException {
 					return statement.getObject( name );
 				}
 			};
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/TimestampTypeDescriptor.java b/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/TimestampTypeDescriptor.java
index e71d7f17ba..424e2107df 100644
--- a/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/TimestampTypeDescriptor.java
+++ b/hibernate-core/src/main/java/org/hibernate/type/descriptor/sql/TimestampTypeDescriptor.java
@@ -1,89 +1,89 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.type.descriptor.sql;
 
 import java.sql.CallableStatement;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Timestamp;
 import java.sql.Types;
 
 import org.hibernate.type.descriptor.ValueBinder;
 import org.hibernate.type.descriptor.ValueExtractor;
 import org.hibernate.type.descriptor.WrapperOptions;
 import org.hibernate.type.descriptor.java.JavaTypeDescriptor;
 
 /**
  * Descriptor for {@link Types#TIMESTAMP TIMESTAMP} handling.
  *
  * @author Steve Ebersole
  */
 public class TimestampTypeDescriptor implements SqlTypeDescriptor {
 	public static final TimestampTypeDescriptor INSTANCE = new TimestampTypeDescriptor();
 
 	public TimestampTypeDescriptor() {
 		SqlTypeDescriptorRegistry.INSTANCE.addDescriptor( this );
 	}
 
 	@Override
 	public int getSqlType() {
 		return Types.TIMESTAMP;
 	}
 
 	@Override
 	public boolean canBeRemapped() {
 		return true;
 	}
 
 	@Override
 	public <X> ValueBinder<X> getBinder(final JavaTypeDescriptor<X> javaTypeDescriptor) {
 		return new BasicBinder<X>( javaTypeDescriptor, this ) {
 			@Override
 			protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
 				st.setTimestamp( index, javaTypeDescriptor.unwrap( value, Timestamp.class, options ) );
 			}
 		};
 	}
 
 	@Override
 	public <X> ValueExtractor<X> getExtractor(final JavaTypeDescriptor<X> javaTypeDescriptor) {
 		return new BasicExtractor<X>( javaTypeDescriptor, this ) {
 			@Override
 			protected X doExtract(ResultSet rs, String name, WrapperOptions options) throws SQLException {
 				return javaTypeDescriptor.wrap( rs.getTimestamp( name ), options );
 			}
 
 			@Override
 			protected X doExtract(CallableStatement statement, int index, WrapperOptions options) throws SQLException {
 				return javaTypeDescriptor.wrap( statement.getTimestamp( index ), options );
 			}
 
 			@Override
 			protected X doExtract(CallableStatement statement, String name, WrapperOptions options) throws SQLException {
 				return javaTypeDescriptor.wrap( statement.getTimestamp( name ), options );
 			}
 		};
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/usertype/ParameterizedType.java b/hibernate-core/src/main/java/org/hibernate/usertype/ParameterizedType.java
index 1a64dc8d4c..d57ca64ea3 100644
--- a/hibernate-core/src/main/java/org/hibernate/usertype/ParameterizedType.java
+++ b/hibernate-core/src/main/java/org/hibernate/usertype/ParameterizedType.java
@@ -1,43 +1,43 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.usertype;
 import java.util.Properties;
 
 /**
  * Support for parameterizable types. A UserType or CustomUserType may be
  * made parameterizable by implementing this interface. Parameters for a
  * type may be set by using a nested type element for the property element
  * in the mapping file, or by defining a typedef.
  *
  * @author Michael Gloegl
  */
 public interface ParameterizedType {
 
 	/**
 	 * Gets called by Hibernate to pass the configured type parameters to
 	 * the implementation.
 	 */
 	public void setParameterValues(Properties parameters);
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/dialect/Mocks.java b/hibernate-core/src/test/java/org/hibernate/dialect/Mocks.java
index 8f5f371af3..7fbe67cc50 100644
--- a/hibernate-core/src/test/java/org/hibernate/dialect/Mocks.java
+++ b/hibernate-core/src/test/java/org/hibernate/dialect/Mocks.java
@@ -1,159 +1,158 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.SQLException;
 
 /**
  * @author Steve Ebersole
  */
-@SuppressWarnings( {"UnnecessaryBoxing"})
 public class Mocks {
 
 	public static Connection createConnection(String databaseName, int majorVersion) {
 		return createConnection( databaseName, majorVersion, -9999 );
 	}
 
 	public static Connection createConnection(String databaseName, int majorVersion, int minorVersion) {
 		DatabaseMetaDataHandler metadataHandler = new DatabaseMetaDataHandler( databaseName, majorVersion, minorVersion );
 		ConnectionHandler connectionHandler = new ConnectionHandler();
 
 		DatabaseMetaData metadataProxy = ( DatabaseMetaData ) Proxy.newProxyInstance(
 				ClassLoader.getSystemClassLoader(),
 				new Class[] { DatabaseMetaData.class },
 				metadataHandler
 		);
 
 		Connection connectionProxy = ( Connection ) Proxy.newProxyInstance(
 				ClassLoader.getSystemClassLoader(),
 				new Class[] { Connection.class },
 				connectionHandler
 		);
 
 		metadataHandler.setConnectionProxy( connectionProxy );
 		connectionHandler.setMetadataProxy( metadataProxy );
 
 		return connectionProxy;
 	}
 
 	private static class ConnectionHandler implements InvocationHandler {
 		private DatabaseMetaData metadataProxy;
 
 		public void setMetadataProxy(DatabaseMetaData metadataProxy) {
 			this.metadataProxy = metadataProxy;
 		}
 
 		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 			final String methodName = method.getName();
 			if ( "getMetaData".equals( methodName ) ) {
 				return metadataProxy;
 			}
 
 			if ( "toString".equals( methodName ) ) {
 				return "Connection proxy [@" + hashCode() + "]";
 			}
 
 			if ( "hashCode".equals( methodName ) ) {
 				return Integer.valueOf( this.hashCode() );
 			}
 
 			if ( canThrowSQLException( method ) ) {
 				throw new SQLException();
 			}
 			else {
 				throw new UnsupportedOperationException();
 			}
 		}
 	}
 
 	private static class DatabaseMetaDataHandler implements InvocationHandler {
 		private final String databaseName;
 		private final int majorVersion;
 		private final int minorVersion;
 
 		private Connection connectionProxy;
 
 		public void setConnectionProxy(Connection connectionProxy) {
 			this.connectionProxy = connectionProxy;
 		}
 
 		private DatabaseMetaDataHandler(String databaseName, int majorVersion) {
 			this( databaseName, majorVersion, -9999 );
 		}
 
 		private DatabaseMetaDataHandler(String databaseName, int majorVersion, int minorVersion) {
 			this.databaseName = databaseName;
 			this.majorVersion = majorVersion;
 			this.minorVersion = minorVersion;
 		}
 
 		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 			final String methodName = method.getName();
 			if ( "getDatabaseProductName".equals( methodName ) ) {
 				return databaseName;
 			}
 
 			if ( "getDatabaseMajorVersion".equals( methodName ) ) {
 				return Integer.valueOf( majorVersion );
 			}
 
 			if ( "getDatabaseMinorVersion".equals( methodName ) ) {
 				return Integer.valueOf( minorVersion );
 			}
 
 			if ( "getConnection".equals( methodName ) ) {
 				return connectionProxy;
 			}
 
 			if ( "toString".equals( methodName ) ) {
 				return "DatabaseMetaData proxy [db-name=" + databaseName + ", version=" + majorVersion + "]";
 			}
 
 			if ( "hashCode".equals( methodName ) ) {
 				return Integer.valueOf( this.hashCode() );
 			}
 
 			if ( canThrowSQLException( method ) ) {
 				throw new SQLException();
 			}
 			else {
 				throw new UnsupportedOperationException();
 			}
 		}
 	}
 
 	private static boolean canThrowSQLException(Method method) {
 		final Class[] exceptions = method.getExceptionTypes();
 		for ( Class exceptionType : exceptions ) {
 			if ( SQLException.class.isAssignableFrom( exceptionType ) ) {
 				return true;
 			}
 		}
 		return false;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/id/BigDecimalHolderTest.java b/hibernate-core/src/test/java/org/hibernate/id/BigDecimalHolderTest.java
index c87af14445..0ac2380c21 100644
--- a/hibernate-core/src/test/java/org/hibernate/id/BigDecimalHolderTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/id/BigDecimalHolderTest.java
@@ -1,34 +1,34 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.id;
 import java.math.BigDecimal;
 
 /**
  * @author Steve Ebersole
  */
 public class BigDecimalHolderTest extends AbstractHolderTest {
 	protected IntegralDataTypeHolder makeHolder() {
 		return IdentifierGeneratorHelper.getIntegralDataTypeHolder( BigDecimal.class );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/id/SequenceHiLoGeneratorNoIncrementTest.java b/hibernate-core/src/test/java/org/hibernate/id/SequenceHiLoGeneratorNoIncrementTest.java
index 97fd6f959e..763d5fcbc3 100644
--- a/hibernate-core/src/test/java/org/hibernate/id/SequenceHiLoGeneratorNoIncrementTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/id/SequenceHiLoGeneratorNoIncrementTest.java
@@ -1,178 +1,178 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.id;
 
 import static org.junit.Assert.assertEquals;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Properties;
 
 import org.hibernate.Session;
 import org.hibernate.testing.env.TestingDatabaseInfo;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.cfg.ObjectNameNormalizer;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.SessionImpl;
 import org.hibernate.jdbc.Work;
 import org.hibernate.mapping.SimpleAuxiliaryDatabaseObject;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.testing.ServiceRegistryBuilder;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 import org.hibernate.type.StandardBasicTypes;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 /**
  * I went back to 3.3 source and grabbed the code/logic as it existed back then and crafted this
  * unit test so that we can make sure the value keep being generated in the expected manner
  *
  * @author Steve Ebersole
  */
 @SuppressWarnings({ "deprecation" })
 public class SequenceHiLoGeneratorNoIncrementTest extends BaseUnitTestCase {
 	private static final String TEST_SEQUENCE = "test_sequence";
 
 	private Configuration cfg;
 	private ServiceRegistry serviceRegistry;
 	private SessionFactoryImplementor sessionFactory;
 	private SequenceHiLoGenerator generator;
     private SessionImplementor session;
 
 	@Before
 	public void setUp() throws Exception {
 		Properties properties = new Properties();
 		properties.setProperty( SequenceGenerator.SEQUENCE, TEST_SEQUENCE );
 		properties.setProperty( SequenceHiLoGenerator.MAX_LO, "0" ); // JPA allocationSize of 1
 		properties.put(
 				PersistentIdentifierGenerator.IDENTIFIER_NORMALIZER,
 				new ObjectNameNormalizer() {
 					@Override
 					protected boolean isUseQuotedIdentifiersGlobally() {
 						return false;
 					}
 
 					@Override
 					protected NamingStrategy getNamingStrategy() {
 						return cfg.getNamingStrategy();
 					}
 				}
 		);
 
 		Dialect dialect = TestingDatabaseInfo.DIALECT;
 
 		generator = new SequenceHiLoGenerator();
 		generator.configure( StandardBasicTypes.LONG, properties, dialect );
 
 		cfg = TestingDatabaseInfo.buildBaseConfiguration()
 				.setProperty( Environment.HBM2DDL_AUTO, "create-drop" );
 		cfg.addAuxiliaryDatabaseObject(
 				new SimpleAuxiliaryDatabaseObject(
 						generator.sqlCreateStrings( dialect )[0],
 						generator.sqlDropStrings( dialect )[0]
 				)
 		);
 
 		serviceRegistry = ServiceRegistryBuilder.buildServiceRegistry( cfg.getProperties() );
 		sessionFactory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
 	}
 
 	@After
 	public void tearDown() throws Exception {
         if(session != null && !session.isClosed()) {
             ((Session)session).close();
         }
 		if ( sessionFactory != null ) {
 			sessionFactory.close();
 		}
 		if ( serviceRegistry != null ) {
 			ServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 
 	@Test
 	public void testHiLoAlgorithm() {
 		session = (SessionImpl) sessionFactory.openSession();
 		((Session)session).beginTransaction();
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// initially sequence should be uninitialized
 		assertEquals( 0L, extractSequenceValue( (session) ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// historically the hilo generators skipped the initial block of values;
 		// 		so the first generated id value is maxlo + 1, here be 4
 		Long generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 1L, generatedValue.longValue() );
 		// which should also perform the first read on the sequence which should set it to its "start with" value (1)
 		assertEquals( 1L, extractSequenceValue( (session) ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 2L, generatedValue.longValue() );
 		assertEquals( 2L, extractSequenceValue( (session) ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 3L, generatedValue.longValue() );
 		assertEquals( 3L, extractSequenceValue( (session) ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 4L, generatedValue.longValue() );
 		assertEquals( 4L, extractSequenceValue( (session) ) );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		generatedValue = (Long) generator.generate( session, null );
 		assertEquals( 5L, generatedValue.longValue() );
 		assertEquals( 5L, extractSequenceValue( (session) ) );
 
 		((Session)session).getTransaction().commit();
 		((Session)session).close();
 	}
 
 	private long extractSequenceValue(final SessionImplementor session) {
 		class WorkImpl implements Work {
 			private long value;
 			public void execute(Connection connection) throws SQLException {
 				
 				PreparedStatement query = session.getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( "select currval('" + TEST_SEQUENCE + "');" );
 				ResultSet resultSet = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( query );
 				resultSet.next();
 				value = resultSet.getLong( 1 );
 			}
 		}
 		WorkImpl work = new WorkImpl();
 		( (Session) session ).doWork( work );
 		return work.value;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/loader/plan/spi/LoadPlanBuilderTest.java b/hibernate-core/src/test/java/org/hibernate/loader/plan/spi/LoadPlanBuilderTest.java
index a5f6f84b2e..28bb284be9 100644
--- a/hibernate-core/src/test/java/org/hibernate/loader/plan/spi/LoadPlanBuilderTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/loader/plan/spi/LoadPlanBuilderTest.java
@@ -1,141 +1,141 @@
 /*
  * jDocBook, processing of DocBook sources
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.loader.plan.spi;
 
 import javax.persistence.CascadeType;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.JoinColumn;
 import javax.persistence.ManyToOne;
 import javax.persistence.OneToMany;
 import java.util.List;
 
 import org.hibernate.engine.spi.CascadingActions;
 import org.hibernate.engine.spi.LoadQueryInfluencers;
 import org.hibernate.loader.plan.internal.CascadeLoadPlanBuilderStrategy;
 import org.hibernate.loader.plan.internal.SingleRootReturnLoadPlanBuilderStrategy;
 import org.hibernate.loader.plan.spi.build.LoadPlanBuilder;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.hibernate.testing.junit4.ExtraAssertions;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 
 /**
  * @author Steve Ebersole
  */
 public class LoadPlanBuilderTest extends BaseCoreFunctionalTestCase {
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class[] { Message.class, Poster.class };
 	}
 
 	@Test
 	public void testSimpleBuild() {
 		EntityPersister ep = (EntityPersister) sessionFactory().getClassMetadata(Message.class);
 		SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
 				sessionFactory(),
 				LoadQueryInfluencers.NONE
 		);
 		LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, ep );
 		assertFalse( plan.hasAnyScalarReturns() );
 		assertEquals( 1, plan.getReturns().size() );
 		Return rtn = plan.getReturns().get( 0 );
 		EntityReturn entityReturn = ExtraAssertions.assertTyping( EntityReturn.class, rtn );
 		assertNotNull( entityReturn.getFetches() );
 		assertEquals( 1, entityReturn.getFetches().length );
 		Fetch fetch = entityReturn.getFetches()[0];
 		EntityFetch entityFetch = ExtraAssertions.assertTyping( EntityFetch.class, fetch );
 		assertNotNull( entityFetch.getFetches() );
 		assertEquals( 0, entityFetch.getFetches().length );
 	}
 
 	@Test
 	public void testCascadeBasedBuild() {
 		EntityPersister ep = (EntityPersister) sessionFactory().getClassMetadata(Message.class);
 		CascadeLoadPlanBuilderStrategy strategy = new CascadeLoadPlanBuilderStrategy(
 				CascadingActions.MERGE,
 				sessionFactory(),
 				LoadQueryInfluencers.NONE
 		);
 		LoadPlan plan = LoadPlanBuilder.buildRootEntityLoadPlan( strategy, ep );
 		assertFalse( plan.hasAnyScalarReturns() );
 		assertEquals( 1, plan.getReturns().size() );
 		Return rtn = plan.getReturns().get( 0 );
 		EntityReturn entityReturn = ExtraAssertions.assertTyping( EntityReturn.class, rtn );
 		assertNotNull( entityReturn.getFetches() );
 		assertEquals( 1, entityReturn.getFetches().length );
 		Fetch fetch = entityReturn.getFetches()[0];
 		EntityFetch entityFetch = ExtraAssertions.assertTyping( EntityFetch.class, fetch );
 		assertNotNull( entityFetch.getFetches() );
 		assertEquals( 0, entityFetch.getFetches().length );
 	}
 
 	@Test
 	public void testCollectionInitializerCase() {
 		CollectionPersister cp = sessionFactory().getCollectionPersister( Poster.class.getName() + ".messages" );
 		SingleRootReturnLoadPlanBuilderStrategy strategy = new SingleRootReturnLoadPlanBuilderStrategy(
 				sessionFactory(),
 				LoadQueryInfluencers.NONE
 		);
 		LoadPlan plan = LoadPlanBuilder.buildRootCollectionLoadPlan( strategy, cp );
 		assertFalse( plan.hasAnyScalarReturns() );
 		assertEquals( 1, plan.getReturns().size() );
 		Return rtn = plan.getReturns().get( 0 );
 		CollectionReturn collectionReturn = ExtraAssertions.assertTyping( CollectionReturn.class, rtn );
 
 		assertNotNull( collectionReturn.getElementGraph().getFetches() );
 		assertEquals( 1, collectionReturn.getElementGraph().getFetches().length ); // the collection elements are fetched
 		Fetch fetch = collectionReturn.getElementGraph().getFetches()[0];
 		EntityFetch entityFetch = ExtraAssertions.assertTyping( EntityFetch.class, fetch );
 		assertNotNull( entityFetch.getFetches() );
 		assertEquals( 0, entityFetch.getFetches().length );
 	}
 
 	@Entity( name = "Message" )
 	public static class Message {
 		@Id
 		private Integer mid;
 		private String msgTxt;
 		@ManyToOne( cascade = CascadeType.MERGE )
 		@JoinColumn
 		private Poster poster;
 	}
 
 	@Entity( name = "Poster" )
 	public static class Poster {
 		@Id
 		private Integer pid;
 		private String name;
 		@OneToMany(mappedBy = "poster")
 		private List<Message> messages;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/package-info.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/package-info.java
index c4b90dd158..95b316c2d1 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/package-info.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/package-info.java
@@ -1,4 +1,4 @@
 @GenericGenerator(name = "myGenerator", strategy = "sequence")
 package org.hibernate.metamodel.binding;
 
-import org.hibernate.annotations.GenericGenerator;
\ No newline at end of file
+import org.hibernate.annotations.GenericGenerator;
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/GenericTypeDiscoveryTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/GenericTypeDiscoveryTest.java
index 2d536b02ca..4d29116a91 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/GenericTypeDiscoveryTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/GenericTypeDiscoveryTest.java
@@ -1,253 +1,253 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.util;
 
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.ManyToOne;
 import javax.persistence.MappedSuperclass;
 
 import org.junit.Test;
 
 /**
  * @author Hardy Ferentschik
  */
 public class GenericTypeDiscoveryTest extends BaseAnnotationIndexTestCase {
 
 	@Test
 	public void testGenericClassHierarchy() {
 //		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies(
 //				Paper.class,
 //				Stuff.class,
 //				Item.class,
 //				PricedStuff.class
 //		);
 //		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
 //
 //		Iterator<EntityClass> iter = hierarchies.iterator().next().iterator();
 //		ConfiguredClass configuredClass = iter.next();
 //		ClassInfo info = configuredClass.getClassInfo();
 //		assertEquals( "wrong class", DotName.createSimple( Stuff.class.getName() ), info.name() );
 //		MappedAttribute property = configuredClass.getMappedAttribute( "value" );
 //		assertEquals( Price.class, property.getJavaType() );
 //
 //		assertTrue( iter.hasNext() );
 //		configuredClass = iter.next();
 //		info = configuredClass.getClassInfo();
 //		assertEquals( "wrong class", DotName.createSimple( PricedStuff.class.getName() ), info.name() );
 //		assertFalse(
 //				"PricedStuff should not mapped properties", configuredClass.getSimpleAttributes().iterator().hasNext()
 //		);
 //
 //		assertTrue( iter.hasNext() );
 //		configuredClass = iter.next();
 //		info = configuredClass.getClassInfo();
 //		assertEquals( "wrong class", DotName.createSimple( Item.class.getName() ), info.name() );
 //		// properties are alphabetically ordered!
 //		property = configuredClass.getMappedAttribute( "owner" );
 //		assertEquals( SomeGuy.class, property.getJavaType() );
 //		property = configuredClass.getMappedAttribute( "type" );
 //		assertEquals( PaperType.class, property.getJavaType() );
 //
 //		assertTrue( iter.hasNext() );
 //		configuredClass = iter.next();
 //		info = configuredClass.getClassInfo();
 //		assertEquals( "wrong class", DotName.createSimple( Paper.class.getName() ), info.name() );
 //		assertFalse( "Paper should not mapped properties", configuredClass.getSimpleAttributes().iterator().hasNext() );
 //
 //		assertFalse( iter.hasNext() );
 	}
 
 	@Test
 	public void testUnresolvedType() {
 //		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies( UnresolvedType.class );
 //		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
 	}
 
 	@MappedSuperclass
 	public class Stuff<Value> {
 		private Value value;
 
 		@ManyToOne
 		public Value getValue() {
 			return value;
 		}
 
 		public void setValue(Value value) {
 			this.value = value;
 		}
 	}
 
 	@MappedSuperclass
 	public class PricedStuff extends Stuff<Price> {
 	}
 
 	@MappedSuperclass
 	public class Item<Type, Owner> extends PricedStuff {
 		private Integer id;
 		private String name;
 		private Type type;
 		private Owner owner;
 
 		@Id
 		@GeneratedValue
 		public Integer getId() {
 			return id;
 		}
 
 		public void setId(Integer id) {
 			this.id = id;
 		}
 
 		public String getName() {
 			return name;
 		}
 
 		public void setName(String name) {
 			this.name = name;
 		}
 
 		@ManyToOne
 		public Type getType() {
 			return type;
 		}
 
 		public void setType(Type type) {
 			this.type = type;
 		}
 
 		@ManyToOne
 		public Owner getOwner() {
 			return owner;
 		}
 
 		public void setOwner(Owner owner) {
 			this.owner = owner;
 		}
 	}
 
 	@Entity
 	public class Paper extends Item<PaperType, SomeGuy> {
 	}
 
 	@Entity
 	public class PaperType {
 		private Integer id;
 		private String name;
 
 		@Id
 		@GeneratedValue
 		public Integer getId() {
 			return id;
 		}
 
 		public void setId(Integer id) {
 			this.id = id;
 		}
 
 		public String getName() {
 			return name;
 		}
 
 		public void setName(String name) {
 			this.name = name;
 		}
 
 	}
 
 	@Entity
 	public class Price {
 		private Integer id;
 		private Double amount;
 		private String currency;
 
 		@Id
 		@GeneratedValue
 		public Integer getId() {
 			return id;
 		}
 
 		public void setId(Integer id) {
 			this.id = id;
 		}
 
 		public Double getAmount() {
 			return amount;
 		}
 
 		public void setAmount(Double amount) {
 			this.amount = amount;
 		}
 
 		public String getCurrency() {
 			return currency;
 		}
 
 		public void setCurrency(String currency) {
 			this.currency = currency;
 		}
 	}
 
 	@Entity
 	public class SomeGuy {
 		private Integer id;
 
 		@Id
 		@GeneratedValue
 		public Integer getId() {
 			return id;
 		}
 
 		public void setId(Integer id) {
 			this.id = id;
 		}
 	}
 
 	@Entity
 	public class UnresolvedType<T> {
 
 		private Integer id;
 		private T state;
 
 		@Id
 		@GeneratedValue
 		public Integer getId() {
 			return id;
 		}
 
 		public void setId(Integer id) {
 			this.id = id;
 		}
 
 		//@Type(type = "org.hibernate.test.annotations.generics.StateType")
 		public T getState() {
 			return state;
 		}
 
 		public void setState(T state) {
 			this.state = state;
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/TypeDiscoveryTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/TypeDiscoveryTest.java
index 40b4e66f67..2d2753440d 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/TypeDiscoveryTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/TypeDiscoveryTest.java
@@ -1,67 +1,67 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.util;
 
 import javax.persistence.Id;
 
 import org.junit.Test;
 
 import org.hibernate.annotations.Parameter;
 import org.hibernate.annotations.Type;
 
 /**
  * @author Hardy Ferentschik
  */
 public class TypeDiscoveryTest extends BaseAnnotationIndexTestCase {
 
 	@Test
 	public void testImplicitAndExplicitType() {
 //		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies( Entity.class );
 //		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
 //
 //		Iterator<EntityClass> iter = hierarchies.iterator().next().iterator();
 //		ConfiguredClass configuredClass = iter.next();
 //
 //		MappedAttribute property = configuredClass.getMappedAttribute( "id" );
 //		assertEquals( "Unexpected property type", int.class, property.getJavaType() );
 //
 //		property = configuredClass.getMappedAttribute( "string" );
 //		assertEquals( "Unexpected property type", String.class, property.getJavaType() );
 //
 //		property = configuredClass.getMappedAttribute( "customString" );
 //		assertEquals( "Unexpected property type", "my.custom.Type", property.getExplicitHibernateTypeName() );
 //
 //		Map<String, String> typeParameters = property.getExplicitHibernateTypeParameters();
 //		assertEquals( "There should be a type parameter", "bar", typeParameters.get( "foo" ) );
 	}
 
 	@javax.persistence.Entity
 	class Entity {
 		@Id
 		private int id;
 		private String string;
 		@Type(type = "my.custom.Type", parameters = { @Parameter(name = "foo", value = "bar") })
 		private String customString;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/sql/TemplateTest.java b/hibernate-core/src/test/java/org/hibernate/sql/TemplateTest.java
index 7421f5e554..2e1d5247ce 100644
--- a/hibernate-core/src/test/java/org/hibernate/sql/TemplateTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/sql/TemplateTest.java
@@ -1,273 +1,273 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.sql;
 
 import java.util.Collections;
 
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
 import org.hibernate.QueryException;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.function.SQLFunctionRegistry;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.persister.entity.PropertyMapping;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.sql.ordering.antlr.ColumnMapper;
 import org.hibernate.sql.ordering.antlr.ColumnReference;
 import org.hibernate.sql.ordering.antlr.SqlValueReference;
 import org.hibernate.testing.ServiceRegistryBuilder;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 import org.hibernate.type.Type;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Steve Ebersole
  */
 public class TemplateTest extends BaseUnitTestCase {
 	private static final PropertyMapping PROPERTY_MAPPING = new PropertyMapping() {
 		public String[] toColumns(String propertyName) throws QueryException, UnsupportedOperationException {
 			if ( "sql".equals( propertyName ) ) {
 				return new String[] { "sql" };
 			}
 			else if ( "component".equals( propertyName ) ) {
 				return new String[] { "comp_1", "comp_2" };
 			}
 			else if ( "component.prop1".equals( propertyName ) ) {
 				return new String[] { "comp_1" };
 			}
 			else if ( "component.prop2".equals( propertyName ) ) {
 				return new String[] { "comp_2" };
 			}
 			else if ( "property".equals( propertyName ) ) {
 				return new String[] { "prop" };
 			}
 			throw new QueryException( "could not resolve property: " + propertyName );
 		}
 
 		public Type toType(String propertyName) throws QueryException {
 			return null;
 		}
 
 		public String[] toColumns(String alias, String propertyName) throws QueryException {
 			return new String[0];
 		}
 
 		public Type getType() {
 			return null;
 		}
 	};
 
 	private static final ColumnMapper MAPPER = new ColumnMapper() {
 		public SqlValueReference[] map(String reference) {
 			final String[] columnNames = PROPERTY_MAPPING.toColumns( reference );
 			final SqlValueReference[] result = new SqlValueReference[ columnNames.length ];
 			int i = 0;
 			for ( final String columnName : columnNames ) {
 				result[i] = new ColumnReference() {
 					@Override
 					public String getColumnName() {
 						return columnName;
 					}
 				};
 				i++;
 			}
 			return result;
 		}
  	};
 
 	private static final Dialect DIALECT = new HSQLDialect();
 
 	private static final SQLFunctionRegistry FUNCTION_REGISTRY = new SQLFunctionRegistry( DIALECT, Collections.EMPTY_MAP );
 
 	private static SessionFactoryImplementor SESSION_FACTORY = null; // Required for ORDER BY rendering.
 
 	@BeforeClass
 	public static void buildSessionFactory() {
 		Configuration cfg = new Configuration();
 		cfg.setProperty( AvailableSettings.DIALECT, DIALECT.getClass().getName() );
 		ServiceRegistry serviceRegistry = ServiceRegistryBuilder.buildServiceRegistry( cfg.getProperties() );
 		SESSION_FACTORY = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
 	}
 
 	@AfterClass
 	public static void closeSessionFactory() {
 		if ( SESSION_FACTORY != null ) {
 			SESSION_FACTORY.close();
 			SESSION_FACTORY = null;
 		}
 	}
 
 	@Test
 	public void testSqlExtractFunction() {
 		String fragment = "extract( year from col )";
 		String template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
 
 		assertEquals( "extract(year from " + Template.TEMPLATE + ".col)", template );
 	}
 
 	@Test
 	public void testSqlTrimFunction() {
 		String fragment = "trim( col )";
 		String template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
 		assertEquals( "trim(" + Template.TEMPLATE + ".col)", template );
 
 		fragment = "trim( from col )";
 		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
 		assertEquals( "trim(from " + Template.TEMPLATE + ".col)", template );
 
 		fragment = "trim( both from col )";
 		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
 		assertEquals( "trim(both from " + Template.TEMPLATE + ".col)", template );
 
 		fragment = "trim( leading from col )";
 		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
 		assertEquals( "trim(leading from " + Template.TEMPLATE + ".col)", template );
 
 		fragment = "trim( TRAILING from col )";
 		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
 		assertEquals( "trim(TRAILING from " + Template.TEMPLATE + ".col)", template );
 
 		fragment = "trim( 'b' from col )";
 		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
 		assertEquals( "trim('b' from " + Template.TEMPLATE + ".col)", template );
 
 		fragment = "trim( both 'b' from col )";
 		template = Template.renderWhereStringTemplate( fragment, Template.TEMPLATE, DIALECT, FUNCTION_REGISTRY );
 		assertEquals( "trim(both 'b' from " + Template.TEMPLATE + ".col)", template );
 	}
 
 	@Test
 	public void testSQLReferences() {
 		String fragment = "sql asc, sql desc";
 		String template = doStandardRendering( fragment );
 
 		assertEquals( Template.TEMPLATE + ".sql asc, " + Template.TEMPLATE + ".sql desc", template );
 	}
 
 	@Test
 	public void testQuotedSQLReferences() {
 		String fragment = "`sql` asc, `sql` desc";
 		String template = doStandardRendering( fragment );
 
 		assertEquals( Template.TEMPLATE + ".\"sql\" asc, " + Template.TEMPLATE + ".\"sql\" desc", template );
 	}
 
 	@Test
 	public void testPropertyReference() {
 		String fragment = "property asc, property desc";
 		String template = doStandardRendering( fragment );
 
 		assertEquals( Template.TEMPLATE + ".prop asc, " + Template.TEMPLATE + ".prop desc", template );
 	}
 
 	@Test
 	public void testFunctionReference() {
 		String fragment = "upper(sql) asc, lower(sql) desc";
 		String template = doStandardRendering( fragment );
 
 		assertEquals( "upper(" + Template.TEMPLATE + ".sql) asc, lower(" + Template.TEMPLATE + ".sql) desc", template );
 	}
 
 	@Test
 	public void testQualifiedFunctionReference() {
 		String fragment = "qual.upper(property) asc, qual.lower(property) desc";
 		String template = doStandardRendering( fragment );
 
 		assertEquals( "qual.upper(" + Template.TEMPLATE + ".prop) asc, qual.lower(" + Template.TEMPLATE + ".prop) desc", template );
 	}
 
 	@Test
 	public void testDoubleQualifiedFunctionReference() {
 		String fragment = "qual1.qual2.upper(property) asc, qual1.qual2.lower(property) desc";
 		String template = doStandardRendering( fragment );
 
 		assertEquals( "qual1.qual2.upper(" + Template.TEMPLATE + ".prop) asc, qual1.qual2.lower(" + Template.TEMPLATE + ".prop) desc", template );
 	}
 
 	@Test
 	public void testFunctionWithPropertyReferenceAsParam() {
 		String fragment = "upper(property) asc, lower(property) desc";
 		String template = doStandardRendering( fragment );
 
 		assertEquals( "upper(" + Template.TEMPLATE + ".prop) asc, lower(" + Template.TEMPLATE + ".prop) desc", template );
 	}
 
 	@Test
 	public void testNestedFunctionReferences() {
 		String fragment = "upper(lower(sql)) asc, lower(upper(sql)) desc";
 		String template = doStandardRendering( fragment );
 
 		assertEquals( "upper(lower(" + Template.TEMPLATE + ".sql)) asc, lower(upper(" + Template.TEMPLATE + ".sql)) desc", template );
 	}
 
 	@Test
 	public void testComplexNestedFunctionReferences() {
 		String fragment = "mod(mod(sql,2),3) asc";
 		String template = doStandardRendering( fragment );
 
 		assertEquals( "mod(mod(" + Template.TEMPLATE + ".sql, 2), 3) asc", template );
 	}
 
 	@Test
 	public void testCollation() {
 		String fragment = "`sql` COLLATE my_collation, `sql` COLLATE your_collation";
 		String template = doStandardRendering( fragment );
 
 		assertEquals( Template.TEMPLATE + ".\"sql\" collate my_collation, " + Template.TEMPLATE + ".\"sql\" collate your_collation", template );
 	}
 
 	@Test
 	public void testCollationAndOrdering() {
 		String fragment = "sql COLLATE my_collation, upper(prop) COLLATE your_collation asc, `sql` desc";
 		String template = doStandardRendering( fragment );
 
 		assertEquals( Template.TEMPLATE + ".sql collate my_collation, upper(" + Template.TEMPLATE + ".prop) collate your_collation asc, " + Template.TEMPLATE + ".\"sql\" desc", template );
 	}
 
 	@Test
 	public void testComponentReferences() {
 		String fragment = "component asc";
 		String template = doStandardRendering( fragment );
 
 		assertEquals( Template.TEMPLATE + ".comp_1 asc, " + Template.TEMPLATE + ".comp_2 asc", template );
 	}
 
 	@Test
 	public void testComponentDerefReferences() {
 		String fragment = "component.prop1 asc";
 		String template = doStandardRendering( fragment );
 
 		assertEquals( Template.TEMPLATE + ".comp_1 asc", template );
 	}
 
 	public String doStandardRendering(String fragment) {
 		return Template.renderOrderByStringTemplate( fragment, MAPPER, SESSION_FACTORY, DIALECT, FUNCTION_REGISTRY );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/Flight.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/Flight.java
index 36967bc70f..662c55f0e2 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/Flight.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/Flight.java
@@ -1,148 +1,148 @@
 //$Id$
 package org.hibernate.test.annotations;
 import java.io.Serializable;
 import java.util.Calendar;
 import java.util.Date;
 import javax.persistence.Basic;
 import javax.persistence.CascadeType;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.FetchType;
 import javax.persistence.Id;
 import javax.persistence.Inheritance;
 import javax.persistence.InheritanceType;
 import javax.persistence.JoinColumn;
 import javax.persistence.ManyToOne;
 import javax.persistence.Temporal;
 import javax.persistence.TemporalType;
 import javax.persistence.Transient;
 import javax.persistence.Version;
 
 /**
  * Flight
  *
  * @author Emmanuel Bernard
  */
 @Entity()
 @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
 public class Flight implements Serializable {
 	Long id;
 	String name;
 	transient Long duration;
 	long durationInSec;
 	Integer version;
 	Company company;
 	String triggeredData;
 	long factor;
 	Date departureDate;
 	java.sql.Timestamp buyDate;
 	Calendar alternativeDepartureDate;
 
 	@Id
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long long1) {
 		id = long1;
 	}
 
 	@Column(name = "flight_name", nullable = false, updatable = false, length = 50)
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String string) {
 		name = string;
 	}
 
 	@Basic(fetch = FetchType.LAZY, optional = false)
 	public Long getDuration() {
 		return duration;
 	}
 
 	@Basic
 	@Temporal(TemporalType.DATE)
 	public Date getDepartureDate() {
 		return departureDate;
 	}
 
 	public void setDepartureDate(Date departureDate) {
 		this.departureDate = departureDate;
 	}
 
 
 	public void setDuration(Long l) {
 		duration = l;
 		//durationInSec = duration / 1000;
 	}
 
 	@Transient
 	public long getDurationInSec() {
 		return durationInSec;
 	}
 
 	public void setDurationInSec(long l) {
 		durationInSec = l;
 	}
 
 	@Version
 	@Column(name = "OPTLOCK")
 	public Integer getVersion() {
 		return version;
 	}
 
 	public void setVersion(Integer i) {
 		version = i;
 	}
 
 	@ManyToOne(cascade = {CascadeType.PERSIST, CascadeType.MERGE})
 	@JoinColumn(name = "COMP_ID")
 	public Company getCompany() {
 		return company;
 	}
 
 	public void setCompany(Company company) {
 		this.company = company;
 	}
 
 	@Column(insertable = false, updatable = false)
 	public String getTriggeredData() {
 		return triggeredData;
 	}
 
 	public void setTriggeredData(String string) {
 		triggeredData = string;
 	}
 
 	public void getIsNotAGetter() {
 		//do nothing
 	}
 
 	public long getFactor(boolean x10) {
 		//this is not a getter should not be persisted
 		return factor * ( 1 + ( x10 == true ? 9 : 0 ) );
 	}
 
 	public void setFactor(long factor) {
 		this.factor = factor;
 	}
 
 	@Temporal(TemporalType.TIMESTAMP)
 	public Calendar getAlternativeDepartureDate() {
 		return alternativeDepartureDate;
 	}
 
 	public void setAlternativeDepartureDate(Calendar alternativeDepartureDate) {
 		this.alternativeDepartureDate = alternativeDepartureDate;
 	}
 
 	public java.sql.Timestamp getBuyDate() {
 		return buyDate;
 	}
 
 	public void setBuyDate(java.sql.Timestamp buyDate) {
 		this.buyDate = buyDate;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/Gardenshed.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/Gardenshed.java
index 9b9f17be66..dad5d73aa6 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/Gardenshed.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/Gardenshed.java
@@ -1,54 +1,54 @@
 //$Id$
 package org.hibernate.test.annotations.access;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.Transient;
 
 import org.hibernate.annotations.AccessType;
 
 /**
  * This is the opposite of the Furniture test, as this tries to override the class AccessType("property") with
  * the property AccessType("field").
  *
  * @author Dennis Fleurbaaij
  * @since 2007-05-31
  */
 @Entity
 @AccessType( "property" )
 public class Gardenshed
 		extends
 		Woody {
 	private Integer id;
 	private String brand;
 	public long floors;
 
 	@Transient
 	public String getBrand() {
 		return brand;
 	}
 
 	public void setBrand(String brand) {
 		this.brand = brand;
 	}
 
 	@Id
 	@GeneratedValue
 	public Integer getId() {
 		return id;
 	}
 
 	public void setId(Integer id) {
 		this.id = id;
 	}
 
 	// These 2 functions should not return in Hibernate, but the value should come from the field "floors"
 	@AccessType( "field" )
 	public long getFloors() {
 		return this.floors + 2;
 	}
 
 	public void setFloors(long floors) {
 		this.floors = floors + 2;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/AccessMappingTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/AccessMappingTest.java
index e51245e375..1d81847cf2 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/AccessMappingTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/AccessMappingTest.java
@@ -1,251 +1,251 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.MappingException;
 import org.hibernate.SessionFactory;
 import org.hibernate.cfg.AnnotationConfiguration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.property.BasicPropertyAccessor;
 import org.hibernate.property.DirectPropertyAccessor;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.testing.ServiceRegistryBuilder;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.tuple.entity.EntityTuplizer;
 
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 
 /**
  * Tests verifying the correct behaviour for the usage of {@code @javax.persistence.Access}.
  *
  * @author Hardy Ferentschik
  */
 @SuppressWarnings({ "deprecation" })
 public class AccessMappingTest {
     private ServiceRegistry serviceRegistry;
 
     @Before
     public void setUp() {
         serviceRegistry = ServiceRegistryBuilder.buildServiceRegistry( Environment.getProperties() );
     }
 
     @After
     public void tearDown() {
         if ( serviceRegistry != null ) {
             ServiceRegistryBuilder.destroy( serviceRegistry );
         }
     }
 
     @Test
     public void testInconsistentAnnotationPlacement() throws Exception {
         AnnotationConfiguration cfg = new AnnotationConfiguration();
         cfg.addAnnotatedClass( Course1.class );
         cfg.addAnnotatedClass( Student.class );
 		SessionFactory sf = null;
         try {
            sf= cfg.buildSessionFactory( serviceRegistry );
             fail( "@Id and @OneToMany are not placed consistently in test entities. SessionFactory creation should fail." );
         }
         catch ( MappingException e ) {
             // success
         } finally {
 			if(sf!=null){
 				sf.close();
 			}
 		}
     }
 
     @Test
     public void testFieldAnnotationPlacement() throws Exception {
         AnnotationConfiguration cfg = new AnnotationConfiguration();
         Class<?> classUnderTest = Course6.class;
         cfg.addAnnotatedClass( classUnderTest );
         cfg.addAnnotatedClass( Student.class );
         SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
         EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Field access should be used.",
                 tuplizer.getIdentifierGetter() instanceof DirectPropertyAccessor.DirectGetter
         );
 		factory.close();
     }
 
     @Test
     public void testPropertyAnnotationPlacement() throws Exception {
         AnnotationConfiguration cfg = new AnnotationConfiguration();
         Class<?> classUnderTest = Course7.class;
         cfg.addAnnotatedClass( classUnderTest );
         cfg.addAnnotatedClass( Student.class );
         SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
         EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Property access should be used.",
                 tuplizer.getIdentifierGetter() instanceof BasicPropertyAccessor.BasicGetter
         );
 		factory.close();
     }
 
     @Test
     public void testExplicitPropertyAccessAnnotationsOnProperty() throws Exception {
         AnnotationConfiguration cfg = new AnnotationConfiguration();
         Class<?> classUnderTest = Course2.class;
         cfg.addAnnotatedClass( classUnderTest );
         cfg.addAnnotatedClass( Student.class );
         SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
         EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Property access should be used.",
                 tuplizer.getIdentifierGetter() instanceof BasicPropertyAccessor.BasicGetter
         );
 		factory.close();
     }
 
     @Test
     public void testExplicitPropertyAccessAnnotationsOnField() throws Exception {
         AnnotationConfiguration cfg = new AnnotationConfiguration();
         cfg.addAnnotatedClass( Course4.class );
         cfg.addAnnotatedClass( Student.class );
 		SessionFactory sf= null;
         try {
            sf = cfg.buildSessionFactory( serviceRegistry );
             fail( "@Id and @OneToMany are not placed consistently in test entities. SessionFactory creation should fail." );
         }
         catch ( MappingException e ) {
             // success
         }  finally {
 			if(sf!=null){
 				sf.close();
 			}
 		}
     }
 
     @Test
     public void testExplicitPropertyAccessAnnotationsWithHibernateStyleOverride() throws Exception {
         AnnotationConfiguration cfg = new AnnotationConfiguration();
         Class<?> classUnderTest = Course3.class;
         cfg.addAnnotatedClass( classUnderTest );
         cfg.addAnnotatedClass( Student.class );
         SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
         EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Field access should be used.",
                 tuplizer.getIdentifierGetter() instanceof DirectPropertyAccessor.DirectGetter
         );
 
         assertTrue(
                 "Property access should be used.",
                 tuplizer.getGetter( 0 ) instanceof BasicPropertyAccessor.BasicGetter
         );
 		factory.close();
     }
 
     @Test
     public void testExplicitPropertyAccessAnnotationsWithJpaStyleOverride() throws Exception {
         AnnotationConfiguration cfg = new AnnotationConfiguration();
         Class<?> classUnderTest = Course5.class;
         cfg.addAnnotatedClass( classUnderTest );
         cfg.addAnnotatedClass( Student.class );
         SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
         EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Field access should be used.",
                 tuplizer.getIdentifierGetter() instanceof DirectPropertyAccessor.DirectGetter
         );
 
         assertTrue(
                 "Property access should be used.",
                 tuplizer.getGetter( 0 ) instanceof BasicPropertyAccessor.BasicGetter
         );
 		factory.close();
     }
 
     @Test
     public void testDefaultFieldAccessIsInherited() throws Exception {
         AnnotationConfiguration cfg = new AnnotationConfiguration();
         Class<?> classUnderTest = User.class;
         cfg.addAnnotatedClass( classUnderTest );
         cfg.addAnnotatedClass( Person.class );
         cfg.addAnnotatedClass( Being.class );
         SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
         EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Field access should be used since the default access mode gets inherited",
                 tuplizer.getIdentifierGetter() instanceof DirectPropertyAccessor.DirectGetter
         );
 		factory.close();
     }
 
     @Test
     public void testDefaultPropertyAccessIsInherited() throws Exception {
         AnnotationConfiguration cfg = new AnnotationConfiguration();
         cfg.addAnnotatedClass( Horse.class );
         cfg.addAnnotatedClass( Animal.class );
 
         SessionFactoryImplementor factory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
         EntityTuplizer tuplizer = factory.getEntityPersister( Animal.class.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Property access should be used since explicity configured via @Access",
                 tuplizer.getIdentifierGetter() instanceof BasicPropertyAccessor.BasicGetter
         );
 
         tuplizer = factory.getEntityPersister( Horse.class.getName() )
                 .getEntityMetamodel()
                 .getTuplizer();
         assertTrue(
                 "Field access should be used since the default access mode gets inherited",
                 tuplizer.getGetter( 0 ) instanceof DirectPropertyAccessor.DirectGetter
         );
 		factory.close();
     }
 
     @TestForIssue(jiraKey = "HHH-5004")
     @Test
     public void testAccessOnClassAndId() throws Exception {
         AnnotationConfiguration cfg = new AnnotationConfiguration();
         cfg.addAnnotatedClass( Course8.class );
         cfg.addAnnotatedClass( Student.class );
         cfg.buildSessionFactory( serviceRegistry ).close();
     }
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/AccessTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/AccessTest.java
index 18cdc28f68..3c69b829ff 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/AccessTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/AccessTest.java
@@ -1,249 +1,249 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.test.annotations.access.Closet;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
 /**
  * @author Emmanuel Bernard
  * @author Hardy Ferentschik
  */
 public class AccessTest extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testDefaultConfigurationModeIsInherited() throws Exception {
 		User john = new User();
 		john.setFirstname( "John" );
 		john.setLastname( "Doe" );
 		List<User> friends = new ArrayList<User>();
 		User friend = new User();
 		friend.setFirstname( "Jane" );
 		friend.setLastname( "Doe" );
 		friends.add( friend );
 		john.setFriends( friends );
 
 		Session s = openSession();
 		s.persist( john );
 		Transaction tx = s.beginTransaction();
 		tx.commit();
 		s.clear();
 		tx = s.beginTransaction();
 		john = ( User ) s.get( User.class, john.getId() );
 		assertEquals( "Wrong number of friends", 1, john.getFriends().size() );
 		assertNull( john.firstname );
 
 		s.delete( john );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSuperclassOverriding() throws Exception {
 		Furniture fur = new Furniture();
 		fur.setColor( "Black" );
 		fur.setName( "Beech" );
 		fur.isAlive = true;
 		Session s = openSession();
 		s.persist( fur );
 		Transaction tx = s.beginTransaction();
 		tx.commit();
 		s.clear();
 		tx = s.beginTransaction();
 		fur = ( Furniture ) s.get( Furniture.class, fur.getId() );
 		assertFalse( fur.isAlive );
 		assertNotNull( fur.getColor() );
 		s.delete( fur );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSuperclassNonOverriding() throws Exception {
 		Furniture fur = new Furniture();
 		fur.setGod( "Buddha" );
 		Session s = openSession();
 		s.persist( fur );
 		Transaction tx = s.beginTransaction();
 		tx.commit();
 		s.clear();
 		tx = s.beginTransaction();
 		fur = ( Furniture ) s.get( Furniture.class, fur.getId() );
 		assertNotNull( fur.getGod() );
 		s.delete( fur );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testPropertyOverriding() throws Exception {
 		Furniture fur = new Furniture();
 		fur.weight = 3;
 		Session s = openSession();
 		s.persist( fur );
 		Transaction tx = s.beginTransaction();
 		tx.commit();
 		s.clear();
 		tx = s.beginTransaction();
 		fur = ( Furniture ) s.get( Furniture.class, fur.getId() );
 		assertEquals( 5, fur.weight );
 		s.delete( fur );
 		tx.commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testNonOverridenSubclass() throws Exception {
 		Chair chair = new Chair();
 		chair.setPillow( "Blue" );
 		Session s = openSession();
 		s.persist( chair );
 		Transaction tx = s.beginTransaction();
 		tx.commit();
 		s.clear();
 		tx = s.beginTransaction();
 		chair = ( Chair ) s.get( Chair.class, chair.getId() );
 		assertNull( chair.getPillow() );
 		s.delete( chair );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testOverridenSubclass() throws Exception {
 		BigBed bed = new BigBed();
 		bed.size = 5;
 		bed.setQuality( "good" );
 		Session s = openSession();
 		s.persist( bed );
 		Transaction tx = s.beginTransaction();
 		tx.commit();
 		s.clear();
 		tx = s.beginTransaction();
 		bed = ( BigBed ) s.get( BigBed.class, bed.getId() );
 		assertEquals( 5, bed.size );
 		assertNull( bed.getQuality() );
 		s.delete( bed );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testFieldsOverriding() throws Exception {
 		Gardenshed gs = new Gardenshed();
 		gs.floors = 4;
 		Session s = openSession();
 		s.persist( gs );
 		Transaction tx = s.beginTransaction();
 		tx.commit();
 		s.clear();
 		tx = s.beginTransaction();
 		gs = ( Gardenshed ) s.get( Gardenshed.class, gs.getId() );
 		assertEquals( 4, gs.floors );
 		assertEquals( 6, gs.getFloors() );
 		s.delete( gs );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testEmbeddableUsesAccessStrategyOfContainingClass() throws Exception {
 		Circle circle = new Circle();
 		Color color = new Color( 5, 10, 15 );
 		circle.setColor( color );
 		Session s = openSession();
 		s.persist( circle );
 		Transaction tx = s.beginTransaction();
 		tx.commit();
 		s.clear();
 		tx = s.beginTransaction();
 		circle = ( Circle ) s.get( Circle.class, circle.getId() );
 		assertEquals( 5, circle.getColor().r );
 		try {
 			circle.getColor().getR();
 			fail();
 		} catch (RuntimeException e) {
 			// success		
 		}
 		s.delete( circle );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testEmbeddableExplicitAccessStrategy() throws Exception {
 		Square square = new Square();
 		Position pos = new Position( 10, 15 );
 		square.setPosition( pos );
 		Session s = openSession();
 		s.persist( square );
 		Transaction tx = s.beginTransaction();
 		tx.commit();
 		s.clear();
 		tx = s.beginTransaction();
 		square = ( Square ) s.get( Square.class, square.getId() );
 		assertEquals( 10, square.getPosition().x );
 		try {
 			square.getPosition().getX();
 			fail();
 		} catch (RuntimeException e) {
 			// success
 		}
 		s.delete( square );
 		tx.commit();
 		s.close();
 	}
 
 	@Override
 	protected Class[] getAnnotatedClasses() {
 		return new Class[] {
 				Bed.class,
 				Chair.class,
 				Furniture.class,
 				BigBed.class,
 				Gardenshed.class,
 				Closet.class,
 				Person.class,
 				User.class,
 				Shape.class,
 				Circle.class,
 				Color.class,
 				Square.class,
 				Position.class
 		};
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Animal.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Animal.java
index f914c95a36..416c32f030 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Animal.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Animal.java
@@ -1,52 +1,52 @@
 //$Id$
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import javax.persistence.Access;
 import javax.persistence.AccessType;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 @Access(AccessType.FIELD)
 public class Animal {
 
 	private long id;
 
 	@Access( AccessType.PROPERTY)
 	@Id
 	@GeneratedValue
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Bed.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Bed.java
index 4db63d0dcf..4a0364c715 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Bed.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Bed.java
@@ -1,48 +1,48 @@
 //$Id$
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import javax.persistence.Access;
 import javax.persistence.AccessType;
 import javax.persistence.Entity;
 import javax.persistence.Transient;
 
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 @Access(AccessType.PROPERTY)
 public class Bed extends Furniture {
 	String quality;
 
 	@Transient
 	public String getQuality() {
 		return quality;
 	}
 
 	public void setQuality(String quality) {
 		this.quality = quality;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/BigBed.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/BigBed.java
index 1f069a53bc..00230d10db 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/BigBed.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/BigBed.java
@@ -1,36 +1,36 @@
 //$Id$
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class BigBed extends Bed {
 	@Column(name = "bed_size")
 	public int size;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Chair.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Chair.java
index 36a561d736..f3243e1a0b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Chair.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Chair.java
@@ -1,45 +1,45 @@
 //$Id$
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import javax.persistence.Entity;
 import javax.persistence.Transient;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class Chair extends Furniture {
 
 	@Transient
 	private String pillow;
 
 	public String getPillow() {
 		return pillow;
 	}
 
 	public void setPillow(String pillow) {
 		this.pillow = pillow;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Circle.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Circle.java
index b9367b6c41..a04886f00b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Circle.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Circle.java
@@ -1,48 +1,48 @@
 //$Id: Being.java 18260 2009-12-17 21:14:07Z hardy.ferentschik $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import javax.persistence.Access;
 import javax.persistence.AccessType;
 import javax.persistence.Embedded;
 import javax.persistence.Entity;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 @Access(AccessType.FIELD)
 public class Circle extends Shape {
 	@Embedded
 	private Color color;
 
 	public Color getColor() {
 		return color;
 	}
 
 	public void setColor(Color color) {
 		this.color = color;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Color.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Color.java
index bd757a9450..214aa877b6 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Color.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Color.java
@@ -1,70 +1,70 @@
 //$Id: Being.java 18260 2009-12-17 21:14:07Z hardy.ferentschik $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import javax.persistence.Embeddable;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Embeddable
 public class Color {
 	public int r;
 	public int g;
 	public int b;
 
 	public Color() {
 	}
 
 	public Color(int r, int g, int b) {
 		this.r = r;
 		this.g = g;
 		this.b = b;
 	}
 
 	public int getB() {
 		throw new RuntimeException();
 	}
 
 	public void setB(int b) {
 		this.b = b;
 	}
 
 	public int getG() {
 		throw new RuntimeException();
 	}
 
 	public void setG(int g) {
 		this.g = g;
 	}
 
 	public int getR() {
 		throw new RuntimeException();
 	}
 
 	public void setR(int r) {
 		this.r = r;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course2.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course2.java
index b18c69f167..a13809d57b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course2.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course2.java
@@ -1,74 +1,74 @@
 //$Id: AccessTest.java 15025 2008-08-11 09:14:39Z hardy.ferentschik $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import java.util.List;
 import javax.persistence.Access;
 import javax.persistence.AccessType;
 import javax.persistence.CascadeType;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 @Access(AccessType.PROPERTY)
 public class Course2 {
 	private long id;
 
 	private String title;
 
 	private List<Student> students;
 
 	@Id
 	@GeneratedValue
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	@OneToMany(cascade = CascadeType.ALL)
 	public List<Student> getStudents() {
 		return students;
 	}
 
 	public void setStudents(List<Student> students) {
 		this.students = students;
 	}
 
 	public String getTitle() {
 		return title;
 	}
 
 	public void setTitle(String title) {
 		this.title = title;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course3.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course3.java
index c70a4c1866..6e3a130971 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course3.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course3.java
@@ -1,76 +1,76 @@
 //$Id: AccessTest.java 15025 2008-08-11 09:14:39Z hardy.ferentschik $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import java.util.List;
 import javax.persistence.Access;
 import javax.persistence.AccessType;
 import javax.persistence.CascadeType;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 @Access(AccessType.PROPERTY)
 public class Course3 {
 	private long id;
 
 	private String title;
 
 
 	private List<Student> students;
 
 	@Id
 	@GeneratedValue
 	@org.hibernate.annotations.AccessType("field")
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	@OneToMany(cascade = CascadeType.ALL)
 	public List<Student> getStudents() {
 		return students;
 	}
 
 	public void setStudents(List<Student> students) {
 		this.students = students;
 	}
 
 	public String getTitle() {
 		return title;
 	}
 
 	public void setTitle(String title) {
 		this.title = title;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course4.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course4.java
index 67faf21203..38791f83f3 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course4.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course4.java
@@ -1,74 +1,74 @@
 //$Id: AccessTest.java 15025 2008-08-11 09:14:39Z hardy.ferentschik $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import java.util.List;
 import javax.persistence.Access;
 import javax.persistence.AccessType;
 import javax.persistence.CascadeType;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 @Access(AccessType.PROPERTY)
 public class Course4 {
 	@Id
 	@GeneratedValue
 	private long id;
 
 	private String title;
 
 	@OneToMany(cascade = CascadeType.ALL)
 	private List<Student> students;
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public List<Student> getStudents() {
 		return students;
 	}
 
 	public void setStudents(List<Student> students) {
 		this.students = students;
 	}
 
 	public String getTitle() {
 		return title;
 	}
 
 	public void setTitle(String title) {
 		this.title = title;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course5.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course5.java
index 6d23f93390..36890f0215 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course5.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course5.java
@@ -1,76 +1,76 @@
 //$Id: AccessTest.java 15025 2008-08-11 09:14:39Z hardy.ferentschik $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import java.util.List;
 import javax.persistence.Access;
 import javax.persistence.AccessType;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.ManyToMany;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 @Access(AccessType.PROPERTY)
 public class Course5 {
 
 	@Access(AccessType.FIELD)
 	@Id
 	@GeneratedValue
 	private long id;
 
 	private String title;
 
 	private List<Student> students;
 
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	@ManyToMany
 	public List<Student> getStudents() {
 		return students;
 	}
 
 	public void setStudents(List<Student> students) {
 		this.students = students;
 	}
 
 	public String getTitle() {
 		return title;
 	}
 
 	public void setTitle(String title) {
 		this.title = title;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course6.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course6.java
index 672808cda3..a4c59969b1 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course6.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course6.java
@@ -1,71 +1,71 @@
 //$Id: AccessTest.java 15025 2008-08-11 09:14:39Z hardy.ferentschik $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import java.util.List;
 import javax.persistence.CascadeType;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 public class Course6 {
 	@Id
 	@GeneratedValue
 	private long id;
 
 	private String title;
 
 	@OneToMany(cascade = CascadeType.ALL)
 	private List<Student> students;
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public List<Student> getStudents() {
 		return students;
 	}
 
 	public void setStudents(List<Student> students) {
 		this.students = students;
 	}
 
 	public String getTitle() {
 		return title;
 	}
 
 	public void setTitle(String title) {
 		this.title = title;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course7.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course7.java
index f596be201f..071ed6a8a5 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course7.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course7.java
@@ -1,71 +1,71 @@
 //$Id: AccessTest.java 15025 2008-08-11 09:14:39Z hardy.ferentschik $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import java.util.List;
 import javax.persistence.CascadeType;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 public class Course7 {
 	private long id;
 
 	private String title;
 
 	private List<Student> students;
 
 	@Id
 	@GeneratedValue
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	@OneToMany(cascade = CascadeType.ALL)
 	public List<Student> getStudents() {
 		return students;
 	}
 
 	public void setStudents(List<Student> students) {
 		this.students = students;
 	}
 
 	public String getTitle() {
 		return title;
 	}
 
 	public void setTitle(String title) {
 		this.title = title;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course8.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course8.java
index 546c8a6ef1..f2265a18ab 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course8.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Course8.java
@@ -1,77 +1,77 @@
 //$Id: AccessTest.java 15025 2008-08-11 09:14:39Z hardy.ferentschik $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import java.util.List;
 import javax.persistence.Access;
 import javax.persistence.AccessType;
 import javax.persistence.CascadeType;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
 
 
 /**
  * Test class for HHH-5004
  *
  * @author Hardy Ferentschik
  */
 @Entity
 @Access(AccessType.PROPERTY)
 public class Course8 {
 	private long id;
 
 	private String title;
 
 	private List<Student> students;
 
 	@Id
 	@GeneratedValue
 	@Access(AccessType.PROPERTY)
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	@OneToMany(cascade = CascadeType.ALL)
 	public List<Student> getStudents() {
 		return students;
 	}
 
 	public void setStudents(List<Student> students) {
 		this.students = students;
 	}
 
 	public String getTitle() {
 		return title;
 	}
 
 	public void setTitle(String title) {
 		this.title = title;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Furniture.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Furniture.java
index 0e15f65f67..7abd9a0b4c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Furniture.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Furniture.java
@@ -1,71 +1,71 @@
 //$Id$
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import javax.persistence.Access;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.Transient;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 @Access(javax.persistence.AccessType.FIELD)
 public class Furniture extends Woody {
 	@Id
 	@GeneratedValue
 	private Integer id;
 
 	private String brand;
 
 	@Transient
 	public String getBrand() {
 		return brand;
 	}
 
 	public void setBrand(String brand) {
 		this.brand = brand;
 	}
 
 	public Integer getId() {
 		return id;
 	}
 
 	public void setId(Integer id) {
 		this.id = id;
 	}
 
 	public long weight;
 
 	@Access(javax.persistence.AccessType.PROPERTY)
 	public long getWeight() {
 		return weight + 1;
 	}
 
 	public void setWeight(long weight) {
 		this.weight = weight + 1;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Gardenshed.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Gardenshed.java
index 4cddbd4aaf..ad456887e0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Gardenshed.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Gardenshed.java
@@ -1,77 +1,77 @@
 //$Id$
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import javax.persistence.Access;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.Transient;
 
 /**
  * This is the opposite of the Furniture test, as this tries to override the class AccessType("property") with
  * the property AccessType("field").
  *
  * @author Dennis Fleurbaaij
  * @since 2007-05-31
  */
 @Entity
 @Access(javax.persistence.AccessType.PROPERTY)
 public class Gardenshed
 		extends
 		Woody {
 	private Integer id;
 	private String brand;
 	public long floors;
 
 	@Transient
 	public String getBrand() {
 		return brand;
 	}
 
 	public void setBrand(String brand) {
 		this.brand = brand;
 	}
 
 	@Id
 	@GeneratedValue
 	public Integer getId() {
 		return id;
 	}
 
 	public void setId(Integer id) {
 		this.id = id;
 	}
 
 	// These 2 functions should not return in Hibernate, but the value should come from the field "floors"
 
 	@Access(javax.persistence.AccessType.FIELD)
 	public long getFloors() {
 		return this.floors + 2;
 	}
 
 	public void setFloors(long floors) {
 		this.floors = floors + 2;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Horse.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Horse.java
index b2238665d5..a4d4e59c33 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Horse.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Horse.java
@@ -1,44 +1,44 @@
 //$Id: Being.java 18260 2009-12-17 21:14:07Z hardy.ferentschik $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import javax.persistence.Entity;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 public class Horse extends Animal {
 
 	private String name;
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Position.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Position.java
index 6540514356..8d45c3c6a6 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Position.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Position.java
@@ -1,63 +1,63 @@
 //$Id: Being.java 18260 2009-12-17 21:14:07Z hardy.ferentschik $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import javax.persistence.Access;
 import javax.persistence.AccessType;
 import javax.persistence.Embeddable;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Embeddable
 @Access(AccessType.FIELD)
 public class Position {
 	public int x;
 	public int y;
 
 	public Position() {
 	}
 
 	public Position(int x, int y) {
 		this.x = x;
 		this.y = y;
 	}
 
 	public int getX() {
 		throw new RuntimeException( );
 	}
 
 	public void setX(int x) {
 		this.x = x;
 	}
 
 	public int getY() {
 		throw new RuntimeException( );
 	}
 
 	public void setY(int y) {
 		this.y = y;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Shape.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Shape.java
index f78f3e0a45..e006e92cfd 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Shape.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Shape.java
@@ -1,47 +1,47 @@
 //$Id: Being.java 18260 2009-12-17 21:14:07Z hardy.ferentschik $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 public class Shape {
 	private long id;
 
 	@Id
 	@GeneratedValue
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Square.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Square.java
index c9dfef0a6c..bc93f0d3ce 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Square.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Square.java
@@ -1,60 +1,60 @@
 //$Id: Being.java 18260 2009-12-17 21:14:07Z hardy.ferentschik $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import javax.persistence.Embedded;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 public class Square {
 
 	private long id;
 
 	@Embedded
 	private Position position;
 
 	@Id
 	@GeneratedValue
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public Position getPosition() {
 		return position;
 	}
 
 	public void setPosition(Position position) {
 		this.position = position;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Thingy.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Thingy.java
index f690b88208..b2201373a5 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Thingy.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Thingy.java
@@ -1,44 +1,44 @@
 //$Id$
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import javax.persistence.MappedSuperclass;
 import javax.persistence.Transient;
 
 /**
  * @author Emmanuel Bernard
  */
 @MappedSuperclass
 public class Thingy {
 	private String god;
 
 	@Transient
 	public String getGod() {
 		return god;
 	}
 
 	public void setGod(String god) {
 		this.god = god;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/User.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/User.java
index bacde9cdd3..a9d3139451 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/User.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/User.java
@@ -1,47 +1,47 @@
 //$Id$
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import java.util.List;
 import javax.persistence.CascadeType;
 import javax.persistence.Entity;
 import javax.persistence.OneToMany;
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 public class User extends Person {
 
 	@OneToMany(cascade = CascadeType.ALL)
 	private List<User> friends;
 
 	public List<User> getFriends() {
 		return friends;
 	}
 
 	public void setFriends(List<User> friends) {
 		this.friends = friends;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Woody.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Woody.java
index e9bb84ae8d..e11663cc28 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Woody.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/jpa/Woody.java
@@ -1,54 +1,54 @@
 //$Id$
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.jpa;
 import javax.persistence.Access;
 import javax.persistence.MappedSuperclass;
 
 /**
  * @author Emmanuel Bernard
  */
 @MappedSuperclass
 @Access(javax.persistence.AccessType.PROPERTY)
 public class Woody extends Thingy {
 	private String color;
 	private String name;
 	public boolean isAlive; //shouldn't be persistent
 
 	public String getColor() {
 		return color;
 	}
 
 	public void setColor(String color) {
 		this.color = color;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/Cook.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/Cook.java
index 98dcef812c..7f0b171bdb 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/Cook.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/Cook.java
@@ -1,50 +1,50 @@
 // $Id$
 /*
 * JBoss, Home of Professional Open Source
 * Copyright 2009, Red Hat, Inc. and/or its affiliates, and individual contributors
 * by the @authors tag. See the copyright.txt in the distribution for a
 * full listing of individual contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 package org.hibernate.test.annotations.access.xml;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 public class Cook {
 	@Id
 	@GeneratedValue
 	private int id;
 
 	private Knive favouriteKnife;
 
 	public Knive getFavouriteKnife() {
 		return favouriteKnife;
 	}
 
 	public void setFavouriteKnife(Knive favouriteKnife) {
 		this.favouriteKnife = favouriteKnife;
 	}
 
 	public int getId() {
 		return id;
 	}
 
 	public void setId(int id) {
 		this.id = id;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/Driver.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/Driver.java
index 8f65534ebe..2cda38951f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/Driver.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/Driver.java
@@ -1,49 +1,49 @@
 // $Id$
 /*
 * JBoss, Home of Professional Open Source
 * Copyright 2009, Red Hat, Inc. and/or its affiliates, and individual contributors
 * by the @authors tag. See the copyright.txt in the distribution for a
 * full listing of individual contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 package org.hibernate.test.annotations.access.xml;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 public class Driver {
 	@Id
 	@GeneratedValue
 	private int id;
 
 	private String name;
 
 	public int getId() {
 		return id;
 	}
 
 	public void setId(int id) {
 		this.id = id;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/Knive.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/Knive.java
index 3767924233..4bd1d71ed7 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/Knive.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/Knive.java
@@ -1,45 +1,45 @@
 // $Id: Waiter.java 18506 2010-01-11 20:23:08Z hardy.ferentschik $
 /*
 * JBoss, Home of Professional Open Source
 * Copyright 2009, Red Hat, Inc. and/or its affiliates, and individual contributors
 * by the @authors tag. See the copyright.txt in the distribution for a
 * full listing of individual contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 package org.hibernate.test.annotations.access.xml;
 import javax.persistence.Embeddable;
 
 /**
  * @author Hardy Ferentschik
  */
 @Embeddable
 public class Knive {
 	private String brand;
 
 	private int bladeLength;
 
 	public int getBladeLength() {
 		return bladeLength;
 	}
 
 	public void setBladeLength(int bladeLength) {
 		this.bladeLength = bladeLength;
 	}
 
 	public String getBrand() {
 		return brand;
 	}
 
 	public void setBrand(String brand) {
 		this.brand = brand;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/RentalCar.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/RentalCar.java
index 545013a672..ea871747c7 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/RentalCar.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/RentalCar.java
@@ -1,49 +1,49 @@
 // $Id$
 /*
 * JBoss, Home of Professional Open Source
 * Copyright 2009, Red Hat, Inc. and/or its affiliates, and individual contributors
 * by the @authors tag. See the copyright.txt in the distribution for a
 * full listing of individual contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 package org.hibernate.test.annotations.access.xml;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 public class RentalCar {
 	@Id
 	@GeneratedValue
 	private int id;
 
 	private Driver driver;
 
 	public int getId() {
 		return id;
 	}
 
 	public void setId(int id) {
 		this.id = id;
 	}
 
 	public Driver getDriver() {
 		return driver;
 	}
 
 	public void setDriver(Driver driver) {
 		this.driver = driver;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/XmlAccessTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/XmlAccessTest.java
index cffeff37b0..cd3c0a021b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/XmlAccessTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/access/xml/XmlAccessTest.java
@@ -1,209 +1,209 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.access.xml;
 
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import javax.persistence.AccessType;
 
 import org.junit.Assert;
 import org.junit.Test;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.property.BasicPropertyAccessor;
 import org.hibernate.property.DirectPropertyAccessor;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 import org.hibernate.tuple.entity.EntityTuplizer;
 
 
 /**
  * Test verifying that it is possible to configure the access type via xml configuration.
  *
  * @author Hardy Ferentschik
  */
 public class XmlAccessTest extends BaseUnitTestCase {
 	@Test
 	public void testAccessOnBasicXmlElement() throws Exception {
 		Class<?> classUnderTest = Tourist.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		List<String> configFiles = Collections.emptyList();
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 
 		// without any xml configuration we have field access
 		assertAccessType( factory, classUnderTest, AccessType.FIELD );
 		factory.close();
 		// now with an additional xml configuration file changing the default access type for Tourist using basic
 		configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/Tourist.xml" );
 		factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.PROPERTY );
 		factory.close();
 	}
 
 	@Test
 	public void testAccessOnPersistenceUnitDefaultsXmlElement() throws Exception {
 		Class<?> classUnderTest = Tourist.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		List<String> configFiles = Collections.emptyList();
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 
 		// without any xml configuration we have field access
 		assertAccessType( factory, classUnderTest, AccessType.FIELD );
 		factory.close();
 		// now with an additional xml configuration file changing the default access type for Tourist using persitence unit defaults
 		configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/Tourist2.xml" );
 		factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.PROPERTY );
 		factory.close();
 	}
 
 	@Test
 	public void testAccessOnEntityMappingsXmlElement() throws Exception {
 		Class<?> classUnderTest = Tourist.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		List<String> configFiles = Collections.emptyList();
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 
 		// without any xml configuration we have field access
 		assertAccessType( factory, classUnderTest, AccessType.FIELD );
 		factory.close();
 		// now with an additional xml configuration file changing the default access type for Tourist using default in entity-mappings
 		configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/Tourist3.xml" );
 		factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.PROPERTY );
 		factory.close();
 	}
 
 	@Test
 	public void testAccessOnEntityXmlElement() throws Exception {
 		Class<?> classUnderTest = Tourist.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		List<String> configFiles = Collections.emptyList();
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 
 		// without any xml configuration we have field access
 		assertAccessType( factory, classUnderTest, AccessType.FIELD );
 		factory.close();
 		// now with an additional xml configuration file changing the default access type for Tourist using entity level config
 		configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/Tourist4.xml" );
 		factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.PROPERTY );
 		factory.close();
 	}
 
 	@Test
 	public void testAccessOnMappedSuperClassXmlElement() throws Exception {
 		Class<?> classUnderTest = Waiter.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		classes.add( Crew.class );
 		List<String> configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/Crew.xml" );
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.FIELD );
 		factory.close();
 	}
 
 	@Test
 	public void testAccessOnAssociationXmlElement() throws Exception {
 		Class<?> classUnderTest = RentalCar.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		classes.add( Driver.class );
 		List<String> configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/RentalCar.xml" );
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.PROPERTY );
 		factory.close();
 	}
 
 	@Test
 	public void testAccessOnEmbeddedXmlElement() throws Exception {
 		Class<?> classUnderTest = Cook.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		classes.add( Knive.class );
 		List<String> configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/Cook.xml" );
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.PROPERTY );
 		factory.close();
 	}
 
 	@Test
 	public void testAccessOnElementCollectionXmlElement() throws Exception {
 		Class<?> classUnderTest = Boy.class;
 		List<Class<?>> classes = new ArrayList<Class<?>>();
 		classes.add( classUnderTest );
 		List<String> configFiles = new ArrayList<String>();
 		configFiles.add( "org/hibernate/test/annotations/access/xml/Boy.xml" );
 		SessionFactoryImplementor factory = buildSessionFactory( classes, configFiles );
 		assertAccessType( factory, classUnderTest, AccessType.PROPERTY );
 		factory.close();
 	}
 
 	private SessionFactoryImplementor buildSessionFactory(List<Class<?>> classesUnderTest, List<String> configFiles) {
 		assert classesUnderTest != null;
 		assert configFiles != null;
 		Configuration cfg = new Configuration();
 		for ( Class<?> clazz : classesUnderTest ) {
 			cfg.addAnnotatedClass( clazz );
 		}
 		for ( String configFile : configFiles ) {
 			InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( configFile );
 			cfg.addInputStream( is );
 		}
 		return ( SessionFactoryImplementor ) cfg.buildSessionFactory();
 	}
 
 	// uses the first getter of the tupelizer for the assertions
 
 	private void assertAccessType(SessionFactoryImplementor factory, Class<?> classUnderTest, AccessType accessType) {
 		EntityTuplizer tuplizer = factory.getEntityPersister( classUnderTest.getName() )
 				.getEntityMetamodel()
 				.getTuplizer();
 		if ( AccessType.FIELD.equals( accessType ) ) {
 			Assert.assertTrue(
 					"Field access was expected.",
 					tuplizer.getGetter( 0 ) instanceof DirectPropertyAccessor.DirectGetter
 			);
 		}
 		else {
 			Assert.assertTrue(
 					"Property access was expected.",
 					tuplizer.getGetter( 0 ) instanceof BasicPropertyAccessor.BasicGetter
 			);
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/backquotes/Printer.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/backquotes/Printer.java
index c275dac84f..02d0f66bde 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/backquotes/Printer.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/backquotes/Printer.java
@@ -1,47 +1,47 @@
 /*
   * Hibernate, Relational Persistence for Idiomatic Java
   *
   * Copyright (c) 2009, Red Hat, Inc. and/or its affiliates or third-
   * party contributors as indicated by the @author tags or express 
   * copyright attribution statements applied by the authors.  
   * All third-party contributions are distributed under license by 
   * Red Hat, Inc.
   *
   * This copyrighted material is made available to anyone wishing to 
   * use, modify, copy, or redistribute it subject to the terms and 
   * conditions of the GNU Lesser General Public License, as published 
   * by the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of 
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
   * Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU Lesser General Public 
   * License along with this distribution; if not, write to:
   * 
   * Free Software Foundation, Inc.
   * 51 Franklin Street, Fifth Floor
   * Boston, MA  02110-1301  USA
   */
 
 package org.hibernate.test.annotations.backquotes;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.Table;
 
 
 @Entity
 @Table(name="`Printer`")
 public class Printer {
     private Long id;
 
     @Id
     public Long getId() {
         return id;
     }
 
     public void setId(Long id) {
         this.id = id;
     }
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/backquotes/PrinterCable.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/backquotes/PrinterCable.java
index b0da052da3..0334746ba8 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/backquotes/PrinterCable.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/backquotes/PrinterCable.java
@@ -1,57 +1,57 @@
 /*
   * Hibernate, Relational Persistence for Idiomatic Java
   *
   * Copyright (c) 2009, Red Hat, Inc. and/or its affiliates or third-
   * party contributors as indicated by the @author tags or express 
   * copyright attribution statements applied by the authors.  
   * All third-party contributions are distributed under license by 
   * Red Hat, Inc.
   *
   * This copyrighted material is made available to anyone wishing to 
   * use, modify, copy, or redistribute it subject to the terms and 
   * conditions of the GNU Lesser General Public License, as published 
   * by the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of 
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
   * Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU Lesser General Public 
   * License along with this distribution; if not, write to:
   * 
   * Free Software Foundation, Inc.
   * 51 Franklin Street, Fifth Floor
   * Boston, MA  02110-1301  USA
   */
 
 package org.hibernate.test.annotations.backquotes;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.JoinColumn;
 import javax.persistence.ManyToOne;
 
 @Entity
 public class PrinterCable {
 	private Long id;
 	private Printer printer;
 
 	@Id
 	public Long getId() {
 		return id;
 	}
 	
 	public void setId(Long id) {
 		this.id = id;
 	}
 	
 	@ManyToOne
 	@JoinColumn(name="aId", referencedColumnName="missing")
 	public Printer getPrinter() {
 		return printer;
 	}
 	
 	public void setPrinter(Printer a) {
 		this.printer = a;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/beanvalidation/BeanValidationGroupsTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/beanvalidation/BeanValidationGroupsTest.java
index 51e038b531..61cb9f60c9 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/beanvalidation/BeanValidationGroupsTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/beanvalidation/BeanValidationGroupsTest.java
@@ -1,112 +1,112 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
  * third-party contributors as indicated by either @author tags or express
  * copyright attribution statements applied by the authors.  All
  * third-party contributions are distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.beanvalidation;
 
 import java.lang.annotation.Annotation;
 import java.math.BigDecimal;
 import javax.validation.ConstraintViolationException;
 import javax.validation.constraints.NotNull;
 import javax.validation.groups.Default;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 /**
  * @author Emmanuel Bernard
  */
 public class BeanValidationGroupsTest extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testListeners() {
 		CupHolder ch = new CupHolder();
 		ch.setRadius( new BigDecimal( "12" ) );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		try {
 			s.persist( ch );
 			s.flush();
 		}
 		catch ( ConstraintViolationException e ) {
 			fail( "invalid object should not be validated" );
 		}
 		try {
 			ch.setRadius( null );
 			s.flush();
 		}
 		catch ( ConstraintViolationException e ) {
 			fail( "invalid object should not be validated" );
 		}
 		try {
 			s.delete( ch );
 			s.flush();
 			fail( "invalid object should not be persisted" );
 		}
 		catch ( ConstraintViolationException e ) {
 			assertEquals( 1, e.getConstraintViolations().size() );
 			// TODO - seems this explicit case is necessary with JDK 5 (at least on Mac). With Java 6 there is no problem
 			Annotation annotation = e.getConstraintViolations()
 					.iterator()
 					.next()
 					.getConstraintDescriptor()
 					.getAnnotation();
 			assertEquals(
 					NotNull.class,
 					annotation.annotationType()
 			);
 		}
 		tx.rollback();
 		s.close();
 	}
 
 	@Override
 	protected void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty(
 				"javax.persistence.validation.group.pre-persist",
 				""
 		);
 		cfg.setProperty(
 				"javax.persistence.validation.group.pre-update",
 				""
 		);
 		cfg.setProperty(
 				"javax.persistence.validation.group.pre-remove",
 				Default.class.getName() + ", " + Strict.class.getName()
 		);
 		cfg.setProperty( "hibernate.validator.apply_to_ddl", "false" );
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] {
 				CupHolder.class
 		};
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/beanvalidation/BeanValidationProvidedFactoryTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/beanvalidation/BeanValidationProvidedFactoryTest.java
index 21395333a7..9f473882e6 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/beanvalidation/BeanValidationProvidedFactoryTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/beanvalidation/BeanValidationProvidedFactoryTest.java
@@ -1,91 +1,91 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
  * third-party contributors as indicated by either @author tags or express
  * copyright attribution statements applied by the authors.  All
  * third-party contributions are distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.beanvalidation;
 
 import java.math.BigDecimal;
 import java.util.Locale;
 import javax.validation.ConstraintViolationException;
 import javax.validation.MessageInterpolator;
 import javax.validation.Validation;
 import javax.validation.ValidatorFactory;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 /**
  * @author Emmanuel Bernard
  */
 public class BeanValidationProvidedFactoryTest extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testListeners() {
 		CupHolder ch = new CupHolder();
 		ch.setRadius( new BigDecimal( "12" ) );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		try {
 			s.persist( ch );
 			s.flush();
 			fail( "invalid object should not be persisted" );
 		}
 		catch ( ConstraintViolationException e ) {
 			assertEquals( 1, e.getConstraintViolations().size() );
 			assertEquals( "Oops", e.getConstraintViolations().iterator().next().getMessage() );
 		}
 		tx.rollback();
 		s.close();
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] {
 				CupHolder.class
 		};
 	}
 
 	@Override
 	protected void configure(Configuration cfg) {
 		super.configure( cfg );
 		final MessageInterpolator messageInterpolator = new MessageInterpolator() {
 
 			public String interpolate(String s, Context context) {
 				return "Oops";
 			}
 
 			public String interpolate(String s, Context context, Locale locale) {
 				return interpolate( s, context );
 			}
 		};
 		final javax.validation.Configuration<?> configuration = Validation.byDefaultProvider().configure();
 		configuration.messageInterpolator( messageInterpolator );
 		ValidatorFactory vf = configuration.buildValidatorFactory();
 		cfg.getProperties().put( "javax.persistence.validation.factory", vf );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/beanvalidation/TvOwner.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/beanvalidation/TvOwner.java
index f5acc3cb2a..5dd2baef13 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/beanvalidation/TvOwner.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/beanvalidation/TvOwner.java
@@ -1,44 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010 by Red Hat Inc and/or its affiliates or by
  * third-party contributors as indicated by either @author tags or express
  * copyright attribution statements applied by the authors.  All
  * third-party contributions are distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
 package org.hibernate.test.annotations.beanvalidation;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.ManyToOne;
 import javax.validation.constraints.NotNull;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class TvOwner {
 	@Id
 	@GeneratedValue
 	public Integer id;
 
 	@ManyToOne
 	@NotNull
 	public Tv tv;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/cid/B.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/cid/B.java
index 4399844216..a8314e4b51 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/cid/B.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/cid/B.java
@@ -1,26 +1,26 @@
 //$Id$
 package org.hibernate.test.annotations.cid;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 
 
 /**
  * @author Artur Legan
  */
 @Entity
 public class B {
 
 	@Id
 	@GeneratedValue
 	private Long id;
 
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/cid/TvProgram.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/cid/TvProgram.java
index 5e18117023..63268c64d1 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/cid/TvProgram.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/cid/TvProgram.java
@@ -1,37 +1,37 @@
 //$Id$
 package org.hibernate.test.annotations.cid;
 import java.util.Date;
 import javax.persistence.AssociationOverride;
 import javax.persistence.AssociationOverrides;
 import javax.persistence.Column;
 import javax.persistence.EmbeddedId;
 import javax.persistence.Entity;
 import javax.persistence.JoinColumn;
 import javax.persistence.PrimaryKeyJoinColumn;
 import javax.persistence.SecondaryTable;
 import javax.persistence.Temporal;
 import javax.persistence.TemporalType;
 
 /**
  * @author Chandra Patni
  */
 @Entity
 @SecondaryTable( name = "TV_PROGRAM_EXT", pkJoinColumns = {
 @PrimaryKeyJoinColumn( name = "CHANNEL_ID" ),
 @PrimaryKeyJoinColumn( name = "PRESENTER_NAME" )
 		} )
 @AssociationOverrides({
 @AssociationOverride(name = "id.channel", joinColumns = @JoinColumn(name = "chan_id", nullable = false)),
 @AssociationOverride(name = "id.presenter", joinColumns = @JoinColumn(name = "presenter_name", nullable = false))})
 public class TvProgram {
 	@EmbeddedId
 	public TvMagazinPk id;
 
 	@Temporal( TemporalType.TIME )
     @Column(name="`time`")
 	Date time;
 
 	@Column( name = "TXT", table = "TV_PROGRAM_EXT" )
 	public String text;
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/collectionelement/BugSystem.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/collectionelement/BugSystem.java
index 50c51bd8f9..7e528b739c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/collectionelement/BugSystem.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/collectionelement/BugSystem.java
@@ -1,37 +1,37 @@
 package org.hibernate.test.annotations.collectionelement;
 import java.util.Set;
 import javax.persistence.ElementCollection;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OrderBy;
 
 @SuppressWarnings({"unchecked", "serial"})
 
 @Entity
 public class BugSystem {
 	@Id
 	@GeneratedValue
 	private Integer id;
 
 	@ElementCollection
 	@OrderBy("reportedBy.lastName ASC,reportedBy.firstName ASC,summary")
 	private Set<Bug> bugs;
 
 	public Integer getId() {
 		return id;
 	}
 
 	public void setId(Integer id) {
 		this.id = id;
 	}
 
 	public Set<Bug> getBugs() {
 		return bugs;
 	}
 
 	public void setBugs(Set<Bug> bugs) {
 		this.bugs = bugs;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/collectionelement/Products.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/collectionelement/Products.java
index 0ed2eb347f..b12f5fbbf0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/collectionelement/Products.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/collectionelement/Products.java
@@ -1,37 +1,37 @@
 package org.hibernate.test.annotations.collectionelement;
 import java.util.Set;
 import javax.persistence.ElementCollection;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OrderBy;
 
 @SuppressWarnings({"unchecked", "serial"})
 
 @Entity
 public class Products {
 	@Id
 	@GeneratedValue
 	private Integer id;
 	
 	@ElementCollection
 	@OrderBy("name ASC")
 	private Set<Widgets> widgets;
 
 	public Integer getId() {
 		return id;
 	}
 
 	public void setId(Integer id) {
 		this.id = id;
 	}
 
 	public Set<Widgets> getWidgets() {
 		return widgets;
 	}
 
 	public void setWidgets(Set<Widgets> widgets) {
 		this.widgets = widgets;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/collectionelement/TestCourse.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/collectionelement/TestCourse.java
index 49361bbb81..c6aa64df2b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/collectionelement/TestCourse.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/collectionelement/TestCourse.java
@@ -1,41 +1,41 @@
 //$Id$
 package org.hibernate.test.annotations.collectionelement;
 import javax.persistence.Embedded;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 
 import org.hibernate.annotations.FilterDef;
 import org.hibernate.annotations.ParamDef;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 @FilterDef(name="selectedLocale", parameters={ @ParamDef( name="param", type="string" ) } )
 public class TestCourse {
 
 	private Long testCourseId;
 
 	private LocalizedString title;
 
 	@Id
 	@GeneratedValue(strategy = GenerationType.AUTO)
 	public Long getTestCourseId() {
 		return testCourseId;
 	}
 
 	public void setTestCourseId(Long testCourseId) {
 		this.testCourseId = testCourseId;
 	}
 
 	@Embedded
 	public LocalizedString getTitle() {
 		return title;
 	}
 
 	public void setTitle(LocalizedString title) {
 		this.title = title;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/Employer.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/Employer.java
index be5006d585..d6abd53c5f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/Employer.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/Employer.java
@@ -1,55 +1,55 @@
 // $Id:$
 /*
 * JBoss, Home of Professional Open Source
 * Copyright 2009, Red Hat, Inc. and/or its affiliates, and individual contributors
 * by the @authors tag. See the copyright.txt in the distribution for a
 * full listing of individual contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 package org.hibernate.test.annotations.derivedidentities;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.IdClass;
 import javax.persistence.ManyToOne;
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 @IdClass(EmployerId.class)
 public class Employer {
 	@Id
 	String name;
 
 	@Id
 	@ManyToOne
 	Employee employee;
 
 	public Employer() {
 	}
 
 	public Employer(String name) {
 		this.name = name;
 	}
 
 	public Employee getEmployee() {
 		return employee;
 	}
 
 	public void setEmployee(Employee emp) {
 		this.employee = emp;
 	}
 
 	public String getName() {
 		return name;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/EmployerId.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/EmployerId.java
index 702f940fb8..ce78815ded 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/EmployerId.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/EmployerId.java
@@ -1,42 +1,42 @@
 // $Id:$
 /*
 * JBoss, Home of Professional Open Source
 * Copyright 2009, Red Hat, Inc. and/or its affiliates, and individual contributors
 * by the @authors tag. See the copyright.txt in the distribution for a
 * full listing of individual contributors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * http://www.apache.org/licenses/LICENSE-2.0
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
 package org.hibernate.test.annotations.derivedidentities;
 import java.io.Serializable;
 
 /**
  * @author Hardy Ferentschik
  */
 public class EmployerId implements Serializable {
 	String name; // matches name of @Id attribute
 	long employee; // matches name of @Id attribute and type of Employee PK
 
 	public EmployerId() {
 	}
 
 	public EmployerId(String name) {
 		this.name = name;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setEmployee(long employee) {
 		this.employee = employee;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/Dependent.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/Dependent.java
index d2867a93af..44423520ac 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/Dependent.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/Dependent.java
@@ -1,41 +1,41 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.derivedidentities.bidirectional;
 import java.io.Serializable;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.ManyToOne;
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 //@IdClass(DependentId.class)
 public class Dependent implements Serializable {
 	@Id
 	@ManyToOne
 	Employee emp;
 
 	String name;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/DerivedIdentityWithBidirectionalAssociationTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/DerivedIdentityWithBidirectionalAssociationTest.java
index d974500302..334857d80e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/DerivedIdentityWithBidirectionalAssociationTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/DerivedIdentityWithBidirectionalAssociationTest.java
@@ -1,75 +1,75 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.derivedidentities.bidirectional;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.test.util.SchemaUtil;
 import org.hibernate.testing.Skip;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Hardy Ferentschik
  */
 @Skip( condition = Skip.AlwaysSkip.class,message = "sdf")
 public class DerivedIdentityWithBidirectionalAssociationTest extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testBidirectionalAssociation() throws Exception {
 		assertTrue( SchemaUtil.isColumnPresent( "Dependent", "emp_empId", configuration() ) );
 		assertTrue( !SchemaUtil.isColumnPresent( "Dependent", "empPK", configuration() ) );
 		Employee e = new Employee();
 		e.empId = 1;
 		e.empName = "Emmanuel";
 
 		Session s = openSession();
 		s.getTransaction().begin();
 		s.persist( e );
 		Dependent d = new Dependent();
 		d.emp = e;
 		s.persist( d );
 		s.flush();
 		s.clear();
 		d = getDerivedClassById( e, s, Dependent.class );
 		assertEquals( e.empId, d.emp.empId );
 		s.getTransaction().rollback();
 		s.close();
 	}
 
 	private <T> T getDerivedClassById(Employee e, Session s, Class<T> clazz) {
 		return clazz.cast( s.createQuery( "from " + clazz.getName() + " d where d.emp.empId = :empId" )
 						.setParameter( "empId", e.empId ).uniqueResult() );
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] {
 				Dependent.class,
 				Employee.class
 		};
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/Employee.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/Employee.java
index a220ea52d7..b074e2be71 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/Employee.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/Employee.java
@@ -1,42 +1,42 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.derivedidentities.bidirectional;
 import java.util.Set;
 import javax.persistence.Entity;
 import javax.persistence.FetchType;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 public class Employee {
 	@Id
 	long empId;
 	String empName;
 
 	@OneToMany(mappedBy = "emp", fetch = FetchType.LAZY)
 	private Set<Dependent> dependents;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/Person.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/Person.java
index 77a0727489..504a79c663 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/Person.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/Person.java
@@ -1,77 +1,77 @@
 package org.hibernate.test.annotations.derivedidentities.bidirectional;
 
 import java.io.Serializable;
 import javax.persistence.Basic;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 import javax.persistence.NamedQuery;
 import javax.persistence.OneToOne;
 
 @Entity
 @NamedQuery(name="PersonQuery", query="SELECT p FROM Person p")
 public class Person
   implements Serializable
 {
   private static final long serialVersionUID = 1L;
 
   @Id
   @GeneratedValue(strategy=GenerationType.AUTO)
   private Integer id;
 
   @Basic
   private String name;
 
   @OneToOne(mappedBy="id")
   private PersonInfo personInfo;
 
   public Integer getId()
   {
     return this.id;
   }
 
   public void setId(Integer id) {
     this.id = id;
   }
 
   public String getName() {
     return this.name;
   }
 
   public void setName(String name) {
     this.name = name;
   }
 
   public int hashCode()
   {
     int hash = 0;
     hash += (this.id != null ? this.id.hashCode() : 0);
     return hash;
   }
 
   public boolean equals(Object object)
   {
     if (!(object instanceof Person)) {
       return false;
     }
     Person other = (Person)object;
 
     return ((this.id != null) || (other.id == null)) && ((this.id == null) || (this.id.equals(other.id)));
   }
 
   public String toString()
   {
     return "nogroup.hibertest.Person[ id=" + this.id + " ]";
   }
 
   public PersonInfo getPersonInfo()
   {
     return this.personInfo;
   }
 
   public void setPersonInfo(PersonInfo personInfo)
   {
     this.personInfo = personInfo;
   }
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/PersonInfo.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/PersonInfo.java
index 08a1ff9714..b209b4e95f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/PersonInfo.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/bidirectional/PersonInfo.java
@@ -1,60 +1,60 @@
 package org.hibernate.test.annotations.derivedidentities.bidirectional;
 
 import java.io.Serializable;
 import javax.persistence.Basic;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.OneToOne;
 
 @Entity
 public class PersonInfo
   implements Serializable
 {
   private static final long serialVersionUID = 1L;
 
   @Id
   @OneToOne
   private Person id;
 
   @Basic
   private String info;
 
   public Person getId()
   {
     return this.id;
   }
 
   public void setId(Person id) {
     this.id = id;
   }
 
   public String getInfo() {
     return this.info;
   }
 
   public void setInfo(String info) {
     this.info = info;
   }
 
   public int hashCode()
   {
     int hash = 0;
     hash += (this.id != null ? this.id.hashCode() : 0);
     return hash;
   }
 
   public boolean equals(Object object)
   {
     if (!(object instanceof PersonInfo)) {
       return false;
     }
     PersonInfo other = (PersonInfo)object;
 
     return ((this.id != null) || (other.id == null)) && ((this.id == null) || (this.id.equals(other.id)));
   }
 
   public String toString()
   {
     return "nogroup.hibertest.PersonInfo[ id=" + this.id + " ]";
   }
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e1/a/DependentId.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e1/a/DependentId.java
index fde1fc0acf..b940a1305b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e1/a/DependentId.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e1/a/DependentId.java
@@ -1,34 +1,34 @@
 package org.hibernate.test.annotations.derivedidentities.e1.a;
 import java.io.Serializable;
 
 /**
  * @author Emmanuel Bernard
  */
 public class DependentId implements Serializable {
 	String name;
 	long emp;	// corresponds to PK type of Employee
 
 	public DependentId() {
 	}
 
 	public DependentId(String name, long emp) {
 		this.name = name;
 		this.emp = emp;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	public long getEmp() {
 		return emp;
 	}
 
 	public void setEmp(long emp) {
 		this.emp = emp;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e1/a/DerivedIdentitySimpleParentIdClassDepTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e1/a/DerivedIdentitySimpleParentIdClassDepTest.java
index 17daf24336..9ae6942783 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e1/a/DerivedIdentitySimpleParentIdClassDepTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e1/a/DerivedIdentitySimpleParentIdClassDepTest.java
@@ -1,97 +1,97 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.derivedidentities.e1.a;
 
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.Query;
 import org.hibernate.Session;
 import org.hibernate.test.util.SchemaUtil;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Emmanuel Bernard
  */
 public class DerivedIdentitySimpleParentIdClassDepTest extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testManyToOne() throws Exception {
 		assertTrue( SchemaUtil.isColumnPresent( "Dependent", "emp_empId", configuration() ) );
 		assertTrue( ! SchemaUtil.isColumnPresent( "Dependent", "emp", configuration() ) );
 
 		Session s = openSession();
 		s.getTransaction().begin();
 		Employee e = new Employee( 1L, "Emmanuel", "Manu" );
 		Dependent d = new Dependent( "Doggy", e );
 		s.persist( d );
 		s.persist( e );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.getTransaction().begin();
 		DependentId dId = new DependentId( d.getName(), d.getEmp().empId );
 		d = (Dependent) s.get( Dependent.class, dId );
 		assertEquals( e.empId, d.getEmp().empId );
 		assertEquals( e.empName, d.getEmp().empName );
 		assertEquals( e.nickname, d.getEmp().nickname );
 		s.delete( d );
 		s.delete( d.getEmp() );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testQueryNewEntityInPC() throws Exception {
 		Session s = openSession();
 		s.getTransaction().begin();
 		Employee e = new Employee( 1L, "Paula", "P" );
 		Dependent d = new Dependent( "LittleP", e );
 		d.setEmp(e);
 		s.persist( d );
 		s.persist( e );
 
 		// find the entity added above
 		Query query = s.createQuery("Select d from Dependent d where d.name='LittleP' and d.emp.empName='Paula'");
 		List depList = query.list();
 		assertEquals( 1, depList.size() );
 		Object newDependent = depList.get(0);
 		assertSame( d, newDependent );
 		s.getTransaction().rollback();
 		s.close();
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] {
 				Dependent.class,
 				Employee.class
 		};
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e1/a/Employee.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e1/a/Employee.java
index 8cf009d011..f35de85fa0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e1/a/Employee.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e1/a/Employee.java
@@ -1,48 +1,48 @@
 package org.hibernate.test.annotations.derivedidentities.e1.a;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class Employee {
 	long empId;
 	String empName;
 
 	String nickname;
 
 	public Employee() {
 	}
 
 	public Employee(long empId, String empName, String nickname) {
 		this.empId = empId;
 		this.empName = empName;
 		this.nickname = nickname;
 	}
 
 	@Id
 	public long getEmpId() {
 		return empId;
 	}
 
 	public void setEmpId(long empId) {
 		this.empId = empId;
 	}
 
 	public String getEmpName() {
 		return empName;
 	}
 
 	public void setEmpName(String empName) {
 		this.empName = empName;
 	}
 
 	public String getNickname() {
 		return nickname;
 	}
 
 	public void setNickname(String nickname) {
 		this.nickname = nickname;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/a/Employee.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/a/Employee.java
index aa310e437b..43258364e1 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/a/Employee.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/a/Employee.java
@@ -1,14 +1,14 @@
 package org.hibernate.test.annotations.derivedidentities.e2.a;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.IdClass;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 @IdClass(EmployeeId.class)
 public class Employee {
 	@Id String firstName;
 	@Id String lastName;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/b/DependentId.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/b/DependentId.java
index e1a5c0105b..a55023c1bf 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/b/DependentId.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/b/DependentId.java
@@ -1,12 +1,12 @@
 package org.hibernate.test.annotations.derivedidentities.e2.b;
 import java.io.Serializable;
 import javax.persistence.Embeddable;
 
 /**
  * @author Emmanuel Bernard
  */
 @Embeddable
 public class DependentId implements Serializable {
 	String name;
 	EmployeeId empPK;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/b/Employee.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/b/Employee.java
index 40681b64a7..faab774632 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/b/Employee.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/b/Employee.java
@@ -1,16 +1,16 @@
 package org.hibernate.test.annotations.derivedidentities.e2.b;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.IdClass;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 @IdClass(EmployeeId.class)
 public class Employee {
 	@Id
 	String firstName;
 	@Id
 	String lastName;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/b/EmployeeId.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/b/EmployeeId.java
index 461188837f..898c5187e0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/b/EmployeeId.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e2/b/EmployeeId.java
@@ -1,10 +1,10 @@
 package org.hibernate.test.annotations.derivedidentities.e2.b;
 import java.io.Serializable;
 
 /**
  * @author Emmanuel Bernard
  */
 public class EmployeeId implements Serializable {
 	String firstName;
 	String lastName;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e3/b/Dependent.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e3/b/Dependent.java
index e4246677cb..8142866635 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e3/b/Dependent.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e3/b/Dependent.java
@@ -1,30 +1,30 @@
 package org.hibernate.test.annotations.derivedidentities.e3.b;
 import javax.persistence.AttributeOverride;
 import javax.persistence.Column;
 import javax.persistence.EmbeddedId;
 import javax.persistence.Entity;
 import javax.persistence.JoinColumn;
 import javax.persistence.JoinColumns;
 import javax.persistence.ManyToOne;
 import javax.persistence.MapsId;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class Dependent {
 	// default column name for "name" attribute is overridden
 	@AttributeOverride(name = "name", column = @Column(name = "dep_name"))
 	@EmbeddedId
 	DependentId id;
 
 
 	@MapsId("empPK")
 	@JoinColumns({
 			@JoinColumn(name = "FK1", referencedColumnName = "FIRSTNAME"),
 			@JoinColumn(name = "FK2", referencedColumnName = "lastName")
 	})
 	@ManyToOne
 	Employee emp;
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/DerivedIdentitySimpleParentSimpleDepTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/DerivedIdentitySimpleParentSimpleDepTest.java
index 561c3b0a56..634a6b317a 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/DerivedIdentitySimpleParentSimpleDepTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/DerivedIdentitySimpleParentSimpleDepTest.java
@@ -1,136 +1,136 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.derivedidentities.e4.a;
 
 import java.util.Date;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.test.util.SchemaUtil;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Emmanuel Bernard
  */
 public class DerivedIdentitySimpleParentSimpleDepTest extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testOneToOneExplicitJoinColumn() throws Exception {
 		assertTrue( SchemaUtil.isColumnPresent( "MedicalHistory", "FK", configuration() ) );
 		assertTrue( ! SchemaUtil.isColumnPresent( "MedicalHistory", "id", configuration() ) );
 
 		Session s = openSession();
 		s.getTransaction().begin();
 		Person person = new Person( "aaa" );
 		s.persist( person );
 		MedicalHistory medicalHistory = new MedicalHistory( person );
 		s.persist( medicalHistory );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.getTransaction().begin();
 		medicalHistory = (MedicalHistory) s.get( MedicalHistory.class, "aaa" );
 		assertEquals( person.ssn, medicalHistory.patient.ssn );
 		medicalHistory.lastupdate = new Date();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.getTransaction().begin();
 		medicalHistory = (MedicalHistory) s.get( MedicalHistory.class, "aaa" );
 		assertNotNull( medicalHistory.lastupdate );
 		s.delete( medicalHistory );
 		s.delete( medicalHistory.patient );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testManyToOneExplicitJoinColumn() throws Exception {
 		assertTrue( SchemaUtil.isColumnPresent( "FinancialHistory", "patient_ssn", configuration() ) );
 		assertTrue( ! SchemaUtil.isColumnPresent( "FinancialHistory", "id", configuration() ) );
 
 		Session s = openSession();
 		s.getTransaction().begin();
 		Person person = new Person( "aaa" );
 		s.persist( person );
 		FinancialHistory financialHistory = new FinancialHistory( person );
 		s.persist( financialHistory );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.getTransaction().begin();
 		financialHistory = (FinancialHistory) s.get( FinancialHistory.class, "aaa" );
 		assertEquals( person.ssn, financialHistory.patient.ssn );
 		financialHistory.lastUpdate = new Date();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.getTransaction().begin();
 		financialHistory = (FinancialHistory) s.get( FinancialHistory.class, "aaa" );
 		assertNotNull( financialHistory.lastUpdate );
 		s.delete( financialHistory );
 		s.delete( financialHistory.patient );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSimplePkValueLoading() {
 		Session s = openSession();
 		s.getTransaction().begin();
 		Person e = new Person( "aaa" );
 		s.persist( e );
 		FinancialHistory d = new FinancialHistory( e );
 		s.persist( d );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.getTransaction().begin();
 		FinancialHistory history = (FinancialHistory) s.get( FinancialHistory.class, "aaa" );
 		assertNotNull( history );
 		s.delete( history );
 		s.delete( history.patient );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] {
 				MedicalHistory.class,
 				Simple.class,
 				Person.class,
 				FinancialHistory.class
 		};
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/FinancialHistory.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/FinancialHistory.java
index 348313b26f..1bf9edfdb9 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/FinancialHistory.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/FinancialHistory.java
@@ -1,30 +1,30 @@
 package org.hibernate.test.annotations.derivedidentities.e4.a;
 import java.io.Serializable;
 import java.util.Date;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.ManyToOne;
 import javax.persistence.Temporal;
 import javax.persistence.TemporalType;
 
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class FinancialHistory implements Serializable {
 	@Id
 	//@JoinColumn(name = "FK")
 	@ManyToOne
 	Person patient;
 
 	@Temporal(TemporalType.DATE)
 	Date lastUpdate;
 
 	public FinancialHistory() {
 	}
 
 	public FinancialHistory(Person patient) {
 		this.patient = patient;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/MedicalHistory.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/MedicalHistory.java
index e50fb34b91..a232e3ced7 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/MedicalHistory.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/MedicalHistory.java
@@ -1,31 +1,31 @@
 package org.hibernate.test.annotations.derivedidentities.e4.a;
 import java.io.Serializable;
 import java.util.Date;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.JoinColumn;
 import javax.persistence.OneToOne;
 import javax.persistence.Temporal;
 import javax.persistence.TemporalType;
 
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class MedicalHistory implements Serializable {
 	@Id
 	@JoinColumn(name = "FK")
 	@OneToOne
 	Person patient;
 
 	@Temporal(TemporalType.DATE)
 	Date lastupdate;
 
 	public MedicalHistory() {
 	}
 
 	public MedicalHistory(Person patient) {
 		this.patient = patient;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/Person.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/Person.java
index 837e723bca..40c870f01a 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/Person.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/a/Person.java
@@ -1,19 +1,19 @@
 package org.hibernate.test.annotations.derivedidentities.e4.a;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class Person {
 	@Id
 	String ssn;
 
 	public Person() {
 	}
 
 	public Person(String ssn) {
 		this.ssn = ssn;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/b/DerivedIdentitySimpleParentSimpleDepMapsIdTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/b/DerivedIdentitySimpleParentSimpleDepMapsIdTest.java
index 13f6054511..5e877a2185 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/b/DerivedIdentitySimpleParentSimpleDepMapsIdTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/b/DerivedIdentitySimpleParentSimpleDepMapsIdTest.java
@@ -1,143 +1,143 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.derivedidentities.e4.b;
 
 import java.util.Date;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.test.util.SchemaUtil;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Emmanuel Bernard
  */
 public class DerivedIdentitySimpleParentSimpleDepMapsIdTest extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testOneToOneExplicitJoinColumn() throws Exception {
 		assertTrue( SchemaUtil.isColumnPresent( "MedicalHistory", "FK", configuration() ) );
 		assertTrue( ! SchemaUtil.isColumnPresent( "MedicalHistory", "id", configuration() ) );
 		Person e = new Person();
 		e.ssn = "aaa";
 		Session s = openSession(  );
 		s.getTransaction().begin();
 		s.persist( e );
 		MedicalHistory d = new MedicalHistory();
 		d.patient = e;
 		//d.id = "aaa"; //FIXME not needed when foreign is enabled
 		s.persist( d );
 		s.flush();
 		s.clear();
 		d = (MedicalHistory) s.get( MedicalHistory.class, d.id );
 		assertEquals( d.id, d.patient.ssn );
 		d.lastupdate = new Date();
 		s.flush();
 		s.clear();
 		d = (MedicalHistory) s.get( MedicalHistory.class, d.id );
 		assertNotNull( d.lastupdate );
 		s.getTransaction().rollback();
 		s.close();
 	}
 
 	@Test
 	public void testManyToOneExplicitJoinColumn() throws Exception {
 		assertTrue( SchemaUtil.isColumnPresent( "FinancialHistory", "FK", configuration() ) );
 		assertTrue( ! SchemaUtil.isColumnPresent( "FinancialHistory", "id", configuration() ) );
 		Person e = new Person();
 		e.ssn = "aaa";
 		Session s = openSession(  );
 		s.getTransaction().begin();
 		s.persist( e );
 		FinancialHistory d = new FinancialHistory();
 		d.patient = e;
 		//d.id = "aaa"; //FIXME not needed when foreign is enabled
 		s.persist( d );
 		s.flush();
 		s.clear();
 		d = (FinancialHistory) s.get( FinancialHistory.class, d.id );
 		assertEquals( d.id, d.patient.ssn );
 		d.lastupdate = new Date();
 		s.flush();
 		s.clear();
 		d = (FinancialHistory) s.get( FinancialHistory.class, d.id );
 		assertNotNull( d.lastupdate );
 		s.getTransaction().rollback();
 		s.close();
 	}
 
 	@Test
 	public void testExplicitlyAssignedDependentIdAttributeValue() {
 		// even though the id is by definition generated (using the "foreign" strategy), JPA
 		// still does allow manually setting the generated id attribute value which providers
 		// are expected to promptly disregard :?
 		Session s = openSession();
 		s.beginTransaction();
 		Person person = new Person( "123456789" );
 		MedicalHistory medicalHistory = new MedicalHistory( "987654321", person );
 		s.persist( person );
 		s.persist( medicalHistory );
 		s.getTransaction().commit();
 		s.close();
 
 		// again, even though we specified an id value of "987654321" prior to persist,
 		// Hibernate should have replaced that with the "123456789" from the associated
 		// person
 		assertEquals( person.ssn, medicalHistory.patient.ssn );
 		assertEquals( person, medicalHistory.patient );
 		assertEquals( person.ssn, medicalHistory.id );
 
 		s = openSession();
 		s.beginTransaction();
 		// Should return null...
 		MedicalHistory separateMedicalHistory = (MedicalHistory) s.get( MedicalHistory.class, "987654321" );
 		assertNull( separateMedicalHistory );
 		// Now we should find it...
 		separateMedicalHistory = (MedicalHistory) s.get( MedicalHistory.class, "123456789" );
 		assertNotNull( separateMedicalHistory );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( medicalHistory );
 		s.delete( person );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] {
 				MedicalHistory.class,
 				Person.class,
 				FinancialHistory.class
 		};
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/b/Person.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/b/Person.java
index af7bf7dab7..5fd0c8b754 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/b/Person.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e4/b/Person.java
@@ -1,19 +1,19 @@
 package org.hibernate.test.annotations.derivedidentities.e4.b;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class Person {
 	@Id
 	String ssn;
 
 	public Person() {
 	}
 
 	public Person(String ssn) {
 		this.ssn = ssn;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e5/b/MedicalHistory.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e5/b/MedicalHistory.java
index df9274b084..940deb0d27 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e5/b/MedicalHistory.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e5/b/MedicalHistory.java
@@ -1,25 +1,25 @@
 package org.hibernate.test.annotations.derivedidentities.e5.b;
 import javax.persistence.EmbeddedId;
 import javax.persistence.Entity;
 import javax.persistence.JoinColumn;
 import javax.persistence.JoinColumns;
 import javax.persistence.MapsId;
 import javax.persistence.OneToOne;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class MedicalHistory {
 	//all attributes map to relationship: AttributeOverride not allowed
 	@EmbeddedId
 	PersonId id;
 
 	@MapsId
 	@JoinColumns({
 			@JoinColumn(name = "FK1", referencedColumnName = "firstName"),
 			@JoinColumn(name = "FK2", referencedColumnName = "lastName")
 	})
 	@OneToOne
 	Person patient;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e5/c/MedicalHistory.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e5/c/MedicalHistory.java
index 44d7e6c1ac..e1b14114a6 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e5/c/MedicalHistory.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e5/c/MedicalHistory.java
@@ -1,22 +1,22 @@
 package org.hibernate.test.annotations.derivedidentities.e5.c;
 import java.io.Serializable;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.JoinColumn;
 import javax.persistence.MapsId;
 import javax.persistence.OneToOne;
 
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class MedicalHistory implements Serializable {
 	@Id
 	Integer id;
 
 	@MapsId
 	@JoinColumn(name = "patient_id")
 	@OneToOne
 	Person patient;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e5/c/Person.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e5/c/Person.java
index 9cb2602230..64386502bc 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e5/c/Person.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e5/c/Person.java
@@ -1,13 +1,13 @@
 package org.hibernate.test.annotations.derivedidentities.e5.c;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class Person {
 	@Id @GeneratedValue
 	Integer id;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/a/DerivedIdentityEmbeddedIdParentSameIdTypeIdClassDepTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/a/DerivedIdentityEmbeddedIdParentSameIdTypeIdClassDepTest.java
index cfa1b469e4..f848e1b259 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/a/DerivedIdentityEmbeddedIdParentSameIdTypeIdClassDepTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/a/DerivedIdentityEmbeddedIdParentSameIdTypeIdClassDepTest.java
@@ -1,74 +1,74 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.derivedidentities.e6.a;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.test.util.SchemaUtil;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Emmanuel Bernard
  */
 public class DerivedIdentityEmbeddedIdParentSameIdTypeIdClassDepTest extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testOneToOneExplicitJoinColumn() throws Exception {
 		assertTrue( SchemaUtil.isColumnPresent( "MedicalHistory", "FK1", configuration() ) );
 		assertTrue( SchemaUtil.isColumnPresent( "MedicalHistory", "FK2", configuration() ) );
 		assertTrue( ! SchemaUtil.isColumnPresent( "MedicalHistory", "firstname", configuration() ) );
 		Person e = new Person();
 		e.id = new PersonId();
 		e.id.firstName = "Emmanuel";
 		e.id.lastName = "Bernard";
 		Session s = openSession(  );
 		s.getTransaction().begin();
 		s.persist( e );
 		MedicalHistory d = new MedicalHistory();
 		d.patient = e;
 		s.persist( d );
 		s.flush();
 		s.clear();
 		PersonId pId = new PersonId();
 		pId.firstName = e.id.firstName;
 		pId.lastName = e.id.lastName;
 		d = (MedicalHistory) s.get( MedicalHistory.class, pId );
 		assertEquals( pId.firstName, d.patient.id.firstName );
 		s.delete( d );
 		s.delete( d.patient );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] {
 				MedicalHistory.class,
 				Person.class
 		};
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/DerivedIdentityEmbeddedIdParentSameIdTypeEmbeddedIdDepTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/DerivedIdentityEmbeddedIdParentSameIdTypeEmbeddedIdDepTest.java
index cc21d75f27..ff97c4b81a 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/DerivedIdentityEmbeddedIdParentSameIdTypeEmbeddedIdDepTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/DerivedIdentityEmbeddedIdParentSameIdTypeEmbeddedIdDepTest.java
@@ -1,72 +1,72 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.derivedidentities.e6.b;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.test.util.SchemaUtil;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Emmanuel Bernard
  */
 public class DerivedIdentityEmbeddedIdParentSameIdTypeEmbeddedIdDepTest extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testOneToOneExplicitJoinColumn() throws Exception {
 		assertTrue( SchemaUtil.isColumnPresent( "MedicalHistory", "FK1", configuration() ) );
 		assertTrue( SchemaUtil.isColumnPresent( "MedicalHistory", "FK2", configuration() ) );
 		assertTrue( ! SchemaUtil.isColumnPresent( "MedicalHistory", "firstname", configuration() ) );
 		Person e = new Person();
 		e.id = new PersonId();
 		e.id.firstName = "Emmanuel";
 		e.id.lastName = "Bernard";
 		Session s = openSession(  );
 		s.getTransaction().begin();
 		s.persist( e );
 		MedicalHistory d = new MedicalHistory();
 //		d.id = new PersonId();
 //		d.id.firstName = "Emmanuel"; //FIXME not needed when foreign is enabled
 //		d.id.lastName = "Bernard"; //FIXME not needed when foreign is enabled
 		d.patient = e;
 		s.persist( d );
 		s.flush();
 		s.clear();
 		d = (MedicalHistory) s.get( MedicalHistory.class, d.id );
 		assertEquals( d.id.firstName, d.patient.id.firstName );
 		s.getTransaction().rollback();
 		s.close();
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] {
 				MedicalHistory.class,
 				Person.class
 		};
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/MedicalHistory.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/MedicalHistory.java
index b3a4f93138..66ff36f640 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/MedicalHistory.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/MedicalHistory.java
@@ -1,25 +1,25 @@
 package org.hibernate.test.annotations.derivedidentities.e6.b;
 import javax.persistence.EmbeddedId;
 import javax.persistence.Entity;
 import javax.persistence.JoinColumn;
 import javax.persistence.JoinColumns;
 import javax.persistence.MapsId;
 import javax.persistence.OneToOne;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class MedicalHistory {
 	//all attributes map to relationship: AttributeOverride not allowed
 	@EmbeddedId
 	PersonId id;
 
 	@MapsId
 	@JoinColumns({
 			@JoinColumn(name = "FK1", referencedColumnName = "firstName"),
 			@JoinColumn(name = "FK2", referencedColumnName = "lastName")
 	})
 	@OneToOne
 	Person patient;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/Person.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/Person.java
index b09159664f..c003aa335a 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/Person.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/Person.java
@@ -1,12 +1,12 @@
 package org.hibernate.test.annotations.derivedidentities.e6.b;
 import javax.persistence.EmbeddedId;
 import javax.persistence.Entity;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class Person {
 	@EmbeddedId
 	PersonId id;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/PersonId.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/PersonId.java
index ab8b941cb9..f2261159dc 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/PersonId.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/derivedidentities/e6/b/PersonId.java
@@ -1,12 +1,12 @@
 package org.hibernate.test.annotations.derivedidentities.e6.b;
 import java.io.Serializable;
 import javax.persistence.Embeddable;
 
 /**
  * @author Emmanuel Bernard
  */
 @Embeddable
 public class PersonId implements Serializable {
 	String firstName;
 	String lastName;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/embedded/EmbeddableB.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/embedded/EmbeddableB.java
index 85f0e53728..5bb2c356cb 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/embedded/EmbeddableB.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/embedded/EmbeddableB.java
@@ -1,40 +1,40 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2013 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.test.annotations.embedded;
 
 import javax.persistence.Embeddable;
 
 /**
  * @author Brett Meyer
  */
 @Embeddable
 public class EmbeddableB {
 	
 	private String embedAttrB;
 
 	public String getEmbedAttrB() {
 		return embedAttrB;
 	}
 
 	public void setEmbedAttrB(String embedAttrB) {
 		this.embedAttrB = embedAttrB;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/embedded/many2one/Country.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/embedded/many2one/Country.java
index 65073a58cd..978c66cf23 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/embedded/many2one/Country.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/embedded/many2one/Country.java
@@ -1,63 +1,63 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.embedded.many2one;
 import java.io.Serializable;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 
 /**
  * THe entity target of the many-to-one from a component/embeddable.
  *
  * @author Steve Ebersole
  */
 @Entity
 public class Country implements Serializable {
 	private String iso2;
 	private String name;
 
 	public Country() {
 	}
 
 	public Country(String iso2, String name) {
 		this.iso2 = iso2;
 		this.name = name;
 	}
 
 	@Id
 	public String getIso2() {
 		return iso2;
 	}
 
 	public void setIso2(String iso2) {
 		this.iso2 = iso2;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/embedded/one2many/EmbeddableWithOne2ManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/embedded/one2many/EmbeddableWithOne2ManyTest.java
index fff1badbfe..a3ff3cea90 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/embedded/one2many/EmbeddableWithOne2ManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/embedded/one2many/EmbeddableWithOne2ManyTest.java
@@ -1,81 +1,81 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.embedded.one2many;
 
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.testing.FailureExpected;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Steve Ebersole
  */
 public class EmbeddableWithOne2ManyTest extends BaseCoreFunctionalTestCase {
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 //		return new Class[] { Alias.class, Person.class };
 		return new Class[] {  };
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "HHH-4883")
 	public void testJoinAcrossEmbedded() {
 		// NOTE : this may or may not work now with HHH-4883 fixed,
 		// but i cannot do this checking until HHH-4599 is done.
 		Session session = openSession();
 		session.beginTransaction();
 		session.createQuery( "from Person p join p.name.aliases a where a.source = 'FBI'" )
 				.list();
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "HHH-4599")
 	public void testBasicOps() {
 		Session session = openSession();
 		session.beginTransaction();
 		Alias alias = new Alias( "Public Enemy", "Number 1", "FBI" );
 		session.persist( alias );
 		Person person = new Person( "John", "Dillinger" );
 		person.getName().getAliases().add( alias );
 		session.persist( person );
 		session.getTransaction().commit();
 		session.close();
 
 		session = openSession();
 		session.beginTransaction();
 		person = (Person) session.load( Person.class, person.getId() );
 		session.delete( person );
 		List aliases = session.createQuery( "from Alias" ).list();
 		assertEquals( 0, aliases.size() );
 		session.getTransaction().commit();
 		session.close();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/CasterStringType.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/CasterStringType.java
index 717dbe68cb..37f32503f3 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/CasterStringType.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/CasterStringType.java
@@ -1,90 +1,90 @@
 //$Id$
 package org.hibernate.test.annotations.entity;
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Types;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.usertype.ParameterizedType;
 import org.hibernate.usertype.UserType;
 
 /**
  * Sample of parameter type
  *
  * @author Emmanuel Bernard
  */
 public class CasterStringType implements UserType, ParameterizedType {
 	private static final String CAST = "cast";
 	private Properties parameters;
 
 	public int[] sqlTypes() {
 		return new int[]{Types.VARCHAR};
 	}
 
 	public Class returnedClass() {
 		return String.class;
 	}
 
 	public boolean equals(Object x, Object y) throws HibernateException {
 		return ( x == y ) || ( x != null && x.equals( y ) );
 	}
 
 	public int hashCode(Object x) throws HibernateException {
 		return x.hashCode();
 	}
 
 	public Object nullSafeGet(ResultSet rs, String[] names, SessionImplementor session, Object owner) throws HibernateException, SQLException {
 		String result = rs.getString( names[0] );
 		if ( rs.wasNull() ) return null;
 		if ( parameters.getProperty( CAST ).equals( "lower" ) ) {
 			return result.toLowerCase();
 		}
 		else {
 			return result.toUpperCase();
 		}
 	}
 
 	public void nullSafeSet(PreparedStatement st, Object value, int index, SessionImplementor session) throws HibernateException, SQLException {
 		if ( value == null ) {
 			st.setNull( index, sqlTypes()[0] );
 		}
 		else {
 			String string = (String) value;
 			if ( parameters.getProperty( CAST ).equals( "lower" ) ) {
 				string = string.toLowerCase();
 			}
 			else {
 				string = string.toUpperCase();
 			}
 			st.setString( index, string );
 		}
 	}
 
 	public Object deepCopy(Object value) throws HibernateException {
 		return value;
 	}
 
 	public boolean isMutable() {
 		return false;
 	}
 
 	public Serializable disassemble(Object value) throws HibernateException {
 		return (Serializable) value;
 	}
 
 	public Object assemble(Serializable cached, Object owner) throws HibernateException {
 		return cached;
 	}
 
 	public Object replace(Object original, Object target, Object owner) throws HibernateException {
 		return original;
 	}
 
 	public void setParameterValues(Properties parameters) {
 		this.parameters = parameters;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/Flight.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/Flight.java
index 47be2d8481..2c5d066dd1 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/Flight.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/Flight.java
@@ -1,48 +1,48 @@
 //$Id$
 package org.hibernate.test.annotations.entity;
 import java.io.Serializable;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.Inheritance;
 import javax.persistence.InheritanceType;
 import javax.persistence.Table;
 
 import org.hibernate.annotations.Formula;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity()
 @Table(name = "Formula_flight")
 @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
 public class Flight implements Serializable {
 	Long id;
 	long maxAltitudeInMilimeter;
 	long maxAltitude;
 
 	@Id
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long long1) {
 		id = long1;
 	}
 
 	public long getMaxAltitude() {
 		return maxAltitude;
 	}
 
 	public void setMaxAltitude(long maxAltitude) {
 		this.maxAltitude = maxAltitude;
 	}
 
 	@Formula("maxAltitude * 1000")
 	public long getMaxAltitudeInMilimeter() {
 		return maxAltitudeInMilimeter;
 	}
 
 	public void setMaxAltitudeInMilimeter(long maxAltitudeInMilimeter) {
 		this.maxAltitudeInMilimeter = maxAltitudeInMilimeter;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/Player.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/Player.java
index 471f8315ee..7c101f39d7 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/Player.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/Player.java
@@ -1,78 +1,78 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009, Red Hat, Inc. and/or its affiliates or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat, Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
 package org.hibernate.test.annotations.entity;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.ManyToOne;
 import javax.persistence.OneToOne;
 
 
 @Entity
 public class Player {
 
 	private int id;
 	private String name;
 	private SoccerTeam team;
 
 	// For the world cup of one versus one matches, we have
 	// teams with one player (1v1 team).
 	private SoccerTeam oneVoneTeam;
 
 	@Id
 	@GeneratedValue
 	public int getId() {
 		return id;
 	}
 	public void setId(int id) {
 		this.id = id;
 	}
 
 	@Column(name="name")
 	public String getName() {
 		return name;
 	}
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	@ManyToOne
 	public SoccerTeam getTeam() {
 		return team;
 	}
 	public void setTeam(SoccerTeam team) {
 		this.team = team;
 	}
 
 	@OneToOne
 	public SoccerTeam getOneVoneTeam() {
 		return oneVoneTeam;
 	}
 
 	public void setOneVoneTeam(SoccerTeam oneVoneTeam) {
 		this.oneVoneTeam = oneVoneTeam;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/SoccerTeam.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/SoccerTeam.java
index 9287172267..e21cac9697 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/SoccerTeam.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/entity/SoccerTeam.java
@@ -1,86 +1,86 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009, Red Hat, Inc. and/or its affiliates or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat, Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
 package org.hibernate.test.annotations.entity;
 import java.util.HashSet;
 import java.util.Set;
 import javax.persistence.CascadeType;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
 import javax.persistence.OneToOne;
 
 @Entity
 public class SoccerTeam {
 	@Id
 	@GeneratedValue
 	private int id;
 
 	String name;
 
 	@OneToMany(mappedBy="team",
 		orphanRemoval=true,
 		cascade = {CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH, CascadeType.DETACH})
 	private Set<Player> players = new HashSet<Player>();
 
 	@OneToOne(mappedBy="oneVoneTeam",
 		orphanRemoval=true,
 		cascade = {CascadeType.PERSIST, CascadeType.MERGE, CascadeType.REFRESH, CascadeType.DETACH})
 	private Player oneVonePlayer;
 
 	public int getId() {
 		return id;
 	}
 
 	public void setId(int id) {
 		this.id = id;
 	}
 
 	public Set<Player> getPlayers() {
 		return players;
 	}
 
 	public void addPlayer(Player val) {
 		players.add(val);
 		val.setTeam(this);
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	public Player getOneVonePlayer() {
 		return oneVonePlayer;
 	}
 
 	public void setOneVonePlayer(Player oneVonePlayer) {
 		this.oneVonePlayer = oneVonePlayer;
 	}
 	
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/fetch/Stay.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/fetch/Stay.java
index 55adcc687f..acf8f714cb 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/fetch/Stay.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/fetch/Stay.java
@@ -1,142 +1,142 @@
 //$Id$
 package org.hibernate.test.annotations.fetch;
 import java.io.Serializable;
 import java.util.Date;
 import javax.persistence.CascadeType;
 import javax.persistence.Entity;
 import javax.persistence.FetchType;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.JoinColumn;
 import javax.persistence.ManyToOne;
 import javax.persistence.Table;
 
 import org.hibernate.annotations.Fetch;
 import org.hibernate.annotations.FetchMode;
 import org.hibernate.annotations.LazyToOne;
 import org.hibernate.annotations.LazyToOneOption;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 @Table(name = "Stay")
 public class Stay implements Serializable {
 
 	// member declaration
 	private int id;
 	private Person person;
 	private Person oldPerson;
 	private Person veryOldPerson;
 	private Date startDate;
 	private Date endDate;
 	private String vessel;
 	private String authoriser;
 	private String comments;
 
 
 	// constructors
 	public Stay() {
 	}
 
 	public Stay(int id) {
 		this.id = id;
 	}
 
 	public Stay(Person person, Date startDate, Date endDate, String vessel, String authoriser, String comments) {
 		this.authoriser = authoriser;
 		this.endDate = endDate;
 		this.person = person;
 		this.startDate = startDate;
 		this.vessel = vessel;
 		this.comments = comments;
 	}
 
 
 	// properties
 	public String getAuthoriser() {
 		return authoriser;
 	}
 
 	public void setAuthoriser(String authoriser) {
 		this.authoriser = authoriser;
 	}
 
 	public String getComments() {
 		return comments;
 	}
 
 	public void setComments(String comments) {
 		this.comments = comments;
 	}
 
 	public Date getEndDate() {
 		return endDate;
 	}
 
 	public void setEndDate(Date endDate) {
 		this.endDate = endDate;
 	}
 
 	@Id
 	@GeneratedValue
 	public int getId() {
 		return id;
 	}
 
 	public void setId(int id) {
 		this.id = id;
 	}
 
 	@ManyToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
 	@JoinColumn(name = "person")
 	public Person getPerson() {
 		return person;
 	}
 
 	public void setPerson(Person person) {
 		this.person = person;
 	}
 
 	@ManyToOne(cascade = CascadeType.ALL)
 	@LazyToOne(LazyToOneOption.PROXY)
 	@Fetch(FetchMode.SELECT)
 	@JoinColumn(name = "oldperson")
 	public Person getOldPerson() {
 		return oldPerson;
 	}
 
 	public void setOldPerson(Person oldPerson) {
 		this.oldPerson = oldPerson;
 	}
 
 	@ManyToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
 	@LazyToOne(LazyToOneOption.PROXY)
 	@Fetch(FetchMode.JOIN)
 	@JoinColumn(name = "veryoldperson")
 	public Person getVeryOldPerson() {
 		return veryOldPerson;
 	}
 
 	public void setVeryOldPerson(Person veryOldPerson) {
 		this.veryOldPerson = veryOldPerson;
 	}
 
 	public Date getStartDate() {
 		return startDate;
 	}
 
 	public void setStartDate(Date startDate) {
 		this.startDate = startDate;
 	}
 
 	public String getVessel() {
 		return vessel;
 	}
 
 	public void setVessel(String vessel) {
 		this.vessel = vessel;
 	}
 
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer2.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer2.java
index 6e1897ad42..05d55085e5 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer2.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer2.java
@@ -1,87 +1,87 @@
 // $Id$
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.annotations.fetchprofile;
 import java.util.Set;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
 
 import org.hibernate.annotations.FetchMode;
 import org.hibernate.annotations.FetchProfile;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 @FetchProfile(name = "customer-with-orders", fetchOverrides = {
 		@FetchProfile.FetchOverride(entity = Customer2.class, association = "foo", mode = FetchMode.JOIN)
 })
 public class Customer2 {
 	@Id
 	@GeneratedValue
 	private long id;
 
 	private String name;
 
 	private long customerNumber;
 
 	@OneToMany
 	private Set<Order> orders;
 
 	public long getCustomerNumber() {
 		return customerNumber;
 	}
 
 	public void setCustomerNumber(long customerNumber) {
 		this.customerNumber = customerNumber;
 	}
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	public Set<Order> getOrders() {
 		return orders;
 	}
 
 	public void setOrders(Set<Order> orders) {
 		this.orders = orders;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer3.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer3.java
index 82430e8a95..a9f4e047e6 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer3.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer3.java
@@ -1,87 +1,87 @@
 // $Id$
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.annotations.fetchprofile;
 import java.util.Set;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
 
 import org.hibernate.annotations.FetchMode;
 import org.hibernate.annotations.FetchProfile;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 @FetchProfile(name = "wrong-class-name", fetchOverrides = {
 		@FetchProfile.FetchOverride(entity = Order.class, association = "orders", mode = FetchMode.JOIN)
 })
 public class Customer3 {
 	@Id
 	@GeneratedValue
 	private long id;
 
 	private String name;
 
 	private long customerNumber;
 
 	@OneToMany
 	private Set<Order> orders;
 
 	public long getCustomerNumber() {
 		return customerNumber;
 	}
 
 	public void setCustomerNumber(long customerNumber) {
 		this.customerNumber = customerNumber;
 	}
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	public Set<Order> getOrders() {
 		return orders;
 	}
 
 	public void setOrders(Set<Order> orders) {
 		this.orders = orders;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer4.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer4.java
index 140b1dc3a1..1e046e771f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer4.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer4.java
@@ -1,87 +1,87 @@
 // $Id$
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.annotations.fetchprofile;
 import java.util.Set;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
 
 import org.hibernate.annotations.FetchMode;
 import org.hibernate.annotations.FetchProfile;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 @FetchProfile(name = "unsupported-fetch-mode", fetchOverrides = {
 		@FetchProfile.FetchOverride(entity = Customer4.class, association = "orders", mode = FetchMode.SELECT)
 })
 public class Customer4 {
 	@Id
 	@GeneratedValue
 	private long id;
 
 	private String name;
 
 	private long customerNumber;
 
 	@OneToMany
 	private Set<Order> orders;
 
 	public long getCustomerNumber() {
 		return customerNumber;
 	}
 
 	public void setCustomerNumber(long customerNumber) {
 		this.customerNumber = customerNumber;
 	}
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	public Set<Order> getOrders() {
 		return orders;
 	}
 
 	public void setOrders(Set<Order> orders) {
 		this.orders = orders;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer5.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer5.java
index cff22ab9ed..2a6856f1c1 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer5.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/Customer5.java
@@ -1,87 +1,87 @@
 // $Id$
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.annotations.fetchprofile;
 import java.util.Set;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
 
 import org.hibernate.annotations.FetchMode;
 import org.hibernate.annotations.FetchProfile;
 
 
 /**
  * @author Hardy Ferentschik
  */
 @Entity
 @FetchProfile(name = "orders-profile", fetchOverrides = {
 		@FetchProfile.FetchOverride(entity = Customer5.class, association = "foo", mode = FetchMode.JOIN)
 })
 public class Customer5 {
 	@Id
 	@GeneratedValue
 	private long id;
 
 	private String name;
 
 	private long customerNumber;
 
 	@OneToMany
 	private Set<Order> orders;
 
 	public long getCustomerNumber() {
 		return customerNumber;
 	}
 
 	public void setCustomerNumber(long customerNumber) {
 		this.customerNumber = customerNumber;
 	}
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	public Set<Order> getOrders() {
 		return orders;
 	}
 
 	public void setOrders(Set<Order> orders) {
 		this.orders = orders;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/FetchProfileTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/FetchProfileTest.java
index e73b40ce03..93b9e3d526 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/FetchProfileTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/fetchprofile/FetchProfileTest.java
@@ -1,193 +1,193 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.fetchprofile;
 
 import java.io.InputStream;
 
 import org.jboss.logging.Logger;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.MappingException;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.testing.ServiceRegistryBuilder;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * Test case for HHH-4812
  *
  * @author Hardy Ferentschik
  */
 @TestForIssue( jiraKey = "HHH-4812" )
 public class FetchProfileTest extends BaseUnitTestCase {
 	private static final Logger log = Logger.getLogger( FetchProfileTest.class );
 
 	private ServiceRegistry serviceRegistry;
 
 	@Before
     public void setUp() {
 		serviceRegistry = ServiceRegistryBuilder.buildServiceRegistry( Environment.getProperties() );
 	}
 
 	@After
     public void tearDown() {
         if (serviceRegistry != null) ServiceRegistryBuilder.destroy(serviceRegistry);
 	}
 
 	@Test
 	public void testFetchProfileConfigured() {
 		Configuration config = new Configuration();
 		config.addAnnotatedClass( Customer.class );
 		config.addAnnotatedClass( Order.class );
 		config.addAnnotatedClass( SupportTickets.class );
 		config.addAnnotatedClass( Country.class );
 		SessionFactoryImplementor sessionImpl = ( SessionFactoryImplementor ) config.buildSessionFactory(
 				serviceRegistry
 		);
 
 		assertTrue(
 				"fetch profile not parsed properly",
 				sessionImpl.containsFetchProfileDefinition( "customer-with-orders" )
 		);
 		assertFalse(
 				"package info should not be parsed",
 				sessionImpl.containsFetchProfileDefinition( "package-profile-1" )
 		);
 		sessionImpl.close();
 	}
 
 	@Test
 	public void testWrongAssociationName() {
 		Configuration config = new Configuration();
 		config.addAnnotatedClass( Customer2.class );
 		config.addAnnotatedClass( Order.class );
 		config.addAnnotatedClass( Country.class );
 
 		try {
 			config.buildMappings();
 			fail();
 		}
 		catch ( MappingException e ) {
             log.trace("success");
 		}
 	}
 
 	@Test
 	public void testWrongClass() {
 		Configuration config = new Configuration();
 		config.addAnnotatedClass( Customer3.class );
 		config.addAnnotatedClass( Order.class );
 		config.addAnnotatedClass( Country.class );
 
 		try {
 			config.buildMappings();
 			fail();
 		}
 		catch ( MappingException e ) {
             log.trace("success");
 		}
 	}
 
 	@Test
 	public void testUnsupportedFetchMode() {
 		Configuration config = new Configuration();
 		config.addAnnotatedClass( Customer4.class );
 		config.addAnnotatedClass( Order.class );
 		config.addAnnotatedClass( Country.class );
 
 		try {
 			config.buildMappings();
 			fail();
 		}
 		catch ( MappingException e ) {
             log.trace("success");
 		}
 	}
 
 	@Test
 	public void testXmlOverride() {
 		Configuration config = new Configuration();
 		config.addAnnotatedClass( Customer5.class );
 		config.addAnnotatedClass( Order.class );
 		config.addAnnotatedClass( Country.class );
 		InputStream is = Thread.currentThread()
 				.getContextClassLoader()
 				.getResourceAsStream( "org/hibernate/test/annotations/fetchprofile/mappings.hbm.xml" );
 		config.addInputStream( is );
 		SessionFactoryImplementor sessionImpl = ( SessionFactoryImplementor ) config.buildSessionFactory(
 				serviceRegistry
 		);
 
 		assertTrue(
 				"fetch profile not parsed properly",
 				sessionImpl.containsFetchProfileDefinition( "orders-profile" )
 		);
 		sessionImpl.close();
 
 		// now the same with no xml
 		config = new Configuration();
 		config.addAnnotatedClass( Customer5.class );
 		config.addAnnotatedClass( Order.class );
 		config.addAnnotatedClass( Country.class );
 		try {
 			config.buildMappings();
 			fail();
 		}
 		catch ( MappingException e ) {
             log.trace("success");
 		}
 	}
 
 	@Test
 	public void testPackageConfiguredFetchProfile() {
 		Configuration config = new Configuration();
 		config.addAnnotatedClass( Customer.class );
 		config.addAnnotatedClass( Order.class );
 		config.addAnnotatedClass( SupportTickets.class );
 		config.addAnnotatedClass( Country.class );
 		config.addPackage( Customer.class.getPackage().getName() );
 		SessionFactoryImplementor sessionImpl = ( SessionFactoryImplementor ) config.buildSessionFactory(
 				serviceRegistry
 		);
 
 		assertTrue(
 				"fetch profile not parsed properly",
 				sessionImpl.containsFetchProfileDefinition( "package-profile-1" )
 		);
 		assertTrue(
 				"fetch profile not parsed properly",
 				sessionImpl.containsFetchProfileDefinition( "package-profile-2" )
 		);
 		sessionImpl.close();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/fkcircularity/FkCircularityTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/fkcircularity/FkCircularityTest.java
index f8829b2f24..adac9331f8 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/fkcircularity/FkCircularityTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/fkcircularity/FkCircularityTest.java
@@ -1,73 +1,73 @@
 // $Id$
 package org.hibernate.test.annotations.fkcircularity;
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
 
 import org.jboss.logging.Logger;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.SQLServerDialect;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.testing.ServiceRegistryBuilder;
 
 /**
  * Test case for ANN-722 and ANN-730.
  *
  * @author Hardy Ferentschik
  */
 public class FkCircularityTest {
 	private static final Logger log = Logger.getLogger( FkCircularityTest.class );
 
 
     @Test
 	public void testJoinedSublcassesInPK() {
 		try {
 			Configuration config = new Configuration();
 			config.addAnnotatedClass(A.class);
 			config.addAnnotatedClass(B.class);
 			config.addAnnotatedClass(C.class);
 			config.addAnnotatedClass(D.class);
 			config.buildMappings(  );
 			String[] schema = config
 					.generateSchemaCreationScript(new SQLServerDialect());
 			for (String s : schema) {
                 log.debug(s);
 			}
             log.debug("success");
 		} catch (Exception e) {
 			StringWriter writer = new StringWriter();
 			e.printStackTrace(new PrintWriter(writer));
             log.debug(writer.toString());
             Assert.fail( e.getMessage() );
 		}
 	}
     @Test
 	public void testDeepJoinedSuclassesHierachy() {
 		try {
 			Configuration config = new Configuration();
 			config.addAnnotatedClass(ClassA.class);
 			config.addAnnotatedClass(ClassB.class);
 			config.addAnnotatedClass(ClassC.class);
 			config.addAnnotatedClass(ClassD.class);
 			config.buildMappings(  );
 			String[] schema = config
 					.generateSchemaCreationScript(new HSQLDialect());
 			for (String s : schema) {
                 log.debug(s);
 			}
             log.debug("success");
 		} catch (Exception e) {
 			StringWriter writer = new StringWriter();
 			e.printStackTrace(new PrintWriter(writer));
             log.debug(writer.toString());
 			Assert.fail(e.getMessage());
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/generics/Dummy.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/generics/Dummy.java
index 5a6948581e..f288627bbc 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/generics/Dummy.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/generics/Dummy.java
@@ -1,35 +1,35 @@
 //$
 package org.hibernate.test.annotations.generics;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.Transient;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class Dummy<K> {
 
 	@Id
 	private Long id;
 
 	@Transient
 	transient private K dummyField;
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public K getDummyField() {
 		return dummyField;
 	}
 
 	public void setDummyField(K dummyField) {
 		this.dummyField = dummyField;
 	}
 
-} 
\ No newline at end of file
+} 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/generics/WildEntity.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/generics/WildEntity.java
index 8200fb6eb5..4579f57889 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/generics/WildEntity.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/generics/WildEntity.java
@@ -1,43 +1,43 @@
 //$Id$
 package org.hibernate.test.annotations.generics;
 import java.io.Serializable;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.Transient;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class WildEntity implements Serializable {
 
 	private static final long serialVersionUID = -1171578628576139205L;
 
 	private int id;
 
 	private String property;
 
 	@Id
 	@GeneratedValue
 	public int getId() {
 		return id;
 	}
 
 	@Transient
 	public <T extends Object> T someMethod() {
 		return null;
 	}
 
 	public void setId(int id) {
 		this.id = id;
 	}
 
 	public String getProperty() {
 		return property;
 	}
 
 	public void setProperty(String property) {
 		this.property = property;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/id/generationmappings/CompleteSequenceEntity.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/id/generationmappings/CompleteSequenceEntity.java
index cf0882a7fb..1fb4183de4 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/id/generationmappings/CompleteSequenceEntity.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/id/generationmappings/CompleteSequenceEntity.java
@@ -1,57 +1,57 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.id.generationmappings;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 @Entity
 public class CompleteSequenceEntity {
 	public static final String SEQ_NAME = "some_other_sequence";
 	private Long id;
 
 	@Id
 	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "COMPLETE_SEQ")
 	@javax.persistence.SequenceGenerator(
 			name = "COMPLETE_SEQ",
 			sequenceName = SEQ_NAME,
 			initialValue = 1000,
 			allocationSize = 52,
 			catalog = "my_catalog",
 			schema = "my_schema"
 	)
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long long1) {
 		id = long1;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/id/generationmappings/MinimalTableEntity.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/id/generationmappings/MinimalTableEntity.java
index 28e76970b4..b05d7f15b5 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/id/generationmappings/MinimalTableEntity.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/id/generationmappings/MinimalTableEntity.java
@@ -1,54 +1,54 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.id.generationmappings;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 import javax.persistence.Table;
 import javax.persistence.TableGenerator;
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 @Entity
 @Table( name = "MINIMAL_TBL" )
 public class MinimalTableEntity {
 	public static final String TBL_NAME = "minimal_tbl";
 
 	private Long id;
 
 	@Id
 	@GeneratedValue(strategy = GenerationType.TABLE, generator = "MINIMAL_TBL")
 	@TableGenerator( name = "MINIMAL_TBL", table = TBL_NAME )
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long long1) {
 		id = long1;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/id/generationmappings/package-info.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/id/generationmappings/package-info.java
index 6b9e7e5c6f..c03458ec8d 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/id/generationmappings/package-info.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/id/generationmappings/package-info.java
@@ -1,12 +1,12 @@
 @GenericGenerator(name = "SequencePerEntityGenerator",
 		strategy = "org.hibernate.id.enhanced.SequenceStyleGenerator",
 		parameters = {
 				@Parameter(name = "prefer_sequence_per_entity", value = "true"),
 				@Parameter(name = "sequence_per_entity_suffix", value = DedicatedSequenceEntity1.SEQUENCE_SUFFIX)
 		}
 
 )
 package org.hibernate.test.annotations.id.generationmappings;
 
 import org.hibernate.annotations.GenericGenerator;
-import org.hibernate.annotations.Parameter;
\ No newline at end of file
+import org.hibernate.annotations.Parameter;
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/DomainAdmin.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/DomainAdmin.java
index 600a7fda87..2dbfc57d43 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/DomainAdmin.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/DomainAdmin.java
@@ -1,83 +1,83 @@
 // $Id$
 /*
  * JBoss, Home of Professional Open Source
  * Copyright 2005, JBoss Inc., and individual contributors as indicated
  * by the @authors tag. See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as
  * published by the Free Software Foundation; either version 2.1 of
  * the License, or (at your option) any later version.
  *
  * This software is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this software; if not, write to the Free
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
 package org.hibernate.test.annotations.idclass;
 import java.io.Serializable;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.IdClass;
 import javax.persistence.NamedNativeQuery;
 import javax.persistence.Table;
 
 
 /**
  * A DomainAdmin.
  *
  * @author <a href="mailto:stale.pedersen@jboss.org">Stale W. Pedersen</a>
  */
 @Entity
 @Table(name = "domainadmin")
 @IdClass(DomainAdminId.class)
 @NamedNativeQuery(name = "DomainAdmin.testQuery",
 		query = "select * from domainadmin da where da.domain_name = 'org'",
 		resultClass = org.hibernate.test.annotations.idclass.DomainAdmin.class)
 public class DomainAdmin implements Serializable {
 
 	@Id
 	@Column(name = "domain_name")
 	private String domainName;
 
 	@Id
 	@Column(name = "admin_user")
 	private String adminUser;
 
 	@Column(name = "nick_name")
 	private String nickName;
 
 	public DomainAdmin() {
 	}
 
 	public String getDomainName() {
 		return domainName;
 	}
 
 	public void setDomainName(String domainName) {
 		this.domainName = domainName;
 	}
 
 	public String getAdminUser() {
 		return adminUser;
 	}
 
 	public void setAdminUser(String adminUser) {
 		this.adminUser = adminUser;
 	}
 
 	public String getNickName() {
 		return nickName;
 	}
 
 	public void setNickName(String nickName) {
 		this.nickName = nickName;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/DomainAdminId.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/DomainAdminId.java
index 4e5b067976..c5796f3efc 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/DomainAdminId.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/DomainAdminId.java
@@ -1,72 +1,72 @@
 // $Id$
 /*
  * JBoss, Home of Professional Open Source
  * Copyright 2005, JBoss Inc., and individual contributors as indicated
  * by the @authors tag. See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as
  * published by the Free Software Foundation; either version 2.1 of
  * the License, or (at your option) any later version.
  *
  * This software is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this software; if not, write to the Free
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
 package org.hibernate.test.annotations.idclass;
 import java.io.Serializable;
 
 /**
  * A DomainAdminId.
  *
  * @author <a href="mailto:stale.pedersen@jboss.org">Stale W. Pedersen</a>
  */
 @SuppressWarnings("serial")
 public class DomainAdminId implements Serializable {
 
 	private String domainName;
 
 	private String adminUser;
 
 	public DomainAdminId() {
 	}
 
 	public DomainAdminId(String domainName, String adminUser) {
 		this.domainName = domainName;
 		this.adminUser = adminUser;
 	}
 
 	public String getDomainName() {
 		return domainName;
 	}
 
 	public void setDomainName(String domainName) {
 		this.domainName = domainName;
 	}
 
 	public String getAdminUser() {
 		return adminUser;
 	}
 
 	public void setAdminUser(String adminUser) {
 		this.adminUser = adminUser;
 	}
 
 	@Override
 	public boolean equals(Object o) {
 		return ( ( o instanceof DomainAdminId ) && domainName.equals( ( ( DomainAdminId ) o ).getDomainName() ) &&
 				adminUser.equals( ( ( DomainAdminId ) o ).getAdminUser() ) );
 	}
 
 	@Override
 	public int hashCode() {
 		return ( domainName + adminUser ).hashCode();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/xml/HabitatSpeciesLink.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/xml/HabitatSpeciesLink.java
index 3553fc04d2..7e8db4dd77 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/xml/HabitatSpeciesLink.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/xml/HabitatSpeciesLink.java
@@ -1,147 +1,147 @@
 // $Id: $
 /*
  * JBoss, Home of Professional Open Source
  * Copyright 2005, JBoss Inc., and individual contributors as indicated
  * by the @authors tag. See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as
  * published by the Free Software Foundation; either version 2.1 of
  * the License, or (at your option) any later version.
  *
  * This software is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this software; if not, write to the Free
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
 package org.hibernate.test.annotations.idclass.xml;
 import java.io.Serializable;
 
 /**
  * @author Hardy Ferentschik
  */
 public class HabitatSpeciesLink implements Serializable {
 	private static final long serialVersionUID = -7079021236893433038L;
 
 	private Long habitatId;
 
 	private Long speciesId;
 
 	public Long getHabitatId() {
 		return this.habitatId;
 	}
 
 	public void setHabitatId(Long newHabitatId) {
 		this.habitatId = newHabitatId;
 	}
 
 	public Long getSpeciesId() {
 		return this.speciesId;
 	}
 
 	public void setSpeciesId(Long newSpeciesId) {
 		this.speciesId = newSpeciesId;
 	}
 
 	@Override
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
 		result = prime * result + ( ( this.getHabitatId() == null ) ? 0
 				: this.getHabitatId().hashCode() );
 		result = prime * result + ( ( this.getSpeciesId() == null ) ? 0
 				: this.getSpeciesId().hashCode() );
 		return result;
 	}
 
 	@Override
 	public boolean equals(Object obj) {
 		if ( this == obj ) {
 			return true;
 		}
 		if ( obj == null ) {
 			return false;
 		}
 		if ( !( obj instanceof HabitatSpeciesLink ) ) {
 			return false;
 		}
 		final HabitatSpeciesLink other = ( HabitatSpeciesLink ) obj;
 		if ( this.getHabitatId() == null ) {
 			if ( other.getHabitatId() != null ) {
 				return false;
 			}
 		}
 		else if ( !this.getHabitatId().equals( other.getHabitatId() ) ) {
 			return false;
 		}
 		if ( this.getSpeciesId() == null ) {
 			if ( other.getSpeciesId() != null ) {
 				return false;
 			}
 		}
 		else if ( !this.getSpeciesId().equals( other.getSpeciesId() ) ) {
 			return false;
 		}
 		return true;
 	}
 
 	public static class HabitatSpeciesLinkId implements Serializable {
 		private Long habitatId;
 
 		private Long speciesId;
 
 		public Long getHabitatId() {
 			return this.habitatId;
 		}
 
 		public void setHabitatId(Long newHabitatId) {
 			this.habitatId = newHabitatId;
 		}
 
 		public Long getSpeciesId() {
 			return this.speciesId;
 		}
 
 		public void setSpeciesId(Long newSpeciesId) {
 			this.speciesId = newSpeciesId;
 		}
 
 		/**
 		 * Equality must be implemented in terms of identity field equality, and
 		 * must use instanceof rather than comparing classes directly (some JPA
 		 * implementations may subclass the identity class).
 		 */
 		public boolean equals(Object other) {
 			if ( other == this ) {
 				return true;
 			}
 			if ( !( other instanceof HabitatSpeciesLinkId ) ) {
 				return false;
 			}
 			HabitatSpeciesLinkId mi = ( HabitatSpeciesLinkId ) other;
 			return ( habitatId == mi.habitatId || ( habitatId != null && habitatId
 					.equals( mi.habitatId ) ) )
 					&& ( speciesId == mi.speciesId || ( speciesId != null && speciesId
 					.equals( mi.speciesId ) ) );
 		}
 
 		/**
 		 * Hashcode must also depend on identity values.
 		 */
 		public int hashCode() {
 			return ( ( habitatId == null ) ? 0
 					: habitatId.hashCode() ) ^ ( ( speciesId == null ) ? 0
 					: speciesId.hashCode() );
 		}
 
 		public String toString() {
 			return "habitatId[" + habitatId + "],speciesId[" + speciesId + "]";
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/xml/IdClassXmlTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/xml/IdClassXmlTest.java
index 74f016baff..fe61caa847 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/xml/IdClassXmlTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/idclass/xml/IdClassXmlTest.java
@@ -1,67 +1,67 @@
 /*
  * JBoss, Home of Professional Open Source
  * Copyright 2005, JBoss Inc., and individual contributors as indicated
  * by the @authors tag. See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as
  * published by the Free Software Foundation; either version 2.1 of
  * the License, or (at your option) any later version.
  *
  * This software is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this software; if not, write to the Free
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
 package org.hibernate.test.annotations.idclass.xml;
 
 import org.junit.Test;
 
 import org.hibernate.testing.FailureExpected;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 /**
  * A test for HHH-4282
  *
  * @author Hardy Ferentschik
  */
 @FailureExpected( jiraKey = "HHH-4282" )
 public class IdClassXmlTest extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testEntityMappingPropertiesAreNotIgnored() {
 		throw new RuntimeException();
 //		Session s = openSession();
 //		Transaction tx = s.beginTransaction();
 //
 //		HabitatSpeciesLink link = new HabitatSpeciesLink();
 //		link.setHabitatId( 1l );
 //		link.setSpeciesId( 1l );
 //		s.persist( link );
 //
 //		Query q = s.getNamedQuery( "testQuery" );
 //		assertEquals( 1, q.list().size() );
 //
 //		tx.rollback();
 //		s.close();
 	}
 
 	@Override
 	protected Class[] getAnnotatedClasses() {
 		return new Class[] {
 				HabitatSpeciesLink.class
 		};
 	}
 
 	@Override
 	protected String[] getXmlFiles() {
 		return new String[] {
 				"org/hibernate/test/annotations/idclass/xml/HabitatSpeciesLink.xml"
 		};
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/idclassgeneratedvalue/Simple2.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/idclassgeneratedvalue/Simple2.java
index 260009451f..9ea4ea3fb3 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/idclassgeneratedvalue/Simple2.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/idclassgeneratedvalue/Simple2.java
@@ -1,76 +1,76 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.idclassgeneratedvalue;
 import java.io.Serializable;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.IdClass;
 
 import org.hibernate.annotations.GenericGenerator;
 
 /**
  * The {@link Simple} entity redone with a generated value {@link #id1} }as part of its
  * composite pk
  *
  * @author <a href="mailto:stale.pedersen@jboss.org">Stale W. Pedersen</a>
  */
 @Entity
 @IdClass(SimplePK.class)
 @SuppressWarnings("serial")
 public class Simple2 implements Serializable {
 	@Id
 	@GenericGenerator(name = "increment", strategy = "increment")
 	@GeneratedValue(generator = "increment")
 	private Long id1;
 
 	@Id
 	private Long id2;
 
 	private int quantity;
 
 	public Simple2() {
 	}
 
 	public Simple2(Long id, int quantity) {
 		this.id2 = id;
 		this.quantity = quantity;
 	}
 
 	public Long getId1() {
 		return id1;
 	}
 
 	public Long getId2() {
 		return id2;
 	}
 
 	public int getQuantity() {
 		return quantity;
 	}
 
 	public void setQuantity(int quantity) {
 		this.quantity = quantity;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/idmanytoone/alphabetical/Acces.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/idmanytoone/alphabetical/Acces.java
index 8716d1f0ee..94a2dcc5fb 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/idmanytoone/alphabetical/Acces.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/idmanytoone/alphabetical/Acces.java
@@ -1,16 +1,16 @@
 //$
 package org.hibernate.test.annotations.idmanytoone.alphabetical;
 import java.io.Serializable;
 import java.math.BigInteger;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.ManyToOne;
 
 @Entity
 public class Acces implements Serializable {
 	@Id
 	private BigInteger idpk;
 
 	@ManyToOne
 	private Droitacces idpkdracc;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/indexcoll/GenerationGroup.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/indexcoll/GenerationGroup.java
index dabe3e6bb9..0b76874e18 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/indexcoll/GenerationGroup.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/indexcoll/GenerationGroup.java
@@ -1,36 +1,36 @@
 //$Id$
 package org.hibernate.test.annotations.indexcoll;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class GenerationGroup {
 
 	@Id
 	@GeneratedValue
 	private int id;
 
 	private Generation generation;
 
 	public int getId() {
 		return id;
 	}
 
 	public void setId(int id) {
 		this.id = id;
 	}
 
 	public Generation getGeneration() {
 		return generation;
 	}
 
 	public void setGeneration(Generation generation) {
 		this.generation = generation;
 	}
 
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/inheritance/joined/Customer.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/inheritance/joined/Customer.java
index 646f28914f..81ddb81d4d 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/inheritance/joined/Customer.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/inheritance/joined/Customer.java
@@ -1,66 +1,66 @@
 /*
   * Hibernate, Relational Persistence for Idiomatic Java
   *
   * Copyright (c) 2009, Red Hat, Inc. and/or its affiliates or third-
   * party contributors as indicated by the @author tags or express 
   * copyright attribution statements applied by the authors.  
   * All third-party contributions are distributed under license by 
   * Red Hat, Inc.
   *
   * This copyrighted material is made available to anyone wishing to 
   * use, modify, copy, or redistribute it subject to the terms and 
   * conditions of the GNU Lesser General Public License, as published 
   * by the Free Software Foundation.
   *
   * This program is distributed in the hope that it will be useful,
   * but WITHOUT ANY WARRANTY; without even the implied warranty of 
   * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
   * Lesser General Public License for more details.
   *
   * You should have received a copy of the GNU Lesser General Public 
   * License along with this distribution; if not, write to:
   * 
   * Free Software Foundation, Inc.
   * 51 Franklin Street, Fifth Floor
   * Boston, MA  02110-1301  USA
   */
 
 package org.hibernate.test.annotations.inheritance.joined;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.Inheritance;
 import javax.persistence.InheritanceType;
 import javax.persistence.SecondaryTable;
 import javax.persistence.Table;
 
 /**
  * @author Sharath Reddy
  *
  */
 @Entity
 @Inheritance(strategy = InheritanceType.JOINED)
 @Table(name = "Customer")
 @SecondaryTable(name = "CustomerDetails")
 public class Customer extends LegalEntity {
 
 	public String customerName;
 	public String customerCode;
 
 	@Column
 	public String getCustomerName() {
 		return customerName;
 	}
 
 	public void setCustomerName(String val) {
 		this.customerName = val;
 	}
 
 	@Column(table="CustomerDetails")
 	public String getCustomerCode() {
 		return customerCode;
 	}
 
 	public void setCustomerCode(String val) {
 		this.customerCode = val;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/inheritance/joined/SwimmingPool.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/inheritance/joined/SwimmingPool.java
index a4d93447e3..6e2a578ef3 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/inheritance/joined/SwimmingPool.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/inheritance/joined/SwimmingPool.java
@@ -1,10 +1,10 @@
 //$Id$
 package org.hibernate.test.annotations.inheritance.joined;
 import javax.persistence.Entity;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class SwimmingPool extends Pool {
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/join/Cat.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/join/Cat.java
index d9222787b0..d187e5ab4a 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/join/Cat.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/join/Cat.java
@@ -1,100 +1,100 @@
 //$Id$
 package org.hibernate.test.annotations.join;
 import java.io.Serializable;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.SecondaryTable;
 import javax.persistence.SecondaryTables;
 import javax.persistence.UniqueConstraint;
 
 import org.hibernate.annotations.FetchMode;
 import org.hibernate.annotations.ForeignKey;
 import org.hibernate.annotations.Index;
 import org.hibernate.annotations.SQLInsert;
 import org.hibernate.annotations.Table;
 import org.hibernate.annotations.Tables;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 @SecondaryTables({
 @SecondaryTable(name = "`Cat nbr1`"),
 @SecondaryTable(name = "Cat2", uniqueConstraints = {@UniqueConstraint(columnNames = {"storyPart2"})})
 		})
 @Tables( {
 	@Table(appliesTo = "Cat", indexes = @Index(name = "secondname",
 			columnNames = "secondName"), comment = "My cat table" ),
 	@Table(appliesTo = "Cat2", foreignKey = @ForeignKey(name="FK_CAT2_CAT"), fetch = FetchMode.SELECT,
 			sqlInsert=@SQLInsert(sql="insert into Cat2(storyPart2, id) values(upper(?), ?)") )
 			} )
 public class Cat implements Serializable {
 
 	private Integer id;
 	private String name;
 	private String secondName;
 	private String storyPart1;
 	private String storyPart2;
 
 	@Id
 	@GeneratedValue
 	public Integer getId() {
 		return id;
 	}
 
 	@Index(name = "nameindex")
 	public String getName() {
 		return name;
 	}
 
 	public void setId(Integer integer) {
 		id = integer;
 	}
 
 	public void setName(String string) {
 		name = string;
 	}
 
 	public String getSecondName() {
 		return secondName;
 	}
 
 	public void setSecondName(String secondName) {
 		this.secondName = secondName;
 	}
 
 // Bug HHH-36
 //	@OneToMany(cascade=CascadeType.ALL, fetch=FetchType.EAGER)
 //	@JoinColumn(name="CAT_ID", secondaryTable="ExtendedLife")
 //	public Set<Life> getLifes() {
 //		return lifes;
 //	}
 //
 //	public void setLifes(Set<Life> collection) {
 //		lifes = collection;
 //	}
 
 	@Column(table = "`Cat nbr1`")
 	@Index(name = "story1index")
 	public String getStoryPart1() {
 		return storyPart1;
 	}
 
 	@Column(table = "Cat2", nullable = false)
 	public String getStoryPart2() {
 		return storyPart2;
 	}
 
 
 	public void setStoryPart1(String string) {
 		storyPart1 = string;
 	}
 
 
 	public void setStoryPart2(String string) {
 		storyPart2 = string;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/join/SysGroupsOrm.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/join/SysGroupsOrm.java
index d2ca917768..5d182b4a11 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/join/SysGroupsOrm.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/join/SysGroupsOrm.java
@@ -1,25 +1,25 @@
 package org.hibernate.test.annotations.join;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.Table;
 
 @Entity
 @Table( name = "SYS_GROUPS" )
 public class SysGroupsOrm {
 
 	private long groupId;
 
 	@Id
 	@GeneratedValue
 	@Column( name = "GROUPID" )
 	public long getGroupId() {
 		return groupId;
 	}
 
 	public void setGroupId( long groupId ) {
 		this.groupId = groupId;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/lob/ImageHolder.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/lob/ImageHolder.java
index 029ae45d07..ad2600585b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/lob/ImageHolder.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/lob/ImageHolder.java
@@ -1,80 +1,80 @@
 //$Id: $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.annotations.lob;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 
 /**
  * An entity containing data that is materialized into a byte array immediately.
  * The hibernate type mapped for {@link #longByteArray} determines the SQL type
  * asctually used.
  * 
  * @author Gail Badner
  */
 @Entity
 public class ImageHolder {
 	private Long id;
 	private byte[] longByteArray;
 	private Dog dog;
 	private Byte[] picByteArray;
 
 	@Id
 	@GeneratedValue
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 	
 	@org.hibernate.annotations.Type(type="image")
 	public byte[] getLongByteArray() {
 		return longByteArray;
 	}
 
 	public void setLongByteArray(byte[] longByteArray) {
 		this.longByteArray = longByteArray;
 	}
 	@org.hibernate.annotations.Type(type="serializable_image")
 	public Dog getDog() {
 		return dog;
 	}
 
 	public void setDog(Dog dog) {
 		this.dog = dog;
 	}
 	@org.hibernate.annotations.Type(type="wrapped_image")
 	public Byte[] getPicByteArray() {
 		return picByteArray;
 	}
 
 	public void setPicByteArray(Byte[] picByteArray) {
 		this.picByteArray = picByteArray;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/lob/ImageTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/lob/ImageTest.java
index 2f1308f643..7a0a8e1d16 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/lob/ImageTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/lob/ImageTest.java
@@ -1,165 +1,165 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.lob;
 
 import junit.framework.AssertionFailedError;
 import org.junit.Assert;
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.dialect.SQLServerDialect;
 import org.hibernate.dialect.Sybase11Dialect;
 import org.hibernate.dialect.SybaseASE15Dialect;
 import org.hibernate.dialect.SybaseDialect;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.testing.RequiresDialect;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 /**
  * Tests eager materialization and mutation of data mapped by
  * {@link org.hibernate.type.ImageType}.
  *
  * @author Gail Badner
  */
 @RequiresDialect( { SybaseASE15Dialect.class, SQLServerDialect.class, SybaseDialect.class, Sybase11Dialect.class })
 public class ImageTest extends BaseCoreFunctionalTestCase {
 	private static final int ARRAY_SIZE = 10000;
 
 	@Test
 	public void testBoundedLongByteArrayAccess() {
 		byte[] original = buildRecursively(ARRAY_SIZE, true);
 		byte[] changed = buildRecursively(ARRAY_SIZE, false);
 
 		Session s = openSession();
 		s.beginTransaction();
 		ImageHolder entity = new ImageHolder();
 		s.save(entity);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = (ImageHolder) s.get(ImageHolder.class, entity.getId());
 		Assert.assertNull( entity.getLongByteArray() );
 		Assert.assertNull( entity.getDog() );
 		Assert.assertNull( entity.getPicByteArray() );
 		entity.setLongByteArray(original);
 		Dog dog = new Dog();
 		dog.setName("rabbit");
 		entity.setDog(dog);
 		entity.setPicByteArray(wrapPrimitive(original));
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = (ImageHolder) s.get(ImageHolder.class, entity.getId());
 		Assert.assertEquals( ARRAY_SIZE, entity.getLongByteArray().length );
 		assertEquals(original, entity.getLongByteArray());
 		Assert.assertEquals( ARRAY_SIZE, entity.getPicByteArray().length );
 		assertEquals(original, unwrapNonPrimitive(entity.getPicByteArray()));
 		Assert.assertNotNull( entity.getDog() );
 		Assert.assertEquals( dog.getName(), entity.getDog().getName() );
 		entity.setLongByteArray(changed);
 		entity.setPicByteArray(wrapPrimitive(changed));
 		dog.setName("papa");
 		entity.setDog(dog);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = (ImageHolder) s.get(ImageHolder.class, entity.getId());
 		Assert.assertEquals( ARRAY_SIZE, entity.getLongByteArray().length );
 		assertEquals(changed, entity.getLongByteArray());
 		Assert.assertEquals( ARRAY_SIZE, entity.getPicByteArray().length );
 		assertEquals(changed, unwrapNonPrimitive(entity.getPicByteArray()));
 		Assert.assertNotNull( entity.getDog() );
 		Assert.assertEquals( dog.getName(), entity.getDog().getName() );
 		entity.setLongByteArray(null);
 		entity.setPicByteArray(null);
 		entity.setDog(null);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = (ImageHolder) s.get(ImageHolder.class, entity.getId());
 		Assert.assertNull( entity.getLongByteArray() );
 		Assert.assertNull( entity.getDog() );
 		Assert.assertNull( entity.getPicByteArray() );
 		s.delete(entity);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	private Byte[] wrapPrimitive(byte[] bytes) {
 		int length = bytes.length;
 		Byte[] result = new Byte[length];
 		for (int index = 0; index < length; index++) {
 			result[index] = Byte.valueOf( bytes[index] );
 		}
 		return result;
 	}
 
 	private byte[] unwrapNonPrimitive(Byte[] bytes) {
 		int length = bytes.length;
 		byte[] result = new byte[length];
 		for (int i = 0; i < length; i++) {
 			result[i] = bytes[i].byteValue();
 		}
 		return result;
 	}
 
 	private byte[] buildRecursively(int size, boolean on) {
 		byte[] data = new byte[size];
 		data[0] = mask(on);
 		for (int i = 0; i < size; i++) {
 			data[i] = mask(on);
 			on = !on;
 		}
 		return data;
 	}
 
 	private byte mask(boolean on) {
 		return on ? (byte) 1 : (byte) 0;
 	}
 
 	public static void assertEquals(byte[] val1, byte[] val2) {
 		if (!ArrayHelper.isEquals( val1, val2 )) {
 			throw new AssertionFailedError("byte arrays did not match");
 		}
 	}
 
 	@Override
 	protected String[] getAnnotatedPackages() {
 		return new String[] { "org.hibernate.test.annotations.lob" };
 	}
 
 	@Override
     public Class<?>[] getAnnotatedClasses() {
 		return new Class[] { ImageHolder.class };
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/manytomany/ManyToManyMaxFetchDepth0Test.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/manytomany/ManyToManyMaxFetchDepth0Test.java
index 7d00524db6..d36bf821c6 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/manytomany/ManyToManyMaxFetchDepth0Test.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/manytomany/ManyToManyMaxFetchDepth0Test.java
@@ -1,42 +1,42 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.annotations.manytomany;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 
 /**
  * Many to many tests using max_fetch_depth == 0
  *
  * @author Gail Badner
  */
 @SuppressWarnings("unchecked")
 public class ManyToManyMaxFetchDepth0Test extends ManyToManyTest {
 	@Override
 	protected void configure(Configuration cfg) {
 		cfg.setProperty( Environment.MAX_FETCH_DEPTH, "0" );
 		super.configure( cfg );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/manytomany/ManyToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/manytomany/ManyToManyTest.java
index 2f75dce8f9..f2d27e1633 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/manytomany/ManyToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/manytomany/ManyToManyTest.java
@@ -1,787 +1,787 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.manytomany;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Date;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Set;
 
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.JDBCException;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.criterion.Restrictions;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * Many to many tests
  *
  * @author Emmanuel Bernard
  */
 @SuppressWarnings("unchecked")
 public class ManyToManyTest extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testDefault() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Store fnac = new Store();
 		fnac.setName( "Fnac" );
 		KnownClient emmanuel = new KnownClient();
 		emmanuel.setName( "Emmanuel" );
 		emmanuel.setStores( new HashSet<Store>() );
 		fnac.setCustomers( new HashSet<KnownClient>() );
 		fnac.getCustomers().add( emmanuel );
 		emmanuel.getStores().add( fnac );
 		fnac.setImplantedIn( new HashSet<City>() );
 		City paris = new City();
 		fnac.getImplantedIn().add( paris );
 		paris.setName( "Paris" );
 		s.persist( fnac );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		Store store;
 		KnownClient knownClient;
 		City city;
 		store = (Store) s.get( Store.class, fnac.getId() );
 		assertNotNull( store );
 		assertNotNull( store.getCustomers() );
 		assertEquals( 1, store.getCustomers().size() );
 		knownClient = store.getCustomers().iterator().next();
 		assertEquals( emmanuel.getName(), knownClient.getName() );
 		assertNotNull( store.getImplantedIn() );
 		assertEquals( 1, store.getImplantedIn().size() );
 		city = store.getImplantedIn().iterator().next();
 		assertEquals( paris.getName(), city.getName() );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		knownClient = (KnownClient) s.get( KnownClient.class, emmanuel.getId() );
 		assertNotNull( knownClient );
 		assertNotNull( knownClient.getStores() );
 		assertEquals( 1, knownClient.getStores().size() );
 		store = knownClient.getStores().iterator().next();
 		assertEquals( fnac.getName(), store.getName() );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCanUseCriteriaQuery() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Store fnac = new Store();
 		fnac.setName( "Fnac" );
 		Supplier emi = new Supplier();
 		emi.setName( "Emmanuel" );
 		emi.setSuppStores( new HashSet<Store>() );
 		fnac.setSuppliers( new HashSet<Supplier>() );
 		fnac.getSuppliers().add( emi );
 		emi.getSuppStores().add( fnac );
 		s.persist( fnac );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		List result = s.createCriteria( Supplier.class ).createAlias( "suppStores", "s" ).add(
 				Restrictions.eq( "s.name", "Fnac" ) ).list();
 		assertEquals( 1, result.size() );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testDefaultCompositePk() throws Exception {
 		Session s;
 		Transaction tx;
 
 		s = openSession();
 		tx = s.beginTransaction();
 		CatPk catPk = new CatPk();
 		catPk.setName( "Minou" );
 		catPk.setThoroughbred( "Persan" );
 		Cat cat = new Cat();
 		cat.setId( catPk );
 		cat.setAge( 32 );
 		Woman woman = new Woman();
 		WomanPk womanPk = new WomanPk();
 		womanPk.setFirstName( "Emma" );
 		womanPk.setLastName( "Peel" );
 		woman.setId( womanPk );
 		woman.setCats( new HashSet<Cat>() );
 		woman.getCats().add( cat );
 		cat.setHumanContacts( new HashSet<Woman>() );
 		cat.getHumanContacts().add( woman );
 		s.persist( woman );
 		s.persist( cat );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		Cat sameCat = (Cat) s.get( Cat.class, cat.getId() );
 		assertNotNull( sameCat );
 		assertNotNull( sameCat.getHumanContacts() );
 		assertEquals( 1, sameCat.getHumanContacts().size() );
 		Woman sameWoman = sameCat.getHumanContacts().iterator().next();
 		assertEquals( sameWoman.getId().getLastName(), woman.getId().getLastName() );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		sameWoman = (Woman) s.get( Woman.class, woman.getId() );
 		assertNotNull( sameWoman );
 		assertNotNull( sameWoman.getCats() );
 		assertEquals( 1, sameWoman.getCats().size() );
 		sameCat = sameWoman.getCats().iterator().next();
 		assertEquals( cat.getAge(), sameCat.getAge() );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testMappedBy() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Store fnac = new Store();
 		fnac.setName( "Fnac" );
 		Supplier emi = new Supplier();
 		emi.setName( "Emmanuel" );
 		emi.setSuppStores( new HashSet<Store>() );
 		fnac.setSuppliers( new HashSet<Supplier>() );
 		fnac.getSuppliers().add( emi );
 		emi.getSuppStores().add( fnac );
 		s.persist( fnac );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		Store store;
 		Supplier supplier;
 		store = (Store) s.get( Store.class, fnac.getId() );
 		assertNotNull( store );
 		assertNotNull( store.getSuppliers() );
 		assertEquals( 1, store.getSuppliers().size() );
 		supplier = store.getSuppliers().iterator().next();
 		assertEquals( emi.getName(), supplier.getName() );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		supplier = (Supplier) s.get( Supplier.class, emi.getId() );
 		assertNotNull( supplier );
 		assertNotNull( supplier.getSuppStores() );
 		assertEquals( 1, supplier.getSuppStores().size() );
 		store = supplier.getSuppStores().iterator().next();
 		assertEquals( fnac.getName(), store.getName() );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testBasic() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Employer er = new Employer();
 		Employee ee = new Employee();
 		s.persist( ee );
 		Set erColl = new HashSet();
 		Collection eeColl = new ArrayList();
 		erColl.add( ee );
 		eeColl.add( er );
 		er.setEmployees( erColl );
 		ee.setEmployers( eeColl );
 		//s.persist(ee);
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		er = (Employer) s.load( Employer.class, er.getId() );
 		assertNotNull( er );
 		assertNotNull( er.getEmployees() );
 		assertEquals( 1, er.getEmployees().size() );
 		Employee eeFromDb = (Employee) er.getEmployees().iterator().next();
 		assertEquals( ee.getId(), eeFromDb.getId() );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		ee = (Employee) s.get( Employee.class, ee.getId() );
 		assertNotNull( ee );
 		assertFalse( "ManyToMany mappedBy lazyness", Hibernate.isInitialized( ee.getEmployers() ) );
 		tx.commit();
 		assertFalse( "ManyToMany mappedBy lazyness", Hibernate.isInitialized( ee.getEmployers() ) );
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		ee = (Employee) s.get( Employee.class, ee.getId() );
 		assertNotNull( ee );
 		er = ee.getEmployers().iterator().next();
 		assertTrue( "second join non lazy", Hibernate.isInitialized( er ) );
 		s.delete( er );
 		s.delete( ee );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testOrderByEmployee() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Employer employer = new Employer();
 		Employee employee1 = new Employee();
 		employee1.setName( "Emmanuel" );
 		Employee employee2 = new Employee();
 		employee2.setName( "Alice" );
 		s.persist( employee1 );
 		s.persist( employee2 );
 		Set erColl = new HashSet();
 		Collection eeColl = new ArrayList();
 		Collection eeColl2 = new ArrayList();
 		erColl.add( employee1 );
 		erColl.add( employee2 );
 		eeColl.add( employer );
 		eeColl2.add( employer );
 		employer.setEmployees( erColl );
 		employee1.setEmployers( eeColl );
 		employee2.setEmployers( eeColl2 );
 
 		s.flush();
 		s.clear();
 
 		employer = (Employer) s.get( Employer.class, employer.getId() );
 		assertNotNull( employer );
 		assertNotNull( employer.getEmployees() );
 		assertEquals( 2, employer.getEmployees().size() );
 		Employee eeFromDb = (Employee) employer.getEmployees().iterator().next();
 		assertEquals( employee2.getName(), eeFromDb.getName() );
 		tx.rollback();
 		s.close();
 	}
 	
 	// HHH-4394
 	@Test
 	public void testOrderByContractor() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 
 		// create some test entities
 		Employer employer = new Employer();
 		Contractor contractor1 = new Contractor();
 		contractor1.setName( "Emmanuel" );
 		contractor1.setHourlyRate(100.0f);
 		Contractor contractor2 = new Contractor();
 		contractor2.setName( "Hardy" );
 		contractor2.setHourlyRate(99.99f);
 		s.persist( contractor1 );
 		s.persist( contractor2 );
 
 		// add contractors to employer
 		List setOfContractors = new ArrayList();
 		setOfContractors.add( contractor1 );
 		setOfContractors.add( contractor2 );
 		employer.setContractors( setOfContractors );
 
 		// add employer to contractors
 		Collection employerListContractor1 = new ArrayList();
 		employerListContractor1.add( employer );
 		contractor1.setEmployers( employerListContractor1 );
 
 		Collection employerListContractor2 = new ArrayList();
 		employerListContractor2.add( employer );
 		contractor2.setEmployers( employerListContractor2 );
 
 		s.flush();
 		s.clear();
 
 		// assertions
 		employer = (Employer) s.get( Employer.class, employer.getId() );
 		assertNotNull( employer );
 		assertNotNull( employer.getContractors() );
 		assertEquals( 2, employer.getContractors().size() );
 		Contractor firstContractorFromDb = (Contractor) employer.getContractors().iterator().next();
 		assertEquals( contractor2.getName(), firstContractorFromDb.getName() );
 		tx.rollback();
 		s.close();
 	}
 	
 	@Test
 	public void testRemoveInBetween() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Employer er = new Employer();
 		Employee ee = new Employee();
 		Employee ee2 = new Employee();
 		s.persist( ee );
 		s.persist( ee2 );
 		Set erColl = new HashSet();
 		Collection eeColl = new ArrayList();
 		erColl.add( ee );
 		erColl.add( ee2 );
 		eeColl.add( er );
 		er.setEmployees( erColl );
 		ee.setEmployers( eeColl );
 		//s.persist(ee);
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		er = (Employer) s.load( Employer.class, er.getId() );
 		assertNotNull( er );
 		assertNotNull( er.getEmployees() );
 		assertEquals( 2, er.getEmployees().size() );
 		Iterator iterator = er.getEmployees().iterator();
 		Employee eeFromDb = (Employee) iterator.next();
 		if ( eeFromDb.getId().equals( ee.getId() ) ) {
 			eeFromDb = (Employee) iterator.next();
 		}
 		assertEquals( ee2.getId(), eeFromDb.getId() );
 		er.getEmployees().remove( eeFromDb );
 		eeFromDb.getEmployers().remove( er );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		ee = (Employee) s.get( Employee.class, ee.getId() );
 		assertNotNull( ee );
 		assertFalse( "ManyToMany mappedBy lazyness", Hibernate.isInitialized( ee.getEmployers() ) );
 		tx.commit();
 		assertFalse( "ManyToMany mappedBy lazyness", Hibernate.isInitialized( ee.getEmployers() ) );
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		ee = (Employee) s.get( Employee.class, ee.getId() );
 		assertNotNull( ee );
 		er = ee.getEmployers().iterator().next();
 		assertTrue( "second join non lazy", Hibernate.isInitialized( er ) );
 		assertEquals( 1, er.getEmployees().size() );
 		s.delete( er );
 		s.delete( ee );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSelf() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Friend f = new Friend();
 		Friend sndF = new Friend();
 		f.setName( "Starsky" );
 		sndF.setName( "Hutch" );
 		Set frnds = new HashSet();
 		frnds.add( sndF );
 		f.setFriends( frnds );
 		//Starsky is a friend of Hutch but hutch is not
 		s.persist( f );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		f = (Friend) s.load( Friend.class, f.getId() );
 		assertNotNull( f );
 		assertNotNull( f.getFriends() );
 		assertEquals( 1, f.getFriends().size() );
 		Friend fromDb2ndFrnd = f.getFriends().iterator().next();
 		assertEquals( fromDb2ndFrnd.getId(), sndF.getId() );
 		assertEquals( 0, fromDb2ndFrnd.getFriends().size() );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCompositePk() throws Exception {
 		Session s;
 		Transaction tx;
 
 		ManPk m1pk = new ManPk();
 		m1pk.setElder( true );
 		m1pk.setFirstName( "Lucky" );
 		m1pk.setLastName( "Luke" );
 		ManPk m2pk = new ManPk();
 		m2pk.setElder( false );
 		m2pk.setFirstName( "Joe" );
 		m2pk.setLastName( "Dalton" );
 
 		Man m1 = new Man();
 		m1.setId( m1pk );
 		m1.setCarName( "Jolly Jumper" );
 		Man m2 = new Man();
 		m2.setId( m2pk );
 
 		WomanPk w1pk = new WomanPk();
 		w1pk.setFirstName( "Ma" );
 		w1pk.setLastName( "Dalton" );
 		WomanPk w2pk = new WomanPk();
 		w2pk.setFirstName( "Carla" );
 		w2pk.setLastName( "Bruni" );
 
 		Woman w1 = new Woman();
 		w1.setId( w1pk );
 		Woman w2 = new Woman();
 		w2.setId( w2pk );
 
 		Set<Woman> womens = new HashSet<Woman>();
 		womens.add( w1 );
 		m1.setWomens( womens );
 		Set<Woman> womens2 = new HashSet<Woman>();
 		womens2.add( w1 );
 		womens2.add( w2 );
 		m2.setWomens( womens2 );
 
 		Set<Man> mens = new HashSet<Man>();
 		mens.add( m1 );
 		mens.add( m2 );
 		w1.setMens( mens );
 		Set<Man> mens2 = new HashSet<Man>();
 		mens2.add( m2 );
 		w2.setMens( mens2 );
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.persist( m1 );
 		s.persist( m2 );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		m1 = (Man) s.load( Man.class, m1pk );
 		assertFalse( m1.getWomens().isEmpty() );
 		assertEquals( 1, m1.getWomens().size() );
 		w1 = (Woman) s.load( Woman.class, w1pk );
 		assertFalse( w1.getMens().isEmpty() );
 		assertEquals( 2, w1.getMens().size() );
 
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testAssociationTableUniqueConstraints() throws Exception {
 		Session s = openSession();
 		Permission readAccess = new Permission();
 		readAccess.setPermission( "read" );
 		readAccess.setExpirationDate( new Date() );
 		Collection<Permission> coll = new ArrayList<Permission>( 2 );
 		coll.add( readAccess );
 		coll.add( readAccess );
 		Group group = new Group();
 		group.setId( new Integer( 1 ) );
 		group.setPermissions( coll );
 		s.getTransaction().begin();
 		try {
 			s.persist( group );
 			s.getTransaction().commit();
 			fail( "Unique constraints not applied on association table" );
 		}
 		catch (JDBCException e) {
 			//success
 			s.getTransaction().rollback();
 		}
 		finally {
 			s.close();
 		}
 	}
 
 	@Test
 	public void testAssociationTableAndOrderBy() throws Exception {
 		Session s = openSession();
 		s.enableFilter( "Groupfilter" );
 		Permission readAccess = new Permission();
 		readAccess.setPermission( "read" );
 		readAccess.setExpirationDate( new Date() );
 		Permission writeAccess = new Permission();
 		writeAccess.setPermission( "write" );
 		writeAccess.setExpirationDate( new Date( new Date().getTime() - 10*60*1000 ) );
 		Collection<Permission> coll = new ArrayList<Permission>( 2 );
 		coll.add( readAccess );
 		coll.add( writeAccess );
 		Group group = new Group();
 		group.setId( new Integer( 1 ) );
 		group.setPermissions( coll );
 		s.getTransaction().begin();
 		s.persist( group );
 		s.flush();
 		s.clear();
 		group = (Group) s.get( Group.class, group.getId() );
 		s.createQuery( "select g from Group g join fetch g.permissions").list();
 		assertEquals( "write", group.getPermissions().iterator().next().getPermission() );
 		s.getTransaction().rollback();
 		s.close();
 	}
 
 	@Test
 	public void testAssociationTableAndOrderByWithSet() throws Exception {
 		Session s = openSession();
 		s.enableFilter( "Groupfilter" );
 
 		Permission readAccess = new Permission();
 		readAccess.setPermission( "read" );
 		readAccess.setExpirationDate( new Date() );
 		
 		Permission writeAccess = new Permission();
 		writeAccess.setPermission( "write" );
 		writeAccess.setExpirationDate( new Date( new Date().getTime() - 10*60*1000 ) );
 		
 		Permission executeAccess = new Permission();
 		executeAccess.setPermission( "execute" );
 		executeAccess.setExpirationDate( new Date( new Date().getTime() - 5*60*1000 ) );
 		
 		Set<Permission> coll = new HashSet<Permission>( 3 );
 		coll.add( readAccess );
 		coll.add( writeAccess );
 		coll.add( executeAccess );
 
 		GroupWithSet group = new GroupWithSet();
 		group.setId( new Integer( 1 ) );
 		group.setPermissions( coll );
 		s.getTransaction().begin();
 		s.persist( group );
 		s.flush();
 		s.clear();
 
 		group = (GroupWithSet) s.get( GroupWithSet.class, group.getId() );
 		s.createQuery( "select g from Group g join fetch g.permissions").list();
 		Iterator<Permission> permIter = group.getPermissions().iterator();
 		assertEquals( "write", permIter.next().getPermission() );
 		assertEquals( "execute", permIter.next().getPermission() );
 		assertEquals( "read", permIter.next().getPermission() );
 		s.getTransaction().rollback();
 		s.close();
 	}
 	
 	@Test
 	public void testJoinedSubclassManyToMany() throws Exception {
 		Session s = openSession();
 		Zone a = new Zone();
 		InspectorPrefixes ip = new InspectorPrefixes( "dgi" );
 		Transaction tx = s.beginTransaction();
 		s.save( a );
 		s.save( ip );
 		ip.getAreas().add( a );
 		tx.commit();
 		s.close();
 		s = openSession();
 		tx = s.beginTransaction();
 		ip = (InspectorPrefixes) s.get( InspectorPrefixes.class, ip.getId() );
 		assertNotNull( ip );
 		assertEquals( 1, ip.getAreas().size() );
 		assertEquals( a.getId(), ip.getAreas().get( 0 ).getId() );
 		s.delete( ip );
 		s.delete( ip.getAreas().get( 0 ) );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testJoinedSubclassManyToManyWithNonPkReference() throws Exception {
 		Session s = openSession();
 		Zone a = new Zone();
 		InspectorPrefixes ip = new InspectorPrefixes( "dgi" );
 		ip.setName( "Inspector" );
 		Transaction tx = s.beginTransaction();
 		s.save( a );
 		s.save( ip );
 		ip.getDesertedAreas().add( a );
 		tx.commit();
 		s.close();
 		s = openSession();
 		tx = s.beginTransaction();
 		ip = (InspectorPrefixes) s.get( InspectorPrefixes.class, ip.getId() );
 		assertNotNull( ip );
 		assertEquals( 1, ip.getDesertedAreas().size() );
 		assertEquals( a.getId(), ip.getDesertedAreas().get( 0 ).getId() );
 		s.delete( ip );
 		s.delete( ip.getDesertedAreas().get( 0 ) );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testReferencedColumnNameToSuperclass() throws Exception {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		BuildingCompany comp = new BuildingCompany();
 		comp.setFoundedIn( new Date() );
 		comp.setName( "Builder century corp.");
 		s.persist( comp );
 		Building building = new Building();
 		building.setCompany( comp );
 		s.persist( building );
 		s.flush();
 		s.clear();
 		building = (Building) s.get( Building.class, building.getId() );
 		assertEquals( comp.getName(), building.getCompany().getName() );
 		tx.rollback();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-4685" )
 	public void testManyToManyEmbeddableBiDirectionalDotNotationInMappedBy() throws Exception {
 		// Section 11.1.25
 		// The ManyToMany annotation may be used within an embeddable class contained within an entity class to specify a
 		// relationship to a collection of entities[101]. If the relationship is bidirectional and the entity containing
 		// the embeddable class is the owner of the relationship, the non-owning side must use the mappedBy element of the
 		// ManyToMany annotation to specify the relationship field or property of the embeddable class. The dot (".")
 		// notation syntax must be used in the mappedBy element to indicate the relationship attribute within the embedded
 		// attribute. The value of each identifier used with the dot notation is the name of the respective embedded field
 		// or property.
 		Session s;
 		s = openSession();
 		s.getTransaction().begin();
 		Employee e = new Employee();
 		e.setName( "Sharon" );
 		List<PhoneNumber> phoneNumbers = new ArrayList<PhoneNumber>();
 		Collection<Employee> employees = new ArrayList<Employee>();
 		employees.add( e );
 		ContactInfo contactInfo = new ContactInfo();
 		PhoneNumber number = new PhoneNumber();
 		number.setEmployees( employees );
 		phoneNumbers.add( number );
 		contactInfo.setPhoneNumbers( phoneNumbers );
 		e.setContactInfo( contactInfo );
 		s.persist( e );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.getTransaction().begin();
 		e = (Employee)s.get( e.getClass(),e.getId() );
 		// follow both directions of many to many association 
 		assertEquals("same employee", e.getName(), e.getContactInfo().getPhoneNumbers().get(0).getEmployees().iterator().next().getName());
 		s.getTransaction().commit();
 
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-4685" )
 	public void testOneToManyEmbeddableBiDirectionalDotNotationInMappedBy() throws Exception {
 		// Section 11.1.26
 		// The ManyToOne annotation may be used within an embeddable class to specify a relationship from the embeddable
 		// class to an entity class. If the relationship is bidirectional, the non-owning OneToMany entity side must use the
 		// mappedBy element of the OneToMany annotation to specify the relationship field or property of the embeddable field
 		// or property on the owning side of the relationship. The dot (".") notation syntax must be used in the mappedBy
 		// element to indicate the relationship attribute within the embedded attribute. The value of each identifier used
 		// with the dot notation is the name of the respective embedded field or property.
 		Session s;
 		s = openSession();
 		s.getTransaction().begin();
 		Employee e = new Employee();
 		JobInfo job = new JobInfo();
 		job.setJobDescription( "Sushi Chef" );
 		ProgramManager pm = new ProgramManager();
 		Collection<Employee> employees = new ArrayList<Employee>();
 		employees.add(e);
 		pm.setManages( employees );
 		job.setPm(pm);
 		e.setJobInfo( job );
 		s.persist( e );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.getTransaction().begin();
 		e = (Employee) s.get( e.getClass(), e.getId() );
 		assertEquals( "same job in both directions", 
 			e.getJobInfo().getJobDescription(),
 			e.getJobInfo().getPm().getManages().iterator().next().getJobInfo().getJobDescription()  );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Override
     protected Class[] getAnnotatedClasses() {
 		return new Class[]{
 				Friend.class,
 				Employer.class,
 				Employee.class,
 				Contractor.class,
 				Man.class,
 				Woman.class,
 				Store.class,
 				KnownClient.class,
 				Supplier.class,
 				City.class,
 				Cat.class,
 				Group.class,
 				GroupWithSet.class,
 				Permission.class,
 				Zone.class,
 				Inspector.class,
 				InspectorPrefixes.class,
 				BuildingCompany.class,
 				Building.class,
 				PhoneNumber.class,
 				ProgramManager.class
 		};
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/manytoone/Carz.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/manytoone/Carz.java
index e3ce9e16be..69e60c3290 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/manytoone/Carz.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/manytoone/Carz.java
@@ -1,122 +1,122 @@
 //$Id$
 package org.hibernate.test.annotations.manytoone;
 import java.io.Serializable;
 import java.util.Date;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.FetchType;
 import javax.persistence.Id;
 import javax.persistence.JoinColumn;
 import javax.persistence.ManyToOne;
 import javax.persistence.Temporal;
 import javax.persistence.TemporalType;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class Carz implements Serializable {
 	@Id
 	private Integer id;
 
 	@Column( name = "make", nullable = false )
 	private String make;
 
 	@Column( name = "model", nullable = false )
 	private String model;
 
 	@Column( name = "manufactured", nullable = false )
 	@Temporal( TemporalType.TIMESTAMP )
 	private Date manufactured;
 
 	@ManyToOne( fetch = FetchType.LAZY )
 	@JoinColumn( name = "loc_code", referencedColumnName = "loc_code" )
 	private Lotz lot;
 
 	public Carz() {
 	}
 
 	public Integer getId() {
 		return this.id;
 	}
 
 	public void setId(Integer id) {
 		this.id = id;
 	}
 
 	public Lotz getLot() {
 		return this.lot;
 	}
 
 	public void setLot(Lotz lot) {
 		this.lot = lot;
 	}
 
 	public String getMake() {
 		return this.make;
 	}
 
 	public void setMake(String make) {
 		this.make = make;
 	}
 
 	public Date getManufactured() {
 		return this.manufactured;
 	}
 
 	public void setManufactured(Date manufactured) {
 		this.manufactured = manufactured;
 	}
 
 	public String getModel() {
 		return this.model;
 	}
 
 	public void setModel(String model) {
 		this.model = model;
 	}
 
 	@Override
 	public int hashCode() {
 		final int PRIME = 31;
 		int result = 1;
 		result = PRIME * result + ( ( this.id == null ) ?
 				0 :
 				this.id.hashCode() );
 		result = PRIME * result + ( ( this.make == null ) ?
 				0 :
 				this.make.hashCode() );
 		result = PRIME * result + ( ( this.manufactured == null ) ?
 				0 :
 				this.manufactured.hashCode() );
 		result = PRIME * result + ( ( this.model == null ) ?
 				0 :
 				this.model.hashCode() );
 		return result;
 	}
 
 	@Override
 	public boolean equals(Object obj) {
 		if ( this == obj ) return true;
 		if ( obj == null ) return false;
 		if ( getClass() != obj.getClass() ) return false;
 		final Carz other = (Carz) obj;
 		if ( this.id == null ) {
 			if ( other.id != null ) return false;
 		}
 		else if ( !this.id.equals( other.id ) ) return false;
 		if ( this.make == null ) {
 			if ( other.make != null ) return false;
 		}
 		else if ( !this.make.equals( other.make ) ) return false;
 		if ( this.manufactured == null ) {
 			if ( other.manufactured != null ) return false;
 		}
 		else if ( !this.manufactured.equals( other.manufactured ) ) return false;
 		if ( this.model == null ) {
 			if ( other.model != null ) return false;
 		}
 		else if ( !this.model.equals( other.model ) ) return false;
 		return true;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/manytoone/ManyToOneTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/manytoone/ManyToOneTest.java
index 74737da101..ec61f61b2b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/manytoone/ManyToOneTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/manytoone/ManyToOneTest.java
@@ -1,399 +1,399 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.manytoone;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.Query;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.test.annotations.Company;
 import org.hibernate.test.annotations.Customer;
 import org.hibernate.test.annotations.Discount;
 import org.hibernate.test.annotations.Flight;
 import org.hibernate.test.annotations.Passport;
 import org.hibernate.test.annotations.Ticket;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Emmanuel Bernard
  */
 public class ManyToOneTest extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testEager() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Color c = new Color();
 		c.setName( "Yellow" );
 		s.persist( c );
 		Car car = new Car();
 		car.setBodyColor( c );
 		s.persist( car );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		car = (Car) s.get( Car.class, car.getId() );
 		tx.commit();
 		s.close();
 		assertNotNull( car );
 		assertNotNull( car.getBodyColor() );
 		assertEquals( "Yellow", car.getBodyColor().getName() );
 	}
 
 	@Test
 	public void testDefaultMetadata() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Color c = new Color();
 		c.setName( "Blue" );
 		s.persist( c );
 		Car car = new Car();
 		car.setBodyColor( c );
 		s.persist( car );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		car = (Car) s.get( Car.class, car.getId() );
 		assertNotNull( car );
 		assertNotNull( car.getBodyColor() );
 		assertEquals( c.getId(), car.getBodyColor().getId() );
 		tx.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testCreate() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Flight firstOne = new Flight();
 		firstOne.setId( new Long( 1 ) );
 		firstOne.setName( "AF0101" );
 		firstOne.setDuration( new Long( 1000 ) );
 		Company frenchOne = new Company();
 		frenchOne.setName( "Air France" );
 		firstOne.setCompany( frenchOne );
 		s.persist( firstOne );
 		tx.commit();
 		s.close();
 		assertNotNull( "identity id should work", frenchOne.getId() );
 
 		s = openSession();
 		tx = s.beginTransaction();
 		firstOne = (Flight) s.get( Flight.class, new Long( 1 ) );
 		assertNotNull( firstOne.getCompany() );
 		assertEquals( frenchOne.getName(), firstOne.getCompany().getName() );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCascade() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Discount discount = new Discount();
 		discount.setDiscount( 20.12 );
 		Customer customer = new Customer();
 		Collection discounts = new ArrayList();
 		discounts.add( discount );
 		customer.setName( "Quentin Tarantino" );
 		discount.setOwner( customer );
 		customer.setDiscountTickets( discounts );
 		s.persist( discount );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		discount = (Discount) s.get( Discount.class, discount.getId() );
 		assertNotNull( discount );
 		assertEquals( 20.12, discount.getDiscount(), 0.01 );
 		assertNotNull( discount.getOwner() );
 		customer = new Customer();
 		customer.setName( "Clooney" );
 		discount.setOwner( customer );
 		discounts = new ArrayList();
 		discounts.add( discount );
 		customer.setDiscountTickets( discounts );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		discount = (Discount) s.get( Discount.class, discount.getId() );
 		assertNotNull( discount );
 		assertNotNull( discount.getOwner() );
 		assertEquals( "Clooney", discount.getOwner().getName() );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		customer = (Customer) s.get( Customer.class, customer.getId() );
 		s.delete( customer );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testFetch() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Discount discount = new Discount();
 		discount.setDiscount( 20 );
 		Customer customer = new Customer();
 		Collection discounts = new ArrayList();
 		discounts.add( discount );
 		customer.setName( "Quentin Tarantino" );
 		discount.setOwner( customer );
 		customer.setDiscountTickets( discounts );
 		s.persist( discount );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		discount = (Discount) s.get( Discount.class, discount.getId() );
 		assertNotNull( discount );
 		assertFalse( Hibernate.isInitialized( discount.getOwner() ) );
 		tx.commit();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		discount = (Discount) s.load( Discount.class, discount.getId() );
 		assertNotNull( discount );
 		assertFalse( Hibernate.isInitialized( discount.getOwner() ) );
 		tx.commit();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.delete( s.get( Discount.class, discount.getId() ) );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCompositeFK() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		ParentPk ppk = new ParentPk();
 		ppk.firstName = "John";
 		ppk.lastName = "Doe";
 		Parent p = new Parent();
 		p.age = 45;
 		p.id = ppk;
 		s.persist( p );
 		Child c = new Child();
 		c.parent = p;
 		s.persist( c );
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		//FIXME: fix this when the small parser bug will be fixed
 		Query q = s.createQuery( "from " + Child.class.getName() ); //+ " c where c.parent.id.lastName = :lastName");
 		//q.setString("lastName", p.id.lastName);
 		List result = q.list();
 		assertEquals( 1, result.size() );
 		Child c2 = (Child) result.get( 0 );
 		assertEquals( c2.id, c.id );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testImplicitCompositeFk() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Node n1 = new Node();
 		n1.setDescription( "Parent" );
 		NodePk n1pk = new NodePk();
 		n1pk.setLevel( 1 );
 		n1pk.setName( "Root" );
 		n1.setId( n1pk );
 		Node n2 = new Node();
 		NodePk n2pk = new NodePk();
 		n2pk.setLevel( 2 );
 		n2pk.setName( "Level 1: A" );
 		n2.setParent( n1 );
 		n2.setId( n2pk );
 		s.persist( n2 );
 		tx.commit();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		n2 = (Node) s.get( Node.class, n2pk );
 		assertNotNull( n2 );
 		assertNotNull( n2.getParent() );
 		assertEquals( 1, n2.getParent().getId().getLevel() );
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testManyToOneNonPk() throws Exception {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Order order = new Order();
 		order.setOrderNbr( "123" );
 		s.persist( order );
 		OrderLine ol = new OrderLine();
 		ol.setItem( "Mouse" );
 		ol.setOrder( order );
 		s.persist( ol );
 		s.flush();
 		s.clear();
 		ol = (OrderLine) s.get( OrderLine.class, ol.getId() );
 		assertNotNull( ol.getOrder() );
 		assertEquals( "123", ol.getOrder().getOrderNbr() );
 		assertTrue( ol.getOrder().getOrderLines().contains( ol ) );
 		tx.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testManyToOneNonPkSecondaryTable() throws Exception {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Order order = new Order();
 		order.setOrderNbr( "123" );
 		s.persist( order );
 		OrderLine ol = new OrderLine();
 		ol.setItem( "Mouse" );
 		ol.setReplacementOrder( order );
 		s.persist( ol );
 		s.flush();
 		s.clear();
 		ol = (OrderLine) s.get( OrderLine.class, ol.getId() );
 		assertNotNull( ol.getReplacementOrder() );
 		assertEquals( "123", ol.getReplacementOrder().getOrderNbr() );
 		assertFalse( ol.getReplacementOrder().getOrderLines().contains( ol ) );
 		tx.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testTwoManyToOneNonPk() throws Exception {
 		//2 many to one non pk pointing to the same referencedColumnName should not fail
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		org.hibernate.test.annotations.manytoone.Customer customer = new org.hibernate.test.annotations.manytoone.Customer();
 		customer.userId="123";
 		org.hibernate.test.annotations.manytoone.Customer customer2 = new org.hibernate.test.annotations.manytoone.Customer();
 		customer2.userId="124";
 		s.persist( customer2 );
 		s.persist( customer );
 		Deal deal = new Deal();
 		deal.from = customer;
 		deal.to = customer2;
 		s.persist( deal );
 		s.flush();
 		s.clear();
 		deal = (Deal) s.get( Deal.class, deal.id );
 		assertNotNull( deal.from );
 		assertNotNull( deal.to );
 		tx.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testFormulaOnOtherSide() throws Exception {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Frame frame = new Frame();
 		frame.setName( "Prada" );
 		s.persist( frame );
 		Lens l = new Lens();
 		l.setFocal( 2.5f );
 		l.setFrame( frame );
 		s.persist( l );
 		Lens r = new Lens();
 		r.setFocal( 1.2f);
 		r.setFrame( frame );
 		s.persist( r );
 		s.flush();
 		s.clear();
 		frame = (Frame) s.get( Frame.class, frame.getId() );
 		assertEquals( 2, frame.getLenses().size() );
 		assertTrue( frame.getLenses().iterator().next().getLength() <= 1/1.2f );
 		assertTrue( frame.getLenses().iterator().next().getLength() >= 1/2.5f );
 		tx.rollback();
 		s.close();
 	}
 
 
 	@Override
 	protected Class[] getAnnotatedClasses() {
 		return new Class[]{
 				Deal.class,
 				org.hibernate.test.annotations.manytoone.Customer.class,
 				Car.class,
 				Color.class,
 				Flight.class,
 				Company.class,
 				Customer.class,
 				Discount.class,
 				Ticket.class,
 				Passport.class,
 				Parent.class,
 				Child.class,
 				Node.class,
 				User.class,
 				DistrictUser.class,
 				Order.class,
 				OrderLine.class,
 				Frame.class,
 				Lens.class
 		};
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/manytoone/referencedcolumnname/Vendor.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/manytoone/referencedcolumnname/Vendor.java
index 965f87ac4b..5d7900222c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/manytoone/referencedcolumnname/Vendor.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/manytoone/referencedcolumnname/Vendor.java
@@ -1,7 +1,7 @@
 //$
 package org.hibernate.test.annotations.manytoone.referencedcolumnname;
 import javax.persistence.Entity;
 
 @Entity
 public class Vendor extends GenericObject {
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/Account.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/Account.java
index 26031ca3e5..821ed37e2c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/Account.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/Account.java
@@ -1,45 +1,45 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.mappedsuperclass.intermediate;
 import javax.persistence.Entity;
 import javax.persistence.Inheritance;
 import javax.persistence.InheritanceType;
 import javax.persistence.Table;
 
 /**
  * The intermediate entity in the hierarchy
  *
  * @author Saša Obradović
  */
 @Entity
 @Table(name = "ACCOUNT")
 @Inheritance(strategy = InheritanceType.JOINED)
 public class Account extends AccountBase {
 	public Account() {
 	}
 
 	public Account(String accountNumber) {
 		super( accountNumber );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/AccountBase.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/AccountBase.java
index a16e05b9cb..0cc9f1e1df 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/AccountBase.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/AccountBase.java
@@ -1,65 +1,65 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.mappedsuperclass.intermediate;
 import javax.persistence.Column;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 import javax.persistence.MappedSuperclass;
 
 /**
  * Represents the most base super class in the hierarchy.
  *
  * @author Saša Obradović
  */
 @MappedSuperclass
 public abstract class AccountBase {
 	@Id
 	@org.hibernate.annotations.GenericGenerator(name = "generator::Account", strategy = "increment")
 	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "generator::Account")
 	@Column(name = "ACC_ID")
 	private Long id;
 
 	@Column(name = "ACC_NO")
 	private String accountNumber;
 
 	public Long getId() {
 		return id;
 	}
 
 	protected AccountBase() {
 	}
 
 	protected AccountBase(String accountNumber) {
 		this.accountNumber = accountNumber;
 	}
 
 	public String getAccountNumber() {
 		return accountNumber;
 	}
 
 	public void setAccountNumber(String accountNumber) {
 		this.accountNumber = accountNumber;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/SavingsAccount.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/SavingsAccount.java
index 56812e11de..44a9fd572d 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/SavingsAccount.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/SavingsAccount.java
@@ -1,45 +1,45 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.mappedsuperclass.intermediate;
 import java.math.BigDecimal;
 import javax.persistence.Entity;
 import javax.persistence.PrimaryKeyJoinColumn;
 import javax.persistence.Table;
 
 /**
  * The "leaf" entity in the hierarchy
  *
  * @author Saša Obradović
  */
 @Entity
 @Table(name = "SAVINGS_ACCOUNT")
 @PrimaryKeyJoinColumn(name = "SAVACC_ACC_ID")
 public class SavingsAccount extends SavingsAccountBase {
 	public SavingsAccount() {
 	}
 
 	public SavingsAccount(String accountNumber, BigDecimal withdrawalLimit) {
 		super( accountNumber, withdrawalLimit );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/SavingsAccountBase.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/SavingsAccountBase.java
index 6399262fb0..0a11005753 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/SavingsAccountBase.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/mappedsuperclass/intermediate/SavingsAccountBase.java
@@ -1,55 +1,55 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.mappedsuperclass.intermediate;
 import java.math.BigDecimal;
 import javax.persistence.Column;
 import javax.persistence.MappedSuperclass;
 
 
 /**
  * Represents the intermediate mapped superclass in the hierarchy.
  *
  * @author Saša Obradović
  */
 @MappedSuperclass
 public abstract class SavingsAccountBase extends Account {
 	@Column(name = "SAVACC_WITHDRAWALLIMIT")
 	private BigDecimal withdrawalLimit;
 
 	protected SavingsAccountBase() {
 	}
 
 	protected SavingsAccountBase(String accountNumber, BigDecimal withdrawalLimit) {
 		super( accountNumber );
 		this.withdrawalLimit = withdrawalLimit;
 	}
 
 	public BigDecimal getWithdrawalLimit() {
 		return withdrawalLimit;
 	}
 
 	public void setWithdrawalLimit(BigDecimal withdrawalLimit) {
 		this.withdrawalLimit = withdrawalLimit;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/namingstrategy/AddressEntry.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/namingstrategy/AddressEntry.java
index 6b6a7d96a4..4c87d527c0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/namingstrategy/AddressEntry.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/namingstrategy/AddressEntry.java
@@ -1,44 +1,44 @@
 package org.hibernate.test.annotations.namingstrategy;
 import javax.persistence.Embeddable;
 
 @Embeddable
 public class AddressEntry implements java.io.Serializable {
 	protected String street;
 	protected String city;
 	protected String state;
 	protected String zip;
 
 	public AddressEntry() {
 	}
 
  	public AddressEntry( String street, String city, String state, String zip) {
 		this.street = street;
 		this.city = city;
 		this.state = state;
 		this.zip = zip;
 	}
 	public String getCity() {
 		return city;
 	}
 	public void setCity(String c) {
 		city = c;
 	}
 	public String getState() {
 		return state;
 	}
 	public void setState(String state) {
 		this.state = state;
 	}
 	public String getStreet() {
 		return street;
 	}
 	public void setStreet(String street) {
 		this.street = street;
 	}
 	public String getZip() {
 		return zip;
 	}
 	public void setZip(String zip) {
 		this.zip = zip;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Manufacturer.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Manufacturer.java
index d64a4e0f2f..0eda7163ce 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Manufacturer.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Manufacturer.java
@@ -1,28 +1,28 @@
 //$Id$
 package org.hibernate.test.annotations.onetomany;
 import java.util.HashSet;
 import java.util.Set;
 
 /**
  * @author Emmanuel Bernard
  */
 public class Manufacturer {
 	private Integer id;
 	private Set<Model> models = new HashSet<Model>();
 
 	public Integer getId() {
 		return id;
 	}
 
 	public void setId(Integer id) {
 		this.id = id;
 	}
 
 	public Set<Model> getModels() {
 		return models;
 	}
 
 	public void setModels(Set<Model> models) {
 		this.models = models;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Model.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Model.java
index 0f3896237e..70f2400bcb 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Model.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Model.java
@@ -1,35 +1,35 @@
 //$Id$
 package org.hibernate.test.annotations.onetomany;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.ManyToOne;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class Model {
 	@Id
 	@GeneratedValue
 	private Integer id;
 
 	@ManyToOne
 	private Manufacturer manufacturer;
 
 	public Integer getId() {
 		return id;
 	}
 
 	public void setId(Integer id) {
 		this.id = id;
 	}
 
 	public Manufacturer getManufacturer() {
 		return manufacturer;
 	}
 
 	public void setManufacturer(Manufacturer manufacturer) {
 		this.manufacturer = manufacturer;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Order.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Order.java
index fcfa0aa2af..40754b863c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Order.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Order.java
@@ -1,67 +1,67 @@
 //$Id$
 package org.hibernate.test.annotations.onetomany;
 import java.util.ArrayList;
 import java.util.List;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.IdClass;
 import javax.persistence.OneToMany;
 import javax.persistence.OrderBy;
 import javax.persistence.Table;
 
 @Entity
 @Table( name = "Order_tbl" )
 @IdClass( OrderID.class )
 public class Order {
 	private String schoolId;
 	private Integer schoolIdSort;
 	private Integer academicYear;
 
 	private List<OrderItem> itemList = new ArrayList<OrderItem>();
 
 	public boolean equals(Object obj) {
 		return super.equals( obj );
 	}
 
 	public int hashCode() {
 		return 10;
 	}
 
 	@Id
 	public Integer getAcademicYear() {
 		return this.academicYear;
 	}
 
 	protected void setAcademicYear(Integer academicYear) {
 		this.academicYear = academicYear;
 	}
 
 	@Id
 	public String getSchoolId() {
 		return this.schoolId;
 	}
 
 	protected void setSchoolId(String schoolId) {
 		this.schoolId = schoolId;
 	}
 
 	@OneToMany( mappedBy = "order" )
 	@OrderBy( "dayNo desc" )
 	public List<OrderItem> getItemList() {
 		return this.itemList;
 	}
 
 	public void setItemList(List<OrderItem> itemList) {
 		this.itemList = itemList;
 	}
 
 	public Integer getSchoolIdSort() {
 		return this.schoolIdSort;
 	}
 
 	public void setSchoolIdSort(Integer schoolIdSort) {
 		this.schoolIdSort = schoolIdSort;
 	}
 
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/OrderID.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/OrderID.java
index a68b40498f..c4701680fb 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/OrderID.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/OrderID.java
@@ -1,30 +1,30 @@
 //$Id$
 package org.hibernate.test.annotations.onetomany;
 import java.io.Serializable;
 import javax.persistence.Column;
 
 /**
  * @author Emmanuel Bernard
  */
 public class OrderID implements Serializable {
 	private String schoolId;
 	private Integer academicYear;
 
 	@Column( name = "Academic_Yr" )
 	public Integer getAcademicYear() {
 		return this.academicYear;
 	}
 
 	public void setAcademicYear(Integer academicYear) {
 		this.academicYear = academicYear;
 	}
 
 	@Column( name = "School_Id" )
 	public String getSchoolId() {
 		return this.schoolId;
 	}
 
 	public void setSchoolId(String schoolId) {
 		this.schoolId = schoolId;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Post.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Post.java
index 1a22d8ae4c..c61e36ba47 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Post.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetomany/Post.java
@@ -1,32 +1,32 @@
 package org.hibernate.test.annotations.onetomany;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import javax.persistence.CascadeType;
 import javax.persistence.DiscriminatorValue;
 import javax.persistence.Entity;
 import javax.persistence.FetchType;
 import javax.persistence.OneToMany;
 import javax.persistence.OrderColumn;
 
 import org.hibernate.annotations.LazyCollection;
 import org.hibernate.annotations.LazyCollectionOption;
 
 @Entity(name = "Post")
 @DiscriminatorValue(value = "WCT")
 public class Post extends Comment{
 
 	protected List<Comment> comments = new ArrayList<Comment>();
 
 	@OneToMany(mappedBy = "post", cascade = CascadeType.ALL , orphanRemoval = false, fetch = FetchType.LAZY)
 	@LazyCollection(LazyCollectionOption.EXTRA)
 	@OrderColumn(name = "idx")
 	public List<Comment> getComments() {
 		return comments;
 	}
 
 	public void setComments(List<Comment> comments) {
 		this.comments = comments;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetoone/OneToOneErrorTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetoone/OneToOneErrorTest.java
index 0ef63b9fca..0da443dc7a 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetoone/OneToOneErrorTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetoone/OneToOneErrorTest.java
@@ -1,44 +1,44 @@
 //$Id$
 package org.hibernate.test.annotations.onetoone;
 
 import org.junit.Assert;
 import org.junit.Test;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.SessionFactory;
 import org.hibernate.cfg.AnnotationConfiguration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.testing.ServiceRegistryBuilder;
 
 /**
  * @author Emmanuel Bernard
  */
 public class OneToOneErrorTest {
     @Test
 	public void testWrongOneToOne() throws Exception {
 		AnnotationConfiguration cfg = new AnnotationConfiguration();
 		cfg.addAnnotatedClass( Show.class )
 				.addAnnotatedClass( ShowDescription.class );
 		cfg.setProperty( Environment.HBM2DDL_AUTO, "create-drop" );
 		ServiceRegistry serviceRegistry = null;
 		SessionFactory sessionFactory = null;
 		try {
 			serviceRegistry = ServiceRegistryBuilder.buildServiceRegistry( Environment.getProperties() );
 			sessionFactory = cfg.buildSessionFactory( serviceRegistry );
             Assert.fail( "Wrong mappedBy does not fail property" );
 		}
 		catch (AnnotationException e) {
 			//success
 		}
 		finally {
 			if(sessionFactory!=null){
 				sessionFactory.close();
 			}
 			if ( serviceRegistry != null ) {
 				ServiceRegistryBuilder.destroy( serviceRegistry );
 			}
 
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetoone/hhh4851/DeviceGroupConfig.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetoone/hhh4851/DeviceGroupConfig.java
index 377ece0479..9796939056 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetoone/hhh4851/DeviceGroupConfig.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetoone/hhh4851/DeviceGroupConfig.java
@@ -1,34 +1,34 @@
 package org.hibernate.test.annotations.onetoone.hhh4851;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.Table;
 
 /**
  * A group of {@link LogicalTerminal logical terminals}. Used to group them for Configuration purpose. That's why a
  * LogicalTerminal can only have one TerminalGroup.
  */
 @Entity
 @Table
 public class DeviceGroupConfig extends BaseEntity {
 
 	private String name = null;
 
 	public DeviceGroupConfig() {
 
 	}
 
 	/**
 	 * Not unique, because we could use the same name in two different organizations.
 	 *
 	 * @return
 	 */
 	@Column(nullable = false)
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetoone/hhh4851/Owner.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetoone/hhh4851/Owner.java
index f55e6b0ec3..362c0bd002 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/onetoone/hhh4851/Owner.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/onetoone/hhh4851/Owner.java
@@ -1,65 +1,65 @@
 package org.hibernate.test.annotations.onetoone.hhh4851;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.Table;
 import javax.persistence.Version;
 
 @Entity
 @Table
 public class Owner {
 
 	private boolean deleted = false;
 	private Long id;
 
 	private String name;
 	private Integer version;
 
 	public Owner() {
 
 	}
 
 	public Owner(String name) {
 		this.name = name;
 	}
 
 	@Id
 	@GeneratedValue
 	public Long getId() {
 		return id;
 	}
 
 	@Column(nullable = false, unique = true)
 	public String getName() {
 		return name;
 	}
 
 	@Version
 	public Integer getVersion() {
 		return version;
 	}
 
 	public boolean isDeleted() {
 		return deleted;
 	}
 
 	public Owner setDeleted(boolean isDeleted) {
 		this.deleted = isDeleted;
 		return this;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public Owner setName(String name) {
 		this.name = name;
 		return this;
 	}
 
 	public void setVersion(Integer version) {
 		this.version = version;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/override/Addr.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/override/Addr.java
index 9aa205e744..f8535c313b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/override/Addr.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/override/Addr.java
@@ -1,65 +1,65 @@
 package org.hibernate.test.annotations.override;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 
 @Entity
 public class Addr {
 
 	@Id
 	int id;
 
 	private String street;
 	private String city;
 	private String state;
 	private String country;
 	private String zipcode;
 
 	public String getStreet() {
 		return street;
 	}
 
 	public void setStreet(String street) {
 		this.street = street;
 	}
 
 	public String getCity() {
 		return city;
 	}
 
 	public void setCity(String city) {
 		this.city = city;
 	}
 
 	public String getState() {
 		return state;
 	}
 
 	public void setState(String state) {
 		this.state = state;
 	}
 
 	public String getCountry() {
 		return country;
 	}
 
 	public void setCountry(String country) {
 		this.country = country;
 	}
 
 	public String getZipcode() {
 		return zipcode;
 	}
 
 	public void setZipcode(String zipcode) {
 		this.zipcode = zipcode;
 	}
 
 	public int getId() {
 		return id;
 	}
 
 	public void setId(int id) {
 		this.id = id;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/override/PropertyRecord.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/override/PropertyRecord.java
index a0675e227b..88aabe4939 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/override/PropertyRecord.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/override/PropertyRecord.java
@@ -1,52 +1,52 @@
 package org.hibernate.test.annotations.override;
 import java.util.Map;
 import java.util.Set;
 import javax.persistence.AttributeOverride;
 import javax.persistence.AttributeOverrides;
 import javax.persistence.CollectionTable;
 import javax.persistence.Column;
 import javax.persistence.ElementCollection;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class PropertyRecord {
 	@Id
 	@GeneratedValue
 	public Long id;
 
 	@AttributeOverrides({
 			@AttributeOverride(name = "key.street", column = @Column(name = "STREET_NAME")),
 			@AttributeOverride(name = "value.size", column = @Column(name = "SQUARE_FEET")),
 			@AttributeOverride(name = "value.tax", column = @Column(name = "ASSESSMENT"))
 					})
 	@ElementCollection
 	public Map<Address, PropertyInfo> parcels;
 
 	@AttributeOverrides({
 			@AttributeOverride(name = "key.street", column = @Column(name = "STREET_NAME")),
 			@AttributeOverride(name = "value.size", column = @Column(name = "SQUARE_FEET")),
 			@AttributeOverride(name = "value.tax", column = @Column(name = "ASSESSMENT"))
 					})
 	@ElementCollection
 	@CollectionTable(name="LegacyParcels")
 	public Map<Address, PropertyInfo> legacyParcels;
 
 	@AttributeOverrides({
 			@AttributeOverride(name = "size", column = @Column(name = "SQUARE_FEET")),
 			@AttributeOverride(name = "tax", column = @Column(name = "ASSESSMENT"))
 					})
 	@ElementCollection
 	public Set<PropertyInfo> unsortedParcels;
 
 	@AttributeOverrides({
 			@AttributeOverride(name = "size", column = @Column(name = "SQUARE_FEET")),
 			@AttributeOverride(name = "tax", column = @Column(name = "ASSESSMENT"))
 					})
 	@ElementCollection
 	public Set<PropertyInfo> legacyUnsortedParcels;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/Card.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/Card.java
index e2b16e6d9e..5d832a7e95 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/Card.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/Card.java
@@ -1,20 +1,20 @@
 package org.hibernate.test.annotations.persister;
 import java.io.Serializable;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.JoinColumn;
 import javax.persistence.ManyToOne;
 
 /**
  * @author Shawn Clowater
  */
 @Entity
 @org.hibernate.annotations.Entity( persister = "org.hibernate.persister.entity.SingleTableEntityPersister" )
 public class Card implements Serializable {
 	@Id
 	public Integer id;
 
 	@ManyToOne()
 	@JoinColumn()
 	public Deck deck;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/CollectionPersister.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/CollectionPersister.java
index 60ed39f1ac..ac7148edda 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/CollectionPersister.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/CollectionPersister.java
@@ -1,18 +1,18 @@
 package org.hibernate.test.annotations.persister;
 import org.hibernate.MappingException;
 import org.hibernate.cache.CacheException;
 import org.hibernate.cache.spi.access.CollectionRegionAccessStrategy;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.mapping.Collection;
 import org.hibernate.persister.collection.OneToManyPersister;
 
 /**
  * @author Shawn Clowater
  */
 public class CollectionPersister extends OneToManyPersister {
 	public CollectionPersister(Collection collection, CollectionRegionAccessStrategy cache, Configuration cfg,
 							   SessionFactoryImplementor factory) throws MappingException, CacheException {
 		super( collection, cache, cfg, factory );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/Deck.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/Deck.java
index 33559b5fed..8d5a29382b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/Deck.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/Deck.java
@@ -1,24 +1,24 @@
 package org.hibernate.test.annotations.persister;
 import java.io.Serializable;
 import java.util.Set;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
 
 import org.hibernate.annotations.Persister;
 
 
 /**
  * @author Shawn Clowater
  */
 @Entity
 @org.hibernate.annotations.Entity( persister = "org.hibernate.persister.entity.SingleTableEntityPersister" )
 @Persister( impl = org.hibernate.test.annotations.persister.EntityPersister.class )
 public class Deck implements Serializable {
 	@Id
 	public Integer id;
 
 	@OneToMany( mappedBy = "deck" )
 	@Persister( impl = org.hibernate.test.annotations.persister.CollectionPersister.class )
 	public Set<Card> cards;
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/EntityPersister.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/EntityPersister.java
index b8c0a3e7fa..0008378144 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/EntityPersister.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/EntityPersister.java
@@ -1,19 +1,19 @@
 package org.hibernate.test.annotations.persister;
 import org.hibernate.HibernateException;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.access.NaturalIdRegionAccessStrategy;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.persister.entity.SingleTableEntityPersister;
 
 /**
  * @author Shawn Clowater
  */
 public class EntityPersister extends SingleTableEntityPersister {
 	public EntityPersister(PersistentClass persistentClass, EntityRegionAccessStrategy cache,
 							NaturalIdRegionAccessStrategy naturalIdRegionAccessStrategy,
 						   SessionFactoryImplementor factory,  Mapping cfg) throws HibernateException {
 		super( persistentClass, cache, naturalIdRegionAccessStrategy, factory, cfg );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/PersisterTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/PersisterTest.java
index 7dea55638c..5d357925ce 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/PersisterTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/persister/PersisterTest.java
@@ -1,70 +1,70 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.persister;
 
 import org.junit.Test;
 
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.persister.entity.SingleTableEntityPersister;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Shawn Clowater
  */
 public class PersisterTest extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testEntityEntityPersisterAndPersisterSpecified() throws Exception {
 		//checks to see that the persister specified with the @Persister annotation takes precedence if a @Entity.persister() is also specified		
 		PersistentClass persistentClass = configuration().getClassMapping( Deck.class.getName() );
 		assertEquals( "Incorrect Persister class for " + persistentClass.getMappedClass(), EntityPersister.class,
 				persistentClass.getEntityPersisterClass() );
 	}
 
 	@Test
 	public void testEntityEntityPersisterSpecified() throws Exception {
 		//tests the persister specified with an @Entity.persister()		
 		PersistentClass persistentClass = configuration().getClassMapping( Card.class.getName() );
 		assertEquals( "Incorrect Persister class for " + persistentClass.getMappedClass(),
 				SingleTableEntityPersister.class, persistentClass.getEntityPersisterClass() );
 	}
 
 	@Test
 	public void testCollectionPersisterSpecified() throws Exception {
 		//tests the persister specified by the @Persister annotation on a collection
 		Collection collection = configuration().getCollectionMapping( Deck.class.getName() + ".cards" );
 		assertEquals( "Incorrect Persister class for collection " + collection.getRole(), CollectionPersister.class,
 				collection.getCollectionPersisterClass() );
 	}
 
 	@Override
 	protected Class[] getAnnotatedClasses() {
 		return new Class[]{
 				Card.class,
 				Deck.class
 		};
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/query/AllTables.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/query/AllTables.java
index 1f6240379d..1ab91d18e5 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/query/AllTables.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/query/AllTables.java
@@ -1,44 +1,44 @@
 package org.hibernate.test.annotations.query;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.EntityResult;
 import javax.persistence.FieldResult;
 import javax.persistence.Id;
 import javax.persistence.SqlResultSetMapping;
 import javax.persistence.Table;
 
 import org.hibernate.annotations.Formula;
 
 @Entity
 @Table(name = "ALL_TABLES")
 @SqlResultSetMapping(name = "all",
 		entities = @EntityResult(entityClass = AllTables.class,
 				fields = {
 						@FieldResult(name = "tableName", column = "t_name"),
 						@FieldResult(name = "daysOld", column = "t_time")
 				}))
  public class AllTables {
 
 	@Id
 	@Column(name = "TABLE_NAME", nullable = false)
 	private String tableName;
 
 	@Formula(value = "(SYSDATE())")
 	private String daysOld;
 
 	public String getTableName() {
 		return tableName;
 	}
 
 	public void setTableName(String tableName) {
 		this.tableName = tableName;
 	}
 
 	public String getDaysOld() {
 		return daysOld;
 	}
 
 	public void setDaysOld(String daysOld) {
 		this.daysOld = daysOld;
 	}
- }
\ No newline at end of file
+ }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/quote/Person.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/quote/Person.java
index 0705a3117b..b99e250d21 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/quote/Person.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/quote/Person.java
@@ -1,56 +1,56 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2013 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.test.annotations.quote;
 
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.Table;
 import javax.persistence.UniqueConstraint;
 
 /**
  * @author Brett Meyer
  */
 @Entity
 @Table(uniqueConstraints = { @UniqueConstraint(columnNames = { "name" }) })
 public class Person {
 	@Id
 	@GeneratedValue
 	private long id;
 
 	private String name;
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/quote/Role.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/quote/Role.java
index 3f25f20056..2123acc425 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/quote/Role.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/quote/Role.java
@@ -1,21 +1,21 @@
 //$Id$
 package org.hibernate.test.annotations.quote;
 import java.io.Serializable;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 import javax.persistence.Table;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 @Table(name = "`Role`")
 public class Role implements Serializable {
 
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private long id;
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/referencedcolumnname/Item.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/referencedcolumnname/Item.java
index 1d826df66a..894d8c2496 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/referencedcolumnname/Item.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/referencedcolumnname/Item.java
@@ -1,22 +1,22 @@
 //$Id$
 package org.hibernate.test.annotations.referencedcolumnname;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity
 public class Item {
 	int id;
 
 	@Id
 	public int getId() {
 		return id;
 	}
 
 	public void setId(int id) {
 		this.id = id;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/tableperclass/Component.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/tableperclass/Component.java
index 151a03797e..776647757f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/tableperclass/Component.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/tableperclass/Component.java
@@ -1,52 +1,52 @@
 //$Id$
 package org.hibernate.test.annotations.tableperclass;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.Inheritance;
 import javax.persistence.InheritanceType;
 
 import org.hibernate.annotations.Index;
 
 /**
  * @author Emmanuel Bernard
  */
 @Entity(name = "xpmComponent")
 @Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
 public abstract class Component {
 	private String manufacturerPartNumber;
 	private Long manufacturerId;
 	private Long id;
 
 
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 
 	@Id
 	public Long getId() {
 		return id;
 	}
 
 	@Column(nullable = false)
 	@Index(name = "manufacturerPartNumber")
 	public String getManufacturerPartNumber() {
 		return manufacturerPartNumber;
 	}
 
 	@Column(nullable = false)
 	public Long getManufacturerId() {
 		return manufacturerId;
 	}
 
 	public void setManufacturerId(Long manufacturerId) {
 		this.manufacturerId = manufacturerId;
 	}
 
 
 	public void setManufacturerPartNumber(String manufacturerPartNumber) {
 		this.manufacturerPartNumber = manufacturerPartNumber;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/xml/hbm/BImpl.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/xml/hbm/BImpl.java
index 8e770906e4..cd909e3038 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/xml/hbm/BImpl.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/xml/hbm/BImpl.java
@@ -1,25 +1,25 @@
 //$Id$
 package org.hibernate.test.annotations.xml.hbm;
 import javax.persistence.Entity;
 import javax.persistence.Table;
 
 @Entity
 @org.hibernate.annotations.Proxy( proxyClass = B.class )
 @Table( name = "B" )
 public class BImpl extends AImpl implements B {
 	private static final long serialVersionUID = 1L;
 
 	private Integer bId = 0;
 
 	public BImpl() {
 		super();
 	}
 
 	public Integer getBId() {
 		return bId;
 	}
 
 	public void setBId(Integer bId) {
 		this.bId = bId;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/cascade/CascadeTestWithAssignedParentIdTest.java b/hibernate-core/src/test/java/org/hibernate/test/cascade/CascadeTestWithAssignedParentIdTest.java
index 597b5b0ec1..00a0222c1f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/cascade/CascadeTestWithAssignedParentIdTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/cascade/CascadeTestWithAssignedParentIdTest.java
@@ -1,72 +1,71 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cascade;
 import java.util.Collections;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * Test case to illustrate that when a child table attempts to cascade to a parent and the parent's Id
  * is set to assigned, an exception thrown (not-null property references a null or transient value). 
  * This error only occurs if the parent link in marked as not nullable.
  *
  * @author Wallace Wadge (based on code by Gail Badner)
  */
 public class CascadeTestWithAssignedParentIdTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] {
 				"cascade/ChildForParentWithAssignedId.hbm.xml",
 				"cascade/ParentWithAssignedId.hbm.xml"
 		};
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testSaveChildWithParent() {
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 		Parent parent = new Parent();
 		Child child = new Child();
 		child.setParent( parent );
 		parent.setChildren( Collections.singleton( child ) );
 		parent.setId( Long.valueOf(123L) );
 		// this should figure out that the parent needs saving first since id is assigned.
 		session.save( child );
 		txn.commit();
 		session.close();
 
 		session = openSession();
 		txn = session.beginTransaction();
 		parent = ( Parent ) session.get( Parent.class, parent.getId() );
 		assertEquals( 1, parent.getChildren().size() );
 		txn.commit();
 		session.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullFalseDelayedInsertTest.java b/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullFalseDelayedInsertTest.java
index acd562fa14..5f6acee73e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullFalseDelayedInsertTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullFalseDelayedInsertTest.java
@@ -1,38 +1,38 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cascade.circle;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 
 /**
  * @author Gail Badner
  */
 public class MultiPathCircleCascadeCheckNullFalseDelayedInsertTest extends MultiPathCircleCascadeDelayedInsertTest {
 	@Override
 	 public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.CHECK_NULLABILITY, "false" );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullTrueDelayedInsertTest.java b/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullTrueDelayedInsertTest.java
index c47c964eb7..655b668aed 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullTrueDelayedInsertTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullTrueDelayedInsertTest.java
@@ -1,38 +1,38 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cascade.circle;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 
 /**
  * @author Gail Badner
  */
 public class MultiPathCircleCascadeCheckNullTrueDelayedInsertTest extends MultiPathCircleCascadeDelayedInsertTest {
 	@Override
 	 public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.CHECK_NULLABILITY, "true" );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullibilityFalseTest.java b/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullibilityFalseTest.java
index de48c60850..4a822b2236 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullibilityFalseTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullibilityFalseTest.java
@@ -1,38 +1,38 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cascade.circle;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 
 /**
  * @author Gail Badner
  */
 public class MultiPathCircleCascadeCheckNullibilityFalseTest extends MultiPathCircleCascadeTest {
 	@Override
 	 public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.CHECK_NULLABILITY, "false" );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullibilityTrueTest.java b/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullibilityTrueTest.java
index c440049c0b..407418209d 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullibilityTrueTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/MultiPathCircleCascadeCheckNullibilityTrueTest.java
@@ -1,38 +1,38 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cascade.circle;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 
 /**
  * @author Gail Badner
  */
 public class MultiPathCircleCascadeCheckNullibilityTrueTest extends MultiPathCircleCascadeTest {
 	@Override
 	 public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.CHECK_NULLABILITY, "true" );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/Vehicle.java b/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/Vehicle.java
index e6c9b83e84..5ae90e2177 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/Vehicle.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/cascade/circle/Vehicle.java
@@ -1,105 +1,105 @@
 //$Id: $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 
 package org.hibernate.test.cascade.circle;
 import java.util.HashSet;
 import java.util.Set;
 
 
 public class Vehicle {
 
 //	@Id
 //	@SequenceGenerator(name="TRANSPORT_SEQ", sequenceName="TRANSPORT_SEQ", initialValue=1, allocationSize=1)
 //	@GeneratedValue(strategy=GenerationType.SEQUENCE, generator="TRANSPORT_SEQ")
 	private Long vehicleID;
 
 	private long version;
 
 	private String name;
 
 	private Set transports = new HashSet();
 
 	private Route route;
 
 	private String transientField = "vehicle original value";
 
 	protected void setVehicleID(Long vehicleID) {
 		this.vehicleID = vehicleID;
 	}
 
 	public Long getVehicleID() {
 		return vehicleID;
 	}
 
 	public long getVersion() {
 		return version;
 	}
 
 	protected void setVersion(long version) {
 		this.version = version;
 	}
 
 	public Set getTransports() {
 		return transports;
 	}
 
 	public void setTransports(Set transports) {
 		this.transports = transports;
 	}
 
 	public Route getRoute() {
 		return route;
 	}
 
 	public void setRoute(Route route) {
 		this.route = route;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	public String toString()
 	{
 		StringBuilder buffer = new StringBuilder();
 
 		buffer.append(name + " id: " + vehicleID + "\n");
 
 		return buffer.toString();
 	}
 
 	public String getTransientField() {
 		return transientField;
 	}
 
 	public void setTransientField(String transientField) {
 		this.transientField = transientField;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/collection/map/hhh7557/MapKey.java b/hibernate-core/src/test/java/org/hibernate/test/collection/map/hhh7557/MapKey.java
index 3bba1a0ae1..afc5913f5c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/collection/map/hhh7557/MapKey.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/collection/map/hhh7557/MapKey.java
@@ -1,154 +1,154 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.collection.map.hhh7557;
 
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.FetchType;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.JoinColumn;
 import javax.persistence.ManyToOne;
 import javax.persistence.Table;
 import javax.persistence.UniqueConstraint;
 
 import org.jboss.logging.Logger;
 
 /**
  * @author Elizabeth Chatman
  * @author Steve Ebersole
  */
 @Entity
 @Table(name = "map_key", uniqueConstraints = {
 		@UniqueConstraint(columnNames = {"name", "default_map_value_id"})
 })
 public class MapKey {
 	private static final Logger log = Logger.getLogger( MapKey.class );
 
 	private Long id;
 	private String name;
 	private MapValue defaultValue;
 
 	public MapKey() {
 	}
 
 	public MapKey(String name, MapValue defaultValue) {
 		this.name = name;
 		this.defaultValue = defaultValue;
 	}
 
 	@Id
 	@GeneratedValue
 	@Column(name = "id", unique = true, nullable = false)
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	@Column(name = "name", nullable = false)
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		log.tracef( "Setting name : %s", name );
 		this.name = name;
 	}
 
 	@ManyToOne(fetch = FetchType.EAGER)
 	@JoinColumn(name = "default_map_value_id", nullable = false)
 	public MapValue getDefaultValue() {
 		return defaultValue;
 	}
 
 	public void setDefaultValue(MapValue defaultValue) {
 		log.tracef( "Setting defaultValue : %s", defaultValue );
 		this.defaultValue = defaultValue;
 	}
 
 	private int previousHashCode = -1;
 
 	@Override
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
 		result = prime * result + ((getDefaultValue() == null) ? 0 : getDefaultValue().hashCode());
 		result = prime * result + ((getName() == null) ? 0 : getName().hashCode());
 		log.tracef(
 				"Calculated hashcode [%s] = %s (previous=%s, changed?=%s)",
 				this,
 				result,
 				previousHashCode,
 				!(previousHashCode == -1 || previousHashCode == result)
 		);
 		previousHashCode = result;
 		return result;
 	}
 
 	@Override
 	public boolean equals(Object obj) {
 		log.tracef( "Checking equality : %s -> %s", this, obj );
 		if ( this == obj ) {
 			return true;
 		}
 		if ( obj == null ) {
 			return false;
 		}
 		if ( !(obj instanceof MapKey) ) {
 			return false;
 		}
 		MapKey other = (MapKey) obj;
 		if ( getDefaultValue() == null ) {
 			if ( other.getDefaultValue() != null ) {
 				return false;
 			}
 		}
 		else if ( !getDefaultValue().equals( other.getDefaultValue() ) ) {
 			return false;
 		}
 		if ( getName() == null ) {
 			if ( other.getName() != null ) {
 				return false;
 			}
 		}
 		else if ( !getName().equals( other.getName() ) ) {
 			return false;
 		}
 		return true;
 	}
 
 	@Override
 	public String toString() {
 		StringBuilder builder = new StringBuilder();
 		builder.append( "MapKey [id=" ).append( getId() )
 				.append( ", name=" ).append( getName() )
 				.append( ", defaultValue=" ).append( getDefaultValue() )
 				.append( "]" );
 		return builder.toString();
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/collection/original/CollectionTest.java b/hibernate-core/src/test/java/org/hibernate/test/collection/original/CollectionTest.java
index dbd503b391..8a754e5f99 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/collection/original/CollectionTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/collection/original/CollectionTest.java
@@ -1,274 +1,274 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.collection.original;
 import java.sql.SQLException;
 
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.HibernateException;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Gavin King
  */
 public class CollectionTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "collection/original/UserPermissions.hbm.xml", "collection/original/Zoo.hbm.xml" };
 	}
 
 	@Test
 	public void testExtraLazy() throws HibernateException, SQLException {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		User u = new User( "gavin" );
 		u.getPermissions().add( new Permission( "obnoxiousness" ) );
 		u.getPermissions().add( new Permission( "pigheadedness" ) );
 		u.getSessionData().put( "foo", "foo value" );
 		s.persist( u );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		u = ( User ) s.get( User.class, "gavin" );
 
 		assertFalse( Hibernate.isInitialized( u.getPermissions() ) );
 		assertEquals( u.getPermissions().size(), 2 );
 		assertTrue( u.getPermissions().contains( new Permission( "obnoxiousness" ) ) );
 		assertFalse( u.getPermissions().contains( new Permission( "silliness" ) ) );
 		assertNotNull( u.getPermissions().get( 1 ) );
 		assertNull( u.getPermissions().get( 3 ) );
 		assertFalse( Hibernate.isInitialized( u.getPermissions() ) );
 
 		assertFalse( Hibernate.isInitialized( u.getSessionData() ) );
 		assertEquals( u.getSessionData().size(), 1 );
 		assertTrue( u.getSessionData().containsKey( "foo" ) );
 		assertFalse( u.getSessionData().containsKey( "bar" ) );
 		assertTrue( u.getSessionData().containsValue( "foo value" ) );
 		assertFalse( u.getSessionData().containsValue( "bar" ) );
 		assertEquals( "foo value", u.getSessionData().get( "foo" ) );
 		assertNull( u.getSessionData().get( "bar" ) );
 		assertFalse( Hibernate.isInitialized( u.getSessionData() ) );
 
 		assertFalse( Hibernate.isInitialized( u.getSessionData() ) );
 		u.getSessionData().put( "bar", "bar value" );
 		u.getSessionAttributeNames().add( "bar" );
 		assertFalse( Hibernate.isInitialized( u.getSessionAttributeNames() ) );
 		assertTrue( Hibernate.isInitialized( u.getSessionData() ) );
 
 		s.delete( u );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testMerge() throws HibernateException, SQLException {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		User u = new User( "gavin" );
 		u.getPermissions().add( new Permission( "obnoxiousness" ) );
 		u.getPermissions().add( new Permission( "pigheadedness" ) );
 		s.persist( u );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		User u2 = ( User ) s.createCriteria( User.class ).uniqueResult();
 		u2.setPermissions( null ); //forces one shot delete
 		s.merge( u );
 		t.commit();
 		s.close();
 
 		u.getPermissions().add( new Permission( "silliness" ) );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.merge( u );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		u2 = ( User ) s.createCriteria( User.class ).uniqueResult();
 		assertEquals( u2.getPermissions().size(), 3 );
 		assertEquals( ( ( Permission ) u2.getPermissions().get( 0 ) ).getType(), "obnoxiousness" );
 		assertEquals( ( ( Permission ) u2.getPermissions().get( 2 ) ).getType(), "silliness" );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete( u2 );
 		s.flush();
 		t.commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testFetch() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		User u = new User( "gavin" );
 		u.getPermissions().add( new Permission( "obnoxiousness" ) );
 		u.getPermissions().add( new Permission( "pigheadedness" ) );
 		u.getEmailAddresses().add( new Email( "gavin@hibernate.org" ) );
 		u.getEmailAddresses().add( new Email( "gavin.king@jboss.com" ) );
 		s.persist( u );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		User u2 = ( User ) s.createCriteria( User.class ).uniqueResult();
 		assertTrue( Hibernate.isInitialized( u2.getEmailAddresses() ) );
 		assertFalse( Hibernate.isInitialized( u2.getPermissions() ) );
 		assertEquals( u2.getEmailAddresses().size(), 2 );
 		s.delete( u2 );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testUpdateOrder() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		User u = new User( "gavin" );
 		u.getSessionData().put( "foo", "foo value" );
 		u.getSessionData().put( "bar", "bar value" );
 		u.getEmailAddresses().add( new Email( "gavin.king@jboss.com" ) );
 		u.getEmailAddresses().add( new Email( "gavin@hibernate.org" ) );
 		u.getEmailAddresses().add( new Email( "gavin@illflow.com" ) );
 		u.getEmailAddresses().add( new Email( "gavin@nospam.com" ) );
 		s.persist( u );
 		t.commit();
 		s.close();
 
 		u.getSessionData().clear();
 		u.getSessionData().put( "baz", "baz value" );
 		u.getSessionData().put( "bar", "bar value" );
 		u.getEmailAddresses().remove( 0 );
 		u.getEmailAddresses().remove( 2 );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( u );
 		t.commit();
 		s.close();
 
 		u.getSessionData().clear();
 		u.getEmailAddresses().add( 0, new Email( "gavin@nospam.com" ) );
 		u.getEmailAddresses().add( new Email( "gavin.king@jboss.com" ) );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( u );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete( u );
 		t.commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testValueMap() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		User u = new User( "gavin" );
 		u.getSessionData().put( "foo", "foo value" );
 		u.getSessionData().put( "bar", null );
 		u.getEmailAddresses().add( null );
 		u.getEmailAddresses().add( new Email( "gavin.king@jboss.com" ) );
 		u.getEmailAddresses().add( null );
 		u.getEmailAddresses().add( null );
 		s.persist( u );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		User u2 = ( User ) s.createCriteria( User.class ).uniqueResult();
 		assertFalse( Hibernate.isInitialized( u2.getSessionData() ) );
 		assertEquals( u2.getSessionData().size(), 1 );
 		assertEquals( u2.getEmailAddresses().size(), 2 );
 		u2.getSessionData().put( "foo", "new foo value" );
 		u2.getEmailAddresses().set( 1, new Email( "gavin@hibernate.org" ) );
 		//u2.getEmailAddresses().remove(3);
 		//u2.getEmailAddresses().remove(2);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		u2 = ( User ) s.createCriteria( User.class ).uniqueResult();
 		assertFalse( Hibernate.isInitialized( u2.getSessionData() ) );
 		assertEquals( u2.getSessionData().size(), 1 );
 		assertEquals( u2.getEmailAddresses().size(), 2 );
 		assertEquals( u2.getSessionData().get( "foo" ), "new foo value" );
 		assertEquals( ( ( Email ) u2.getEmailAddresses().get( 1 ) ).getAddress(), "gavin@hibernate.org" );
 		s.delete( u2 );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-3636" )
 	public void testCollectionInheritance() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Zoo zoo = new Zoo();
 		Mammal m = new Mammal();
 		m.setMammalName( "name1" );
 		m.setMammalName2( "name2" );
 		m.setMammalName3( "name3" );
 		m.setZoo( zoo );
 		zoo.getAnimals().add( m );
 		Long id = ( Long ) s.save( zoo );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Zoo found = ( Zoo ) s.get( Zoo.class, id );
 		found.getAnimals().size();
 		s.delete( found );
 		t.commit();
 		s.close();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/collection/original/Mammal.java b/hibernate-core/src/test/java/org/hibernate/test/collection/original/Mammal.java
index cb32431bab..c71a0ae175 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/collection/original/Mammal.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/collection/original/Mammal.java
@@ -1,35 +1,35 @@
 package org.hibernate.test.collection.original;
 
 
 public class Mammal extends Animal {
     private String mammalName;
     private String mammalName2;
     private String mammalName3;
 
 	public String getMammalName() {
 		return mammalName;
 	}
 
 	public void setMammalName(String mammalName) {
 		this.mammalName = mammalName;
 	}
 
 	public String getMammalName2() {
 		return mammalName2;
 	}
 
 	public void setMammalName2(String mammalName2) {
 		this.mammalName2 = mammalName2;
 	}
 
 	public String getMammalName3() {
 		return mammalName3;
 	}
 
 	public void setMammalName3(String mammalName3) {
 		this.mammalName3 = mammalName3;
 	}
 	
 	
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/collection/set/PersistentSetNonLazyTest.java b/hibernate-core/src/test/java/org/hibernate/test/collection/set/PersistentSetNonLazyTest.java
index cfa42457aa..4d49b0be70 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/collection/set/PersistentSetNonLazyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/collection/set/PersistentSetNonLazyTest.java
@@ -1,52 +1,52 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.collection.set;
 
 import org.junit.Test;
 
 import org.hibernate.testing.FailureExpected;
 
 /**
  * @author Gail Badner
  */
 public class PersistentSetNonLazyTest extends PersistentSetTest {
 	public String[] getMappings() {
 		return new String[] { "collection/set/MappingsNonLazy.hbm.xml" };
 	}
 
 	@Override
 	protected String getCacheConcurrencyStrategy() {
 		return "nonstrict-read-write";
 	}
 
 	@Test
 	@Override
 	@FailureExpected(
 			jiraKey = "unknown",
 			message = "known to fail with non-lazy collection using query cache"
 	)
 	public void testLoadChildCheckParentContainsChildCache() {
 		 super.testLoadChildCheckParentContainsChildCache();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/component/basic2/Name.java b/hibernate-core/src/test/java/org/hibernate/test/component/basic2/Name.java
index efaa422c37..a978625783 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/component/basic2/Name.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/component/basic2/Name.java
@@ -1,63 +1,63 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.component.basic2;
 
 import java.io.Serializable;
 import javax.persistence.Column;
 import javax.persistence.Embeddable;
 
 /**
  * @author Steve Ebersole
  */
 @Embeddable
 public class Name implements Serializable {
     private String firstName;
     private String lastName;
 
 	public Name() {
 	}
 
 	public Name(String firstName, String lastName) {
 		this.firstName = firstName;
 		this.lastName = lastName;
 	}
 
 	@Column(name = "FIRST_NAME", nullable = false)
 	public String getFirstName() {
 		return firstName;
 	}
 
 	public void setFirstName(String firstName) {
 		this.firstName = firstName;
 	}
 
 	@Column(name = "LAST_NAME", nullable = false)
 	public String getLastName() {
 		return lastName;
 	}
 
 	public void setLastName(String lastName) {
 		this.lastName = lastName;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/constraint/ConstraintTest.java b/hibernate-core/src/test/java/org/hibernate/test/constraint/ConstraintTest.java
index 0e33a4ff83..1f6d093c43 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/constraint/ConstraintTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/constraint/ConstraintTest.java
@@ -1,145 +1,145 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2012 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.test.constraint;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 import java.util.Iterator;
 
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OneToOne;
 import javax.persistence.Table;
 import javax.persistence.UniqueConstraint;
 
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.ForeignKey;
 import org.hibernate.mapping.UniqueKey;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.junit.Test;
 
 public class ConstraintTest extends BaseCoreFunctionalTestCase {
 	
 	private static final int MAX_NAME_LENGTH = 30;
 	
 	private static final String EXPLICIT_FK_NAME = "fk_explicit";
 	
 	private static final String EXPLICIT_UK_NAME = "uk_explicit";
 	
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] {
 				DataPoint.class, DataPoint2.class
 		};
 	}
 	
 	@Test
 	@TestForIssue( jiraKey = "HHH-7797" )
 	public void testUniqueConstraints() {
 		Column column = (Column) configuration().getClassMapping( DataPoint.class.getName() )
 				.getProperty( "foo1" ).getColumnIterator().next();
 		assertFalse( column.isNullable() );
 		assertTrue( column.isUnique() );
 
 		column = (Column) configuration().getClassMapping( DataPoint.class.getName() )
 				.getProperty( "foo2" ).getColumnIterator().next();
 		assertTrue( column.isNullable() );
 		assertTrue( column.isUnique() );
 
 		column = (Column) configuration().getClassMapping( DataPoint.class.getName() )
 				.getProperty( "id" ).getColumnIterator().next();
 		assertFalse( column.isNullable() );
 		assertTrue( column.isUnique() );
 	}
 	
 	@Test
 	@TestForIssue( jiraKey = "HHH-1904" )
 	public void testConstraintNameLength() {
 		Iterator<org.hibernate.mapping.Table> tableItr = configuration().getTableMappings();
 		while (tableItr.hasNext()) {
 			org.hibernate.mapping.Table table = tableItr.next();
 			
 			Iterator fkItr = table.getForeignKeyIterator();
 			while (fkItr.hasNext()) {
 				ForeignKey fk = (ForeignKey) fkItr.next();
 				assertTrue( fk.getName().length() <= MAX_NAME_LENGTH );
 				
 				// ensure the randomly generated constraint name doesn't
 				// happen if explicitly given
 				Column column = fk.getColumn( 0 );
 				if ( column.getName().equals( "explicit" ) ) {
 					assertEquals( fk.getName(), EXPLICIT_FK_NAME );
 				}
 			}
 			
 			Iterator ukItr = table.getUniqueKeyIterator();
 			while (ukItr.hasNext()) {
 				UniqueKey uk = (UniqueKey) ukItr.next();
 				assertTrue( uk.getName().length() <= MAX_NAME_LENGTH );
 				
 				// ensure the randomly generated constraint name doesn't
 				// happen if explicitly given
 				Column column = uk.getColumn( 0 );
 				if ( column.getName().equals( "explicit" ) ) {
 					assertEquals( uk.getName(), EXPLICIT_UK_NAME );
 				}
 			}
 		}
 	}
 	
 	@Entity
 	@Table( name = "DataPoint", uniqueConstraints = {
 			@UniqueConstraint( name = EXPLICIT_UK_NAME, columnNames = { "explicit" } )
 	} )
 	public static class DataPoint {
 		@Id
 		@GeneratedValue
 		@javax.persistence.Column( nullable = false, unique = true)
 		public long id;
 		
 		@javax.persistence.Column( nullable = false, unique = true)
 		public String foo1;
 		
 		@javax.persistence.Column( nullable = true, unique = true)
 		public String foo2;
 		
 		public String explicit;
 	}
 	
 	@Entity
 	@Table( name = "DataPoint2" )
 	public static class DataPoint2 {
 		@Id
 		@GeneratedValue
 		public long id;
 		
 		@OneToOne
 		public DataPoint dp;
 		
 		@OneToOne
 		@org.hibernate.annotations.ForeignKey(name = EXPLICIT_FK_NAME)
 		public DataPoint explicit;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/criteria/CourseMeeting.java b/hibernate-core/src/test/java/org/hibernate/test/criteria/CourseMeeting.java
index f544bce3a9..6b75bd9297 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/criteria/CourseMeeting.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/criteria/CourseMeeting.java
@@ -1,30 +1,30 @@
 package org.hibernate.test.criteria;
 
 
 /**
  * @author Gail Badner
  */
 public class CourseMeeting {
 	private CourseMeetingId id;
 	private Course course;
 
 	public CourseMeeting() {}
 
 	public CourseMeeting(Course course, String day, int period, String location) {
 		this.id = new CourseMeetingId( course, day, period, location );
 		this.course = course;
 	}
 
 	public CourseMeetingId getId() {
 		return id;
 	}
 	public void setId(CourseMeetingId id) {
 		this.id = id;
 	}
 	public  Course getCourse() {
 		return course;
 	}
 	public void setCourse(Course course) {
 		this.course = course;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/criteria/CourseMeetingId.java b/hibernate-core/src/test/java/org/hibernate/test/criteria/CourseMeetingId.java
index 595e11b541..1e97a8ad26 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/criteria/CourseMeetingId.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/criteria/CourseMeetingId.java
@@ -1,46 +1,46 @@
 package org.hibernate.test.criteria;
 import java.io.Serializable;
 
 /**
  * @author Gail Badner
  */
 public class CourseMeetingId implements Serializable {
 	private String courseCode;
 	private String day;
 	private int period;
 	private String location;
 
 	public CourseMeetingId() {}
 
 	public CourseMeetingId(Course course, String day, int period, String location) {
 		this.courseCode = course.getCourseCode();
 		this.day = day;
 		this.period = period;
 		this.location = location;
 	}
 
 	public String getCourseCode() {
 		return courseCode;
 	}
 	public void setCourseCode(String courseCode) {
 		this.courseCode = courseCode;
 	}
 	public String getDay() {
 		return day;
 	}
 	public void setDay(String day) {
 		this.day = day;
 	}
 	public int getPeriod() {
 		return period;
 	}
 	public void setPeriod(int period) {
 		this.period = period;
 	}
 	public String getLocation() {
 		return location;
 	}
 	public void setLocation(String location) {
 		this.location = location;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/criteria/Order.java b/hibernate-core/src/test/java/org/hibernate/test/criteria/Order.java
index 36be1dec3c..e6998e35de 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/criteria/Order.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/criteria/Order.java
@@ -1,52 +1,52 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.criteria;
 
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Set;
 
 public class Order {
 
   private int orderId;
 
   public int getOrderId() {
     return orderId;
   }
 
   private Set<OrderLine> orderLines = new HashSet<OrderLine>();
 
   public Set<OrderLine> getLines() {
     return Collections.unmodifiableSet(orderLines);
   }
 
   public void addLine(OrderLine orderLine){
     orderLine.setOrder(this);
     this.orderLines.add(orderLine);
   }
   
   public String toString() {
     return "" + getOrderId() + " - " + getLines();
   }
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/criteria/OrderLine.java b/hibernate-core/src/test/java/org/hibernate/test/criteria/OrderLine.java
index 77f35a7544..8af0d4a1b9 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/criteria/OrderLine.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/criteria/OrderLine.java
@@ -1,58 +1,58 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.criteria;
 
 public class OrderLine {
 
   private int lineId = 0;
   
   private Order order;
   
   private String articleId;
 
   
   public int getLineId() {
     return lineId;
   }
 
   public Order getOrder() {
     return order;
   }  
 
   public String getArticleId() {
     return articleId;
   }
 
   public void setOrder(Order order) {
     this.order = order;
   }
 
   public void setArticleId(String articleId) {
     this.articleId = articleId;
   }
   
   public String toString() {
     return "[" + getLineId() + ":" + getArticleId() + "]";
   }
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/criteria/OuterJoinCriteriaTest.java b/hibernate-core/src/test/java/org/hibernate/test/criteria/OuterJoinCriteriaTest.java
index de0e913dc8..e17e6a150a 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/criteria/OuterJoinCriteriaTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/criteria/OuterJoinCriteriaTest.java
@@ -1,428 +1,428 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.criteria;
 
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.junit.Test;
 
 import org.hibernate.Criteria;
 import org.hibernate.Session;
 import org.hibernate.criterion.Restrictions;
 import org.hibernate.sql.JoinFragment;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * @author Mattias Jiderhamn
  * @author Gail Badner
  */
 public class OuterJoinCriteriaTest extends BaseCoreFunctionalTestCase {
 	private Order order1;
 	private Order order2;
 	private Order order3;
 
 	@Override
 	public String[] getMappings() {
 		return new String[] { "criteria/Order.hbm.xml" };
 	}
 
 	@Test
 	public void testSubcriteriaWithNonNullRestrictions() {
 		Session s = openSession();
 		s.getTransaction().begin();
 
 		Criteria rootCriteria = s.createCriteria( Order.class );
 		Criteria subCriteria = rootCriteria.createCriteria( "orderLines", JoinFragment.LEFT_OUTER_JOIN );
 		assertNotSame( rootCriteria, subCriteria );
 
 		// add restrictions to subCriteria, ensuring we stay on subCriteria
 		assertSame( subCriteria, subCriteria.add( Restrictions.eq( "articleId", "3000" ) ) );
 
 		List orders = rootCriteria.list();
 
 		// order1 and order3 should be returned because each has articleId == "3000"
 		// both should have their full collection
 		assertEquals( 2, orders.size() );
 		for ( Iterator it = orders.iterator(); it.hasNext(); ) {
 			Order o = (Order) it.next();
 			if ( order1.getOrderId() == o.getOrderId() ) {
 				assertEquals( order1.getLines().size(), o.getLines().size() );
 			}
 			else if ( order3.getOrderId() == o.getOrderId() ) {
 				assertEquals( order3.getLines().size(), o.getLines().size() );
 			}
 			else {
 				fail( "unknown order" );
 			}
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSubcriteriaWithNonNullRestrictionsAliasToEntityMap() {
 		Session s = openSession();
 		s.getTransaction().begin();
 
 		Criteria rootCriteria = s.createCriteria( Order.class, "o" );
 		Criteria subCriteria = rootCriteria.createCriteria( "orderLines", "ol", JoinFragment.LEFT_OUTER_JOIN );
 		assertNotSame( rootCriteria, subCriteria );
 
 		// add restriction to subCriteria, ensuring we stay on subCriteria
 		assertSame( subCriteria, subCriteria.add( Restrictions.eq( "articleId", "3000" ) ) );
 
 		List orders = rootCriteria.setResultTransformer( Criteria.ALIAS_TO_ENTITY_MAP ).list();
 
 		// order1 and order3 should be returned because each has articleId == "3000";
 		// the orders should both should have their full collection;
 		assertEquals( 2, orders.size() );
 		for ( Iterator it = orders.iterator(); it.hasNext(); ) {
 			Map map = (Map) it.next();
 			Order o = ( Order ) map.get( "o" );
 		    // the orderLine returned from the map should have articleId = "3000"
 			OrderLine ol = ( OrderLine ) map.get( "ol" );
 			if ( order1.getOrderId() == o.getOrderId() ) {
 				assertEquals( order1.getLines().size(), o.getLines().size() );
 				assertEquals( "3000", ol.getArticleId() );
 			}
 			else if ( order3.getOrderId() == o.getOrderId() ) {
 				assertEquals( order3.getLines().size(), o.getLines().size() );
 				assertEquals( "3000", ol.getArticleId() );
 			}
 			else {
 				fail( "unknown order" );
 			}
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSubcriteriaWithNullOrNonNullRestrictions() {
 		Session s = openSession();
 		s.getTransaction().begin();
 
 		Criteria rootCriteria = s.createCriteria( Order.class );
 		Criteria subCriteria = rootCriteria.createCriteria( "orderLines", JoinFragment.LEFT_OUTER_JOIN );
 		assertNotSame( rootCriteria, subCriteria );
 
 		// add restrictions to subCriteria, ensuring we stay on subCriteria
 		// add restriction to subCriteria, ensuring we stay on subCriteria
 		assertSame(
 				subCriteria,
 				subCriteria.add(
 					Restrictions.or(
 							Restrictions.isNull( "articleId" ),		  // Allow null
 							Restrictions.eq( "articleId", "1000" )
 					)
 				)
 		);
 
 		List orders = rootCriteria.list();
 
 		// order1 should be returned because it has an orderline with articleId == "1000";
 		// order2 should be returned because it has no orderlines
 		assertEquals( 2, orders.size() );
 		for ( Iterator it = orders.iterator(); it.hasNext(); ) {
 			Order o = ( Order ) it.next();
 			if ( order1.getOrderId() == o.getOrderId() ) {
 				// o.getLines() should contain all of its orderLines
 				assertEquals( order1.getLines().size(), o.getLines().size() );
 			}
 			else if ( order2.getOrderId() == o.getOrderId() ) {
 				assertEquals( order2.getLines() , o.getLines() );
 				assertTrue( o.getLines().isEmpty() );
 			}
 			else {
 				fail( "unknown order" );
 			}
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSubcriteriaWithNullOrNonNullRestrictionsAliasToEntityMap() {
 		Session s = openSession();
 		s.getTransaction().begin();
 
 		Criteria rootCriteria = s.createCriteria( Order.class, "o" );
 		Criteria subCriteria = rootCriteria.createCriteria( "orderLines", "ol", JoinFragment.LEFT_OUTER_JOIN );
 		assertNotSame( rootCriteria, subCriteria );
 
 		// add restriction to subCriteria, ensuring we stay on subCriteria
 		assertSame(
 				subCriteria,
 				subCriteria.add(
 					Restrictions.or(
 							Restrictions.isNull( "ol.articleId" ),		  // Allow null
 							Restrictions.eq( "ol.articleId", "1000" )
 					)
 				)
 		);
 
 		List orders = rootCriteria.setResultTransformer( Criteria.ALIAS_TO_ENTITY_MAP ).list();
 
 		// order1 should be returned because it has an orderline with articleId == "1000";
 		// order2 should be returned because it has no orderlines
 		assertEquals( 2, orders.size() );
 		for ( Iterator it = orders.iterator(); it.hasNext(); ) {
 			Map map = (Map) it.next();
 			Order o = ( Order ) map.get( "o" );
 		    // the orderLine returned from the map should either be null or have articleId = "1000"
 			OrderLine ol = ( OrderLine ) map.get( "ol" );
 			if ( order1.getOrderId() == o.getOrderId() ) {
 				// o.getLines() should contain all of its orderLines
 				assertEquals( order1.getLines().size(), o.getLines().size() );
 				assertNotNull( ol );
 				assertEquals( "1000", ol.getArticleId() );
 			}
 			else if ( order2.getOrderId() == o.getOrderId() ) {
 				assertEquals( order2.getLines() , o.getLines() );
 				assertTrue( o.getLines().isEmpty() );
 				assertNull( ol );
 			}
 			else {
 				fail( "unknown order" );
 			}
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSubcriteriaWithClauseAliasToEntityMap() {
 		Session s = openSession();
 		s.getTransaction().begin();
 
 		Criteria rootCriteria = s.createCriteria( Order.class, "o" );
 		Criteria subCriteria = rootCriteria.createCriteria(
 				"orderLines",
 				"ol", JoinFragment.LEFT_OUTER_JOIN,
 				Restrictions.or(
 						Restrictions.isNull( "ol.articleId" ),		  // Allow null
 						Restrictions.eq( "ol.articleId", "1000" )
 				)
 		);
 		assertNotSame( rootCriteria, subCriteria );
 
 		List orders = rootCriteria.setResultTransformer( Criteria.ALIAS_TO_ENTITY_MAP ).list();
 
 		// all orders should be returned (via map.get( "o" )) with their full collections;
 		assertEquals( 3, orders.size() );
 		for ( Iterator it = orders.iterator(); it.hasNext(); ) {
 			Map map = ( Map ) it.next();
 			Order o = ( Order ) map.get( "o" );
 		    // the orderLine returned from the map should either be null or have articleId = "1000"
 			OrderLine ol = ( OrderLine ) map.get( "ol" );
 			if ( order1.getOrderId() == o.getOrderId() ) {
 				// o.getLines() should contain all of its orderLines
 				assertEquals( order1.getLines().size(), o.getLines().size() );
 				assertNotNull( ol );
 				assertEquals( "1000", ol.getArticleId() );
 			}
 			else if ( order2.getOrderId() == o.getOrderId() ) {
 				assertTrue( o.getLines().isEmpty() );
 				assertNull( ol );
 			}
 			else if ( order3.getOrderId() == o.getOrderId() ) {
 				assertEquals( order3.getLines().size(), o.getLines().size() );
 				assertNull( ol);
 			}
 			else {
 				fail( "unknown order" );
 			}
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testAliasWithNonNullRestrictions() {
 		Session s = openSession();
 		s.getTransaction().begin();
 
 		Criteria rootCriteria = s.createCriteria( Order.class );
 		// create alias, ensuring we stay on the root criteria
 		assertSame( rootCriteria, rootCriteria.createAlias( "orderLines", "ol", JoinFragment.LEFT_OUTER_JOIN ) );
 
 		// add restrictions to rootCriteria
 		assertSame( rootCriteria, rootCriteria.add( Restrictions.eq( "ol.articleId", "3000" ) ) );
 
 		List orders = rootCriteria.list();
 
 		// order1 and order3 should be returned because each has articleId == "3000"
 		// the contained collections should only have the orderLine with articleId == "3000"
 		assertEquals( 2, orders.size() );
 		for ( Iterator it = orders.iterator(); it.hasNext(); ) {
 			Order o = (Order) it.next();
 			if ( order1.getOrderId() == o.getOrderId() ) {
 				assertEquals( 1, o.getLines().size() );
 				assertEquals( "3000", o.getLines().iterator().next().getArticleId() );
 			}
 			else if ( order3.getOrderId() == o.getOrderId() ) {
 				assertEquals( 1, o.getLines().size() );
 				assertEquals( "3000", o.getLines().iterator().next().getArticleId() );
 			}
 			else {
 				fail( "unknown order" );
 			}
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testAliasWithNullOrNonNullRestrictions() {
 		Session s = openSession();
 		s.getTransaction().begin();
 
 		Criteria rootCriteria = s.createCriteria( Order.class );
 		// create alias, ensuring we stay on the root criteria
 		assertSame( rootCriteria, rootCriteria.createAlias( "orderLines", "ol", JoinFragment.LEFT_OUTER_JOIN ) );
 
 		// add restrictions to rootCriteria
 		assertSame(
 				rootCriteria,
 				rootCriteria.add(
 						Restrictions.or(
 								Restrictions.isNull( "ol.articleId" ),		  // Allow null
 								Restrictions.eq( "ol.articleId", "1000" )
 						)
 				)
 		);
 
 		List orders = rootCriteria.list();
 
 		// order1 should be returned because it has an orderline with articleId == "1000";
 		// the contained collection for order1 should only have the orderLine with articleId == "1000";
 		// order2 should be returned because it has no orderlines
 		assertEquals( 2, orders.size() );
 		for ( Object order : orders ) {
 			Order o = (Order) order;
 			if ( order1.getOrderId() == o.getOrderId() ) {
 				assertEquals( "1000", o.getLines().iterator().next().getArticleId() );
 			}
 			else if ( order2.getOrderId() == o.getOrderId() ) {
 				assertEquals( 0, o.getLines().size() );
 			}
 			else {
 				fail( "unknown order" );
 			}
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNonNullSubcriteriaRestrictionsOnRootCriteria() {
 		Session s = openSession();
 		s.getTransaction().begin();
 
 		Criteria rootCriteria = s.createCriteria( Order.class );
 		Criteria subCriteria = rootCriteria.createCriteria( "orderLines", "ol", JoinFragment.LEFT_OUTER_JOIN );
 		assertNotSame( rootCriteria, subCriteria );
 
 		// add restriction to rootCriteria (NOT subcriteria)
 		assertSame( rootCriteria, rootCriteria.add( Restrictions.eq( "ol.articleId", "3000" ) ) );
 
 		List orders = rootCriteria.list();
 
 		// results should be the same as testAliasWithNonNullRestrictions() (using Criteria.createAlias())
 		// order1 and order3 should be returned because each has articleId == "3000"
 		// the contained collections should only have the orderLine with articleId == "3000"
 		assertEquals( 2, orders.size() );
 		for ( Iterator it = orders.iterator(); it.hasNext(); ) {
 			Order o = (Order) it.next();
 			if ( order1.getOrderId() == o.getOrderId() ) {
 				assertEquals( 1, o.getLines().size() );
 				assertEquals( "3000", o.getLines().iterator().next().getArticleId() );
 			}
 			else if ( order3.getOrderId() == o.getOrderId() ) {
 				assertEquals( 1, o.getLines().size() );
 				assertEquals( "3000", o.getLines().iterator().next().getArticleId() );
 			}
 			else {
 				fail( "unknown order" );
 			}
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	protected void prepareTest() {
 		Session s = openSession();
 		s.getTransaction().begin();
 
 		// Order with one mathing line
 		order1 = new Order();
 		OrderLine line = new OrderLine();
 		line.setArticleId( "1000" );
 		order1.addLine( line );
 		line = new OrderLine();
 		line.setArticleId( "3000" );
 		order1.addLine( line );
 		s.persist( order1 );
 
 		// Order with no lines
 		order2 = new Order();
 		s.persist( order2 );
 
 		// Order with non-matching line
 		order3 = new Order();
 		line = new OrderLine();
 		line.setArticleId( "3000" );
 		order3.addLine( line );
 		s.persist( order3 );
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	protected void cleanupTest() {
 		Session s = openSession();
 		s.getTransaction().begin();
 
 		s.createQuery( "delete from OrderLine" ).executeUpdate();
 
 		s.createQuery( "delete from Order" ).executeUpdate();
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	private static boolean isBlank(String s) {
 		return s == null || s.trim().length() == 0;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/deletetransient/Note.java b/hibernate-core/src/test/java/org/hibernate/test/deletetransient/Note.java
index 62020f8472..31358e3ffc 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/deletetransient/Note.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/deletetransient/Note.java
@@ -1,34 +1,34 @@
 package org.hibernate.test.deletetransient;
 
 
 /**
  *
  * @author Gail Badner
  */
 public class Note {
 	private Long id;
 	private String description;
 
 	public Note() {
 	}
 
 	public Note(String description) {
 		this.description = description;
 	}
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public String getDescription() {
 		return description;
 	}
 
 	public void setDescription(String description) {
 		this.description = description;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/deletetransient/Suite.java b/hibernate-core/src/test/java/org/hibernate/test/deletetransient/Suite.java
index 8b80787475..9adc391a9f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/deletetransient/Suite.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/deletetransient/Suite.java
@@ -1,44 +1,44 @@
 package org.hibernate.test.deletetransient;
 import java.util.HashSet;
 import java.util.Set;
 
 /**
  *
  * @author Gail Badner
  */
 public class Suite {
 	private Long id;
 	private String location;
 	private Set notes = new HashSet();
 
 	public Suite() {
 	}
 
 	public Suite(String location) {
 		this.location = location;
 	}
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public String getLocation() {
 		return location;
 	}
 
 	public void setLocation(String location) {
 		this.location = location;
 	}
 
 	public Set getNotes() {
 		return notes;
 	}
 
 	public void setNotes(Set notes) {
 		this.notes = notes;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/SQLFunctionsInterSystemsTest.java b/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/SQLFunctionsInterSystemsTest.java
index 7ca70682c9..4e54f28b6f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/SQLFunctionsInterSystemsTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/dialect/functional/cache/SQLFunctionsInterSystemsTest.java
@@ -1,770 +1,760 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.dialect.functional.cache;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Date;
 import java.util.GregorianCalendar;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 import org.junit.Test;
 
 import org.hibernate.LockMode;
 import org.hibernate.Query;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.dialect.Cache71Dialect;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.jdbc.Work;
 import org.hibernate.test.legacy.Blobber;
 import org.hibernate.test.legacy.Broken;
 import org.hibernate.test.legacy.Fixed;
 import org.hibernate.test.legacy.Simple;
 import org.hibernate.test.legacy.Single;
 import org.hibernate.testing.RequiresDialect;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Tests for function support on CacheSQL...
  *
  * @author Jonathan Levinson
  */
 @RequiresDialect( value = Cache71Dialect.class )
 public class SQLFunctionsInterSystemsTest extends BaseCoreFunctionalTestCase {
 	private static final Logger log = Logger.getLogger( SQLFunctionsInterSystemsTest.class );
 
 	public String[] getMappings() {
 		return new String[] {
 				"legacy/AltSimple.hbm.xml",
 				"legacy/Broken.hbm.xml",
 				"legacy/Blobber.hbm.xml",
 				"dialect/functional/cache/TestInterSystemsFunctionsClass.hbm.xml"
 		};
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testDialectSQLFunctions() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Simple simple = new Simple( Long.valueOf( 10 ) );
 		simple.setName("Simple Dialect Function Test");
 		simple.setAddress("Simple Address");
 		simple.setPay(new Float(45.8));
 		simple.setCount(2);
 		s.save( simple );
 
 		// Test to make sure allocating an specified object operates correctly.
 		assertTrue(
 				s.createQuery( "select new org.hibernate.test.legacy.S(s.count, s.address) from Simple s" ).list().size() == 1
 		);
 
 		// Quick check the base dialect functions operate correctly
 		assertTrue(
 				s.createQuery( "select max(s.count) from Simple s" ).list().size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select count(*) from Simple s" ).list().size() == 1
 		);
 
 		List rset = s.createQuery( "select s.name, sysdate, floor(s.pay), round(s.pay,0) from Simple s" ).list();
 		assertNotNull("Name string should have been returned",(((Object[])rset.get(0))[0]));
 		assertNotNull("Todays Date should have been returned",(((Object[])rset.get(0))[1]));
 		assertEquals("floor(45.8) result was incorrect ", new Integer(45), ( (Object[]) rset.get(0) )[2] );
 		assertEquals("round(45.8) result was incorrect ", new Float(46), ( (Object[]) rset.get(0) )[3] );
 
 		simple.setPay(new Float(-45.8));
 		s.update(simple);
 
 		// Test type conversions while using nested functions (Float to Int).
 		rset = s.createQuery( "select abs(round(s.pay,0)) from Simple s" ).list();
 		assertEquals("abs(round(-45.8)) result was incorrect ", new Float(46), rset.get(0));
 
 		// Test a larger depth 3 function example - Not a useful combo other than for testing
 		assertTrue(
 				s.createQuery( "select floor(round(sysdate,1)) from Simple s" ).list().size() == 1
 		);
 
 		// Test the oracle standard NVL funtion as a test of multi-param functions...
 		simple.setPay(null);
 		s.update(simple);
 		Double value = (Double) s.createQuery("select mod( nvl(s.pay, 5000), 2 ) from Simple as s where s.id = 10").list().get(0);
 		assertTrue( 0 == value.intValue() );
 
 		// Test the hsql standard MOD funtion as a test of multi-param functions...
 		value = (Double) s.createQuery( "select MOD(s.count, 2) from Simple as s where s.id = 10" )
 				.list()
 				.get(0);
 		assertTrue( 0 == value.intValue() );
 
         s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing", "unchecked"})
 	public void testSetProperties() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf( 10 ) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		Query q = s.createQuery("from Simple s where s.name=:name and s.count=:count");
 		q.setProperties(simple);
 		assertTrue( q.list().get(0)==simple );
 		//misuse of "Single" as a propertyobject, but it was the first testclass i found with a collection ;)
 		Single single = new Single() { // trivial hack to test properties with arrays.
 			@SuppressWarnings( {"unchecked"})
 			String[] getStuff() { 
 				return (String[]) getSeveral().toArray(new String[getSeveral().size()]);
 			}
 		};
 
 		List l = new ArrayList();
 		l.add("Simple 1");
 		l.add("Slimeball");
 		single.setSeveral(l);
 		q = s.createQuery("from Simple s where s.name in (:several)");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 
 
 		q = s.createQuery("from Simple s where s.name in (:stuff)");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testBroken() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Broken b = new Fixed();
 		b.setId( Long.valueOf( 123 ));
 		b.setOtherId("foobar");
 		s.save(b);
 		s.flush();
 		b.setTimestamp( new Date() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update(b);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		b = (Broken) s.load( Broken.class, b );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete(b);
 		t.commit();
 		s.close();
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testNothinToUpdate() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testCachedQuery() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setCacheable(true);
 		q.setString("name", "Simple 1");
 		assertTrue( q.list().size()==1 );
 		simple = (Simple) q.list().get(0);
 
 		q.setString("name", "Simple 2");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		simple.setName("Simple 2");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setString("name", "Simple 2");
 		q.setCacheable(true);
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		t.commit();
 		s.close();
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testCachedQueryRegion() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString("name", "Simple 1");
 		assertTrue( q.list().size()==1 );
 		simple = (Simple) q.list().get(0);
 
 		q.setString("name", "Simple 2");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		simple.setName("Simple 2");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		t.commit();
 		s.close();
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing", "unchecked"})
 	public void testSQLFunctions() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save(simple );
 
 		s.createQuery( "from Simple s where repeat('foo', 3) = 'foofoofoo'" ).list();
 		s.createQuery( "from Simple s where repeat(s.name, 3) = 'foofoofoo'" ).list();
 		s.createQuery( "from Simple s where repeat( lower(s.name), (3 + (1-1)) / 2) = 'foofoofoo'" ).list();
 
 		assertTrue(
 				s.createQuery( "from Simple s where upper( s.name ) ='SIMPLE 1'" ).list().size()==1
 		);
 		assertTrue(
 				s.createQuery(
 						"from Simple s where not( upper( s.name ) ='yada' or 1=2 or 'foo'='bar' or not('foo'='foo') or 'foo' like 'bar' )"
 				).list()
 						.size()==1
 		);
 
 		assertTrue(
 				s.createQuery( "from Simple s where lower( s.name || ' foo' ) ='simple 1 foo'" ).list().size()==1
 		);
 		assertTrue(
 				s.createQuery( "from Simple s where lower( concat(s.name, ' foo') ) ='simple 1 foo'" ).list().size()==1
 		);
 
 		Simple other = new Simple( Long.valueOf(20) );
 		other.setName( "Simple 2" );
 		other.setCount( 12 );
 		simple.setOther( other );
 		s.save( other );
 		//s.find("from Simple s where s.name ## 'cat|rat|bag'");
 		assertTrue(
 				s.createQuery( "from Simple s where upper( s.other.name ) ='SIMPLE 2'" ).list().size()==1
 		);
 		assertTrue(
 				s.createQuery( "from Simple s where not ( upper( s.other.name ) ='SIMPLE 2' )" ).list().size()==0
 		);
 		assertTrue(
 				s.createQuery(
 						"select distinct s from Simple s where ( ( s.other.count + 3 ) = (15*2)/2 and s.count = 69) or ( ( s.other.count + 2 ) / 7 ) = 2"
 				).list()
 						.size()==1
 		);
 		assertTrue(
 				s.createQuery(
 						"select s from Simple s where ( ( s.other.count + 3 ) = (15*2)/2 and s.count = 69) or ( ( s.other.count + 2 ) / 7 ) = 2 order by s.other.count"
 				).list()
 						.size()==1
 		);
 		Simple min = new Simple( Long.valueOf(30) );
 		min.setCount( -1 );
 		s.save(min );
 
 		assertTrue(
 				s.createQuery( "from Simple s where s.count > ( select min(sim.count) from Simple sim )" )
 						.list()
 						.size()==2
 		);
 		t.commit();
 		t = s.beginTransaction();
 		assertTrue(
 				s.createQuery(
 						"from Simple s where s = some( select sim from Simple sim where sim.count>=0 ) and s.count >= 0"
 				).list()
 						.size()==2
 		);
 		assertTrue(
 				s.createQuery(
 						"from Simple s where s = some( select sim from Simple sim where sim.other.count=s.other.count ) and s.other.count > 0"
 				).list()
 						.size()==1
 		);
 
 		Iterator iter = s.createQuery( "select sum(s.count) from Simple s group by s.count having sum(s.count) > 10" )
 				.iterate();
 		assertTrue( iter.hasNext() );
 		assertEquals( Long.valueOf( 12 ), iter.next() );
 		assertTrue( !iter.hasNext() );
 		iter = s.createQuery( "select s.count from Simple s group by s.count having s.count = 12" ).iterate();
 		assertTrue( iter.hasNext() );
 
 		s.createQuery(
 				"select s.id, s.count, count(t), max(t.date) from Simple s, Simple t where s.count = t.count group by s.id, s.count order by s.count"
 		).iterate();
 
 		Query q = s.createQuery("from Simple s");
 		q.setMaxResults( 10 );
 		assertTrue( q.list().size()==3 );
 		q = s.createQuery("from Simple s");
 		q.setMaxResults( 1 );
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s");
 		assertTrue( q.list().size() == 3 );
 		q = s.createQuery("from Simple s where s.name = ?");
 		q.setString( 0, "Simple 1" );
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name = ? and upper(s.name) = ?");
 		q.setString(1, "SIMPLE 1");
 		q.setString( 0, "Simple 1" );
 		q.setFirstResult(0);
 		assertTrue( q.iterate().hasNext() );
 		q = s.createQuery("from Simple s where s.name = :foo and upper(s.name) = :bar or s.count=:count or s.count=:count + 1");
 		q.setParameter( "bar", "SIMPLE 1" );
 		q.setString( "foo", "Simple 1" );
 		q.setInteger("count", 69);
 		q.setFirstResult(0);
 		assertTrue( q.iterate().hasNext() );
 		q = s.createQuery("select s.id from Simple s");
 		q.setFirstResult(1);
 		q.setMaxResults( 2 );
 		iter = q.iterate();
 		int i=0;
 		while ( iter.hasNext() ) {
 			assertTrue( iter.next() instanceof Long );
 			i++;
 		}
 		assertTrue( i == 2 );
 		q = s.createQuery("select all s, s.other from Simple s where s = :s");
 		q.setParameter("s", simple);
 		assertTrue( q.list().size()==1 );
 
 
 		q = s.createQuery("from Simple s where s.name in (:name_list) and s.count > :count");
 		HashSet set = new HashSet();
 		set.add("Simple 1");
 		set.add("foo");
 		q.setParameterList( "name_list", set );
 		q.setParameter("count", new Integer(-1) );
 		assertTrue( q.list().size()==1 );
 
 		ScrollableResults sr = s.createQuery("from Simple s").scroll();
 		sr.next();
 		sr.get(0);
 		sr.close();
 
 		s.delete( other );
 		s.delete( simple );
 		s.delete( min );
 		t.commit();
 		s.close();
 
 	}
 
 	public void testBlobClob() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Blobber b = new Blobber();
 		b.setBlob( s.getLobHelper().createBlob( "foo/bar/baz".getBytes() ) );
 		b.setClob( s.getLobHelper().createClob("foo/bar/baz") );
 		s.save(b);
 		//s.refresh(b);
 		//assertTrue( b.getClob() instanceof ClobImpl );
 		s.flush();
 		s.refresh(b);
 		//b.getBlob().setBytes( 2, "abc".getBytes() );
         log.debug("levinson: just bfore b.getClob()");
         b.getClob().getSubString(2, 3);
 		//b.getClob().setString(2, "abc");
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		Blobber b2 = new Blobber();
 		s.save(b2);
 		b2.setBlob( b.getBlob() );
 		b.setBlob(null);
 		//assertTrue( b.getClob().getSubString(1, 3).equals("fab") );
 		b.getClob().getSubString(1, 6);
 		//b.getClob().setString(1, "qwerty");
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		b.setClob( s.getLobHelper().createClob("xcvfxvc xcvbx cvbx cvbx cvbxcvbxcvbxcvb") );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		assertTrue( b.getClob().getSubString(1, 7).equals("xcvfxvc") );
 		//b.getClob().setString(5, "1234567890");
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testSqlFunctionAsAlias() throws Exception {
 		String functionName = locateAppropriateDialectFunctionNameForAliasTest();
 		if (functionName == null) {
             log.info("Dialect does not list any no-arg functions");
 			return;
 		}
 
         log.info("Using function named [" + functionName + "] for 'function as alias' test");
 		String query = "select " + functionName + " from Simple as " + functionName + " where " + functionName + ".id = 10";
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List result = s.createQuery( query ).list();
 		assertTrue( result.size() == 1 );
 		assertTrue(result.get(0) instanceof Simple);
 		s.delete( result.get(0) );
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"ForLoopReplaceableByForEach"})
 	private String locateAppropriateDialectFunctionNameForAliasTest() {
 		for (Iterator itr = getDialect().getFunctions().entrySet().iterator(); itr.hasNext(); ) {
 			final Map.Entry entry = (Map.Entry) itr.next();
 			final SQLFunction function = (SQLFunction) entry.getValue();
 			if ( !function.hasArguments() && !function.hasParenthesesIfNoArguments() ) {
 				return (String) entry.getKey();
 			}
 		}
 		return null;
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testCachedQueryOnInsert() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s");
 		List list = q.setCacheable(true).list();
 		assertTrue( list.size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Simple simple2 = new Simple( Long.valueOf(12) );
 		simple2.setCount(133);
 		s.save( simple2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==2 );
 		for ( Object o : list ) {
 			s.delete( o );
 		}
 		t.commit();
 		s.close();
 
 	}
 
-    @SuppressWarnings( {"UnnecessaryBoxing", "UnnecessaryUnboxing"})
 	public void testInterSystemsFunctions() throws Exception {
         Calendar cal = new GregorianCalendar();
         cal.set(1977,6,3,0,0,0);
         java.sql.Timestamp testvalue = new java.sql.Timestamp(cal.getTimeInMillis());
         testvalue.setNanos(0);
         Calendar cal3 = new GregorianCalendar();
         cal3.set(1976,2,3,0,0,0);
         java.sql.Timestamp testvalue3 = new java.sql.Timestamp(cal3.getTimeInMillis());
         testvalue3.setNanos(0);
 
         final Session s = openSession();
         s.beginTransaction();
         try {
 			s.doWork(
 					new Work() {
 						@Override
 						public void execute(Connection connection) throws SQLException {
 							Statement stmt = ((SessionImplementor)s).getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().createStatement();
 							((SessionImplementor)s).getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().executeUpdate( stmt, "DROP FUNCTION spLock FROM TestInterSystemsFunctionsClass" );
 						}
 					}
 			);
         }
         catch (Exception ex) {
             System.out.println("as we expected stored procedure sp does not exist when we drop it");
 
         }
 		s.getTransaction().commit();
 
         s.beginTransaction();
 		s.doWork(
 				new Work() {
 					@Override
 					public void execute(Connection connection) throws SQLException {
 						Statement stmt = ((SessionImplementor)s).getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().createStatement();
 						String create_function = "CREATE FUNCTION SQLUser.TestInterSystemsFunctionsClass_spLock\n" +
 								"     ( INOUT pHandle %SQLProcContext, \n" +
 								"       ROWID INTEGER \n" +
 								" )\n" +
 								" FOR User.TestInterSystemsFunctionsClass " +
 								"    PROCEDURE\n" +
 								"    RETURNS INTEGER\n" +
 								"    LANGUAGE OBJECTSCRIPT\n" +
 								"    {\n" +
 								"        q 0\n" +
 								"     }";
 						((SessionImplementor)s).getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().executeUpdate( stmt, create_function );
 					}
 				}
 		);
         s.getTransaction().commit();
 
         s.beginTransaction();
 
         TestInterSystemsFunctionsClass object = new TestInterSystemsFunctionsClass( Long.valueOf( 10 ) );
         object.setDateText("1977-07-03");
         object.setDate1( testvalue );
         object.setDate3( testvalue3 );
         s.save( object );
         s.getTransaction().commit();
         s.close();
 
         Session s2 = openSession();
         s2.beginTransaction();
         TestInterSystemsFunctionsClass test = (TestInterSystemsFunctionsClass) s2.get(TestInterSystemsFunctionsClass.class, Long.valueOf(10));
         assertTrue( test.getDate1().equals(testvalue));
         test = (TestInterSystemsFunctionsClass) s2.get(TestInterSystemsFunctionsClass.class, Long.valueOf(10), LockMode.UPGRADE);
         assertTrue( test.getDate1().equals(testvalue));
         Date value = (Date) s2.createQuery( "select nvl(o.date,o.dateText) from TestInterSystemsFunctionsClass as o" )
 				.list()
 				.get(0);
         assertTrue( value.equals(testvalue));
         Object nv = s2.createQuery( "select nullif(o.dateText,o.dateText) from TestInterSystemsFunctionsClass as o" )
 				.list()
 				.get(0);
         assertTrue( nv == null);
         String dateText = (String) s2.createQuery(
 				"select nvl(o.dateText,o.date) from TestInterSystemsFunctionsClass as o"
 		).list()
 				.get(0);
         assertTrue( dateText.equals("1977-07-03"));
         value = (Date) s2.createQuery( "select ifnull(o.date,o.date1) from TestInterSystemsFunctionsClass as o" )
 				.list()
 				.get(0);
         assertTrue( value.equals(testvalue));
         value = (Date) s2.createQuery( "select ifnull(o.date3,o.date,o.date1) from TestInterSystemsFunctionsClass as o" )
 				.list()
 				.get(0);
         assertTrue( value.equals(testvalue));
         Integer pos = (Integer) s2.createQuery(
 				"select position('07', o.dateText) from TestInterSystemsFunctionsClass as o"
 		).list()
 				.get(0);
         assertTrue(pos.intValue() == 6);
         String st = (String) s2.createQuery( "select convert(o.date1, SQL_TIME) from TestInterSystemsFunctionsClass as o" )
 				.list()
 				.get(0);
         assertTrue( st.equals("00:00:00"));
         java.sql.Time tm = (java.sql.Time) s2.createQuery(
 				"select cast(o.date1, time) from TestInterSystemsFunctionsClass as o"
 		).list()
 				.get(0);
         assertTrue( tm.toString().equals("00:00:00"));
         Double diff = (Double) s2.createQuery(
 				"select timestampdiff(SQL_TSI_FRAC_SECOND, o.date3, o.date1) from TestInterSystemsFunctionsClass as o"
 		).list()
 				.get(0);
         assertTrue(diff.doubleValue() != 0.0);
         diff = (Double) s2.createQuery(
 				"select timestampdiff(SQL_TSI_MONTH, o.date3, o.date1) from TestInterSystemsFunctionsClass as o"
 		).list()
 				.get(0);
         assertTrue(diff.doubleValue() == 16.0);
         diff = (Double) s2.createQuery(
 				"select timestampdiff(SQL_TSI_WEEK, o.date3, o.date1) from TestInterSystemsFunctionsClass as o"
 		).list()
 				.get(0);
         assertTrue(diff.doubleValue() >= 16*4);
         diff = (Double) s2.createQuery(
 				"select timestampdiff(SQL_TSI_YEAR, o.date3, o.date1) from TestInterSystemsFunctionsClass as o"
 		).list()
 				.get(0);
         assertTrue(diff.doubleValue() == 1.0);
 
         s2.getTransaction().commit();
         s2.close();
     }
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/ImprovedTuplizerDynamicEntityTest.java b/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/ImprovedTuplizerDynamicEntityTest.java
index 362e7d6006..cb993c2e37 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/ImprovedTuplizerDynamicEntityTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/ImprovedTuplizerDynamicEntityTest.java
@@ -1,147 +1,147 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.dynamicentity.tuplizer2;
 
 import java.util.HashSet;
 
 import org.junit.Test;
 
 import org.hibernate.EntityMode;
 import org.hibernate.Hibernate;
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.test.dynamicentity.Address;
 import org.hibernate.test.dynamicentity.Company;
 import org.hibernate.test.dynamicentity.Customer;
 import org.hibernate.test.dynamicentity.Person;
 import org.hibernate.test.dynamicentity.ProxyHelper;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 
 /**
  * Demonstrates use of Tuplizers to allow the use of JDK
  * {@link java.lang.reflect.Proxy dynamic proxies} as our
  * domain model.
  * <p/>
  * Here we plug a custom Interceptor into the session simply to
  * allow us to not have to explicitly supply the appropriate entity
  * name to the Session calls.
  *
  * @author Steve Ebersole
  */
 public class ImprovedTuplizerDynamicEntityTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] { "dynamicentity/tuplizer2/Customer.hbm.xml" };
 	}
 
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.getEntityTuplizerFactory().registerDefaultTuplizerClass( EntityMode.POJO, MyEntityTuplizer.class );
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testIt() {
 		// Test saving these dyna-proxies
 		Session session = openSession();
 		session.beginTransaction();
 		Company company = ProxyHelper.newCompanyProxy();
 		company.setName( "acme" );
 		session.save( company );
 		Customer customer = ProxyHelper.newCustomerProxy();
 		customer.setName( "Steve" );
 		customer.setCompany( company );
 		Address address = ProxyHelper.newAddressProxy();
 		address.setStreet( "somewhere over the rainbow" );
 		address.setCity( "lawerence, kansas" );
 		address.setPostalCode( "toto");
 		customer.setAddress( address );
 		customer.setFamily( new HashSet() );
 		Person son = ProxyHelper.newPersonProxy();
 		son.setName( "son" );
 		customer.getFamily().add( son );
 		Person wife = ProxyHelper.newPersonProxy();
 		wife.setName( "wife" );
 		customer.getFamily().add( wife );
 		session.save( customer );
 		session.getTransaction().commit();
 		session.close();
 
 		assertNotNull( "company id not assigned", company.getId() );
 		assertNotNull( "customer id not assigned", customer.getId() );
 		assertNotNull( "address id not assigned", address.getId() );
 		assertNotNull( "son:Person id not assigned", son.getId() );
 		assertNotNull( "wife:Person id not assigned", wife.getId() );
 
 		// Test loading these dyna-proxies, along with flush processing
 		session = openSession();
 		session.beginTransaction();
 		customer = ( Customer ) session.load( Customer.class, customer.getId() );
 		assertFalse( "should-be-proxy was initialized", Hibernate.isInitialized( customer ) );
 
 		customer.setName( "other" );
 		session.flush();
 		assertFalse( "should-be-proxy was initialized", Hibernate.isInitialized( customer.getCompany() ) );
 
 		session.refresh( customer );
 		assertEquals( "name not updated", "other", customer.getName() );
 		assertEquals( "company association not correct", "acme", customer.getCompany().getName() );
 
 		session.getTransaction().commit();
 		session.close();
 
 		// Test detached entity re-attachment with these dyna-proxies
 		customer.setName( "Steve" );
 		session = openSession();
 		session.beginTransaction();
 		session.update( customer );
 		session.flush();
 		session.refresh( customer );
 		assertEquals( "name not updated", "Steve", customer.getName() );
 		session.getTransaction().commit();
 		session.close();
 
 		// Test querying
 		session = openSession();
 		session.beginTransaction();
 		int count = session.createQuery( "from Customer" ).list().size();
 		assertEquals( "querying dynamic entity", 1, count );
 		session.clear();
 		count = session.createQuery( "from Person" ).list().size();
 		assertEquals( "querying dynamic entity", 3, count );
 		session.getTransaction().commit();
 		session.close();
 
 		// test deleteing
 		session = openSession();
 		session.beginTransaction();
 		session.delete( company );
 		session.delete( customer );
 		session.getTransaction().commit();
 		session.close();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityInstantiator.java b/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityInstantiator.java
index 819745ad0e..ee0e80e64f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityInstantiator.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityInstantiator.java
@@ -1,78 +1,78 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.dynamicentity.tuplizer2;
 
 import java.io.Serializable;
 
 import org.hibernate.HibernateException;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.test.dynamicentity.Address;
 import org.hibernate.test.dynamicentity.Company;
 import org.hibernate.test.dynamicentity.Customer;
 import org.hibernate.test.dynamicentity.Person;
 import org.hibernate.test.dynamicentity.ProxyHelper;
 import org.hibernate.tuple.Instantiator;
 
 /**
  * @author Steve Ebersole
  */
 public class MyEntityInstantiator implements Instantiator {
 	private final String entityName;
 
 	public MyEntityInstantiator(String entityName) {
 		this.entityName = entityName;
 	}
 
 	public Object instantiate(Serializable id) {
 		if ( Person.class.getName().equals( entityName ) ) {
 			return ProxyHelper.newPersonProxy( id );
 		}
 		if ( Customer.class.getName().equals( entityName ) ) {
 			return ProxyHelper.newCustomerProxy( id );
 		}
 		else if ( Company.class.getName().equals( entityName ) ) {
 			return ProxyHelper.newCompanyProxy( id );
 		}
 		else if ( Address.class.getName().equals( entityName ) ) {
 			return ProxyHelper.newAddressProxy( id );
 		}
 		else {
 			throw new IllegalArgumentException( "unknown entity for instantiation [" + entityName + "]" );
 		}
 	}
 
 	public Object instantiate() {
 		return instantiate( null );
 	}
 
 	public boolean isInstance(Object object) {
 		try {
 			return ReflectHelper.classForName( entityName ).isInstance( object );
 		}
 		catch( Throwable t ) {
 			throw new HibernateException( "could not get handle to entity-name as interface : " + t );
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityTuplizer.java b/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityTuplizer.java
index 433919cfdd..80b971ab19 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityTuplizer.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/dynamicentity/tuplizer2/MyEntityTuplizer.java
@@ -1,91 +1,91 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.dynamicentity.tuplizer2;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.property.Getter;
 import org.hibernate.property.Setter;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.test.dynamicentity.ProxyHelper;
 import org.hibernate.test.dynamicentity.tuplizer.MyEntityInstantiator;
 import org.hibernate.tuple.Instantiator;
 import org.hibernate.tuple.entity.EntityMetamodel;
 import org.hibernate.tuple.entity.PojoEntityTuplizer;
 
 /**
  * @author Steve Ebersole
  */
 public class MyEntityTuplizer extends PojoEntityTuplizer {
 
 	public MyEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
 		super( entityMetamodel, mappedEntity );
 	}
 
 	public MyEntityTuplizer(EntityMetamodel entityMetamodel, EntityBinding mappedEntity) {
 		super( entityMetamodel, mappedEntity );
 	}
 
 	public EntityNameResolver[] getEntityNameResolvers() {
 		return new EntityNameResolver[] { MyEntityNameResolver.INSTANCE };
 	}
 
 	protected Instantiator buildInstantiator(PersistentClass persistentClass) {
 		return new MyEntityInstantiator( persistentClass.getEntityName() );
 	}
 
 	public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
 		String entityName = ProxyHelper.extractEntityName( entityInstance );
 		if ( entityName == null ) {
 			entityName = super.determineConcreteSubclassEntityName( entityInstance, factory );
 		}
 		return entityName;
 	}
 
 	protected ProxyFactory buildProxyFactory(PersistentClass persistentClass, Getter idGetter, Setter idSetter) {
 		// allows defining a custom proxy factory, which is responsible for
 		// generating lazy proxies for a given entity.
 		//
 		// Here we simply use the default...
 		return super.buildProxyFactory( persistentClass, idGetter, idSetter );
 	}
 
 	public static class MyEntityNameResolver implements EntityNameResolver {
 		public static final MyEntityNameResolver INSTANCE = new MyEntityNameResolver();
 
 		public String resolveEntityName(Object entity) {
 			return ProxyHelper.extractEntityName( entity );
 		}
 
 		public boolean equals(Object obj) {
 			return getClass().equals( obj.getClass() );
 		}
 
 		public int hashCode() {
 			return getClass().hashCode();
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/event/collection/BrokenCollectionEventTest.java b/hibernate-core/src/test/java/org/hibernate/test/event/collection/BrokenCollectionEventTest.java
index 6354edf4b0..5d659bf1df 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/event/collection/BrokenCollectionEventTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/event/collection/BrokenCollectionEventTest.java
@@ -1,337 +1,337 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.event.collection;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.collection.spi.PersistentCollection;
 import org.hibernate.event.spi.AbstractCollectionEvent;
 import org.hibernate.test.event.collection.association.bidirectional.manytomany.ChildWithBidirectionalManyToMany;
 import org.hibernate.test.event.collection.association.unidirectional.ParentWithCollectionOfEntities;
 import org.hibernate.testing.FailureExpected;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 
 /**
  * These tests are known to fail. When the functionality is corrected, the
  * corresponding method will be moved into AbstractCollectionEventTest.
  *
  * @author Gail Badner
  */
 public class BrokenCollectionEventTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "event/collection/association/unidirectional/onetomany/UnidirectionalOneToManySetMapping.hbm.xml" };
 	}
 
 	@Override
 	protected void cleanupTest() {
 		ParentWithCollection dummyParent = createParent( "dummyParent" );
 		dummyParent.setChildren( createCollection() );
 		Child dummyChild = dummyParent.addChild( "dummyChild" );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		List children = s.createCriteria( dummyChild.getClass() ).list();
 		List parents = s.createCriteria( dummyParent.getClass() ).list();
 		for ( Iterator it = parents.iterator(); it.hasNext(); ) {
 			ParentWithCollection parent = ( ParentWithCollection ) it.next();
 			parent.clearChildren();
 			s.delete( parent );
 		}
 		for ( Iterator it = children.iterator(); it.hasNext(); ) {
 			s.delete( it.next() );
 		}
 		tx.commit();
 		s.close();
 	}
 
 	public ParentWithCollection createParent(String name) {
 		return new ParentWithCollectionOfEntities( name );
 	}
 
 	public Collection createCollection() {
 		return new HashSet();
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "unknown" )
 	public void testUpdateDetachedParentNoChildrenToNull() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithNoChildren( "parent" );
 		listeners.clear();
 		assertEquals( 0, parent.getChildren().size() );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Collection oldCollection = parent.getChildren();
 		parent.newChildren( null );
 		s.update( parent );
 		tx.commit();
 		s.close();
 		int index = 0;
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
 		// pre- and post- collection recreate events should be created when updating an entity with a "null" collection
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}
 
 	// The following fails for the same reason as testUpdateDetachedParentNoChildrenToNullFailureExpected
 	// When that issue is fixed, this one should also be fixed and moved into AbstractCollectionEventTest.
 	/*
 	public void testUpdateDetachedParentOneChildToNullFailureExpected() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		Child oldChild = ( Child ) parent.getChildren().iterator().next();
 		assertEquals( 1, parent.getChildren().size() );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Collection oldCollection = parent.getChildren();
 		parent.newChildren( null );
 		s.update( parent );
 		tx.commit();
 		s.close();
 		int index = 0;
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
 		if ( oldChild instanceof ChildWithBidirectionalManyToMany ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) oldChild, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), ( ChildWithBidirectionalManyToMany ) oldChild, index++ );
 		}
 		// pre- and post- collection recreate events should be created when updating an entity with a "null" collection
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}
 	*/
 
 	@Test
 	@FailureExpected( jiraKey = "unknown" )
 	public void testSaveParentNullChildren() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithNullChildren( "parent" );
 		assertNull( parent.getChildren() );
 		int index = 0;
 		// pre- and post- collection recreate events should be created when creating an entity with a "null" collection
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		tx.commit();
 		s.close();
 		assertNotNull( parent.getChildren() );
 		checkNumberOfResults( listeners, 0 );
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "unknown" )
 	public void testUpdateParentNoChildrenToNull() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithNoChildren( "parent" );
 		listeners.clear();
 		assertEquals( 0, parent.getChildren().size() );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( ParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		Collection oldCollection = parent.getChildren();
 		parent.newChildren( null );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( (PersistentCollection) oldCollection ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, oldCollection, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
 		// pre- and post- collection recreate events should be created when updating an entity with a "null" collection
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}
 
 
 	// The following two tests fail for the same reason as testUpdateParentNoChildrenToNullFailureExpected
 	// When that issue is fixed, this one should also be fixed and moved into AbstractCollectionEventTest.
 	/*
 	public void testUpdateParentOneChildToNullFailureExpected() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		Child oldChild = ( Child ) parent.getChildren().iterator().next();
 		assertEquals( 1, parent.getChildren().size() );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( AbstractParentWithCollection ) s.get( parent.getClass(), parent.getId() );
 		if ( oldChild instanceof ChildEntity ) {
 			oldChild = ( Child ) s.get( oldChild.getClass(), ( ( ChildEntity ) oldChild ).getId() );
 		}
 		Collection oldCollection = parent.getChildren();
 		parent.newChildren( null );
 		tx.commit();
 		s.close();
 		int index = 0;
 		if ( ( ( PersistentCollection ) oldCollection ).wasInitialized() ) {
 			checkResult( listeners, listeners.getInitializeCollectionListener(), parent, oldCollection, index++ );
 		}
 		ChildWithBidirectionalManyToMany oldChildWithManyToMany = null;
 		if ( oldChild instanceof ChildWithBidirectionalManyToMany ) {
 			oldChildWithManyToMany = ( ChildWithBidirectionalManyToMany ) oldChild;
 			if ( ( ( PersistentCollection ) oldChildWithManyToMany.getParents() ).wasInitialized() ) {
 				checkResult( listeners, listeners.getInitializeCollectionListener(), oldChildWithManyToMany, index++ );
 			}
 		}
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
 		if ( oldChildWithManyToMany != null ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), oldChildWithManyToMany, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), oldChildWithManyToMany, index++ );
 		}
 		// pre- and post- collection recreate events should be created when updating an entity with a "null" collection
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}
 
 	public void testUpdateMergedParentOneChildToNullFailureExpected() {
 		CollectionListeners listeners = new CollectionListeners( sessionFactory() );
 		ParentWithCollection parent = createParentWithOneChild( "parent", "child" );
 		assertEquals( 1, parent.getChildren().size() );
 		listeners.clear();
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		parent = ( AbstractParentWithCollection ) s.merge( parent );
 		Collection oldCollection = parent.getChildren();
 		parent.newChildren( null );
 		tx.commit();
 		s.close();
 		int index = 0;
 		Child oldChild = ( Child ) oldCollection.iterator().next();
 		ChildWithBidirectionalManyToMany oldChildWithManyToMany = null;
 		if ( oldChild instanceof ChildWithBidirectionalManyToMany ) {
 			oldChildWithManyToMany = ( ChildWithBidirectionalManyToMany ) oldChild;
 			if ( ( ( PersistentCollection ) oldChildWithManyToMany.getParents() ).wasInitialized() ) {
 		}
 			checkResult( listeners, listeners.getInitializeCollectionListener(), oldChildWithManyToMany, index++ );
 		}
 		checkResult( listeners, listeners.getPreCollectionRemoveListener(), parent, oldCollection, index++ );
 		checkResult( listeners, listeners.getPostCollectionRemoveListener(), parent, oldCollection, index++ );
 		if ( oldChildWithManyToMany != null ) {
 			checkResult( listeners, listeners.getPreCollectionUpdateListener(), oldChildWithManyToMany, index++ );
 			checkResult( listeners, listeners.getPostCollectionUpdateListener(), oldChildWithManyToMany, index++ );
 		}
 		// pre- and post- collection recreate events should be created when updating an entity with a "null" collection
 		checkResult( listeners, listeners.getPreCollectionRecreateListener(), parent, index++ );
 		checkResult( listeners, listeners.getPostCollectionRecreateListener(), parent, index++ );
 		checkNumberOfResults( listeners, index );
 	}	
 	*/
 
 	private ParentWithCollection createParentWithNullChildren(String parentName) {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		ParentWithCollection parent = createParent( parentName );
 		s.save( parent );
 		tx.commit();
 		s.close();
 		return parent;
 	}
 
 	private ParentWithCollection createParentWithNoChildren(String parentName) {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		ParentWithCollection parent = createParent( parentName );
 		parent.setChildren( createCollection() );
 		s.save( parent );
 		tx.commit();
 		s.close();
 		return parent;
 	}
 
 	private ParentWithCollection createParentWithOneChild(String parentName, String ChildName) {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		ParentWithCollection parent = createParent( parentName );
 		parent.setChildren( createCollection() );
 		parent.addChild( ChildName );
 		s.save( parent );
 		tx.commit();
 		s.close();
 		return parent;
 	}
 
 	protected void checkResult(CollectionListeners listeners,
 							 CollectionListeners.Listener listenerExpected,
 							 ParentWithCollection parent,
 							 int index) {
 		checkResult( listeners, listenerExpected, parent, parent.getChildren(), index );
 	}
 	protected void checkResult(CollectionListeners listeners,
 							 CollectionListeners.Listener listenerExpected,
 							 ChildWithBidirectionalManyToMany child,
 							 int index) {
 		checkResult( listeners, listenerExpected, child, child.getParents(), index );
 	}
 
 	protected void checkResult(CollectionListeners listeners,
 							 CollectionListeners.Listener listenerExpected,
 							 Entity ownerExpected,
 							 Collection collExpected,
 							 int index) {
 		assertSame( listenerExpected, listeners.getListenersCalled().get( index ) );
 		assertSame(
 				ownerExpected,
 				( ( AbstractCollectionEvent ) listeners.getEvents().get( index ) ).getAffectedOwnerOrNull()
 		);
 		assertEquals(
 				ownerExpected.getId(),
 				( ( AbstractCollectionEvent ) listeners.getEvents().get( index ) ).getAffectedOwnerIdOrNull()
 		);
 		assertEquals(
 				ownerExpected.getClass().getName(),
 				( (AbstractCollectionEvent) listeners.getEvents().get( index ) ).getAffectedOwnerEntityName()
 		);
 		assertSame(
 				collExpected, ( ( AbstractCollectionEvent ) listeners.getEvents().get( index ) ).getCollection()
 		);
 	}
 
 	private void checkNumberOfResults(CollectionListeners listeners, int nEventsExpected) {
 		assertEquals( nEventsExpected, listeners.getListenersCalled().size() );
 		assertEquals( nEventsExpected, listeners.getEvents().size() );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/event/collection/association/bidirectional/onetomany/BidirectionalOneToManyBagCollectionEventTest.java b/hibernate-core/src/test/java/org/hibernate/test/event/collection/association/bidirectional/onetomany/BidirectionalOneToManyBagCollectionEventTest.java
index f3f82918b2..b9b4959952 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/event/collection/association/bidirectional/onetomany/BidirectionalOneToManyBagCollectionEventTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/event/collection/association/bidirectional/onetomany/BidirectionalOneToManyBagCollectionEventTest.java
@@ -1,55 +1,55 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.event.collection.association.bidirectional.onetomany;
 import java.util.ArrayList;
 import java.util.Collection;
 
 import org.hibernate.test.event.collection.Child;
 import org.hibernate.test.event.collection.ParentWithCollection;
 import org.hibernate.test.event.collection.association.AbstractAssociationCollectionEventTest;
 
 /**
  *
  * @author Gail Badner
  */
 public class BidirectionalOneToManyBagCollectionEventTest extends AbstractAssociationCollectionEventTest {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "event/collection/association/bidirectional/onetomany/BidirectionalOneToManyBagMapping.hbm.xml" };
 	}
 
 	@Override
 	public ParentWithCollection createParent(String name) {
 		return new ParentWithBidirectionalOneToMany( name );
 	}
 
 	@Override
 	public Collection createCollection() {
 		return new ArrayList();
 	}
 
 	public Child createChild(String name) {
 		return new ChildWithManyToOne( name );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/event/collection/association/bidirectional/onetomany/BidirectionalOneToManyBagSubclassCollectionEventTest.java b/hibernate-core/src/test/java/org/hibernate/test/event/collection/association/bidirectional/onetomany/BidirectionalOneToManyBagSubclassCollectionEventTest.java
index 463f7cdb80..abfaccf928 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/event/collection/association/bidirectional/onetomany/BidirectionalOneToManyBagSubclassCollectionEventTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/event/collection/association/bidirectional/onetomany/BidirectionalOneToManyBagSubclassCollectionEventTest.java
@@ -1,41 +1,41 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.event.collection.association.bidirectional.onetomany;
 
 import org.hibernate.test.event.collection.ParentWithCollection;
 
 /**
  * @author Gail Badner
  */
 public class BidirectionalOneToManyBagSubclassCollectionEventTest extends BidirectionalOneToManyBagCollectionEventTest {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "event/collection/association/bidirectional/onetomany/BidirectionalOneToManyBagSubclassMapping.hbm.xml" };
 	}
 
 	@Override
 	public ParentWithCollection createParent(String name) {
 		return new ParentWithBidirectionalOneToManySubclass( name );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/event/collection/association/bidirectional/onetomany/ParentWithBidirectionalOneToManySubclass.java b/hibernate-core/src/test/java/org/hibernate/test/event/collection/association/bidirectional/onetomany/ParentWithBidirectionalOneToManySubclass.java
index 7f0be1b4c6..d819917544 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/event/collection/association/bidirectional/onetomany/ParentWithBidirectionalOneToManySubclass.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/event/collection/association/bidirectional/onetomany/ParentWithBidirectionalOneToManySubclass.java
@@ -1,38 +1,38 @@
 //$Id: $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution statements
  * applied by the authors.
  *
  * All third-party contributions are distributed under license by Red Hat
  * Middleware LLC.  This copyrighted material is made available to anyone
  * wishing to use, modify, copy, or redistribute it subject to the terms
  * and conditions of the GNU Lesser General Public License, as published by
  * the Free Software Foundation.  This program is distributed in the hope
  * that it will be useful, but WITHOUT ANY WARRANTY; without even the
  * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  *
  * See the GNU Lesser General Public License for more details.  You should
  * have received a copy of the GNU Lesser General Public License along with
  * this distribution; if not, write to: Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.event.collection.association.bidirectional.onetomany;
 
 
 
 /**
  *
  * @author Gail Badner
  */
 public class ParentWithBidirectionalOneToManySubclass extends ParentWithBidirectionalOneToMany {
 	public ParentWithBidirectionalOneToManySubclass() {
 	}
 
 	public ParentWithBidirectionalOneToManySubclass(String name) {
 		super( name );
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/event/collection/values/ParentWithCollectionOfValues.java b/hibernate-core/src/test/java/org/hibernate/test/event/collection/values/ParentWithCollectionOfValues.java
index 5532b3bc4f..903bf275cd 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/event/collection/values/ParentWithCollectionOfValues.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/event/collection/values/ParentWithCollectionOfValues.java
@@ -1,42 +1,42 @@
 //$Id: $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution statements
  * applied by the authors.
  *
  * All third-party contributions are distributed under license by Red Hat
  * Middleware LLC.  This copyrighted material is made available to anyone
  * wishing to use, modify, copy, or redistribute it subject to the terms
  * and conditions of the GNU Lesser General Public License, as published by
  * the Free Software Foundation.  This program is distributed in the hope
  * that it will be useful, but WITHOUT ANY WARRANTY; without even the
  * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  *
  * See the GNU Lesser General Public License for more details.  You should
  * have received a copy of the GNU Lesser General Public License along with
  * this distribution; if not, write to: Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.event.collection.values;
 import org.hibernate.test.event.collection.AbstractParentWithCollection;
 import org.hibernate.test.event.collection.Child;
 import org.hibernate.test.event.collection.ChildValue;
 
 /**
  *
  * @author Gail Badner
  */
 public class ParentWithCollectionOfValues extends AbstractParentWithCollection {
 	public ParentWithCollectionOfValues() {
 	}
 
 	public ParentWithCollectionOfValues(String name) {
 		super( name );
 	}
 	
 	public Child createChild(String name) {
 		return new ChildValue( name );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/filter/hql/JoinedFilteredBulkManipulationTest.java b/hibernate-core/src/test/java/org/hibernate/test/filter/hql/JoinedFilteredBulkManipulationTest.java
index c36ddcab0f..7494fa5e64 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/filter/hql/JoinedFilteredBulkManipulationTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/filter/hql/JoinedFilteredBulkManipulationTest.java
@@ -1,216 +1,210 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.filter.hql;
 import java.util.Date;
 
 import org.hibernate.dialect.CUBRIDDialect;
 import org.hibernate.testing.SkipForDialect;
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Steve Ebersole
  */
 @SkipForDialect(
         value = CUBRIDDialect.class,
         comment = "As of verion 8.4.1 CUBRID doesn't support temporary tables. This test fails with" +
                 "HibernateException: cannot doAfterTransactionCompletion multi-table deletes using dialect not supporting temp tables"
 )
 public class JoinedFilteredBulkManipulationTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] {
 			"filter/hql/filter-defs.hbm.xml",
 			"filter/hql/Joined.hbm.xml"
 		};
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testFilteredJoinedSubclassHqlDeleteRoot() {
 		Session s = openSession();
 		s.beginTransaction();
 		s.save( new Employee( "John", 'M', "john", new Date() ) );
 		s.save( new Employee( "Jane", 'F', "jane", new Date() ) );
 		s.save( new Customer( "Charlie", 'M', "charlie", "Acme" ) );
 		s.save( new Customer( "Wanda", 'F', "wanda", "ABC" ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.enableFilter( "sex" ).setParameter( "sexCode", Character.valueOf( 'M' ) );
 		int count = s.createQuery( "delete Person" ).executeUpdate();
 		assertEquals( 2, count );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete Person" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testFilteredJoinedSubclassHqlDeleteNonLeaf() {
 		Session s = openSession();
 		s.beginTransaction();
 		s.save( new Employee( "John", 'M', "john", new Date() ) );
 		s.save( new Employee( "Jane", 'F', "jane", new Date() ) );
 		s.save( new Customer( "Charlie", 'M', "charlie", "Acme" ) );
 		s.save( new Customer( "Wanda", 'F', "wanda", "ABC" ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.enableFilter( "sex" ).setParameter( "sexCode", Character.valueOf( 'M' ) );
 		int count = s.createQuery( "delete User" ).executeUpdate();
 		assertEquals( 2, count );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete Person" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testFilteredJoinedSubclassHqlDeleteLeaf() {
 		Session s = openSession();
 		s.beginTransaction();
 		s.save( new Employee( "John", 'M', "john", new Date() ) );
 		s.save( new Employee( "Jane", 'F', "jane", new Date() ) );
 		s.save( new Customer( "Charlie", 'M', "charlie", "Acme" ) );
 		s.save( new Customer( "Wanda", 'F', "wanda", "ABC" ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.enableFilter( "sex" ).setParameter( "sexCode", Character.valueOf( 'M' ) );
 		int count = s.createQuery( "delete Employee" ).executeUpdate();
 		assertEquals( 1, count );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete Person" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testFilteredJoinedSubclassHqlUpdateRoot() {
 		Session s = openSession();
 		s.beginTransaction();
 		s.save( new Employee( "John", 'M', "john", new Date() ) );
 		s.save( new Employee( "Jane", 'F', "jane", new Date() ) );
 		s.save( new Customer( "Charlie", 'M', "charlie", "Acme" ) );
 		s.save( new Customer( "Wanda", 'F', "wanda", "ABC" ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.enableFilter( "sex" ).setParameter( "sexCode", Character.valueOf( 'M' ) );
 		int count = s.createQuery( "update Person p set p.name = '<male>'" ).executeUpdate();
 		assertEquals( 2, count );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete Person" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testFilteredJoinedSubclassHqlUpdateNonLeaf() {
 		Session s = openSession();
 		s.beginTransaction();
 		s.save( new Employee( "John", 'M', "john", new Date() ) );
 		s.save( new Employee( "Jane", 'F', "jane", new Date() ) );
 		s.save( new Customer( "Charlie", 'M', "charlie", "Acme" ) );
 		s.save( new Customer( "Wanda", 'F', "wanda", "ABC" ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.enableFilter( "sex" ).setParameter( "sexCode", Character.valueOf( 'M' ) );
 		int count = s.createQuery( "update User u set u.username = :un where u.name = :n" )
 				.setString( "un", "charlie" )
 				.setString( "n", "Wanda" )
 				.executeUpdate();
 		assertEquals( 0, count );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete Person" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testFilteredJoinedSubclassHqlUpdateLeaf() {
 		Session s = openSession();
 		s.beginTransaction();
 		s.save( new Employee( "John", 'M', "john", new Date() ) );
 		s.save( new Employee( "Jane", 'F', "jane", new Date() ) );
 		s.save( new Customer( "Charlie", 'M', "charlie", "Acme" ) );
 		s.save( new Customer( "Wanda", 'F', "wanda", "ABC" ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.enableFilter( "sex" ).setParameter( "sexCode", Character.valueOf( 'M' ) );
 		int count = s.createQuery( "update Customer c set c.company = 'XYZ'" ).executeUpdate();
 		assertEquals( 1, count );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete Person" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/generated/PartiallyGeneratedComponentTest.java b/hibernate-core/src/test/java/org/hibernate/test/generated/PartiallyGeneratedComponentTest.java
index dd481f692d..838e26d5a1 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/generated/PartiallyGeneratedComponentTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/generated/PartiallyGeneratedComponentTest.java
@@ -1,80 +1,80 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.generated;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.dialect.Oracle9iDialect;
 import org.hibernate.testing.RequiresDialect;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 
 /**
  * {@inheritDoc}
  *
  * @author Steve Ebersole
  */
 @RequiresDialect( Oracle9iDialect.class )
 public class PartiallyGeneratedComponentTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] { "generated/ComponentOwner.hbm.xml" };
 	}
 
 	@Test
 	public void testPartialComponentGeneration() {
 		ComponentOwner owner = new ComponentOwner( "initial" );
 		Session s = openSession();
 		s.beginTransaction();
 		s.save( owner );
 		s.getTransaction().commit();
 		s.close();
 
 		assertNotNull( "expecting insert value generation", owner.getComponent() );
 		int previousValue = owner.getComponent().getGenerated();
 		assertFalse( "expecting insert value generation", 0 == previousValue );
 
 		s = openSession();
 		s.beginTransaction();
 		owner = ( ComponentOwner ) s.get( ComponentOwner.class, owner.getId() );
 		assertEquals( "expecting insert value generation", previousValue, owner.getComponent().getGenerated() );
 		owner.setName( "subsequent" );
 		s.getTransaction().commit();
 		s.close();
 
 		assertNotNull( owner.getComponent() );
 		previousValue = owner.getComponent().getGenerated();
 
 		s = openSession();
 		s.beginTransaction();
 		owner = ( ComponentOwner ) s.get( ComponentOwner.class, owner.getId() );
 		assertEquals( "expecting update value generation", previousValue, owner.getComponent().getGenerated() );
 		s.delete( owner );
 		s.getTransaction().commit();
 		s.close();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingOrderByTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingOrderByTest.java
index da291a03d4..83ab99f135 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingOrderByTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingOrderByTest.java
@@ -1,702 +1,702 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory;
 import org.hibernate.testing.FailureExpected;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Tests AST parser processing of ORDER BY clauses.
  *
  * @author Gail Badner
  */
 public class ASTParserLoadingOrderByTest extends BaseCoreFunctionalTestCase {
 	StateProvince stateProvince;
 	private Zoo zoo1;
 	private Zoo zoo2;
 	private Zoo zoo3;
 	private Zoo zoo4;
 	Set<Zoo> zoosWithSameName;
 	Set<Zoo> zoosWithSameAddress;
 	Mammal zoo1Mammal1;
 	Mammal zoo1Mammal2;
 	Human zoo2Director1;
 	Human zoo2Director2;
 
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 				"hql/Animal.hbm.xml",
 		};
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.USE_QUERY_CACHE, "false" );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 		cfg.setProperty( Environment.QUERY_TRANSLATOR, ASTQueryTranslatorFactory.class.getName() );
 	}
 
 	private void createData() {
 		stateProvince = new StateProvince();
 		stateProvince.setName( "IL" );
 
 	    zoo1 = new Zoo();
 		zoo1.setName( "Zoo" );
 		Address address1 = new Address();
 		address1.setStreet( "1313 Mockingbird Lane" );
 		address1.setCity( "Anywhere" );
 		address1.setStateProvince( stateProvince );
 		address1.setCountry( "USA" );
 		zoo1.setAddress( address1 );
 		zoo1Mammal1 = new Mammal();
 		zoo1Mammal1.setDescription( "zoo1Mammal1" );
 		zoo1Mammal1.setZoo( zoo1 );
 		zoo1.getMammals().put( "type1", zoo1Mammal1);
 		zoo1Mammal2 = new Mammal();
 		zoo1Mammal2.setDescription( "zoo1Mammal2" );
 		zoo1Mammal2.setZoo( zoo1 );
 		zoo1.getMammals().put( "type1", zoo1Mammal2);
 
 		zoo2 = new Zoo();
 		zoo2.setName( "A Zoo" );
 		Address address2 = new Address();
 		address2.setStreet( "1313 Mockingbird Lane" );
 		address2.setCity( "Anywhere" );
 		address2.setStateProvince( stateProvince );
 		address2.setCountry( "USA" );
 		zoo2.setAddress( address2 );
 		zoo2Director1 = new Human();
 		zoo2Director1.setName( new Name( "Duh", 'A', "Man" ) );
 		zoo2Director2 = new Human();
 		zoo2Director2.setName( new Name( "Fat", 'A', "Cat" ) );
 		zoo2.getDirectors().put( "Head Honcho", zoo2Director1 );
 		zoo2.getDirectors().put( "Asst. Head Honcho", zoo2Director2 );		
 
 		zoo3 = new Zoo();
 		zoo3.setName( "Zoo" );
 		Address address3 = new Address();
 		address3.setStreet( "1312 Mockingbird Lane" );
 		address3.setCity( "Anywhere" );
 		address3.setStateProvince( stateProvince );
 		address3.setCountry( "USA" );
 		zoo3.setAddress( address3 );
 
 		zoo4 = new Zoo();
 		zoo4.setName( "Duh Zoo" );
 		Address address4 = new Address();
 		address4.setStreet( "1312 Mockingbird Lane" );
 		address4.setCity( "Nowhere" );
 		address4.setStateProvince( stateProvince );
 		address4.setCountry( "USA" );
 		zoo4.setAddress( address4 );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.save( stateProvince );
 		s.save( zoo1Mammal1 );
 		s.save( zoo1Mammal2 );
 		s.save( zoo1 );
 		s.save( zoo2Director1 );
 		s.save( zoo2Director2 );
 		s.save( zoo2 );
 		s.save( zoo3 );
 		s.save( zoo4 );
 		t.commit();
 		s.close();
 
 		zoosWithSameName = new HashSet<Zoo>( 2 );
 		zoosWithSameName.add( zoo1 );
 		zoosWithSameName.add( zoo3 );
 		zoosWithSameAddress = new HashSet<Zoo>( 2 );
 		zoosWithSameAddress.add( zoo1 );
 		zoosWithSameAddress.add( zoo2 );
 	}
 
 	private void cleanupData() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		if ( zoo1 != null ) {
 			s.delete( zoo1 );
 			zoo1 = null;
 		}
 		if ( zoo2 != null ) {
 			s.delete( zoo2 );
 			zoo2 = null;
 		}
 		if ( zoo3 != null ) {
 			s.delete( zoo3 );
 			zoo3 = null;
 		}
 		if ( zoo4 != null ) {
 			s.delete( zoo4 );
 			zoo4 = null;
 		}
 		if ( zoo1Mammal1 != null ) {
 			s.delete( zoo1Mammal1 );
 			zoo1Mammal1 = null;
 		}
 		if ( zoo1Mammal2 != null ) {
 			s.delete( zoo1Mammal2 );
 			zoo1Mammal2 = null;
 		}
 		if ( zoo2Director1 != null ) {
 			s.delete( zoo2Director1 );
 			zoo2Director1 = null;
 		}
 		if ( zoo2Director2 != null ) {
 			s.delete( zoo2Director2 );
 			zoo2Director2 = null;			
 		}
 		if ( stateProvince != null ) {
 			s.delete( stateProvince );
 		}
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testOrderByOnJoinedSubclassPropertyWhoseColumnIsNotInDrivingTable() {
 		// this is simply a syntax check
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.createQuery( "from Human h order by h.bodyWeight" ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testOrderByNoSelectAliasRef() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by name, address:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select name, address from Zoo order by name, address"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address from Zoo z order by z.name, z.address"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z2.name, z2.address from Zoo z2 where z2.name in ( select name from Zoo ) order by z2.name, z2.address"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		// using ASC
 		checkTestOrderByResults(
 				s.createQuery(
 						"select name, address from Zoo order by name ASC, address ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address from Zoo z order by z.name ASC, z.address ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z2.name, z2.address from Zoo z2 where z2.name in ( select name from Zoo ) order by z2.name ASC, z2.address ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 
 		// ordered by address, name:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address from Zoo z order by z.address, z.name"
 				).list(),
 				zoo3, zoo4, zoo2, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select name, address from Zoo order by address, name"
 				).list(),
 				zoo3, zoo4, zoo2, zoo1, null
 		);
 
 		// ordered by address:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		// unordered:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address from Zoo z order by z.address"
 				).list(),
 				zoo3, zoo4, null, null, zoosWithSameAddress
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select name, address from Zoo order by address"
 				).list(),
 				zoo3, zoo4, null, null, zoosWithSameAddress
 		);
 
 		// ordered by name:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		// unordered:
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address from Zoo z order by z.name"
 				).list(),
 				zoo2, zoo4, null, null, zoosWithSameName
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select name, address from Zoo order by name"
 				).list(),
 				zoo2, zoo4, null, null, zoosWithSameName
 		);
 		t.commit();
 		s.close();
 
 		cleanupData();
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "unknown" )
 	public void testOrderByComponentDescNoSelectAliasRef() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by address DESC, name DESC:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address from Zoo z order by z.address DESC, z.name DESC"
 				).list(),
 				zoo1, zoo2, zoo4, zoo3, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select name, address from Zoo order by address DESC, name DESC"
 				).list(),
 				zoo1, zoo2, zoo4, zoo3, null
 		);
 		t.commit();
 		s.close();
 		cleanupData();
 	}
 
 	@Test
 	public void testOrderBySelectAliasRef() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by name, address:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z2.name as zname, z2.address as zooAddress from Zoo z2 where z2.name in ( select name from Zoo ) order by zname, zooAddress"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as name, z.address as address from Zoo z order by name, address"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as zooName, z.address as zooAddress from Zoo z order by zooName, zooAddress"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address as name from Zoo z order by z.name, name"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address as name from Zoo z order by z.name, name"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		// using ASC
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z2.name as zname, z2.address as zooAddress from Zoo z2 where z2.name in ( select name from Zoo ) order by zname ASC, zooAddress ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as name, z.address as address from Zoo z order by name ASC, address ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as zooName, z.address as zooAddress from Zoo z order by zooName ASC, zooAddress ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address as name from Zoo z order by z.name ASC, name ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address as name from Zoo z order by z.name ASC, name ASC"
 				).list(),
 				zoo2, zoo4, zoo3, zoo1, null
 		);
 
 		// ordered by address, name:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as address, z.address as name from Zoo z order by name, address"
 				).list(),
 				zoo3, zoo4, zoo2, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address as name from Zoo z order by name, z.name"
 				).list(),
 				zoo3, zoo4, zoo2, zoo1, null
 		);
 		// using ASC
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as address, z.address as name from Zoo z order by name ASC, address ASC"
 				).list(),
 				zoo3, zoo4, zoo2, zoo1, null
 		);
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name, z.address as name from Zoo z order by name ASC, z.name ASC"
 				).list(),
 				zoo3, zoo4, zoo2, zoo1, null
 		);
 
 		// ordered by address:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		// unordered:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as zooName, z.address as zooAddress from Zoo z order by zooAddress"
 				).list(),
 				zoo3, zoo4, null, null, zoosWithSameAddress
 		);
 
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as zooName, z.address as name from Zoo z order by name"
 				).list(),
 				zoo3, zoo4, null, null, zoosWithSameAddress
 		);
 
 		// ordered by name:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		// unordered:
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as zooName, z.address as zooAddress from Zoo z order by zooName"
 				).list(),
 				zoo2, zoo4, null, null, zoosWithSameName
 		);
 
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as address, z.address as name from Zoo z order by address"
 				).list(),
 				zoo2, zoo4, null, null, zoosWithSameName
 		);
 		t.commit();
 		s.close();
 
 		cleanupData();
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "unknown")
 	public void testOrderByComponentDescSelectAliasRefFailureExpected() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by address desc, name desc:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		// using DESC
 		checkTestOrderByResults(
 				s.createQuery(
 						"select z.name as zooName, z.address as zooAddress from Zoo z order by zooAddress DESC, zooName DESC"
 				).list(),
 				zoo1, zoo2, zoo4, zoo3, null
 		);
 
 		t.commit();
 		s.close();
 
 		cleanupData();
 	}
 
 	@Test
 	public void testOrderByEntityWithFetchJoinedCollection() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by address desc, name desc:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		// using DESC
 		List list = s.createQuery( "from Zoo z join fetch z.mammals" ).list();
 
 		t.commit();
 		s.close();
 
 		cleanupData();
 	}
 
 	@Test
 	public void testOrderBySelectNewArgAliasRef() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by name, address:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		List list =
 				s.createQuery(
 						"select new Zoo( z.name as zname, z.address as zaddress) from Zoo z order by zname, zaddress"
 				).list();
 		assertEquals( 4, list.size() );
 		assertEquals( zoo2, list.get( 0 ) );
 		assertEquals( zoo4, list.get( 1 ) );
 		assertEquals( zoo3, list.get( 2 ) );
 		assertEquals( zoo1, list.get( 3 ) );
 
 		// ordered by address, name:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		list =
 				s.createQuery(
 						"select new Zoo( z.name as zname, z.address as zaddress) from Zoo z order by zaddress, zname"
 				).list();
 		assertEquals( 4, list.size() );
 		assertEquals( zoo3, list.get( 0 ) );
 		assertEquals( zoo4, list.get( 1 ) );
 		assertEquals( zoo2, list.get( 2 ) );
 		assertEquals( zoo1, list.get( 3 ) );
 
 
 		t.commit();
 		s.close();
 
 		cleanupData();
 	}
 
 	@Test(timeout = 5 * 60 * 1000)
 	public void testOrderBySelectNewMapArgAliasRef() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by name, address:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		List list =
 				s.createQuery(
 						"select new map( z.name as zname, z.address as zaddress ) from Zoo z left join z.mammals m order by zname, zaddress"
 				).list();
 		assertEquals( 4, list.size() );
 		assertEquals( zoo2.getName(), ( ( Map ) list.get( 0 ) ).get( "zname" ) );
 		assertEquals( zoo2.getAddress(), ( ( Map ) list.get( 0 ) ).get( "zaddress" ) );
 		assertEquals( zoo4.getName(), ( ( Map ) list.get( 1 ) ).get( "zname" ) );
 		assertEquals( zoo4.getAddress(), ( ( Map ) list.get( 1 ) ).get( "zaddress" ) );
 		assertEquals( zoo3.getName(), ( ( Map ) list.get( 2 ) ).get( "zname" ) );
 		assertEquals( zoo3.getAddress(), ( ( Map ) list.get( 2 ) ).get( "zaddress" ) );
 		assertEquals( zoo1.getName(), ( ( Map ) list.get( 3 ) ).get( "zname" ) );
 		assertEquals( zoo1.getAddress(), ( ( Map ) list.get( 3 ) ).get( "zaddress" ) );
 
 		// ordered by address, name:
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		list =
 				s.createQuery(
 						"select new map( z.name as zname, z.address as zaddress ) from Zoo z left join z.mammals m order by zaddress, zname"
 				).list();
 		assertEquals( 4, list.size() );
 		assertEquals( zoo3.getName(), ( ( Map ) list.get( 0 ) ).get( "zname" ) );
 		assertEquals( zoo3.getAddress(), ( ( Map ) list.get( 0 ) ).get( "zaddress" ) );
 		assertEquals( zoo4.getName(), ( ( Map ) list.get( 1 ) ).get( "zname" ) );
 		assertEquals( zoo4.getAddress(), ( ( Map ) list.get( 1 ) ).get( "zaddress" ) );
 		assertEquals( zoo2.getName(), ( ( Map ) list.get( 2 ) ).get( "zname" ) );
 		assertEquals( zoo2.getAddress(), ( ( Map ) list.get( 2 ) ).get( "zaddress" ) );
 		assertEquals( zoo1.getName(), ( ( Map ) list.get( 3 ) ).get( "zname" ) );
 		assertEquals( zoo1.getAddress(), ( ( Map ) list.get( 3 ) ).get( "zaddress" ) );
 		t.commit();
 		s.close();
 
 		cleanupData();
 	}
 
 	@Test
 	public void testOrderByAggregatedArgAliasRef() {
 		createData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// ordered by name, address:
 		//   zoo2  A Zoo       1313 Mockingbird Lane, Anywhere, IL USA
 		//   zoo4  Duh Zoo     1312 Mockingbird Lane, Nowhere, IL USA
 		//   zoo3  Zoo         1312 Mockingbird Lane, Anywhere, IL USA
 		//   zoo1  Zoo         1313 Mockingbird Lane, Anywhere, IL USA
 		List list =
 				s.createQuery(
 						"select z.name as zname, count(*) as cnt from Zoo z group by z.name order by cnt desc, zname"
 				).list();
 		assertEquals( 3, list.size() );
 		assertEquals( zoo3.getName(), ( ( Object[] ) list.get( 0 ) )[ 0 ] );
 		assertEquals( Long.valueOf( 2 ), ( ( Object[] ) list.get( 0 ) )[ 1 ] );
 		assertEquals( zoo2.getName(), ( ( Object[] ) list.get( 1 ) )[ 0 ] );
 		assertEquals( Long.valueOf( 1 ), ( ( Object[] ) list.get( 1 ) )[ 1 ] );
 		assertEquals( zoo4.getName(), ( ( Object[] ) list.get( 2 ) )[ 0 ] );
 		assertEquals( Long.valueOf( 1 ), ( ( Object[] ) list.get( 2 ) )[ 1 ] );
 		t.commit();
 		s.close();
 		cleanupData();
 	}
 
 	private void checkTestOrderByResults(
 			List results,
 			Zoo zoo1,
 			Zoo zoo2,
 			Zoo zoo3,
 			Zoo zoo4,
 			Set<Zoo> zoosUnordered) {
 		assertEquals( 4, results.size() );
 		Set<Zoo> zoosUnorderedCopy = ( zoosUnordered == null ? null : new HashSet<Zoo>( zoosUnordered ) );
 		checkTestOrderByResult( results.get( 0 ), zoo1, zoosUnorderedCopy );
 		checkTestOrderByResult( results.get( 1 ), zoo2, zoosUnorderedCopy );
 		checkTestOrderByResult( results.get( 2 ), zoo3, zoosUnorderedCopy );
 		checkTestOrderByResult( results.get( 3 ), zoo4, zoosUnorderedCopy );
 		if ( zoosUnorderedCopy != null ) {
 			assertTrue( zoosUnorderedCopy.isEmpty() );
 		}
 	}
 
 	private void checkTestOrderByResult(Object result,
 										Zoo zooExpected,
 										Set<Zoo> zoosUnordered) {
 		assertTrue( result instanceof Object[] );
 		Object[] resultArray = ( Object[] ) result;
 		assertEquals( 2,  resultArray.length );
 		Hibernate.initialize( ( ( Address ) resultArray[ 1 ] ).getStateProvince() );
 		if ( zooExpected == null ) {
 			Zoo zooResult = new Zoo();
 			zooResult.setName( ( String ) resultArray[ 0 ] );
 			zooResult.setAddress( ( Address ) resultArray[ 1 ] );
 			assertTrue( zoosUnordered.remove( zooResult ) );
 		}
 		else {
 			assertEquals( zooExpected.getName(), ( ( Object[] ) result )[ 0 ] );
 			assertEquals( zooExpected.getAddress(), ( ( Object[] ) result )[ 1 ] );
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingTest.java
index 2de5d359a3..cd44e6b24c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/ASTParserLoadingTest.java
@@ -164,2832 +164,2827 @@ public class ASTParserLoadingTest extends BaseCoreFunctionalTestCase {
 
 		// and doubly:
 		s.createQuery( "from Zoo z where ( select count(*) from Zoo ) + ( select count(*) from Zoo ) = 0" ).list();
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testJpaTypeOperator() {
 		// just checking syntax here...
 		Session s = openSession();
 		s.beginTransaction();
 
 		///////////////////////////////////////////////////////////////
 		// where clause
 		// control
 		s.createQuery( "from Animal a where a.class = Dog" ).list();
         // test
 		s.createQuery( "from Animal a where type(a) = Dog" ).list();
 
 		///////////////////////////////////////////////////////////////
 		// select clause (at some point we should unify these)
 		// control
 		Query query = s.createQuery( "select a.class from Animal a where a.class = Dog" );
 		query.list(); // checks syntax
 		assertEquals( 1, query.getReturnTypes().length );
 		assertEquals( Integer.class, query.getReturnTypes()[0].getReturnedClass() ); // always integer for joined
         // test
 		query = s.createQuery( "select type(a) from Animal a where type(a) = Dog" );
 		query.list(); // checks syntax
 		assertEquals( 1, query.getReturnTypes().length );
 		assertEquals( DiscriminatorType.class, query.getReturnTypes()[0].getClass() );
 		assertEquals( Class.class, query.getReturnTypes()[0].getReturnedClass() );
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testComponentJoins() {
 		Session s = openSession();
 		s.beginTransaction();
 		ComponentContainer root = new ComponentContainer(
 				new ComponentContainer.Address(
 						"123 Main",
 						"Anywhere",
 						"USA",
 						new ComponentContainer.Address.Zip( 12345, 6789 )
 				)
 		);
 		s.save( root );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List result = s.createQuery( "select a from ComponentContainer c join c.address a" ).list();
 		assertEquals( 1, result.size() );
 		assertTrue( ComponentContainer.Address.class.isInstance( result.get( 0 ) ) );
 
 		result = s.createQuery( "select a.zip from ComponentContainer c join c.address a" ).list();
 		assertEquals( 1, result.size() );
 		assertTrue( ComponentContainer.Address.Zip.class.isInstance( result.get( 0 ) ) );
 
 		result = s.createQuery( "select z from ComponentContainer c join c.address a join a.zip z" ).list();
 		assertEquals( 1, result.size() );
 		assertTrue( ComponentContainer.Address.Zip.class.isInstance( result.get( 0 ) ) );
 
 		result = s.createQuery( "select z.code from ComponentContainer c join c.address a join a.zip z" ).list();
 		assertEquals( 1, result.size() );
 		assertTrue( Integer.class.isInstance( result.get( 0 ) ) );
 		s.delete( root );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testJPAQLQualifiedIdentificationVariablesControl() {
 		// just checking syntax here...
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from VariousKeywordPropertyEntity where type = 'something'" ).list();
 		s.createQuery( "from VariousKeywordPropertyEntity where value = 'something'" ).list();
 		s.createQuery( "from VariousKeywordPropertyEntity where key = 'something'" ).list();
 		s.createQuery( "from VariousKeywordPropertyEntity where entry = 'something'" ).list();
 
 		s.createQuery( "from VariousKeywordPropertyEntity e where e.type = 'something'" ).list();
 		s.createQuery( "from VariousKeywordPropertyEntity e where e.value = 'something'" ).list();
 		s.createQuery( "from VariousKeywordPropertyEntity e where e.key = 'something'" ).list();
 		s.createQuery( "from VariousKeywordPropertyEntity e where e.entry = 'something'" ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testJPAQLMapKeyQualifier() {
 		Session s = openSession();
 		s.beginTransaction();
 		Human me = new Human();
 		me.setName( new Name( "Steve", null, "Ebersole" ) );
 		Human joe = new Human();
 		me.setName( new Name( "Joe", null, "Ebersole" ) );
 		me.setFamily( new HashMap() );
 		me.getFamily().put( "son", joe );
 		s.save( me );
 		s.save( joe );
 		s.getTransaction().commit();
 		s.close();
 
 		// in SELECT clause
 		{
 			// hibernate-only form
 			s = openSession();
 			s.beginTransaction();
 			List results = s.createQuery( "select distinct key(h.family) from Human h" ).list();
 			assertEquals( 1, results.size() );
 			Object key = results.get(0);
 			assertTrue( String.class.isAssignableFrom( key.getClass() ) );
 			s.getTransaction().commit();
 			s.close();
 		}
 
 		{
 			// jpa form
 			s = openSession();
 			s.beginTransaction();
 			List results = s.createQuery( "select distinct KEY(f) from Human h join h.family f" ).list();
 			assertEquals( 1, results.size() );
 			Object key = results.get(0);
 			assertTrue( String.class.isAssignableFrom( key.getClass() ) );
 			s.getTransaction().commit();
 			s.close();
 		}
 
 		// in WHERE clause
 		{
 			// hibernate-only form
 			s = openSession();
 			s.beginTransaction();
 			Long count = (Long) s.createQuery( "select count(*) from Human h where KEY(h.family) = 'son'" ).uniqueResult();
 			assertEquals( (Long)1L, count );
 			s.getTransaction().commit();
 			s.close();
 		}
 
 		{
 			// jpa form
 			s = openSession();
 			s.beginTransaction();
 			Long count = (Long) s.createQuery( "select count(*) from Human h join h.family f where key(f) = 'son'" ).uniqueResult();
 			assertEquals( (Long)1L, count );
 			s.getTransaction().commit();
 			s.close();
 		}
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( me );
 		s.delete( joe );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testJPAQLMapEntryQualifier() {
 		Session s = openSession();
 		s.beginTransaction();
 		Human me = new Human();
 		me.setName( new Name( "Steve", null, "Ebersole" ) );
 		Human joe = new Human();
 		me.setName( new Name( "Joe", null, "Ebersole" ) );
 		me.setFamily( new HashMap() );
 		me.getFamily().put( "son", joe );
 		s.save( me );
 		s.save( joe );
 		s.getTransaction().commit();
 		s.close();
 
 		// in SELECT clause
 		{
 			// hibernate-only form
 			s = openSession();
 			s.beginTransaction();
 			List results = s.createQuery( "select entry(h.family) from Human h" ).list();
 			assertEquals( 1, results.size() );
 			Object result = results.get(0);
 			assertTrue( Map.Entry.class.isAssignableFrom( result.getClass() ) );
 			Map.Entry entry = (Map.Entry) result;
 			assertTrue( String.class.isAssignableFrom( entry.getKey().getClass() ) );
 			assertTrue( Human.class.isAssignableFrom( entry.getValue().getClass() ) );
 			s.getTransaction().commit();
 			s.close();
 		}
 
 		{
 			// jpa form
 			s = openSession();
 			s.beginTransaction();
 			List results = s.createQuery( "select ENTRY(f) from Human h join h.family f" ).list();
 			assertEquals( 1, results.size() );
 			Object result = results.get(0);
 			assertTrue( Map.Entry.class.isAssignableFrom( result.getClass() ) );
 			Map.Entry entry = (Map.Entry) result;
 			assertTrue( String.class.isAssignableFrom( entry.getKey().getClass() ) );
 			assertTrue( Human.class.isAssignableFrom( entry.getValue().getClass() ) );
 			s.getTransaction().commit();
 			s.close();
 		}
 
 		// not exactly sure of the syntax of ENTRY in the WHERE clause...
 
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( me );
 		s.delete( joe );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testJPAQLMapValueQualifier() {
 		Session s = openSession();
 		s.beginTransaction();
 		Human me = new Human();
 		me.setName( new Name( "Steve", null, "Ebersole" ) );
 		Human joe = new Human();
 		me.setName( new Name( "Joe", null, "Ebersole" ) );
 		me.setFamily( new HashMap() );
 		me.getFamily().put( "son", joe );
 		s.save( me );
 		s.save( joe );
 		s.getTransaction().commit();
 		s.close();
 
 		// in SELECT clause
 		{
 			// hibernate-only form
 			s = openSession();
 			s.beginTransaction();
 			List results = s.createQuery( "select value(h.family) from Human h" ).list();
 			assertEquals( 1, results.size() );
 			Object result = results.get(0);
 			assertTrue( Human.class.isAssignableFrom( result.getClass() ) );
 			s.getTransaction().commit();
 			s.close();
 		}
 
 		{
 			// jpa form
 			s = openSession();
 			s.beginTransaction();
 			List results = s.createQuery( "select VALUE(f) from Human h join h.family f" ).list();
 			assertEquals( 1, results.size() );
 			Object result = results.get(0);
 			assertTrue( Human.class.isAssignableFrom( result.getClass() ) );
 			s.getTransaction().commit();
 			s.close();
 		}
 
 		// in WHERE clause
 		{
 			// hibernate-only form
 			s = openSession();
 			s.beginTransaction();
 			Long count = (Long) s.createQuery( "select count(*) from Human h where VALUE(h.family) = :joe" ).setParameter( "joe", joe ).uniqueResult();
 			// ACTUALLY EXACTLY THE SAME AS:
 			// select count(*) from Human h where h.family = :joe
 			assertEquals( (Long)1L, count );
 			s.getTransaction().commit();
 			s.close();
 		}
 
 		{
 			// jpa form
 			s = openSession();
 			s.beginTransaction();
 			Long count = (Long) s.createQuery( "select count(*) from Human h join h.family f where value(f) = :joe" ).setParameter( "joe", joe ).uniqueResult();
 			// ACTUALLY EXACTLY THE SAME AS:
 			// select count(*) from Human h join h.family f where f = :joe
 			assertEquals( (Long)1L, count );
 			s.getTransaction().commit();
 			s.close();
 		}
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( me );
 		s.delete( joe );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@SkipForDialect(
 			value = IngresDialect.class,
 			jiraKey = "HHH-4961",
 			comment = "Ingres does not support this scoping in 9.3"
 	)
 	public void testPaginationWithPolymorphicQuery() {
 		Session s = openSession();
 		s.beginTransaction();
 		Human h = new Human();
 		h.setName( new Name( "Steve", null, "Ebersole" ) );
 		s.save( h );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List results = s.createQuery( "from java.lang.Object" ).setMaxResults( 2 ).list();
 		assertEquals( 1, results.size() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( h );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-2045" )
 	@RequiresDialect( H2Dialect.class )
 	public void testEmptyInList() {
 		Session session = openSession();
 		session.beginTransaction();
 		Human human = new Human();
 		human.setName( new Name( "Lukasz", null, "Antoniak" ) );
 		human.setNickName( "NONE" );
 		session.save( human );
 		session.getTransaction().commit();
 		session.close();
 
 		session = openSession();
 		session.beginTransaction();
 		List results = session.createQuery( "from Human h where h.nickName in ()" ).list();
 		assertEquals( 0, results.size() );
 		session.getTransaction().commit();
 		session.close();
 
 		session = openSession();
 		session.beginTransaction();
 		session.delete( human );
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	@Test
 	public void testComponentNullnessChecks() {
 		Session s = openSession();
 		s.beginTransaction();
 		Human h = new Human();
 		h.setName( new Name( "Johnny", 'B', "Goode" ) );
 		s.save( h );
 		h = new Human();
 		h.setName( new Name( "Steve", null, "Ebersole" ) );
 		s.save( h );
 		h = new Human();
 		h.setName( new Name( "Bono", null, null ) );
 		s.save( h );
 		h = new Human();
 		h.setName( new Name( null, null, null ) );
 		s.save( h );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List results = s.createQuery( "from Human where name is null" ).list();
 		assertEquals( 1, results.size() );
 		results = s.createQuery( "from Human where name is not null" ).list();
 		assertEquals( 3, results.size() );
 		String query =
 				( getDialect() instanceof DB2Dialect || getDialect() instanceof HSQLDialect ) ?
 						"from Human where cast(? as string) is null" :
 						"from Human where ? is null"
 				;
 		s.createQuery( query ).setParameter( 0, null ).list();
 
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete Human" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-4150" )
 	public void testSelectClauseCaseWithSum() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Human h1 = new Human();
 		h1.setBodyWeight( 74.0f );
 		h1.setDescription( "Me" );
 		s.persist( h1 );
 
 		Human h2 = new Human();
 		h2.setBodyWeight( 125.0f );
 		h2.setDescription( "big persion #1" );
 		s.persist( h2 );
 
 		Human h3 = new Human();
 		h3.setBodyWeight( 110.0f );
 		h3.setDescription( "big persion #2" );
 		s.persist( h3 );
 
 		s.flush();
 
 		Number count = (Number) s.createQuery( "select sum(case when bodyWeight > 100 then 1 else 0 end) from Human" ).uniqueResult();
 		assertEquals( 2, count.intValue() );
 		count = (Number) s.createQuery( "select sum(case when bodyWeight > 100 then bodyWeight else 0 end) from Human" ).uniqueResult();
 		assertEquals( h2.getBodyWeight() + h3.getBodyWeight(), count.floatValue(), 0.001 );
 
 		t.rollback();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-4150" )
 	public void testSelectClauseCaseWithCountDistinct() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Human h1 = new Human();
 		h1.setBodyWeight( 74.0f );
 		h1.setDescription( "Me" );
 		h1.setNickName( "Oney" );
 		s.persist( h1 );
 
 		Human h2 = new Human();
 		h2.setBodyWeight( 125.0f );
 		h2.setDescription( "big persion" );
 		h2.setNickName( "big #1" );
 		s.persist( h2 );
 
 		Human h3 = new Human();
 		h3.setBodyWeight( 110.0f );
 		h3.setDescription( "big persion" );
 		h3.setNickName( "big #2" );
 		s.persist( h3 );
 
 		s.flush();
 
 		Number count = (Number) s.createQuery( "select count(distinct case when bodyWeight > 100 then description else null end) from Human" ).uniqueResult();
 		assertEquals( 1, count.intValue() );
 		count = (Number) s.createQuery( "select count(case when bodyWeight > 100 then description else null end) from Human" ).uniqueResult();
 		assertEquals( 2, count.intValue() );
 		count = (Number) s.createQuery( "select count(distinct case when bodyWeight > 100 then nickName else null end) from Human" ).uniqueResult();
 		assertEquals( 2, count.intValue() );
 
 		t.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testInvalidCollectionDereferencesFail() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		// control group...
 		s.createQuery( "from Animal a join a.offspring o where o.description = 'xyz'" ).list();
 		s.createQuery( "from Animal a join a.offspring o where o.father.description = 'xyz'" ).list();
 		s.createQuery( "from Animal a join a.offspring o order by o.description" ).list();
 		s.createQuery( "from Animal a join a.offspring o order by o.father.description" ).list();
 
 		try {
 			s.createQuery( "from Animal a where a.offspring.description = 'xyz'" ).list();
 			fail( "illegal collection dereference semantic did not cause failure" );
 		}
 		catch( QueryException qe ) {
             log.trace("expected failure...", qe);
 		}
 
 		try {
 			s.createQuery( "from Animal a where a.offspring.father.description = 'xyz'" ).list();
 			fail( "illegal collection dereference semantic did not cause failure" );
 		}
 		catch( QueryException qe ) {
             log.trace("expected failure...", qe);
 		}
 
 		try {
 			s.createQuery( "from Animal a order by a.offspring.description" ).list();
 			fail( "illegal collection dereference semantic did not cause failure" );
 		}
 		catch( QueryException qe ) {
             log.trace("expected failure...", qe);
 		}
 
 		try {
 			s.createQuery( "from Animal a order by a.offspring.father.description" ).list();
 			fail( "illegal collection dereference semantic did not cause failure" );
 		}
 		catch( QueryException qe ) {
             log.trace("expected failure...", qe);
 		}
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testConcatenation() {
 		// simple syntax checking...
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Human h where h.nickName = '1' || 'ov' || 'tha' || 'few'" ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testExpressionWithParamInFunction() {
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Animal a where abs(a.bodyWeight-:param) < 2.0" ).setLong( "param", 1 ).list();
 		s.createQuery( "from Animal a where abs(:param - a.bodyWeight) < 2.0" ).setLong( "param", 1 ).list();
 		if ( ( getDialect() instanceof HSQLDialect ) || ( getDialect() instanceof DB2Dialect ) ) {
 			// HSQLDB and DB2 don't like the abs(? - ?) syntax. bit work if at least one parameter is typed...
 			s.createQuery( "from Animal where abs(cast(:x as long) - :y) < 2.0" ).setLong( "x", 1 ).setLong( "y", 1 ).list();
 			s.createQuery( "from Animal where abs(:x - cast(:y as long)) < 2.0" ).setLong( "x", 1 ).setLong( "y", 1 ).list();
 			s.createQuery( "from Animal where abs(cast(:x as long) - cast(:y as long)) < 2.0" ).setLong( "x", 1 ).setLong( "y", 1 ).list();
 		}
 		else {
 			s.createQuery( "from Animal where abs(:x - :y) < 2.0" ).setLong( "x", 1 ).setLong( "y", 1 ).list();
 		}
 
 		if ( getDialect() instanceof DB2Dialect ) {
 			s.createQuery( "from Animal where lower(upper(cast(:foo as string))) like 'f%'" ).setString( "foo", "foo" ).list();
 		}
 		else {
 			s.createQuery( "from Animal where lower(upper(:foo)) like 'f%'" ).setString( "foo", "foo" ).list();
 		}
 		s.createQuery( "from Animal a where abs(abs(a.bodyWeight - 1.0 + :param) * abs(length('ffobar')-3)) = 3.0" ).setLong(
 				"param", 1
 		).list();
 		if ( getDialect() instanceof DB2Dialect ) {
 			s.createQuery( "from Animal where lower(upper('foo') || upper(cast(:bar as string))) like 'f%'" ).setString( "bar", "xyz" ).list();
 		}
 		else {
 			s.createQuery( "from Animal where lower(upper('foo') || upper(:bar)) like 'f%'" ).setString( "bar", "xyz" ).list();
 		}
 		if ( ! ( getDialect() instanceof PostgreSQLDialect|| getDialect() instanceof PostgreSQL81Dialect || getDialect() instanceof MySQLDialect ) ) {
 			s.createQuery( "from Animal where abs(cast(1 as float) - cast(:param as float)) = 1.0" ).setLong( "param", 1 ).list();
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCrazyIdFieldNames() {
 		MoreCrazyIdFieldNameStuffEntity top = new MoreCrazyIdFieldNameStuffEntity( "top" );
 		HeresAnotherCrazyIdFieldName next = new HeresAnotherCrazyIdFieldName( "next" );
 		top.setHeresAnotherCrazyIdFieldName( next );
 		MoreCrazyIdFieldNameStuffEntity other = new MoreCrazyIdFieldNameStuffEntity( "other" );
 		Session s = openSession();
 		s.beginTransaction();
 		s.save( next );
 		s.save( top );
 		s.save( other );
 		s.flush();
 
 		List results = s.createQuery( "select e.heresAnotherCrazyIdFieldName from MoreCrazyIdFieldNameStuffEntity e where e.heresAnotherCrazyIdFieldName is not null" ).list();
 		assertEquals( 1, results.size() );
 		Object result = results.get( 0 );
 		assertClassAssignability( HeresAnotherCrazyIdFieldName.class, result.getClass() );
 		assertSame( next, result );
 
 		results = s.createQuery( "select e.heresAnotherCrazyIdFieldName.heresAnotherCrazyIdFieldName from MoreCrazyIdFieldNameStuffEntity e where e.heresAnotherCrazyIdFieldName is not null" ).list();
 		assertEquals( 1, results.size() );
 		result = results.get( 0 );
 		assertClassAssignability( Long.class, result.getClass() );
 		assertEquals( next.getHeresAnotherCrazyIdFieldName(), result );
 
 		results = s.createQuery( "select e.heresAnotherCrazyIdFieldName from MoreCrazyIdFieldNameStuffEntity e" ).list();
 		assertEquals( 1, results.size() );
 		Iterator itr = s.createQuery( "select e.heresAnotherCrazyIdFieldName from MoreCrazyIdFieldNameStuffEntity e" ).iterate();
 		assertTrue( itr.hasNext() ); itr.next(); assertFalse( itr.hasNext() );
 
 		s.delete( top );
 		s.delete( next );
 		s.delete( other );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-2257" )
 	public void testImplicitJoinsInDifferentClauses() {
 		// both the classic and ast translators output the same syntactically valid sql
 		// for all of these cases; the issue is that shallow (iterate) and
 		// non-shallow (list/scroll) queries return different results because the
 		// shallow skips the inner join which "weeds out" results from the non-shallow queries.
 		// The results were initially different depending upon the clause(s) in which the
 		// implicit join occurred
 		Session s = openSession();
 		s.beginTransaction();
 		SimpleEntityWithAssociation owner = new SimpleEntityWithAssociation( "owner" );
 		SimpleAssociatedEntity e1 = new SimpleAssociatedEntity( "thing one", owner );
 		SimpleAssociatedEntity e2 = new SimpleAssociatedEntity( "thing two" );
 		s.save( e1 );
 		s.save( e2 );
 		s.save( owner );
 		s.getTransaction().commit();
 		s.close();
 
 		checkCounts( "select e.owner from SimpleAssociatedEntity e", 1, "implicit-join in select clause" );
 		checkCounts( "select e.id, e.owner from SimpleAssociatedEntity e", 1, "implicit-join in select clause" );
 
 		// resolved to a "id short cut" when part of the order by clause -> no inner join = no weeding out...
 		checkCounts( "from SimpleAssociatedEntity e order by e.owner", 2, "implicit-join in order-by clause" );
 		// resolved to a "id short cut" when part of the group by clause -> no inner join = no weeding out...
 		checkCounts( "select e.owner.id, count(*) from SimpleAssociatedEntity e group by e.owner", 2, "implicit-join in select and group-by clauses" );
 
 	 	s = openSession();
 		s.beginTransaction();
 		s.delete( e1 );
 		s.delete( e2 );
 		s.delete( owner );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testRowValueConstructorSyntaxInInList() {
 		Session s = openSession();
 		s.beginTransaction();
 		Product product = new Product();
 		product.setDescription( "My Product" );
 		product.setNumberAvailable( 10 );
 		product.setPrice( new BigDecimal( 123 ) );
 		product.setProductId( "4321" );
 		s.save( product );
 
 
 		Customer customer = new Customer();
 		customer.setCustomerId( "123456789" );
 		customer.setName( "My customer" );
 		customer.setAddress( "somewhere" );
 		s.save( customer );
 
 		Order order = customer.generateNewOrder( new BigDecimal( 1234 ) );
 		s.save( order );
 
 		LineItem li = order.generateLineItem( product, 5 );
 		s.save( li );
 		product = new Product();
 		product.setDescription( "My Product" );
 		product.setNumberAvailable( 10 );
 		product.setPrice( new BigDecimal( 123 ) );
 		product.setProductId( "1234" );
 		s.save( product );
 		li = order.generateLineItem( product, 10 );
 		s.save( li );
 
 		s.flush();
 		Query query = s.createQuery( "from LineItem l where l.id in (:idList)" );
 		List<Id> list = new ArrayList<Id>();
 		list.add( new Id( "123456789", order.getId().getOrderNumber(), "4321" ) );
 		list.add( new Id( "123456789", order.getId().getOrderNumber(), "1234" ) );
 		query.setParameterList( "idList", list );
 		assertEquals( 2, query.list().size() );
 
 		query = s.createQuery( "from LineItem l where l.id in :idList" );
 		query.setParameterList( "idList", list );
 		assertEquals( 2, query.list().size() );
 
 		s.getTransaction().rollback();
 		s.close();
 
 	}
 
 	private void checkCounts(String hql, int expected, String testCondition) {
 		Session s = openSession();
 		s.beginTransaction();
 		int count = determineCount( s.createQuery( hql ).list().iterator() );
 		assertEquals( "list() [" + testCondition + "]", expected, count );
 		count = determineCount( s.createQuery( hql ).iterate() );
 		assertEquals( "iterate() [" + testCondition + "]", expected, count );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-2257" )
 	public void testImplicitSelectEntityAssociationInShallowQuery() {
 		// both the classic and ast translators output the same syntactically valid sql.
 		// the issue is that shallow and non-shallow queries return different
 		// results because the shallow skips the inner join which "weeds out" results
 		// from the non-shallow queries...
 		Session s = openSession();
 		s.beginTransaction();
 		SimpleEntityWithAssociation owner = new SimpleEntityWithAssociation( "owner" );
 		SimpleAssociatedEntity e1 = new SimpleAssociatedEntity( "thing one", owner );
 		SimpleAssociatedEntity e2 = new SimpleAssociatedEntity( "thing two" );
 		s.save( e1 );
 		s.save( e2 );
 		s.save( owner );
 		s.getTransaction().commit();
 		s.close();
 
 	 	s = openSession();
 		s.beginTransaction();
 		int count = determineCount( s.createQuery( "select e.id, e.owner from SimpleAssociatedEntity e" ).list().iterator() );
 		assertEquals( 1, count ); // thing two would be removed from the result due to the inner join
 		count = determineCount( s.createQuery( "select e.id, e.owner from SimpleAssociatedEntity e" ).iterate() );
 		assertEquals( 1, count );
 		s.getTransaction().commit();
 		s.close();
 
 	 	s = openSession();
 		s.beginTransaction();
 		s.delete( e1 );
 		s.delete( e2 );
 		s.delete( owner );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	private int determineCount(Iterator iterator) {
 		int count = 0;
 		while( iterator.hasNext() ) {
 			count++;
 			iterator.next();
 		}
 		return count;
 	}
 
     @Test
     @TestForIssue( jiraKey = "HHH-6714" )
     public void testUnaryMinus(){
         Session s = openSession();
         s.beginTransaction();
         Human stliu = new Human();
         stliu.setIntValue( 26 );
 
         s.persist( stliu );
         s.getTransaction().commit();
         s.clear();
         s.beginTransaction();
         List list =s.createQuery( "from Human h where -(h.intValue - 100)=74" ).list();
         assertEquals( 1, list.size() );
         s.getTransaction().commit();
         s.close();
 
 
     }
 
 	@Test
 	public void testEntityAndOneToOneReturnedByQuery() {
 		Session s = openSession();
 		s.beginTransaction();
 		Human h = new Human();
 		h.setName( new Name( "Gail", null, "Badner" ) );
 		s.save( h );
 		User u = new User();
 		u.setUserName( "gbadner" );
 		u.setHuman( h );
 		s.save( u );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Object [] result = ( Object [] ) s.createQuery( "from User u, Human h where u.human = h" ).uniqueResult();
 		assertNotNull( result );
 		assertEquals( u.getUserName(), ( ( User ) result[ 0 ] ).getUserName() );
 		assertEquals( h.getName().getFirst(), ((Human) result[1]).getName().getFirst() );
 		assertSame( ((User) result[0]).getHuman(), result[1] );
 		s.createQuery( "delete User" ).executeUpdate();
 		s.createQuery( "delete Human" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNestedComponentIsNull() {
 		// (1) From MapTest originally...
 		// (2) Was then moved into HQLTest...
 		// (3) However, a bug fix to EntityType#getIdentifierOrUniqueKeyType (HHH-2138)
 		// 		caused the classic parser to suddenly start throwing exceptions on
 		//		this query, apparently relying on the buggy behavior somehow; thus
 		//		moved here to at least get some syntax checking...
 		//
 		// fyi... found and fixed the problem in the classic parser; still
 		// leaving here for syntax checking
 		new SyntaxChecker( "from Commento c where c.marelo.commento.mcompr is null" ).checkAll();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-939" )
 	public void testSpecialClassPropertyReference() {
 		// this is a long standing bug in Hibernate when applied to joined-subclasses;
 		//  see HHH-939 for details and history
 		new SyntaxChecker( "from Zoo zoo where zoo.class = PettingZoo" ).checkAll();
 		new SyntaxChecker( "select a.description from Animal a where a.class = Mammal" ).checkAll();
 		new SyntaxChecker( "select a.class from Animal a" ).checkAll();
 		new SyntaxChecker( "from DomesticAnimal an where an.class = Dog" ).checkAll();
 		new SyntaxChecker( "from Animal an where an.class = Dog" ).checkAll();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-2376" )
 	public void testSpecialClassPropertyReferenceFQN() {
 		new SyntaxChecker( "from Zoo zoo where zoo.class = org.hibernate.test.hql.PettingZoo" ).checkAll();
 		new SyntaxChecker( "select a.description from Animal a where a.class = org.hibernate.test.hql.Mammal" ).checkAll();
 		new SyntaxChecker( "from DomesticAnimal an where an.class = org.hibernate.test.hql.Dog" ).checkAll();
 		new SyntaxChecker( "from Animal an where an.class = org.hibernate.test.hql.Dog" ).checkAll();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-1631" )
 	public void testSubclassOrSuperclassPropertyReferenceInJoinedSubclass() {
 		// this is a long standing bug in Hibernate; see HHH-1631 for details and history
 		//
 		// (1) pregnant is defined as a property of the class (Mammal) itself
 		// (2) description is defined as a property of the superclass (Animal)
 		// (3) name is defined as a property of a particular subclass (Human)
 
 		new SyntaxChecker( "from Zoo z join z.mammals as m where m.name.first = 'John'" ).checkIterate();
 
 		new SyntaxChecker( "from Zoo z join z.mammals as m where m.pregnant = false" ).checkAll();
 		new SyntaxChecker( "select m.pregnant from Zoo z join z.mammals as m where m.pregnant = false" ).checkAll();
 
 		new SyntaxChecker( "from Zoo z join z.mammals as m where m.description = 'tabby'" ).checkAll();
 		new SyntaxChecker( "select m.description from Zoo z join z.mammals as m where m.description = 'tabby'" ).checkAll();
 
 		new SyntaxChecker( "from Zoo z join z.mammals as m where m.name.first = 'John'" ).checkAll();
 		new SyntaxChecker( "select m.name from Zoo z join z.mammals as m where m.name.first = 'John'" ).checkAll();
 
 		new SyntaxChecker( "select m.pregnant from Zoo z join z.mammals as m" ).checkAll();
 		new SyntaxChecker( "select m.description from Zoo z join z.mammals as m" ).checkAll();
 		new SyntaxChecker( "select m.name from Zoo z join z.mammals as m" ).checkAll();
 
 		new SyntaxChecker( "from DomesticAnimal da join da.owner as o where o.nickName = 'Gavin'" ).checkAll();
 		new SyntaxChecker( "select da.father from DomesticAnimal da join da.owner as o where o.nickName = 'Gavin'" ).checkAll();
 		new SyntaxChecker( "select da.father from DomesticAnimal da where da.owner.nickName = 'Gavin'" ).checkAll();
 	}
 
 	/**
 	 * {@link #testSubclassOrSuperclassPropertyReferenceInJoinedSubclass} tests the implicit form of entity casting
 	 * that Hibernate has always supported.  THis method tests the explicit variety added by JPA 2.1 using the TREAT
 	 * keyword.
 	 */
 	@Test
 	public void testExplicitEntityCasting() {
 		new SyntaxChecker( "from Zoo z join treat(z.mammals as Human) as m where m.name.first = 'John'" ).checkIterate();
 		new SyntaxChecker( "from Zoo z join z.mammals as m where treat(m as Human).name.first = 'John'" ).checkIterate();
 	}
 
 	@Test
 	@RequiresDialectFeature(
 			value = DialectChecks.SupportLimitAndOffsetCheck.class,
 			comment = "dialect does not support offset and limit combo"
 	)
 	public void testSimpleSelectWithLimitAndOffset() throws Exception {
 		// just checking correctness of param binding code...
 		Session session = openSession();
 		session.createQuery( "from Animal" )
 				.setFirstResult( 2 )
 				.setMaxResults( 1 )
 				.list();
 		session.close();
 	}
 
 	@Test
 	public void testJPAPositionalParameterList() {
 		Session s = openSession();
 		s.beginTransaction();
 		ArrayList<String> params = new ArrayList<String>();
 		params.add( "Doe" );
 		params.add( "Public" );
 		s.createQuery( "from Human where name.last in (?1)" )
 				.setParameterList( "1", params )
 				.list();
 
 		s.createQuery( "from Human where name.last in ?1" )
 				.setParameterList( "1", params )
 				.list();
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testComponentQueries() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		Type[] types = s.createQuery( "select h.name from Human h" ).getReturnTypes();
 		assertEquals( 1, types.length );
 		assertTrue( types[0] instanceof ComponentType );
 
 		// Test the ability to perform comparisons between component values
 		s.createQuery( "from Human h where h.name = h.name" ).list();
 		s.createQuery( "from Human h where h.name = :name" ).setParameter( "name", new Name() ).list();
 		s.createQuery( "from Human where name = :name" ).setParameter( "name", new Name() ).list();
 		s.createQuery( "from Human h where :name = h.name" ).setParameter( "name", new Name() ).list();
 		s.createQuery( "from Human h where :name <> h.name" ).setParameter( "name", new Name() ).list();
 
 		// Test the ability to perform comparisons between a component and an explicit row-value
 		s.createQuery( "from Human h where h.name = ('John', 'X', 'Doe')" ).list();
 		s.createQuery( "from Human h where ('John', 'X', 'Doe') = h.name" ).list();
 		s.createQuery( "from Human h where ('John', 'X', 'Doe') <> h.name" ).list();
 		s.createQuery( "from Human h where ('John', 'X', 'Doe') >= h.name" ).list();
 
 		s.createQuery( "from Human h order by h.name" ).list();
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-1774" )
 	@SkipForDialect(
 			value = IngresDialect.class,
 			comment = "Subselects are not supported within select target lists in Ingres",
 			jiraKey = "HHH-4970"
 	)
 	public void testComponentParameterBinding() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		Order.Id oId = new Order.Id( "1234", 1 );
 
 		// control
 		s.createQuery("from Order o where o.customer.name =:name and o.id = :id")
 				.setParameter( "name", "oracle" )
 				.setParameter( "id", oId )
 				.list();
 
 		// this is the form that caused problems in the original case...
 		s.createQuery("from Order o where o.id = :id and o.customer.name =:name ")
 				.setParameter( "id", oId )
 				.setParameter( "name", "oracle" )
 				.list();
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testAnyMappingReference() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		PropertyValue redValue = new StringPropertyValue( "red" );
 		PropertyValue loneliestNumberValue = new IntegerPropertyValue( 1 );
 
 		Long id;
 		PropertySet ps = new PropertySet( "my properties" );
 		ps.setSomeSpecificProperty( redValue );
 		ps.getGeneralProperties().put( "the loneliest number", loneliestNumberValue );
 		ps.getGeneralProperties().put( "i like", new StringPropertyValue( "pina coladas" ) );
 		ps.getGeneralProperties().put( "i also like", new StringPropertyValue( "getting caught in the rain" ) );
 		s.save( ps );
 
 		s.getTransaction().commit();
 		id = ps.getId();
 		s.clear();
 		s.beginTransaction();
 
 		// TODO : setEntity() currently will not work here, but that would be *very* nice
 		// does not work because the corresponding EntityType is then used as the "bind type" rather
 		// than the "discovered" AnyType...
 		s.createQuery( "from PropertySet p where p.someSpecificProperty = :ssp" ).setParameter( "ssp", redValue ).list();
 
 		s.createQuery( "from PropertySet p where p.someSpecificProperty.id is not null" ).list();
 
 		s.createQuery( "from PropertySet p join p.generalProperties gp where gp.id is not null" ).list();
 
 		s.delete( s.load( PropertySet.class, id ) );
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testJdkEnumStyleEnumConstant() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 
 		s.createQuery( "from Zoo z where z.classification = org.hibernate.test.hql.Classification.LAME" ).list();
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	@FailureExpected( jiraKey = "unknown" )
 	public void testParameterTypeMismatch() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		Query query = s.createQuery( "from Animal a where a.description = :nonstring" )
 				.setParameter( "nonstring", Integer.valueOf( 1 ) );
 		try {
 			query.list();
 			fail( "query execution should have failed" );
 		}
 		catch( TypeMismatchException tme ) {
 			// expected behavior
 		}
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testMultipleBagFetchesFail() {
 		Session s = openSession();
 		s.beginTransaction();
 		try {
 			s.createQuery( "from Human h join fetch h.friends f join fetch f.friends fof" ).list();
 			fail( "failure expected" );
 		}
 		catch( HibernateException e ) {
 			assertTrue( "unexpected failure reason : " + e, e.getMessage().indexOf( "multiple bags" ) > 0 );
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-1248" )
 	public void testCollectionJoinsInSubselect() {
 		// HHH-1248 : initially FromElementFactory treated any explicit join
 		// as an implied join so that theta-style joins would always be used.
 		// This was because correlated subqueries cannot use ANSI-style joins
 		// for the correlation.  However, this special treatment was not limited
 		// to only correlated subqueries; it was applied to any subqueries ->
 		// which in-and-of-itself is not necessarily bad.  But somewhere later
 		// the choices made there caused joins to be dropped.
 		Session s = openSession();
 		String qryString =
 				"select a.id, a.description" +
 				" from Animal a" +
 				"       left join a.offspring" +
 				" where a in (" +
 				"       select a1 from Animal a1" +
 				"           left join a1.offspring o" +
 				"       where a1.id=1" +
 		        ")";
 		s.createQuery( qryString ).list();
 		qryString =
 				"select h.id, h.description" +
 		        " from Human h" +
 				"      left join h.friends" +
 				" where h in (" +
 				"      select h1" +
 				"      from Human h1" +
 				"          left join h1.friends f" +
 				"      where h1.id=1" +
 				")";
 		s.createQuery( qryString ).list();
 		qryString =
 				"select h.id, h.description" +
 		        " from Human h" +
 				"      left join h.friends f" +
 				" where f in (" +
 				"      select h1" +
 				"      from Human h1" +
 				"          left join h1.friends f1" +
 				"      where h = f1" +
 				")";
 		s.createQuery( qryString ).list();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionFetchWithDistinctionAndLimit() {
 		// create some test data...
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		int parentCount = 30;
 		for ( int i = 0; i < parentCount; i++ ) {
 			Animal child1 = new Animal();
 			child1.setDescription( "collection fetch distinction (child1 - parent" + i + ")" );
 			s.persist( child1 );
 			Animal child2 = new Animal();
 			child2.setDescription( "collection fetch distinction (child2 - parent " + i + ")" );
 			s.persist( child2 );
 			Animal parent = new Animal();
 			parent.setDescription( "collection fetch distinction (parent" + i + ")" );
 			parent.setSerialNumber( "123-" + i );
 			parent.addOffspring( child1 );
 			parent.addOffspring( child2 );
 			s.persist( parent );
 		}
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		// Test simple distinction
 		List results;
 		results = s.createQuery( "select distinct p from Animal p inner join fetch p.offspring" ).list();
 		assertEquals( "duplicate list() returns", 30, results.size() );
 		// Test first/max
 		results = s.createQuery( "select p from Animal p inner join fetch p.offspring order by p.id" )
 				.setFirstResult( 5 )
 				.setMaxResults( 20 )
 				.list();
 		assertEquals( "duplicate returns", 20, results.size() );
 		Animal firstReturn = ( Animal ) results.get( 0 );
 		assertEquals( "firstResult not applied correctly", "123-5", firstReturn.getSerialNumber() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete Animal where mother is not null" ).executeUpdate();
 		s.createQuery( "delete Animal" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testFetchInSubqueryFails() {
 		Session s = openSession();
 		try {
 			s.createQuery( "from Animal a where a.mother in (select m from Animal a1 inner join a1.mother as m join fetch m.mother)" ).list();
 			fail( "fetch join allowed in subquery" );
 		}
 		catch( QueryException expected ) {
 			// expected behavior
 		}
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-1464" )
 	public void testQueryMetadataRetrievalWithFetching() {
 		// HHH-1464 : there was a problem due to the fact they we polled
 		// the shallow version of the query plan to get the metadata.
 		Session s = openSession();
 		Query query = s.createQuery( "from Animal a inner join fetch a.mother" );
 		assertEquals( 1, query.getReturnTypes().length );
 		assertNull( query.getReturnAliases() );
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-429" )
 	@SuppressWarnings( {"unchecked"})
 	public void testSuperclassPropertyReferenceAfterCollectionIndexedAccess() {
 		// note: simply performing syntax checking in the db
 		Session s = openSession();
 		s.beginTransaction();
 		Mammal tiger = new Mammal();
 		tiger.setDescription( "Tiger" );
 		s.persist( tiger );
 		Mammal mother = new Mammal();
 		mother.setDescription( "Tiger's mother" );
 		mother.setBodyWeight( 4.0f );
 		mother.addOffspring( tiger );
 		s.persist( mother );
 		Zoo zoo = new Zoo();
 		zoo.setName( "Austin Zoo" );
 		zoo.setMammals( new HashMap() );
 		zoo.getMammals().put( "tiger", tiger );
 		s.persist( zoo );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List results = s.createQuery( "from Zoo zoo where zoo.mammals['tiger'].mother.bodyWeight > 3.0f" ).list();
 		assertEquals( 1, results.size() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( tiger );
 		s.delete( mother );
 		s.delete( zoo );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testJoinFetchCollectionOfValues() {
 		// note: simply performing syntax checking in the db
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "select h from Human as h join fetch h.nickNames" ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testIntegerLiterals() {
 		// note: simply performing syntax checking in the db
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Foo where long = 1" ).list();
 		s.createQuery( "from Foo where long = " + Integer.MIN_VALUE ).list();
 		s.createQuery( "from Foo where long = " + Integer.MAX_VALUE ).list();
 		s.createQuery( "from Foo where long = 1L" ).list();
 		s.createQuery( "from Foo where long = " + (Long.MIN_VALUE + 1) + "L" ).list();
 		s.createQuery( "from Foo where long = " + Long.MAX_VALUE + "L" ).list();
 		s.createQuery( "from Foo where integer = " + (Long.MIN_VALUE + 1) ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testDecimalLiterals() {
 		// note: simply performing syntax checking in the db
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Animal where bodyWeight > 100.0e-10" ).list();
 		s.createQuery( "from Animal where bodyWeight > 100.0E-10" ).list();
 		s.createQuery( "from Animal where bodyWeight > 100.001f" ).list();
 		s.createQuery( "from Animal where bodyWeight > 100.001F" ).list();
 		s.createQuery( "from Animal where bodyWeight > 100.001d" ).list();
 		s.createQuery( "from Animal where bodyWeight > 100.001D" ).list();
 		s.createQuery( "from Animal where bodyWeight > .001f" ).list();
 		s.createQuery( "from Animal where bodyWeight > 100e-10" ).list();
 		s.createQuery( "from Animal where bodyWeight > .01E-10" ).list();
 		s.createQuery( "from Animal where bodyWeight > 1e-38" ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNakedPropertyRef() {
 		// note: simply performing syntax and column/table resolution checking in the db
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Animal where bodyWeight = bodyWeight" ).list();
 		s.createQuery( "select bodyWeight from Animal" ).list();
 		s.createQuery( "select max(bodyWeight) from Animal" ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNakedComponentPropertyRef() {
 		// note: simply performing syntax and column/table resolution checking in the db
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Human where name.first = 'Gavin'" ).list();
 		s.createQuery( "select name from Human" ).list();
 		s.createQuery( "select upper(h.name.first) from Human as h" ).list();
 		s.createQuery( "select upper(name.first) from Human" ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNakedImplicitJoins() {
 		// note: simply performing syntax and column/table resolution checking in the db
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Animal where mother.father.id = 1" ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNakedEntityAssociationReference() {
 		// note: simply performing syntax and column/table resolution checking in the db
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Animal where mother = :mother" ).setParameter( "mother", null ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNakedMapIndex() throws Exception {
 		// note: simply performing syntax and column/table resolution checking in the db
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Zoo where mammals['dog'].description like '%black%'" ).list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testInvalidFetchSemantics() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		try {
 			s.createQuery( "select mother from Human a left join fetch a.mother mother" ).list();
 			fail( "invalid fetch semantic allowed!" );
 		}
 		catch( QueryException e ) {
 		}
 
 		try {
 			s.createQuery( "select mother from Human a left join fetch a.mother mother" ).list();
 			fail( "invalid fetch semantic allowed!" );
 		}
 		catch( QueryException e ) {
 		}
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	public void testArithmetic() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Zoo zoo = new Zoo();
 		zoo.setName("Melbourne Zoo");
 		s.persist(zoo);
 		s.createQuery("select 2*2*2*2*(2*2) from Zoo").uniqueResult();
 		s.createQuery("select 2 / (1+1) from Zoo").uniqueResult();
 		int result0 = ( (Integer) s.createQuery("select 2 - (1+1) from Zoo").uniqueResult() ).intValue();
 		int result1 = ( (Integer) s.createQuery("select 2 - 1 + 1 from Zoo").uniqueResult() ).intValue();
 		int result2 = ( (Integer) s.createQuery("select 2 * (1-1) from Zoo").uniqueResult() ).intValue();
 		int result3 = ( (Integer) s.createQuery("select 4 / (2 * 2) from Zoo").uniqueResult() ).intValue();
 		int result4 = ( (Integer) s.createQuery("select 4 / 2 * 2 from Zoo").uniqueResult() ).intValue();
 		int result5 = ( (Integer) s.createQuery("select 2 * (2/2) from Zoo").uniqueResult() ).intValue();
 		int result6 = ( (Integer) s.createQuery("select 2 * (2/2+1) from Zoo").uniqueResult() ).intValue();
 		assertEquals(result0, 0);
 		assertEquals(result1, 2);
 		assertEquals(result2, 0);
 		assertEquals(result3, 1);
 		assertEquals(result4, 4);
 		assertEquals(result5, 2);
 		assertEquals(result6, 4);
 		s.delete(zoo);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testNestedCollectionFetch() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.createQuery("from Animal a left join fetch a.offspring o left join fetch o.offspring where a.mother.id = 1 order by a.description").list();
 		s.createQuery("from Zoo z left join fetch z.animals a left join fetch a.offspring where z.name ='MZ' order by a.description").list();
 		s.createQuery("from Human h left join fetch h.pets a left join fetch a.offspring where h.name.first ='Gavin' order by a.description").list();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SkipForDialect(
 			value = IngresDialect.class,
 			jiraKey = "HHH-4973",
 			comment = "Ingres 9.3 does not support sub-selects in the select list"
 	)
 	@SuppressWarnings( {"unchecked"})
 	public void testSelectClauseSubselect() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Zoo zoo = new Zoo();
 		zoo.setName("Melbourne Zoo");
 		zoo.setMammals( new HashMap() );
 		zoo.setAnimals( new HashMap() );
 		Mammal plat = new Mammal();
 		plat.setBodyWeight( 11f );
 		plat.setDescription( "Platypus" );
 		plat.setZoo(zoo);
 		plat.setSerialNumber("plat123");
 		zoo.getMammals().put("Platypus", plat);
 		zoo.getAnimals().put("plat123", plat);
 		s.persist( plat );
 		s.persist( zoo );
 
 		s.createQuery("select (select max(z.id) from a.zoo z) from Animal a").list();
 		s.createQuery("select (select max(z.id) from a.zoo z where z.name=:name) from Animal a")
 			.setParameter("name", "Melbourne Zoo").list();
 
 		s.delete( plat );
 		s.delete(zoo);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testInitProxy() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Mammal plat = new Mammal();
 		plat.setBodyWeight( 11f );
 		plat.setDescription( "Platypus" );
 		s.persist( plat );
 		s.flush();
 		s.clear();
 		plat = (Mammal) s.load(Mammal.class, plat.getId() );
 		assertFalse( Hibernate.isInitialized(plat) );
 		Object plat2 = s.createQuery("from Animal a").uniqueResult();
 		assertSame( plat, plat2 );
 		assertTrue( Hibernate.isInitialized( plat ) );
 		s.delete( plat );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testSelectClauseImplicitJoin() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Zoo zoo = new Zoo();
 		zoo.setName("The Zoo");
 		zoo.setMammals( new HashMap() );
 		zoo.setAnimals( new HashMap() );
 		Mammal plat = new Mammal();
 		plat.setBodyWeight( 11f );
 		plat.setDescription( "Platypus" );
 		plat.setZoo( zoo );
 		plat.setSerialNumber( "plat123" );
 		zoo.getMammals().put( "Platypus", plat );
 		zoo.getAnimals().put("plat123", plat);
 		s.persist( plat );
 		s.persist(zoo);
 		s.flush();
 		s.clear();
 		Query q = s.createQuery("select distinct a.zoo from Animal a where a.zoo is not null");
 		Type type = q.getReturnTypes()[0];
 		assertTrue( type instanceof ManyToOneType );
 		assertEquals( ( (ManyToOneType) type ).getAssociatedEntityName(), "org.hibernate.test.hql.Zoo" );
 		zoo = (Zoo) q.list().get(0);
 		assertEquals( zoo.getMammals().size(), 1 );
 		assertEquals( zoo.getAnimals().size(), 1 );
 		s.clear();
 		s.delete(plat);
 		s.delete(zoo);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testSelectClauseImplicitJoinWithIterate() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Zoo zoo = new Zoo();
 		zoo.setName("The Zoo");
 		zoo.setMammals( new HashMap() );
 		zoo.setAnimals( new HashMap() );
 		Mammal plat = new Mammal();
 		plat.setBodyWeight( 11f );
 		plat.setDescription( "Platypus" );
 		plat.setZoo(zoo);
 		plat.setSerialNumber("plat123");
 		zoo.getMammals().put("Platypus", plat);
 		zoo.getAnimals().put("plat123", plat);
 		s.persist( plat );
 		s.persist(zoo);
 		s.flush();
 		s.clear();
 		Query q = s.createQuery("select distinct a.zoo from Animal a where a.zoo is not null");
 		Type type = q.getReturnTypes()[0];
 		assertTrue( type instanceof ManyToOneType );
 		assertEquals( ( (ManyToOneType) type ).getAssociatedEntityName(), "org.hibernate.test.hql.Zoo" );
 		zoo = (Zoo) q
 			.iterate().next();
 		assertEquals( zoo.getMammals().size(), 1 );
 		assertEquals( zoo.getAnimals().size(), 1 );
 		s.clear();
 		s.delete(plat);
 		s.delete(zoo);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testComponentOrderBy() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Long id1 = ( Long ) s.save( genSimpleHuman( "John", "Jacob" ) );
 		Long id2 = ( Long ) s.save( genSimpleHuman( "Jingleheimer", "Schmidt" ) );
 
 		s.flush();
 
 		// the component is defined with the firstName column first...
 		List results = s.createQuery( "from Human as h order by h.name" ).list();
 		assertEquals( "Incorrect return count", 2, results.size() );
 
 		Human h1 = ( Human ) results.get( 0 );
 		Human h2 = ( Human ) results.get( 1 );
 
 		assertEquals( "Incorrect ordering", id2, h1.getId() );
 		assertEquals( "Incorrect ordering", id1, h2.getId() );
 
 		s.delete( h1 );
 		s.delete( h2 );
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testOrderedWithCustomColumnReadAndWrite() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		SimpleEntityWithAssociation first = new SimpleEntityWithAssociation();
 		first.setNegatedNumber( 1 );
 		s.save( first );
 		SimpleEntityWithAssociation second = new SimpleEntityWithAssociation();
 		second.setNegatedNumber(2);
 		s.save( second );
 		s.flush();
 
 		// Check order via SQL. Numbers are negated in the DB, so second comes first.
 		List listViaSql = s.createSQLQuery("select id from SIMPLE_1 order by negated_num").list();
 		assertEquals( 2, listViaSql.size() );
 		assertEquals( second.getId().longValue(), ((Number) listViaSql.get( 0 )).longValue() );
 		assertEquals( first.getId().longValue(), ((Number) listViaSql.get( 1 )).longValue() );
 
 		// Check order via HQL. Now first comes first b/c the read negates the DB negation.
 		List listViaHql = s.createQuery("from SimpleEntityWithAssociation order by negatedNumber").list();
 		assertEquals( 2, listViaHql.size() );
 		assertEquals(first.getId(), ((SimpleEntityWithAssociation)listViaHql.get(0)).getId());
 		assertEquals(second.getId(), ((SimpleEntityWithAssociation)listViaHql.get(1)).getId());
 
 		s.delete( first );
 		s.delete( second );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testHavingWithCustomColumnReadAndWrite() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		SimpleEntityWithAssociation first = new SimpleEntityWithAssociation();
 		first.setNegatedNumber(5);
 		first.setName( "simple" );
 		s.save(first);
 		SimpleEntityWithAssociation second = new SimpleEntityWithAssociation();
 		second.setNegatedNumber( 10 );
 		second.setName("simple");
 		s.save(second);
 		SimpleEntityWithAssociation third = new SimpleEntityWithAssociation();
 		third.setNegatedNumber( 20 );
 		third.setName( "complex" );
 		s.save( third );
 		s.flush();
 
 		// Check order via HQL. Now first comes first b/c the read negates the DB negation.
 		Number r = (Number)s.createQuery("select sum(negatedNumber) from SimpleEntityWithAssociation " +
 				"group by name having sum(negatedNumber) < 20").uniqueResult();
 		assertEquals(r.intValue(), 15);
 
 		s.delete(first);
 		s.delete(second);
 		s.delete(third);
 		t.commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testLoadSnapshotWithCustomColumnReadAndWrite() {
 		// Exercises entity snapshot load when select-before-update is true.
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		final double SIZE_IN_KB = 1536d;
 		final double SIZE_IN_MB = SIZE_IN_KB / 1024d;
 		Image image = new Image();
 		image.setName( "picture.gif" );
 		image.setSizeKb( SIZE_IN_KB );
 		s.persist( image );
 		s.flush();
 
 		// Value returned by Oracle is a Types.NUMERIC, which is mapped to a BigDecimalType;
 		// Cast returned value to Number then call Number.doubleValue() so it works on all dialects.
 		Double sizeViaSql = ( (Number)s.createSQLQuery("select size_mb from image").uniqueResult() ).doubleValue();
 		assertEquals(SIZE_IN_MB, sizeViaSql, 0.01d);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		final double NEW_SIZE_IN_KB = 2048d;
 		final double NEW_SIZE_IN_MB = NEW_SIZE_IN_KB / 1024d;
 		image.setSizeKb( NEW_SIZE_IN_KB );
 		s.update( image );
 		s.flush();
 
 		sizeViaSql = ( (Number)s.createSQLQuery("select size_mb from image").uniqueResult() ).doubleValue();
 		assertEquals(NEW_SIZE_IN_MB, sizeViaSql, 0.01d);
 
 		s.delete(image);
 		t.commit();
 		s.close();
 	}
 
 	private Human genSimpleHuman(String fName, String lName) {
 		Human h = new Human();
 		h.setName( new Name( fName, 'X', lName ) );
 
 		return h;
 	}
 
 	@Test
 	public void testCastInSelect() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Animal a = new Animal();
 		a.setBodyWeight(12.4f);
 		a.setDescription("an animal");
 		s.persist(a);
 		Object bodyWeight = s.createQuery("select cast(bodyWeight as integer) from Animal").uniqueResult();
 		assertTrue( Integer.class.isInstance( bodyWeight ) );
 		assertEquals( 12, bodyWeight );
 
 		bodyWeight = s.createQuery("select cast(bodyWeight as big_decimal) from Animal").uniqueResult();
 		assertTrue( BigDecimal.class.isInstance( bodyWeight ) );
 		assertEquals( a.getBodyWeight(), ( (BigDecimal) bodyWeight ).floatValue(), .01 );
 
 		Object literal = s.createQuery("select cast(10000000 as big_integer) from Animal").uniqueResult();
 		assertTrue( BigInteger.class.isInstance( literal ) );
 		assertEquals( BigInteger.valueOf( 10000000 ), literal );
 		s.delete(a);
 		t.commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testNumericExpressionReturnTypes() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Animal a = new Animal();
 		a.setBodyWeight(12.4f);
 		a.setDescription("an animal");
 		s.persist(a);
 
 		Object result;
 
 		// addition ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		result = s.createQuery( "select 1 + 1 from Animal as a" ).uniqueResult();
 		assertTrue( "int + int", Integer.class.isInstance( result ) );
 		assertEquals( 2, result );
 
 		result = s.createQuery( "select 1 + 1L from Animal a" ).uniqueResult();
 		assertTrue( "int + long", Long.class.isInstance( result ) );
 		assertEquals( Long.valueOf( 2 ), result );
 
 		result = s.createQuery( "select 1 + 1BI from Animal a" ).uniqueResult();
 		assertTrue( "int + BigInteger", BigInteger.class.isInstance( result ) );
 		assertEquals( BigInteger.valueOf( 2 ), result );
 
 		result = s.createQuery( "select 1 + 1F from Animal a" ).uniqueResult();
 		assertTrue( "int + float", Float.class.isInstance( result ) );
 		assertEquals( Float.valueOf( 2 ), result );
 
 		result = s.createQuery( "select 1 + 1D from Animal a" ).uniqueResult();
 		assertTrue( "int + double", Double.class.isInstance( result ) );
 		assertEquals( Double.valueOf( 2 ), result );
 
 		result = s.createQuery( "select 1 + 1BD from Animal a" ).uniqueResult();
 		assertTrue( "int + BigDecimal", BigDecimal.class.isInstance( result ) );
 		assertEquals( BigDecimal.valueOf( 2 ), result );
 
 		result = s.createQuery( "select 1F + 1D from Animal a" ).uniqueResult();
 		assertTrue( "float + double", Double.class.isInstance( result ) );
 		assertEquals( Double.valueOf( 2 ), result );
 
 		result = s.createQuery( "select 1F + 1BD from Animal a" ).uniqueResult();
 		assertTrue( "float + BigDecimal", Float.class.isInstance( result ) );
 		assertEquals( Float.valueOf( 2 ), result );
 
 		// subtraction ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		result = s.createQuery( "select 1 - 1 from Animal as a" ).uniqueResult();
 		assertTrue( "int - int", Integer.class.isInstance( result ) );
 		assertEquals( 0, result );
 
 		result = s.createQuery( "select 1 - 1L from Animal a" ).uniqueResult();
 		assertTrue( "int - long", Long.class.isInstance( result ) );
 		assertEquals( Long.valueOf( 0 ), result );
 
 		result = s.createQuery( "select 1 - 1BI from Animal a" ).uniqueResult();
 		assertTrue( "int - BigInteger", BigInteger.class.isInstance( result ) );
 		assertEquals( BigInteger.valueOf( 0 ), result );
 
 		result = s.createQuery( "select 1 - 1F from Animal a" ).uniqueResult();
 		assertTrue( "int - float", Float.class.isInstance( result ) );
 		assertEquals( Float.valueOf( 0 ), result );
 
 		result = s.createQuery( "select 1 - 1D from Animal a" ).uniqueResult();
 		assertTrue( "int - double", Double.class.isInstance( result ) );
 		assertEquals( Double.valueOf( 0 ), result );
 
 		result = s.createQuery( "select 1 - 1BD from Animal a" ).uniqueResult();
 		assertTrue( "int - BigDecimal", BigDecimal.class.isInstance( result ) );
 		assertEquals( BigDecimal.valueOf( 0 ), result );
 
 		result = s.createQuery( "select 1F - 1D from Animal a" ).uniqueResult();
 		assertTrue( "float - double", Double.class.isInstance( result ) );
 		assertEquals( Double.valueOf( 0 ), result );
 
 		result = s.createQuery( "select 1F - 1BD from Animal a" ).uniqueResult();
 		assertTrue( "float - BigDecimal", Float.class.isInstance( result ) );
 		assertEquals( Float.valueOf( 0 ), result );
 
 		// multiplication ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		result = s.createQuery( "select 1 * 1 from Animal as a" ).uniqueResult();
 		assertTrue( "int * int", Integer.class.isInstance( result ) );
 		assertEquals( 1, result );
 
 		result = s.createQuery( "select 1 * 1L from Animal a" ).uniqueResult();
 		assertTrue( "int * long", Long.class.isInstance( result ) );
 		assertEquals( Long.valueOf( 1 ), result );
 
 		result = s.createQuery( "select 1 * 1BI from Animal a" ).uniqueResult();
 		assertTrue( "int * BigInteger", BigInteger.class.isInstance( result ) );
 		assertEquals( BigInteger.valueOf( 1 ), result );
 
 		result = s.createQuery( "select 1 * 1F from Animal a" ).uniqueResult();
 		assertTrue( "int * float", Float.class.isInstance( result ) );
 		assertEquals( Float.valueOf( 1 ), result );
 
 		result = s.createQuery( "select 1 * 1D from Animal a" ).uniqueResult();
 		assertTrue( "int * double", Double.class.isInstance( result ) );
 		assertEquals( Double.valueOf( 1 ), result );
 
 		result = s.createQuery( "select 1 * 1BD from Animal a" ).uniqueResult();
 		assertTrue( "int * BigDecimal", BigDecimal.class.isInstance( result ) );
 		assertEquals( BigDecimal.valueOf( 1 ), result );
 
 		s.delete(a);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testAliases() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Animal a = new Animal();
 		a.setBodyWeight(12.4f);
 		a.setDescription("an animal");
 		s.persist(a);
 		String[] aliases1 = s.createQuery("select a.bodyWeight as abw, a.description from Animal a").getReturnAliases();
 		assertEquals( aliases1[0], "abw" );
 		assertEquals(aliases1[1], "1");
 		String[] aliases2 = s.createQuery("select count(*), avg(a.bodyWeight) as avg from Animal a").getReturnAliases();
 		assertEquals( aliases2[0], "0" );
 		assertEquals(aliases2[1], "avg");
 		s.delete(a);
 		t.commit();
 		s.close();
 	}
 
 	@Test
     @SkipForDialect(
             value = CUBRIDDialect.class,
             comment = "As of version 8.4.1 CUBRID does not support temporary tables." +
                     " This test somehow calls MultiTableDeleteExecutor which raises an" +
                     " exception saying 'cannot doAfterTransactionCompletion multi-table" +
                     " deletes using dialect not supporting temp tables'."
     )
 	public void testParameterMixing() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.createQuery( "from Animal a where a.description = ? and a.bodyWeight = ? or a.bodyWeight = :bw" )
 				.setString( 0, "something" )
 				.setFloat( 1, 12345f )
 				.setFloat( "bw", 123f )
 				.list();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testOrdinalParameters() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.createQuery( "from Animal a where a.description = ? and a.bodyWeight = ?" )
 				.setString( 0, "something" )
 				.setFloat( 1, 123f )
 				.list();
 		s.createQuery( "from Animal a where a.bodyWeight in (?, ?)" )
 				.setFloat( 0, 999f )
 				.setFloat( 1, 123f )
 				.list();
 		t.commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testIndexParams() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.createQuery( "from Zoo zoo where zoo.mammals[:name] = :id" )
 			.setParameter( "name", "Walrus" )
 			.setParameter( "id", Long.valueOf( 123 ) )
 			.list();
 		s.createQuery("from Zoo zoo where zoo.mammals[:name].bodyWeight > :w")
 			.setParameter("name", "Walrus")
 			.setParameter("w", new Float(123.32))
 			.list();
 		s.createQuery("from Zoo zoo where zoo.animals[:sn].mother.bodyWeight < :mw")
 			.setParameter("sn", "ant-123")
 			.setParameter("mw", new Float(23.32))
 			.list();
 		/*s.createQuery("from Zoo zoo where zoo.animals[:sn].description like :desc and zoo.animals[:sn].bodyWeight > :wmin and zoo.animals[:sn].bodyWeight < :wmax")
 			.setParameter("sn", "ant-123")
 			.setParameter("desc", "%big%")
 			.setParameter("wmin", new Float(123.32))
 			.setParameter("wmax", new Float(167.89))
 			.list();*/
 		/*s.createQuery("from Human where addresses[:type].city = :city and addresses[:type].country = :country")
 			.setParameter("type", "home")
 			.setParameter("city", "Melbourne")
 			.setParameter("country", "Australia")
 			.list();*/
 		t.commit();
 		s.close();
 	}
 
 	@Test
     @SkipForDialect( value = SybaseASE15Dialect.class, jiraKey = "HHH-6424")
-	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	public void testAggregation() {
 		Session s = openSession();
 		s.beginTransaction();
 		Human h = new Human();
 		h.setBodyWeight( (float) 74.0 );
 		h.setHeightInches(120.5);
 		h.setDescription("Me");
 		h.setName( new Name("Gavin", 'A', "King") );
 		h.setNickName("Oney");
 		s.persist(h);
 		Double sum = (Double) s.createQuery("select sum(h.bodyWeight) from Human h").uniqueResult();
 		Double avg = (Double) s.createQuery("select avg(h.heightInches) from Human h").uniqueResult();	// uses custom read and write for column
 		assertEquals(sum.floatValue(), 74.0, 0.01);
 		assertEquals(avg.doubleValue(), 120.5, 0.01);
 		Long id = (Long) s.createQuery("select max(a.id) from Animal a").uniqueResult();
 		assertNotNull( id );
 		s.delete( h );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		h = new Human();
 		h.setFloatValue( 2.5F );
 		h.setIntValue( 1 );
 		s.persist( h );
 		Human h2 = new Human();
 		h2.setFloatValue( 2.5F );
 		h2.setIntValue( 2 );
 		s.persist( h2 );
 		Object[] results = (Object[]) s.createQuery( "select sum(h.floatValue), avg(h.floatValue), sum(h.intValue), avg(h.intValue) from Human h" )
 				.uniqueResult();
 		// spec says sum() on a float or double value should result in double
 		assertTrue( Double.class.isInstance( results[0] ) );
 		assertEquals( 5D, results[0] );
 		// avg() should return a double
 		assertTrue( Double.class.isInstance( results[1] ) );
 		assertEquals( 2.5D, results[1] );
 		// spec says sum() on short, int or long should result in long
 		assertTrue( Long.class.isInstance( results[2] ) );
 		assertEquals( 3L, results[2] );
 		// avg() should return a double
 		assertTrue( Double.class.isInstance( results[3] ) );
 		if (getDialect() instanceof SQLServer2008Dialect) assertEquals( 1.0D, results[3] );
 		else assertEquals( 1.5D, results[3] );
 		s.delete(h);
 		s.delete(h2);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSelectClauseCase() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Human h = new Human();
 		h.setBodyWeight( (float) 74.0 );
 		h.setHeightInches( 120.5 );
 		h.setDescription("Me");
 		h.setName( new Name("Gavin", 'A', "King") );
 		h.setNickName("Oney");
 		s.persist(h);
 		String name = (String) s.createQuery("select case nickName when 'Oney' then 'gavin' when 'Turin' then 'christian' else nickName end from Human").uniqueResult();
 		assertEquals(name, "gavin");
 		String result = (String) s.createQuery("select case when bodyWeight > 100 then 'fat' else 'skinny' end from Human").uniqueResult();
 		assertEquals(result, "skinny");
 		s.delete(h);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SkipForDialect(
 			value = IngresDialect.class,
 			jiraKey = "HHH-4976",
 			comment = "Ingres 9.3 does not support sub-selects in the select list"
 	)
 	public void testImplicitPolymorphism() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Product product = new Product();
 		product.setDescription( "My Product" );
 		product.setNumberAvailable( 10 );
 		product.setPrice( new BigDecimal( 123 ) );
 		product.setProductId( "4321" );
 		s.save( product );
 
 		List list = s.createQuery("from java.lang.Comparable").list();
 		assertEquals( list.size(), 0 );
 
 		list = s.createQuery("from java.lang.Object").list();
 		assertEquals( list.size(), 1 );
 
 		s.delete(product);
 
 		list = s.createQuery("from java.lang.Object").list();
 		assertEquals( list.size(), 0 );
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCoalesce() {
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 		session.createQuery("from Human h where coalesce(h.nickName, h.name.first, h.name.last) = 'max'").list();
 		session.createQuery("select nullif(nickName, '1e1') from Human").list();
 		txn.commit();
 		session.close();
 	}
 
 	@Test
 	public void testStr() {
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 		Animal an = new Animal();
 		an.setBodyWeight(123.45f);
 		session.persist( an );
 		String str = (String) session.createQuery("select str(an.bodyWeight) from Animal an where str(an.bodyWeight) like '%1%'").uniqueResult();
 		if ( getDialect() instanceof DB2Dialect ) {
 			assertTrue( str.startsWith("1.234") );
 		}
 		else //noinspection deprecation
 			if ( getDialect() instanceof SybaseDialect || getDialect() instanceof Sybase11Dialect || getDialect() instanceof SybaseASE15Dialect || getDialect() instanceof SybaseAnywhereDialect || getDialect() instanceof SQLServerDialect ) {
 			// str(val) on sybase assumes a default of 10 characters with no decimal point or decimal values
 			// str(val) on sybase result is right-justified
 			assertEquals( str.length(), 10 );
 			assertTrue( str.endsWith("123") );
 			str = (String) session.createQuery("select str(an.bodyWeight, 8, 3) from Animal an where str(an.bodyWeight, 8, 3) like '%1%'").uniqueResult();
 			assertEquals( str.length(), 8 );
 			assertTrue( str.endsWith( "123.450" ) );
 		}
 		else {
 			assertTrue( str.startsWith("123.4") );
 		}
 
 		//noinspection deprecation
 		if ( ! ( getDialect() instanceof SybaseDialect ) && ! ( getDialect() instanceof Sybase11Dialect ) && ! ( getDialect() instanceof SybaseASE15Dialect ) && ! ( getDialect() instanceof SybaseAnywhereDialect ) && ! ( getDialect() instanceof SQLServerDialect ) ) {
 			// In TransactSQL (the variant spoken by Sybase and SQLServer), the str() function
 			// is explicitly intended for numeric values only...
 			String dateStr1 = (String) session.createQuery("select str(current_date) from Animal").uniqueResult();
 			String dateStr2 = (String) session.createQuery("select str(year(current_date))||'-'||str(month(current_date))||'-'||str(day(current_date)) from Animal").uniqueResult();
 			System.out.println(dateStr1 + '=' + dateStr2);
 			if ( ! ( getDialect() instanceof Oracle8iDialect ) ) { //Oracle renders the name of the month :(
 				String[] dp1 = StringHelper.split("-", dateStr1);
 				String[] dp2 = StringHelper.split( "-", dateStr2 );
 				for (int i=0; i<3; i++) {
 					if ( dp1[i].startsWith( "0" ) ) {
 						dp1[i] = dp1[i].substring( 1 );
 					}
 					assertEquals( dp1[i], dp2[i] );
 				}
 			}
 		}
 		session.delete(an);
 		txn.commit();
 		session.close();
 	}
 
 	@Test
 	@SkipForDialect( value = { MySQLDialect.class, DB2Dialect.class } )
 	public void testCast() {
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 		session.createQuery("from Human h where h.nickName like 'G%'").list();
 		session.createQuery("from Animal a where cast(a.bodyWeight as string) like '1.%'").list();
 		session.createQuery("from Animal a where cast(a.bodyWeight as integer) = 1").list();
 		txn.commit();
 		session.close();
 	}
 
 	@Test
 	public void testExtract() {
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 		session.createQuery("select second(current_timestamp()), minute(current_timestamp()), hour(current_timestamp()) from Mammal m").list();
 		session.createQuery("select day(m.birthdate), month(m.birthdate), year(m.birthdate) from Mammal m").list();
 		if ( !(getDialect() instanceof DB2Dialect) ) { //no ANSI extract
 			session.createQuery("select extract(second from current_timestamp()), extract(minute from current_timestamp()), extract(hour from current_timestamp()) from Mammal m").list();
 			session.createQuery("select extract(day from m.birthdate), extract(month from m.birthdate), extract(year from m.birthdate) from Mammal m").list();
 		}
 		txn.commit();
 		session.close();
 	}
 
 	@Test
 	@SkipForDialect(
 			value = IngresDialect.class,
 			jiraKey = "HHH-4976",
 			comment = "Ingres 9.3 does not support sub-selects in the select list"
 	)
 	public void testOneToManyFilter() throws Throwable {
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 
 		Product product = new Product();
 		product.setDescription( "My Product" );
 		product.setNumberAvailable( 10 );
 		product.setPrice( new BigDecimal( 123 ) );
 		product.setProductId( "4321" );
 		session.save( product );
 
 		Customer customer = new Customer();
 		customer.setCustomerId( "123456789" );
 		customer.setName( "My customer" );
 		customer.setAddress( "somewhere" );
 		session.save( customer );
 
 		Order order = customer.generateNewOrder( new BigDecimal( 1234 ) );
 		session.save( order );
 
 		LineItem li = order.generateLineItem( product, 5 );
 		session.save( li );
 
 		session.flush();
 
 		assertEquals( session.createFilter( customer.getOrders(), "" ).list().size(), 1 );
 
 		assertEquals( session.createFilter( order.getLineItems(), "" ).list().size(), 1 );
 		assertEquals( session.createFilter( order.getLineItems(), "where this.quantity > :quantity" ).setInteger( "quantity", 5 ).list().size(), 0 );
 
 		session.delete(li);
 		session.delete(order);
 		session.delete(product);
 		session.delete(customer);
 		txn.commit();
 		session.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testManyToManyFilter() throws Throwable {
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 
 		Human human = new Human();
 		human.setName( new Name( "Steve", 'L', "Ebersole" ) );
 		session.save( human );
 
 		Human friend = new Human();
 		friend.setName( new Name( "John", 'Q', "Doe" ) );
 		friend.setBodyWeight( 11.0f );
 		session.save( friend );
 
 		human.setFriends( new ArrayList() );
 		friend.setFriends( new ArrayList() );
 		human.getFriends().add( friend );
 		friend.getFriends().add( human );
 
 		session.flush();
 
 		assertEquals( session.createFilter( human.getFriends(), "" ).list().size(), 1 );
 		assertEquals( session.createFilter( human.getFriends(), "where this.bodyWeight > ?" ).setFloat( 0, 10f ).list().size(), 1 );
 		assertEquals( session.createFilter( human.getFriends(), "where this.bodyWeight < ?" ).setFloat( 0, 10f ).list().size(), 0 );
 
 		session.delete(human);
 		session.delete(friend);
 
 		txn.commit();
 		session.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testFilterWithCustomColumnReadAndWrite() {
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 
 		Human human = new Human();
 		human.setName( new Name( "Steve", 'L', "Ebersole" ) );
 		human.setHeightInches( 73d );
 		session.save( human );
 
 		Human friend = new Human();
 		friend.setName( new Name( "John", 'Q', "Doe" ) );
 		friend.setHeightInches( 50d );
 		session.save( friend );
 
 		human.setFriends( new ArrayList() );
 		friend.setFriends( new ArrayList() );
 		human.getFriends().add( friend );
 		friend.getFriends().add( human );
 
 		session.flush();
 
 		assertEquals( session.createFilter( human.getFriends(), "" ).list().size(), 1 );
 		assertEquals( session.createFilter( human.getFriends(), "where this.heightInches < ?" ).setDouble( 0, 51d ).list().size(), 1 );
 		assertEquals(
 				session.createFilter( human.getFriends(), "where this.heightInches > ?" )
 						.setDouble( 0, 51d )
 						.list()
 						.size(), 0
 		);
 		assertEquals(
 				session.createFilter( human.getFriends(), "where this.heightInches between 49 and 51" ).list().size(), 1
 		);
 		assertEquals( session.createFilter( human.getFriends(), "where this.heightInches not between 49 and 51" ).list().size(), 0 );
 
 		session.delete( human );
 		session.delete( friend );
 
 		txn.commit();
 		session.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment", "UnusedDeclaration"})
 	public void testSelectExpressions() {
 		createTestBaseData();
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 		Human h = new Human();
 		h.setName( new Name( "Gavin", 'A', "King" ) );
 		h.setNickName("Oney");
 		h.setBodyWeight( 1.0f );
 		session.persist( h );
 		List results = session.createQuery("select 'found', lower(h.name.first) from Human h where lower(h.name.first) = 'gavin'").list();
 		results = session.createQuery("select 'found', lower(h.name.first) from Human h where concat(h.name.first, ' ', h.name.initial, ' ', h.name.last) = 'Gavin A King'").list();
 		results = session.createQuery("select 'found', lower(h.name.first) from Human h where h.name.first||' '||h.name.initial||' '||h.name.last = 'Gavin A King'").list();
 		results = session.createQuery("select a.bodyWeight + m.bodyWeight from Animal a join a.mother m").list();
 		results = session.createQuery("select 2.0 * (a.bodyWeight + m.bodyWeight) from Animal a join a.mother m").list();
 		results = session.createQuery("select sum(a.bodyWeight + m.bodyWeight) from Animal a join a.mother m").list();
 		results = session.createQuery("select sum(a.mother.bodyWeight * 2.0) from Animal a").list();
 		results = session.createQuery("select concat(h.name.first, ' ', h.name.initial, ' ', h.name.last) from Human h").list();
 		results = session.createQuery("select h.name.first||' '||h.name.initial||' '||h.name.last from Human h").list();
 		results = session.createQuery("select nickName from Human").list();
 		results = session.createQuery("select lower(nickName) from Human").list();
 		results = session.createQuery("select abs(bodyWeight*-1) from Human").list();
 		results = session.createQuery("select upper(h.name.first||' ('||h.nickName||')') from Human h").list();
 		results = session.createQuery("select abs(a.bodyWeight-:param) from Animal a").setParameter("param", new Float(2.0)).list();
 		results = session.createQuery("select abs(:param - a.bodyWeight) from Animal a").setParameter("param", new Float(2.0)).list();
 		results = session.createQuery("select lower(upper('foo')) from Animal").list();
 		results = session.createQuery("select lower(upper('foo') || upper('bar')) from Animal").list();
 		results = session.createQuery("select sum(abs(bodyWeight - 1.0) * abs(length('ffobar')-3)) from Animal").list();
 		session.delete(h);
 		txn.commit();
 		session.close();
 		destroyTestBaseData();
 	}
 
 	private void createTestBaseData() {
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 
 		Mammal m1 = new Mammal();
 		m1.setBodyWeight( 11f );
 		m1.setDescription( "Mammal #1" );
 
 		session.save( m1 );
 
 		Mammal m2 = new Mammal();
 		m2.setBodyWeight( 9f );
 		m2.setDescription( "Mammal #2" );
 		m2.setMother( m1 );
 
 		session.save( m2 );
 
 		txn.commit();
 		session.close();
 
 		createdAnimalIds.add( m1.getId() );
 		createdAnimalIds.add( m2.getId() );
 	}
 
 	private void destroyTestBaseData() {
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 
 		for ( Long createdAnimalId : createdAnimalIds ) {
 			Animal animal = (Animal) session.load( Animal.class, createdAnimalId );
 			session.delete( animal );
 		}
 
 		txn.commit();
 		session.close();
 
 		createdAnimalIds.clear();
 	}
 
 	@Test
 	public void testImplicitJoin() throws Exception {
 		Session session = openSession();
 		Transaction t = session.beginTransaction();
 		Animal a = new Animal();
 		a.setBodyWeight(0.5f);
 		a.setBodyWeight( 1.5f );
 		Animal b = new Animal();
 		Animal mother = new Animal();
 		mother.setBodyWeight(10.0f);
 		mother.addOffspring( a );
 		mother.addOffspring( b );
 		session.persist( a );
 		session.persist( b );
 		session.persist( mother );
 		List list = session.createQuery("from Animal a where a.mother.bodyWeight < 2.0 or a.mother.bodyWeight > 9.0").list();
 		assertEquals( list.size(), 2 );
 		list = session.createQuery("from Animal a where a.mother.bodyWeight > 2.0 and a.mother.bodyWeight > 9.0").list();
 		assertEquals( list.size(), 2 );
 		session.delete(b);
 		session.delete(a);
 		session.delete(mother);
 		t.commit();
 		session.close();
 	}
 
 	@Test
 	public void testFromOnly() throws Exception {
 		createTestBaseData();
 		Session session = openSession();
 		List results = session.createQuery( "from Animal" ).list();
 		assertEquals( "Incorrect result size", 2, results.size() );
 		assertTrue( "Incorrect result return type", results.get( 0 ) instanceof Animal );
 		session.close();
 		destroyTestBaseData();
 	}
 
 	@Test
 	public void testSimpleSelect() throws Exception {
 		createTestBaseData();
 		Session session = openSession();
 		List results = session.createQuery( "select a from Animal as a" ).list();
 		assertEquals( "Incorrect result size", 2, results.size() );
 		assertTrue( "Incorrect result return type", results.get( 0 ) instanceof Animal );
 		session.close();
 		destroyTestBaseData();
 	}
 
 	@Test
 	public void testEntityPropertySelect() throws Exception {
 		createTestBaseData();
 		Session session = openSession();
 		List results = session.createQuery( "select a.mother from Animal as a" ).list();
 		assertTrue( "Incorrect result return type", results.get( 0 ) instanceof Animal );
 		session.close();
 		destroyTestBaseData();
 	}
 
 	@Test
 	public void testWhere() throws Exception {
 		createTestBaseData();
 
 		Session session = openSession();
 		List results = session.createQuery( "from Animal an where an.bodyWeight > 10" ).list();
 		assertEquals( "Incorrect result size", 1, results.size() );
 
 		results = session.createQuery( "from Animal an where not an.bodyWeight > 10" ).list();
 		assertEquals( "Incorrect result size", 1, results.size() );
 
 		results = session.createQuery( "from Animal an where an.bodyWeight between 0 and 10" ).list();
 		assertEquals( "Incorrect result size", 1, results.size() );
 
 		results = session.createQuery( "from Animal an where an.bodyWeight not between 0 and 10" ).list();
 		assertEquals( "Incorrect result size", 1, results.size() );
 
 		results = session.createQuery( "from Animal an where sqrt(an.bodyWeight)/2 > 10" ).list();
 		assertEquals( "Incorrect result size", 0, results.size() );
 
 		results = session.createQuery( "from Animal an where (an.bodyWeight > 10 and an.bodyWeight < 100) or an.bodyWeight is null" ).list();
 		assertEquals( "Incorrect result size", 1, results.size() );
 
 		session.close();
 
 		destroyTestBaseData();
 	}
 
 	@Test
 	public void testEntityFetching() throws Exception {
 		createTestBaseData();
 
 		Session session = openSession();
 
 		List results = session.createQuery( "from Animal an join fetch an.mother" ).list();
 		assertEquals( "Incorrect result size", 1, results.size() );
 		assertTrue( "Incorrect result return type", results.get( 0 ) instanceof Animal );
 		Animal mother = ( ( Animal ) results.get( 0 ) ).getMother();
 		assertTrue( "fetch uninitialized", mother != null && Hibernate.isInitialized( mother ) );
 
 		results = session.createQuery( "select an from Animal an join fetch an.mother" ).list();
 		assertEquals( "Incorrect result size", 1, results.size() );
 		assertTrue( "Incorrect result return type", results.get( 0 ) instanceof Animal );
 		mother = ( ( Animal ) results.get( 0 ) ).getMother();
 		assertTrue( "fetch uninitialized", mother != null && Hibernate.isInitialized( mother ) );
 
 		session.close();
 
 		destroyTestBaseData();
 	}
 
 	@Test
 	public void testCollectionFetching() throws Exception {
 		createTestBaseData();
 
 		Session session = openSession();
 		List results = session.createQuery( "from Animal an join fetch an.offspring" ).list();
 		assertEquals( "Incorrect result size", 1, results.size() );
 		assertTrue( "Incorrect result return type", results.get( 0 ) instanceof Animal );
 		Collection os = ( ( Animal ) results.get( 0 ) ).getOffspring();
 		assertTrue( "fetch uninitialized", os != null && Hibernate.isInitialized( os ) && os.size() == 1 );
 
 		results = session.createQuery( "select an from Animal an join fetch an.offspring" ).list();
 		assertEquals( "Incorrect result size", 1, results.size() );
 		assertTrue( "Incorrect result return type", results.get( 0 ) instanceof Animal );
 		os = ( ( Animal ) results.get( 0 ) ).getOffspring();
 		assertTrue( "fetch uninitialized", os != null && Hibernate.isInitialized( os ) && os.size() == 1 );
 
 		session.close();
 
 		destroyTestBaseData();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testJoinFetchedCollectionOfJoinedSubclass() throws Exception {
 		Mammal mammal = new Mammal();
 		mammal.setDescription( "A Zebra" );
 		Zoo zoo = new Zoo();
 		zoo.setName( "A Zoo" );
 		zoo.getMammals().put( "zebra", mammal );
 		mammal.setZoo( zoo );
 
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 		session.save( mammal );
 		session.save( zoo );
 		txn.commit();
 
 		session = openSession();
 		txn = session.beginTransaction();
 		List results = session.createQuery( "from Zoo z join fetch z.mammals" ).list();
 		assertEquals( "Incorrect result size", 1, results.size() );
 		assertTrue( "Incorrect result return type", results.get( 0 ) instanceof Zoo );
 		Zoo zooRead = ( Zoo ) results.get( 0 );
 		assertEquals( zoo, zooRead );
 		assertTrue( Hibernate.isInitialized( zooRead.getMammals() ) );
 		Mammal mammalRead = ( Mammal ) zooRead.getMammals().get( "zebra" );
 		assertEquals( mammal, mammalRead );
 		session.delete( mammalRead );
 		session.delete( zooRead );
 		txn.commit();
 		session.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testJoinedCollectionOfJoinedSubclass() throws Exception {
 		Mammal mammal = new Mammal();
 		mammal.setDescription( "A Zebra" );
 		Zoo zoo = new Zoo();
 		zoo.setName( "A Zoo" );
 		zoo.getMammals().put( "zebra", mammal );
 		mammal.setZoo( zoo );
 
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 		session.save( mammal );
 		session.save( zoo );
 		txn.commit();
 
 		session = openSession();
 		txn = session.beginTransaction();
 		List results = session.createQuery( "from Zoo z join z.mammals m" ).list();
 		assertEquals( "Incorrect result size", 1, results.size() );
 		assertTrue( "Incorrect result return type", results.get( 0 ) instanceof Object[] );
 		Object[] resultObjects = ( Object[] ) results.get( 0 );
 		Zoo zooRead = ( Zoo ) resultObjects[ 0 ];
 		Mammal mammalRead = ( Mammal ) resultObjects[ 1 ];
 		assertEquals( zoo, zooRead );
 		assertEquals( mammal, mammalRead );
 		session.delete( mammalRead );
 		session.delete( zooRead );
 		txn.commit();
 		session.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testJoinedCollectionOfJoinedSubclassProjection() throws Exception {
 		Mammal mammal = new Mammal();
 		mammal.setDescription( "A Zebra" );
 		Zoo zoo = new Zoo();
 		zoo.setName( "A Zoo" );
 		zoo.getMammals().put( "zebra", mammal );
 		mammal.setZoo( zoo );
 
 		Session session = openSession();
 		Transaction txn = session.beginTransaction();
 		session.save( mammal );
 		session.save( zoo );
 		txn.commit();
 
 		session = openSession();
 		txn = session.beginTransaction();
 		List results = session.createQuery( "select z, m from Zoo z join z.mammals m" ).list();
 		assertEquals( "Incorrect result size", 1, results.size() );
 		assertTrue( "Incorrect result return type", results.get( 0 ) instanceof Object[] );
 		Object[] resultObjects = ( Object[] ) results.get( 0 );
 		Zoo zooRead = ( Zoo ) resultObjects[ 0 ];
 		Mammal mammalRead = ( Mammal ) resultObjects[ 1 ];
 		assertEquals( zoo, zooRead );
 		assertEquals( mammal, mammalRead );
 		session.delete( mammalRead );
 		session.delete( zooRead );
 		txn.commit();
 		session.close();
 	}
 
 	@Test
 	public void testProjectionQueries() throws Exception {
 		createTestBaseData();
 		Session session = openSession();
 		List results = session.createQuery( "select an.mother.id, max(an.bodyWeight) from Animal an group by an.mother.id" ).list();
 		// mysql returns nulls in this group by
 		assertEquals( "Incorrect result size", 2, results.size() );
 		assertTrue( "Incorrect return type", results.get( 0 ) instanceof Object[] );
 		assertEquals( "Incorrect return dimensions", 2, ( ( Object[] ) results.get( 0 ) ).length );
 		session.close();
 		destroyTestBaseData();
 	}
 
 	@Test
 	public void testStandardFunctions() throws Exception {
 		Session session = openSession();
 		Transaction t = session.beginTransaction();
 		Product p = new Product();
 		p.setDescription( "a product" );
 		p.setPrice( new BigDecimal( 1.0 ) );
 		p.setProductId( "abc123" );
 		session.persist(p);
 		Object[] result = (Object[]) session
 			.createQuery("select current_time(), current_date(), current_timestamp() from Product")
 			.uniqueResult();
 		assertTrue( result[0] instanceof Time );
 		assertTrue( result[1] instanceof Date );
 		assertTrue( result[2] instanceof Timestamp );
 		assertNotNull( result[0] );
 		assertNotNull( result[1] );
 		assertNotNull( result[2] );
 		session.delete(p);
 		t.commit();
 		session.close();
 	}
 
 	@Test
 	public void testDynamicInstantiationQueries() throws Exception {
 		createTestBaseData();
 
 		Session session = openSession();
 
 		List results = session.createQuery( "select new Animal(an.description, an.bodyWeight) from Animal an" ).list();
 		assertEquals( "Incorrect result size", 2, results.size() );
 		assertClassAssignability( results.get( 0 ).getClass(), Animal.class );
 
 		Iterator iter = session.createQuery( "select new Animal(an.description, an.bodyWeight) from Animal an" ).iterate();
 		assertTrue( "Incorrect result size", iter.hasNext() );
 		assertTrue( "Incorrect return type", iter.next() instanceof Animal );
 
 		results = session.createQuery( "select new list(an.description, an.bodyWeight) from Animal an" ).list();
 		assertEquals( "Incorrect result size", 2, results.size() );
 		assertTrue( "Incorrect return type", results.get( 0 ) instanceof List );
 		assertEquals( "Incorrect return type", ( (List) results.get( 0 ) ).size(), 2 );
 
 		results = session.createQuery( "select new list(an.description, an.bodyWeight) from Animal an" ).list();
 		assertEquals( "Incorrect result size", 2, results.size() );
 		assertTrue( "Incorrect return type", results.get( 0 ) instanceof List );
 		assertEquals( "Incorrect return type", ( (List) results.get( 0 ) ).size(), 2 );
 
 		iter = session.createQuery( "select new list(an.description, an.bodyWeight) from Animal an" ).iterate();
 		assertTrue( "Incorrect result size", iter.hasNext() );
 		Object obj = iter.next();
 		assertTrue( "Incorrect return type", obj instanceof List );
 		assertEquals( "Incorrect return type", ( (List) obj ).size(), 2 );
 
 		iter = session.createQuery( "select new list(an.description, an.bodyWeight) from Animal an" ).iterate();
 		assertTrue( "Incorrect result size", iter.hasNext() );
 		obj = iter.next();
 		assertTrue( "Incorrect return type", obj instanceof List );
 		assertEquals( "Incorrect return type", ( (List) obj ).size(), 2 );
 
 		results = session.createQuery( "select new map(an.description, an.bodyWeight) from Animal an" ).list();
 		assertEquals( "Incorrect result size", 2, results.size() );
 		assertTrue( "Incorrect return type", results.get( 0 ) instanceof Map );
 		assertEquals( "Incorrect return type", ( (Map) results.get( 0 ) ).size(), 2 );
 		assertTrue( ( (Map) results.get( 0 ) ).containsKey("0") );
 		assertTrue( ( (Map) results.get( 0 ) ).containsKey("1") );
 
 		results = session.createQuery( "select new map(an.description as descr, an.bodyWeight as bw) from Animal an" ).list();
 		assertEquals( "Incorrect result size", 2, results.size() );
 		assertTrue( "Incorrect return type", results.get( 0 ) instanceof Map );
 		assertEquals( "Incorrect return type", ( (Map) results.get( 0 ) ).size(), 2 );
 		assertTrue( ( (Map) results.get( 0 ) ).containsKey("descr") );
 		assertTrue( ( (Map) results.get( 0 ) ).containsKey("bw") );
 
 		iter = session.createQuery( "select new map(an.description, an.bodyWeight) from Animal an" ).iterate();
 		assertTrue( "Incorrect result size", iter.hasNext() );
 		obj = iter.next();
 		assertTrue( "Incorrect return type", obj instanceof Map );
 		assertEquals( "Incorrect return type", ( (Map) obj ).size(), 2 );
 
 		ScrollableResults sr = session.createQuery( "select new map(an.description, an.bodyWeight) from Animal an" ).scroll();
 		assertTrue( "Incorrect result size", sr.next() );
 		obj = sr.get(0);
 		assertTrue( "Incorrect return type", obj instanceof Map );
 		assertEquals( "Incorrect return type", ( (Map) obj ).size(), 2 );
 		sr.close();
 
 		sr = session.createQuery( "select new Animal(an.description, an.bodyWeight) from Animal an" ).scroll();
 		assertTrue( "Incorrect result size", sr.next() );
 		assertTrue( "Incorrect return type", sr.get(0) instanceof Animal );
 		sr.close();
 
 		// caching...
 		QueryStatistics stats = sessionFactory().getStatistics().getQueryStatistics( "select new Animal(an.description, an.bodyWeight) from Animal an" );
 		results = session.createQuery( "select new Animal(an.description, an.bodyWeight) from Animal an" )
 				.setCacheable( true )
 				.list();
 		assertEquals( "incorrect result size", 2, results.size() );
 		assertClassAssignability( Animal.class, results.get( 0 ).getClass() );
 		long initCacheHits = stats.getCacheHitCount();
 		results = session.createQuery( "select new Animal(an.description, an.bodyWeight) from Animal an" )
 				.setCacheable( true )
 				.list();
 		assertEquals( "dynamic intantiation query not served from cache", initCacheHits + 1, stats.getCacheHitCount() );
 		assertEquals( "incorrect result size", 2, results.size() );
 		assertClassAssignability( Animal.class, results.get( 0 ).getClass() );
 
 		session.close();
 
 		destroyTestBaseData();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testCachedJoinedAndJoinFetchedManyToOne() throws Exception {
 		Animal a = new Animal();
 		a.setDescription( "an animal" );
 
 		Animal mother = new Animal();
 		mother.setDescription( "a mother" );
 		mother.addOffspring( a );
 		a.setMother( mother );
 
 		Animal offspring1 = new Animal();
 		offspring1.setDescription( "offspring1" );
 		a.addOffspring( offspring1 );
 		offspring1.setMother( a );
 
 		Animal offspring2 = new Animal();
 		offspring2.setDescription( "offspring2" );
 		a.addOffspring( offspring2 );
 		offspring2.setMother( a );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.save( mother );
 		s.save( a );
 		s.save( offspring1 );
 		s.save( offspring2 );
 		t.commit();
 		s.close();
 
 		sessionFactory().getCache().evictQueryRegions();
 		sessionFactory().getStatistics().clear();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List list = s.createQuery( "from Animal a left join fetch a.mother" ).setCacheable( true ).list();
 		assertEquals( 0, sessionFactory().getStatistics().getQueryCacheHitCount() );
 		assertEquals( 1, sessionFactory().getStatistics().getQueryCachePutCount() );
 		list = s.createQuery( "select a from Animal a left join fetch a.mother" ).setCacheable( true ).list();
 		assertEquals( 1, sessionFactory().getStatistics().getQueryCacheHitCount() );
 		assertEquals( 1, sessionFactory().getStatistics().getQueryCachePutCount() );
 		list = s.createQuery( "select a, m from Animal a left join a.mother m" ).setCacheable( true ).list();
 		assertEquals( 1, sessionFactory().getStatistics().getQueryCacheHitCount() );
 		assertEquals( 2, sessionFactory().getStatistics().getQueryCachePutCount() );
 		list = s.createQuery( "from Animal" ).list();
 		for(Object obj : list){
 			s.delete( obj );
 		}
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment", "UnusedDeclaration"})
 	public void testCachedJoinedAndJoinFetchedOneToMany() throws Exception {
 		Animal a = new Animal();
 		a.setDescription( "an animal" );
 		Animal mother = new Animal();
 		mother.setDescription( "a mother" );
 		mother.addOffspring( a );
 		a.setMother( mother );
 		Animal offspring1 = new Animal();
 		offspring1.setDescription( "offspring1" );
 		Animal offspring2 = new Animal();
 		offspring1.setDescription( "offspring2" );
 		a.addOffspring( offspring1 );
 		offspring1.setMother( a );
 		a.addOffspring( offspring2 );
 		offspring2.setMother( a );
 
 		sessionFactory().getCache().evictQueryRegions();
 		sessionFactory().getStatistics().clear();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.save( mother );
 		s.save( a );
 		s.save( offspring1 );
 		s.save( offspring2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List list = s.createQuery( "from Animal a left join fetch a.offspring" ).setCacheable( true ).list();
 		assertEquals( 0, sessionFactory().getStatistics().getQueryCacheHitCount() );
 		assertEquals( 1, sessionFactory().getStatistics().getQueryCachePutCount() );
 		list = s.createQuery( "select a from Animal a left join fetch a.offspring" ).setCacheable( true ).list();
 		assertEquals( 1, sessionFactory().getStatistics().getQueryCacheHitCount() );
 		assertEquals( 1, sessionFactory().getStatistics().getQueryCachePutCount() );
 		list = s.createQuery( "select a, o from Animal a left join a.offspring o" ).setCacheable( true ).list();
 		assertEquals( 1, sessionFactory().getStatistics().getQueryCacheHitCount() );
 		assertEquals( 2, sessionFactory().getStatistics().getQueryCachePutCount() );
 		list = s.createQuery( "from Animal" ).list();
 		for ( Object obj : list ) {
 			s.delete( obj );
 		}
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testIllegalMixedTransformerQueries() {
 		Session session = openSession();
 
 		try {
 			getSelectNewQuery( session ).setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP).list();
 			fail("'select new' together with a resulttransformer should result in error!");
 		} catch(QueryException he) {
 			assertTrue(he.getMessage().indexOf("ResultTransformer")==0);
 		}
 
 		try {
 			getSelectNewQuery( session ).setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP).iterate();
 			fail("'select new' together with a resulttransformer should result in error!");
 		} catch(HibernateException he) {
 			assertTrue(he.getMessage().indexOf("ResultTransformer")==0);
 		}
 
 		try {
 			getSelectNewQuery( session ).setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP).scroll();
 			fail("'select new' together with a resulttransformer should result in error!");
 		} catch(HibernateException he) {
 			assertTrue(he.getMessage().indexOf("ResultTransformer")==0);
 		}
 
 		session.close();
 	}
 
 	private Query getSelectNewQuery(Session session) {
 		return session.createQuery( "select new Animal(an.description, an.bodyWeight) from Animal an" );
 	}
 
 	@Test
 	public void testResultTransformerScalarQueries() throws Exception {
 		createTestBaseData();
 
 		String query = "select an.description as description, an.bodyWeight as bodyWeight from Animal an order by bodyWeight desc";
 
 		Session session = openSession();
 
 		List results = session.createQuery( query )
 		.setResultTransformer(Transformers.aliasToBean(Animal.class)).list();
 		assertEquals( "Incorrect result size", results.size(), 2 );
 		assertTrue( "Incorrect return type", results.get(0) instanceof Animal );
 		Animal firstAnimal = (Animal) results.get(0);
 		Animal secondAnimal = (Animal) results.get(1);
 		assertEquals("Mammal #1", firstAnimal.getDescription());
 		assertEquals("Mammal #2", secondAnimal.getDescription());
 		assertFalse(session.contains(firstAnimal));
 		session.close();
 
 		session = openSession();
 
 		Iterator iter = session.createQuery( query )
 	     .setResultTransformer(Transformers.aliasToBean(Animal.class)).iterate();
 		assertTrue( "Incorrect result size", iter.hasNext() );
 		assertTrue( "Incorrect return type", iter.next() instanceof Animal );
 
 		session.close();
 
 		session = openSession();
 
 		ScrollableResults sr = session.createQuery( query )
 	     .setResultTransformer(Transformers.aliasToBean(Animal.class)).scroll();
 		assertTrue( "Incorrect result size", sr.next() );
 		assertTrue( "Incorrect return type", sr.get(0) instanceof Animal );
 		assertFalse( session.contains( sr.get( 0 ) ) );
 		sr.close();
 
 		session.close();
 
 		session = openSession();
 
 		results = session.createQuery( "select a from Animal a, Animal b order by a.id" )
 				.setResultTransformer( DistinctRootEntityResultTransformer.INSTANCE )
 				.list();
 		assertEquals( "Incorrect result size", 2, results.size());
 		assertTrue( "Incorrect return type", results.get(0) instanceof Animal );
 		firstAnimal = (Animal) results.get(0);
 		secondAnimal = (Animal) results.get(1);
 		assertEquals( "Mammal #1", firstAnimal.getDescription() );
 		assertEquals( "Mammal #2", secondAnimal.getDescription() );
 
 		session.close();
 
 		destroyTestBaseData();
 	}
 
 	@Test
 	public void testResultTransformerEntityQueries() throws Exception {
 		createTestBaseData();
 
 		String query = "select an as an from Animal an order by bodyWeight desc";
 
 		Session session = openSession();
 
 		List results = session.createQuery( query )
 		.setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP).list();
 		assertEquals( "Incorrect result size", results.size(), 2 );
 		assertTrue( "Incorrect return type", results.get(0) instanceof Map );
 		Map map = ((Map) results.get(0));
 		assertEquals(1, map.size());
 		Animal firstAnimal = (Animal) map.get("an");
 		map = ((Map) results.get(1));
 		Animal secondAnimal = (Animal) map.get("an");
 		assertEquals( "Mammal #1", firstAnimal.getDescription() );
 		assertEquals("Mammal #2", secondAnimal.getDescription());
 		assertTrue(session.contains(firstAnimal));
 		assertSame( firstAnimal, session.get( Animal.class, firstAnimal.getId() ) );
 		session.close();
 
 		session = openSession();
 
 		Iterator iter = session.createQuery( query )
 	     .setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP).iterate();
 		assertTrue( "Incorrect result size", iter.hasNext() );
 		map = (Map) iter.next();
 		firstAnimal = (Animal) map.get("an");
 		assertEquals( "Mammal #1", firstAnimal.getDescription() );
 		assertTrue( "Incorrect result size", iter.hasNext() );
 
 		session.close();
 
 		session = openSession();
 
 		ScrollableResults sr = session.createQuery( query )
 	     .setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP).scroll();
 		assertTrue( "Incorrect result size", sr.next() );
 		assertTrue( "Incorrect return type", sr.get(0) instanceof Map );
 		assertFalse( session.contains( sr.get( 0 ) ) );
 		sr.close();
 
 		session.close();
 
 		destroyTestBaseData();
 	}
 
 	@Test
 	public void testEJBQLFunctions() throws Exception {
 		Session session = openSession();
 
 		String hql = "from Animal a where a.description = concat('1', concat('2','3'), '4'||'5')||'0'";
 		session.createQuery(hql).list();
 
 		hql = "from Animal a where substring(a.description, 1, 3) = 'cat'";
 		session.createQuery(hql).list();
 
 		hql = "select substring(a.description, 1, 3) from Animal a";
 		session.createQuery(hql).list();
 
 		hql = "from Animal a where lower(a.description) = 'cat'";
 		session.createQuery(hql).list();
 
 		hql = "select lower(a.description) from Animal a";
 		session.createQuery(hql).list();
 
 		hql = "from Animal a where upper(a.description) = 'CAT'";
 		session.createQuery(hql).list();
 
 		hql = "select upper(a.description) from Animal a";
 		session.createQuery(hql).list();
 
 		hql = "from Animal a where length(a.description) = 5";
 		session.createQuery(hql).list();
 
 		hql = "select length(a.description) from Animal a";
 		session.createQuery(hql).list();
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java b/hibernate-core/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java
index fedb1cf891..a9ed92449e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/BulkManipulationTest.java
@@ -1,1378 +1,1373 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
 
 import junit.framework.AssertionFailedError;
 
 import org.hibernate.QueryException;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.dialect.CUBRIDDialect;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.exception.ConstraintViolationException;
 import org.hibernate.id.BulkInsertionCapableIdentifierGenerator;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.testing.DialectChecks;
 import org.hibernate.testing.RequiresDialectFeature;
 import org.hibernate.testing.SkipForDialect;
 import org.hibernate.testing.SkipLog;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.junit.Test;
 
 /**
  * Tests execution of bulk UPDATE/DELETE statements through the new AST parser.
  *
  * @author Steve Ebersole
  */
 public class BulkManipulationTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] {
 				"hql/Animal.hbm.xml",
 		        "hql/Vehicle.hbm.xml",
 		        "hql/KeyManyToOneEntity.hbm.xml",
 		        "hql/Versions.hbm.xml",
 				"hql/FooBarCopy.hbm.xml",
 				"legacy/Multi.hbm.xml",
 				"hql/EntityWithCrazyCompositeKey.hbm.xml",
 				"hql/SimpleEntityWithAssociation.hbm.xml",
 				"hql/BooleanLiteralEntity.hbm.xml",
 				"hql/CompositeIdEntity.hbm.xml"
 		};
 	}
 
 	@Test
 	public void testUpdateWithSubquery() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		// just checking parsing and syntax...
 		s.createQuery( "update Human h set h.bodyWeight = h.bodyWeight + (select count(1) from IntegerVersioned)" ).executeUpdate();
 		s.createQuery( "update Human h set h.bodyWeight = h.bodyWeight + (select count(1) from IntegerVersioned) where h.description = 'abc'" ).executeUpdate();
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testDeleteNonExistentEntity() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		try {
 			s.createQuery( "delete NonExistentEntity" ).executeUpdate();
 			fail( "no exception thrown" );
 		}
 		catch( QueryException ignore ) {
 		}
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testUpdateNonExistentEntity() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		try {
 			s.createQuery( "update NonExistentEntity e set e.someProp = ?" ).executeUpdate();
 			fail( "no exception thrown" );
 		}
 		catch( QueryException e ) {
 		}
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
     @SkipForDialect(
             value = CUBRIDDialect.class,
             comment = "As of verion 8.4.1 CUBRID doesn't support temporary tables. This test fails with" +
                     "HibernateException: cannot doAfterTransactionCompletion multi-table deletes using dialect not supporting temp tables"
     )
 	public void testTempTableGenerationIsolation() throws Throwable{
 		Session s = openSession();
 		s.beginTransaction();
 
 		Truck truck = new Truck();
 		truck.setVin( "123t" );
 		truck.setOwner( "Steve" );
 		s.save( truck );
 
 		// manually flush the session to ensure the insert happens
 		s.flush();
 
 		// now issue a bulk delete against Car which should force the temp table to be
 		// created.  we need to test to ensure that this does not cause the transaction
 		// to be committed...
 		s.createQuery( "delete from Vehicle" ).executeUpdate();
 
 		s.getTransaction().rollback();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List list = s.createQuery( "from Car" ).list();
 		assertEquals( "temp table gen caused premature commit", 0, list.size() );
 		s.createQuery( "delete from Car" ).executeUpdate();
 		s.getTransaction().rollback();
 		s.close();
 	}
 
 	@Test
 	public void testBooleanHandling() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// currently, we need the three different binds because they are different underlying types...
 		int count = s.createQuery( "update BooleanLiteralEntity set yesNoBoolean = :b1, trueFalseBoolean = :b2, zeroOneBoolean = :b3" )
 				.setBoolean( "b1", true )
 				.setBoolean( "b2", true )
 				.setBoolean( "b3", true )
 				.executeUpdate();
 		assertEquals( 1, count );
 		BooleanLiteralEntity entity = ( BooleanLiteralEntity ) s.createQuery( "from BooleanLiteralEntity" ).uniqueResult();
 		assertTrue( entity.isYesNoBoolean() );
 		assertTrue( entity.isTrueFalseBoolean() );
 		assertTrue( entity.isZeroOneBoolean() );
 		s.clear();
 
 		count = s.createQuery( "update BooleanLiteralEntity set yesNoBoolean = true, trueFalseBoolean = true, zeroOneBoolean = true" )
 				.executeUpdate();
 		assertEquals( 1, count );
 		entity = ( BooleanLiteralEntity ) s.createQuery( "from BooleanLiteralEntity" ).uniqueResult();
 		assertTrue( entity.isYesNoBoolean() );
 		assertTrue( entity.isTrueFalseBoolean() );
 		assertTrue( entity.isZeroOneBoolean() );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testSimpleInsert() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		s.createQuery( "insert into Pickup (id, vin, owner) select id, vin, owner from Car" ).executeUpdate();
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createQuery( "delete Vehicle" ).executeUpdate();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testSimpleNativeSQLInsert() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		List l = s.createQuery("from Vehicle").list();
 		assertEquals(l.size(),4);
 
 		s.createSQLQuery( "insert into Pickup (id, vin, owner) select id, vin, owner from Car" ).executeUpdate();
 
 		l = s.createQuery("from Vehicle").list();
 		assertEquals( l.size(), 5 );
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createSQLQuery( "delete from Truck" ).executeUpdate();
 
 		l = s.createQuery("from Vehicle").list();
 		assertEquals(l.size(),4);
 
 		Car c = (Car) s.createQuery( "from Car where owner = 'Kirsten'" ).uniqueResult();
 		c.setOwner( "NotKirsten" );
 		assertEquals( 0, s.getNamedQuery( "native-delete-car" ).setString( 0, "Kirsten" ).executeUpdate() );
 		assertEquals( 1, s.getNamedQuery( "native-delete-car" ).setString( 0, "NotKirsten" ).executeUpdate() );
 
 
 		assertEquals(
 				0, s.createSQLQuery( "delete from SUV where owner = :owner" )
 				.setString( "owner", "NotThere" )
 				.executeUpdate()
 		);
 		assertEquals(
 				1, s.createSQLQuery( "delete from SUV where owner = :owner" )
 				.setString( "owner", "Joe" )
 				.executeUpdate()
 		);
 		s.createSQLQuery( "delete from Pickup" ).executeUpdate();
 
 		l = s.createQuery("from Vehicle").list();
 		assertEquals(l.size(),0);
 
 
 		t.commit();
 		s.close();
 
 
 		data.cleanup();
 	}
 	
 	@Test
 	public void testInsertWithManyToOne() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		s.createQuery( "insert into Animal (description, bodyWeight, mother) select description, bodyWeight, mother from Human" ).executeUpdate();
 
 		t.commit();
 		t = s.beginTransaction();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testInsertWithMismatchedTypes() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		try {
 			s.createQuery( "insert into Pickup (owner, vin, id) select id, vin, owner from Car" ).executeUpdate();
 			fail( "mismatched types did not error" );
 		}
 		catch( QueryException e ) {
 			// expected result
 		}
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createQuery( "delete Vehicle" ).executeUpdate();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testInsertIntoSuperclassPropertiesFails() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		try {
 			s.createQuery( "insert into Human (id, bodyWeight) select id, bodyWeight from Lizard" ).executeUpdate();
 			fail( "superclass prop insertion did not error" );
 		}
 		catch( QueryException e ) {
 			// expected result
 		}
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createQuery( "delete Animal where mother is not null" ).executeUpdate();
 		s.createQuery( "delete Animal where father is not null" ).executeUpdate();
 		s.createQuery( "delete Animal" ).executeUpdate();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testInsertAcrossMappedJoinFails() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		try {
 			s.createQuery( "insert into Joiner (name, joinedName) select vin, owner from Car" ).executeUpdate();
 			fail( "mapped-join insertion did not error" );
 		}
 		catch( QueryException e ) {
 			// expected result
 		}
 
 		t.commit();
 		t = s.beginTransaction();
 
 		s.createQuery( "delete Joiner" ).executeUpdate();
 		s.createQuery( "delete Vehicle" ).executeUpdate();
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	protected boolean supportsBulkInsertIdGeneration(Class entityClass) {
 		EntityPersister persister = sessionFactory().getEntityPersister( entityClass.getName() );
 		IdentifierGenerator generator = persister.getIdentifierGenerator();
 		return BulkInsertionCapableIdentifierGenerator.class.isInstance( generator )
 				&& BulkInsertionCapableIdentifierGenerator.class.cast( generator ).supportsBulkInsertionIdentifierGeneration();
 	}
 
 	@Test
 	public void testInsertWithGeneratedId() {
 		// Make sure the env supports bulk inserts with generated ids...
 		if ( !supportsBulkInsertIdGeneration( PettingZoo.class ) ) {
 			SkipLog.reportSkip(
 					"bulk id generation not supported",
 					"test bulk inserts with generated id and generated timestamp"
 			);
 			return;
 		}
 
 		// create a Zoo
 		Zoo zoo = new Zoo();
 		zoo.setName( "zoo" );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.save( zoo );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "insert into PettingZoo (name) select name from Zoo" ).executeUpdate();
 		t.commit();
 		s.close();
 
 		assertEquals( "unexpected insertion count", 1, count );
 
 		s = openSession();
 		t = s.beginTransaction();
 		PettingZoo pz = ( PettingZoo ) s.createQuery( "from PettingZoo" ).uniqueResult();
 		t.commit();
 		s.close();
 
 		assertEquals( zoo.getName(), pz.getName() );
 		assertTrue( !zoo.getId().equals( pz.getId() ) );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete Zoo" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
-	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	@Test
 	public void testInsertWithGeneratedVersionAndId() {
 		// Make sure the env supports bulk inserts with generated ids...
 		if ( !supportsBulkInsertIdGeneration( IntegerVersioned.class ) ) {
 			SkipLog.reportSkip(
 					"bulk id generation not supported",
 					"test bulk inserts with generated id and generated timestamp"
 			);
 			return;
 		}
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		IntegerVersioned entity = new IntegerVersioned( "int-vers" );
 		s.save( entity );
 		s.createQuery( "select id, name, version from IntegerVersioned" ).list();
 		t.commit();
 		s.close();
 
 		Long initialId = entity.getId();
 		int initialVersion = entity.getVersion();
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "insert into IntegerVersioned ( name ) select name from IntegerVersioned" ).executeUpdate();
 		t.commit();
 		s.close();
 
 		assertEquals( "unexpected insertion count", 1, count );
 
 		s = openSession();
 		t = s.beginTransaction();
 		IntegerVersioned created = ( IntegerVersioned ) s.createQuery( "from IntegerVersioned where id <> :initialId" )
 				.setLong( "initialId", initialId.longValue() )
 				.uniqueResult();
 		t.commit();
 		s.close();
 
 		assertEquals( "version was not seeded", initialVersion, created.getVersion() );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete IntegerVersioned" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	@RequiresDialectFeature(
 			value = DialectChecks.SupportsParametersInInsertSelectCheck.class,
 			comment = "dialect does not support parameter in INSERT ... SELECT"
 	)
 	public void testInsertWithGeneratedTimestampVersion() {
 		// Make sure the env supports bulk inserts with generated ids...
 		if ( !supportsBulkInsertIdGeneration( TimestampVersioned.class ) ) {
 			SkipLog.reportSkip(
 					"bulk id generation not supported",
 					"test bulk inserts with generated id and generated timestamp"
 			);
 			return;
 		}
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		TimestampVersioned entity = new TimestampVersioned( "int-vers" );
 		s.save( entity );
 		s.createQuery( "select id, name, version from TimestampVersioned" ).list();
 		t.commit();
 		s.close();
 
 		Long initialId = entity.getId();
 		//Date initialVersion = entity.getVersion();
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "insert into TimestampVersioned ( name ) select name from TimestampVersioned" ).executeUpdate();
 		t.commit();
 		s.close();
 
 		assertEquals( "unexpected insertion count", 1, count );
 
 		s = openSession();
 		t = s.beginTransaction();
 		TimestampVersioned created = ( TimestampVersioned ) s.createQuery( "from TimestampVersioned where id <> :initialId" )
 				.setLong( "initialId", initialId.longValue() )
 				.uniqueResult();
 		t.commit();
 		s.close();
 
 		assertNotNull( created.getVersion() );
 		//assertEquals( "version was not seeded", initialVersion, created.getVersion() );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery( "delete TimestampVersioned" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testInsertWithAssignedCompositeId() {
 		// this just checks that the query parser detects that we are explicitly inserting a composite id
 		Session s = openSession();
 		s.beginTransaction();
 		// intentionally reversing the order of the composite id properties to make sure that is supported too
 		s.createQuery( "insert into CompositeIdEntity (key2, someProperty, key1) select a.key2, 'COPY', a.key1 from CompositeIdEntity a" ).executeUpdate();
 		s.createQuery( "delete from CompositeIdEntity" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();		
 	}
 
 	@Test
     @SkipForDialect(
             value = CUBRIDDialect.class,
             comment = "As of verion 8.4.1 CUBRID doesn't support temporary tables. This test fails with" +
                     "HibernateException: cannot doAfterTransactionCompletion multi-table deletes using dialect not supporting temp tables"
     )
 	public void testInsertWithSelectListUsingJoins() {
 		// this is just checking parsing and syntax...
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "insert into Animal (description, bodyWeight) select h.description, h.bodyWeight from Human h where h.mother.mother is not null" ).executeUpdate();
 		s.createQuery( "insert into Animal (description, bodyWeight) select h.description, h.bodyWeight from Human h join h.mother m where m.mother is not null" ).executeUpdate();
 		s.createQuery( "delete from Animal" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testIncorrectSyntax() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		try {
 			s.createQuery( "update Human set Human.description = 'xyz' where Human.id = 1 and Human.description is null" );
 			fail( "expected failure" );
 		}
 		catch( QueryException expected ) {
 			// ignore : expected behavior
 		}
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testUpdateWithWhereExistsSubquery() {
 		// multi-table ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Human joe = new Human();
 		joe.setName( new Name( "Joe", 'Q', "Public" ) );
 		s.save( joe );
 		Human doll = new Human();
 		doll.setName( new Name( "Kyu", 'P', "Doll" ) );
 		doll.setFriends( new ArrayList() );
 		doll.getFriends().add( joe );
 		s.save( doll );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		String updateQryString = "update Human h " +
 		                         "set h.description = 'updated' " +
 		                         "where exists (" +
 		                         "      select f.id " +
 		                         "      from h.friends f " +
 		                         "      where f.name.last = 'Public' " +
 		                         ")";
 		int count = s.createQuery( updateQryString ).executeUpdate();
 		assertEquals( 1, count );
 		s.delete( doll );
 		s.delete( joe );
 		t.commit();
 		s.close();
 
 		// single-table (one-to-many & many-to-many) ~~~~~~~~~~~~~~~~~~~~~~~~~~
 		s = openSession();
 		t = s.beginTransaction();
 		SimpleEntityWithAssociation entity = new SimpleEntityWithAssociation();
 		SimpleEntityWithAssociation other = new SimpleEntityWithAssociation();
 		entity.setName( "main" );
 		other.setName( "many-to-many-association" );
 		entity.getManyToManyAssociatedEntities().add( other );
 		entity.addAssociation( "one-to-many-association" );
 		s.save( entity );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		// one-to-many test
 		updateQryString = "update SimpleEntityWithAssociation e " +
 		                         "set e.name = 'updated' " +
 		                         "where exists (" +
 		                         "      select a.id " +
 		                         "      from e.associatedEntities a " +
 		                         "      where a.name = 'one-to-many-association' " +
 		                         ")";
 		count = s.createQuery( updateQryString ).executeUpdate();
 		assertEquals( 1, count );
 		// many-to-many test
 		if ( getDialect().supportsSubqueryOnMutatingTable() ) {
 			updateQryString = "update SimpleEntityWithAssociation e " +
 									 "set e.name = 'updated' " +
 									 "where exists (" +
 									 "      select a.id " +
 									 "      from e.manyToManyAssociatedEntities a " +
 									 "      where a.name = 'many-to-many-association' " +
 									 ")";
 			count = s.createQuery( updateQryString ).executeUpdate();
 			assertEquals( 1, count );
 		}
 		s.delete( entity.getManyToManyAssociatedEntities().iterator().next() );
 		s.delete( entity );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testIncrementCounterVersion() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		IntegerVersioned entity = new IntegerVersioned( "int-vers" );
 		s.save( entity );
 		t.commit();
 		s.close();
 
 		int initialVersion = entity.getVersion();
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "update versioned IntegerVersioned set name = name" ).executeUpdate();
 		assertEquals( "incorrect exec count", 1, count );
 		t.commit();
 
 		t = s.beginTransaction();
 		entity = ( IntegerVersioned ) s.load( IntegerVersioned.class, entity.getId() );
 		assertEquals( "version not incremented", initialVersion + 1, entity.getVersion() );
 
 		s.delete( entity );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testIncrementTimestampVersion() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		TimestampVersioned entity = new TimestampVersioned( "ts-vers" );
 		s.save( entity );
 		t.commit();
 		s.close();
 
 		Date initialVersion = entity.getVersion();
 
 		synchronized (this) {
 			try {
 				wait(1500);
 			}
 			catch (InterruptedException ie) {}
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		int count = s.createQuery( "update versioned TimestampVersioned set name = name" ).executeUpdate();
 		assertEquals( "incorrect exec count", 1, count );
 		t.commit();
 
 		t = s.beginTransaction();
 		entity = ( TimestampVersioned ) s.load( TimestampVersioned.class, entity.getId() );
 		assertTrue( "version not incremented", entity.getVersion().after( initialVersion ) );
 
 		s.delete( entity );
 		t.commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	public void testUpdateOnComponent() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Human human = new Human();
 		human.setName( new Name( "Stevee", 'X', "Ebersole" ) );
 
 		s.save( human );
 		s.flush();
 
 		t.commit();
 
 		String correctName = "Steve";
 
 		t = s.beginTransaction();
 
 		int count = s.createQuery( "update Human set name.first = :correction where id = :id" )
 				.setString( "correction", correctName )
 				.setLong( "id", human.getId().longValue() )
 				.executeUpdate();
 
 		assertEquals( "Incorrect update count", 1, count );
 
 		t.commit();
 
 		t = s.beginTransaction();
 
 		s.refresh( human );
 
 		assertEquals( "Update did not execute properly", correctName, human.getName().getFirst() );
 
 		s.createQuery( "delete Human" ).executeUpdate();
 		t.commit();
 
 		s.close();
 	}
 
 	@Test
     @SkipForDialect(
             value = CUBRIDDialect.class,
             comment = "As of verion 8.4.1 CUBRID doesn't support temporary tables. This test fails with" +
                     "HibernateException: cannot doAfterTransactionCompletion multi-table deletes using dialect not supporting temp tables"
     )
 	public void testUpdateOnManyToOne() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		s.createQuery( "update Animal a set a.mother = null where a.id = 2" ).executeUpdate();
 		if ( ! ( getDialect() instanceof MySQLDialect ) ) {
 			// MySQL does not support (even un-correlated) subqueries against the update-mutating table
 			s.createQuery( "update Animal a set a.mother = (from Animal where id = 1) where a.id = 2" ).executeUpdate();
 		}
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testUpdateOnImplicitJoinFails() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Human human = new Human();
 		human.setName( new Name( "Steve", 'E', null ) );
 
 		Human mother = new Human();
 		mother.setName( new Name( "Jane", 'E', null ) );
 		human.setMother( mother );
 
 		s.save( human );
 		s.save( mother );
 		s.flush();
 
 		t.commit();
 
 		t = s.beginTransaction();
 		try {
 			s.createQuery( "update Human set mother.name.initial = :initial" ).setString( "initial", "F" ).executeUpdate();
 			fail( "update allowed across implicit join" );
 		}
 		catch( QueryException e ) {
 		}
 
 		s.createQuery( "delete Human where mother is not null" ).executeUpdate();
 		s.createQuery( "delete Human" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	public void testUpdateOnDiscriminatorSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update PettingZoo set name = name" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass update count", 1, count );
 
 		t.rollback();
 		t = s.beginTransaction();
 
 		count = s.createQuery( "update PettingZoo pz set pz.name = pz.name where pz.id = :id" )
 				.setLong( "id", data.pettingZoo.getId().longValue() )
 				.executeUpdate();
 		assertEquals( "Incorrect discrim subclass update count", 1, count );
 
 		t.rollback();
 		t = s.beginTransaction();
 
 		count = s.createQuery( "update Zoo as z set z.name = z.name" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass update count", 2, count );
 
 		t.rollback();
 		t = s.beginTransaction();
 
 		// TODO : not so sure this should be allowed.  Seems to me that if they specify an alias,
 		// property-refs should be required to be qualified.
 		count = s.createQuery( "update Zoo as z set name = name where id = :id" )
 				.setLong( "id", data.zoo.getId().longValue() )
 				.executeUpdate();
 		assertEquals( "Incorrect discrim subclass update count", 1, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateOnAnimal() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		int count = s.createQuery( "update Animal set description = description where description = :desc" )
 				.setString( "desc", data.frog.getDescription() )
 				.executeUpdate();
 		assertEquals( "Incorrect entity-updated count", 1, count );
 
 		count = s.createQuery( "update Animal set description = :newDesc where description = :desc" )
 				.setString( "desc", data.polliwog.getDescription() )
 				.setString( "newDesc", "Tadpole" )
 				.executeUpdate();
 		assertEquals( "Incorrect entity-updated count", 1, count );
 
 		Animal tadpole = ( Animal ) s.load( Animal.class, data.polliwog.getId() );
 		assertEquals( "Update did not take effect", "Tadpole", tadpole.getDescription() );
 
 		count = s.createQuery( "update Animal set bodyWeight = bodyWeight + :w1 + :w2" )
 				.setDouble( "w1", 1 )
 				.setDouble( "w2", 2 )
 				.executeUpdate();
 		assertEquals( "incorrect count on 'complex' update assignment", count, 6 );
 
 		if ( ! ( getDialect() instanceof MySQLDialect ) ) {
 			// MySQL does not support (even un-correlated) subqueries against the update-mutating table
 			s.createQuery( "update Animal set bodyWeight = ( select max(bodyWeight) from Animal )" )
 					.executeUpdate();
 		}
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateOnMammal() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update Mammal set description = description" ).executeUpdate();
 		assertEquals( "incorrect update count against 'middle' of joined-subclass hierarchy", 2, count );
 
 		count = s.createQuery( "update Mammal set bodyWeight = 25" ).executeUpdate();
 		assertEquals( "incorrect update count against 'middle' of joined-subclass hierarchy", 2, count );
 
 		if ( ! ( getDialect() instanceof MySQLDialect ) ) {
 			// MySQL does not support (even un-correlated) subqueries against the update-mutating table
 			count = s.createQuery( "update Mammal set bodyWeight = ( select max(bodyWeight) from Animal )" ).executeUpdate();
 			assertEquals( "incorrect update count against 'middle' of joined-subclass hierarchy", 2, count );
 		}
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateSetNullUnionSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		// These should reach out into *all* subclass tables...
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update Vehicle set owner = 'Steve'" ).executeUpdate();
 		assertEquals( "incorrect restricted update count", 4, count );
 		count = s.createQuery( "update Vehicle set owner = null where owner = 'Steve'" ).executeUpdate();
 		assertEquals( "incorrect restricted update count", 4, count );
 
 		try {
 			count = s.createQuery( "delete Vehicle where owner is null" ).executeUpdate();
 			assertEquals( "incorrect restricted delete count", 4, count );
 		}
 		catch ( AssertionFailedError afe ) {
 			if ( H2Dialect.class.isInstance( getDialect() ) ) {
 				// http://groups.google.com/group/h2-database/t/5548ff9fd3abdb7
 				// this is fixed in H2 1.2.140
 				count = s.createQuery( "delete Vehicle" ).executeUpdate();
 				assertEquals( "incorrect count", 4, count );
 			}
 			else {
 				throw afe;
 			}
 		}
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateSetNullOnDiscriminatorSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update PettingZoo set address.city = null" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 		count = s.createQuery( "delete Zoo where address.city is null" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 
 		count = s.createQuery( "update Zoo set address.city = null" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 		count = s.createQuery( "delete Zoo where address.city is null" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testUpdateSetNullOnJoinedSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "update Mammal set bodyWeight = null" ).executeUpdate();
 		assertEquals( "Incorrect deletion count on joined subclass", 2, count );
 
 		count = s.createQuery( "delete Animal where bodyWeight = null" ).executeUpdate();
 		assertEquals( "Incorrect deletion count on joined subclass", 2, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testDeleteWithSubquery() {
 		// setup the test data...
 		Session s = openSession();
 		s.beginTransaction();
 		SimpleEntityWithAssociation owner = new SimpleEntityWithAssociation( "myEntity-1" );
 		owner.addAssociation( "assoc-1" );
 		owner.addAssociation( "assoc-2" );
 		owner.addAssociation( "assoc-3" );
 		s.save( owner );
 		SimpleEntityWithAssociation owner2 = new SimpleEntityWithAssociation( "myEntity-2" );
 		owner2.addAssociation( "assoc-1" );
 		owner2.addAssociation( "assoc-2" );
 		owner2.addAssociation( "assoc-3" );
 		owner2.addAssociation( "assoc-4" );
 		s.save( owner2 );
 		SimpleEntityWithAssociation owner3 = new SimpleEntityWithAssociation( "myEntity-3" );
 		s.save( owner3 );
 		s.getTransaction().commit();
 		s.close();
 
 		// now try the bulk delete
 		s = openSession();
 		s.beginTransaction();
 		int count = s.createQuery( "delete SimpleEntityWithAssociation e where size( e.associatedEntities ) = 0 and e.name like '%'" ).executeUpdate();
 		assertEquals( "incorrect delete count", 1, count );
 		s.getTransaction().commit();
 		s.close();
 
 		// finally, clean up
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete SimpleAssociatedEntity" ).executeUpdate();
 		s.createQuery( "delete SimpleEntityWithAssociation" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	@RequiresDialectFeature(
 			value = DialectChecks.HasSelfReferentialForeignKeyBugCheck.class,
 			comment = "self referential FK bug"
 	)
 	public void testSimpleDeleteOnAnimal() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "delete from Animal as a where a.id = :id" )
 				.setLong( "id", data.polliwog.getId().longValue() )
 				.executeUpdate();
 		assertEquals( "Incorrect delete count", 1, count );
 
 		count = s.createQuery( "delete Animal where id = :id" )
 				.setLong( "id", data.catepillar.getId().longValue() )
 				.executeUpdate();
 		assertEquals( "incorrect delete count", 1, count );
 
 		if ( getDialect().supportsSubqueryOnMutatingTable() ) {
 			count = s.createQuery( "delete from User u where u not in (select u from User u)" ).executeUpdate();
 			assertEquals( 0, count );
 		}
 
 		count = s.createQuery( "delete Animal a" ).executeUpdate();
 		assertEquals( "Incorrect delete count", 4, count );
 
 		List list = s.createQuery( "select a from Animal as a" ).list();
 		assertTrue( "table not empty", list.isEmpty() );
 
 		t.commit();
 		s.close();
 		data.cleanup();
 	}
 
 	@Test
 	public void testDeleteOnDiscriminatorSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "delete PettingZoo" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 
 		count = s.createQuery( "delete Zoo" ).executeUpdate();
 		assertEquals( "Incorrect discrim subclass delete count", 1, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testDeleteOnJoinedSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "delete Mammal where bodyWeight > 150" ).executeUpdate();
 		assertEquals( "Incorrect deletion count on joined subclass", 1, count );
 
 		count = s.createQuery( "delete Mammal" ).executeUpdate();
 		assertEquals( "Incorrect deletion count on joined subclass", 1, count );
 
 		count = s.createQuery( "delete SubMulti" ).executeUpdate();
 		assertEquals( "Incorrect deletion count on joined subclass", 0, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testDeleteOnMappedJoin() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "delete Joiner where joinedName = :joinedName" ).setString( "joinedName", "joined-name" ).executeUpdate();
 		assertEquals( "Incorrect deletion count on joined subclass", 1, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 	
 	@Test
 	public void testDeleteUnionSubclassAbstractRoot() {
 		TestData data = new TestData();
 		data.prepare();
 
 		// These should reach out into *all* subclass tables...
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "delete Vehicle where owner = :owner" ).setString( "owner", "Steve" ).executeUpdate();
 		assertEquals( "incorrect restricted update count", 1, count );
 
 		count = s.createQuery( "delete Vehicle" ).executeUpdate();
 		assertEquals( "incorrect update count", 3, count );
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testDeleteUnionSubclassConcreteSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		// These should only affect the given table
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "delete Truck where owner = :owner" ).setString( "owner", "Steve" ).executeUpdate();
 		assertEquals( "incorrect restricted update count", 1, count );
 
 		count = s.createQuery( "delete Truck" ).executeUpdate();
 		assertEquals( "incorrect update count", 2, count );
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testDeleteUnionSubclassLeafSubclass() {
 		TestData data = new TestData();
 		data.prepare();
 
 		// These should only affect the given table
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "delete Car where owner = :owner" ).setString( "owner", "Kirsten" ).executeUpdate();
 		assertEquals( "incorrect restricted update count", 1, count );
 
 		count = s.createQuery( "delete Car" ).executeUpdate();
 		assertEquals( "incorrect update count", 0, count );
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
     @SkipForDialect(
             value = CUBRIDDialect.class,
             comment = "As of verion 8.4.1 CUBRID doesn't support temporary tables. This test fails with" +
                     "HibernateException: cannot doAfterTransactionCompletion multi-table deletes using dialect not supporting temp tables"
     )
 	public void testDeleteWithMetadataWhereFragments() throws Throwable {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		// Note: we are just checking the syntax here...
 		s.createQuery("delete from Bar").executeUpdate();
 		s.createQuery("delete from Bar where barString = 's'").executeUpdate();
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testDeleteRestrictedOnManyToOne() {
 		TestData data = new TestData();
 		data.prepare();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		int count = s.createQuery( "delete Animal where mother = :mother" )
 				.setEntity( "mother", data.butterfly )
 				.executeUpdate();
 		assertEquals( 1, count );
 
 		t.commit();
 		s.close();
 
 		data.cleanup();
 	}
 
 	@Test
 	public void testDeleteSyntaxWithCompositeId() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		s.createQuery( "delete EntityWithCrazyCompositeKey where id.id = 1 and id.otherId = 2" ).executeUpdate();
 		s.createQuery( "delete from EntityWithCrazyCompositeKey where id.id = 1 and id.otherId = 2" ).executeUpdate();
 		s.createQuery( "delete from EntityWithCrazyCompositeKey e where e.id.id = 1 and e.id.otherId = 2" ).executeUpdate();
 
 		t.commit();
 		s.close();
 	}
 	
 	@Test
 	@TestForIssue( jiraKey = "HHH-1917" )
 	public void testManyToManyBulkDelete() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Human friend = new Human();
 		friend.setName( new Name( "Bob", 'B', "Bobbert" ) );
 		s.save( friend );
 		
 		Human brett = new Human();
 		brett.setName( new Name( "Brett", 'E', "Meyer" ) );
 		brett.setFriends( new ArrayList() );
 		brett.getFriends().add( friend );
 		s.save( brett );
 		
 		s.flush();
 		
 		try {
 			s.createQuery( "delete from Human" ).executeUpdate();
 		}
 		catch (ConstraintViolationException cve) {
 			fail("The join table was not cleared prior to the bulk delete.");
 		}
 		finally {
 			t.rollback();
 			s.close();
 		}
 	}
 
 	private class TestData {
 
 		private Animal polliwog;
 		private Animal catepillar;
 		private Animal frog;
 		private Animal butterfly;
 
 		private Zoo zoo;
 		private Zoo pettingZoo;
 
 		private void prepare() {
 			Session s = openSession();
 			Transaction txn = s.beginTransaction();
 
 			polliwog = new Animal();
 			polliwog.setBodyWeight( 12 );
 			polliwog.setDescription( "Polliwog" );
 
 			catepillar = new Animal();
 			catepillar.setBodyWeight( 10 );
 			catepillar.setDescription( "Catepillar" );
 
 			frog = new Animal();
 			frog.setBodyWeight( 34 );
 			frog.setDescription( "Frog" );
 
 			polliwog.setFather( frog );
 			frog.addOffspring( polliwog );
 
 			butterfly = new Animal();
 			butterfly.setBodyWeight( 9 );
 			butterfly.setDescription( "Butterfly" );
 
 			catepillar.setMother( butterfly );
 			butterfly.addOffspring( catepillar );
 
 			s.save( frog );
 			s.save( polliwog );
 			s.save( butterfly );
 			s.save( catepillar );
 
 			Dog dog = new Dog();
 			dog.setBodyWeight( 200 );
 			dog.setDescription( "dog" );
 			s.save( dog );
 
 			Cat cat = new Cat();
 			cat.setBodyWeight( 100 );
 			cat.setDescription( "cat" );
 			s.save( cat );
 
 			zoo = new Zoo();
 			zoo.setName( "Zoo" );
 			Address add = new Address();
 			add.setCity("MEL");
 			add.setCountry("AU");
 			add.setStreet("Main st");
 			add.setPostalCode("3000");
 			zoo.setAddress(add);
 
 			pettingZoo = new PettingZoo();
 			pettingZoo.setName( "Petting Zoo" );
 			Address addr = new Address();
 			addr.setCity("Sydney");
 			addr.setCountry("AU");
 			addr.setStreet("High st");
 			addr.setPostalCode("2000");
 			pettingZoo.setAddress(addr);
 
 			s.save( zoo );
 			s.save( pettingZoo );
 
 			Joiner joiner = new Joiner();
 			joiner.setJoinedName( "joined-name" );
 			joiner.setName( "name" );
 			s.save( joiner );
 
 			Car car = new Car();
 			car.setVin( "123c" );
 			car.setOwner( "Kirsten" );
 			s.save( car );
 
 			Truck truck = new Truck();
 			truck.setVin( "123t" );
 			truck.setOwner( "Steve" );
 			s.save( truck );
 
 			SUV suv = new SUV();
 			suv.setVin( "123s" );
 			suv.setOwner( "Joe" );
 			s.save( suv );
 
 			Pickup pickup = new Pickup();
 			pickup.setVin( "123p" );
 			pickup.setOwner( "Cecelia" );
 			s.save( pickup );
 
 			BooleanLiteralEntity bool = new BooleanLiteralEntity();
 			s.save( bool );
 
 			txn.commit();
 			s.close();
 		}
 
 		private void cleanup() {
 			Session s = openSession();
 			Transaction txn = s.beginTransaction();
 
 			// workaround awesome HSQLDB "feature"
 			s.createQuery( "delete from Animal where mother is not null or father is not null" ).executeUpdate();
 			s.createQuery( "delete from Animal" ).executeUpdate();
 			s.createQuery( "delete from Zoo" ).executeUpdate();
 			s.createQuery( "delete from Joiner" ).executeUpdate();
 			s.createQuery( "delete from Vehicle" ).executeUpdate();
 			s.createQuery( "delete from BooleanLiteralEntity" ).executeUpdate();
 
 			txn.commit();
 			s.close();
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/EntityWithFunctionAsColumnHolder.java b/hibernate-core/src/test/java/org/hibernate/test/hql/EntityWithFunctionAsColumnHolder.java
index 5f48bf3be4..ffa008687e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/EntityWithFunctionAsColumnHolder.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/EntityWithFunctionAsColumnHolder.java
@@ -1,66 +1,66 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.hql;
 import java.util.HashSet;
 import java.util.Set;
 
 /**
  *
  * @author Gail Badner
  */
 public class EntityWithFunctionAsColumnHolder {
 	private long id;
 	private EntityWithFunctionAsColumnHolder nextHolder;
 	private Set entityWithArgFunctionAsColumns = new HashSet();
 	private Set entityWithNoArgFunctionAsColumns = new HashSet();
 
 	public long getId() {
 		return id;
 	}
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public EntityWithFunctionAsColumnHolder getNextHolder() {
 		return nextHolder;
 	}
 	public void setNextHolder(EntityWithFunctionAsColumnHolder nextHolder) {
 		this.nextHolder = nextHolder;
 	}
 
 	public Set getEntityWithArgFunctionAsColumns() {
 		return entityWithArgFunctionAsColumns;
 	}
 	public void setEntityWithArgFunctionAsColumns(Set entityWithArgFunctionAsColumns) {
 		this.entityWithArgFunctionAsColumns = entityWithArgFunctionAsColumns;
 	}
 
 	public Set getEntityWithNoArgFunctionAsColumns() {
 		return entityWithNoArgFunctionAsColumns;
 	}
 	public void setEntityWithNoArgFunctionAsColumns(Set entityWithNoArgFunctionAsColumns) {
 		this.entityWithNoArgFunctionAsColumns = entityWithNoArgFunctionAsColumns;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hql/QueryTranslatorTestCase.java b/hibernate-core/src/test/java/org/hibernate/test/hql/QueryTranslatorTestCase.java
index bfb03cfe3f..ab0cf0d992 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hql/QueryTranslatorTestCase.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hql/QueryTranslatorTestCase.java
@@ -1,306 +1,306 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.hql;
 
+import java.io.Serializable;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.TreeMap;
 
 import junit.framework.ComparisonFailure;
 
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.engine.query.spi.HQLQueryPlan;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory;
 import org.hibernate.hql.internal.ast.QueryTranslatorImpl;
 import org.hibernate.hql.internal.ast.util.ASTPrinter;
 import org.hibernate.hql.internal.classic.ClassicQueryTranslatorFactory;
 import org.hibernate.hql.spi.QueryTranslator;
 import org.hibernate.hql.spi.QueryTranslatorFactory;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.hibernate.type.Type;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 public abstract class QueryTranslatorTestCase extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] {
 				"hql/Animal.hbm.xml",
 				"hql/EntityWithCrazyCompositeKey.hbm.xml",
 				"hql/CrazyIdFieldNames.hbm.xml",
 				"hql/SimpleEntityWithAssociation.hbm.xml",
 				"hql/ComponentContainer.hbm.xml",
 				"batchfetch/ProductLine.hbm.xml",
 				"cid/Customer.hbm.xml",
 				"cid/Order.hbm.xml",
 				"cid/LineItem.hbm.xml",
 				"cid/Product.hbm.xml",
 				"legacy/Baz.hbm.xml",
 				"legacy/Category.hbm.xml",
 				"legacy/Commento.hbm.xml",
 				"legacy/Container.hbm.xml",
 				"legacy/Custom.hbm.xml",
 				"legacy/Eye.hbm.xml",
 				"legacy/Fee.hbm.xml",
 				"legacy/FooBar.hbm.xml",
 				"legacy/Fum.hbm.xml",
 				"legacy/Glarch.hbm.xml",
 				"legacy/Holder.hbm.xml",
 				"legacy/Many.hbm.xml",
 				"legacy/Marelo.hbm.xml",
 				"legacy/MasterDetail.hbm.xml",
 				"legacy/Middle.hbm.xml",
 				"legacy/Multi.hbm.xml",
 				"legacy/Nameable.hbm.xml",
 				"legacy/One.hbm.xml",
 				"legacy/Qux.hbm.xml",
 				"legacy/Simple.hbm.xml",
 				"legacy/SingleSeveral.hbm.xml",
 				"legacy/WZ.hbm.xml",
 				"legacy/UpDown.hbm.xml",
 				"compositeelement/Parent.hbm.xml",
 				"onetoone/joined/Person.hbm.xml",
 				"any/Properties.hbm.xml"
 		};
 	}
 
 	@Override
 	public boolean createSchema() {
 		return false;
 	}
 
 	@Override
 	public boolean rebuildSessionFactoryOnError() {
 		return false;
 	}
 
 	public void assertTranslation(String hql) throws QueryException, MappingException {
 		assertTranslation( hql, null );
 	}
 
 	protected void assertTranslation(String hql, Map replacements) {
 		ComparisonFailure cf = null;
 		try {
 			assertTranslation( hql, replacements, false, null );
 		}
 		catch ( ComparisonFailure e ) {
 			e.printStackTrace();
 			cf = e;
 		}
 		if ("false".equals(System.getProperty("org.hibernate.test.hql.SkipScalarQuery","false"))) {
 			// Run the scalar translation anyway, even if there was a comparison failure.
 			assertTranslation( hql, replacements, true, null );
 		}
 		if (cf != null)
 			throw cf;
 	}
 
 	protected void assertTranslation(String hql, Map replacements, boolean scalar, String sql) {
 		SessionFactoryImplementor factory = sessionFactory();
 
 		// Create an empty replacements map if we don't have one.
 		if ( replacements == null ) {
 			replacements = new HashMap();
 		}
 
 		// steve -> note that the empty maps here represent the currently enabled filters...
 		QueryTranslator oldQueryTranslator = null;
 		Exception oldException = null;
 		try {
 			System.out.println("Compiling with classic QueryTranslator...");
 			QueryTranslatorFactory classic = new ClassicQueryTranslatorFactory();
 			oldQueryTranslator = classic.createQueryTranslator( hql, hql, Collections.EMPTY_MAP, factory );
 			oldQueryTranslator.compile( replacements, scalar );
 		}
 		catch ( QueryException e ) {
 			oldException = e;
 		}
 		catch ( MappingException e ) {
 			oldException = e;
 		}
 
 		QueryTranslator newQueryTranslator = null;
 		Exception newException = null;
 		try {
 			System.out.println("Compiling with AST QueryTranslator...");
 			newQueryTranslator = createNewQueryTranslator( hql, replacements, scalar );
 		}
 		catch ( QueryException e ) {
 			newException = e;
 		}
 		catch ( MappingException e ) {
 			newException = e;
 		}
 
 		// If the old QT threw an exception, the new one should too.
 		if ( oldException != null ) {
 			assertNotNull( "New query translator did *NOT* throw an exception, the old one did : " + oldException, newException );
 			assertEquals( oldException.getMessage(), newException.getMessage() );
 			return;	// Don't bother with the rest of the assertions.
 		}
 		else if ( newException != null ) {
 			newException.printStackTrace();
 			assertNull( "Old query translator did not throw an exception, the new one did", newException );
 		}
 
 		// -- check all of the outputs --
 		checkSql( oldQueryTranslator, newQueryTranslator, hql, scalar, sql );
 		checkQuerySpaces( oldQueryTranslator, newQueryTranslator );
 		checkReturnedTypes( oldQueryTranslator, newQueryTranslator );
 
 	}
 
 	protected QueryTranslatorImpl createNewQueryTranslator(String hql, Map replacements, boolean scalar) {
 		SessionFactoryImplementor factory = sessionFactory();
 		return createNewQueryTranslator( hql, replacements, scalar, factory );
 	}
 
 	private QueryTranslatorImpl createNewQueryTranslator(String hql, Map replacements, boolean scalar, SessionFactoryImplementor factory) {
 		QueryTranslatorFactory ast = new ASTQueryTranslatorFactory();
 		QueryTranslatorImpl newQueryTranslator = ( QueryTranslatorImpl ) ast.createQueryTranslator( hql, hql, Collections.EMPTY_MAP, factory );
 		newQueryTranslator.compile( replacements, scalar );
 		return newQueryTranslator;
 	}
 
 	protected QueryTranslatorImpl createNewQueryTranslator(String hql) {
 		return createNewQueryTranslator( hql, new HashMap(), false );
 	}
 
 	protected QueryTranslatorImpl createNewQueryTranslator(String hql, SessionFactoryImplementor sfimpl) {
 		return createNewQueryTranslator( hql, new HashMap(), false, sfimpl );
 	}
 
 	protected HQLQueryPlan createQueryPlan(String hql, boolean scalar) {
 		return new HQLQueryPlan( hql, scalar, Collections.EMPTY_MAP, sessionFactory() );
 	}
 
 	protected HQLQueryPlan createQueryPlan(String hql) {
 		return createQueryPlan( hql, false );
 	}
 
 	@Deprecated
 	protected SessionFactoryImplementor getSessionFactoryImplementor() {
 		return sessionFactory();
 	}
 
 	private void checkReturnedTypes(QueryTranslator oldQueryTranslator, QueryTranslator newQueryTranslator) {
 		// Check the returned types for a regression.
 		Type[] oldReturnTypes = oldQueryTranslator.getReturnTypes();
 		Type[] returnTypes = newQueryTranslator.getReturnTypes();
 		assertEquals( "Return types array is not the right length!", oldReturnTypes.length, returnTypes.length );
 		for ( int i = 0; i < returnTypes.length; i++ ) {
 			assertNotNull( returnTypes[i] );
 			assertNotNull( oldReturnTypes[i] );
 			assertEquals( "Returned types did not match!", oldReturnTypes[i].getReturnedClass(), returnTypes[i].getReturnedClass() );
 			System.out.println("returnedType[" + i + "] = " + returnTypes[i] + " oldReturnTypes[" + i + "] = " + oldReturnTypes[i]);
 		}
 	}
 
 	private void checkQuerySpaces(QueryTranslator oldQueryTranslator, QueryTranslator newQueryTranslator) {
 		// Check the query spaces for a regression.
-		Set oldQuerySpaces = oldQueryTranslator.getQuerySpaces();
-		Set querySpaces = newQueryTranslator.getQuerySpaces();
+		Set<Serializable> oldQuerySpaces = oldQueryTranslator.getQuerySpaces();
+		Set<Serializable> querySpaces = newQueryTranslator.getQuerySpaces();
 		assertEquals( "Query spaces is not the right size!", oldQuerySpaces.size(), querySpaces.size() );
 		for ( Object o : oldQuerySpaces ) {
 			assertTrue( "New query space does not contain " + o + "!", querySpaces.contains( o ) );
 		}
 	}
 
 	protected Exception compileBadHql(String hql, boolean scalar) {
 		QueryTranslator newQueryTranslator;
 		Map replacements = null;
 		Exception newException = null;
 		SessionFactoryImplementor factory = sessionFactory();
 		try {
 			QueryTranslatorFactory ast = new ASTQueryTranslatorFactory();
 			newQueryTranslator = ast.createQueryTranslator( hql, hql, Collections.EMPTY_MAP, factory );
 			newQueryTranslator.compile( replacements, scalar );
 		}
 		catch ( QueryException e ) {
 			newException = e;
 		}
 		catch ( MappingException e ) {
 			newException = e;
 		}
 		assertNotNull( "Expected exception from compilation of '" + hql + "'!", newException );
 		return newException;
 	}
 
 	private void checkSql(QueryTranslator oldQueryTranslator, QueryTranslator newQueryTranslator, String hql, boolean scalar, String sql) {
 
 		String oldsql = oldQueryTranslator.getSQLString();
 		String newsql = newQueryTranslator.getSQLString();
 		System.out.println( "HQL    : " + ASTPrinter.escapeMultibyteChars(hql) );
 		System.out.println( "OLD SQL: " + ASTPrinter.escapeMultibyteChars(oldsql) );
 		System.out.println( "NEW SQL: " + ASTPrinter.escapeMultibyteChars(newsql) );
 		if ( sql == null ) {
 			// Check the generated SQL.                                          ASTPrinter.escapeMultibyteChars(
 			assertSQLEquals( "SQL is not the same as the old SQL (scalar=" + scalar + ")", oldsql, newsql );
 		}
 		else {
 			assertSQLEquals( "SQL is not the same as the expected SQL (scalar=" + scalar + ")", sql, newsql );
 		}
 	}
 
 	private void assertSQLEquals(String message, String oldsql, String newsql) {
 		Map oldMap = getTokens(oldsql);
 		Map newMap = getTokens(newsql);
 		if ( !oldMap.equals(newMap) ) {
 			assertEquals(message, oldsql, newsql);
 		}
 	}
 
 	
-	@SuppressWarnings( {"UnnecessaryBoxing", "UnnecessaryUnboxing"})
 	private Map getTokens(String sql) {
 		Map<String,Integer> result = new TreeMap<String,Integer>();
 		if ( sql == null ) {
 			return result;
 		}
 		result.put( "=", Integer.valueOf( StringHelper.countUnquoted( sql, '=' ) ) );
 		StringTokenizer tokenizer = new StringTokenizer( sql, "(),= " );
 		while ( tokenizer.hasMoreTokens() ) {
 			String fragment = tokenizer.nextToken();
 			/*if ( "on".equals(fragment) ) fragment = "and";
 			if ( "join".equals(fragment) || "inner".equals(fragment) ) continue;*/
 			Integer count = result.get(fragment);
 			if ( count == null ) {
 				count = Integer.valueOf(1);
 			}
 			else {
 				count = Integer.valueOf( count.intValue() + 1 );
 			}
 			result.put(fragment, count);
 		}
 		return result;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hqlfetchscroll/Child.java b/hibernate-core/src/test/java/org/hibernate/test/hqlfetchscroll/Child.java
index 54f6a9791d..7180428403 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hqlfetchscroll/Child.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hqlfetchscroll/Child.java
@@ -1,36 +1,36 @@
 package org.hibernate.test.hqlfetchscroll;
 
 public class Child {
 
 	// A numeric id must be the <id> field.  Some databases (Sybase, etc.)
 	// require identifier columns in order to support scrollable results.
 	private long id;
 	private String name;
 
 	Child() {
 	}
 
 	public Child(String name) {
 		this.name = name;
 	}
 
 	public long getId() {
 		return id;
 	}
 
 	void setId(long id) {
 		this.id = id;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	private void setName(String name) {
 		this.name = name;
 	}
 
 	public String toString() {
 		return name;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/hqlfetchscroll/Parent.java b/hibernate-core/src/test/java/org/hibernate/test/hqlfetchscroll/Parent.java
index 1ce74e3c5d..2d41eb5c6a 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/hqlfetchscroll/Parent.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/hqlfetchscroll/Parent.java
@@ -1,52 +1,52 @@
 package org.hibernate.test.hqlfetchscroll;
 
 import java.util.HashSet;
 import java.util.Set;
 
 public class Parent {
 	
 	// A numeric id must be the <id> field.  Some databases (Sybase, etc.)
 	// require identifier columns in order to support scrollable results.
 	private long id;
 	private String name;
 	private Set children = new HashSet();
 
 	Parent() {
 	}
 
 	public Parent(String name) {
 		this.name = name;
 	}
 
 	public long getId() {
 		return id;
 	}
 
 	void setId(long id) {
 		this.id = id;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	void setName(String name) {
 		this.name = name;
 	}
 
 	public Set getChildren() {
 		return children;
 	}
 
 	private void setChildren(Set children) {
 		this.children = children;
 	}
 
 	public void addChild(Child child) {
 		children.add( child );
 	}
 
 	public String toString() {
 		return name;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/idgen/biginteger/increment/BigIntegerIncrementGeneratorTest.java b/hibernate-core/src/test/java/org/hibernate/test/idgen/biginteger/increment/BigIntegerIncrementGeneratorTest.java
index f4d5565ff8..a06a14861b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/idgen/biginteger/increment/BigIntegerIncrementGeneratorTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/idgen/biginteger/increment/BigIntegerIncrementGeneratorTest.java
@@ -1,64 +1,64 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.idgen.biginteger.increment;
 import java.math.BigInteger;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Steve Ebersole
  */
 public class BigIntegerIncrementGeneratorTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] { "idgen/biginteger/increment/Mapping.hbm.xml" };
 	}
 
 	@Test
 	public void testBasics() {
 		Session s = openSession();
 		s.beginTransaction();
 		Entity entity = new Entity( "BigInteger + increment #1" );
 		s.save( entity );
 		Entity entity2 = new Entity( "BigInteger + increment #2" );
 		s.save( entity2 );
 		s.getTransaction().commit();
 		s.close();
 
 		assertEquals( BigInteger.valueOf( 1 ), entity.getId() );
 		assertEquals( BigInteger.valueOf( 2 ), entity2.getId() );
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( entity );
 		s.delete( entity2 );
 		s.getTransaction().commit();
 		s.close();
 
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/idgen/biginteger/sequence/BigIntegerSequenceGeneratorTest.java b/hibernate-core/src/test/java/org/hibernate/test/idgen/biginteger/sequence/BigIntegerSequenceGeneratorTest.java
index 7d2d99342e..c6759a94c0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/idgen/biginteger/sequence/BigIntegerSequenceGeneratorTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/idgen/biginteger/sequence/BigIntegerSequenceGeneratorTest.java
@@ -1,66 +1,66 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.idgen.biginteger.sequence;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.testing.DialectChecks;
 import org.hibernate.testing.RequiresDialectFeature;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 /**
  * @author Steve Ebersole
  */
 @RequiresDialectFeature( value = DialectChecks.SupportsSequences.class )
 public class BigIntegerSequenceGeneratorTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] { "idgen/biginteger/sequence/Mapping.hbm.xml" };
 	}
 
 	@Test
 	public void testBasics() {
 		Session s = openSession();
 		s.beginTransaction();
 		Entity entity = new Entity( "BigInteger + sequence #1" );
 		s.save( entity );
 		Entity entity2 = new Entity( "BigInteger + sequence #2" );
 		s.save( entity2 );
 		s.getTransaction().commit();
 		s.close();
 
 // hsqldb defines different behavior for the initial select from a sequence
 // then say oracle
 //		assertEquals( BigInteger.valueOf( 1 ), entity.getId() );
 //		assertEquals( BigInteger.valueOf( 2 ), entity2.getId() );
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( entity );
 		s.delete( entity2 );
 		s.getTransaction().commit();
 		s.close();
 
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/idgen/biginteger/sequence/Entity.java b/hibernate-core/src/test/java/org/hibernate/test/idgen/biginteger/sequence/Entity.java
index 98df1b1a6c..0949fb6938 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/idgen/biginteger/sequence/Entity.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/idgen/biginteger/sequence/Entity.java
@@ -1,58 +1,58 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.idgen.biginteger.sequence;
 import java.math.BigInteger;
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class Entity {
 	private BigInteger id;
 	private String name;
 
 	public Entity() {
 	}
 
 	public Entity(String name) {
 		this.name = name;
 	}
 
 	public BigInteger getId() {
 		return id;
 	}
 
 	public void setId(BigInteger id) {
 		this.id = id;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/Info.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/Info.java
index 9974797cf4..3a7aee5bf5 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/Info.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/Info.java
@@ -1,42 +1,42 @@
 //$Id: Contract.java 7222 2005-06-19 17:22:01Z oneovthafew $
 package org.hibernate.test.immutable;
 import java.io.Serializable;
 
 public class Info implements Serializable {
 
 	private long id;
 	private String text;
 	private long version;
 
 	public Info() {
 		super();
 	}
 
 	public Info(String text) {
 		this.text = text;
 	}
 
 	public long getVersion() {
 		return version;
 	}
 
 	public void setVersion(long version) {
 		this.version = version;
 	}
 
 	public String getText() {
 		return text;
 	}
 
 	public void setText(String text) {
 		this.text = text;
 	}
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/Party.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/Party.java
index 66c48cd72e..86f2d4250a 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/Party.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/Party.java
@@ -1,62 +1,62 @@
 //$Id: Contract.java 7222 2005-06-19 17:22:01Z oneovthafew $
 package org.hibernate.test.immutable;
 import java.io.Serializable;
 import java.util.HashSet;
 import java.util.Set;
 
 public class Party implements Serializable {
 
 	private long id;
 	private long version;
 	private Contract contract;
 	private String name;
 	private Set infos = new HashSet();
 
 	public Party() {
 		super();
 	}
 
 	public Party(String name) {
 		this.name = name;
 	}
 
 	public long getVersion() {
 		return version;
 	}
 
 	public void setVersion(long version) {
 		this.version = version;
 	}
 	
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public Contract getContract() {
 		return contract;
 	}
 
 	public void setContract(Contract contract) {
 		this.contract = contract;
 	}
 
 	public Set getInfos() {
 		return infos;
 	}
 
 	public void setInfos(Set infos) {
 		this.infos = infos;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/Plan.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/Plan.java
index 82813b71c4..b8ce10e296 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/Plan.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/Plan.java
@@ -1,98 +1,98 @@
 //$Id: ContractVariation.java 7222 2005-06-19 17:22:01Z oneovthafew $
 package org.hibernate.test.immutable;
 import java.io.Serializable;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 
 public class Plan implements Serializable {
 
 	private long id;
 	private long version;
 	private String description;
 	private Set contracts;
 	private Set infos;
 
 	public Plan() {
 		this( null );
 	}
 
 	public Plan(String description) {
 		this.description = description;
 		contracts = new HashSet();
 		infos = new HashSet();
 	}
 
 	public long getVersion() {
 		return version;
 	}
 
 	public void setVersion(long version) {
 		this.version = version;
 	}
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public String getDescription() {
 		return description;
 	}
 
 	public void setDescription(String description) {
 		this.description = description;
 	}
 
 	public Set getContracts() {
 		return contracts;
 	}
 
 	public void setContracts(Set contracts) {
 		this.contracts = contracts;
 	}
 
 	public void addContract(Contract contract) {
 		if ( ! contracts.add( contract ) ) {
 			return;
 		}
 		if ( contract.getParent() != null ) {
 			addContract( contract.getParent() );
 		}
 		contract.getPlans().add( this );
 		for ( Iterator it=contract.getSubcontracts().iterator(); it.hasNext(); ) {
 			Contract sub = ( Contract ) it.next();
 			addContract( sub );
 		}
 	}
 
 	public void removeContract(Contract contract) {
 		if ( contract.getParent() != null ) {
 			contract.getParent().getSubcontracts().remove( contract );
 			contract.setParent( null );			
 		}
 		removeSubcontracts( contract );
 		contract.getPlans().remove( this );
 		contracts.remove( contract );
 	}
 
 	public void removeSubcontracts(Contract contract) {
 		for ( Iterator it=contract.getSubcontracts().iterator(); it.hasNext(); ) {
 			Contract sub = ( Contract ) it.next();
 			removeSubcontracts( sub );
 			sub.getPlans().remove( this );
 			contracts.remove( sub );
 		}
 	}
 
 	public Set getInfos() {
 		return infos;
 	}
 
 	public void setInfos(Set infos) {
 		this.infos = infos;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/AbstractEntityWithManyToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/AbstractEntityWithManyToManyTest.java
index fd9e09215f..3f79b0b476 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/AbstractEntityWithManyToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/AbstractEntityWithManyToManyTest.java
@@ -128,1001 +128,1001 @@ public abstract class AbstractEntityWithManyToManyTest extends BaseCoreFunctiona
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		p.addContract( new Contract( null, "gail", "phone") );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist(p);
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		assertEquals( 1, p.getContracts().size() );
 		Contract c = ( Contract ) p.getContracts().iterator().next();
 		assertEquals( "gail", c.getCustomerName() );
 		if ( isPlanContractsBidirectional ) {
 			assertEquals( 1, c.getPlans().size() );
 			assertSame( p, c.getPlans().iterator().next() );
 		}
 		s.delete(p);
 		assertEquals( new Long( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria( Plan.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
 	public void testCreateWithNonEmptyManyToManyCollectionOfExisting() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist(c);
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		p.addContract( c );
 		s = openSession();
 		t = s.beginTransaction();
 		s.save(p);
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		assertEquals( 1, p.getContracts().size() );
 		c = ( Contract ) p.getContracts().iterator().next();
 		assertEquals( "gail", c.getCustomerName() );
 		if ( isPlanContractsBidirectional ) {
 			assertEquals( 1, c.getPlans().size() );
 			assertSame( p, c.getPlans().iterator().next() );
 		}
 		s.delete(p);
 		assertEquals( new Long( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria( Plan.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
 	public void testAddNewManyToManyElementToPersistentEntity() {
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( p );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.get( Plan.class, p.getId() );
 		assertEquals( 0, p.getContracts().size() );
 		p.addContract( new Contract( null, "gail", "phone") );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan) s.createCriteria( Plan.class ).uniqueResult();
 		assertEquals( 1, p.getContracts().size() );
 		Contract c = ( Contract ) p.getContracts().iterator().next();
 		assertEquals( "gail", c.getCustomerName() );
 		if ( isPlanContractsBidirectional ) {
 			assertEquals( 1, c.getPlans().size() );
 			assertSame( p, c.getPlans().iterator().next() );
 		}
 		s.delete( p );
 		assertEquals( new Long( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria( Plan.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
 	public void testAddExistingManyToManyElementToPersistentEntity() {
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		Contract c = new Contract( null, "gail", "phone" );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( p );
 		s.persist( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.get( Plan.class, p.getId() );
 		assertEquals( 0, p.getContracts().size() );
 		c = ( Contract ) s.get( Contract.class, c.getId() );
 		if ( isPlanContractsBidirectional ) {
 			assertEquals( 0, c.getPlans().size() );
 		}
 		p.addContract( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( isContractVersioned && isPlanVersioned ? 2 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		assertEquals( 1, p.getContracts().size() );
 		c = ( Contract ) p.getContracts().iterator().next();
 		assertEquals( "gail", c.getCustomerName() );
 		if ( isPlanContractsBidirectional ) {
 			assertSame( p, c.getPlans().iterator().next() );
 		}
 		s.delete( p );
 		assertEquals( new Long( 0 ), s.createCriteria( Plan.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
 	public void testCreateWithEmptyManyToManyCollectionUpdateWithExistingElement() {
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		Contract c = new Contract( null, "gail", "phone");
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( p );
 		s.persist( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		p.addContract( c );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( p );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( isContractVersioned && isPlanVersioned ? 2 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		assertEquals( 1, p.getContracts().size() );
 		c = ( Contract ) p.getContracts().iterator().next();
 		assertEquals( "gail", c.getCustomerName() );
 		if ( isPlanContractsBidirectional ) {
 			assertSame( p, c.getPlans().iterator().next() );
 		}
 		s.delete( p );
 		assertEquals( new Long( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria( Plan.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
 	public void testCreateWithNonEmptyManyToManyCollectionUpdateWithNewElement() {
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		Contract c = new Contract( null, "gail", "phone");
 		p.addContract( c );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist(p);
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		Contract newC = new Contract( null, "sherman", "telepathy" );
 		p.addContract( newC );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( p );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		assertEquals( 2, p.getContracts().size() );
 		for ( Iterator it=p.getContracts().iterator(); it.hasNext(); ) {
 			Contract aContract = ( Contract ) it.next();
 			if ( aContract.getId() == c.getId() ) {
 				assertEquals( "gail", aContract.getCustomerName() );
 			}
 			else if ( aContract.getId() == newC.getId() ) {
 				assertEquals( "sherman", aContract.getCustomerName() );
 			}
 			else {
 				fail( "unknown contract" );
 			}
 			if ( isPlanContractsBidirectional ) {
 				assertSame( p, aContract.getPlans().iterator().next() );
 			}
 		}
 		s.delete( p );
 		assertEquals( new Long( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria(Plan.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 3 );
 	}
 
 	@Test
 	public void testCreateWithEmptyManyToManyCollectionMergeWithExistingElement() {
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		Contract c = new Contract( null, "gail", "phone");
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( p );
 		s.persist( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		p.addContract( c );
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.merge( p );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( isContractVersioned && isPlanVersioned ? 2 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		assertEquals( 1, p.getContracts().size() );
 		c = ( Contract ) p.getContracts().iterator().next();
 		assertEquals( "gail", c.getCustomerName() );
 		if ( isPlanContractsBidirectional ) {
 			assertSame( p, c.getPlans().iterator().next() );
 		}
 		s.delete( p );
 		assertEquals( new Long( 0 ), s.createCriteria(Plan.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
 	public void testCreateWithNonEmptyManyToManyCollectionMergeWithNewElement() {
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		Contract c = new Contract( null, "gail", "phone");
 		p.addContract( c );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( p );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		Contract newC = new Contract( null, "yogi", "mail" );
 		p.addContract( newC );
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.merge( p );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( isContractVersioned && isPlanVersioned ? 2 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		assertEquals( 2, p.getContracts().size() );
 		for ( Iterator it=p.getContracts().iterator(); it.hasNext(); ) {
 			Contract aContract = ( Contract ) it.next();
 			if ( aContract.getId() == c.getId() ) {
 				assertEquals( "gail", aContract.getCustomerName() );
 			}
 			else if ( ! aContract.getCustomerName().equals( newC.getCustomerName() ) ) {
 				fail( "unknown contract:" + aContract.getCustomerName() );
 			}
 			if ( isPlanContractsBidirectional ) {
 				assertSame( p, aContract.getPlans().iterator().next() );
 			}
 		}
 		s.delete( p );
 		assertEquals( new Long( 0 ), s.createCriteria( Plan.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 3 );
 	}
 
 	@Test
 	public void testRemoveManyToManyElementUsingUpdate() {
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		Contract c = new Contract( null, "gail", "phone");
 		p.addContract( c );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( p );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		p.removeContract( c );
 		assertEquals( 0, p.getContracts().size() );
 		if ( isPlanContractsBidirectional ) {
 			assertEquals( 0, c.getPlans().size() );
 		}
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( p );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		assertDeleteCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		if ( isPlanContractsInverse ) {
 			assertEquals( 1, p.getContracts().size() );
 			c = ( Contract ) p.getContracts().iterator().next();
 			assertEquals( "gail", c.getCustomerName() );
 			assertSame( p, c.getPlans().iterator().next() );
 		}
 		else {
 			assertEquals( 0, p.getContracts().size() );
 			c = ( Contract ) s.createCriteria( Contract.class ).uniqueResult();
 			if ( isPlanContractsBidirectional ) {
 				assertEquals( 0, c.getPlans().size() );
 			}
 			s.delete( c );
 		}
 		s.delete( p );
 		assertEquals( new Long( 0 ), s.createCriteria(Plan.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
 	public void testRemoveManyToManyElementUsingUpdateBothSides() {
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		Contract c = new Contract( null, "gail", "phone");
 		p.addContract( c );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( p );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		p.removeContract( c );
 		assertEquals( 0, p.getContracts().size() );
 		if ( isPlanContractsBidirectional ) {
 			assertEquals( 0, c.getPlans().size() );
 		}
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( p );
 		s.update( c );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( isContractVersioned && isPlanVersioned ? 2 : 0 );
 		assertDeleteCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		assertEquals( 0, p.getContracts().size() );
 		c = ( Contract ) s.createCriteria( Contract.class ).uniqueResult();
 		if ( isPlanContractsBidirectional ) {
 			assertEquals( 0, c.getPlans().size() );
 		}
 		s.delete( c );
 		s.delete( p );
 		assertEquals( new Long( 0 ), s.createCriteria(Plan.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
 	public void testRemoveManyToManyElementUsingMerge() {
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		Contract c = new Contract( null, "gail", "phone");
 		p.addContract( c );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( p );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		p.removeContract( c );
 		assertEquals( 0, p.getContracts().size() );
 		if ( isPlanContractsBidirectional ) {
 			assertEquals( 0, c.getPlans().size() );
 		}
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.merge( p );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		assertDeleteCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		if ( isPlanContractsInverse ) {
 			assertEquals( 1, p.getContracts().size() );
 			c = ( Contract ) p.getContracts().iterator().next();
 			assertEquals( "gail", c.getCustomerName() );
 			assertSame( p, c.getPlans().iterator().next() );
 		}
 		else {
 			assertEquals( 0, p.getContracts().size() );
 			c = ( Contract ) s.createCriteria( Contract.class ).uniqueResult();
 			if ( isPlanContractsBidirectional ) {
 				assertEquals( 0, c.getPlans().size() );
 			}
 			s.delete( c );
 		}
 		s.delete( p );
 		assertEquals( new Long( 0 ), s.createCriteria(Plan.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
 	public void testRemoveManyToManyElementUsingMergeBothSides() {
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		Contract c = new Contract( null, "gail", "phone");
 		p.addContract( c );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( p );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		p.removeContract( c );
 		assertEquals( 0, p.getContracts().size() );
 		if ( isPlanContractsBidirectional ) {
 			assertEquals( 0, c.getPlans().size() );
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.merge( p );
 		c = ( Contract ) s.merge( c );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( isContractVersioned  && isPlanVersioned ? 2 : 0 );
 		assertDeleteCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		assertEquals( 0, p.getContracts().size() );
 		c = ( Contract ) s.createCriteria( Contract.class ).uniqueResult();
 		if ( isPlanContractsBidirectional ) {
 			assertEquals( 0, c.getPlans().size() );
 		}
 		s.delete( c );
 		s.delete( p );
 		assertEquals( new Long( 0 ), s.createCriteria(Plan.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
 	public void testDeleteManyToManyElement() {
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		Contract c = new Contract( null, "gail", "phone");
 		p.addContract( c );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( p );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( p );
 		p.removeContract( c );
 		s.delete( c );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		assertDeleteCount( 1 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		assertEquals( 0, p.getContracts().size() );
 		c = ( Contract ) s.createCriteria( Contract.class ).uniqueResult();
 		assertNull( c );
 		s.delete( p );
 		assertEquals( new Long( 0 ), s.createCriteria(Plan.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 1 );
 	}
 
 	@Test
 	public void testRemoveManyToManyElementByDelete() {
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		Contract c = new Contract( null, "gail", "phone");
 		p.addContract( c );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( p );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		p.removeContract( c );
 		assertEquals( 0, p.getContracts().size() );
 		if ( isPlanContractsBidirectional ) {
 			assertEquals( 0, c.getPlans().size() );
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( p );
 		s.delete( c );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( isPlanVersioned ? 1 : 0 );
 		assertDeleteCount( 1 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		assertEquals( 0, p.getContracts().size() );
 		s.delete( p );
 		assertEquals( new Long( 0 ), s.createCriteria(Plan.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 1 );
 	}
 
 	@Test
 	public void testManyToManyCollectionOptimisticLockingWithMerge() {
 		clearCounts();
 
 		Plan pOrig = new Plan( "plan" );
 		Contract cOrig = new Contract( null, "gail", "phone");
 		pOrig.addContract( cOrig );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( pOrig );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Plan p = ( Plan ) s.get( Plan.class, pOrig.getId() );
 		Contract newC = new Contract( null, "sherman", "note" );
 		p.addContract( newC );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		pOrig.removeContract( cOrig );
 		try {
 			s.merge( pOrig );
 			assertFalse( isContractVersioned );
 		}
 		catch (StaleObjectStateException ex) {
 			assertTrue( isContractVersioned);
 		}
 		finally {
 			t.rollback();
 		}
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		s.delete( p );
 		assertEquals( new Long( 0 ), s.createCriteria(Plan.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 3 );
 	}
 
 	@Test
 	public void testManyToManyCollectionOptimisticLockingWithUpdate() {
 		clearCounts();
 
 		Plan pOrig = new Plan( "plan" );
 		Contract cOrig = new Contract( null, "gail", "phone");
 		pOrig.addContract( cOrig );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist(pOrig);
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Plan p = ( Plan ) s.get( Plan.class, pOrig.getId() );
 		Contract newC = new Contract( null, "yogi", "pawprint" );
 		p.addContract( newC );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		pOrig.removeContract( cOrig );
 		s.update( pOrig );
 		try {
 			t.commit();
 			assertFalse( isContractVersioned );
 		}
 		catch (StaleStateException ex) {
 			t.rollback();
 			assertTrue( isContractVersioned );
 			if ( ! sessionFactory().getSettings().isJdbcBatchVersionedData() ) {
 				assertTrue( StaleObjectStateException.class.isInstance( ex ) );
 			}
 		}
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = ( Plan ) s.createCriteria( Plan.class ).uniqueResult();
 		s.delete( p );
 		s.createQuery( "delete from Contract" ).executeUpdate();
 		assertEquals( new Long( 0 ), s.createCriteria(Plan.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testMoveManyToManyElementToNewEntityCollection() {
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		p.addContract( new Contract( null, "gail", "phone" ) );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( p );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = (Plan) s.createCriteria( Plan.class ).uniqueResult();
 		assertEquals( 1, p.getContracts().size() );
 		Contract c = ( Contract ) p.getContracts().iterator().next();
 		assertEquals( "gail", c.getCustomerName() );
 		if ( isPlanContractsBidirectional ) {
 			assertSame( p, c.getPlans().iterator().next() );
 		}
 		p.removeContract( c );
 		Plan p2 = new Plan( "new plan" );
 		p2.addContract( c );
 		s.save( p2 );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( isPlanVersioned && isContractVersioned ? 2 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = (Plan) s.createCriteria( Plan.class ).add( Restrictions.idEq( new Long( p.getId() ) )).uniqueResult();
 		p2 = (Plan) s.createCriteria( Plan.class ).add( Restrictions.idEq( new Long( p2.getId() ) )).uniqueResult();
 		/*
 		if ( isPlanContractsInverse ) {
 			assertEquals( 1, p.getContracts().size() );
 			c = ( Contract ) p.getContracts().iterator().next();
 			assertEquals( "gail", c.getCustomerName() );
 			if ( isPlanContractsBidirectional ) {
 				assertSame( p, c.getPlans().iterator().next() );
 			}
 			assertEquals( 0, p2.getContracts().size() );
 		}
 		else {
 		*/
 			assertEquals( 0, p.getContracts().size() );
 			assertEquals( 1, p2.getContracts().size() );
 			c = ( Contract ) p2.getContracts().iterator().next();
 			assertEquals( "gail", c.getCustomerName() );
 			if ( isPlanContractsBidirectional ) {
 				assertSame( p2, c.getPlans().iterator().next() );
 			}
 		//}
 		s.delete( p );
 		s.delete( p2 );
 		assertEquals( new Long( 0 ), s.createCriteria( Plan.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 3 );
 	}
 
 	@Test
 	public void testMoveManyToManyElementToExistingEntityCollection() {
 		clearCounts();
 
 		Plan p = new Plan( "plan" );
 		p.addContract( new Contract( null, "gail", "phone" ) );
 		Plan p2 = new Plan( "plan2" );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( p );
 		s.persist( p2 );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 3 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = (Plan) s.createCriteria( Plan.class ).add( Restrictions.idEq( new Long( p.getId() ) )).uniqueResult();
 		assertEquals( 1, p.getContracts().size() );
 		Contract c = ( Contract ) p.getContracts().iterator().next();
 		assertEquals( "gail", c.getCustomerName() );
 		if ( isPlanContractsBidirectional ) {
 			assertSame( p, c.getPlans().iterator().next() );
 		}
 		p.removeContract( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( isPlanVersioned && isContractVersioned ? 2 : 0 );
 		clearCounts();
 		
 		s = openSession();
 		t = s.beginTransaction();
 		p2 = (Plan) s.createCriteria( Plan.class ).add( Restrictions.idEq( new Long( p2.getId() ) )).uniqueResult();
 		c = (Contract) s.createCriteria( Contract.class ).add( Restrictions.idEq( new Long( c.getId() ) )).uniqueResult();
 		p2.addContract( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( isPlanVersioned && isContractVersioned ? 2 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = (Plan) s.createCriteria( Plan.class ).add( Restrictions.idEq( new Long( p.getId() ) )).uniqueResult();
 		p2 = (Plan) s.createCriteria( Plan.class ).add( Restrictions.idEq( new Long( p2.getId() ) )).uniqueResult();
 		/*
 		if ( isPlanContractsInverse ) {
 			assertEquals( 1, p.getContracts().size() );
 			c = ( Contract ) p.getContracts().iterator().next();
 			assertEquals( "gail", c.getCustomerName() );
 			if ( isPlanContractsBidirectional ) {
 				assertSame( p, c.getPlans().iterator().next() );
 			}
 			assertEquals( 0, p2.getContracts().size() );
 		}
 		else {
 		*/
 			assertEquals( 0, p.getContracts().size() );
 			assertEquals( 1, p2.getContracts().size() );
 			c = ( Contract ) p2.getContracts().iterator().next();
 			assertEquals( "gail", c.getCustomerName() );
 			if ( isPlanContractsBidirectional ) {
 				assertSame( p2, c.getPlans().iterator().next() );
 			}
 		//}
 		s.delete( p );
 		s.delete( p2 );
 		assertEquals( new Long( 0 ), s.createCriteria( Plan.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 3 );
 	}
 
 	protected void clearCounts() {
 		sessionFactory().getStatistics().clear();
 	}
 
 	protected void assertInsertCount(int expected) {
 		int inserts = ( int ) sessionFactory().getStatistics().getEntityInsertCount();
 		assertEquals( "unexpected insert count", expected, inserts );
 	}
 
 	protected void assertUpdateCount(int expected) {
 		int updates = ( int ) sessionFactory().getStatistics().getEntityUpdateCount();
 		assertEquals( "unexpected update counts", expected, updates );
 	}
 
 	protected void assertDeleteCount(int expected) {
 		int deletes = ( int ) sessionFactory().getStatistics().getEntityDeleteCount();
 		assertEquals( "unexpected delete counts", expected, deletes );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/AbstractEntityWithOneToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/AbstractEntityWithOneToManyTest.java
index 476924e558..e5133e65e9 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/AbstractEntityWithOneToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/AbstractEntityWithOneToManyTest.java
@@ -1,1222 +1,1202 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection;
 import org.junit.Test;
 
 import org.hibernate.QueryException;
 import org.hibernate.Session;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.StaleStateException;
 import org.hibernate.Transaction;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.criterion.Projections;
 import org.hibernate.criterion.Restrictions;
 import org.hibernate.internal.SessionFactoryImpl;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * @author Gail Badner
  */
 @SuppressWarnings( {"UnusedDeclaration"})
 public abstract class AbstractEntityWithOneToManyTest extends BaseCoreFunctionalTestCase {
 	private boolean isContractPartiesInverse;
 	private boolean isContractPartiesBidirectional;
 	private boolean isContractVariationsBidirectional;
 	private boolean isContractVersioned;
 	public void configure(Configuration cfg) {
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true");
 	}
 
 	protected boolean checkUpdateCountsAfterAddingExistingElement() {
 		return true;
 	}
 
 	protected boolean checkUpdateCountsAfterRemovingElementWithoutDelete() {
 		return true;
 	}
 
 	protected void prepareTest() throws Exception {
 		super.prepareTest();
 		isContractPartiesInverse = sessionFactory().getCollectionPersister( Contract.class.getName() + ".parties" ).isInverse();
 		try {
 			 sessionFactory().getEntityPersister( Party.class.getName() ).getPropertyType( "contract" );
 			isContractPartiesBidirectional = true;
 		}
 		catch ( QueryException ex) {
 			isContractPartiesBidirectional = false;
 		}
 		try {
 			 sessionFactory().getEntityPersister( ContractVariation.class.getName() ).getPropertyType( "contract" );
 			isContractVariationsBidirectional = true;
 		}
 		catch ( QueryException ex) {
 			isContractVariationsBidirectional = false;
 		}
 
 		isContractVersioned = sessionFactory().getEntityPersister( Contract.class.getName() ).isVersioned();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testUpdateProperty() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		c.addParty( new Party( "party" ) );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist(c);
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria( Contract.class ).uniqueResult();
 		c.setCustomerName( "yogi" );
 		assertEquals( 1, c.getParties().size() );
 		Party party = ( Party ) c.getParties().iterator().next();
 		party.setName( "new party" );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria( Contract.class ).uniqueResult();
 		assertEquals( 1, c.getParties().size() );
 		party = ( Party ) c.getParties().iterator().next();
 		assertEquals( "party", party.getName() );
 		if ( isContractPartiesBidirectional ) {
 			assertSame( c, party.getContract() );
 		}
 		s.delete(c);
 		assertEquals( Long.valueOf( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria( Party.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testCreateWithNonEmptyOneToManyCollectionOfNew() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		c.addParty( new Party( "party" ) );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist(c);
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria( Contract.class ).uniqueResult();
 		assertEquals( 1, c.getParties().size() );
 		Party party = ( Party ) c.getParties().iterator().next();
 		assertEquals( "party", party.getName() );
 		if ( isContractPartiesBidirectional ) {
 			assertSame( c, party.getContract() );
 		}
 		s.delete(c);
 		assertEquals( Long.valueOf( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria( Party.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testCreateWithNonEmptyOneToManyCollectionOfExisting() {
 		clearCounts();
 
 		Party party = new Party( "party" );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( party );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		c.addParty( party );
 		s = openSession();
 		t = s.beginTransaction();
 		s.save( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		// BUG, should be assertUpdateCount( ! isContractPartiesInverse && isPartyVersioned ? 1 : 0 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria( Contract.class ).uniqueResult();
 		if ( isContractPartiesInverse ) {
 			assertEquals( 0 , c.getParties().size() );
 			party = ( Party ) s.createCriteria( Party.class ).uniqueResult();
 			assertNull( party.getContract() );
 			s.delete( party );
 		}
 		else {
 			assertEquals( 1 , c.getParties().size() );
 			party = ( Party ) c.getParties().iterator().next();
 			assertEquals( "party", party.getName() );
 			if ( isContractPartiesBidirectional ) {
 				assertSame( c, party.getContract() );
 			}
 		}
 		s.delete(c);
 		assertEquals( Long.valueOf( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria( Party.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testAddNewOneToManyElementToPersistentEntity() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone" );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = ( Contract ) s.get( Contract.class, c.getId() );
 		assertEquals( 0, c.getParties().size() );
 		c.addParty( new Party( "party" ) );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria( Contract.class ).uniqueResult();
 		assertEquals( 1, c.getParties().size() );
 		Party party = ( Party ) c.getParties().iterator().next();
 		assertEquals( "party", party.getName() );
 		if ( isContractPartiesBidirectional ) {
 			assertSame( c, party.getContract() );
 		}
 		s.delete(c);
 		assertEquals( Long.valueOf( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria( Party.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testAddExistingOneToManyElementToPersistentEntity() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone" );
 		Party party = new Party( "party" );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( c );
 		s.persist( party );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = ( Contract ) s.get( Contract.class, c.getId() );
 		assertEquals( 0, c.getParties().size() );
 		party = ( Party ) s.get( Party.class, party.getId() );
 		if ( isContractPartiesBidirectional ) {
 			assertNull( party.getContract() );
 		}
 		c.addParty( party );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		if ( checkUpdateCountsAfterAddingExistingElement() ) {
 			assertUpdateCount( isContractVersioned && ! isContractPartiesInverse ? 1 : 0 );
 		}
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria( Contract.class ).uniqueResult();
 		if ( isContractPartiesInverse ) {
 			assertEquals( 0, c.getParties().size() );
 			s.delete( party );
 		}
 		else {
 			assertEquals( 1, c.getParties().size() );
 			party = ( Party ) c.getParties().iterator().next();
 			assertEquals( "party", party.getName() );
 			if ( isContractPartiesBidirectional ) {
 				assertSame( c, party.getContract() );
 			}
 		}
 		s.delete(c);
 		assertEquals( Long.valueOf( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria( Party.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testCreateWithEmptyOneToManyCollectionUpdateWithExistingElement() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		Party party = new Party( "party" );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( c );
 		s.persist( party );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		c.addParty( party );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		if ( checkUpdateCountsAfterAddingExistingElement() ) {
 			assertUpdateCount( isContractVersioned && ! isContractPartiesInverse ? 1 : 0 );
 		}
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria(Contract.class).uniqueResult();
 		if ( isContractPartiesInverse ) {
 			assertEquals( 0, c.getParties().size() );
 			s.delete( party );
 		}
 		else {
 			assertEquals( 1, c.getParties().size() );
 			party = ( Party ) c.getParties().iterator().next();
 			assertEquals( "party", party.getName() );
 			if ( isContractPartiesBidirectional ) {
 				assertSame( c, party.getContract() );
 			}
 		}
 		s.delete(c);
 		assertEquals( Long.valueOf( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria( Party.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testCreateWithNonEmptyOneToManyCollectionUpdateWithNewElement() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		Party party = new Party( "party" );
 		c.addParty( party );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist(c);
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		Party newParty = new Party( "new party" );
 		c.addParty( newParty );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria(Contract.class).uniqueResult();
 		assertEquals( 2, c.getParties().size() );
 		for ( Object o : c.getParties() ) {
 			Party aParty = (Party) o;
 			if ( aParty.getId() == party.getId() ) {
 				assertEquals( "party", aParty.getName() );
 			}
 			else if ( aParty.getId() == newParty.getId() ) {
 				assertEquals( "new party", aParty.getName() );
 			}
 			else {
 				fail( "unknown party" );
 			}
 			if ( isContractPartiesBidirectional ) {
 				assertSame( c, aParty.getContract() );
 			}
 		}
 		s.delete(c);
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Party.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 3 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnusedAssignment", "UnnecessaryBoxing"})
 	public void testCreateWithEmptyOneToManyCollectionMergeWithExistingElement() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		Party party = new Party( "party" );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( c );
 		s.persist( party );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		c.addParty( party );
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = ( Contract ) s.merge( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		if ( checkUpdateCountsAfterAddingExistingElement() ) {
 			assertUpdateCount( isContractVersioned && ! isContractPartiesInverse ? 1 : 0 );
 		}
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria( Contract.class ).uniqueResult();
 		if ( isContractPartiesInverse ) {
 			assertEquals( 0, c.getParties().size() );
 			s.delete( party );
 		}
 		else {
 			assertEquals( 1, c.getParties().size() );
 			party = ( Party ) c.getParties().iterator().next();
 			assertEquals( "party", party.getName() );
 			if ( isContractPartiesBidirectional ) {
 				assertSame( c, party.getContract() );
 			}
 		}
 		s.delete(c);
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Party.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnusedAssignment", "UnnecessaryBoxing"})
 	public void testCreateWithNonEmptyOneToManyCollectionMergeWithNewElement() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		Party party = new Party( "party" );
 		c.addParty( party );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist(c);
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		Party newParty = new Party( "new party" );
 		c.addParty( newParty );
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = ( Contract ) s.merge( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria(Contract.class).uniqueResult();
 		assertEquals( 2, c.getParties().size() );
 		for ( Object o : c.getParties() ) {
 			Party aParty = (Party) o;
 			if ( aParty.getId() == party.getId() ) {
 				assertEquals( "party", aParty.getName() );
 			}
 			else if ( !aParty.getName().equals( newParty.getName() ) ) {
 				fail( "unknown party:" + aParty.getName() );
 			}
 			if ( isContractPartiesBidirectional ) {
 				assertSame( c, aParty.getContract() );
 			}
 		}
 		s.delete(c);
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Party.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 3 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testMoveOneToManyElementToNewEntityCollection() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		c.addParty( new Party( "party" ) );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist(c);
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria( Contract.class ).uniqueResult();
 		assertEquals( 1, c.getParties().size() );
 		Party party = ( Party ) c.getParties().iterator().next();
 		assertEquals( "party", party.getName() );
 		if ( isContractPartiesBidirectional ) {
 			assertSame( c, party.getContract() );
 		}
 		c.removeParty( party );
 		Contract c2 = new Contract(null, "david", "phone" );
 		c2.addParty( party );
 		s.save( c2 );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria( Contract.class ).add( Restrictions.idEq( Long.valueOf( c.getId() ) )).uniqueResult();
 		c2 = (Contract) s.createCriteria( Contract.class ).add( Restrictions.idEq( Long.valueOf( c2.getId() ) )).uniqueResult();
 		if ( isContractPartiesInverse ) {
 			assertEquals( 1, c.getParties().size() );
 			party = ( Party ) c.getParties().iterator().next();
 			assertEquals( "party", party.getName() );
 			if ( isContractPartiesBidirectional ) {
 				assertSame( c, party.getContract() );
 			}
 			assertEquals( 0, c2.getParties().size() );
 		}
 		else {
 			assertEquals( 0, c.getParties().size() );
 			assertEquals( 1, c2.getParties().size() );
 			party = ( Party ) c2.getParties().iterator().next();
 			assertEquals( "party", party.getName() );
 			if ( isContractPartiesBidirectional ) {
 				assertSame( c2, party.getContract() );
 			}
 		}
 		s.delete(c);
 		s.delete( c2 );
 		assertEquals( new Long( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( new Long( 0 ), s.createCriteria( Party.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 3 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testMoveOneToManyElementToExistingEntityCollection() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		c.addParty( new Party( "party" ) );
 		Contract c2 = new Contract(null, "david", "phone" );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( c );
 		s.persist( c2 );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 3 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria( Contract.class ).add( Restrictions.idEq( Long.valueOf( c.getId() ) )).uniqueResult();
 		assertEquals( 1, c.getParties().size() );
 		Party party = ( Party ) c.getParties().iterator().next();
 		assertEquals( "party", party.getName() );
 		if ( isContractPartiesBidirectional ) {
 			assertSame( c, party.getContract() );
 		}
 		c.removeParty( party );
 		c2 = (Contract) s.createCriteria( Contract.class ).add( Restrictions.idEq( Long.valueOf( c2.getId() ) )).uniqueResult();
 		c2.addParty( party );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( isContractVersioned ? 2 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria( Contract.class ).add( Restrictions.idEq( Long.valueOf( c.getId() ) )).uniqueResult();
 		c2 = (Contract) s.createCriteria( Contract.class ).add( Restrictions.idEq( Long.valueOf( c2.getId() ) )).uniqueResult();
 		if ( isContractPartiesInverse ) {
 			assertEquals( 1, c.getParties().size() );
 			party = ( Party ) c.getParties().iterator().next();
 			assertEquals( "party", party.getName() );
 			if ( isContractPartiesBidirectional ) {
 				assertSame( c, party.getContract() );
 			}
 			assertEquals( 0, c2.getParties().size() );
 		}
 		else {
 			assertEquals( 0, c.getParties().size() );
 			assertEquals( 1, c2.getParties().size() );
 			party = ( Party ) c2.getParties().iterator().next();
 			assertEquals( "party", party.getName() );
 			if ( isContractPartiesBidirectional ) {
 				assertSame( c2, party.getContract() );
 			}
 		}
 		s.delete(c);
 		s.delete( c2 );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria( Contract.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria( Party.class ).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 3 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testRemoveOneToManyElementUsingUpdate() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		Party party = new Party( "party" );
 		c.addParty( party );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		c.removeParty( party );
 		assertEquals( 0, c.getParties().size() );
 		if ( isContractPartiesBidirectional ) {
 			assertNull( party.getContract() );
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( c );
 		s.update( party );
 		t.commit();
 		s.close();
 
 		if ( checkUpdateCountsAfterRemovingElementWithoutDelete() ) {
 			assertUpdateCount( isContractVersioned && ! isContractPartiesInverse ? 1 : 0 );
 		}
 		assertDeleteCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = ( Contract ) s.createCriteria( Contract.class ).uniqueResult();
 		if ( isContractPartiesInverse ) {
 			assertEquals( 1, c.getParties().size() );
 			party = ( Party ) c.getParties().iterator().next();
 			assertEquals( "party", party.getName() );
 			assertSame( c, party.getContract() );
 		}
 		else {
 			assertEquals( 0, c.getParties().size() );
 			party = ( Party ) s.createCriteria( Party.class ).uniqueResult();
 			if ( isContractPartiesBidirectional ) {
 				assertNull( party.getContract() );
 			}
 			s.delete( party );
 		}
 		s.delete( c );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Party.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnusedAssignment", "UnnecessaryBoxing"})
 	public void testRemoveOneToManyElementUsingMerge() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		Party party = new Party( "party" );
 		c.addParty( party );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		c.removeParty( party );
 		assertEquals( 0, c.getParties().size() );
 		if ( isContractPartiesBidirectional ) {
 			assertNull( party.getContract() );
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = ( Contract ) s.merge( c );
 		party = ( Party ) s.merge( party );
 		t.commit();
 		s.close();
 
 		if ( checkUpdateCountsAfterRemovingElementWithoutDelete() ) {
 			assertUpdateCount( isContractVersioned && ! isContractPartiesInverse ? 1 : 0 );
 		}
 		assertDeleteCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = ( Contract ) s.createCriteria( Contract.class ).uniqueResult();
 		if ( isContractPartiesInverse ) {
 			assertEquals( 1, c.getParties().size() );
 			party = ( Party ) c.getParties().iterator().next();
 			assertEquals( "party", party.getName() );
 			assertSame( c, party.getContract() );
 		}
 		else {
 			assertEquals( 0, c.getParties().size() );
 			party = ( Party ) s.createCriteria( Party.class ).uniqueResult();
 			if ( isContractPartiesBidirectional ) {
 				assertNull( party.getContract() );
 			}
 			s.delete( party );
 		}
 		s.delete( c );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Party.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testDeleteOneToManyElement() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		Party party = new Party( "party" );
 		c.addParty( party );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( c );
 		c.removeParty( party );
 		s.delete( party );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		assertDeleteCount( 1 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = ( Contract ) s.createCriteria( Contract.class ).uniqueResult();
 		assertEquals( 0, c.getParties().size() );
 		party = ( Party ) s.createCriteria( Party.class ).uniqueResult();
 		assertNull( party );
 		s.delete( c );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Party.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 1 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testRemoveOneToManyElementByDelete() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		Party party = new Party( "party" );
 		c.addParty( party );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		c.removeParty( party );
 		assertEquals( 0, c.getParties().size() );
 		if ( isContractPartiesBidirectional ) {
 			assertNull( party.getContract() );
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( c );
 		s.delete( party );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		assertDeleteCount( 1 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = ( Contract ) s.createCriteria( Contract.class ).uniqueResult();
 		assertEquals( 0, c.getParties().size() );
 		s.delete( c );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Party.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 1 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testRemoveOneToManyOrphanUsingUpdate() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		ContractVariation cv = new ContractVariation( 1, c );
 		cv.setText( "cv1" );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		c.getVariations().remove( cv );
 		cv.setContract( null );
 		assertEquals( 0, c.getVariations().size() );
 		if ( isContractVariationsBidirectional ) {
 			assertNull( cv.getContract() );
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( c );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		assertDeleteCount( 1 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = ( Contract ) s.createCriteria( Contract.class ).uniqueResult();
 		assertEquals( 0, c.getVariations().size() );
 		cv = ( ContractVariation ) s.createCriteria( ContractVariation.class ).uniqueResult();
 		assertNull( cv );
 		s.delete( c );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(ContractVariation.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 1 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnusedAssignment", "UnnecessaryBoxing"})
 	public void testRemoveOneToManyOrphanUsingMerge() {
 		Contract c = new Contract( null, "gail", "phone");
 		ContractVariation cv = new ContractVariation( 1, c );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		c.getVariations().remove( cv );
 		cv.setContract( null );
 		assertEquals( 0, c.getVariations().size() );
 		if ( isContractVariationsBidirectional ) {
 			assertNull( cv.getContract() );
 		}
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = ( Contract ) s.merge( c );
 		cv = ( ContractVariation ) s.merge( cv );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		assertDeleteCount( 1 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = ( Contract ) s.createCriteria( Contract.class ).uniqueResult();
 		assertEquals( 0, c.getVariations().size() );
 		cv = ( ContractVariation ) s.createCriteria( ContractVariation.class ).uniqueResult();
 		assertNull( cv );
 		s.delete( c );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(ContractVariation.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 1 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testDeleteOneToManyOrphan() {
 		clearCounts();
 
 		Contract c = new Contract( null, "gail", "phone");
 		ContractVariation cv = new ContractVariation( 1, c );
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist( c );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( c );
 		c.getVariations().remove( cv );
 		cv.setContract( null );
 		assertEquals( 0, c.getVariations().size() );
 		s.delete( cv );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		assertDeleteCount( 1 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = ( Contract ) s.createCriteria( Contract.class ).uniqueResult();
 		assertEquals( 0, c.getVariations().size() );
 		cv = ( ContractVariation ) s.createCriteria( ContractVariation.class ).uniqueResult();
 		assertNull( cv );
 		s.delete( c );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(ContractVariation.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 1 );
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	@Test
 	public void testOneToManyCollectionOptimisticLockingWithMerge() {
 		clearCounts();
 
 		Contract cOrig = new Contract( null, "gail", "phone");
 		Party partyOrig = new Party( "party" );
 		cOrig.addParty( partyOrig );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist(cOrig);
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Contract c = ( Contract ) s.get( Contract.class, cOrig.getId() );
 		Party newParty = new Party( "new party" );
 		c.addParty( newParty );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		cOrig.removeParty( partyOrig );
 		try {
 			s.merge( cOrig );
 			assertFalse( isContractVersioned );
 		}
 		catch (StaleObjectStateException ex) {
 			assertTrue( isContractVersioned);
 		}
 		finally {
 			t.rollback();
 		}
 		s.close();
 		
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria(Contract.class).uniqueResult();
 		s.delete(c);
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Party.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 3 );
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	@Test
 	public void testOneToManyCollectionOptimisticLockingWithUpdate() {
 		clearCounts();
 
 		Contract cOrig = new Contract( null, "gail", "phone");
 		Party partyOrig = new Party( "party" );
 		cOrig.addParty( partyOrig );
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.persist(cOrig);
 		t.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Contract c = ( Contract ) s.get( Contract.class, cOrig.getId() );
 		Party newParty = new Party( "new party" );
 		c.addParty( newParty );
 		t.commit();
 		s.close();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( isContractVersioned ? 1 : 0 );
 		clearCounts();
 
 		s = openSession();
 		t = s.beginTransaction();
 		cOrig.removeParty( partyOrig );
 		s.update( cOrig );
 		try {
 			t.commit();
 			assertFalse( isContractVersioned );
 		}
 		catch (StaleStateException ex) {
 			t.rollback();
 			assertTrue( isContractVersioned );
 			if ( ! sessionFactory().getSettings().isJdbcBatchVersionedData() ) {
 				assertTrue( StaleObjectStateException.class.isInstance( ex ) );
 			}
 		}
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Contract) s.createCriteria(Contract.class).uniqueResult();
 		s.createQuery( "delete from Party" ).executeUpdate();
 		s.delete( c );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Contract.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		assertEquals( Long.valueOf( 0 ), s.createCriteria(Party.class).setProjection( Projections.rowCount() ).uniqueResult() );
 		t.commit();
 		s.close();
 	}
 
 	protected void clearCounts() {
 		sessionFactory().getStatistics().clear();
 	}
 
 	protected void assertInsertCount(int expected) {
 		int inserts = ( int ) sessionFactory().getStatistics().getEntityInsertCount();
 		assertEquals( "unexpected insert count", expected, inserts );
 	}
 
 	protected void assertUpdateCount(int expected) {
 		int updates = ( int ) sessionFactory().getStatistics().getEntityUpdateCount();
 		assertEquals( "unexpected update counts", expected, updates );
 	}
 
 	protected void assertDeleteCount(int expected) {
 		int deletes = ( int ) sessionFactory().getStatistics().getEntityDeleteCount();
 		assertEquals( "unexpected delete counts", expected, deletes );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Info.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Info.java
index 0b31f54158..5932498ed9 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Info.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Info.java
@@ -1,65 +1,65 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.immutable.entitywithmutablecollection;
 import java.io.Serializable;
 
 public class Info implements Serializable {
 
 	private long id;
 	private String text;
 	private long version;
 
 	public Info() {
 		super();
 	}
 
 	public Info(String text) {
 		this.text = text;
 	}
 
 	public long getVersion() {
 		return version;
 	}
 
 	public void setVersion(long version) {
 		this.version = version;
 	}
 
 	public String getText() {
 		return text;
 	}
 
 	public void setText(String text) {
 		this.text = text;
 	}
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Owner.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Owner.java
index f81b3d8f8e..864924e793 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Owner.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Owner.java
@@ -1,75 +1,75 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.immutable.entitywithmutablecollection;
 import java.io.Serializable;
 
 public class Owner implements Serializable {
 
 	private long id;
 	private long version;
 	private Plan plan;
 	private String name;
 
 	public Owner() {
 		super();
 	}
 
 	public Owner(String name) {
 		this.name = name;
 	}
 
 	public long getVersion() {
 		return version;
 	}
 
 	public void setVersion(long version) {
 		this.version = version;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public Plan getPlan() {
 		return plan;
 	}
 
 	public void setPlan(Plan plan) {
 		this.plan = plan;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Party.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Party.java
index 3672c7bb29..b6169c8c3c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Party.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Party.java
@@ -1,85 +1,85 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.immutable.entitywithmutablecollection;
 import java.io.Serializable;
 import java.util.HashSet;
 import java.util.Set;
 
 public class Party implements Serializable {
 
 	private long id;
 	private long version;
 	private Contract contract;
 	private String name;
 	private Set infos = new HashSet();
 
 	public Party() {
 		super();
 	}
 
 	public Party(String name) {
 		this.name = name;
 	}
 
 	public long getVersion() {
 		return version;
 	}
 
 	public void setVersion(long version) {
 		this.version = version;
 	}
 	
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public Contract getContract() {
 		return contract;
 	}
 
 	public void setContract(Contract contract) {
 		this.contract = contract;
 	}
 
 	public Set getInfos() {
 		return infos;
 	}
 
 	public void setInfos(Set infos) {
 		this.infos = infos;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Plan.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Plan.java
index e7875f66a8..c211f97ee4 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Plan.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/Plan.java
@@ -1,130 +1,130 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.immutable.entitywithmutablecollection;
 import java.io.Serializable;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Set;
 
 public class Plan implements Serializable {
 
 	private long id;
 	private long version;
 	private String description;
 	private Set contracts;
 	private Set infos;
 	private Owner owner;
 
 	public Plan() {
 		this( null );
 	}
 
 	public Plan(String description) {
 		this.description = description;
 		contracts = new HashSet();
 		infos = new HashSet();
 	}
 
 	public long getVersion() {
 		return version;
 	}
 
 	public void setVersion(long version) {
 		this.version = version;
 	}
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public String getDescription() {
 		return description;
 	}
 
 	public void setDescription(String description) {
 		this.description = description;
 	}
 
 	public Set getContracts() {
 		return contracts;
 	}
 
 	public void setContracts(Set contracts) {
 		this.contracts = contracts;
 	}
 
 	public void addContract(Contract contract) {
 		if ( ! contracts.add( contract ) ) {
 			return;
 		}
 		if ( contract.getParent() != null ) {
 			addContract( contract.getParent() );
 		}
 		contract.getPlans().add( this );
 		for ( Iterator it=contract.getSubcontracts().iterator(); it.hasNext(); ) {
 			Contract sub = ( Contract ) it.next();
 			addContract( sub );
 		}
 	}
 
 	public void removeContract(Contract contract) {
 		if ( contract.getParent() != null ) {
 			contract.getParent().getSubcontracts().remove( contract );
 			contract.setParent( null );			
 		}
 		removeSubcontracts( contract );
 		contract.getPlans().remove( this );
 		contracts.remove( contract );
 	}
 
 	public void removeSubcontracts(Contract contract) {
 		for ( Iterator it=contract.getSubcontracts().iterator(); it.hasNext(); ) {
 			Contract sub = ( Contract ) it.next();
 			removeSubcontracts( sub );
 			sub.getPlans().remove( this );
 			contracts.remove( sub );
 		}
 	}
 
 	public Set getInfos() {
 		return infos;
 	}
 
 	public void setInfos(Set infos) {
 		this.infos = infos;
 	}
 
 	public Owner getOwner() {
 		return owner;
 	}
 
 	public void setOwner(Owner owner) {
 		this.owner = owner;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/EntityWithInverseManyToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/EntityWithInverseManyToManyTest.java
index fd6c41fd34..eaedc0c38d 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/EntityWithInverseManyToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/EntityWithInverseManyToManyTest.java
@@ -1,36 +1,36 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.inverse;
 
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithManyToManyTest;
 
 /**
  * @author Gail Badner
  */
 public class EntityWithInverseManyToManyTest extends AbstractEntityWithManyToManyTest {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/inverse/ContractVariation.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/EntityWithInverseOneToManyJoinTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/EntityWithInverseOneToManyJoinTest.java
index 913564f870..48c693a3c8 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/EntityWithInverseOneToManyJoinTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/EntityWithInverseOneToManyJoinTest.java
@@ -1,42 +1,42 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.inverse;
 
 import org.hibernate.dialect.CUBRIDDialect;
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithOneToManyTest;
 import org.hibernate.testing.SkipForDialect;
 
 /**
  * @author Gail Badner
  */
 @SkipForDialect(
         value = CUBRIDDialect.class,
         comment = "As of verion 8.4.1 CUBRID doesn't support temporary tables. This test fails with" +
                 "HibernateException: cannot doAfterTransactionCompletion multi-table deletes using dialect not supporting temp tables"
 )
 public class EntityWithInverseOneToManyJoinTest extends AbstractEntityWithOneToManyTest {
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/inverse/ContractVariationOneToManyJoin.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/EntityWithInverseOneToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/EntityWithInverseOneToManyTest.java
index 722b590bf7..c84291ec25 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/EntityWithInverseOneToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/EntityWithInverseOneToManyTest.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.inverse;
 
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithOneToManyTest;
 
 /**
  * @author Gail Badner
  */
 public class EntityWithInverseOneToManyTest extends AbstractEntityWithOneToManyTest {
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/inverse/ContractVariation.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseManyToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseManyToManyTest.java
index 8dffa3b6be..54a6196d79 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseManyToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseManyToManyTest.java
@@ -1,36 +1,36 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.inverse;
 
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithManyToManyTest;
 
 /**
  * @author Gail Badner
  */
 public class VersionedEntityWithInverseManyToManyTest extends AbstractEntityWithManyToManyTest {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/inverse/ContractVariationVersioned.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyFailureExpectedTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyFailureExpectedTest.java
index 0379ae0854..9135d5dc3b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyFailureExpectedTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyFailureExpectedTest.java
@@ -1,90 +1,90 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.inverse;
 
 import org.junit.Test;
 
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithOneToManyTest;
 import org.hibernate.testing.FailureExpected;
 
 /**
  * @author Gail Badner
  *
  * These tests reproduce HHH-4992.
  */
 public class VersionedEntityWithInverseOneToManyFailureExpectedTest extends AbstractEntityWithOneToManyTest {
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/inverse/ContractVariationVersioned.hbm.xml" };
 	}
 
 	@Test
 	@Override
 	@FailureExpected(
 			jiraKey = "HHH-4992",
 			message = "known to fail with versioned entity with inverse collection"
 	)
 	public void testAddExistingOneToManyElementToPersistentEntity() {
 		super.testAddExistingOneToManyElementToPersistentEntity();
 	}
 
 	@Test
 	@Override
 	@FailureExpected(
 			jiraKey = "HHH-4992",
 			message = "known to fail with versioned entity with inverse collection"
 	)
 	public void testCreateWithEmptyOneToManyCollectionUpdateWithExistingElement() {
 		super.testCreateWithEmptyOneToManyCollectionUpdateWithExistingElement();
 	}
 
 	@Test
 	@Override
 	@FailureExpected(
 			jiraKey = "HHH-4992",
 			message = "known to fail with versioned entity with inverse collection"
 	)
 	public void testCreateWithEmptyOneToManyCollectionMergeWithExistingElement() {
 		super.testCreateWithEmptyOneToManyCollectionMergeWithExistingElement();
 	}
 
 	@Test
 	@Override
 	@FailureExpected(
 			jiraKey = "HHH-4992",
 			message = "known to fail with versioned entity with inverse collection"
 	)
 	public void testRemoveOneToManyElementUsingUpdate() {
 		super.testRemoveOneToManyElementUsingUpdate();
 	}
 
 	@Test
 	@Override
 	@FailureExpected(
 			jiraKey = "HHH-4992",
 			message = "known to fail with versioned entity with inverse collection"
 	)
 	public void testRemoveOneToManyElementUsingMerge() {
 		super.testRemoveOneToManyElementUsingMerge();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyJoinFailureExpectedTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyJoinFailureExpectedTest.java
index 18e5b0b54f..ef1642834f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyJoinFailureExpectedTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyJoinFailureExpectedTest.java
@@ -1,95 +1,95 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.inverse;
 
 import org.hibernate.dialect.CUBRIDDialect;
 import org.hibernate.testing.SkipForDialect;
 import org.junit.Test;
 
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithOneToManyTest;
 import org.hibernate.testing.FailureExpected;
 
 /**
  * @author Gail Badner
  */
 @SkipForDialect(
         value = CUBRIDDialect.class,
         comment = "As of verion 8.4.1 CUBRID doesn't support temporary tables. This test fails with" +
                 "HibernateException: cannot doAfterTransactionCompletion multi-table deletes using dialect not supporting temp tables"
 )
 public class VersionedEntityWithInverseOneToManyJoinFailureExpectedTest extends AbstractEntityWithOneToManyTest {
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/inverse/ContractVariationVersionedOneToManyJoin.hbm.xml" };
 	}
 
 	@Test
 	@Override
 	@FailureExpected(
 			jiraKey = "HHH-4992",
 			message = "known to fail with inverse collection"
 	)
 	public void testAddExistingOneToManyElementToPersistentEntity() {
 		super.testAddExistingOneToManyElementToPersistentEntity();
 	}
 
 	@Test
 	@Override
 	@FailureExpected(
 			jiraKey = "HHH-4992",
 			message = "known to fail with inverse collection"
 	)
 	public void testCreateWithEmptyOneToManyCollectionUpdateWithExistingElement() {
 		super.testCreateWithEmptyOneToManyCollectionUpdateWithExistingElement();
 	}
 
 	@Test
 	@Override
 	@FailureExpected(
 			jiraKey = "HHH-4992",
 			message = "known to fail with inverse collection"
 	)
 	public void testCreateWithEmptyOneToManyCollectionMergeWithExistingElement() {
 		super.testCreateWithEmptyOneToManyCollectionMergeWithExistingElement();
 	}
 
 	@Test
 	@Override
 	@FailureExpected(
 			jiraKey = "HHH-4992",
 			message = "known to fail with inverse collection"
 	)
 	public void testRemoveOneToManyElementUsingUpdate() {
 		super.testRemoveOneToManyElementUsingUpdate();
 	}
 
 	@Test
 	@Override
 	@FailureExpected(
 			jiraKey = "HHH-4992",
 			message = "known to fail with inverse collection"
 	)
 	public void testRemoveOneToManyElementUsingMerge() {
 		super.testRemoveOneToManyElementUsingMerge();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyJoinTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyJoinTest.java
index 57509a90a9..55fe3a2e55 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyJoinTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyJoinTest.java
@@ -1,53 +1,53 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.inverse;
 
 import org.hibernate.dialect.CUBRIDDialect;
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithOneToManyTest;
 import org.hibernate.testing.SkipForDialect;
 import org.hibernate.testing.TestForIssue;
 
 
 /**
  * @author Gail Badner
  */
 @TestForIssue( jiraKey = "HHH-4992" )
 @SkipForDialect(
         value = CUBRIDDialect.class,
         comment = "As of verion 8.4.1 CUBRID doesn't support temporary tables. This test fails with" +
                 "HibernateException: cannot doAfterTransactionCompletion multi-table deletes using dialect not supporting temp tables"
 )
 public class VersionedEntityWithInverseOneToManyJoinTest extends AbstractEntityWithOneToManyTest {
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/inverse/ContractVariationVersionedOneToManyJoin.hbm.xml" };
 	}
 
 	protected boolean checkUpdateCountsAfterAddingExistingElement() {
 		return false;
 	}
 
 	protected boolean checkUpdateCountsAfterRemovingElementWithoutDelete() {
 		return false;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyTest.java
index a0e01ebbc1..07d6a8c59e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/inverse/VersionedEntityWithInverseOneToManyTest.java
@@ -1,43 +1,43 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.inverse;
 
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithOneToManyTest;
 
 /**
  * @author Gail Badner
  */
 public class VersionedEntityWithInverseOneToManyTest extends AbstractEntityWithOneToManyTest {
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/inverse/ContractVariationVersioned.hbm.xml" };
 	}
 
 	protected boolean checkUpdateCountsAfterAddingExistingElement() {
 		return false;
 	}
 
 	protected boolean checkUpdateCountsAfterRemovingElementWithoutDelete() {
 		return false;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseManyToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseManyToManyTest.java
index 729745d13b..2d74e3caa9 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseManyToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseManyToManyTest.java
@@ -1,36 +1,36 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.noninverse;
 
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithManyToManyTest;
 
 /**
  * @author Gail Badner
  */
 public class EntityWithNonInverseManyToManyTest extends AbstractEntityWithManyToManyTest {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/noninverse/ContractVariation.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseManyToManyUnidirTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseManyToManyUnidirTest.java
index 68f8f236ee..9778ca81b3 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseManyToManyUnidirTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseManyToManyUnidirTest.java
@@ -1,36 +1,36 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.noninverse;
 
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithManyToManyTest;
 
 /**
  * @author Gail Badner
  */
 public class EntityWithNonInverseManyToManyUnidirTest extends AbstractEntityWithManyToManyTest {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/noninverse/ContractVariationUnidir.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseOneToManyJoinTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseOneToManyJoinTest.java
index 947d3fd69f..7f13f72c87 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseOneToManyJoinTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseOneToManyJoinTest.java
@@ -1,42 +1,42 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.noninverse;
 
 import org.hibernate.dialect.CUBRIDDialect;
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithOneToManyTest;
 import org.hibernate.testing.SkipForDialect;
 
 /**
  * @author Gail Badner
  */
 @SkipForDialect(
         value = CUBRIDDialect.class,
         comment = "As of verion 8.4.1 CUBRID doesn't support temporary tables. This test fails with" +
                 "HibernateException: cannot doAfterTransactionCompletion multi-table deletes using dialect not supporting temp tables"
 )
 public class EntityWithNonInverseOneToManyJoinTest extends AbstractEntityWithOneToManyTest {
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/noninverse/ContractVariationOneToManyJoin.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseOneToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseOneToManyTest.java
index bf2ede12d8..84d2170aaa 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseOneToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseOneToManyTest.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.noninverse;
 
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithOneToManyTest;
 
 /**
  * @author Gail Badner
  */
 public class EntityWithNonInverseOneToManyTest extends AbstractEntityWithOneToManyTest {
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/noninverse/ContractVariation.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseOneToManyUnidirTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseOneToManyUnidirTest.java
index a9c2cbb44b..3fe6c4c260 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseOneToManyUnidirTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/EntityWithNonInverseOneToManyUnidirTest.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.noninverse;
 
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithOneToManyTest;
 
 /**
  * @author Gail Badner
  */
 public class EntityWithNonInverseOneToManyUnidirTest extends AbstractEntityWithOneToManyTest {
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/noninverse/ContractVariationUnidir.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/VersionedEntityWithNonInverseManyToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/VersionedEntityWithNonInverseManyToManyTest.java
index 02ff97e3ad..2dfbf5d0e4 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/VersionedEntityWithNonInverseManyToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/VersionedEntityWithNonInverseManyToManyTest.java
@@ -1,36 +1,36 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.noninverse;
 
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithManyToManyTest;
 
 /**
  * @author Gail Badner
  */
 public class VersionedEntityWithNonInverseManyToManyTest extends AbstractEntityWithManyToManyTest {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/noninverse/ContractVariationVersioned.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/VersionedEntityWithNonInverseOneToManyJoinTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/VersionedEntityWithNonInverseOneToManyJoinTest.java
index 11c71880fb..7f504bbcdc 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/VersionedEntityWithNonInverseOneToManyJoinTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/VersionedEntityWithNonInverseOneToManyJoinTest.java
@@ -1,42 +1,42 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.noninverse;
 
 import org.hibernate.dialect.CUBRIDDialect;
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithOneToManyTest;
 import org.hibernate.testing.SkipForDialect;
 
 /**
  * @author Gail Badner
  */
 @SkipForDialect(
         value = CUBRIDDialect.class,
         comment = "As of verion 8.4.1 CUBRID doesn't support temporary tables. This test fails with" +
                 "HibernateException: cannot doAfterTransactionCompletion multi-table deletes using dialect not supporting temp tables"
 )
 public class VersionedEntityWithNonInverseOneToManyJoinTest extends AbstractEntityWithOneToManyTest {
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/noninverse/ContractVariationVersionedOneToManyJoin.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/VersionedEntityWithNonInverseOneToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/VersionedEntityWithNonInverseOneToManyTest.java
index 02ed983266..f4f239e1b0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/VersionedEntityWithNonInverseOneToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/immutable/entitywithmutablecollection/noninverse/VersionedEntityWithNonInverseOneToManyTest.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.immutable.entitywithmutablecollection.noninverse;
 
 import org.hibernate.test.immutable.entitywithmutablecollection.AbstractEntityWithOneToManyTest;
 
 /**
  * @author Gail Badner
  */
 public class VersionedEntityWithNonInverseOneToManyTest extends AbstractEntityWithOneToManyTest {
 	public String[] getMappings() {
 		return new String[] { "immutable/entitywithmutablecollection/noninverse/ContractVariationVersioned.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/TestLazyPropertyCustomTypeExecutable.java b/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/TestLazyPropertyCustomTypeExecutable.java
index b17afd2472..ea9a0407e1 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/TestLazyPropertyCustomTypeExecutable.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/instrument/cases/TestLazyPropertyCustomTypeExecutable.java
@@ -1,91 +1,91 @@
 package org.hibernate.test.instrument.cases;
 import java.util.Iterator;
 
 import junit.framework.Assert;
 
 import org.hibernate.Session;
 import org.hibernate.bytecode.instrumentation.internal.FieldInterceptionHelper;
 import org.hibernate.test.instrument.domain.Problematic;
 
 /**
  * {@inheritDoc}
  *
  * @author Steve Ebersole
  */
 public class TestLazyPropertyCustomTypeExecutable extends AbstractExecutable {
 
 	protected String[] getResources() {
 		return new String[] { "org/hibernate/test/instrument/domain/Problematic.hbm.xml" };
 	}
 
 	public void execute() throws Exception {
 		Session s = getFactory().openSession();
 		Problematic p = new Problematic();
 		try {
 			s.beginTransaction();
 			p.setName( "whatever" );
 			p.setBytes( new byte[] { 1, 0, 1, 1, 0 } );
 			s.save( p );
 			s.getTransaction().commit();
 		} catch (Exception e) {
 			s.getTransaction().rollback();
 			throw e;
 		} finally {
 			s.close();
 		}
 
 		// this access should be ok because p1 is not a lazy proxy 
 		s = getFactory().openSession();
 		try {
 			s.beginTransaction();
 			Problematic p1 = (Problematic) s.get( Problematic.class, p.getId() );
 			Assert.assertTrue( FieldInterceptionHelper.isInstrumented( p1 ) );
 			p1.getRepresentation();
 			s.getTransaction().commit();
 		} catch (Exception e) {
 			s.getTransaction().rollback();
 			throw e;
 		} finally {
 			s.close();
 		}
 		
 		s = getFactory().openSession();
 		try {
 			s.beginTransaction();
 			Problematic p1 = (Problematic) s.createQuery( "from Problematic" ).setReadOnly(true ).list().get( 0 );
 			p1.getRepresentation();
 			s.getTransaction().commit();
 		} catch (Exception e) {
 			s.getTransaction().rollback();
 			throw e;
 		} finally {
 			s.close();
 		}
 		
 		s = getFactory().openSession();
 		try {
 			s.beginTransaction();
 			Problematic p1 = (Problematic) s.load( Problematic.class, p.getId() );
 			Assert.assertFalse( FieldInterceptionHelper.isInstrumented( p1 ) );
 			p1.setRepresentation( p.getRepresentation() );
 			s.getTransaction().commit();
 		} catch (Exception e) {
 			s.getTransaction().rollback();
 			throw e;
 		} finally {
 			s.close();
 		}
 	}
 
 	protected void cleanup() {
 		Session s = getFactory().openSession();
 		s.beginTransaction();
 		Iterator itr = s.createQuery( "from Problematic" ).list().iterator();
 		while ( itr.hasNext() ) {
 			Problematic p = (Problematic) itr.next();
 			s.delete( p );
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/instrument/domain/CustomBlobType.java b/hibernate-core/src/test/java/org/hibernate/test/instrument/domain/CustomBlobType.java
index b37d712827..02ce15bedf 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/instrument/domain/CustomBlobType.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/instrument/domain/CustomBlobType.java
@@ -1,110 +1,110 @@
 package org.hibernate.test.instrument.domain;
 
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Types;
 import java.util.Arrays;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.usertype.UserType;
 
 /**
  * A simple byte[]-based custom type.
  */
 public class CustomBlobType implements UserType {
 	/**
 	 * {@inheritDoc}
 	 */
 	public Object nullSafeGet(ResultSet rs, String names[], SessionImplementor session, Object owner) throws SQLException {
 		// cast just to make sure...
 		return StandardBasicTypes.BINARY.nullSafeGet( rs, names[0], session );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void nullSafeSet(PreparedStatement ps, Object value, int index, SessionImplementor session) throws SQLException, HibernateException {
 		// cast just to make sure...
 		StandardBasicTypes.BINARY.nullSafeSet( ps, value, index, session );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Object deepCopy(Object value) {
 		byte result[] = null;
 
 		if ( value != null ) {
 			byte bytes[] = ( byte[] ) value;
 
 			result = new byte[bytes.length];
 			System.arraycopy( bytes, 0, result, 0, bytes.length );
 		}
 
 		return result;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public boolean isMutable() {
 		return true;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public int[] sqlTypes() {
 		return new int[] { Types.VARBINARY };
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Class returnedClass() {
 		return byte[].class;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public boolean equals(Object x, Object y) {
 		return Arrays.equals( ( byte[] ) x, ( byte[] ) y );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Object assemble(Serializable arg0, Object arg1)
 			throws HibernateException {
 		return null;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Serializable disassemble(Object arg0)
 			throws HibernateException {
 		return null;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public int hashCode(Object arg0)
 			throws HibernateException {
 		return 0;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Object replace(Object arg0, Object arg1, Object arg2)
 			throws HibernateException {
 		return null;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/interceptor/InstantiateInterceptor.java b/hibernate-core/src/test/java/org/hibernate/test/interceptor/InstantiateInterceptor.java
index 2ec32ae892..3566bedde0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/interceptor/InstantiateInterceptor.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/interceptor/InstantiateInterceptor.java
@@ -1,53 +1,53 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 
 /**
  * @author Gail Badner
  */
 package org.hibernate.test.interceptor;
 import java.io.Serializable;
 
 import org.hibernate.CallbackException;
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.EntityMode;
 
 public class InstantiateInterceptor extends EmptyInterceptor {
 	private String injectedString;
 
 	public InstantiateInterceptor(String injectedString) {
 		this.injectedString = injectedString;		
 	}
 
 	public Object instantiate(String entityName, EntityMode entityMode, Serializable id) throws CallbackException {
 		if ( ! "org.hibernate.test.interceptor.User".equals( entityName ) ) {
 			return null;
 		}
 		// Simply inject a sample string into new instances
 		User instance = new User();
 		instance.setName( ( String ) id );
 		instance.setInjectedString( injectedString );
 		return instance;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/Document.java b/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/Document.java
index 804eb88e6c..d28fd5fda6 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/Document.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/Document.java
@@ -1,23 +1,23 @@
 //$Id: Document.java 4407 2004-08-22 01:20:08Z oneovthafew $
 package org.hibernate.test.interfaceproxy;
 import java.sql.Blob;
 import java.util.Calendar;
 
 /**
  * @author Gavin King
  */
 public interface Document extends Item {
 	/**
 	 * @return Returns the content.
 	 */
 	public Blob getContent();
 
 	/**
 	 * @param content The content to set.
 	 */
 	public void setContent(Blob content);
 	
 	public Calendar getCreated();
 	
 	public Calendar getModified();
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/Folder.java b/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/Folder.java
index 258c8a642b..815181b532 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/Folder.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/Folder.java
@@ -1,18 +1,18 @@
 //$Id: Folder.java 4407 2004-08-22 01:20:08Z oneovthafew $
 package org.hibernate.test.interfaceproxy;
 
 
 /**
  * @author Gavin King
  */
 public interface Folder extends Item {
 	/**
 	 * @return Returns the parent.
 	 */
 	public Folder getParent();
 
 	/**
 	 * @param parent The parent to set.
 	 */
 	public void setParent(Folder parent);
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/Item.java b/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/Item.java
index 9499d892d9..bcf28fac97 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/Item.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/Item.java
@@ -1,23 +1,23 @@
 //$Id: Item.java 4407 2004-08-22 01:20:08Z oneovthafew $
 package org.hibernate.test.interfaceproxy;
 
 
 /**
  * @author Gavin King
  */
 public interface Item {
 	/**
 	 * @return Returns the id.
 	 */
 	public Long getId();
 
 	/**
 	 * @return Returns the name.
 	 */
 	public String getName();
 
 	/**
 	 * @param name The name to set.
 	 */
 	public void setName(String name);
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/SecureDocument.java b/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/SecureDocument.java
index f7c5862eff..1b14cb4f06 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/SecureDocument.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/interfaceproxy/SecureDocument.java
@@ -1,28 +1,28 @@
 //$Id: SecureDocument.java 4407 2004-08-22 01:20:08Z oneovthafew $
 package org.hibernate.test.interfaceproxy;
 
 
 /**
  * @author Gavin King
  */
 public interface SecureDocument extends Document {
 	/**
 	 * @return Returns the owner.
 	 */
 	public String getOwner();
 
 	/**
 	 * @param owner The owner to set.
 	 */
 	public void setOwner(String owner);
 
 	/**
 	 * @return Returns the permissionBits.
 	 */
 	public byte getPermissionBits();
 
 	/**
 	 * @param permissionBits The permissionBits to set.
 	 */
 	public void setPermissionBits(byte permissionBits);
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/jpa/naturalid/ClassWithIdentityColumn.java b/hibernate-core/src/test/java/org/hibernate/test/jpa/naturalid/ClassWithIdentityColumn.java
index 6b8f8d3415..29b4589d51 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/jpa/naturalid/ClassWithIdentityColumn.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/jpa/naturalid/ClassWithIdentityColumn.java
@@ -1,27 +1,27 @@
 package org.hibernate.test.jpa.naturalid;
 
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 
 import org.hibernate.annotations.NaturalId;
 
 @Entity
 public class ClassWithIdentityColumn {
 	@Id
 	@GeneratedValue(strategy = GenerationType.IDENTITY)
 	private long id;
 
 	@NaturalId(mutable = true)
 	private String name;
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/jpa/naturalid/ImmutableNaturalIdTest.java b/hibernate-core/src/test/java/org/hibernate/test/jpa/naturalid/ImmutableNaturalIdTest.java
index 8cfc91aab2..bdc9001fbf 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/jpa/naturalid/ImmutableNaturalIdTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/jpa/naturalid/ImmutableNaturalIdTest.java
@@ -1,349 +1,349 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.jpa.naturalid;
 
 import org.junit.Test;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.criterion.Restrictions;
 import org.hibernate.test.jpa.AbstractJPATest;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * copied from {@link org.hibernate.test.naturalid.immutable.ImmutableNaturalIdTest}
  *
  * @author Steve Ebersole
  */
 public class ImmutableNaturalIdTest extends AbstractJPATest {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "jpa/naturalid/User.hbm.xml" };
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.USE_SECOND_LEVEL_CACHE, "true" );
 		cfg.setProperty( Environment.USE_QUERY_CACHE, "true" );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 	}
 
 	@Test
 	public void testUpdate() {
 		// prepare some test data...
 		Session session = openSession();
     	session.beginTransaction();
 	  	User user = new User();
     	user.setUserName( "steve" );
     	user.setEmail( "steve@hibernate.org" );
     	user.setPassword( "brewhaha" );
 		session.save( user );
     	session.getTransaction().commit();
     	session.close();
 
 		// 'user' is now a detached entity, so lets change a property and reattch...
 		user.setPassword( "homebrew" );
 		session = openSession();
 		session.beginTransaction();
 		session.update( user );
 		session.getTransaction().commit();
 		session.close();
 
 		// clean up
 		session = openSession();
 		session.beginTransaction();
 		session.delete( user );
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	@Test
 	public void testNaturalIdCheck() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		User u = new User( "steve", "superSecret" );
 		s.persist( u );
 		u.setUserName( "Steve" );
 		try {
 			s.flush();
 			fail();
 		}
 		catch ( HibernateException he ) {
 		}
 		u.setUserName( "steve" );
 		s.delete( u );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSimpleNaturalIdLoadAccessCache() {
 		Session s = openSession();
 		s.beginTransaction();
 		User u = new User( "steve", "superSecret" );
 		s.persist( u );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		u = (User) s.bySimpleNaturalId( User.class ).load( "steve" );
 		assertNotNull( u );
 		User u2 = (User) s.bySimpleNaturalId( User.class ).getReference( "steve" );
 		assertTrue( u == u2 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete User" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNaturalIdLoadAccessCache() {
 		Session s = openSession();
 		s.beginTransaction();
 		User u = new User( "steve", "superSecret" );
 		s.persist( u );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getStatistics().clear();
 
 		s = openSession();
 		s.beginTransaction();
 		u = (User) s.byNaturalId( User.class ).using( "userName", "steve" ).load();
 		assertNotNull( u );
 		s.getTransaction().commit();
 		s.close();
 
 		assertEquals( 1, sessionFactory().getStatistics().getEntityLoadCount() );
 		assertEquals( 0, sessionFactory().getStatistics().getSecondLevelCacheMissCount() );
 		assertEquals( 0, sessionFactory().getStatistics().getSecondLevelCacheHitCount() );
 		assertEquals( 0, sessionFactory().getStatistics().getSecondLevelCachePutCount() );
 		assertEquals( 1, sessionFactory().getStatistics().getNaturalIdQueryExecutionCount() );
 		assertEquals( 0, sessionFactory().getStatistics().getNaturalIdCacheHitCount() );
 		assertEquals( 0, sessionFactory().getStatistics().getNaturalIdCachePutCount() );
 
 		s = openSession();
 		s.beginTransaction();
 		User v = new User( "gavin", "supsup" );
 		s.persist( v );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getStatistics().clear();
 
 		s = openSession();
 		s.beginTransaction();
 		u = (User) s.byNaturalId( User.class ).using( "userName", "steve" ).load();
 		assertNotNull( u );
 		assertEquals( 1, sessionFactory().getStatistics().getEntityLoadCount() );
 		assertEquals( 1, sessionFactory().getStatistics().getNaturalIdQueryExecutionCount() );//0: incorrect stats since hbm.xml can't enable NaturalId caching
 		assertEquals( 0, sessionFactory().getStatistics().getNaturalIdCacheHitCount() );
 		u = (User) s.byNaturalId( User.class ).using( "userName", "steve" ).load();
 		assertNotNull( u );
 		assertEquals( 1, sessionFactory().getStatistics().getEntityLoadCount() );
 		assertEquals( 1, sessionFactory().getStatistics().getNaturalIdQueryExecutionCount() );//0: incorrect stats since hbm.xml can't enable NaturalId caching
 		assertEquals( 0, sessionFactory().getStatistics().getNaturalIdCacheHitCount() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete User" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNaturalIdCache() {
 		Session s = openSession();
 		s.beginTransaction();
 		User u = new User( "steve", "superSecret" );
 		s.persist( u );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getStatistics().clear();
 
 		s = openSession();
 		s.beginTransaction();
 		u = ( User ) s.createCriteria( User.class )
 				.add( Restrictions.naturalId().set( "userName", "steve" ) )
 				.setCacheable( true )
 				.uniqueResult();
 		assertNotNull( u );
 		s.getTransaction().commit();
 		s.close();
 
 		assertEquals( 1, sessionFactory().getStatistics().getNaturalIdQueryExecutionCount() );
 		assertEquals( 0, sessionFactory().getStatistics().getNaturalIdCacheHitCount() );
 		assertEquals( 0, sessionFactory().getStatistics().getNaturalIdCachePutCount() );//1: no stats since hbm.xml can't enable NaturalId caching
 
 		s = openSession();
 		s.beginTransaction();
 		User v = new User( "gavin", "supsup" );
 		s.persist( v );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getStatistics().clear();
 
 		s = openSession();
 		s.beginTransaction();
 		u = ( User ) s.createCriteria( User.class )
 				.add( Restrictions.naturalId().set( "userName", "steve" ) )
 				.setCacheable( true )
 				.uniqueResult();
 		assertNotNull( u );
 		assertEquals( 1, sessionFactory().getStatistics().getNaturalIdQueryExecutionCount() );//0: incorrect stats since hbm.xml can't enable NaturalId caching
 		assertEquals( 0, sessionFactory().getStatistics().getNaturalIdCacheHitCount() );//0: no stats since hbm.xml can't enable NaturalId caching
 		u = ( User ) s.createCriteria( User.class )
 				.add( Restrictions.naturalId().set( "userName", "steve" ) )
 				.setCacheable( true )
 				.uniqueResult();
 		assertNotNull( u );
 		assertEquals( 1, sessionFactory().getStatistics().getNaturalIdQueryExecutionCount() );//0: incorrect stats since hbm.xml can't enable NaturalId caching
 		assertEquals( 0, sessionFactory().getStatistics().getNaturalIdCacheHitCount() );//0: no stats since hbm.xml can't enable NaturalId caching
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete User" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNaturalIdDeleteUsingCache() {
 		Session s = openSession();
 		s.beginTransaction();
 		User u = new User( "steve", "superSecret" );
 		s.persist( u );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getStatistics().clear();
 
 		s = openSession();
 		s.beginTransaction();
 		u = ( User ) s.createCriteria( User.class )
 				.add( Restrictions.naturalId().set( "userName", "steve" ) )
 				.setCacheable( true )
 				.uniqueResult();
 		assertNotNull( u );
 		s.getTransaction().commit();
 		s.close();
 
 		assertEquals( 1, sessionFactory().getStatistics().getNaturalIdQueryExecutionCount() );
 		assertEquals( 0, sessionFactory().getStatistics().getNaturalIdCacheHitCount() );
 		assertEquals( 0, sessionFactory().getStatistics().getNaturalIdCachePutCount() );//0: no stats since hbm.xml can't enable NaturalId caching
 
 		sessionFactory().getStatistics().clear();
 
 		s = openSession();
 		s.beginTransaction();
 		u = ( User ) s.createCriteria( User.class )
 				.add( Restrictions.naturalId().set( "userName", "steve" ) )
 				.setCacheable( true )
 				.uniqueResult();
 		assertNotNull( u );
 		assertEquals( 1, sessionFactory().getStatistics().getNaturalIdQueryExecutionCount() );//0: incorrect stats since hbm.xml can't enable NaturalId caching
 		assertEquals( 0, sessionFactory().getStatistics().getNaturalIdCacheHitCount() );//1: incorrect stats since hbm.xml can't enable NaturalId caching
 
 		s.delete( u );
 
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		u = ( User ) s.createCriteria( User.class )
 				.add( Restrictions.naturalId().set( "userName", "steve" ) )
 				.setCacheable( true )
 				.uniqueResult();
 		assertNull( u );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNaturalIdRecreateUsingCache() {
 		testNaturalIdDeleteUsingCache();
 
 		Session s = openSession();
 		s.beginTransaction();
 		User u = new User( "steve", "superSecret" );
 		s.persist( u );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getStatistics().clear();
 
 		s = openSession();
 		s.beginTransaction();
 		u = ( User ) s.createCriteria( User.class )
 				.add( Restrictions.naturalId().set( "userName", "steve" ) )
 				.setCacheable( true )
 				.uniqueResult();
 		assertNotNull( u );
 
 		assertEquals( 1, sessionFactory().getStatistics().getNaturalIdQueryExecutionCount() );
 		assertEquals( 0, sessionFactory().getStatistics().getNaturalIdCacheHitCount() );
 		assertEquals( 0, sessionFactory().getStatistics().getNaturalIdCachePutCount() );//1: no stats since hbm.xml can't enable NaturalId caching
 
 		sessionFactory().getStatistics().clear();
 		s.getTransaction().commit();
 		s.close();
 		s = openSession();
 		s.beginTransaction();
 		u = ( User ) s.createCriteria( User.class )
 				.add( Restrictions.naturalId().set( "userName", "steve" ) )
 				.setCacheable( true )
 				.uniqueResult();
 		assertNotNull( u );
 		assertEquals( 1, sessionFactory().getStatistics().getNaturalIdQueryExecutionCount() );//0: incorrect stats since hbm.xml can't enable NaturalId caching
 		assertEquals( 0, sessionFactory().getStatistics().getNaturalIdCacheHitCount() );//1: incorrect stats since hbm.xml can't enable NaturalId caching
 
 		s.delete( u );
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/jpa/naturalid/User.java b/hibernate-core/src/test/java/org/hibernate/test/jpa/naturalid/User.java
index 86269b4327..04a2670c41 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/jpa/naturalid/User.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/jpa/naturalid/User.java
@@ -1,90 +1,90 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.jpa.naturalid;
 
 
 /**
  * {@inheritDoc}
  *
  * @author Steve Ebersole
  * (copied from org.hibernate.test.naturalid.immutable.User)
  */
 public class User implements java.io.Serializable {
 
 	private Integer myUserId;
 	private Integer version;
 	private String userName;
 	private String password;
 	private String email;
 
 	public User() {
 	}
 
 	public User(String userName, String password) {
 		this.userName = userName;
 		this.password = password;
 	}
 
 	public Integer getMyUserId() {
 		return this.myUserId;
 	}
 
 	public void setMyUserId(Integer myUserId) {
 		this.myUserId = myUserId;
 	}
 
 	public String getUserName() {
 		return this.userName;
 	}
 
 	public void setUserName(String userName) {
 		this.userName = userName;
 	}
 
 	public String getPassword() {
 		return this.password;
 	}
 
 	public void setPassword(String password) {
 		this.password = password;
 	}
 
 	public String getEmail() {
 		return this.email;
 	}
 
 	public void setEmail(String email) {
 		this.email = email;
 	}
 
 	public Integer getVersion() {
 		return this.version;
 	}
 
 	public void setVersion(Integer version) {
 		this.version = version;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/ABCTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/ABCTest.java
index ec14b03f73..3d638bb855 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/ABCTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/ABCTest.java
@@ -1,183 +1,182 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
 
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
-@SuppressWarnings( {"UnnecessaryBoxing"})
 public class ABCTest extends LegacyTestCase {
 	public String[] getMappings() {
 		return new String[] { "legacy/ABC.hbm.xml", "legacy/ABCExtends.hbm.xml" };
 	}
 
 	@Test
 	public void testFormulaAssociation() throws Throwable {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Long did = Long.valueOf(12);
 		D d = new D( did );
 		s.save(d);
 		A a = new A();
 		a.setName("a");
 		s.save( a );
 		d.setReverse( a );
 		d.inverse = a;
 		t.commit();
 		s.close();
 		
 		s = openSession();
 		t = s.beginTransaction();
 		d = (D) s.get(D.class, did);
 		assertNotNull( d.getReverse() );
 		s.clear();
 		sessionFactory().getCache().evictEntityRegion( D.class );
 		sessionFactory().getCache().evictEntityRegion(A.class);
 		d = (D) s.get(D.class, did);
 		assertNotNull( d.inverse );
 		assertTrue(d.inverse.getName().equals("a"));
 		s.clear();
 		sessionFactory().getCache().evictEntityRegion( D.class );
 		sessionFactory().getCache().evictEntityRegion( A.class );
 		assertTrue( s.createQuery( "from D d join d.reverse r join d.inverse i where i = r" ).list().size()==1 );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testHigherLevelIndexDefinition() throws Throwable {
 		String[] commands = configuration().generateSchemaCreationScript( getDialect() );
 		int max = commands.length;
 		boolean found = false;
 		for (int indx = 0; indx < max; indx++) {
 			System.out.println("Checking command : " + commands[indx]);
 			found = commands[indx].indexOf("create index indx_a_name") >= 0;
 			if (found)
 				break;
 		}
 		assertTrue("Unable to locate indx_a_name index creation", found);
 	}
 
 	@Test
 	public void testSubclassing() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		C1 c1 = new C1();
 		D d = new D();
 		d.setAmount(213.34f);
 		c1.setAddress("foo bar");
 		c1.setCount(23432);
 		c1.setName("c1");
 		c1.setBName("a funny name");
 		c1.setD(d);
 		s.save(c1);
 		d.setId( c1.getId() );
 		s.save(d);
 
 		assertTrue( s.createQuery( "from C2 c where 1=1 or 1=1" ).list().size()==0 );
 
 		t.commit();
 		s.close();
 
 		sessionFactory().getCache().evictEntityRegion( A.class );
 		
 		s = openSession();
 		t = s.beginTransaction();
 		c1 = (C1) s.get( A.class, c1.getId() );
 		assertTrue(
 			c1.getAddress().equals("foo bar") &&
 			(c1.getCount()==23432) &&
 			c1.getName().equals("c1") &&
 			c1.getD().getAmount()>213.3f
 		);
 		assertEquals( "a funny name", c1.getBName() );
 		t.commit();
 		s.close();
 		
 		sessionFactory().getCache().evictEntityRegion( A.class );
 
 		s = openSession();
 		t = s.beginTransaction();
 		c1 = (C1) s.get( B.class, c1.getId() );
 		assertTrue(
 			c1.getAddress().equals("foo bar") &&
 			(c1.getCount()==23432) &&
 			c1.getName().equals("c1") &&
 			c1.getD().getAmount()>213.3f
 		);
 		assertEquals( "a funny name", c1.getBName() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c1 = (C1) s.load( C1.class, c1.getId() );
 		assertTrue(
 			c1.getAddress().equals("foo bar") &&
 			(c1.getCount()==23432) &&
 			c1.getName().equals("c1") &&
 			c1.getD().getAmount()>213.3f
 		);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List bs = s.createQuery("from B").list();
 		for (int i=0; i<bs.size(); i++) {
 			C1 b = (C1) bs.get(i);
 			s.delete(b);
 			s.delete( b.getD() );
 		}
 		t.commit();
 		s.close();
 	}
 	
 	@Test
 	public void testGetSave() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		assertNull( s.get( D.class, Long.valueOf(1) ) );
 		D d = new D();
 		d.setId( Long.valueOf(1) );
 		s.save(d);
 		s.flush();
 		assertNotNull( s.get( D.class, Long.valueOf(1) ) );
 		s.delete(d);
 		s.flush();
 		t.commit();
 		s.close();
 	}
 
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/CustomSQLTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/CustomSQLTest.java
index a62a6a3d6a..c7bd7511be 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/CustomSQLTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/CustomSQLTest.java
@@ -1,186 +1,184 @@
 //$Id: CustomSQLTest.java 10977 2006-12-12 23:28:04Z steve.ebersole@jboss.com $
 package org.hibernate.test.legacy;
 
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Session;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.PostgreSQL81Dialect;
 import org.hibernate.dialect.PostgreSQLDialect;
 import org.hibernate.id.PostInsertIdentifierGenerator;
 import org.hibernate.testing.DialectCheck;
 import org.hibernate.testing.RequiresDialectFeature;
 import org.hibernate.testing.SkipForDialect;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author MAX
  *
  */
 public class CustomSQLTest extends LegacyTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "legacy/CustomSQL.hbm.xml" };
 	}
 
     public static class NonIdentityGeneratorChecker implements DialectCheck {
         @Override
         public boolean isMatch(Dialect dialect) {
             return !PostInsertIdentifierGenerator.class.isAssignableFrom( getDialect().getNativeIdentifierGeneratorClass() );
         }
     }
 
 	@Test
     @RequiresDialectFeature( NonIdentityGeneratorChecker.class )
     @SkipForDialect( value = {PostgreSQL81Dialect.class, PostgreSQLDialect.class}, jiraKey = "HHH-6704")
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testInsert() throws HibernateException, SQLException {
 		Session s = openSession();
 		s.beginTransaction();
 		Role p = new Role();
 		p.setName("Patient");
 		s.save( p );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getCache().evictEntityRegion( Role.class );
 
 		s = openSession();
 		s.beginTransaction();
 		Role p2 = (Role) s.get(Role.class, Long.valueOf(p.getId()));
 		assertNotSame(p, p2);
 		assertEquals(p2.getId(),p.getId());
 		assertTrue(p2.getName().equalsIgnoreCase(p.getName()));
 		s.delete(p2);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testJoinedSubclass() throws HibernateException, SQLException {
 		Session s = openSession();
 		s.beginTransaction();
 		Medication m = new Medication();
 		m.setPrescribedDrug(new Drug());
 		m.getPrescribedDrug().setName( "Morphine" );
 		s.save( m.getPrescribedDrug() );
 		s.save( m );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Medication m2  = (Medication) s.get(Medication.class, m.getId());
 		assertNotSame(m, m2);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 //	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing", "unchecked"})
 //    @RequiresDialectFeature( NonIdentityGeneratorChecker.class )
 	public void testCollectionCUD() throws HibernateException, SQLException {
 		Role role = new Role();
 		role.setName("Jim Flanders");
 		Intervention iv = new Medication();
 		iv.setDescription("JF medical intervention");
 		role.getInterventions().add(iv);
 
 		List sx = new ArrayList();
 		sx.add("somewhere");
 		sx.add("somehow");
 		sx.add("whatever");
 		role.setBunchOfStrings(sx);
 
 		Session s = openSession();
 		s.beginTransaction();
 		s.save(role);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Role r = (Role) s.get(Role.class, Long.valueOf(role.getId()));
 		assertNotSame(role,r);
 		assertEquals(1,r.getInterventions().size());
 		assertEquals(3, r.getBunchOfStrings().size());
 		r.getBunchOfStrings().set(1, "replacement");
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		r = (Role) s.get(Role.class,new Long(role.getId()));
 		assertNotSame(role,r);
 
 		assertEquals(r.getBunchOfStrings().get(1),"replacement");
 		assertEquals(3, r.getBunchOfStrings().size());
 
 		r.getBunchOfStrings().set(1, "replacement");
 
 		r.getBunchOfStrings().remove(1);
 		s.flush();
 
 		r.getBunchOfStrings().clear();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 //	@Test
 //    @RequiresDialectFeature( NonIdentityGeneratorChecker.class )
 	public void testCRUD() throws HibernateException, SQLException {
 		Person p = new Person();
 		p.setName("Max");
 		p.setLastName("Andersen");
 		p.setNationalID("110974XYZ");
 		p.setAddress("P. P. Street 8");
 
 		Session s = openSession();
 		s.beginTransaction();
 		s.save(p);
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().getCache().evictEntityRegion( Person.class );
 
 		s = openSession();
 		s.beginTransaction();
 		Person p2 = (Person) s.get(Person.class, p.getId());
 		assertNotSame(p, p2);
 		assertEquals(p2.getId(),p.getId());
 		assertEquals(p2.getLastName(),p.getLastName());
 		s.flush();
 
 		List list = s.createQuery( "select p from Party as p" ).list();
 		assertTrue(list.size() == 1);
 
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		list = s.createQuery( "select p from Person as p where p.address = 'Lrkevnget 1'" ).list();
 		assertTrue(list.size() == 0);
 		p.setAddress("Lrkevnget 1");
 		s.update(p);
 		list = s.createQuery( "select p from Person as p where p.address = 'Lrkevnget 1'" ).list();
 		assertTrue(list.size() == 1);
 		list = s.createQuery( "select p from Party as p where p.address = 'P. P. Street 8'" ).list();
 		assertTrue(list.size() == 0);
 
 		s.delete(p);
 		list = s.createQuery( "select p from Person as p" ).list();
 		assertTrue(list.size() == 0);
 
 		s.getTransaction().commit();
 		s.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/FooBarTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/FooBarTest.java
index c329f3dfdb..006c6fcaaa 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/FooBarTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/FooBarTest.java
@@ -1479,2001 +1479,2000 @@ public class FooBarTest extends LegacyTestCase {
 		baz.setIdFooBag(l);
 		baz.setByteBag(l2);
 		l.add( new Foo() );
 		l.add( new Bar() );
 		byte[] bytes = "ffo".getBytes();
 		l2.add(bytes);
 		l2.add( "foo".getBytes() );
 		s.flush();
 		l.add( new Foo() );
 		l.add( new Bar() );
 		l2.add( "bar".getBytes() );
 		s.flush();
 		s.delete( l.remove(3) );
 		bytes[1]='o';
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load(Baz.class, baz.getCode());
 		assertTrue( baz.getIdFooBag().size()==3 );
 		assertTrue( baz.getByteBag().size()==3 );
 		bytes = "foobar".getBytes();
 		Iterator iter = baz.getIdFooBag().iterator();
 		while ( iter.hasNext() ) s.delete( iter.next() );
 		baz.setIdFooBag(null);
 		baz.getByteBag().add(bytes);
 		baz.getByteBag().add(bytes);
 		assertTrue( baz.getByteBag().size()==5 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load(Baz.class, baz.getCode());
 		assertTrue( baz.getIdFooBag().size()==0 );
 		assertTrue( baz.getByteBag().size()==5 );
 		baz.getIdFooBag().add( new Foo() );
 		iter = baz.getByteBag().iterator();
 		iter.next();
 		iter.remove();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load(Baz.class, baz.getCode());
 		assertTrue( baz.getIdFooBag().size()==1 );
 		assertTrue( baz.getByteBag().size()==4 );
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	private boolean isOuterJoinFetchingDisabled() {
 		return new Integer(0).equals( sessionFactory().getSettings().getMaximumFetchDepth() );
 	}
 
 	@Test
 	public void testForceOuterJoin() throws Exception {
 		if ( isOuterJoinFetchingDisabled() ) {
 			return;
 		}
 
 		Session s = openSession();
 		s.beginTransaction();
 		Glarch g = new Glarch();
 		FooComponent fc = new FooComponent();
 		fc.setGlarch(g);
 		FooProxy f = new Foo();
 		FooProxy f2 = new Foo();
 		f.setComponent(fc);
 		f.setFoo(f2);
 		s.save(f2);
 		Serializable id = s.save(f);
 		Serializable gid = s.getIdentifier( f.getComponent().getGlarch() );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().evict(Foo.class);
 
 		s = openSession();
 		s.beginTransaction();
 		f = (FooProxy) s.load(Foo.class, id);
 		assertFalse( Hibernate.isInitialized(f) );
 		assertTrue( Hibernate.isInitialized( f.getComponent().getGlarch() ) ); //outer-join="true"
 		assertFalse( Hibernate.isInitialized( f.getFoo() ) ); //outer-join="auto"
 		assertEquals( s.getIdentifier( f.getComponent().getGlarch() ), gid );
 		s.delete(f);
 		s.delete( f.getFoo() );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testEmptyCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Serializable id = s.save( new Baz() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Baz baz = (Baz) s.load(Baz.class, id);
 		Set foos = baz.getFooSet();
 		assertTrue( foos.size() == 0 );
 		Foo foo = new Foo();
 		foos.add( foo );
 		s.save(foo);
 		s.flush();
 		s.delete(foo);
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testOneToOneGenerator() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		X x = new X();
 		Y y = new Y();
 		x.setY(y);
 		y.setTheX(x);
 		x.getXxs().add( new X.XX(x) );
 		x.getXxs().add( new X.XX(x) );
 		Serializable id = s.save(y);
 		assertEquals( id, s.save(x) );
 		s.flush();
 		assertTrue( s.contains(y) && s.contains(x) );
 		s.getTransaction().commit();
 		s.close();
 		assertEquals( new Long(x.getId()), y.getId() );
 
 		s = openSession();
 		s.beginTransaction();
 		x = new X();
 		y = new Y();
 		x.setY(y);
 		y.setTheX(x);
 		x.getXxs().add( new X.XX(x) );
 		s.save(y);
 		s.flush();
 		assertTrue( s.contains(y) && s.contains(x) );
 		s.getTransaction().commit();
 		s.close();
 		assertEquals( new Long(x.getId()), y.getId() );
 
 		s = openSession();
 		s.beginTransaction();
 		x = new X();
 		y = new Y();
 		x.setY(y);
 		y.setTheX(x);
 		x.getXxs().add( new X.XX(x) );
 		x.getXxs().add( new X.XX(x) );
 		id = s.save(x);
 		assertEquals( id, y.getId() );
 		assertEquals( id, new Long( x.getId() ) );
 		s.flush();
 		assertTrue( s.contains(y) && s.contains(x) );
 		doDelete( s, "from X x" );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testLimit() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		for ( int i=0; i<10; i++ ) s.save( new Foo() );
 		Iterator iter = s.createQuery("from Foo foo")
 			.setMaxResults(4)
 			.setFirstResult(2)
 			.iterate();
 		int count=0;
 		while ( iter.hasNext() ) {
 		    iter.next();
 			count++;
 		}
 		assertEquals(4, count);
 		iter = s.createQuery("select distinct foo from Foo foo")
 			.setMaxResults(2)
 			.setFirstResult(2)
 			.list()
 			.iterator();
 		count=0;
 		while ( iter.hasNext() ) {
 			iter.next();
 			count++;
 		}
 		assertTrue(count==2);
 		iter = s.createQuery("select distinct foo from Foo foo")
 		.setMaxResults(3)
 		.list()
 		.iterator();
 		count=0;
 		while ( iter.hasNext() ) {
 			iter.next();
 			count++;
 		}
 		assertTrue(count==3);
 		assertEquals( 10, doDelete( s, "from Foo foo" ) );
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCustom() throws Exception {
 		GlarchProxy g = new Glarch();
 		Multiplicity m = new Multiplicity();
 		m.count = 12;
 		m.glarch = g;
 		g.setMultiple(m);
 
 		Session s = openSession();
 		s.beginTransaction();
 		Serializable gid = s.save(g);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		//g = (Glarch) s.createQuery( "from Glarch g where g.multiple.count=12" ).list().get(0);
 		s.createQuery( "from Glarch g where g.multiple.count=12" ).list().get( 0 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (Glarch) s.createQuery( "from Glarch g where g.multiple.glarch=g and g.multiple.count=12" ).list().get(0);
 		assertTrue( g.getMultiple()!=null );
 		assertEquals( g.getMultiple().count, 12 );
 		assertSame(g.getMultiple().glarch, g);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( g.getMultiple() != null );
 		assertEquals( g.getMultiple().count, 12 );
 		assertSame( g.getMultiple().glarch, g );
 		s.delete(g);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSaveAddDelete() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		Set bars = new HashSet();
 		baz.setCascadingBars( bars );
 		s.save( baz );
 		s.flush();
 		baz.getCascadingBars().add( new Bar() );
 		s.delete(baz);
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNamedParams() throws Exception {
 		Bar bar = new Bar();
 		Bar bar2 = new Bar();
 		bar.setName("Bar");
 		bar2.setName("Bar Two");
 		bar.setX( 10 );
 		bar2.setX( 1000 );Baz baz = new Baz();
 		baz.setCascadingBars( new HashSet() );
 		baz.getCascadingBars().add(bar);
 		bar.setBaz(baz);
 
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		s.save( baz );
 		s.save( bar2 );
 
 		List list = s.createQuery(
 				"from Bar bar left join bar.baz baz left join baz.cascadingBars b where bar.name like 'Bar %'"
 		).list();
 		Object row = list.iterator().next();
 		assertTrue( row instanceof Object[] && ( (Object[]) row ).length==3 );
 
 		Query q = s.createQuery("select bar, b from Bar bar left join bar.baz baz left join baz.cascadingBars b where bar.name like 'Bar%'");
 		list = q.list();
 		if ( !(getDialect() instanceof SAPDBDialect) ) assertTrue( list.size()==2 );
 
 		q = s.createQuery("select bar, b from Bar bar left join bar.baz baz left join baz.cascadingBars b where ( bar.name in (:nameList) or bar.name in (:nameList) ) and bar.string = :stringVal");
 		HashSet nameList = new HashSet();
 		nameList.add( "bar" );
 		nameList.add( "Bar" );
 		nameList.add( "Bar Two" );
 		q.setParameterList( "nameList", nameList );
 		q.setParameter( "stringVal", "a string" );
 		list = q.list();
 		if ( !(getDialect() instanceof SAPDBDialect) ) assertTrue( list.size()==2 );
 
 		try {
 			q.setParameterList("nameList", (Collection)null);
 			fail("Should throw an queryexception when passing a null!");
 		} catch (QueryException qe) {
 			//should happen
 		}
 
 		q = s.createQuery("select bar, b from Bar bar inner join bar.baz baz inner join baz.cascadingBars b where bar.name like 'Bar%'");
 		Object result = q.uniqueResult();
 		assertTrue( result != null );
 		q = s.createQuery("select bar, b from Bar bar left join bar.baz baz left join baz.cascadingBars b where bar.name like :name and b.name like :name");
 		q.setString( "name", "Bar%" );
 		list = q.list();
 		assertTrue( list.size()==1 );
 
 
 		// This test added for issue HB-297 - there is an named parameter in the Order By clause
 		q = s.createQuery("select bar from Bar bar order by ((bar.x - :valueX)*(bar.x - :valueX))");
 		q.setInteger( "valueX", bar.getX() + 1 );
 		list = q.list();
 		assertTrue( ((Bar) list.get( 0 )).getX() == bar.getX() );
 		q.setInteger( "valueX", bar2.getX() + 1 );
 		list = q.list();
 		assertTrue( ((Bar)list.get(0)).getX() == bar2.getX());
 
 		s.delete(baz);
 		s.delete(bar2);
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	@RequiresDialectFeature(
 			value = DialectChecks.SupportsEmptyInListCheck.class,
 			comment = "Dialect does not support SQL empty in list [x in ()]"
 	)
 	public void testEmptyInListQuery() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		Query q = s.createQuery( "select bar from Bar as bar where bar.name in (:nameList)" );
 		q.setParameterList( "nameList", Collections.EMPTY_LIST );
 		assertEquals( 0, q.list().size() );
 
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testParameterCheck() throws HibernateException {
 		Session s = openSession();
 		try {
 			Query q = s.createQuery("select bar from Bar as bar where bar.x > :myX");
 			q.list();
 			fail("Should throw QueryException for missing myX");
 		}
 		catch (QueryException iae) {
 			// should happen
 		}
 		finally {
 			s.close();
 		}
 
 		s = openSession();
 		try {
 			Query q = s.createQuery("select bar from Bar as bar where bar.x > ?");
 			q.list();
 			fail("Should throw QueryException for missing ?");
 		}
 		catch (QueryException iae) {
 			// should happen
 		}
 		finally {
 			s.close();
 		}
 
 		s = openSession();
 		try {
 			Query q = s.createQuery("select bar from Bar as bar where bar.x > ? or bar.short = 1 or bar.string = 'ff ? bb'");
 			q.setInteger(0, 1);
 			q.list();
 		}
 		catch (QueryException iae) {
 			fail("Should not throw QueryException for missing ?");
 		}
 		finally {
 			s.close();
 		}
 
 		s = openSession();
 		try {
 			Query q = s.createQuery("select bar from Bar as bar where bar.string = ' ? ' or bar.string = '?'");
 			q.list();
 		}
 		catch (QueryException iae) {
 			fail("Should not throw QueryException for ? in quotes");
 		}
 		finally {
 			s.close();
 		}
 
 		s = openSession();
 		try {
 			Query q = s.createQuery("select bar from Bar as bar where bar.string = ? or bar.string = ? or bar.string = ?");
 			q.setParameter(0, "bull");
 			q.setParameter(2, "shit");
 			q.list();
 			fail("should throw exception telling me i have not set parameter 1");
 		}
 		catch (QueryException iae) {
 			// should happen!
 		}
 		finally {
 			s.close();
 		}
 	}
 
 	@Test
 	public void testDyna() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		GlarchProxy g = new Glarch();
 		g.setName("G");
 		Serializable id = s.save(g);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, id);
 		assertTrue( g.getName().equals("G") );
 		assertTrue( g.getDynaBean().get("foo").equals("foo") && g.getDynaBean().get("bar").equals( new Integer(66) ) );
 		assertTrue( ! (g instanceof Glarch) );
 		g.getDynaBean().put("foo", "bar");
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, id);
 		assertTrue( g.getDynaBean().get("foo").equals("bar") && g.getDynaBean().get("bar").equals( new Integer(66) ) );
 		g.setDynaBean(null);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, id);
 		assertTrue( g.getDynaBean()==null );
 		s.delete(g);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testFindByCriteria() throws Exception {
 		if ( getDialect() instanceof DB2Dialect ) {
 			return;
 		}
 
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Foo f = new Foo();
 		s.save( f );
 		s.flush();
 
 		List list = s.createCriteria(Foo.class)
 			.add( Restrictions.eq( "integer", f.getInteger() ) )
 			.add( Restrictions.eqProperty("integer", "integer") )
 			.add( Restrictions.like( "string", f.getString().toUpperCase() ).ignoreCase() )
 			.add( Restrictions.in( "boolean", new Boolean[] { f.getBoolean(), f.getBoolean() } ) )
 			.setFetchMode("foo", FetchMode.JOIN)
 			.setFetchMode("baz", FetchMode.SELECT)
 			.setFetchMode("abstracts", FetchMode.JOIN)
 			.list();
 		assertTrue( list.size() == 1 && list.get( 0 ) == f );
 
 		list = s.createCriteria(Foo.class).add(
 				Restrictions.disjunction()
 					.add( Restrictions.eq( "integer", f.getInteger() ) )
 					.add( Restrictions.like( "string", f.getString() ) )
 					.add( Restrictions.eq( "boolean", f.getBoolean() ) )
 			)
 			.add( Restrictions.isNotNull("boolean") )
 			.list();
 		assertTrue( list.size() == 1 && list.get( 0 ) == f );
 
 		Foo example = new Foo();
 		example.setString("a STRing");
 		list = s.createCriteria(Foo.class).add(
 			Example.create(example)
 				.excludeZeroes()
 				.ignoreCase()
 				.excludeProperty("bool")
 				.excludeProperty("char")
 				.excludeProperty("yesno")
 			)
 			.list();
 		assertTrue(
 				"Example API without like did not work correctly, size was " + list.size(),
 				list.size() == 1 && list.get( 0 ) == f
 		);
 		example.setString("rin");
 
 		list = s.createCriteria(Foo.class).add(
 			Example.create(example)
 				.excludeZeroes()
 				.enableLike(MatchMode.ANYWHERE)
 				.excludeProperty("bool")
 				.excludeProperty("char")
 				.excludeProperty("yesno")
 			)
 			.list();
 		assertTrue( "Example API without like did not work correctly, size was " + list.size(), list.size()==1 && list.get(0)==f );
 
 		list = s.createCriteria(Foo.class)
 			.add( Restrictions.or(
 					Restrictions.and(
 					Restrictions.eq( "integer", f.getInteger() ),
 					Restrictions.like( "string", f.getString() )
 				),
 				Restrictions.eq( "boolean", f.getBoolean() )
 			) )
 			.list();
 		assertTrue( list.size()==1 && list.get(0)==f );
 		list = s.createCriteria(Foo.class)
 			.setMaxResults(5)
 			.addOrder( Order.asc("date") )
 			.list();
 		assertTrue( list.size()==1 && list.get(0)==f );
 		list = s.createCriteria(Foo.class)
 			.setFirstResult(1)
 			.addOrder( Order.asc("date") )
 			.addOrder( Order.desc("string") )
 			.list();
 		assertTrue( list.size() == 0 );
 		list = s.createCriteria(Foo.class)
 			.setFetchMode( "component.importantDates", FetchMode.JOIN )
 			.list();
 		assertTrue( list.size() == 3 );
 
 		list = s.createCriteria(Foo.class)
 			.setFetchMode( "component.importantDates", FetchMode.JOIN )
 			.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY)
 			.list();
 		assertTrue( list.size()==1 );
 
 		f.setFoo( new Foo() );
 		s.save( f.getFoo() );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		list = s.createCriteria(Foo.class)
 			.add( Restrictions.eq( "integer", f.getInteger() ) )
 			.add( Restrictions.like( "string", f.getString() ) )
 			.add( Restrictions.in( "boolean", new Boolean[] { f.getBoolean(), f.getBoolean() } ) )
 			.add( Restrictions.isNotNull("foo") )
 			.setFetchMode( "foo", FetchMode.JOIN )
 			.setFetchMode( "baz", FetchMode.SELECT )
 			.setFetchMode( "component.glarch", FetchMode.SELECT )
 			.setFetchMode( "foo.baz", FetchMode.SELECT )
 			.setFetchMode( "foo.component.glarch", FetchMode.SELECT )
 			.list();
 		f = (Foo) list.get(0);
 		assertTrue( Hibernate.isInitialized( f.getFoo() ) );
 		assertTrue( !Hibernate.isInitialized( f.getComponent().getGlarch() ) );
 
 		s.save( new Bar() );
 		list = s.createCriteria(Bar.class)
 			.list();
 		assertTrue( list.size() == 1 );
 		assertTrue( s.createCriteria(Foo.class).list().size()==3 );
 		s.delete( list.get( 0 ) );
 
 		s.delete( f.getFoo() );
 		s.delete(f);
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testAfterDelete() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo foo = new Foo();
 		s.save(foo);
 		s.flush();
 		s.delete(foo);
 		s.save(foo);
 		s.delete(foo);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionWhere() throws Exception {
 		Foo foo1 = new Foo();
 		Foo foo2 = new Foo();
 		Baz baz = new Baz();
 		Foo[] arr = new Foo[10];
 		arr[0] = foo1;
 		arr[9] = foo2;
 
 		Session s = openSession();
 		s.beginTransaction();
 		s.save( foo1 );
 		s.save(foo2);
 		baz.setFooArray( arr );
 		s.save( baz );
 		s.getTransaction().commit();
 		s.close();
 
 		final Session s2 = openSession();
 		s2.beginTransaction();
 		baz = (Baz) s2.load( Baz.class, baz.getCode() );
 		assertTrue( baz.getFooArray().length == 1 );
 		assertTrue( s2.createQuery( "from Baz baz join baz.fooArray foo" ).list().size()==1 );
 		assertTrue( s2.createQuery( "from Foo foo" ).list().size()==2 );
 		assertTrue( s2.createFilter( baz.getFooArray(), "" ).list().size() == 1 );
 		//assertTrue( s.delete("from java.lang.Object o")==9 );
 		doDelete( s2, "from Foo foo" );
 		final String bazid = baz.getCode();
 		s2.delete( baz );
 		int rows = s2.doReturningWork(
 				new AbstractReturningWork<Integer>() {
 					@Override
 					public Integer execute(Connection connection) throws SQLException {
 						Statement st = connection.createStatement();
 						return st.executeUpdate( "delete from FOO_ARRAY where id_='" + bazid + "' and i>=8" );
 					}
 				}
 		);
 		assertTrue( rows == 1 );
 		s2.getTransaction().commit();
 		s2.close();
 	}
 
 	@Test
 	public void testComponentParent() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		BarProxy bar = new Bar();
 		bar.setBarComponent( new FooComponent() );
 		Baz baz = new Baz();
 		baz.setComponents( new FooComponent[] { new FooComponent(), new FooComponent() } );
 		s.save(bar);
 		s.save(baz);
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		bar = (BarProxy) s.load(Bar.class, bar.getKey());
 		s.load(baz, baz.getCode());
 		assertTrue( bar.getBarComponent().getParent()==bar );
 		assertTrue( baz.getComponents()[0].getBaz()==baz && baz.getComponents()[1].getBaz()==baz );
 		s.delete(baz);
 		s.delete(bar);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionCache() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setDefaults();
 		s.save(baz);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.load( Baz.class, baz.getCode() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	public void ntestAssociationId() throws Exception {
 		// IMPL NOTE : previously not being run due to the name
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Bar bar = new Bar();
 		String id = (String) s.save(bar);
 		MoreStuff more = new MoreStuff();
 		more.setName("More Stuff");
 		more.setIntId(12);
 		more.setStringId("id");
 		Stuff stuf = new Stuff();
 		stuf.setMoreStuff(more);
 		more.setStuffs( new ArrayList() );
 		more.getStuffs().add(stuf);
 		stuf.setFoo(bar);
 		stuf.setId(1234);
 		stuf.setProperty( TimeZone.getDefault() );
 		s.save(more);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List results = s.createQuery(
 				"from Stuff as s where s.foo.id = ? and s.id.id = ? and s.moreStuff.id.intId = ? and s.moreStuff.id.stringId = ?"
 		)
 				.setParameter( 0, bar, s.getTypeHelper().entity(Foo.class) )
 				.setParameter( 1, new Long(1234), StandardBasicTypes.LONG )
 				.setParameter( 2, new Integer(12), StandardBasicTypes.INTEGER )
 				.setParameter( 3, "id", StandardBasicTypes.STRING )
 				.list();
 		assertEquals( 1, results.size() );
 		results = s.createQuery( "from Stuff as s where s.foo.id = ? and s.id.id = ? and s.moreStuff.name = ?" )
 				.setParameter( 0, bar, s.getTypeHelper().entity(Foo.class) )
 				.setParameter( 1, new Long(1234), StandardBasicTypes.LONG )
 				.setParameter( 2, "More Stuff", StandardBasicTypes.STRING )
 				.list();
 		assertEquals( 1, results.size() );
 		s.createQuery( "from Stuff as s where s.foo.string is not null" ).list();
 		assertTrue(
 				s.createQuery( "from Stuff as s where s.foo > '0' order by s.foo" ).list().size()==1
 		);
 		//s.createCriteria(Stuff.class).createCriteria("id.foo").add( Expression.isNull("foo") ).list();
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		FooProxy foo = (FooProxy) s.load(Foo.class, id);
 		s.load(more, more);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Stuff stuff = new Stuff();
 		stuff.setFoo(foo);
 		stuff.setId(1234);
 		stuff.setMoreStuff(more);
 		s.load(stuff, stuff);
 		assertTrue( stuff.getProperty().equals( TimeZone.getDefault() ) );
 		assertTrue( stuff.getMoreStuff().getName().equals("More Stuff") );
 		doDelete( s, "from MoreStuff" );
 		doDelete( s, "from Foo foo" );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCascadeSave() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		List list = new ArrayList();
 		list.add( new Fee() );
 		list.add( new Fee() );
 		baz.setFees( list );
 		s.save(baz);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		assertTrue( baz.getFees().size() == 2 );
 		s.delete(baz);
 		assertTrue( !s.createQuery( "from Fee fee" ).iterate().hasNext() );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionsInSelect() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Foo[] foos = new Foo[] { null, new Foo() };
 		s.save( foos[1] );
 		Baz baz = new Baz();
 		baz.setDefaults();
 		baz.setFooArray(foos);
 		s.save(baz);
 		Baz baz2 = new Baz();
 		baz2.setDefaults();
 		s.save(baz2);
 
 		Bar bar = new Bar();
 		bar.setBaz(baz);
 		s.save(bar);
 
 		List list = s.createQuery( "select new Result(foo.string, foo.long, foo.integer) from Foo foo" ).list();
 		assertTrue( list.size()==2 && ( list.get(0) instanceof Result ) && ( list.get(1) instanceof Result ) );
 		/*list = s.find("select new Result( baz.name, foo.long, count(elements(baz.fooArray)) ) from Baz baz join baz.fooArray foo group by baz.name, foo.long");
 		assertTrue( list.size()==1 && ( list.get(0) instanceof Result ) );
 		Result r = ((Result) list.get(0) );
 		assertEquals( r.getName(), baz.getName() );
 		assertEquals( r.getCount(), 1 );
 		assertEquals( r.getAmount(), foos[1].getLong().longValue() );*/
 		list = s.createQuery(
 				"select new Result( baz.name, max(foo.long), count(foo) ) from Baz baz join baz.fooArray foo group by baz.name"
 		).list();
 		assertTrue( list.size()==1 && ( list.get(0) instanceof Result ) );
 		Result r = ((Result) list.get(0) );
 		assertEquals( r.getName(), baz.getName() );
 		assertEquals( r.getCount(), 1 );
 		assertTrue( r.getAmount() > 696969696969696000l );
 
 
 		//s.find("select max( elements(bar.baz.fooArray) ) from Bar as bar");
 		//The following test is disabled for databases with no subselects...also for Interbase (not sure why).
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof HSQLDialect) /*&& !(dialect instanceof MckoiDialect)*/ && !(getDialect() instanceof SAPDBDialect) && !(getDialect() instanceof PointbaseDialect) )  {
 			s.createQuery( "select count(*) from Baz as baz where 1 in indices(baz.fooArray)" ).list();
 			s.createQuery( "select count(*) from Bar as bar where 'abc' in elements(bar.baz.fooArray)" ).list();
 			s.createQuery( "select count(*) from Bar as bar where 1 in indices(bar.baz.fooArray)" ).list();
 			if ( !(getDialect() instanceof DB2Dialect) &&  !(getDialect() instanceof Oracle8iDialect ) && !( getDialect() instanceof SybaseDialect ) && !( getDialect() instanceof Sybase11Dialect ) && !( getDialect() instanceof SybaseASE15Dialect ) && !( getDialect() instanceof PostgreSQLDialect ) && !(getDialect() instanceof PostgreSQL81Dialect)) {
 				// SybaseAnywhereDialect supports implicit conversions from strings to ints
 				s.createQuery(
 						"select count(*) from Bar as bar, bar.component.glarch.proxyArray as g where g.id in indices(bar.baz.fooArray)"
 				).list();
 				s.createQuery(
 						"select max( elements(bar.baz.fooArray) ) from Bar as bar, bar.component.glarch.proxyArray as g where g.id in indices(bar.baz.fooArray)"
 				).list();
 			}
 			s.createQuery(
 					"select count(*) from Bar as bar where '1' in (from bar.component.glarch.proxyArray g where g.name='foo')"
 			).list();
 			s.createQuery(
 					"select count(*) from Bar as bar where '1' in (from bar.component.glarch.proxyArray g where g.name='foo')"
 			).list();
 			s.createQuery(
 					"select count(*) from Bar as bar left outer join bar.component.glarch.proxyArray as pg where '1' in (from bar.component.glarch.proxyArray)"
 			).list();
 		}
 
 		list = s.createQuery(
 				"from Baz baz left join baz.fooToGlarch join fetch baz.fooArray foo left join fetch foo.foo"
 		).list();
 		assertTrue( list.size()==1 && ( (Object[]) list.get(0) ).length==2 );
 
 		s.createQuery(
 				"select baz.name from Bar bar inner join bar.baz baz inner join baz.fooSet foo where baz.name = bar.string"
 		).list();
 		s.createQuery(
 				"SELECT baz.name FROM Bar AS bar INNER JOIN bar.baz AS baz INNER JOIN baz.fooSet AS foo WHERE baz.name = bar.string"
 		).list();
 
 		if ( !( getDialect() instanceof HSQLDialect ) ) s.createQuery(
 				"select baz.name from Bar bar join bar.baz baz left outer join baz.fooSet foo where baz.name = bar.string"
 		).list();
 
 		s.createQuery( "select baz.name from Bar bar join bar.baz baz join baz.fooSet foo where baz.name = bar.string" )
 				.list();
 		s.createQuery(
 				"SELECT baz.name FROM Bar AS bar JOIN bar.baz AS baz JOIN baz.fooSet AS foo WHERE baz.name = bar.string"
 		).list();
 
 		if ( !( getDialect() instanceof HSQLDialect ) ) {
 			s.createQuery(
 					"select baz.name from Bar bar left join bar.baz baz left join baz.fooSet foo where baz.name = bar.string"
 			).list();
 			s.createQuery( "select foo.string from Bar bar left join bar.baz.fooSet foo where bar.string = foo.string" )
 					.list();
 		}
 
 		s.createQuery(
 				"select baz.name from Bar bar left join bar.baz baz left join baz.fooArray foo where baz.name = bar.string"
 		).list();
 		s.createQuery( "select foo.string from Bar bar left join bar.baz.fooArray foo where bar.string = foo.string" )
 				.list();
 
 		s.createQuery(
 				"select bar.string, foo.string from Bar bar inner join bar.baz as baz inner join baz.fooSet as foo where baz.name = 'name'"
 		).list();
 		s.createQuery( "select foo from Bar bar inner join bar.baz as baz inner join baz.fooSet as foo" ).list();
 		s.createQuery( "select foo from Bar bar inner join bar.baz.fooSet as foo" ).list();
 
 		s.createQuery(
 				"select bar.string, foo.string from Bar bar join bar.baz as baz join baz.fooSet as foo where baz.name = 'name'"
 		).list();
 		s.createQuery( "select foo from Bar bar join bar.baz as baz join baz.fooSet as foo" ).list();
 		s.createQuery( "select foo from Bar bar join bar.baz.fooSet as foo" ).list();
 
 		assertTrue( s.createQuery( "from Bar bar join bar.baz.fooArray foo" ).list().size()==1 );
 
 		assertTrue( s.createQuery( "from Bar bar join bar.baz.fooSet foo" ).list().size()==0 );
 		assertTrue( s.createQuery( "from Bar bar join bar.baz.fooArray foo" ).list().size()==1 );
 
 		s.delete(bar);
 
 		if ( getDialect() instanceof DB2Dialect || getDialect() instanceof PostgreSQLDialect || getDialect() instanceof PostgreSQL81Dialect ) {
 			s.createQuery( "select one from One one join one.manies many group by one order by count(many)" ).iterate();
 			s.createQuery( "select one from One one join one.manies many group by one having count(many) < 5" )
 					.iterate();
 		}
 
 		s.createQuery( "from One one join one.manies many where one.id = 1 and many.id = 1" ).list();
 		s.createQuery( "select one.id, elements(one.manies) from One one" ).iterate();
 		s.createQuery( "select max( elements(one.manies) ) from One one" ).iterate();
 		s.createQuery( "select one, elements(one.manies) from One one" ).list();
 		Iterator iter = s.createQuery( "select elements(baz.fooArray) from Baz baz where baz.id=?" )
 				.setParameter( 0, baz.getCode(), StandardBasicTypes.STRING )
 				.iterate();
 		assertTrue( iter.next()==foos[1] && !iter.hasNext() );
 		list = s.createQuery( "select elements(baz.fooArray) from Baz baz where baz.id=?" )
 				.setParameter( 0, baz.getCode(), StandardBasicTypes.STRING )
 				.list();
 		assertEquals( 1, list.size() );
 		iter = s.createQuery( "select indices(baz.fooArray) from Baz baz where baz.id=?" )
 				.setParameter( 0, baz.getCode(), StandardBasicTypes.STRING )
 				.iterate();
 		assertTrue( iter.next().equals( new Integer(1) ) && !iter.hasNext() );
 
 		iter = s.createQuery( "select size(baz.stringSet) from Baz baz where baz.id=?" )
 				.setParameter( 0, baz.getCode(), StandardBasicTypes.STRING )
 				.iterate();
 		assertEquals( new Integer(3), iter.next() );
 
 		s.createQuery( "from Foo foo where foo.component.glarch.id is not null" ).list();
 
 		iter = s.createQuery(
 				"select baz, size(baz.stringSet), count( distinct elements(baz.stringSet) ), max( elements(baz.stringSet) ) from Baz baz group by baz"
 		).iterate();
 		while ( iter.hasNext() ) {
 			Object[] arr = (Object[]) iter.next();
             log.info(arr[0] + " " + arr[1] + " " + arr[2] + " " + arr[3]);
 		}
 
 		s.delete(baz);
 		s.delete(baz2);
 		s.delete( foos[1] );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testNewFlushing() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setDefaults();
 		s.save(baz);
 		s.flush();
 		baz.getStringArray()[0] = "a new value";
 		Iterator iter = s.createQuery( "from Baz baz" ).iterate();//no flush
 		assertTrue( iter.next()==baz );
 		iter = s.createQuery( "select elements(baz.stringArray) from Baz baz" ).iterate();
 		boolean found = false;
 		while ( iter.hasNext() ) {
 			if ( iter.next().equals("a new value") ) found = true;
 		}
 		assertTrue( found );
 		baz.setStringArray( null );
 		s.createQuery( "from Baz baz" ).iterate(); //no flush
 		iter = s.createQuery( "select elements(baz.stringArray) from Baz baz" ).iterate();
 		assertTrue( !iter.hasNext() );
 		baz.getStringList().add( "1E1" );
 		iter = s.createQuery( "from Foo foo" ).iterate();//no flush
 		assertTrue( !iter.hasNext() );
 		iter = s.createQuery( "select elements(baz.stringList) from Baz baz" ).iterate();
 		found = false;
 		while ( iter.hasNext() ) {
 			if ( iter.next().equals("1E1") ) found = true;
 		}
 		assertTrue( found );
 		baz.getStringList().remove( "1E1" );
 		iter = s.createQuery( "select elements(baz.stringArray) from Baz baz" ).iterate(); //no flush
 		iter = s.createQuery( "select elements(baz.stringList) from Baz baz" ).iterate();
 		found = false;
 		while ( iter.hasNext() ) {
 			if ( iter.next().equals("1E1") ) found = true;
 		}
 		assertTrue(!found);
 
 		List newList = new ArrayList();
 		newList.add("value");
 		baz.setStringList( newList );
 		iter = s.createQuery( "from Foo foo" ).iterate();//no flush
 		baz.setStringList( null );
 		iter = s.createQuery( "select elements(baz.stringList) from Baz baz" ).iterate();
 		assertTrue( !iter.hasNext() );
 
 		baz.setStringList(newList);
 		iter = s.createQuery( "from Foo foo" ).iterate();//no flush
 		iter = s.createQuery( "select elements(baz.stringList) from Baz baz" ).iterate();
 		assertTrue( iter.hasNext() );
 
 		s.delete( baz );
 		txn.commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing", "unchecked"})
 	public void testPersistCollections() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		assertEquals( 0, ( (Long) s.createQuery( "select count(*) from Bar" ).iterate().next() ).longValue() );
 		assertTrue( s.createQuery( "select count(*) from Bar b" ).iterate().next().equals( new Long(0) ) );
 		assertFalse( s.createQuery( "from Glarch g" ).iterate().hasNext() );
 
 		Baz baz = new Baz();
 		s.save(baz);
 		baz.setDefaults();
 		baz.setStringArray( new String[] { "stuff" } );
 		Set bars = new HashSet();
 		bars.add( new Bar() );
 		baz.setCascadingBars(bars);
 		HashMap sgm = new HashMap();
 		sgm.put( "a", new Glarch() );
 		sgm.put( "b", new Glarch() );
 		baz.setStringGlarchMap(sgm);
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		assertEquals( 1L, ((Long) s.createQuery( "select count(*) from Bar" ).iterate().next()).longValue() );
 		baz = (Baz) ( (Object[]) s.createQuery( "select baz, baz from Baz baz" ).list().get(0) )[1];
 		assertTrue( baz.getCascadingBars().size()==1 );
 		//System.out.println( s.print(baz) );
 		Foo foo = new Foo();
 		s.save(foo);
 		Foo foo2 = new Foo() ;
 		s.save(foo2);
 		baz.setFooArray( new Foo[] { foo, foo, null, foo2 } );
 		baz.getFooSet().add(foo);
 		baz.getCustoms().add( new String[] { "new", "custom" } );
 		baz.setStringArray(null);
 		baz.getStringList().set(0, "new value");
 		baz.setStringSet( new TreeSet() );
 		Time time = new java.sql.Time(12345);
 		baz.getTimeArray()[2] = time;
 		//System.out.println(time);
 
 		assertTrue( baz.getStringGlarchMap().size()==1 );
 
 		//The following test is disabled databases with no subselects
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof HSQLDialect) && !(getDialect() instanceof PointbaseDialect) )  {
 			List list = s.createQuery(
 					"select foo from Foo foo, Baz baz where foo in elements(baz.fooArray) and 3 = some elements(baz.intArray) and 4 > all indices(baz.intArray)"
 			).list();
 			assertTrue( "collection.elements find", list.size()==2 );
 		}
 		if (!(getDialect() instanceof SAPDBDialect) ) { // SAPDB doesn't like distinct with binary type
 			List list = s.createQuery( "select distinct foo from Baz baz join baz.fooArray foo" ).list();
 			assertTrue( "collection.elements find", list.size()==2 );
 		}
 
 		List list = s.createQuery( "select foo from Baz baz join baz.fooSet foo" ).list();
 		assertTrue( "association.elements find", list.size()==1 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		assertEquals( 1, ((Long) s.createQuery( "select count(*) from Bar" ).iterate().next()).longValue() );
 		baz = (Baz) s.createQuery( "select baz from Baz baz order by baz" ).list().get(0);
 		assertTrue( "collection of custom types - added element", baz.getCustoms().size()==4 && baz.getCustoms().get(0)!=null );
 		assertTrue ( "component of component in collection", baz.getComponents()[1].getSubcomponent()!=null );
 		assertTrue( baz.getComponents()[1].getBaz()==baz );
 		assertTrue( "set of objects", ( (FooProxy) baz.getFooSet().iterator().next() ).getKey().equals( foo.getKey() ));
 		assertTrue( "collection removed", baz.getStringArray().length==0 );
 		assertTrue( "changed element", baz.getStringList().get(0).equals("new value"));
 		assertTrue( "replaced set", baz.getStringSet().size()==0 );
 		assertTrue( "array element change", baz.getTimeArray()[2]!=null );
 		assertTrue( baz.getCascadingBars().size()==1 );
 		//System.out.println( s.print(baz) );
 		baz.getStringSet().add("two");
 		baz.getStringSet().add("one");
 		baz.getBag().add("three");
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		baz = (Baz) s.createQuery( "select baz from Baz baz order by baz" ).list().get(0);
 		assertTrue( baz.getStringSet().size()==2 );
 		assertTrue( baz.getStringSet().first().equals("one") );
 		assertTrue( baz.getStringSet().last().equals("two") );
 		assertTrue( baz.getBag().size()==5 );
 		baz.getStringSet().remove("two");
 		baz.getBag().remove("duplicate");
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		assertEquals( 1, ((Long) s.createQuery( "select count(*) from Bar" ).iterate().next()).longValue() );
 		baz = (Baz) s.load(Baz.class, baz.getCode());
 		assertTrue( baz.getCascadingBars().size()==1 );
 		Bar bar = new Bar();
 		Bar bar2 = new Bar();
 		s.save(bar); s.save(bar2);
 		baz.setTopFoos( new HashSet() );
 		baz.getTopFoos().add(bar);
 		baz.getTopFoos().add(bar2);
 		assertTrue( baz.getCascadingBars().size()==1 );
 		baz.setTopGlarchez( new TreeMap() );
 		GlarchProxy g = new Glarch();
 		s.save(g);
 		baz.getTopGlarchez().put( new Character('G'), g );
 		HashMap map = new HashMap();
 		map.put(bar, g);
 		map.put(bar2, g);
 		baz.setFooToGlarch(map);
 		map = new HashMap();
 		map.put( new FooComponent("name", 123, null, null), bar );
 		map.put( new FooComponent("nameName", 12, null, null), bar );
 		baz.setFooComponentToFoo(map);
 		map = new HashMap();
 		map.put(bar, g);
 		baz.setGlarchToFoo(map);
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		baz = (Baz) s.createQuery( "select baz from Baz baz order by baz" ).list().get(0);
 		assertTrue( baz.getCascadingBars().size()==1 );
 
 		Session s2 = openSession();
 		Transaction txn2 = s2.beginTransaction();
 		assertEquals( 3, ((Long) s2.createQuery( "select count(*) from Bar" ).iterate().next()).longValue() );
 		Baz baz2 = (Baz) s2.createQuery( "select baz from Baz baz order by baz" ).list().get(0);
 		Object o = baz2.getFooComponentToFoo().get( new FooComponent("name", 123, null, null) );
 		assertTrue(
 			o==baz2.getFooComponentToFoo().get( new FooComponent("nameName", 12, null, null) ) && o!=null
 		);
 		txn2.commit();
 		s2.close();
 
 		assertTrue( Hibernate.isInitialized( baz.getFooToGlarch() ) );
 		assertTrue( baz.getTopFoos().size()==2 );
 		assertTrue( baz.getTopGlarchez().size()==1 );
 		assertTrue( baz.getTopFoos().iterator().next()!=null );
 		assertTrue( baz.getStringSet().size()==1 );
 		assertTrue( baz.getBag().size()==4 );
 		assertTrue( baz.getFooToGlarch().size()==2 );
 		assertTrue( baz.getFooComponentToFoo().size()==2 );
 		assertTrue( baz.getGlarchToFoo().size()==1 );
 		Iterator iter = baz.getFooToGlarch().keySet().iterator();
 		for (int i=0; i<2; i++ ) assertTrue( iter.next() instanceof BarProxy );
 		FooComponent fooComp = (FooComponent) baz.getFooComponentToFoo().keySet().iterator().next();
 		assertTrue(
 			( (fooComp.getCount()==123 && fooComp.getName().equals("name"))
 			|| (fooComp.getCount()==12 && fooComp.getName().equals("nameName")) )
 			&& ( baz.getFooComponentToFoo().get(fooComp) instanceof BarProxy )
 		);
 		Glarch g2 = new Glarch();
 		s.save(g2);
 		g = (GlarchProxy) baz.getTopGlarchez().get( new Character('G') );
 		baz.getTopGlarchez().put( new Character('H'), g );
 		baz.getTopGlarchez().put( new Character('G'), g2 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		baz = (Baz) s.load(Baz.class, baz.getCode());
 		assertTrue( baz.getTopGlarchez().size()==2 );
 		assertTrue( baz.getCascadingBars().size()==1 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		assertEquals( 3, ((Long) s.createQuery( "select count(*) from Bar" ).iterate().next()).longValue() );
 		baz = (Baz) s.createQuery( "select baz from Baz baz order by baz" ).list().get(0);
 		assertTrue( baz.getTopGlarchez().size()==2 );
 		assertTrue( baz.getCascadingBars().size()==1 );
 		txn.commit();
 
 		final Session s3 = (Session) SerializationHelper.deserialize( SerializationHelper.serialize(s) );
 		s.close();
 
 		txn2 = s3.beginTransaction();
 		baz = (Baz) s3.load(Baz.class, baz.getCode());
 		assertEquals( 3, ((Long) s3.createQuery( "select count(*) from Bar" ).iterate().next()).longValue() );
 		s3.delete(baz);
 		s3.delete( baz.getTopGlarchez().get( Character.valueOf('G') ) );
 		s3.delete( baz.getTopGlarchez().get( Character.valueOf('H') ) );
 		int rows = s3.doReturningWork(
 				new AbstractReturningWork<Integer>() {
 					@Override
 					public Integer execute(Connection connection) throws SQLException {
 						final String sql = "update " + getDialect().openQuote() + "glarchez" + getDialect().closeQuote() + " set baz_map_id=null where baz_map_index='a'";
 						Statement st = connection.createStatement();
 						return st.executeUpdate( sql );
 					}
 				}
 		);
 		assertTrue(rows==1);
 		assertEquals( 2, doDelete( s3, "from Bar bar" ) );
 		FooProxy[] arr = baz.getFooArray();
 		assertTrue( "new array of objects", arr.length==4 && arr[1].getKey().equals( foo.getKey() ) );
 		for ( int i=1; i<arr.length; i++ ) {
 			if ( arr[i]!=null) s3.delete(arr[i]);
 		}
 
 		s3.load( Qux.class, new Long(666) ); //nonexistent
 
 		assertEquals( 1, doDelete( s3, "from Glarch g" ) );
 		txn2.commit();
 
 		s3.disconnect();
 
 		Session s4 = (Session) SerializationHelper.deserialize( SerializationHelper.serialize( s3 ) );
 		s3.close();
 		//s3.reconnect();
 		assertTrue( s4.load( Qux.class, new Long(666) )!=null ); //nonexistent
 		//s3.disconnect();
 		s4.close();
 	}
 
 	@Test
 	public void testSaveFlush() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Fee fee = new Fee();
 		s.save( fee );
 		fee.setFi( "blah" );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		fee = (Fee) s.load( Fee.class, fee.getKey() );
 		assertTrue( "blah".equals( fee.getFi() ) );
 		s.delete(fee);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCreateUpdate() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo foo = new Foo();
 		s.save(foo);
 		foo.setString("dirty");
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Foo foo2 = new Foo();
 		s.load( foo2, foo.getKey() );
 		// There is an interbase bug that causes null integers to return as 0, also numeric precision is <= 15
 		assertTrue( "create-update", foo.equalsFoo(foo2) );
 		//System.out.println( s.print(foo2) );
 		s.delete(foo2);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo = new Foo();
 		s.save(foo);
 		foo.setString("dirty");
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.load(foo2, foo.getKey());
 		// There is an interbase bug that causes null integers to return as 0, also numeric precision is <= 15
 		assertTrue( "create-update", foo.equalsFoo(foo2) );
 		//System.out.println( s.print(foo2) );
 		s.delete(foo2);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testUpdateCollections() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Holder baz = new Holder();
 		baz.setName("123");
 		Foo f1 = new Foo();
 		Foo f2 = new Foo();
 		Foo f3 = new Foo();
 		One o = new One();
 		baz.setOnes( new ArrayList() );
 		baz.getOnes().add(o);
 		Foo[] foos = new Foo[] { f1, null, f2 };
 		baz.setFooArray(foos);
 		baz.setFoos( new HashSet() );
 		baz.getFoos().add(f1);
 		s.save(f1);
 		s.save(f2);
 		s.save(f3);
 		s.save(o);
 		s.save(baz);
 		s.getTransaction().commit();
 		s.close();
 
 		baz.getOnes().set(0, null);
 		baz.getOnes().add(o);
 		baz.getFoos().add(f2);
 		foos[0] = f3;
 		foos[1] = f1;
 
 		s = openSession();
 		s.beginTransaction();
 		s.saveOrUpdate(baz);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Holder h = (Holder) s.load(Holder.class, baz.getId());
 		assertTrue( h.getOnes().get(0)==null );
 		assertTrue( h.getOnes().get(1)!=null );
 		assertTrue( h.getFooArray()[0]!=null);
 		assertTrue( h.getFooArray()[1]!=null);
 		assertTrue( h.getFooArray()[2]!=null);
 		assertTrue( h.getFoos().size()==2 );
 		s.getTransaction().commit();
 		s.close();
 
 		baz.getFoos().remove(f1);
 		baz.getFoos().remove(f2);
 		baz.getFooArray()[0]=null;
 		baz.getFooArray()[0]=null;
 		baz.getFooArray()[0]=null;
 
 		s = openSession();
 		s.beginTransaction();
 		s.saveOrUpdate(baz);
 		doDelete( s, "from Foo" );
 		baz.getOnes().remove(o);
 		doDelete( s, "from One" );
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCreate() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo foo = new Foo();
 		s.save(foo);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Foo foo2 = new Foo();
 		s.load( foo2, foo.getKey() );
 		// There is an interbase bug that causes null integers to return as 0, also numeric precision is <= 15
 		assertTrue( "create", foo.equalsFoo( foo2 ) );
 		s.delete(foo2);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCallback() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Qux q = new Qux("0");
 		s.save(q);
 		q.setChild( new Qux( "1" ) );
 		s.save( q.getChild() );
 		Qux q2 = new Qux("2");
 		q2.setChild( q.getChild() );
 		Qux q3 = new Qux("3");
 		q.getChild().setChild(q3);
 		s.save( q3 );
 		Qux q4 = new Qux("4");
 		q4.setChild( q3 );
 		s.save(q4);
 		s.save( q2 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		List l = s.createQuery( "from Qux" ).list();
 		assertTrue( "", l.size() == 5 );
 		s.delete( l.get( 0 ) );
 		s.delete( l.get( 1 ) );
 		s.delete( l.get( 2 ) );
 		s.delete( l.get(3) );
 		s.delete( l.get(4) );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testPolymorphism() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Bar bar = new Bar();
 		s.save(bar);
 		bar.setBarString("bar bar");
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		FooProxy foo = (FooProxy) s.load( Foo.class, bar.getKey() );
 		assertTrue( "polymorphic", foo instanceof BarProxy );
 		assertTrue( "subclass property", ( (BarProxy) foo ).getBarString().equals( bar.getBarString() ) );
 		//System.out.println( s.print(foo) );
 		s.delete(foo);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testRemoveContains() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setDefaults();
 		s.save( baz );
 		s.flush();
 		assertTrue( s.contains(baz) );
 		s.evict( baz );
 		assertFalse( s.contains(baz) );
 		Baz baz2 = (Baz) s.load( Baz.class, baz.getCode() );
 		assertFalse( baz == baz2 );
 		s.delete(baz2);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testCollectionOfSelf() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Bar bar = new Bar();
 		s.save(bar);
 		bar.setAbstracts( new HashSet() );
 		bar.getAbstracts().add( bar );
 		Bar bar2 = new Bar();
 		bar.getAbstracts().add( bar2 );
 		bar.setFoo(bar);
 		s.save( bar2 );
 		s.getTransaction().commit();
 		s.close();
 
 		bar.setAbstracts( null );
 
 		s = openSession();
 		s.beginTransaction();
 		s.load( bar, bar.getKey() );
 		assertTrue( "collection contains self", bar.getAbstracts().size() == 2 && bar.getAbstracts().contains( bar ) );
 		assertTrue( "association to self", bar.getFoo()==bar );
 		for ( Object o : bar.getAbstracts() ) {
 			s.delete( o );
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testFind() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 
 		Bar bar = new Bar();
 		s.save(bar);
 		bar.setBarString("bar bar");
 		bar.setString("xxx");
 		Foo foo = new Foo();
 		s.save(foo);
 		foo.setString("foo bar");
 		s.save( new Foo() );
 		s.save( new Bar() );
 		List list1 = s.createQuery( "select foo from Foo foo where foo.string='foo bar'" ).list();
 		assertTrue( "find size", list1.size()==1 );
 		assertTrue( "find ==", list1.get(0)==foo );
 		List list2 = s.createQuery( "from Foo foo order by foo.string, foo.date" ).list();
 		assertTrue( "find size", list2.size()==4 );
 
 		list1 = s.createQuery( "from Foo foo where foo.class='B'" ).list();
 		assertTrue( "class special property", list1.size()==2);
 		list1 = s.createQuery( "from Foo foo where foo.class=Bar" ).list();
 		assertTrue( "class special property", list1.size()==2);
 		list1 = s.createQuery( "from Foo foo where foo.class=Bar" ).list();
 		list2 = s.createQuery( "select bar from Bar bar, Foo foo where bar.string = foo.string and not bar=foo" ).list();
 		assertTrue( "class special property", list1.size()==2);
 		assertTrue( "select from a subclass", list2.size()==1);
 		Trivial t = new Trivial();
 		s.save(t);
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		list1 = s.createQuery( "from Foo foo where foo.string='foo bar'" ).list();
 		assertTrue( "find size", list1.size()==1 );
 		// There is an interbase bug that causes null integers to return as 0, also numeric precision is <= 15
 		assertTrue( "find equals", ( (Foo) list1.get(0) ).equalsFoo(foo) );
 		list2 = s.createQuery( "select foo from Foo foo" ).list();
 		assertTrue( "find size", list2.size()==5 );
 		List list3 = s.createQuery( "from Bar bar where bar.barString='bar bar'" ).list();
 		assertTrue( "find size", list3.size()==1 );
 		assertTrue( "find same instance", list2.contains( list1.get(0) ) && list2.contains( list2.get(0) ) );
 		assertTrue( s.createQuery( "from Trivial" ).list().size()==1 );
 		doDelete( s, "from Trivial" );
 
 		list2 = s.createQuery( "from Foo foo where foo.date = ?" )
 				.setParameter( 0, new java.sql.Date(123), StandardBasicTypes.DATE )
 				.list();
 		assertTrue ( "find by date", list2.size()==4 );
 		Iterator iter = list2.iterator();
 		while ( iter.hasNext() ) {
 			s.delete( iter.next() );
 		}
 		list2 = s.createQuery( "from Foo foo" ).list();
 		assertTrue( "find deleted", list2.size()==0);
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testDeleteRecursive() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo x = new Foo();
 		Foo y = new Foo();
 		x.setFoo( y );
 		y.setFoo( x );
 		s.save( x );
 		s.save( y );
 		s.flush();
 		s.delete( y );
 		s.delete( x );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testReachability() throws Exception {
 		//first for unkeyed collections
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz1 = new Baz();
 		s.save(baz1);
 		Baz baz2 = new Baz();
 		s.save(baz2);
 		baz1.setIntArray( new int[] {1 ,2, 3, 4} );
 		baz1.setFooSet( new HashSet() );
 		Foo foo = new Foo();
 		s.save(foo);
 		baz1.getFooSet().add(foo);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		baz1 = (Baz) s.load( Baz.class, baz1.getCode() );
 		baz2.setFooSet( baz1.getFooSet() ); baz1.setFooSet(null);
 		baz2.setIntArray( baz1.getIntArray() ); baz1.setIntArray(null);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		baz1 = (Baz) s.load( Baz.class, baz1.getCode() );
 		assertTrue( "unkeyed reachability", baz2.getIntArray().length==4 );
 		assertTrue( "unkeyed reachability", baz2.getFooSet().size()==1 );
 		assertTrue( "unkeyed reachability", baz1.getIntArray().length==0 );
 		assertTrue( "unkeyed reachability", baz1.getFooSet().size()==0 );
 		//System.out.println( s.print(baz1) + s.print(baz2) );
 		FooProxy fp = (FooProxy) baz2.getFooSet().iterator().next();
 		s.delete(fp);
 		s.delete(baz1);
 		s.delete(baz2);
 		s.getTransaction().commit();
 		s.close();
 
 		//now for collections of collections
 		s = openSession();
 		s.beginTransaction();
 		baz1 = new Baz();
 		s.save(baz1);
 		baz2 = new Baz();
 		s.save(baz2);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		baz1 = (Baz) s.load( Baz.class, baz1.getCode() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		baz1 = (Baz) s.load( Baz.class, baz1.getCode() );
 		s.delete(baz1);
 		s.delete(baz2);
 		s.getTransaction().commit();
 		s.close();
 
 		//now for keyed collections
 		s = openSession();
 		s.beginTransaction();
 		baz1 = new Baz();
 		s.save(baz1);
 		baz2 = new Baz();
 		s.save(baz2);
 		Foo foo1 = new Foo();
 		Foo foo2 = new Foo();
 		s.save(foo1); s.save(foo2);
 		baz1.setFooArray( new Foo[] { foo1, null, foo2 } );
 		baz1.setStringDateMap( new TreeMap() );
 		baz1.getStringDateMap().put("today", new Date( System.currentTimeMillis() ) );
 		baz1.getStringDateMap().put("tomorrow", new Date( System.currentTimeMillis() + 86400000 ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		baz1 = (Baz) s.load( Baz.class, baz1.getCode() );
 		baz2.setFooArray( baz1.getFooArray() ); baz1.setFooArray(null);
 		baz2.setStringDateMap( baz1.getStringDateMap() ); baz1.setStringDateMap(null);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		baz1 = (Baz) s.load( Baz.class, baz1.getCode() );
 		assertTrue( "reachability", baz2.getStringDateMap().size()==2 );
 		assertTrue( "reachability", baz2.getFooArray().length==3 );
 		assertTrue( "reachability", baz1.getStringDateMap().size()==0 );
 		assertTrue( "reachability", baz1.getFooArray().length==0 );
 		assertTrue( "null element", baz2.getFooArray()[1]==null );
 		assertTrue( "non-null element", baz2.getStringDateMap().get("today")!=null );
 		assertTrue( "non-null element", baz2.getStringDateMap().get("tomorrow")!=null );
 		assertTrue( "null element", baz2.getStringDateMap().get("foo")==null );
 		s.delete( baz2.getFooArray()[0] );
 		s.delete( baz2.getFooArray()[2] );
 		s.delete(baz1);
 		s.delete(baz2);
 		s.flush();
 		assertTrue( s.createQuery( "from java.lang.Object" ).list().size()==0 );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testPersistentLifecycle() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Qux q = new Qux();
 		s.save(q);
 		q.setStuff("foo bar baz qux");
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		q = (Qux) s.load( Qux.class, q.getKey() );
 		assertTrue( "lifecycle create", q.getCreated() );
 		assertTrue( "lifecycle load", q.getLoaded() );
 		assertTrue( "lifecycle subobject", q.getFoo()!=null );
 		s.delete(q);
 		assertTrue( "lifecycle delete", q.getDeleted() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		assertTrue( "subdeletion", s.createQuery( "from Foo foo" ).list().size()==0);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testIterators() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		for ( int i=0; i<10; i++ ) {
 			Qux q = new Qux();
 			Object qid = s.save(q);
 			assertTrue("not null", qid!=null);
 		}
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Iterator iter = s.createQuery( "from Qux q where q.stuff is null" ).iterate();
 		int count=0;
 		while ( iter.hasNext() ) {
 			Qux q = (Qux) iter.next();
 			q.setStuff("foo");
 			if (count==0 || count==5) iter.remove();
 			count++;
 		}
 		assertTrue("iterate", count==10);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		assertEquals( 8, doDelete( s, "from Qux q where q.stuff=?", "foo", StandardBasicTypes.STRING ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		iter = s.createQuery( "from Qux q" ).iterate();
 		assertTrue( "empty iterator", !iter.hasNext() );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testVersioning() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		GlarchProxy g = new Glarch();
 		s.save(g);
 		GlarchProxy g2 = new Glarch();
 		s.save(g2);
 		Serializable gid = s.getIdentifier(g);
 		Serializable g2id = s.getIdentifier(g2);
 		g.setName("glarch");
 		txn.commit();
 		s.close();
 
 		sessionFactory().evict(Glarch.class);
 
 		s = openSession();
 		txn = s.beginTransaction();
 		g = (GlarchProxy) s.load( Glarch.class, gid );
 		s.lock(g, LockMode.UPGRADE);
 		g2 = (GlarchProxy) s.load( Glarch.class, g2id );
 		assertTrue( "version", g.getVersion()==1 );
 		assertTrue( "version", g.getDerivedVersion()==1 );
 		assertTrue( "version", g2.getVersion()==0 );
 		g.setName("foo");
 		assertTrue(
 			"find by version",
 				s.createQuery( "from Glarch g where g.version=2" ).list().size()==1
 		);
 		g.setName("bar");
 		txn.commit();
 		s.close();
 
 		sessionFactory().evict(Glarch.class);
 
 		s = openSession();
 		txn = s.beginTransaction();
 		g = (GlarchProxy) s.load( Glarch.class, gid );
 		g2 = (GlarchProxy) s.load( Glarch.class, g2id );
 		assertTrue( "version", g.getVersion()==3 );
 		assertTrue( "version", g.getDerivedVersion()==3 );
 		assertTrue( "version", g2.getVersion()==0 );
 		g.setNext(null);
 		g2.setNext(g);
 		s.delete(g2);
 		s.delete(g);
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testVersionedCollections() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		GlarchProxy g = new Glarch();
 		s.save(g);
 		g.setProxyArray( new GlarchProxy[] { g } );
 		String gid = (String) s.getIdentifier(g);
 		ArrayList list = new ArrayList();
 		list.add("foo");
 		g.setStrings(list);
 		HashSet set = new HashSet();
 		set.add( g );
 		g.setProxySet( set );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( g.getStrings().size()==1 );
 		assertTrue( g.getProxyArray().length==1 );
 		assertTrue( g.getProxySet().size()==1 );
 		assertTrue( "versioned collection before", g.getVersion() == 1 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( g.getStrings().get(0).equals("foo") );
 		assertTrue( g.getProxyArray()[0]==g );
 		assertTrue( g.getProxySet().iterator().next()==g );
 		assertTrue( "versioned collection before", g.getVersion() == 1 );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( "versioned collection before", g.getVersion() == 1 );
 		g.getStrings().add( "bar" );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( "versioned collection after", g.getVersion()==2 );
 		assertTrue( "versioned collection after", g.getStrings().size() == 2 );
 		g.setProxyArray( null );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( "versioned collection after", g.getVersion()==3 );
 		assertTrue( "versioned collection after", g.getProxyArray().length == 0 );
 		g.setFooComponents( new ArrayList() );
 		g.setProxyArray( null );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		g = (GlarchProxy) s.load(Glarch.class, gid);
 		assertTrue( "versioned collection after", g.getVersion()==4 );
 		s.delete(g);
 		s.flush();
 		assertTrue( s.createQuery( "from java.lang.Object" ).list().size()==0 );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testRecursiveLoad() throws Exception {
 		//Non polymorphic class (there is an implementation optimization
 		//being tested here)
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		GlarchProxy last = new Glarch();
 		s.save(last);
 		last.setOrder( (short) 0 );
 		for (int i=0; i<5; i++) {
 			GlarchProxy next = new Glarch();
 			s.save(next);
 			last.setNext(next);
 			last = next;
 			last.setOrder( (short) (i+1) );
 		}
 		Iterator iter = s.createQuery( "from Glarch g" ).iterate();
 		while ( iter.hasNext() ) {
 			iter.next();
 		}
 		List list = s.createQuery( "from Glarch g" ).list();
 		assertTrue( "recursive find", list.size()==6 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		list = s.createQuery( "from Glarch g" ).list();
 		assertTrue( "recursive iter", list.size()==6 );
 		list = s.createQuery( "from Glarch g where g.next is not null" ).list();
 		assertTrue( "recursive iter", list.size()==5 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		iter = s.createQuery( "from Glarch g order by g.order asc" ).iterate();
 		while ( iter.hasNext() ) {
 			GlarchProxy g = (GlarchProxy) iter.next();
 			assertTrue( "not null", g!=null );
 			iter.remove();
 		}
 		txn.commit();
 		s.close();
 
 		//Same thing but using polymorphic class (no optimisation possible):
 		s = openSession();
 		txn = s.beginTransaction();
 		FooProxy flast = new Bar();
 		s.save(flast);
 		flast.setString( "foo0" );
 		for (int i=0; i<5; i++) {
 			FooProxy foo = new Bar();
 			s.save(foo);
 			flast.setFoo(foo);
 			flast = flast.getFoo();
 			flast.setString( "foo" + (i+1) );
 		}
 		iter = s.createQuery( "from Foo foo" ).iterate();
 		while ( iter.hasNext() ) {
 			iter.next();
 		}
 		list = s.createQuery( "from Foo foo" ).list();
 		assertTrue( "recursive find", list.size()==6 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		list = s.createQuery( "from Foo foo" ).list();
 		assertTrue( "recursive iter", list.size()==6 );
 		iter = list.iterator();
 		while ( iter.hasNext() ) {
 			assertTrue( "polymorphic recursive load", iter.next() instanceof BarProxy );
 		}
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		iter = s.createQuery( "from Foo foo order by foo.string asc" ).iterate();
 		while ( iter.hasNext() ) {
 			BarProxy bar = (BarProxy) iter.next();
 			assertTrue( "not null", bar!=null );
 			iter.remove();
 		}
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testScrollableIterator() throws Exception {
 		// skip if not one of these named dialects
 		boolean match = getDialect() instanceof DB2Dialect
 				|| getDialect() instanceof SybaseDialect
 				|| getDialect() instanceof HSQLDialect
 				|| getDialect() instanceof Oracle8iDialect // 9i/10g too because of inheritence...
 				;
 		if ( ! match ) {
 			return;
 		}
 
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		s.save( new Foo() );
 		s.save( new Foo() );
 		s.save( new Foo() );
 		s.save( new Bar() );
 		Query query = s.createQuery("select f, f.integer from Foo f");
 		assertTrue( query.getReturnTypes().length==2 );
 		ScrollableResults iter = query.scroll();
 		assertTrue( iter.next() );
 		assertTrue( iter.scroll(1) );
 		FooProxy f2 = (FooProxy) iter.get()[0];
 		assertTrue( f2!=null );
 		assertTrue( iter.scroll(-1) );
 		Object f1 = iter.get(0);
 		iter.next();
 		assertTrue( f1!=null && iter.get(0)==f2 );
 		iter.getInteger(1);
 
 		assertTrue( !iter.scroll(100) );
 		assertTrue( iter.first() );
 		assertTrue( iter.scroll(3) );
 		Object f4 = iter.get(0);
 		assertTrue( f4!=null );
 		assertTrue( !iter.next() );
 		assertTrue( iter.first() );
 		assertTrue( iter.get(0)==f1 );
 		assertTrue( iter.last() );
 		assertTrue( iter.get(0)==f4 );
 		assertTrue( iter.previous() );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		query = s.createQuery("select f, f.integer from Foo f");
 		assertTrue( query.getReturnTypes().length==2 );
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/LegacyTestCase.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/LegacyTestCase.java
index e88393d175..5919d147c5 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/LegacyTestCase.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/LegacyTestCase.java
@@ -1,130 +1,129 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
 
 import java.util.List;
 
 import org.junit.Before;
 
 import org.hibernate.Query;
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.DefaultNamingStrategy;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.DB2Dialect;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.PostgreSQL81Dialect;
 import org.hibernate.dialect.PostgreSQLDialect;
 import org.hibernate.hql.internal.classic.ClassicQueryTranslatorFactory;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.hibernate.type.Type;
 
 /**
  * @author Steve Ebersole
  */
 public abstract class LegacyTestCase extends BaseCoreFunctionalTestCase {
 	public static final String USE_ANTLR_PARSER_PROP = "legacy.use_antlr_hql_parser";
 
 	private boolean useAntlrParser;
 
 	@Before
-	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	public void checkAntlrParserSetting() {
 		useAntlrParser = Boolean.valueOf( extractFromSystem( USE_ANTLR_PARSER_PROP ) );
 	}
 
 	protected boolean supportsLockingNullableSideOfJoin(Dialect dialect) {
 		// db2 and pgsql do *NOT*
 		return ! ( DB2Dialect.class.isInstance( dialect ) || PostgreSQL81Dialect.class.isInstance( dialect ) || PostgreSQLDialect.class.isInstance( dialect ));
 	}
 
 	protected static String extractFromSystem(String systemPropertyName) {
 		try {
 			return System.getProperty( systemPropertyName );
 		}
 		catch( Throwable t ) {
 			return null;
 		}
 	}
 
 	@Override
 	protected void cleanupTestData() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		List list = s.createQuery( "from java.lang.Object" ).list();
 		for ( Object obj : list ) {
 			s.delete( obj );
 		}
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		if ( !useAntlrParser ) {
 			cfg.setProperty( Environment.QUERY_TRANSLATOR, ClassicQueryTranslatorFactory.class.getName() );
 			try {
 				String dialectTrueRepresentation = Dialect.getDialect().toBooleanValueString( true );
 				// if this call succeeds, then the dialect is saying to represent true/false as int values...
 				Integer.parseInt( dialectTrueRepresentation );
 				String subs = cfg.getProperties().getProperty( Environment.QUERY_SUBSTITUTIONS );
 				if ( subs == null ) {
 					subs = "";
 				}
 				if ( StringHelper.isEmpty( subs ) ) {
 					subs = "true=1, false=0";
 				}
 				else {
 					subs += ", true=1, false=0";
 				}
 				cfg.getProperties().setProperty( Environment.QUERY_SUBSTITUTIONS, subs );
 				cfg.setNamingStrategy( DefaultNamingStrategy.INSTANCE );
 			}
 			catch( NumberFormatException nfe ) {
 				// the Integer#parseInt call failed...
 			}
 		}
 	}
 
 	protected int doDelete(Session session, String queryString) {
 		return doDelete( session, session.createQuery( queryString ) );
 	}
 
 	protected int doDelete(Session session, String queryString, Object param, Type paramType) {
 		Query query = session.createQuery( queryString )
 				.setParameter( 0, param, paramType );
 		return doDelete( session, query );
 	}
 
 	protected int doDelete(Session session, Query selectQuery) {
 		int count = 0;
 		for ( Object o : selectQuery.list() ) {
 			session.delete( o );
 			count++;
 		}
 		return count;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/MultiplicityType.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/MultiplicityType.java
index db5c9336a0..09acc4d7cf 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/MultiplicityType.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/MultiplicityType.java
@@ -1,166 +1,166 @@
 //$Id: MultiplicityType.java 6592 2005-04-28 15:44:16Z oneovthafew $
 package org.hibernate.test.legacy;
 import java.io.Serializable;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Session;
 import org.hibernate.engine.internal.ForeignKeys;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.type.IntegerType;
 import org.hibernate.type.ManyToOneType;
 import org.hibernate.type.StandardBasicTypes;
 import org.hibernate.type.StringType;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeFactory;
 import org.hibernate.usertype.CompositeUserType;
 
 public class MultiplicityType implements CompositeUserType {
 
 	private static final String[] PROP_NAMES = new String[] {
 		"count", "glarch"
 	};
 	private static final int[] SQL_TYPES = new int[] {
 			IntegerType.INSTANCE.getSqlTypeDescriptor().getSqlType(),
 			StringType.INSTANCE.getSqlTypeDescriptor().getSqlType()
 	};
 	private static final Type[] TYPES = new Type[] {
 			IntegerType.INSTANCE,
 			new ManyToOneType(
 					new TypeFactory.TypeScope() {
 						@Override
 						public SessionFactoryImplementor resolveFactory() {
 							// todo : can we tie this into org.hibernate.type.TypeFactory.TypeScopeImpl() somehow?
 							throw new HibernateException( "Cannot access SessionFactory from here" );
 						}
 					},
 					Glarch.class.getName()
 			)
 	};
 
 	public String[] getPropertyNames() {
 		return PROP_NAMES;
 	}
 
 	public Type[] getPropertyTypes() {
 		return TYPES;
 	}
 
 	public int hashCode(Object x) throws HibernateException {
 		Multiplicity o = (Multiplicity) x;
 		return o.count + o.glarch.hashCode();
 	}
 
 	public Object getPropertyValue(Object component, int property) {
 		Multiplicity o = (Multiplicity) component;
 		return property==0 ?
 				new Integer(o.count) :
 				o.glarch;
 	}
 
 	public void setPropertyValue(
 		Object component,
 		int property,
 		Object value) {
 
 		Multiplicity o = (Multiplicity) component;
 		if (property==0) {
 			o.count = ( (Integer) value ).intValue();
 		}
 		else {
 			o.glarch = (Glarch) value;
 		}
 	}
 
 	public int[] sqlTypes() {
 		return SQL_TYPES;
 	}
 
 	public Class returnedClass() {
 		return Multiplicity.class;
 	}
 
 	public boolean equals(Object x, Object y) {
 		Multiplicity mx = (Multiplicity) x;
 		Multiplicity my = (Multiplicity) y;
 		if (mx==my) return true;
 		if (mx==null || my==null) return false;
 		return mx.count==my.count && mx.glarch==my.glarch;
 	}
 
 	public Object nullSafeGet(ResultSet rs, String[] names, SessionImplementor session, Object owner)
 		throws HibernateException, SQLException {
 
 		Integer c = IntegerType.INSTANCE.nullSafeGet( rs, names[0], session );
 		GlarchProxy g = (GlarchProxy) ( (Session) session ).getTypeHelper().entity( Glarch.class ).nullSafeGet(rs, names[1], session, owner);
 		Multiplicity m = new Multiplicity();
 		m.count = c==null ? 0 : c.intValue();
 		m.glarch = g;
 		return m;
 	}
 
 	public void nullSafeSet(PreparedStatement st, Object value, int index, SessionImplementor session)
 		throws HibernateException, SQLException {
 
 		Multiplicity o = (Multiplicity) value;
 		GlarchProxy g;
 		Integer c;
 		if (o==null) {
 			g=null;
 			c=new Integer(0);
 		}
 		else {
 			g = o.glarch;
 			c = new Integer(o.count);
 		}
 		StandardBasicTypes.INTEGER.nullSafeSet(st, c, index, session);
 		( (Session) session ).getTypeHelper().entity( Glarch.class ).nullSafeSet(st, g, index+1, session);
 
 	}
 
 	public Object deepCopy(Object value) {
 		if (value==null) return null;
 		Multiplicity v = (Multiplicity) value;
 		Multiplicity m = new Multiplicity();
 		m.count = v.count;
 		m.glarch = v.glarch;
 		return m;
 	}
 
 	public boolean isMutable() {
 		return true;
 	}
 
 	public Object assemble(
 		Serializable cached,
 		SessionImplementor session,
 		Object owner) throws HibernateException {
 		if (cached==null) return null;
 		Serializable[] o = (Serializable[]) cached;
 		Multiplicity m = new Multiplicity();
 		m.count = ( (Integer) o[0] ).intValue();
 		m.glarch = o[1]==null ? 
 			null : 
 			(GlarchProxy) session.internalLoad( Glarch.class.getName(), o[1], false, false );
 		return m;
 	}
 
 	public Serializable disassemble(Object value, SessionImplementor session)
 	throws HibernateException {
 		if (value==null) return null;
 		Multiplicity m = (Multiplicity) value;
 		return new Serializable[] { 
 				new Integer(m.count), 
 				ForeignKeys.getEntityIdentifierIfNotUnsaved( Glarch.class.getName(), m.glarch, session ) 
 		};
 	}
 
 	public Object replace(Object original, Object target, SessionImplementor session, Object owner) 
 	throws HibernateException {
 		return assemble( disassemble(original, session), session, owner);
 	}
 	
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/ParentChildTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/ParentChildTest.java
index dd97788db5..875ca2598e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/ParentChildTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/ParentChildTest.java
@@ -1,1067 +1,1066 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
 
 import java.io.Serializable;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.junit.Test;
 
 import org.hibernate.Criteria;
 import org.hibernate.FetchMode;
 import org.hibernate.Hibernate;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.ReplicationMode;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.criterion.Restrictions;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.IngresDialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.engine.spi.EntityEntry;
 import org.hibernate.internal.SessionImpl;
 import org.hibernate.jdbc.AbstractWork;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.testing.FailureExpected;
 import org.hibernate.type.StandardBasicTypes;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 
-@SuppressWarnings( {"UnnecessaryBoxing"})
 public class ParentChildTest extends LegacyTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 			"legacy/ParentChild.hbm.xml",
 			"legacy/FooBar.hbm.xml",
 		 	"legacy/Baz.hbm.xml",
 		 	"legacy/Qux.hbm.xml",
 		 	"legacy/Glarch.hbm.xml",
 		 	"legacy/Fum.hbm.xml",
 		 	"legacy/Fumm.hbm.xml",
 		 	"legacy/Fo.hbm.xml",
 		 	"legacy/One.hbm.xml",
 		 	"legacy/Many.hbm.xml",
 		 	"legacy/Immutable.hbm.xml",
 		 	"legacy/Fee.hbm.xml",
 		 	"legacy/Vetoer.hbm.xml",
 		 	"legacy/Holder.hbm.xml",
 		 	"legacy/Simple.hbm.xml",
 		 	"legacy/Container.hbm.xml",
 		 	"legacy/Circular.hbm.xml",
 		 	"legacy/Stuff.hbm.xml"
 		};
 	}
 
 	@Test
 	public void testReplicate() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Container baz = new Container();
 		Contained f = new Contained();
 		List list = new ArrayList();
 		list.add(baz);
 		f.setBag(list);
 		List list2 = new ArrayList();
 		list2.add(f);
 		baz.setBag(list2);
 		s.save(f);
 		s.save(baz);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.replicate(baz, ReplicationMode.OVERWRITE);
 		// HHH-2378
 		SessionImpl x = (SessionImpl)s;
 		EntityEntry entry = x.getPersistenceContext().getEntry( baz );
 		assertNull(entry.getVersion());
 		// ~~~~~~~
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.replicate(baz, ReplicationMode.IGNORE);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete(baz);
 		s.delete(f);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testQueryOneToOne() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Serializable id = s.save( new Parent() );
 		assertTrue( s.createQuery( "from Parent p left join fetch p.child" ).list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Parent p = (Parent) s.createQuery("from Parent p left join fetch p.child").uniqueResult();
 		assertTrue( p.getChild()==null );
 		s.createQuery( "from Parent p join p.child c where c.x > 0" ).list();
 		s.createQuery( "from Child c join c.parent p where p.x > 0" ).list();
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete( s.get(Parent.class, id) );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@FailureExpected( jiraKey = "unknown" )
 	public void testProxyReuse() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		FooProxy foo = new Foo();
 		FooProxy foo2 = new Foo();
 		Serializable id = s.save(foo);
 		Serializable id2 = s.save(foo2);
 		foo2.setInt( 1234567 );
 		foo.setInt(1234);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		foo = (FooProxy) s.load(Foo.class, id);
 		foo2 = (FooProxy) s.load(Foo.class, id2);
 		assertFalse( Hibernate.isInitialized( foo ) );
 		Hibernate.initialize( foo2 );
 		Hibernate.initialize(foo);
 		assertTrue( foo.getComponent().getImportantDates().length==4 );
 		assertTrue( foo2.getComponent().getImportantDates().length == 4 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		foo.setKey( "xyzid" );
 		foo.setFloat( new Float( 1.2f ) );
 		foo2.setKey( (String) id ); //intentionally id, not id2!
 		foo2.setFloat( new Float( 1.3f ) );
 		foo2.getDependent().setKey( null );
 		foo2.getComponent().getSubcomponent().getFee().setKey(null);
 		assertFalse( foo2.getKey().equals( id ) );
 		s.save( foo );
 		s.update( foo2 );
 		assertEquals( foo2.getKey(), id );
 		assertTrue( foo2.getInt() == 1234567 );
 		assertEquals( foo.getKey(), "xyzid" );
 		t.commit();
 		s.close();
 		
 		s = openSession();
 		t = s.beginTransaction();
 		foo = (FooProxy) s.load(Foo.class, id);
 		assertTrue( foo.getInt() == 1234567 );
 		assertTrue( foo.getComponent().getImportantDates().length==4 );
 		String feekey = foo.getDependent().getKey();
 		String fookey = foo.getKey();
 		s.delete( foo );
 		s.delete( s.get(Foo.class, id2) );
 		s.delete( s.get(Foo.class, "xyzid") );
 // here is the issue (HHH-4092).  After the deletes above there are 2 Fees and a Glarch unexpectedly hanging around
 		assertEquals( 2, doDelete( s, "from java.lang.Object" ) );
 		t.commit();
 		s.close();
 		
 		//to account for new id rollback shit
 		foo.setKey(fookey);
 		foo.getDependent().setKey( feekey );
 		foo.getComponent().setGlarch( null );
 		foo.getComponent().setSubcomponent(null);
 		
 		s = openSession();
 		t = s.beginTransaction();
 		//foo.getComponent().setGlarch(null); //no id property!
 		s.replicate( foo, ReplicationMode.OVERWRITE );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Foo refoo = (Foo) s.get(Foo.class, id);
 		assertEquals( feekey, refoo.getDependent().getKey() );
 		s.delete(refoo);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testComplexCriteria() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		s.save(baz);
 		baz.setDefaults();
 		Map topGlarchez = new HashMap();
 		baz.setTopGlarchez(topGlarchez);
 		Glarch g1 = new Glarch();
 		g1.setName("g1");
 		s.save(g1);
 		Glarch g2 = new Glarch();
 		g2.setName("g2");
 		s.save(g2);
 		g1.setProxyArray( new GlarchProxy[] {g2} );
 		topGlarchez.put( new Character('1'),g1 );
 		topGlarchez.put( new Character('2'), g2);
 		Foo foo1 = new Foo();
 		Foo foo2 = new Foo();
 		s.save(foo1);
 		s.save(foo2);
 		baz.getFooSet().add(foo1);
 		baz.getFooSet().add(foo2);
 		baz.setFooArray( new FooProxy[] { foo1 } );
 
 		LockMode lockMode = supportsLockingNullableSideOfJoin( getDialect() ) ? LockMode.UPGRADE : LockMode.READ;
 
 		Criteria crit = s.createCriteria(Baz.class);
 		crit.createCriteria("topGlarchez")
 			.add( Restrictions.isNotNull("name") )
 			.createCriteria("proxyArray")
 				.add( Restrictions.eqProperty("name", "name") )
 				.add( Restrictions.eq("name", "g2") )
 				.add( Restrictions.gt("x", new Integer(-666) ) );
 		crit.createCriteria("fooSet")
 			.add( Restrictions.isNull("null") )
 			.add( Restrictions.eq("string", "a string") )
 			.add( Restrictions.lt("integer", new Integer(-665) ) );
 		crit.createCriteria("fooArray")
 				// this is the bit causing the problems; creating the criteria on fooArray does not add it to FROM,
 				// and so restriction below leads to an invalid reference.
 			.add( Restrictions.eq("string", "a string") )
 			.setLockMode(lockMode);
 
 		List list = crit.list();
 		assertTrue( list.size()==2 );
 		
 		s.createCriteria(Glarch.class).setLockMode(LockMode.UPGRADE).list();
 		s.createCriteria(Glarch.class).setLockMode(Criteria.ROOT_ALIAS, LockMode.UPGRADE).list();
 		
 		g2.setName(null);
 		t.commit();
 		s.close();
 		
 		s = openSession();
 		t = s.beginTransaction();
 		
 		list = s.createCriteria(Baz.class).add( Restrictions.isEmpty("fooSet") ).list();
 		assertEquals( list.size(), 0 );
 
 		list = s.createCriteria(Baz.class).add( Restrictions.isNotEmpty("fooSet") ).list();
 		assertEquals( new HashSet(list).size(), 1 );
 
 		list = s.createCriteria(Baz.class).add( Restrictions.sizeEq("fooSet", 2) ).list();
 		assertEquals( new HashSet(list).size(), 1 );
 		
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 
 		crit = s.createCriteria(Baz.class)
 			.setLockMode(lockMode);
 		crit.createCriteria("topGlarchez")
 			.add( Restrictions.gt( "x", new Integer(-666) ) );
 		crit.createCriteria("fooSet")
 			.add( Restrictions.isNull("null") );
 		list = crit.list();
 
 		assertTrue( list.size()==4 );
 		baz = (Baz) crit.uniqueResult();
 		assertTrue( Hibernate.isInitialized(baz.getTopGlarchez()) ); //cos it is nonlazy
 		assertTrue( !Hibernate.isInitialized(baz.getFooSet()) );
 
 		list = s.createCriteria(Baz.class)
 			.createCriteria("fooSet")
 				.createCriteria("foo")
 					.createCriteria("component.glarch")
 						.add( Restrictions.eq("name", "xxx") )
 			.list();
 		assertTrue( list.size()==0 );
 
 		list = s.createCriteria(Baz.class)
 			.createAlias("fooSet", "foo")
 			.createAlias("foo.foo", "foo2")
 			.setLockMode("foo2", lockMode)
 			.add( Restrictions.isNull("foo2.component.glarch") )
 			.createCriteria("foo2.component.glarch")
 				.add( Restrictions.eq("name", "xxx") )
 			.list();
 		assertTrue( list.size()==0 );
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 
 		crit = s.createCriteria(Baz.class);
 		crit.createCriteria("topGlarchez")
 			.add( Restrictions.isNotNull("name") );
 		crit.createCriteria("fooSet")
 			.add( Restrictions.isNull("null") );
 
 		list = crit.list();
 		assertTrue( list.size()==2 );
 		baz = (Baz) crit.uniqueResult();
 		assertTrue( Hibernate.isInitialized(baz.getTopGlarchez()) ); //cos it is nonlazy
 		assertTrue( !Hibernate.isInitialized(baz.getFooSet()) );
 		
 		s.createCriteria(Child.class).setFetchMode("parent", FetchMode.JOIN).list();
 
 		doDelete( s, "from Glarch g" );
 		s.delete( s.get(Foo.class, foo1.getKey() ) );
 		s.delete( s.get(Foo.class, foo2.getKey() ) );
 		s.delete(baz);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testArrayHQL() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		s.save(baz);
 		Foo foo1 = new Foo();
 		s.save(foo1);
 		baz.setFooArray( new FooProxy[] { foo1 } );
 
 		s.flush();
 		s.clear();
 
 		baz = ( Baz ) s.createQuery("from Baz b left join fetch b.fooArray").uniqueResult();
 		assertEquals( 1, baz.getFooArray().length );
 
 		t.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testArrayCriteria() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		s.save(baz);
 		Foo foo1 = new Foo();
 		s.save(foo1);
 		baz.setFooArray( new FooProxy[] { foo1 } );
 
 		s.flush();
 		s.clear();
 
 		baz = ( Baz ) s.createCriteria(Baz.class).createCriteria( "fooArray" ).uniqueResult();
 		assertEquals( 1, baz.getFooArray().length );
 
 		t.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testLazyManyToOneHQL() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		s.save(baz);
 		Foo foo1 = new Foo();
 		s.save(foo1);
 		baz.setFoo( foo1 );
 
 		s.flush();
 		s.clear();
 
 		baz = ( Baz ) s.createQuery("from Baz b").uniqueResult();
 		assertFalse( Hibernate.isInitialized( baz.getFoo() ) );
 		assertTrue( baz.getFoo() instanceof HibernateProxy );
 
 		t.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testLazyManyToOneCriteria() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		s.save(baz);
 		Foo foo1 = new Foo();
 		s.save(foo1);
 		baz.setFoo( foo1 );
 
 		s.flush();
 		s.clear();
 
 		baz = ( Baz ) s.createCriteria( Baz.class ).uniqueResult();
 		assertTrue( Hibernate.isInitialized( baz.getFoo() ) );
 		assertFalse( baz.getFoo() instanceof HibernateProxy );
 
 		t.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testLazyManyToOneGet() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		s.save(baz);
 		Foo foo1 = new Foo();
 		s.save(foo1);
 		baz.setFoo( foo1 );
 
 		s.flush();
 		s.clear();
 
 		baz = ( Baz ) s.get( Baz.class, baz.getCode() );
 		assertTrue( Hibernate.isInitialized( baz.getFoo() ) );
 		assertFalse( baz.getFoo() instanceof HibernateProxy );
 
 		t.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testClassWhere() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setParts( new ArrayList() );
 		Part p1 = new Part();
 		p1.setDescription("xyz");
 		Part p2 = new Part();
 		p2.setDescription("abc");
 		baz.getParts().add(p1);
 		baz.getParts().add(p2);
 		s.save(baz);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		assertTrue( s.createCriteria(Part.class).list().size()==1 ); //there is a where condition on Part mapping
 		assertTrue( s.createCriteria(Part.class).add( Restrictions.eq( "id", p1.getId() ) ).list().size()==1 );
 		assertTrue( s.createQuery("from Part").list().size()==1 );
 		assertTrue( s.createQuery("from Baz baz join baz.parts").list().size()==2 );
 		baz = (Baz) s.createCriteria(Baz.class).uniqueResult();
 		assertTrue( s.createFilter( baz.getParts(), "" ).list().size()==2 );
 		//assertTrue( baz.getParts().size()==1 );
 		s.delete( s.get( Part.class, p1.getId() ));
 		s.delete( s.get( Part.class, p2.getId() ));
 		s.delete(baz);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testClassWhereManyToMany() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setMoreParts( new ArrayList() );
 		Part p1 = new Part();
 		p1.setDescription("xyz");
 		Part p2 = new Part();
 		p2.setDescription("abc");
 		baz.getMoreParts().add(p1);
 		baz.getMoreParts().add(p2);
 		s.save(baz);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		assertTrue( s.createCriteria(Part.class).list().size()==1 ); //there is a where condition on Part mapping
 		assertTrue( s.createCriteria(Part.class).add( Restrictions.eq( "id", p1.getId() ) ).list().size()==1 );
 		assertTrue( s.createQuery("from Part").list().size()==1 );
 		assertTrue( s.createQuery("from Baz baz join baz.moreParts").list().size()==2 );
 		baz = (Baz) s.createCriteria(Baz.class).uniqueResult();
 		assertTrue( s.createFilter( baz.getMoreParts(), "" ).list().size()==2 );
 		//assertTrue( baz.getParts().size()==1 );
 		s.delete( s.get( Part.class, p1.getId() ));
 		s.delete( s.get( Part.class, p2.getId() ));
 		s.delete(baz);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionQuery() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Simple s1 = new Simple( Long.valueOf(1) );
 		s1.setName("s");
 		s1.setCount(0);
 		Simple s2 = new Simple( Long.valueOf(2) );
 		s2.setCount(2);
 		Simple s3 = new Simple( Long.valueOf(3) );
 		s3.setCount(3);
 		s.save( s1 );
 		s.save( s2 );
 		s.save( s3 );
 		Container c = new Container();
 		Contained cd = new Contained();
 		List bag = new ArrayList();
 		bag.add(cd);
 		c.setBag(bag);
 		List l = new ArrayList();
 		l.add(s1);
 		l.add(s3);
 		l.add(s2);
 		c.setOneToMany(l);
 		l = new ArrayList();
 		l.add(s1);
 		l.add(null);
 		l.add(s2);
 		c.setManyToMany(l);
 		s.save(c);
 		Container cx = new Container();
 		s.save(cx);
 		Simple sx = new Simple( Long.valueOf(5) );
 		sx.setCount(5);
 		sx.setName("s");
 		s.save( sx );
 		assertTrue(
 				s.createQuery( "select c from ContainerX c, Simple s where c.oneToMany[2] = s" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c, Simple s where c.manyToMany[2] = s" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c, Simple s where s = c.oneToMany[2]" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c, Simple s where s = c.manyToMany[2]" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c where c.oneToMany[0].name = 's'" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c where c.manyToMany[0].name = 's'" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c where 's' = c.oneToMany[2 - 2].name" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c where 's' = c.manyToMany[(3+1)/4-1].name" ).list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c where c.oneToMany[ c.manyToMany[0].count ].name = 's'" )
 						.list()
 						.size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select c from ContainerX c where c.manyToMany[ c.oneToMany[0].count ].name = 's'" )
 						.list()
 						.size() == 1
 		);
 		if ( ! ( getDialect() instanceof MySQLDialect ) && !(getDialect() instanceof org.hibernate.dialect.TimesTenDialect) ) {
 			assertTrue(
 					s.createQuery( "select c from ContainerX c where c.manyToMany[ maxindex(c.manyToMany) ].count = 2" )
 							.list()
 							.size() == 1
 			);
 		}
 		assertTrue( s.contains(cd) );
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof HSQLDialect) )  {
 			s.createFilter( c.getBag(), "where 0 in elements(this.bag)" ).list();
 			s.createFilter( c.getBag(), "where 0 in elements(this.lazyBag)" ).list();
 		}
 		s.createQuery( "select count(comp.name) from ContainerX c join c.components comp" ).list();
 		s.delete(cd);
 		s.delete(c);
 		s.delete(s1);
 		s.delete(s2);
 		s.delete(s3);
 		s.delete(cx);
 		s.delete(sx);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testParentChild() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Parent p = new Parent();
 		Child c = new Child();
 		c.setParent(p);
 		p.setChild(c);
 		s.save(p);
 		s.save(c);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Child) s.load( Child.class, new Long( c.getId() ) );
 		p = c.getParent();
 		assertTrue( "1-1 parent", p!=null );
 		c.setCount(32);
 		p.setCount(66);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Child) s.load( Child.class, new Long( c.getId() ) );
 		p = c.getParent();
 		assertTrue( "1-1 update", p.getCount()==66 );
 		assertTrue( "1-1 update", c.getCount()==32 );
 		assertTrue(
 			"1-1 query",
 				s.createQuery( "from Child c where c.parent.count=66" ).list().size()==1
 		);
 		assertTrue(
 			"1-1 query",
 			( (Object[]) s.createQuery( "from Parent p join p.child c where p.count=66" ).list().get(0) ).length==2
 		);
 		s.createQuery( "select c, c.parent from Child c order by c.parent.count" ).list();
 		s.createQuery( "select c, c.parent from Child c where c.parent.count=66 order by c.parent.count" ).list();
 		s.createQuery( "select c, c.parent, c.parent.count from Child c order by c.parent.count" ).iterate();
 		List result = s.createQuery( "FROM Parent AS p WHERE p.count = ?" )
 				.setParameter( 0, new Integer(66), StandardBasicTypes.INTEGER )
 				.list();
 		assertEquals( "1-1 query", 1, result.size() );
 		s.delete(c); s.delete(p);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testParentNullChild() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Parent p = new Parent();
 		s.save(p);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = (Parent) s.load( Parent.class, new Long( p.getId() ) );
 		assertTrue( p.getChild()==null );
 		p.setCount(66);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		p = (Parent) s.load( Parent.class, new Long( p.getId() ) );
 		assertTrue( "null 1-1 update", p.getCount()==66 );
 		assertTrue( p.getChild()==null );
 		s.delete(p);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testManyToMany() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Container c = new Container();
 		c.setManyToMany( new ArrayList() );
 		c.setBag( new ArrayList() );
 		Simple s1 = new Simple( Long.valueOf(12) );
 		Simple s2 = new Simple( Long.valueOf(-1) );
 		s1.setCount(123); s2.setCount(654);
 		Contained c1 = new Contained();
 		c1.setBag( new ArrayList() );
 		c1.getBag().add(c);
 		c.getBag().add(c1);
 		c.getManyToMany().add(s1);
 		c.getManyToMany().add(s2);
 		Serializable cid = s.save(c);
 		s.save( s1 );
 		s.save( s2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.load(Container.class, cid);
 		assertTrue( c.getBag().size()==1 );
 		assertTrue( c.getManyToMany().size()==2 );
 		c1 = (Contained) c.getBag().iterator().next();
 		assertTrue( c.getBag().size()==1 );
 		c.getBag().remove(c1);
 		c1.getBag().remove(c);
 		assertTrue( c.getManyToMany().remove(0)!=null );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.load(Container.class, cid);
 		assertTrue( c.getBag().size()==0 );
 		assertTrue( c.getManyToMany().size()==1 );
 		c1 = (Contained) s.load( Contained.class, new Long(c1.getId()) );
 		assertTrue( c1.getBag().size()==0 );
 		assertEquals( 1, doDelete( s, "from ContainerX c" ) );
 		assertEquals( 1, doDelete( s, "from Contained" ) );
 		assertEquals( 2, doDelete( s, "from Simple" ) );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testContainer() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Container c = new Container();
 		Simple x = new Simple( Long.valueOf(1) );
 		x.setCount(123);
 		Simple y = new Simple( Long.valueOf(0) );
 		y.setCount(456);
 		s.save( x );
 		s.save( y );
 		List o2m = new ArrayList();
 		o2m.add(x); o2m.add(null); o2m.add(y);
 		List m2m = new ArrayList();
 		m2m.add(x); m2m.add(null); m2m.add(y);
 		c.setOneToMany(o2m); c.setManyToMany(m2m);
 		List comps = new ArrayList();
 		Container.ContainerInnerClass ccic = new Container.ContainerInnerClass();
 		ccic.setName("foo");
 		ccic.setSimple(x);
 		comps.add(ccic);
 		comps.add(null);
 		ccic = new Container.ContainerInnerClass();
 		ccic.setName("bar");
 		ccic.setSimple(y);
 		comps.add(ccic);
 		HashSet compos = new HashSet();
 		compos.add(ccic);
 		c.setComposites(compos);
 		c.setComponents(comps);
 		One one = new One();
 		Many many = new Many();
 		HashSet manies = new HashSet();
 		manies.add(many);
 		one.setManies(manies);
 		many.setOne(one);
 		ccic.setMany(many);
 		ccic.setOne(one);
 		s.save(one);
 		s.save(many);
 		s.save(c);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Long count = (Long) s.createQuery("select count(*) from ContainerX as c join c.components as ce join ce.simple as s where ce.name='foo'").uniqueResult();
 		assertTrue( count.intValue()==1 );
 		List res = s.createQuery(
 				"select c, s from ContainerX as c join c.components as ce join ce.simple as s where ce.name='foo'"
 		).list();
 		assertTrue(res.size()==1);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.load( Container.class, new Long( c.getId() ) );
 		System.out.println( c.getOneToMany() );
 		System.out.println( c.getManyToMany() );
 		System.out.println( c.getComponents() );
 		System.out.println( c.getComposites() );
 		ccic = (Container.ContainerInnerClass) c.getComponents().get(2);
 		assertTrue( ccic.getMany().getOne()==ccic.getOne() );
 		assertTrue( c.getComponents().size()==3 );
 		assertTrue( c.getComposites().size()==1 );
 		assertTrue( c.getOneToMany().size()==3 );
 		assertTrue( c.getManyToMany().size()==3 );
 		assertTrue( c.getOneToMany().get(0)!=null );
 		assertTrue( c.getOneToMany().get(2)!=null );
 		for ( int i=0; i<3; i++ ) {
 			assertTrue( c.getManyToMany().get(i) == c.getOneToMany().get(i) );
 		}
 		Object o1 = c.getOneToMany().get(0);
 		Object o2 = c.getOneToMany().remove(2);
 		c.getOneToMany().set(0, o2);
 		c.getOneToMany().set(1, o1);
 		o1 = c.getComponents().remove(2);
 		c.getComponents().set(0, o1);
 		c.getManyToMany().set( 0, c.getManyToMany().get(2) );
 		Container.ContainerInnerClass ccic2 = new Container.ContainerInnerClass();
 		ccic2.setName("foo");
 		ccic2.setOne(one);
 		ccic2.setMany(many);
 		ccic2.setSimple( (Simple) s.load(Simple.class, new Long(0) ) );
 		c.getComposites().add(ccic2);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.load( Container.class, new Long( c.getId() ) );
 		System.out.println( c.getOneToMany() );
 		System.out.println( c.getManyToMany() );
 		System.out.println( c.getComponents() );
 		System.out.println( c.getComposites() );
 		assertTrue( c.getComponents().size()==1 ); //WAS: 2
 		assertTrue( c.getComposites().size()==2 );
 		assertTrue( c.getOneToMany().size()==2 );
 		assertTrue( c.getManyToMany().size()==3 );
 		assertTrue( c.getOneToMany().get(0)!=null );
 		assertTrue( c.getOneToMany().get(1)!=null );
 		( (Container.ContainerInnerClass) c.getComponents().get(0) ).setName("a different name");
 		( (Container.ContainerInnerClass) c.getComposites().iterator().next() ).setName("once again");
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.load( Container.class, new Long( c.getId() ) );
 		System.out.println( c.getOneToMany() );
 		System.out.println( c.getManyToMany() );
 		System.out.println( c.getComponents() );
 		System.out.println( c.getComposites() );
 		assertTrue( c.getComponents().size()==1 ); //WAS: 2
 		assertTrue( c.getComposites().size()==2 );
 		assertTrue( ( (Container.ContainerInnerClass) c.getComponents().get(0) ).getName().equals("a different name") );
 		Iterator iter = c.getComposites().iterator();
 		boolean found = false;
 		while ( iter.hasNext() ) {
 			if ( ( (Container.ContainerInnerClass) iter.next() ).getName().equals("once again") ) found = true;
 		}
 		assertTrue(found);
 		c.getOneToMany().clear();
 		c.getManyToMany().clear();
 		c.getComposites().clear();
 		c.getComponents().clear();
 		doDelete( s, "from Simple" );
 		doDelete( s, "from Many" );
 		doDelete( s, "from One" );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.load( Container.class, new Long( c.getId() ) );
 		assertTrue( c.getComponents().size()==0 );
 		assertTrue( c.getComposites().size()==0 );
 		assertTrue( c.getOneToMany().size()==0 );
 		assertTrue( c.getManyToMany().size()==0 );
 		s.delete(c);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCascadeCompositeElements() throws Exception {
 		Container c = new Container();
 		List list = new ArrayList();
 		c.setCascades(list);
 		Container.ContainerInnerClass cic = new Container.ContainerInnerClass();
 		cic.setMany( new Many() );
 		cic.setOne( new One() );
 		list.add(cic);
 		Session s = openSession();
 		s.beginTransaction();
 		s.save(c);
 		s.getTransaction().commit();
 		s.close();
 		
 		s=openSession();
 		s.beginTransaction();
 		c = (Container) s.createQuery( "from ContainerX c" ).iterate().next();
 		cic = (Container.ContainerInnerClass) c.getCascades().iterator().next();
 		assertTrue( cic.getMany()!=null && cic.getOne()!=null );
 		assertTrue( c.getCascades().size()==1 );
 		s.delete(c);
 		s.getTransaction().commit();
 		s.close();
 
 		c = new Container();
 		s = openSession();
 		s.beginTransaction();
 		s.save(c);
 		list = new ArrayList();
 		c.setCascades(list);
 		cic = new Container.ContainerInnerClass();
 		cic.setMany( new Many() );
 		cic.setOne( new One() );
 		list.add(cic);
 		s.getTransaction().commit();
 		s.close();
 		
 		s=openSession();
 		s.beginTransaction();
 		c = (Container) s.createQuery( "from ContainerX c" ).iterate().next();
 		cic = (Container.ContainerInnerClass) c.getCascades().iterator().next();
 		assertTrue( cic.getMany()!=null && cic.getOne()!=null );
 		assertTrue( c.getCascades().size()==1 );
 		s.delete(c);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testBag() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Container c = new Container();
 		Contained c1 = new Contained();
 		Contained c2 = new Contained();
 		c.setBag( new ArrayList() );
 		c.getBag().add(c1);
 		c.getBag().add(c2);
 		c1.getBag().add(c);
 		c2.getBag().add(c);
 		s.save(c);
 		c.getBag().add(c2);
 		c2.getBag().add(c);
 		c.getLazyBag().add(c1);
 		c1.getLazyBag().add(c);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.createQuery( "from ContainerX c" ).list().get(0);
 		c.getLazyBag().size();
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.createQuery( "from ContainerX c" ).list().get(0);
 		Contained c3 = new Contained();
 		//c.getBag().add(c3);
 		//c3.getBag().add(c);
 		c.getLazyBag().add(c3);
 		c3.getLazyBag().add(c);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.createQuery( "from ContainerX c" ).list().get(0);
 		Contained c4 = new Contained();
 		c.getLazyBag().add(c4);
 		c4.getLazyBag().add(c);
 		assertTrue( c.getLazyBag().size()==3 ); //forces initialization
 		//s.save(c4);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		c = (Container) s.createQuery( "from ContainerX c" ).list().get(0);
 		Iterator i = c.getBag().iterator();
 		int j=0;
 		while ( i.hasNext() ) {
 			assertTrue( i.next()!=null );
 			j++;
 		}
 		assertTrue(j==3);
 		assertTrue( c.getLazyBag().size()==3 );
 		s.delete(c);
 		c.getBag().remove(c2);
 		Iterator iter = c.getBag().iterator();
 		j=0;
 		while ( iter.hasNext() ) {
 			j++;
 			s.delete( iter.next() );
 		}
 		assertTrue(j==2);
 		s.delete( s.load(Contained.class, new Long( c4.getId() ) ) );
 		s.delete( s.load(Contained.class, new Long( c3.getId() ) ) );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCircularCascade() throws Exception {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Circular c = new Circular();
 		c.setClazz(Circular.class);
 		c.setOther( new Circular() );
 		c.getOther().setOther( new Circular() );
 		c.getOther().getOther().setOther(c);
 		c.setAnyEntity( c.getOther() );
 		String id = (String) s.save(c);
 		tx.commit();
 		s.close();
 		s = openSession();
 		tx = s.beginTransaction();
 		c = (Circular) s.load(Circular.class, id);
 		c.getOther().getOther().setClazz(Foo.class);
 		tx.commit();
 		s.close();
 		c.getOther().setClazz(Qux.class);
 		s = openSession();
 		tx = s.beginTransaction();
 		s.saveOrUpdate(c);
 		tx.commit();
 		s.close();
 		c.getOther().getOther().setClazz(Bar.class);
 		s = openSession();
 		tx = s.beginTransaction();
 		s.saveOrUpdate(c);
 		tx.commit();
 		s.close();
 		s = openSession();
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLFunctionsTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLFunctionsTest.java
index ace0447683..6956140ef3 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLFunctionsTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/SQLFunctionsTest.java
@@ -1,701 +1,700 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
 
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 import org.junit.Test;
 
 import org.hibernate.Query;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.dialect.DB2Dialect;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.InterbaseDialect;
 import org.hibernate.dialect.MckoiDialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.Oracle9iDialect;
 import org.hibernate.dialect.SQLServerDialect;
 import org.hibernate.dialect.Sybase11Dialect;
 import org.hibernate.dialect.SybaseASE15Dialect;
 import org.hibernate.dialect.SybaseAnywhereDialect;
 import org.hibernate.dialect.SybaseDialect;
 import org.hibernate.dialect.TimesTenDialect;
 import org.hibernate.dialect.function.SQLFunction;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 
-@SuppressWarnings( {"UnnecessaryUnboxing", "UnnecessaryBoxing"})
 public class SQLFunctionsTest extends LegacyTestCase {
 	private static final Logger log = Logger.getLogger( SQLFunctionsTest.class );
 
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 			"legacy/AltSimple.hbm.xml",
 			"legacy/Broken.hbm.xml",
 			"legacy/Blobber.hbm.xml"
 		};
 	}
 
 	@Test
 	public void testDialectSQLFunctions() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Iterator iter = s.createQuery( "select max(s.count) from Simple s" ).iterate();
 
 		if ( getDialect() instanceof MySQLDialect ) assertTrue( iter.hasNext() && iter.next()==null );
 
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple Dialect Function Test");
 		simple.setAddress("Simple Address");
 		simple.setPay( Float.valueOf(45.8f) );
 		simple.setCount(2);
 		s.save( simple );
 
 		// Test to make sure allocating an specified object operates correctly.
 		assertTrue(
 				s.createQuery( "select new org.hibernate.test.legacy.S(s.count, s.address) from Simple s" ).list().size() == 1
 		);
 
 		// Quick check the base dialect functions operate correctly
 		assertTrue(
 				s.createQuery( "select max(s.count) from Simple s" ).list().size() == 1
 		);
 		assertTrue(
 				s.createQuery( "select count(*) from Simple s" ).list().size() == 1
 		);
 
 		if ( getDialect() instanceof Oracle9iDialect ) {
 			// Check Oracle Dialect mix of dialect functions - no args (no parenthesis and single arg functions
 			List rset = s.createQuery( "select s.name, sysdate, trunc(s.pay), round(s.pay) from Simple s" ).list();
 			assertNotNull("Name string should have been returned",(((Object[])rset.get(0))[0]));
 			assertNotNull("Todays Date should have been returned",(((Object[])rset.get(0))[1]));
 			assertEquals("trunc(45.8) result was incorrect ", Float.valueOf(45), ( (Object[]) rset.get(0) )[2] );
 			assertEquals("round(45.8) result was incorrect ", Float.valueOf(46), ( (Object[]) rset.get(0) )[3] );
 
 			simple.setPay(new Float(-45.8));
 			s.update(simple);
 
 			// Test type conversions while using nested functions (Float to Int).
 			rset = s.createQuery( "select abs(round(s.pay)) from Simple s" ).list();
 			assertEquals("abs(round(-45.8)) result was incorrect ", Float.valueOf( 46 ), rset.get(0));
 
 			// Test a larger depth 3 function example - Not a useful combo other than for testing
 			assertTrue(
 					s.createQuery( "select trunc(round(sysdate)) from Simple s" ).list().size() == 1
 			);
 
 			// Test the oracle standard NVL funtion as a test of multi-param functions...
 			simple.setPay(null);
 			s.update(simple);
 			Integer value = (Integer) s.createQuery(
 					"select MOD( NVL(s.pay, 5000), 2 ) from Simple as s where s.id = 10"
 			).list()
 					.get(0);
 			assertTrue( 0 == value.intValue() );
 		}
 
 		if ( (getDialect() instanceof HSQLDialect) ) {
 			// Test the hsql standard MOD funtion as a test of multi-param functions...
 			Integer value = (Integer) s.createQuery( "select MOD(s.count, 2) from Simple as s where s.id = 10" )
 					.list()
 					.get(0);
 			assertTrue( 0 == value.intValue() );
 		}
 
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSetProperties() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		Query q = s.createQuery("from Simple s where s.name=:name and s.count=:count");
 		q.setProperties(simple);
 		assertTrue( q.list().get(0)==simple );
 		//misuse of "Single" as a propertyobject, but it was the first testclass i found with a collection ;)
 		Single single = new Single() { // trivial hack to test properties with arrays.
 			String[] getStuff() { return (String[]) getSeveral().toArray(new String[getSeveral().size()]); }
 		};
 
 		List l = new ArrayList();
 		l.add("Simple 1");
 		l.add("Slimeball");
 		single.setSeveral(l);
 		q = s.createQuery("from Simple s where s.name in (:several)");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 
 		q = s.createQuery("from Simple s where s.name in :several");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 
 		q = s.createQuery("from Simple s where s.name in (:stuff)");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 
 		q = s.createQuery("from Simple s where s.name in :stuff");
 		q.setProperties(single);
 		assertTrue( q.list().get(0)==simple );
 
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSetPropertiesMap() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		Map parameters = new HashMap();
 		parameters.put("name", simple.getName());
 		parameters.put("count", new Integer(simple.getCount()));
 
 		Query q = s.createQuery("from Simple s where s.name=:name and s.count=:count");
 		q.setProperties((parameters));
 		assertTrue( q.list().get(0)==simple );
 
 		List l = new ArrayList();
 		l.add("Simple 1");
 		l.add("Slimeball");
 		parameters.put("several", l);
 		q = s.createQuery("from Simple s where s.name in (:several)");
 		q.setProperties(parameters);
 		assertTrue( q.list().get(0)==simple );
 
 
 		parameters.put("stuff", l.toArray(new String[0]));
 		q = s.createQuery("from Simple s where s.name in (:stuff)");
 		q.setProperties(parameters);
 		assertTrue( q.list().get(0)==simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testBroken() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Broken b = new Fixed();
 		b.setId( new Long(123));
 		b.setOtherId("foobar");
 		s.save(b);
 		s.flush();
 		b.setTimestamp( new Date() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update(b);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		b = (Broken) s.load( Broken.class, b );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete(b);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testNothinToUpdate() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCachedQuery() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName( "Simple 1" );
 		Long id = (Long) s.save( simple );
 		assertEquals( Long.valueOf( 10 ), id );
 		assertEquals( Long.valueOf( 10 ), simple.getId() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setCacheable(true);
 		q.setString("name", "Simple 1");
 		assertTrue( q.list().size()==1 );
 		simple = (Simple) q.list().get(0);
 
 		q.setString("name", "Simple 2");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		simple.setName("Simple 2");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setString("name", "Simple 2");
 		q.setCacheable(true);
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCachedQueryRegion() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name=:name");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString("name", "Simple 1");
 		assertTrue( q.list().size()==1 );
 		simple = (Simple) q.list().get(0);
 
 		q.setString("name", "Simple 2");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		simple.setName("Simple 2");
 		assertTrue( q.list().size()==1 );
 		assertTrue( q.list().size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.update( simple );
 		s.delete(simple);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s where s.name=?");
 		q.setCacheRegion("foo");
 		q.setCacheable(true);
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==0 );
 		assertTrue( q.list().size()==0 );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testSQLFunctions() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 
 		if ( getDialect() instanceof DB2Dialect) {
 			s.createQuery( "from Simple s where repeat('foo', 3) = 'foofoofoo'" ).list();
 			s.createQuery( "from Simple s where repeat(s.name, 3) = 'foofoofoo'" ).list();
 			s.createQuery( "from Simple s where repeat( lower(s.name), 3 + (1-1) / 2) = 'foofoofoo'" ).list();
 		}
 
 		assertTrue(
 				s.createQuery( "from Simple s where upper( s.name ) ='SIMPLE 1'" ).list().size()==1
 		);
 		if ( !(getDialect() instanceof HSQLDialect) ) {
 			assertTrue(
 					s.createQuery(
 							"from Simple s where not( upper( s.name ) ='yada' or 1=2 or 'foo'='bar' or not('foo'='foo') or 'foo' like 'bar' )"
 					).list()
 							.size()==1
 			);
 		}
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof SybaseDialect) && !(getDialect() instanceof SQLServerDialect) && !(getDialect() instanceof MckoiDialect) && !(getDialect() instanceof InterbaseDialect) && !(getDialect() instanceof TimesTenDialect) ) { //My SQL has a funny concatenation operator
 			assertTrue(
 					s.createQuery( "from Simple s where lower( s.name || ' foo' ) ='simple 1 foo'" ).list().size()==1
 			);
 		}
 		if ( (getDialect() instanceof SybaseDialect) ) {
 			assertTrue(
 					s.createQuery( "from Simple s where lower( s.name + ' foo' ) ='simple 1 foo'" ).list().size()==1
 			);
 		}
 		if ( (getDialect() instanceof MckoiDialect) || (getDialect() instanceof TimesTenDialect)) {
 			assertTrue(
 					s.createQuery( "from Simple s where lower( concat(s.name, ' foo') ) ='simple 1 foo'" ).list().size()==1
 			);
 		}
 
 		Simple other = new Simple( Long.valueOf(20) );
 		other.setName("Simple 2");
 		other.setCount(12);
 		simple.setOther(other);
 		s.save( other );
 		//s.find("from Simple s where s.name ## 'cat|rat|bag'");
 		assertTrue(
 				s.createQuery( "from Simple s where upper( s.other.name ) ='SIMPLE 2'" ).list().size()==1
 		);
 		assertTrue(
 				s.createQuery( "from Simple s where not ( upper( s.other.name ) ='SIMPLE 2' )" ).list().size()==0
 		);
 		assertTrue(
 				s.createQuery(
 						"select distinct s from Simple s where ( ( s.other.count + 3 ) = (15*2)/2 and s.count = 69) or ( ( s.other.count + 2 ) / 7 ) = 2"
 				).list()
 						.size()==1
 		);
 		assertTrue(
 				s.createQuery(
 						"select s from Simple s where ( ( s.other.count + 3 ) = (15*2)/2 and s.count = 69) or ( ( s.other.count + 2 ) / 7 ) = 2 order by s.other.count"
 				).list()
 						.size()==1
 		);
 		Simple min = new Simple( Long.valueOf(30) );
 		min.setCount(-1);
 		s.save( min );
 		if ( ! (getDialect() instanceof MySQLDialect) && ! (getDialect() instanceof HSQLDialect) ) { //My SQL has no subqueries
 			assertTrue(
 					s.createQuery( "from Simple s where s.count > ( select min(sim.count) from Simple sim )" )
 							.list()
 							.size()==2
 			);
 			t.commit();
 			t = s.beginTransaction();
 			assertTrue(
 					s.createQuery(
 							"from Simple s where s = some( select sim from Simple sim where sim.count>=0 ) and s.count >= 0"
 					).list()
 							.size()==2
 			);
 			assertTrue(
 					s.createQuery(
 							"from Simple s where s = some( select sim from Simple sim where sim.other.count=s.other.count ) and s.other.count > 0"
 					).list()
 							.size()==1
 			);
 		}
 
 		Iterator iter = s.createQuery( "select sum(s.count) from Simple s group by s.count having sum(s.count) > 10" )
 				.iterate();
 		assertTrue( iter.hasNext() );
 		assertEquals( Long.valueOf(12), iter.next() );
 		assertTrue( !iter.hasNext() );
 		if ( ! (getDialect() instanceof MySQLDialect) ) {
 			iter = s.createQuery( "select s.count from Simple s group by s.count having s.count = 12" ).iterate();
 			assertTrue( iter.hasNext() );
 		}
 
 		s.createQuery(
 				"select s.id, s.count, count(t), max(t.date) from Simple s, Simple t where s.count = t.count group by s.id, s.count order by s.count"
 		).iterate();
 
 		Query q = s.createQuery("from Simple s");
 		q.setMaxResults(10);
 		assertTrue( q.list().size()==3 );
 		q = s.createQuery("from Simple s");
 		q.setMaxResults(1);
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s");
 		assertTrue( q.list().size()==3 );
 		q = s.createQuery("from Simple s where s.name = ?");
 		q.setString(0, "Simple 1");
 		assertTrue( q.list().size()==1 );
 		q = s.createQuery("from Simple s where s.name = ? and upper(s.name) = ?");
 		q.setString(1, "SIMPLE 1");
 		q.setString(0, "Simple 1");
 		q.setFirstResult(0);
 		assertTrue( q.iterate().hasNext() );
 		q = s.createQuery("from Simple s where s.name = :foo and upper(s.name) = :bar or s.count=:count or s.count=:count + 1");
 		q.setParameter("bar", "SIMPLE 1");
 		q.setString("foo", "Simple 1");
 		q.setInteger("count", 69);
 		q.setFirstResult(0);
 		assertTrue( q.iterate().hasNext() );
 		q = s.createQuery("select s.id from Simple s");
 		q.setFirstResult(1);
 		q.setMaxResults(2);
 		iter = q.iterate();
 		int i=0;
 		while ( iter.hasNext() ) {
 			assertTrue( iter.next() instanceof Long );
 			i++;
 		}
 		assertTrue(i==2);
 		q = s.createQuery("select all s, s.other from Simple s where s = :s");
 		q.setParameter("s", simple);
 		assertTrue( q.list().size()==1 );
 
 
 		q = s.createQuery("from Simple s where s.name in (:name_list) and s.count > :count");
 		HashSet set = new HashSet();
 		set.add("Simple 1"); set.add("foo");
 		q.setParameterList( "name_list", set );
 		q.setParameter("count", Integer.valueOf( -1 ) );
 		assertTrue( q.list().size()==1 );
 
 		ScrollableResults sr = s.createQuery("from Simple s").scroll();
 		sr.next();
 		sr.get(0);
 		sr.close();
 
 		s.delete(other);
 		s.delete(simple);
 		s.delete(min);
 		t.commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testBlobClob() throws Exception {
 		// Sybase does not support ResultSet.getBlob(String)
 		if ( getDialect() instanceof SybaseDialect || getDialect() instanceof Sybase11Dialect || getDialect() instanceof SybaseASE15Dialect || getDialect() instanceof SybaseAnywhereDialect ) {
 			return;
 		}
 		Session s = openSession();
 		s.beginTransaction();
 		Blobber b = new Blobber();
 		b.setBlob( s.getLobHelper().createBlob( "foo/bar/baz".getBytes() ) );
 		b.setClob( s.getLobHelper().createClob("foo/bar/baz") );
 		s.save(b);
 		//s.refresh(b);
 		//assertTrue( b.getClob() instanceof ClobImpl );
 		s.flush();
 
 		s.refresh(b);
 		//b.getBlob().setBytes( 2, "abc".getBytes() );
 		b.getClob().getSubString(2, 3);
 		//b.getClob().setString(2, "abc");
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		Blobber b2 = new Blobber();
 		s.save(b2);
 		b2.setBlob( b.getBlob() );
 		b.setBlob(null);
 		//assertTrue( b.getClob().getSubString(1, 3).equals("fab") );
 		b.getClob().getSubString(1, 6);
 		//b.getClob().setString(1, "qwerty");
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		b.setClob( s.getLobHelper().createClob("xcvfxvc xcvbx cvbx cvbx cvbxcvbxcvbxcvb") );
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		b = (Blobber) s.load( Blobber.class, new Integer( b.getId() ) );
 		assertTrue( b.getClob().getSubString(1, 7).equals("xcvfxvc") );
 		//b.getClob().setString(5, "1234567890");
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSqlFunctionAsAlias() throws Exception {
 		String functionName = locateAppropriateDialectFunctionNameForAliasTest();
 		if (functionName == null) {
             log.info("Dialect does not list any no-arg functions");
 			return;
 		}
 
         log.info("Using function named [" + functionName + "] for 'function as alias' test");
 		String query = "select " + functionName + " from Simple as " + functionName + " where " + functionName + ".id = 10";
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List result = s.createQuery( query ).list();
 		assertTrue( result.size() == 1 );
 		assertTrue(result.get(0) instanceof Simple);
 		s.delete( result.get(0) );
 		t.commit();
 		s.close();
 	}
 
 	private String locateAppropriateDialectFunctionNameForAliasTest() {
 		for (Iterator itr = getDialect().getFunctions().entrySet().iterator(); itr.hasNext(); ) {
 			final Map.Entry entry = (Map.Entry) itr.next();
 			final SQLFunction function = (SQLFunction) entry.getValue();
 			if ( !function.hasArguments() && !function.hasParenthesesIfNoArguments() ) {
 				return (String) entry.getKey();
 			}
 		}
 		return null;
 	}
 
 	@Test
 	public void testCachedQueryOnInsert() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Simple simple = new Simple( Long.valueOf(10) );
 		simple.setName("Simple 1");
 		s.save( simple );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query q = s.createQuery("from Simple s");
 		List list = q.setCacheable(true).list();
 		assertTrue( list.size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==1 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Simple simple2 = new Simple( Long.valueOf(12) );
 		simple2.setCount(133);
 		s.save( simple2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==2 );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		q = s.createQuery("from Simple s");
 		list = q.setCacheable(true).list();
 		assertTrue( list.size()==2 );
 		Iterator i = list.iterator();
 		while ( i.hasNext() ) s.delete( i.next() );
 		t.commit();
 		s.close();
 
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/lob/ImageTest.java b/hibernate-core/src/test/java/org/hibernate/test/lob/ImageTest.java
index 9a6cfe16f0..6392575151 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/lob/ImageTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/lob/ImageTest.java
@@ -1,36 +1,36 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.lob;
 
 /**
  * Tests eager materialization and mutation of data mapped by
  * {@link org.hibernate.type.ImageType}.
  *
  * @author Gail Badner
  */
 public class ImageTest extends LongByteArrayTest {
 	public String[] getMappings() {
 		return new String[] { "lob/ImageMappings.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/lob/JpaLargeBlobTest.java b/hibernate-core/src/test/java/org/hibernate/test/lob/JpaLargeBlobTest.java
index 40e5f98942..92e592a0e3 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/lob/JpaLargeBlobTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/lob/JpaLargeBlobTest.java
@@ -1,113 +1,113 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2012 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.test.lob;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.sql.Blob;
 import java.util.Random;
 
 import org.hibernate.LobHelper;
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.testing.RequiresDialect;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.junit.Test;
 
 /**
  * @author Brett Meyer
  */
 @TestForIssue( jiraKey = "HHH-7698" )
 @RequiresDialect( value = H2Dialect.class, jiraKey = "HHH-7724" )
 public class JpaLargeBlobTest extends BaseCoreFunctionalTestCase {
     
     @Override
     protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] { LobEntity.class };
 	}
 
     @Override
     protected void configure(Configuration configuration) {
     	super.configure( configuration );
         configuration.setProperty(Environment.USE_STREAMS_FOR_BINARY, "true");
     }
 
     @Test
     public void jpaBlobStream() throws Exception {
         Session session = openSession();
         LobEntity o = new LobEntity();
 
         LobHelper lh = session.getLobHelper();
         LobInputStream lis = new LobInputStream();
 
         session.getTransaction().begin();
 
         Blob blob = lh.createBlob(lis, LobEntity.BLOB_LENGTH);
         o.setBlob(blob);
         
         // Regardless if NON_CONTEXTUAL_LOB_CREATION is set to true,
         // ContextualLobCreator should use a NonContextualLobCreator to create
         // a blob Proxy.  If that's the case, the InputStream will not be read
         // until it's persisted with the JDBC driver.
         // Although HHH-7698 was about high memory consumption, this is the best
         // way to test that the high memory use is being prevented.
         assertFalse( lis.wasRead() );
 
         session.persist(o);
         session.getTransaction().commit();
         
         assertTrue( lis.wasRead() );
         
         session.close();
 
         lis.close();
     }
     
     private class LobInputStream extends InputStream {
     	private boolean read = false;
     	private Long count = (long) 200 * 1024 * 1024;
 
         @Override
         public int read() throws IOException {
         	read = true;
             if (count > 0) {
                 count--;
                 return new Random().nextInt();
             }
             return -1;
         }
         
         @Override
         public int available() throws IOException {
         	return 1;
         }
         
         public boolean wasRead() {
         	return read;
         }
     }
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/lob/LobEntity.java b/hibernate-core/src/test/java/org/hibernate/test/lob/LobEntity.java
index e66a27c1fe..2f945f1cfd 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/lob/LobEntity.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/lob/LobEntity.java
@@ -1,60 +1,60 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2012 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.test.lob;
 
 import java.sql.Blob;
 
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.Lob;
 
 /**
  * @author Brett Meyer
  */
 @Entity
 public class LobEntity {
 	public static final int BLOB_LENGTH = 100000000;
     private Long id;
 
     @Id
     @GeneratedValue
     public Long getId() {
         return id;
     }
 
     public void setId(Long id) {
         this.id = id;
     }
 
     @Lob
     @Column(length = BLOB_LENGTH)
     private Blob blob;
 
     public Blob getBlob() {
         return blob;
     }
 
     public void setBlob(Blob blob) {
         this.blob = blob;
     }
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/lob/LongByteArrayHolder.java b/hibernate-core/src/test/java/org/hibernate/test/lob/LongByteArrayHolder.java
index 6e6749350a..f995468266 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/lob/LongByteArrayHolder.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/lob/LongByteArrayHolder.java
@@ -1,55 +1,55 @@
 //$Id: $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.lob;
 
 
 /**
  * An entity containing data that is materialized into a byte array immediately.
  * The hibernate type mapped for {@link #longByteArray} determines the SQL type
  * asctually used.
  * 
  * @author Gail Badner
  */
 public class LongByteArrayHolder {
 	private Long id;
 	private byte[] longByteArray;
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public byte[] getLongByteArray() {
 		return longByteArray;
 	}
 
 	public void setLongByteArray(byte[] longByteArray) {
 		this.longByteArray = longByteArray;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/lob/LongByteArrayTest.java b/hibernate-core/src/test/java/org/hibernate/test/lob/LongByteArrayTest.java
index 924aa9671c..bf73d62607 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/lob/LongByteArrayTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/lob/LongByteArrayTest.java
@@ -1,144 +1,144 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.lob;
 
 import junit.framework.AssertionFailedError;
 import org.junit.Assert;
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertNull;
 
 /**
  * Tests eager materialization and mutation of long byte arrays.
  *
  * @author Steve Ebersole
  */
 public abstract class LongByteArrayTest extends BaseCoreFunctionalTestCase {
 	private static final int ARRAY_SIZE = 10000;
 
 	@Test
 	public void testBoundedLongByteArrayAccess() {
 		byte[] original = buildRecursively( ARRAY_SIZE, true );
 		byte[] changed = buildRecursively( ARRAY_SIZE, false );
 		byte[] empty = new byte[] {};
 
 		Session s = openSession();
 		s.beginTransaction();
 		LongByteArrayHolder entity = new LongByteArrayHolder();
 		s.save( entity );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = ( LongByteArrayHolder ) s.get( LongByteArrayHolder.class, entity.getId() );
 		assertNull( entity.getLongByteArray() );
 		entity.setLongByteArray( original );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = ( LongByteArrayHolder ) s.get( LongByteArrayHolder.class, entity.getId() );
 		Assert.assertEquals( ARRAY_SIZE, entity.getLongByteArray().length );
 		assertEquals( original, entity.getLongByteArray() );
 		entity.setLongByteArray( changed );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = ( LongByteArrayHolder ) s.get( LongByteArrayHolder.class, entity.getId() );
 		Assert.assertEquals( ARRAY_SIZE, entity.getLongByteArray().length );
 		assertEquals( changed, entity.getLongByteArray() );
 		entity.setLongByteArray( null );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = ( LongByteArrayHolder ) s.get( LongByteArrayHolder.class, entity.getId() );
 		assertNull( entity.getLongByteArray() );
 		entity.setLongByteArray( empty );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = ( LongByteArrayHolder ) s.get( LongByteArrayHolder.class, entity.getId() );
 		if ( entity.getLongByteArray() != null ) {
 			Assert.assertEquals( empty.length, entity.getLongByteArray().length );
 			assertEquals( empty, entity.getLongByteArray() );
 		}
 		s.delete( entity );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSaving() {
 		byte[] value = buildRecursively( ARRAY_SIZE, true );
 
 		Session s = openSession();
 		s.beginTransaction();
 		LongByteArrayHolder entity = new LongByteArrayHolder();
 		entity.setLongByteArray( value );
 		s.persist( entity );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = ( LongByteArrayHolder ) s.get( LongByteArrayHolder.class, entity.getId() );
 		Assert.assertEquals( ARRAY_SIZE, entity.getLongByteArray().length );
 		assertEquals( value, entity.getLongByteArray() );
 		s.delete( entity );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	private byte[] buildRecursively(int size, boolean on) {
 		byte[] data = new byte[size];
 		data[0] = mask( on );
 		for ( int i = 0; i < size; i++ ) {
 			data[i] = mask( on );
 			on = !on;
 		}
 		return data;
 	}
 
 	private byte mask(boolean on) {
 		return on ? ( byte ) 1 : ( byte ) 0;
 	}
 
 	public static void assertEquals(byte[] val1, byte[] val2) {
 		if ( !ArrayHelper.isEquals( val1, val2 ) ) {
 			throw new AssertionFailedError( "byte arrays did not match" );
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/lob/LongStringHolder.java b/hibernate-core/src/test/java/org/hibernate/test/lob/LongStringHolder.java
index 00eb06cc9e..9d262e00f9 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/lob/LongStringHolder.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/lob/LongStringHolder.java
@@ -1,54 +1,54 @@
 //$Id: $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.lob;
 
 
 /**
  * An entity containing data that is materialized into a String immediately.
  *
  * @author Gail Badner
  */
 public class LongStringHolder {
 	private Long id;
 
 	private String longString;
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public String getLongString() {
 		return longString;
 	}
 
 	public void setLongString(String longString) {
 		this.longString = longString;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/lob/LongStringTest.java b/hibernate-core/src/test/java/org/hibernate/test/lob/LongStringTest.java
index 5546b53734..5feac68c19 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/lob/LongStringTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/lob/LongStringTest.java
@@ -1,115 +1,115 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.lob;
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.dialect.SybaseASE15Dialect;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 
 /**
  * Tests eager materialization and mutation of long strings.
  *
  * @author Steve Ebersole
  */
 @SuppressWarnings( {"UnusedDeclaration"})
 public abstract class LongStringTest extends BaseCoreFunctionalTestCase {
 	private static final int LONG_STRING_SIZE = 10000;
 
 	@Test
 	public void testBoundedLongStringAccess() {
 		String original = buildRecursively( LONG_STRING_SIZE, 'x' );
 		String changed = buildRecursively( LONG_STRING_SIZE, 'y' );
 		String empty = "";
 
 		Session s = openSession();
 		s.beginTransaction();
 		LongStringHolder entity = new LongStringHolder();
 		s.save( entity );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = ( LongStringHolder ) s.get( LongStringHolder.class, entity.getId() );
 		assertNull( entity.getLongString() );
 		entity.setLongString( original );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = ( LongStringHolder ) s.get( LongStringHolder.class, entity.getId() );
 		assertEquals( LONG_STRING_SIZE, entity.getLongString().length() );
 		assertEquals( original, entity.getLongString() );
 		entity.setLongString( changed );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = ( LongStringHolder ) s.get( LongStringHolder.class, entity.getId() );
 		assertEquals( LONG_STRING_SIZE, entity.getLongString().length() );
 		assertEquals( changed, entity.getLongString() );
 		entity.setLongString( null );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = ( LongStringHolder ) s.get( LongStringHolder.class, entity.getId() );
 		assertNull( entity.getLongString() );
 		entity.setLongString( empty );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		entity = ( LongStringHolder ) s.get( LongStringHolder.class, entity.getId() );
 		if ( entity.getLongString() != null ) {
             if(getDialect() instanceof SybaseASE15Dialect){
                 //Sybase uses a single blank to denote an empty string (this is by design). So, when inserting an empty string '', it is interpreted as single blank ' '.
                 assertEquals( empty.length(), entity.getLongString().trim().length() );
                 assertEquals( empty, entity.getLongString().trim() );
             }else{
 			    assertEquals( empty.length(), entity.getLongString().length() );
                 assertEquals( empty, entity.getLongString() );
             }
 		}
 		s.delete( entity );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	private String buildRecursively(int size, char baseChar) {
 		StringBuilder buff = new StringBuilder();
 		for( int i = 0; i < size; i++ ) {
 			buff.append( baseChar );
 		}
 		return buff.toString();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/lob/MaterializedBlobTest.java b/hibernate-core/src/test/java/org/hibernate/test/lob/MaterializedBlobTest.java
index d760937d77..d774a23419 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/lob/MaterializedBlobTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/lob/MaterializedBlobTest.java
@@ -1,43 +1,43 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.lob;
 
 import org.hibernate.testing.DialectChecks;
 import org.hibernate.testing.RequiresDialectFeature;
 
 /**
  * Tests eager materialization and mutation of data mapped by
  * {@link org.hibernate.type.MaterializedBlobType}.
  *
  * @author Gail Badner
  */
 @RequiresDialectFeature(
 		value = DialectChecks.SupportsExpectedLobUsagePattern.class,
 		comment = "database/driver does not support expected LOB usage pattern"
 )
 public class MaterializedBlobTest extends LongByteArrayTest {
 	public String[] getMappings() {
 		return new String[] { "lob/MaterializedBlobMappings.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/lob/MaterializedClobTest.java b/hibernate-core/src/test/java/org/hibernate/test/lob/MaterializedClobTest.java
index 351beb3494..d70effd8eb 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/lob/MaterializedClobTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/lob/MaterializedClobTest.java
@@ -1,40 +1,40 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.lob;
 
 import org.hibernate.testing.DialectChecks;
 import org.hibernate.testing.RequiresDialectFeature;
 
 /**
  * Tests eager materialization and mutation of data mapped by
  * {@link org.hibernate.type.MaterializedClobType}.
  *
  * @author Gail Badner
  */
 @RequiresDialectFeature( DialectChecks.SupportsExpectedLobUsagePattern.class )
 public class MaterializedClobTest extends LongStringTest {
 	public String[] getMappings() {
 		return new String[] { "lob/MaterializedClobMappings.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/lob/SerializableHolder.java b/hibernate-core/src/test/java/org/hibernate/test/lob/SerializableHolder.java
index 9f64218a98..d65edd8a90 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/lob/SerializableHolder.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/lob/SerializableHolder.java
@@ -1,55 +1,55 @@
 //$Id: $
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.lob;
 import java.io.Serializable;
 
 /**
  * An entity containing serializable data which is
  * mapped via the {@link org.hibernate.type.SerializableType}.
  *
  * @author Steve Ebersole
  */
 public class SerializableHolder {
 	private Long id;
 
 	private Serializable serialData;
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public Serializable getSerialData() {
 		return serialData;
 	}
 
 	public void setSerialData(Serializable serialData) {
 		this.serialData = serialData;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/lob/TextTest.java b/hibernate-core/src/test/java/org/hibernate/test/lob/TextTest.java
index 5b58d89c49..264ca530aa 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/lob/TextTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/lob/TextTest.java
@@ -1,36 +1,36 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.lob;
 
 /**
  * Test eager materialization and mutation data mapped by
  * #{@link org.hibernate.type.TextType}.
  *
  * @author Gail Badner
  */
 public class TextTest extends LongStringTest {
 	public String[] getMappings() {
 		return new String[] { "lob/TextMappings.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/manytomanyassociationclass/surrogateid/assigned/ManyToManyAssociationClassAssignedIdTest.java b/hibernate-core/src/test/java/org/hibernate/test/manytomanyassociationclass/surrogateid/assigned/ManyToManyAssociationClassAssignedIdTest.java
index 8808908f29..05a81558c9 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/manytomanyassociationclass/surrogateid/assigned/ManyToManyAssociationClassAssignedIdTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/manytomanyassociationclass/surrogateid/assigned/ManyToManyAssociationClassAssignedIdTest.java
@@ -1,45 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.manytomanyassociationclass.surrogateid.assigned;
 
 import org.hibernate.test.manytomanyassociationclass.AbstractManyToManyAssociationClassTest;
 import org.hibernate.test.manytomanyassociationclass.Membership;
 
 /**
  * Tests on many-to-many association using an association class with a surrogate ID that is assigned.
  *
  * @author Gail Badner
  */
 public class ManyToManyAssociationClassAssignedIdTest extends AbstractManyToManyAssociationClassTest {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "manytomanyassociationclass/surrogateid/assigned/Mappings.hbm.xml" };
 	}
 
 	@Override
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public Membership createMembership(String name) {
 		return new Membership( Long.valueOf( 1000 ), name );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/manytomanyassociationclass/surrogateid/generated/ManyToManyAssociationClassGeneratedIdTest.java b/hibernate-core/src/test/java/org/hibernate/test/manytomanyassociationclass/surrogateid/generated/ManyToManyAssociationClassGeneratedIdTest.java
index a6bb8491ba..0eacb416da 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/manytomanyassociationclass/surrogateid/generated/ManyToManyAssociationClassGeneratedIdTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/manytomanyassociationclass/surrogateid/generated/ManyToManyAssociationClassGeneratedIdTest.java
@@ -1,133 +1,133 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.manytomanyassociationclass.surrogateid.generated;
 import java.util.HashSet;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.exception.ConstraintViolationException;
 import org.hibernate.test.manytomanyassociationclass.AbstractManyToManyAssociationClassTest;
 import org.hibernate.test.manytomanyassociationclass.Membership;
 
 import static org.junit.Assert.fail;
 
 /**
  * Tests on many-to-many association using an association class with a surrogate ID that is generated.
  *
  * @author Gail Badner
  */
 public class ManyToManyAssociationClassGeneratedIdTest extends AbstractManyToManyAssociationClassTest {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "manytomanyassociationclass/surrogateid/generated/Mappings.hbm.xml" };
 	}
 
 	@Override
 	public Membership createMembership(String name) {
 		return new Membership( name );
 	}
 
 	@Test
 	public void testRemoveAndAddEqualElement() {
 		deleteMembership( getUser(), getGroup(), getMembership() );
 		addMembership( getUser(), getGroup(), createMembership( "membership" ) );
 
 		Session s = openSession();
 		s.beginTransaction();
 		try {
 			// The new membership is transient (it has a null surrogate ID), so
 			// Hibernate assumes that it should be added to the collection.
 			// Inserts are done before deletes, so a ConstraintViolationException
 			// will be thrown on the insert because the unique constraint on the
 			// user and group IDs in the join table is violated. See HHH-2801.
 			s.merge( getUser() );
 			s.getTransaction().commit();
 			fail( "should have failed because inserts are before deletes");
 		}
 		catch( ConstraintViolationException ex ) {
 			// expected
 			s.getTransaction().rollback();
 		}
 		finally {
 			s.close();
 		}
 	}
 
 	@Test
 	public void testRemoveAndAddEqualCollection() {
 		deleteMembership( getUser(), getGroup(), getMembership() );
 		getUser().setMemberships( new HashSet() );
 		getGroup().setMemberships( new HashSet() );
 		addMembership( getUser(), getGroup(), createMembership( "membership" ) );
 
 		Session s = openSession();
 		s.beginTransaction();
 		try {
 			// The new membership is transient (it has a null surrogate ID), so
 			// Hibernate assumes that it should be added to the collection.
 			// Inserts are done before deletes, so a ConstraintViolationException
 			// will be thrown on the insert because the unique constraint on the
 			// user and group IDs in the join table is violated. See HHH-2801.
 			s.merge( getUser() );
 			s.getTransaction().commit();
 			fail( "should have failed because inserts are before deletes");
 		}
 		catch( ConstraintViolationException ex ) {
 			// expected
 			s.getTransaction().rollback();
 		}
 		finally {
 			s.close();
 		}
 	}
 
 	@Test
 	public void testRemoveAndAddEqualElementNonKeyModified() {
 		deleteMembership( getUser(), getGroup(), getMembership() );
 		Membership membershipNew = createMembership( "membership" );
 		addMembership( getUser(), getGroup(), membershipNew );
 		membershipNew.setName( "membership1" );
 
 		Session s = openSession();
 		s.beginTransaction();
 		try {
 			// The new membership is transient (it has a null surrogate ID), so
 			// Hibernate assumes that it should be added to the collection.
 			// Inserts are done before deletes, so a ConstraintViolationException
 			// will be thrown on the insert because the unique constraint on the
 			// user and group IDs in the join table is violated. See HHH-2801.
 			s.merge( getUser() );
 			s.getTransaction().commit();
 			fail( "should have failed because inserts are before deletes");
 		}
 		catch( ConstraintViolationException ex ) {
 			// expected
 			s.getTransaction().rollback();
 		}
 		finally {
 			s.close();
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/map/MapIndexFormulaTest.java b/hibernate-core/src/test/java/org/hibernate/test/map/MapIndexFormulaTest.java
index 73e4b4554a..0084011815 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/map/MapIndexFormulaTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/map/MapIndexFormulaTest.java
@@ -1,137 +1,136 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.map;
 import java.util.List;
 import java.util.Map;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Gavin King
  */
 public class MapIndexFormulaTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] { "map/UserGroup.hbm.xml" };
 	}
 
 	@Test
 	public void testIndexFunctionOnManyToManyMap() {
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Group g join g.users u where g.name = 'something' and index(u) = 'nada'" )
 				.list();
 		s.createQuery( "from Group g join g.users u where g.name = 'something' and minindex(u) = 'nada'" )
 				.list();
 		s.createQuery( "from Group g join g.users u where g.name = 'something' and maxindex(u) = 'nada'" )
 				.list();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"unchecked", "UnnecessaryBoxing"})
 	public void testIndexFormulaMap() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		User gavin = new User("gavin", "secret");
 		User turin = new User("turin", "tiger");
 		Group g = new Group("developers");
 		g.getUsers().put("gavin", gavin);
 		g.getUsers().put("turin", turin);
 		s.persist(g);
 		gavin.getSession().put( "foo", new SessionAttribute("foo", "foo bar baz") );
 		gavin.getSession().put( "bar", new SessionAttribute("bar", "foo bar baz 2") );
 		t.commit();
 		s.close();
 		
 		s = openSession();
 		t = s.beginTransaction();
 		g = (Group) s.get(Group.class, "developers");
 		assertEquals( g.getUsers().size(), 2 );
 		g.getUsers().remove("turin");
 		Map smap = ( (User) g.getUsers().get("gavin") ).getSession();
 		assertEquals(smap.size(), 2);
 		smap.remove("bar");
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		g = (Group) s.get(Group.class, "developers");
 		assertEquals( g.getUsers().size(), 1 );
 		smap = ( (User) g.getUsers().get("gavin") ).getSession();
 		assertEquals(smap.size(), 1);
 		gavin = (User) g.getUsers().put("gavin", turin);
 		s.delete(gavin);
 		assertEquals( s.createQuery("select count(*) from SessionAttribute").uniqueResult(), new Long(0) );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		g = (Group) s.get(Group.class, "developers");
 		assertEquals( g.getUsers().size(), 1 );
 		turin = (User) g.getUsers().get("turin");
 		smap = turin.getSession();
 		assertEquals(smap.size(), 0);
 		assertEquals( s.createQuery("select count(*) from User").uniqueResult(), Long.valueOf(1) );
 		s.delete(g);
 		s.delete(turin);
 		assertEquals( s.createQuery("select count(*) from User").uniqueResult(), Long.valueOf( 0 ) );
 		t.commit();
 		s.close();
 	}
 	
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testSQLQuery() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		User gavin = new User("gavin", "secret");
 		User turin = new User("turin", "tiger");
 		gavin.getSession().put( "foo", new SessionAttribute("foo", "foo bar baz") );
 		gavin.getSession().put( "bar", new SessionAttribute("bar", "foo bar baz 2") );
 		s.persist(gavin);
 		s.persist(turin);
 		s.flush();
 		s.clear();
 		List results = s.getNamedQuery("userSessionData").setParameter("uname", "%in").list();
 		assertEquals( results.size(), 2 );
 		gavin = (User) ( (Object[]) results.get(0) )[0];
 		assertEquals( gavin.getName(), "gavin" );
 		assertEquals( gavin.getSession().size(), 2 );
 		s.createQuery("delete SessionAttribute").executeUpdate();
 		s.createQuery("delete User").executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/naturalid/mutable/cached/AllCached.java b/hibernate-core/src/test/java/org/hibernate/test/naturalid/mutable/cached/AllCached.java
index 4439d84cc1..f4fdd4d5fa 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/naturalid/mutable/cached/AllCached.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/naturalid/mutable/cached/AllCached.java
@@ -1,50 +1,50 @@
 package org.hibernate.test.naturalid.mutable.cached;
 
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 
 import org.hibernate.annotations.Cache;
 import org.hibernate.annotations.CacheConcurrencyStrategy;
 import org.hibernate.annotations.GenericGenerator;
 import org.hibernate.annotations.NaturalId;
 import org.hibernate.annotations.NaturalIdCache;
 
 /**
  * @author Guenther Demetz
  * Same as Another.class, excpect that here also the entity class itself is configured for shared cache
  */
 @Entity
 @NaturalIdCache
 @Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
 public class AllCached {
 	private Integer id;
 	private String name;
 
 	public AllCached() {
 	}
 
 	public AllCached(String name) {
 		this.name = name;
 	}
 
 	@Id
 	@GeneratedValue( generator = "increment" )
 	@GenericGenerator( name = "increment", strategy = "increment" )
 	public Integer getId() {
 		return id;
 	}
 
 	public void setId(Integer id) {
 		this.id = id;
 	}
 
 	@NaturalId(mutable = true)
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/naturalid/nullable/A.java b/hibernate-core/src/test/java/org/hibernate/test/naturalid/nullable/A.java
index fbe5767a9d..3d3e481ac2 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/naturalid/nullable/A.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/naturalid/nullable/A.java
@@ -1,57 +1,57 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.naturalid.nullable;
 
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 import javax.persistence.ManyToOne;
 import javax.persistence.OneToMany;
 import java.util.HashSet;
 import java.util.Set;
 
 import org.hibernate.annotations.NaturalId;
 
 /**
  * @author Guenther Demetz
  */
 @Entity
 public class A  {
 	@Id
 	@GeneratedValue(strategy = GenerationType.TABLE)
 	public long oid;
 
 	@ManyToOne
 	@NaturalId(mutable=true)
 	public C assC;
 
 	@Column
 	@NaturalId(mutable=true)
 	public String myname;
 
 	@OneToMany(mappedBy="assA")
 	public Set<B> assB = new HashSet<B>();
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/naturalid/nullable/C.java b/hibernate-core/src/test/java/org/hibernate/test/naturalid/nullable/C.java
index 32b27d2039..9ec41addee 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/naturalid/nullable/C.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/naturalid/nullable/C.java
@@ -1,44 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.naturalid.nullable;
 
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 
 import org.hibernate.annotations.NaturalId;
 
 /**
  * @author Guenther Demetz
  */
 @Entity
 public class C {
 	@Id @GeneratedValue(strategy = GenerationType.TABLE)
 	public long oid;
 
 	@NaturalId(mutable=true)
 	public String name;
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/CreateTest.java b/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/CreateTest.java
index 4f41193be4..d092a7b55e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/CreateTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/CreateTest.java
@@ -1,294 +1,293 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.nonflushedchanges;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import javax.transaction.RollbackException;
 
 import org.junit.Assert;
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.PersistentObjectException;
 import org.hibernate.Session;
 import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
 import org.hibernate.exception.ConstraintViolationException;
 import org.hibernate.testing.jta.TestingJtaPlatformImpl;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 
 /**
  * @author Gavin King, Gail Badner (adapted this from "ops" tests version)
  */
 public class CreateTest extends AbstractOperationTestCase {
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testNoUpdatesOnCreateVersionedWithCollection() throws Exception {
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		VersionedEntity root = new VersionedEntity( "root", "root" );
 		VersionedEntity child = new VersionedEntity( "c1", "child-1" );
 		root.getChildren().add( child );
 		child.setParent( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		s.save( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( VersionedEntity ) getOldToNewEntityRefMap().get( root );
 		applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( VersionedEntity ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		assertDeleteCount( 0 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.delete( root );
 		applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
 	public void testCreateTree() throws Exception {
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Node root = new Node( "root" );
 		Node child = new Node( "child" );
 		root.addChild( child );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		s.persist( root );
 		applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		System.out.println( "getting" );
 		root = ( Node ) s.get( Node.class, "root" );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( Node ) getOldToNewEntityRefMap().get( root );
 		Node child2 = new Node( "child2" );
 		root.addChild( child2 );
 		System.out.println( "committing" );
 		applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 3 );
 		assertUpdateCount( 0 );
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testCreateTreeWithGeneratedId() throws Exception {
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		NumberedNode root = new NumberedNode( "root" );
 		NumberedNode child = new NumberedNode( "child" );
 		root.addChild( child );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		s.persist( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) s.get( NumberedNode.class, Long.valueOf( root.getId() ) );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		NumberedNode child2 = new NumberedNode( "child2" );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		root.addChild( child2 );
 		applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 3 );
 		assertUpdateCount( 0 );
 	}
 
 	@Test
 	public void testCreateException() throws Exception {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Node dupe = new Node( "dupe" );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		s.persist( dupe );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		dupe = ( Node ) getOldToNewEntityRefMap().get( dupe );
 		s.persist( dupe );
 		applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		s.persist( dupe );
 		applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		try {
 			TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 			Assert.fail();
 		}
 		catch ( ConstraintViolationException cve ) {
 			//verify that an exception is thrown!
 		}
 		catch ( RollbackException e ) {
 			if ( ! ConstraintViolationException.class.isInstance( e.getCause() ) ) {
 				throw (Exception) e.getCause();
 			}
 		}
 		if ( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) ) {
 			// ugh! really!?!
 			TestingJtaPlatformImpl.INSTANCE.getTransactionManager().rollback();
 		}
 
 		Node nondupe = new Node( "nondupe" );
 		nondupe.addChild( dupe );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		s.persist( nondupe );
 		applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		try {
 			TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 			Assert.fail();
 		}
 		catch ( ConstraintViolationException cve ) {
 			//verify that an exception is thrown!
 		}
 		catch ( RollbackException e ) {
 			if ( ! ConstraintViolationException.class.isInstance( e.getCause() ) ) {
 				throw (Exception) e.getCause();
 			}
 		}
 		if ( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) ) {
 			// ugh! really!?!
 			TestingJtaPlatformImpl.INSTANCE.getTransactionManager().rollback();
 		}
 	}
 
 	@Test
 	public void testCreateExceptionWithGeneratedId() throws Exception {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		NumberedNode dupe = new NumberedNode( "dupe" );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		s.persist( dupe );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		dupe = ( NumberedNode ) getOldToNewEntityRefMap().get( dupe );
 		s.persist( dupe );
 		applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		dupe = ( NumberedNode ) getOldToNewEntityRefMap().get( dupe );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		try {
 			s.persist( dupe );
 			s.flush();
 			assertFalse( true );
 		}
 		catch ( PersistentObjectException poe ) {
 			//verify that an exception is thrown!
 		}
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().rollback();
 
 		NumberedNode nondupe = new NumberedNode( "nondupe" );
 		nondupe.addChild( dupe );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		try {
 			s.persist( nondupe );
 			assertFalse( true );
 		}
 		catch ( PersistentObjectException poe ) {
 			//verify that an exception is thrown!
 		}
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().rollback();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testBasic() throws Exception {
 		Session s;
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		Employer er = new Employer();
 		Employee ee = new Employee();
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		s.persist( ee );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		ee = ( Employee ) getOldToNewEntityRefMap().get( ee );
 		Collection erColl = new ArrayList();
 		Collection eeColl = new ArrayList();
 		erColl.add( ee );
 		eeColl.add( er );
 		er.setEmployees( erColl );
 		ee.setEmployers( eeColl );
 		applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		ee = ( Employee ) getOldToNewEntityRefMap().get( ee );
 		er = ( Employer ) ee.getEmployers().iterator().next();
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		er = ( Employer ) s.load( Employer.class, er.getId() );
 		assertNotNull( er );
 		assertFalse( Hibernate.isInitialized( er ) );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		er = ( Employer ) getOldToNewEntityRefMap().get( er );
 		assertNotNull( er );
 		assertFalse( Hibernate.isInitialized( er ) );
 		assertNotNull( er.getEmployees() );
 		assertEquals( 1, er.getEmployees().size() );
 		Employee eeFromDb = ( Employee ) er.getEmployees().iterator().next();
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		eeFromDb = ( Employee ) getOldToNewEntityRefMap().get( eeFromDb );
 		assertEquals( ee.getId(), eeFromDb.getId() );
 		applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/MergeTest.java b/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/MergeTest.java
index c17f5444fc..13685650f0 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/MergeTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/MergeTest.java
@@ -1,884 +1,880 @@
 //$Id: MergeTest.java 11037 2007-01-09 16:04:16Z steve.ebersole@jboss.com $
 package org.hibernate.test.nonflushedchanges;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.NonUniqueObjectException;
 import org.hibernate.Session;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.criterion.Projections;
 import org.hibernate.testing.jta.TestingJtaPlatformImpl;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * adapted this from "ops" tests version
  *
  * @author Gail Badner
  * @author Gavin King
  */
 public class MergeTest extends AbstractOperationTestCase {
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testMergeStaleVersionFails() throws Exception {
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		VersionedEntity entity = new VersionedEntity( "entity", "entity" );
 		s.persist( entity );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		// make the detached 'entity' reference stale...
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		VersionedEntity entity2 = ( VersionedEntity ) s.get( VersionedEntity.class, entity.getId() );
 		entity2.setName( "entity-name" );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		// now try to reattach it
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		try {
 			s.merge( entity );
 			s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 			entity = ( VersionedEntity ) getOldToNewEntityRefMap().get( entity );
 			TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 			fail( "was expecting staleness error" );
 		}
 		catch ( StaleObjectStateException expected ) {
 			// expected outcome...
 		}
 		finally {
 			TestingJtaPlatformImpl.INSTANCE.getTransactionManager().rollback();
 		}
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testMergeBidiPrimayKeyOneToOne() throws Exception {
 		rebuildSessionFactory();
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Person p = new Person( "steve" );
 
 		new PersonalDetails( "I have big feet", p );
 		s.persist( p );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		clearCounts();
 
 		p.getDetails().setSomePersonalDetail( p.getDetails().getSomePersonalDetail() + " and big hands too" );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		p = ( Person ) s.merge( p );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		p = ( Person ) getOldToNewEntityRefMap().get( p );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( 1 );
 		assertDeleteCount( 0 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.delete( p );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testMergeBidiForeignKeyOneToOne() throws Exception {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Person p = new Person( "steve" );
 		Address a = new Address( "123 Main", "Austin", "US", p );
 		s.persist( a );
 		s.persist( p );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		clearCounts();
 
 		p.getAddress().setStreetAddress( "321 Main" );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		p = ( Person ) s.merge( p );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( 0 ); // no cascade
 		assertDeleteCount( 0 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.delete( a );
 		s.delete( p );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 	}
 
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testNoExtraUpdatesOnMerge() throws Exception {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Node node = new Node( "test" );
 		s.persist( node );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		clearCounts();
 
 		// node is now detached, but we have made no changes.  so attempt to merge it
 		// into this new session; this should cause no updates...
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		node = ( Node ) s.merge( node );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertUpdateCount( 0 );
 		assertInsertCount( 0 );
 
 		///////////////////////////////////////////////////////////////////////
 		// as a control measure, now update the node while it is detached and
 		// make sure we get an update as a result...
 		node.setDescription( "new description" );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		node = ( Node ) s.merge( node );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 		assertUpdateCount( 1 );
 		assertInsertCount( 0 );
 		///////////////////////////////////////////////////////////////////////
 
 
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked", "UnusedAssignment"})
 	public void testNoExtraUpdatesOnMergeWithCollection() throws Exception {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Node parent = new Node( "parent" );
 		Node child = new Node( "child" );
 		parent.getChildren().add( child );
 		child.setParent( parent );
 		s.persist( parent );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		clearCounts();
 
 		// parent is now detached, but we have made no changes.  so attempt to merge it
 		// into this new session; this should cause no updates...
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		parent = ( Node ) s.merge( parent );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertUpdateCount( 0 );
 		assertInsertCount( 0 );
 
 		///////////////////////////////////////////////////////////////////////
 		// as a control measure, now update the node while it is detached and
 		// make sure we get an update as a result...
 		( ( Node ) parent.getChildren().iterator().next() ).setDescription( "child's new description" );
 		parent.addChild( new Node( "second child" ) );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		parent = ( Node ) s.merge( parent );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 		assertUpdateCount( 1 );
 		assertInsertCount( 1 );
 		///////////////////////////////////////////////////////////////////////
 
 
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testNoExtraUpdatesOnMergeVersioned() throws Exception {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		VersionedEntity entity = new VersionedEntity( "entity", "entity" );
 		s.persist( entity );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		clearCounts();
 
 		// entity is now detached, but we have made no changes.  so attempt to merge it
 		// into this new session; this should cause no updates...
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		VersionedEntity mergedEntity = ( VersionedEntity ) s.merge( entity );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		mergedEntity = ( VersionedEntity ) getOldToNewEntityRefMap().get( mergedEntity );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertUpdateCount( 0 );
 		assertInsertCount( 0 );
 		assertEquals( "unexpected version increment", entity.getVersion(), mergedEntity.getVersion() );
 
 
 		///////////////////////////////////////////////////////////////////////
 		// as a control measure, now update the node while it is detached and
 		// make sure we get an update as a result...
 		entity.setName( "new name" );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		entity = ( VersionedEntity ) s.merge( entity );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 		assertUpdateCount( 1 );
 		assertInsertCount( 0 );
 		///////////////////////////////////////////////////////////////////////
 
 
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked", "UnusedAssignment"})
 	public void testNoExtraUpdatesOnMergeVersionedWithCollection() throws Exception {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		VersionedEntity parent = new VersionedEntity( "parent", "parent" );
 		VersionedEntity child = new VersionedEntity( "child", "child" );
 		parent.getChildren().add( child );
 		child.setParent( parent );
 		s.persist( parent );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		clearCounts();
 
 		// parent is now detached, but we have made no changes.  so attempt to merge it
 		// into this new session; this should cause no updates...
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		VersionedEntity mergedParent = ( VersionedEntity ) s.merge( parent );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		mergedParent = ( VersionedEntity ) getOldToNewEntityRefMap().get( mergedParent );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertUpdateCount( 0 );
 		assertInsertCount( 0 );
 		assertEquals( "unexpected parent version increment", parent.getVersion(), mergedParent.getVersion() );
 		VersionedEntity mergedChild = ( VersionedEntity ) mergedParent.getChildren().iterator().next();
 		assertEquals( "unexpected child version increment", child.getVersion(), mergedChild.getVersion() );
 
 		///////////////////////////////////////////////////////////////////////
 		// as a control measure, now update the node while it is detached and
 		// make sure we get an update as a result...
 		mergedParent.setName( "new name" );
 		mergedParent.getChildren().add( new VersionedEntity( "child2", "new child" ) );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		parent = ( VersionedEntity ) s.merge( mergedParent );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		parent = ( VersionedEntity ) getOldToNewEntityRefMap().get( parent );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 		assertUpdateCount( 1 );
 		assertInsertCount( 1 );
 		///////////////////////////////////////////////////////////////////////
 
 
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked", "UnusedAssignment"})
 	public void testNoExtraUpdatesOnPersistentMergeVersionedWithCollection() throws Exception {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		VersionedEntity parent = new VersionedEntity( "parent", "parent" );
 		VersionedEntity child = new VersionedEntity( "child", "child" );
 		parent.getChildren().add( child );
 		child.setParent( parent );
 		s.persist( parent );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		clearCounts();
 
 		// parent is now detached, but we have made no changes. so attempt to merge it
 		// into this new session; this should cause no updates...
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		// load parent so that merge will follow entityIsPersistent path
 		VersionedEntity persistentParent = ( VersionedEntity ) s.get( VersionedEntity.class, parent.getId() );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		persistentParent = ( VersionedEntity ) getOldToNewEntityRefMap().get( persistentParent );
 		// load children
 		persistentParent.getChildren().iterator().next();
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		persistentParent = ( VersionedEntity ) getOldToNewEntityRefMap().get( persistentParent );
 		VersionedEntity mergedParent = ( VersionedEntity ) s.merge( persistentParent ); // <-- This merge leads to failure
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		mergedParent = ( VersionedEntity ) getOldToNewEntityRefMap().get( mergedParent );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertUpdateCount( 0 );
 		assertInsertCount( 0 );
 		assertEquals( "unexpected parent version increment", parent.getVersion(), mergedParent.getVersion() );
 		VersionedEntity mergedChild = ( VersionedEntity ) mergedParent.getChildren().iterator().next();
 		assertEquals( "unexpected child version increment", child.getVersion(), mergedChild.getVersion() );
 
 		///////////////////////////////////////////////////////////////////////
 		// as a control measure, now update the node once it is loaded and
 		// make sure we get an update as a result...
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		persistentParent = ( VersionedEntity ) s.get( VersionedEntity.class, parent.getId() );
 		persistentParent.setName( "new name" );
 		persistentParent.getChildren().add( new VersionedEntity( "child2", "new child" ) );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		persistentParent = ( VersionedEntity ) getOldToNewEntityRefMap().get( persistentParent );
 		persistentParent = ( VersionedEntity ) s.merge( persistentParent );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 		assertUpdateCount( 1 );
 		assertInsertCount( 1 );
 		///////////////////////////////////////////////////////////////////////
 
 		//
 	}
 
 	@Test
 	public void testPersistThenMergeInSameTxnWithVersion() throws Exception {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		VersionedEntity entity = new VersionedEntity( "test", "test" );
 		s.persist( entity );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		s.merge( new VersionedEntity( "test", "test-2" ) );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 
 		try {
 			// control operation...
 			s.saveOrUpdate( new VersionedEntity( "test", "test-3" ) );
 			fail( "saveOrUpdate() should fail here" );
 		}
 		catch ( NonUniqueObjectException expected ) {
 			// expected behavior
 		}
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 
 	}
 
 	@Test
 	public void testPersistThenMergeInSameTxnWithTimestamp() throws Exception {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		TimestampedEntity entity = new TimestampedEntity( "test", "test" );
 		s.persist( entity );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		s.merge( new TimestampedEntity( "test", "test-2" ) );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 
 		try {
 			// control operation...
 			s.saveOrUpdate( new TimestampedEntity( "test", "test-3" ) );
 			fail( "saveOrUpdate() should fail here" );
 		}
 		catch ( NonUniqueObjectException expected ) {
 			// expected behavior
 		}
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testMergeDeepTree() throws Exception {
 
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Node root = new Node( "root" );
 		Node child = new Node( "child" );
 		Node grandchild = new Node( "grandchild" );
 		root.addChild( child );
 		child.addChild( grandchild );
 		s.merge( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 3 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		grandchild.setDescription( "the grand child" );
 		Node grandchild2 = new Node( "grandchild2" );
 		child.addChild( grandchild2 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.merge( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 1 );
 		clearCounts();
 
 		Node child2 = new Node( "child2" );
 		Node grandchild3 = new Node( "grandchild3" );
 		child2.addChild( grandchild3 );
 		root.addChild( child2 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.merge( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.delete( grandchild );
 		s.delete( grandchild2 );
 		s.delete( grandchild3 );
 		s.delete( child );
 		s.delete( child2 );
 		s.delete( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testMergeDeepTreeWithGeneratedId() throws Exception {
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		NumberedNode root = new NumberedNode( "root" );
 		NumberedNode child = new NumberedNode( "child" );
 		NumberedNode grandchild = new NumberedNode( "grandchild" );
 		root.addChild( child );
 		child.addChild( grandchild );
 		root = ( NumberedNode ) s.merge( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 3 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		child = ( NumberedNode ) root.getChildren().iterator().next();
 		grandchild = ( NumberedNode ) child.getChildren().iterator().next();
 		grandchild.setDescription( "the grand child" );
 		NumberedNode grandchild2 = new NumberedNode( "grandchild2" );
 		child.addChild( grandchild2 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		root = ( NumberedNode ) s.merge( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 1 );
 		clearCounts();
 
 		sessionFactory().getCache().evictEntityRegion( NumberedNode.class );
 
 		NumberedNode child2 = new NumberedNode( "child2" );
 		NumberedNode grandchild3 = new NumberedNode( "grandchild3" );
 		child2.addChild( grandchild3 );
 		root.addChild( child2 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		root = ( NumberedNode ) s.merge( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.createQuery( "delete from NumberedNode where name like 'grand%'" ).executeUpdate();
 		s.createQuery( "delete from NumberedNode where name like 'child%'" ).executeUpdate();
 		s.createQuery( "delete from NumberedNode" ).executeUpdate();
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testMergeTree() throws Exception {
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Node root = new Node( "root" );
 		Node child = new Node( "child" );
 		root.addChild( child );
 		s.persist( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( Node ) getOldToNewEntityRefMap().get( root );
 		child = ( Node ) root.getChildren().iterator().next();
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 2 );
 		clearCounts();
 
 		root.setDescription( "The root node" );
 		child.setDescription( "The child node" );
 
 		Node secondChild = new Node( "second child" );
 
 		root.addChild( secondChild );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.merge( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 2 );
 
 
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testMergeTreeWithGeneratedId() throws Exception {
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		NumberedNode root = new NumberedNode( "root" );
 		NumberedNode child = new NumberedNode( "child" );
 		root.addChild( child );
 		s.persist( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		child = ( NumberedNode ) root.getChildren().iterator().next();
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 2 );
 		clearCounts();
 
 		root.setDescription( "The root node" );
 		child.setDescription( "The child node" );
 
 		NumberedNode secondChild = new NumberedNode( "second child" );
 
 		root.addChild( secondChild );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.merge( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 2 );
 
 
 	}
 
 	@Test
-	@SuppressWarnings( {"UnusedAssignment", "UnnecessaryBoxing"})
 	public void testMergeManaged() throws Exception {
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		NumberedNode root = new NumberedNode( "root" );
 		s.persist( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		NumberedNode child = new NumberedNode( "child" );
 		root = ( NumberedNode ) s.merge( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		root.addChild( child );
 		assertSame( root, s.merge( root ) );
 		Object mergedChild = root.getChildren().iterator().next();
 		assertNotSame( mergedChild, child );
 		assertTrue( s.contains( mergedChild ) );
 		assertFalse( s.contains( child ) );
 		assertEquals( root.getChildren().size(), 1 );
 		assertTrue( root.getChildren().contains( mergedChild ) );
 		//assertNotSame( mergedChild, s.merge(child) ); //yucky :(
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		mergedChild = root.getChildren().iterator().next();
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 0 );
 
 		assertEquals( root.getChildren().size(), 1 );
 		assertTrue( root.getChildren().contains( mergedChild ) );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		assertEquals(
 				Long.valueOf( 2 ),
 				s.createCriteria( NumberedNode.class )
 						.setProjection( Projections.rowCount() )
 						.uniqueResult()
 		);
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testMergeManagedUninitializedCollection() throws Exception {
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		NumberedNode root = new NumberedNode( "root" );
 		root.addChild( new NumberedNode( "child" ) );
 		s.persist( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		clearCounts();
 
 		NumberedNode newRoot = new NumberedNode( "root" );
 		newRoot.setId( root.getId() );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		root = ( NumberedNode ) s.get( NumberedNode.class, root.getId() );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		Set managedChildren = root.getChildren();
 		assertFalse( Hibernate.isInitialized( managedChildren ) );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		managedChildren = root.getChildren();
 		newRoot.setChildren( managedChildren );
 		assertSame( root, s.merge( newRoot ) );
 		assertSame( managedChildren, root.getChildren() );
 		assertFalse( Hibernate.isInitialized( managedChildren ) );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( 0 );
 		assertDeleteCount( 0 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		assertEquals(
 				Long.valueOf( 2 ),
 				s.createCriteria( NumberedNode.class )
 						.setProjection( Projections.rowCount() )
 						.uniqueResult()
 		);
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testMergeManagedInitializedCollection() throws Exception {
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		NumberedNode root = new NumberedNode( "root" );
 		root.addChild( new NumberedNode( "child" ) );
 		s.persist( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		clearCounts();
 
 		NumberedNode newRoot = new NumberedNode( "root" );
 		newRoot.setId( root.getId() );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		root = ( NumberedNode ) s.get( NumberedNode.class, root.getId() );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		Set managedChildren = root.getChildren();
 		Hibernate.initialize( managedChildren );
 		assertTrue( Hibernate.isInitialized( managedChildren ) );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		managedChildren = root.getChildren();
 		newRoot.setChildren( managedChildren );
 		assertSame( root, s.merge( newRoot ) );
 		assertSame( managedChildren, root.getChildren() );
 		assertTrue( Hibernate.isInitialized( managedChildren ) );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( 0 );
 		assertDeleteCount( 0 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		assertEquals(
 				Long.valueOf( 2 ),
 				s.createCriteria( NumberedNode.class )
 						.setProjection( Projections.rowCount() )
 						.uniqueResult()
 		);
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testRecursiveMergeTransient() throws Exception {
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Employer jboss = new Employer();
 		Employee gavin = new Employee();
 		jboss.setEmployees( new ArrayList() );
 		jboss.getEmployees().add( gavin );
 		s.merge( jboss );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		s.flush();
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		jboss = ( Employer ) s.createQuery( "from Employer e join fetch e.employees" ).uniqueResult();
 		assertTrue( Hibernate.isInitialized( jboss.getEmployees() ) );
 		assertEquals( 1, jboss.getEmployees().size() );
 		s.clear();
 		s.merge( jboss.getEmployees().iterator().next() );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing", "UnusedAssignment"})
 	public void testDeleteAndMerge() throws Exception {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Employer jboss = new Employer();
 		s.persist( jboss );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		Employer otherJboss;
 		otherJboss = ( Employer ) s.get( Employer.class, jboss.getId() );
 		s.delete( otherJboss );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		jboss.setVers( Integer.valueOf( 1 ) );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.merge( jboss );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked", "UnusedAssignment"})
 	public void testMergeManyToManyWithCollectionDeference() throws Exception {
 		// setup base data...
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Competition competition = new Competition();
 		competition.getCompetitors().add( new Competitor( "Name" ) );
 		competition.getCompetitors().add( new Competitor() );
 		competition.getCompetitors().add( new Competitor() );
 		s.persist( competition );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		// the competition graph is now detached:
 		//   1) create a new List reference to represent the competitors
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		List newComp = new ArrayList();
 		Competitor originalCompetitor = ( Competitor ) competition.getCompetitors().get( 0 );
 		originalCompetitor.setName( "Name2" );
 		newComp.add( originalCompetitor );
 		newComp.add( new Competitor() );
 		//   2) set that new List reference unto the Competition reference
 		competition.setCompetitors( newComp );
 		//   3) attempt the merge
 		Competition competition2 = ( Competition ) s.merge( competition );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		Competition competition2copy = ( Competition ) getOldToNewEntityRefMap().get( competition2 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertFalse( competition == competition2 );
 		assertFalse( competition2 == competition2copy );
 		assertFalse( competition.getCompetitors() == competition2.getCompetitors() );
 		assertEquals( 2, competition2.getCompetitors().size() );
 		assertEquals( 2, competition2copy.getCompetitors().size() );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		competition = ( Competition ) s.get( Competition.class, competition.getId() );
 		assertEquals( 2, competition.getCompetitors().size() );
 		s.delete( competition );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	protected void cleanupTestData() throws Exception {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		s.createQuery( "delete from NumberedNode where parent is not null" ).executeUpdate();
 		s.createQuery( "delete from NumberedNode" ).executeUpdate();
 
 		s.createQuery( "delete from Node where parent is not null" ).executeUpdate();
 		s.createQuery( "delete from Node" ).executeUpdate();
 
 		s.createQuery( "delete from VersionedEntity where parent is not null" ).executeUpdate();
 		s.createQuery( "delete from VersionedEntity" ).executeUpdate();
 		s.createQuery( "delete from TimestampedEntity" ).executeUpdate();
 
 		s.createQuery( "delete from Competitor" ).executeUpdate();
 		s.createQuery( "delete from Competition" ).executeUpdate();
 
 		for ( Employer employer : (List<Employer>)s.createQuery( "from Employer" ).list() ) {
 			s.delete( employer );
 		}
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 	}
 
 	@Override
 	protected boolean isCleanupTestDataRequired() {
 		return true;
 	}
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/SaveOrUpdateTest.java b/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/SaveOrUpdateTest.java
index 87ecff00ce..db176698f9 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/SaveOrUpdateTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/nonflushedchanges/SaveOrUpdateTest.java
@@ -1,548 +1,545 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.nonflushedchanges;
 
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.HibernateException;
 import org.hibernate.Session;
 import org.hibernate.bytecode.instrumentation.internal.FieldInterceptionHelper;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.criterion.Projections;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.testing.jta.TestingJtaPlatformImpl;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * adapted this from "ops" tests version
  *
  * @author Gail Badner
  * @author Gavin King
  */
 public class SaveOrUpdateTest extends AbstractOperationTestCase {
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 		cfg.setProperty( Environment.STATEMENT_BATCH_SIZE, "0" );
 	}
 
 	public String[] getMappings() {
 		return new String[] { "nonflushedchanges/Node.hbm.xml" };
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testSaveOrUpdateDeepTree() throws Exception {
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Node root = new Node( "root" );
 		Node child = new Node( "child" );
 		Node grandchild = new Node( "grandchild" );
 		root.addChild( child );
 		child.addChild( grandchild );
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( Node ) getOldToNewEntityRefMap().get( root );
 		child = ( Node ) getOldToNewEntityRefMap().get( child );
 		grandchild = ( Node ) getOldToNewEntityRefMap().get( grandchild );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 3 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		grandchild.setDescription( "the grand child" );
 		Node grandchild2 = new Node( "grandchild2" );
 		child.addChild( grandchild2 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( Node ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 1 );
 		clearCounts();
 
 		Node child2 = new Node( "child2" );
 		Node grandchild3 = new Node( "grandchild3" );
 		child2.addChild( grandchild3 );
 		root.addChild( child2 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.delete( grandchild );
 		s.delete( grandchild2 );
 		s.delete( grandchild3 );
 		s.delete( child );
 		s.delete( child2 );
 		s.delete( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testSaveOrUpdateDeepTreeWithGeneratedId() throws Exception {
 		boolean instrumented = FieldInterceptionHelper.isInstrumented( new NumberedNode() );
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		NumberedNode root = new NumberedNode( "root" );
 		NumberedNode child = new NumberedNode( "child" );
 		NumberedNode grandchild = new NumberedNode( "grandchild" );
 		root.addChild( child );
 		child.addChild( grandchild );
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		child = ( NumberedNode ) getOldToNewEntityRefMap().get( child );
 		grandchild = ( NumberedNode ) getOldToNewEntityRefMap().get( grandchild );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 3 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		child = ( NumberedNode ) root.getChildren().iterator().next();
 		grandchild = ( NumberedNode ) child.getChildren().iterator().next();
 		grandchild.setDescription( "the grand child" );
 		NumberedNode grandchild2 = new NumberedNode( "grandchild2" );
 		child.addChild( grandchild2 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( instrumented ? 1 : 3 );
 		clearCounts();
 
 		NumberedNode child2 = new NumberedNode( "child2" );
 		NumberedNode grandchild3 = new NumberedNode( "grandchild3" );
 		child2.addChild( grandchild3 );
 		root.addChild( child2 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( instrumented ? 0 : 4 );
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.createQuery( "delete from NumberedNode where name like 'grand%'" ).executeUpdate();
 		s.createQuery( "delete from NumberedNode where name like 'child%'" ).executeUpdate();
 		s.createQuery( "delete from NumberedNode" ).executeUpdate();
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testSaveOrUpdateTree() throws Exception {
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Node root = new Node( "root" );
 		Node child = new Node( "child" );
 		root.addChild( child );
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( Node ) getOldToNewEntityRefMap().get( root );
 		child = ( Node ) getOldToNewEntityRefMap().get( child );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 2 );
 		clearCounts();
 
 		root.setDescription( "The root node" );
 		child.setDescription( "The child node" );
 
 		Node secondChild = new Node( "second child" );
 
 		root.addChild( secondChild );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 2 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.createQuery( "delete from Node where parent is not null" ).executeUpdate();
 		s.createQuery( "delete from Node" ).executeUpdate();
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testSaveOrUpdateTreeWithGeneratedId() throws Exception {
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		NumberedNode root = new NumberedNode( "root" );
 		NumberedNode child = new NumberedNode( "child" );
 		root.addChild( child );
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		child = ( NumberedNode ) getOldToNewEntityRefMap().get( child );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 2 );
 		clearCounts();
 
 		root.setDescription( "The root node" );
 		child.setDescription( "The child node" );
 
 		NumberedNode secondChild = new NumberedNode( "second child" );
 
 		root.addChild( secondChild );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 2 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.createQuery( "delete from NumberedNode where parent is not null" ).executeUpdate();
 		s.createQuery( "delete from NumberedNode" ).executeUpdate();
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnusedAssignment", "UnnecessaryBoxing"})
 	public void testSaveOrUpdateManaged() throws Exception {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		NumberedNode root = new NumberedNode( "root" );
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		root = ( NumberedNode ) s.get( NumberedNode.class, root.getId() );
 		NumberedNode child = new NumberedNode( "child" );
 		root.addChild( child );
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		assertNull( getOldToNewEntityRefMap().get( child ) );
 		s.flush();
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		child = ( NumberedNode ) getOldToNewEntityRefMap().get( child );
 		child = ( NumberedNode ) root.getChildren().iterator().next();
 		assertTrue( s.contains( child ) );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		child = ( NumberedNode ) getOldToNewEntityRefMap().get( child );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertTrue( root.getChildren().contains( child ) );
 		assertEquals( root.getChildren().size(), 1 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		assertEquals(
 				Long.valueOf( 2 ),
 				s.createCriteria( NumberedNode.class )
 						.setProjection( Projections.rowCount() )
 						.uniqueResult()
 		);
 		s.delete( root );
 		s.delete( child );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnusedAssignment", "UnnecessaryBoxing"})
 	public void testSaveOrUpdateGot() throws Exception {
 		boolean instrumented = FieldInterceptionHelper.isInstrumented( new NumberedNode() );
 
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		NumberedNode root = new NumberedNode( "root" );
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( instrumented ? 0 : 1 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		root = ( NumberedNode ) s.get( NumberedNode.class, Long.valueOf( root.getId() ) );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		Hibernate.initialize( root.getChildren() );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		NumberedNode child = new NumberedNode( "child" );
 		root.addChild( child );
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( NumberedNode ) getOldToNewEntityRefMap().get( root );
 		assertTrue( Hibernate.isInitialized( root.getChildren() ) );
 		child = ( NumberedNode ) root.getChildren().iterator().next();
 		assertTrue( s.contains( child ) );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( instrumented ? 0 : 1 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		assertEquals(
 				s.createCriteria( NumberedNode.class )
 						.setProjection( Projections.rowCount() )
 						.uniqueResult(),
 				new Long( 2 )
 		);
 		s.delete( root );
 		s.delete( child );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnusedAssignment", "UnnecessaryBoxing"})
 	public void testSaveOrUpdateGotWithMutableProp() throws Exception {
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Node root = new Node( "root" );
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( Node ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 1 );
 		assertUpdateCount( 0 );
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( Node ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( 0 );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		root = ( Node ) s.get( Node.class, "root" );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( Node ) getOldToNewEntityRefMap().get( root );
 		Hibernate.initialize( root.getChildren() );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( Node ) getOldToNewEntityRefMap().get( root );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		clearCounts();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		Node child = new Node( "child" );
 		root.addChild( child );
 		s.saveOrUpdate( root );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( Node ) getOldToNewEntityRefMap().get( root );
 		child = ( Node ) root.getChildren().iterator().next();
 		assertTrue( s.contains( child ) );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		root = ( Node ) getOldToNewEntityRefMap().get( root );
 		child = ( Node ) getOldToNewEntityRefMap().get( child );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		assertInsertCount( 1 );
 		//assertUpdateCount( 1 ); //note: will fail here if no second-level cache
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		assertEquals(
 				Long.valueOf( 2 ),
 				s.createCriteria( Node.class )
 						.setProjection( Projections.rowCount() )
 						.uniqueResult()
 		);
 		s.delete( root );
 		s.delete( child );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedAssignment"})
 	public void testEvictThenSaveOrUpdate() throws Exception {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s = openSession();
 		Node parent = new Node( "1:parent" );
 		Node child = new Node( "2:child" );
 		Node grandchild = new Node( "3:grandchild" );
 		parent.addChild( child );
 		child.addChild( grandchild );
 		s.saveOrUpdate( parent );
 		s = applyNonFlushedChangesToNewSessionCloseOldSession( s );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s1 = openSession();
 		child = ( Node ) s1.load( Node.class, "2:child" );
 		s1 = applyNonFlushedChangesToNewSessionCloseOldSession( s1 );
 		child = ( Node ) getOldToNewEntityRefMap().get( child );
 		assertTrue( s1.contains( child ) );
 		assertFalse( Hibernate.isInitialized( child ) );
 		assertTrue( s1.contains( child.getParent() ) );
 		assertTrue( Hibernate.isInitialized( child ) );
 		assertFalse( Hibernate.isInitialized( child.getChildren() ) );
 		assertFalse( Hibernate.isInitialized( child.getParent() ) );
 		assertTrue( s1.contains( child ) );
 		s1 = applyNonFlushedChangesToNewSessionCloseOldSession( s1 );
 		// child is an initialized proxy; after serialization, it is
 		// the proxy is replaced by its implementation
 		// TODO: find out if this is how this should work...
 		child = ( Node ) getOldToNewEntityRefMap().get(
 				( ( HibernateProxy ) child ).getHibernateLazyInitializer().getImplementation()
 		);
 		s1.evict( child );
 		assertFalse( s1.contains( child ) );
 		assertTrue( s1.contains( child.getParent() ) );
 
 		javax.transaction.Transaction tx1 = TestingJtaPlatformImpl.INSTANCE.getTransactionManager().suspend();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		Session s2 = openSession();
 		try {
 			s2.getTransaction().begin();
 			s2.saveOrUpdate( child );
 			fail();
 		}
 		catch ( HibernateException ex ) {
 			// expected because parent is connected to s1
 		}
 		finally {
 			TestingJtaPlatformImpl.INSTANCE.getTransactionManager().rollback();
 		}
 
 		s1.evict( child.getParent() );
 		assertFalse( s1.contains( child.getParent() ) );
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s2 = openSession();
  		s2.saveOrUpdate( child );
 		s2 = applyNonFlushedChangesToNewSessionCloseOldSession( s2 );
 		child = ( Node ) getOldToNewEntityRefMap().get( child );
 		assertTrue( s2.contains( child ) );
 		assertFalse( s1.contains( child ) );
 		assertTrue( s2.contains( child.getParent() ) );
 		assertFalse( s1.contains( child.getParent() ) );
 		assertFalse( Hibernate.isInitialized( child.getChildren() ) );
 		assertFalse( Hibernate.isInitialized( child.getParent() ) );
 		assertEquals( 1, child.getChildren().size() );
 		assertEquals( "1:parent", child.getParent().getName() );
 		assertTrue( Hibernate.isInitialized( child.getChildren() ) );
 		assertFalse( Hibernate.isInitialized( child.getParent() ) );
 		assertNull( child.getParent().getDescription() );
 		assertTrue( Hibernate.isInitialized( child.getParent() ) );
 		s1 = applyNonFlushedChangesToNewSessionCloseOldSession( s1 );
 		s2 = applyNonFlushedChangesToNewSessionCloseOldSession( s2 );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().resume( tx1 );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 //		tx1.commit();
 
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 		s = openSession();
 		s.delete( s.get( Node.class, "3:grandchild" ) );
 		s.delete( s.get( Node.class, "2:child" ) );
 		s.delete( s.get( Node.class, "1:parent" ) );
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 	}
 
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/onetomany/AbstractRecursiveBidirectionalOneToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/onetomany/AbstractRecursiveBidirectionalOneToManyTest.java
index 35da12cb2c..70a94b7bde 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/onetomany/AbstractRecursiveBidirectionalOneToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/onetomany/AbstractRecursiveBidirectionalOneToManyTest.java
@@ -1,193 +1,191 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.onetomany;
 
 import java.util.ArrayList;
 
 import org.junit.Test;
 
 import org.hibernate.CacheMode;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 /**
  *  What is done:
  *    ___                   ___
  *   |   |                 |   |
  *    -> 1                  -> 1
  *       |   -transform->     / \
  *       2                   2   3
  *       |
  *     	 3
  *
  * @author Burkhard Graves
  * @author Gail Badner
  */
 @SuppressWarnings( {"UnusedDeclaration"})
 public abstract class AbstractRecursiveBidirectionalOneToManyTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "onetomany/Node.hbm.xml" };
 	}
 
 	@Override
 	public Session openSession() {
 		Session s = super.openSession();
 		s.setCacheMode( getSessionCacheMode() );
 		return s;
 	}
 
 	protected abstract CacheMode getSessionCacheMode();
 
 	@Test
 	public void testOneToManyMoveElement() {
 		init();
 		transformMove();
 		check( false );
 		delete();
 	}
 
 	@Test
 	public void testOneToManyMoveElementWithDirtySimpleProperty() {
 		init();
 		transformMoveWithDirtySimpleProperty();
 		check( true );
 		delete();
 	}
 
 	@Test
 	public void testOneToManyReplaceList() {
 		init();
 		transformReplace();
 		check( false );
 		delete();
 	}
 
 	void init() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 
 		Node node1 = new Node( 1, "node1" );
 		Node node2 = new Node( 2, "node2" );
 		Node node3 = new Node( 3, "node3" );
 
 		node1.addSubNode( node2 );
 		node2.addSubNode( node3 );
 
 		s.save(node1);
 
 		tx.commit();
 		s.close();
 	}
 
 	void transformMove() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 
 		Node node3 = (Node) s.load(Node.class, new Integer(3));
 		Node node2 = node3.getParentNode();
 		Node node1 = node2.getParentNode();
 
 		node2.removeSubNode( node3 );
 		node1.addSubNode( node3 );
 
 		tx.commit();
 		s.close();
 	}
 
 	void transformMoveWithDirtySimpleProperty() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 
 		Node node3 = (Node) s.load(Node.class, new Integer(3));
 		Node node2 = node3.getParentNode();
 		Node node1 = node2.getParentNode();
 
 		node2.removeSubNode( node3 );
 		node1.addSubNode( node3 );
 		node3.setDescription( "node3-updated" );
 
 		tx.commit();
 		s.close();
 	}
 
 	void transformReplace() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 
 		Node node3 = (Node) s.load(Node.class, new Integer(3));
 		Node node2 = node3.getParentNode();
 		Node node1 = node2.getParentNode();
 
 		node2.removeSubNode( node3 );
 		node1.setSubNodes(  new ArrayList() );
 		node1.addSubNode( node2 );
 		node1.addSubNode( node3 );
 
 		tx.commit();
 		s.close();
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	void check(boolean simplePropertyUpdated) {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Node node3 = (Node) s.get( Node.class, Integer.valueOf(3) );
 
 		// fails with 2nd level cache enabled
 		assertEquals( 1, node3.getParentNode().getId().intValue() );
 		assertEquals( ( simplePropertyUpdated ? "node3-updated" : "node3" ), node3.getDescription() );
 		assertTrue( node3.getSubNodes().isEmpty() );
 
 		Node node1 = node3.getParentNode();
 		assertNull( node1.getParentNode() );
 		assertEquals( 2, node1.getSubNodes().size() );
 		assertEquals( 2, ( ( Node ) node1.getSubNodes().get( 0 ) ).getId().intValue() );
 		assertEquals( "node1", node1.getDescription() );
 
 		Node node2 = ( Node ) node1.getSubNodes().get( 0 );
 		assertSame( node1, node2.getParentNode() );
 		assertTrue( node2.getSubNodes().isEmpty() );
 		assertEquals( "node2", node2.getDescription() );
 
 		tx.commit();
 		s.close();
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	void delete() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Node node1 = ( Node ) s.get(  Node.class, Integer.valueOf( 1 ) );
 		s.delete( node1 );
 		tx.commit();
 		s.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/onetomany/AbstractVersionedRecursiveBidirectionalOneToManyTest.java b/hibernate-core/src/test/java/org/hibernate/test/onetomany/AbstractVersionedRecursiveBidirectionalOneToManyTest.java
index a4b7902b6d..97ba8d8de5 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/onetomany/AbstractVersionedRecursiveBidirectionalOneToManyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/onetomany/AbstractVersionedRecursiveBidirectionalOneToManyTest.java
@@ -1,56 +1,55 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.onetomany;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Burkhard Graves
  * @author Gail Badner
  */
 public abstract class AbstractVersionedRecursiveBidirectionalOneToManyTest extends AbstractRecursiveBidirectionalOneToManyTest {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "onetomany/VersionedNode.hbm.xml" };
 	}
 
 	@Override
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	void check(boolean simplePropertyUpdated) {
 		super.check( simplePropertyUpdated );
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Node node1 = ( Node ) s.get( Node.class, Integer.valueOf( 1 ) );
 		Node node2 = ( Node ) s.get( Node.class, Integer.valueOf( 2 ) );
 		Node node3 = ( Node ) s.get( Node.class, Integer.valueOf( 3 ) );
 		assertEquals( 1, node1.getVersion() );
 		assertEquals( 1, node2.getVersion() );
 		assertEquals( 1, node3.getVersion() );
 		tx.commit();
 		s.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/onetomany/RecursiveBidirectionalOneToManyNoCacheTest.java b/hibernate-core/src/test/java/org/hibernate/test/onetomany/RecursiveBidirectionalOneToManyNoCacheTest.java
index e60fea4b02..958fd87fe0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/onetomany/RecursiveBidirectionalOneToManyNoCacheTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/onetomany/RecursiveBidirectionalOneToManyNoCacheTest.java
@@ -1,40 +1,40 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.onetomany;
 
 import org.hibernate.CacheMode;
 
 /**
  * @author Burkhard Graves
  * @author Gail Badner
  */
 public class RecursiveBidirectionalOneToManyNoCacheTest extends AbstractRecursiveBidirectionalOneToManyTest {
 	public String getCacheConcurrencyStrategy() {
 			return null;
 	}
 	
 	protected CacheMode getSessionCacheMode() {
 			return CacheMode.IGNORE;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/ops/CreateTest.java b/hibernate-core/src/test/java/org/hibernate/test/ops/CreateTest.java
index f35a0956dc..8a266493f7 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/ops/CreateTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/ops/CreateTest.java
@@ -1,242 +1,241 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.ops;
 
 import java.util.ArrayList;
 import java.util.Collection;
 
 import org.junit.Test;
 
 import org.hibernate.PersistentObjectException;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.exception.ConstraintViolationException;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 
 /**
  * @author Gavin King
  */
 public class CreateTest extends AbstractOperationTestCase {
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testNoUpdatesOnCreateVersionedWithCollection() {
 		clearCounts();
 
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		VersionedEntity root = new VersionedEntity( "root", "root" );
 		VersionedEntity child = new VersionedEntity( "c1", "child-1" );
 		root.getChildren().add( child );
 		child.setParent( root );
 		s.save(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount( 2 );
 		assertUpdateCount( 0 );
 		assertDeleteCount( 0 );
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.delete( root );
 		tx.commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertDeleteCount( 2 );
 	}
 
 	@Test
 	public void testCreateTree() {
 		clearCounts();
 
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Node root = new Node("root");
 		Node child = new Node("child");
 		root.addChild(child);
 		s.persist(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(2);
 		assertUpdateCount(0);
 
 		s = openSession();
 		tx = s.beginTransaction();
 		System.out.println("getting");
 		root = (Node) s.get(Node.class, "root");
 		Node child2 = new Node("child2");
 		root.addChild(child2);
 		System.out.println("committing");
 		tx.commit();
 		s.close();
 
 		assertInsertCount(3);
 		assertUpdateCount(0);
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testCreateTreeWithGeneratedId() {
 		clearCounts();
 
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		NumberedNode root = new NumberedNode("root");
 		NumberedNode child = new NumberedNode("child");
 		root.addChild(child);
 		s.persist(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(2);
 		assertUpdateCount(0);
 
 		s = openSession();
 		tx = s.beginTransaction();
 		root = (NumberedNode) s.get( NumberedNode.class, Long.valueOf( root.getId() ) );
 		NumberedNode child2 = new NumberedNode("child2");
 		root.addChild(child2);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(3);
 		assertUpdateCount(0);
 	}
 
 	@Test
 	public void testCreateException() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Node dupe = new Node("dupe");
 		s.persist(dupe);
 		s.persist(dupe);
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.persist(dupe);
 		try {
 			tx.commit();
 			fail( "Expecting constraint failure" );
 		}
 		catch (ConstraintViolationException cve) {
 			//verify that an exception is thrown!
 		}
 		tx.rollback();
 		s.close();
 
 		Node nondupe = new Node("nondupe");
 		nondupe.addChild(dupe);
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.persist(nondupe);
 		try {
 			tx.commit();
 			assertFalse(true);
 		}
 		catch (ConstraintViolationException cve) {
 			//verify that an exception is thrown!
 		}
 		tx.rollback();
 		s.close();
 	}
 
 	@Test
 	public void testCreateExceptionWithGeneratedId() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		NumberedNode dupe = new NumberedNode("dupe");
 		s.persist(dupe);
 		s.persist(dupe);
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		try {
 			s.persist(dupe);
 			assertFalse(true);
 		}
 		catch (PersistentObjectException poe) {
 			//verify that an exception is thrown!
 		}
 		tx.rollback();
 		s.close();
 
 		NumberedNode nondupe = new NumberedNode("nondupe");
 		nondupe.addChild(dupe);
 
 		s = openSession();
 		tx = s.beginTransaction();
 		try {
 			s.persist(nondupe);
 			assertFalse(true);
 		}
 		catch (PersistentObjectException poe) {
 			//verify that an exception is thrown!
 		}
 		tx.rollback();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testBasic() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Employer er = new Employer();
 		Employee ee = new Employee();
 		s.persist(ee);
 		Collection erColl = new ArrayList();
 		Collection eeColl = new ArrayList();
 		erColl.add(ee);
 		eeColl.add(er);
 		er.setEmployees(erColl);
 		ee.setEmployers(eeColl);
 		tx.commit();
 		s.close();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		er = (Employer) s.load(Employer.class, er.getId() );
 		assertNotNull(er);
 		assertNotNull( er.getEmployees() );
 		assertEquals( 1, er.getEmployees().size() );
 		Employee eeFromDb = (Employee) er.getEmployees().iterator().next();
 		assertEquals( ee.getId(), eeFromDb.getId() );
 		tx.commit();
 		s.close();
 	}
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/ops/MergeTest.java b/hibernate-core/src/test/java/org/hibernate/test/ops/MergeTest.java
index f3a01eb033..00b5dba4fb 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/ops/MergeTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/ops/MergeTest.java
@@ -1,857 +1,853 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.ops;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.NonUniqueObjectException;
 import org.hibernate.Session;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.Transaction;
 import org.hibernate.criterion.Projections;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * @author Gavin King
  */
 public class MergeTest extends AbstractOperationTestCase {
 	@Test
 	public void testMergeStaleVersionFails() throws Exception {
 		Session s = openSession();
         s.beginTransaction();
 		VersionedEntity entity = new VersionedEntity( "entity", "entity" );
 		s.persist( entity );
 		s.getTransaction().commit();
 		s.close();
 
 		// make the detached 'entity' reference stale...
 		s = openSession();
         s.beginTransaction();
 		VersionedEntity entity2 = ( VersionedEntity ) s.get( VersionedEntity.class, entity.getId() );
 		entity2.setName( "entity-name" );
 		s.getTransaction().commit();
 		s.close();
 
 		// now try to reattch it
 		s = openSession();
 		s.beginTransaction();
 		try {
 			s.merge( entity );
 			s.getTransaction().commit();
 			fail( "was expecting staleness error" );
 		}
 		catch ( StaleObjectStateException expected ) {
 			// expected outcome...
 		}
 		finally {
 			s.getTransaction().rollback();
 			s.close();
 		}
 	}
 
 	@Test
 	public void testMergeBidiPrimayKeyOneToOne() throws Exception {
 		rebuildSessionFactory();
 		Session s = openSession();
         s.beginTransaction();
 		Person p = new Person( "steve" );
 		new PersonalDetails( "I have big feet", p );
 		s.persist( p );
 		s.getTransaction().commit();
 		s.close();
 
 		clearCounts();
 
 		p.getDetails().setSomePersonalDetail( p.getDetails().getSomePersonalDetail() + " and big hands too" );
 		s = openSession();
         s.beginTransaction();
 		p = ( Person ) s.merge( p );
 		s.getTransaction().commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( 1 );
 		assertDeleteCount( 0 );
 
 		s = openSession();
         s.beginTransaction();
 		s.delete( p );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testMergeBidiForeignKeyOneToOne() throws Exception {
 		Session s = openSession();
         s.beginTransaction();
 		Person p = new Person( "steve" );
 		Address a = new Address( "123 Main", "Austin", "US", p );
 		s.persist( a );
 		s.persist( p );
 		s.getTransaction().commit();
 		s.close();
 
 		clearCounts();
 
 		p.getAddress().setStreetAddress( "321 Main" );
 		s = openSession();
         s.beginTransaction();
 		p = ( Person ) s.merge( p );
 		s.getTransaction().commit();
 		s.close();
 
 		assertInsertCount( 0 );
 		assertUpdateCount( 0 ); // no cascade
 		assertDeleteCount( 0 );
 
 		s = openSession();
         s.beginTransaction();
 		s.delete( a );
 		s.delete( p );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
     @SuppressWarnings( {"UnusedAssignment"})
 	public void testNoExtraUpdatesOnMerge() throws Exception {
 		Session s = openSession();
         s.beginTransaction();
 		Node node = new Node( "test" );
 		s.persist( node );
 		s.getTransaction().commit();
 		s.close();
 
 		clearCounts();
 
 		// node is now detached, but we have made no changes.  so attempt to merge it
 		// into this new session; this should cause no updates...
 		s = openSession();
 		s.beginTransaction();
 		node = ( Node ) s.merge( node );
 		s.getTransaction().commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertInsertCount( 0 );
 
 		///////////////////////////////////////////////////////////////////////
 		// as a control measure, now update the node while it is detached and
 		// make sure we get an update as a result...
 		node.setDescription( "new description" );
 		s = openSession();
 		s.beginTransaction();
 		node = ( Node ) s.merge( node );
 		s.getTransaction().commit();
 		s.close();
 		assertUpdateCount( 1 );
 		assertInsertCount( 0 );
 		///////////////////////////////////////////////////////////////////////
 
 		cleanup();
     }
 
 	@Test
 	@SuppressWarnings( {"unchecked", "UnusedAssignment"})
 	public void testNoExtraUpdatesOnMergeWithCollection() throws Exception {
 		Session s = openSession();
         s.beginTransaction();
 		Node parent = new Node( "parent" );
 		Node child = new Node( "child" );
 		parent.getChildren().add( child );
 		child.setParent( parent );
 		s.persist( parent );
 		s.getTransaction().commit();
 		s.close();
 
 		clearCounts();
 
 		// parent is now detached, but we have made no changes.  so attempt to merge it
 		// into this new session; this should cause no updates...
 		s = openSession();
 		s.beginTransaction();
 		parent = ( Node ) s.merge( parent );
 		s.getTransaction().commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertInsertCount( 0 );
 
 		///////////////////////////////////////////////////////////////////////
 		// as a control measure, now update the node while it is detached and
 		// make sure we get an update as a result...
 		( ( Node ) parent.getChildren().iterator().next() ).setDescription( "child's new description" );
 		parent.addChild( new Node( "second child" ) );
 		s = openSession();
 		s.beginTransaction();
 		parent = ( Node ) s.merge( parent );
 		s.getTransaction().commit();
 		s.close();
 		assertUpdateCount( 1 );
 		assertInsertCount( 1 );
 		///////////////////////////////////////////////////////////////////////
 
 		cleanup();
 	}
 
 	@Test
     @SuppressWarnings( {"UnusedAssignment"})
 	public void testNoExtraUpdatesOnMergeVersioned() throws Exception {
 		Session s = openSession();
         s.beginTransaction();
 		VersionedEntity entity = new VersionedEntity( "entity", "entity" );
 		s.persist( entity );
 		s.getTransaction().commit();
 		s.close();
 
 		clearCounts();
 
 		// entity is now detached, but we have made no changes.  so attempt to merge it
 		// into this new session; this should cause no updates...
 		s = openSession();
 		s.beginTransaction();
 		VersionedEntity mergedEntity = ( VersionedEntity ) s.merge( entity );
 		s.getTransaction().commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertInsertCount( 0 );
         assertEquals( "unexpected version increment", entity.getVersion(), mergedEntity.getVersion() );
 
 
 		///////////////////////////////////////////////////////////////////////
 		// as a control measure, now update the node while it is detached and
 		// make sure we get an update as a result...
 		entity.setName( "new name" );
 		s = openSession();
 		s.beginTransaction();
 		entity = ( VersionedEntity ) s.merge( entity );
 		s.getTransaction().commit();
 		s.close();
 		assertUpdateCount( 1 );
 		assertInsertCount( 0 );
 		///////////////////////////////////////////////////////////////////////
 
 		cleanup();
     }
 
 	@Test
 	@SuppressWarnings( {"unchecked", "UnusedAssignment"})
 	public void testNoExtraUpdatesOnMergeVersionedWithCollection() throws Exception {
 		Session s = openSession();
         s.beginTransaction();
 		VersionedEntity parent = new VersionedEntity( "parent", "parent" );
 		VersionedEntity child = new VersionedEntity( "child", "child" );
 		parent.getChildren().add( child );
 		child.setParent( parent );
 		s.persist( parent );
 		s.getTransaction().commit();
 		s.close();
 
 		clearCounts();
 
 		// parent is now detached, but we have made no changes.  so attempt to merge it
 		// into this new session; this should cause no updates...
 		s = openSession();
 		s.beginTransaction();
 		VersionedEntity mergedParent = ( VersionedEntity ) s.merge( parent );
 		s.getTransaction().commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertInsertCount( 0 );
 		assertEquals( "unexpected parent version increment", parent.getVersion(), mergedParent.getVersion() );
 		VersionedEntity mergedChild = ( VersionedEntity ) mergedParent.getChildren().iterator().next();
 		assertEquals( "unexpected child version increment", child.getVersion(), mergedChild.getVersion() );
 
 		///////////////////////////////////////////////////////////////////////
 		// as a control measure, now update the node while it is detached and
 		// make sure we get an update as a result...
 		mergedParent.setName( "new name" );
 		mergedParent.getChildren().add( new VersionedEntity( "child2", "new child" ) );
 		s = openSession();
 		s.beginTransaction();
 		parent = ( VersionedEntity ) s.merge( mergedParent );
 		s.getTransaction().commit();
 		s.close();
 		assertUpdateCount( 1 );
 		assertInsertCount( 1 );
 		///////////////////////////////////////////////////////////////////////
 
 		cleanup();
     }
 
 	@Test
 	@SuppressWarnings( {"unchecked", "UnusedAssignment", "UnusedDeclaration"})
 	public void testNoExtraUpdatesOnPersistentMergeVersionedWithCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		VersionedEntity parent = new VersionedEntity( "parent", "parent" );
 		VersionedEntity child = new VersionedEntity( "child", "child" );
 		parent.getChildren().add( child );
 		child.setParent( parent );
 		s.persist( parent );
 		s.getTransaction().commit();
 		s.close();
 
 		clearCounts();
 
 		// parent is now detached, but we have made no changes. so attempt to merge it
 		// into this new session; this should cause no updates...
 		s = openSession();
 		s.beginTransaction();
 		// load parent so that merge will follow entityIsPersistent path
 		VersionedEntity persistentParent = ( VersionedEntity ) s.get( VersionedEntity.class, parent.getId() );
 		// load children
 		VersionedEntity persistentChild = ( VersionedEntity ) persistentParent.getChildren().iterator().next();
 		VersionedEntity mergedParent = ( VersionedEntity ) s.merge( persistentParent ); // <-- This merge leads to failure
 		s.getTransaction().commit();
 		s.close();
 
 		assertUpdateCount( 0 );
 		assertInsertCount( 0 );
 		assertEquals( "unexpected parent version increment", parent.getVersion(), mergedParent.getVersion() );
 		VersionedEntity mergedChild = ( VersionedEntity ) mergedParent.getChildren().iterator().next();
 		assertEquals( "unexpected child version increment", child.getVersion(), mergedChild.getVersion() );
 
 		///////////////////////////////////////////////////////////////////////
 		// as a control measure, now update the node once it is loaded and
 		// make sure we get an update as a result...
 		s = openSession();
 		s.beginTransaction();
 		persistentParent = ( VersionedEntity ) s.get( VersionedEntity.class, parent.getId() );
 		persistentParent.setName( "new name" );
 		persistentParent.getChildren().add( new VersionedEntity( "child2", "new child" ) );
 		persistentParent = ( VersionedEntity ) s.merge( persistentParent );
 		s.getTransaction().commit();
 		s.close();
 		assertUpdateCount( 1 );
 		assertInsertCount( 1 );
 		///////////////////////////////////////////////////////////////////////
 
 		// cleanup();
 	}
 
 	@Test
 	public void testPersistThenMergeInSameTxnWithVersion() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		VersionedEntity entity = new VersionedEntity( "test", "test" );
 		s.persist( entity );
 		s.merge( new VersionedEntity( "test", "test-2" ) );
 
 		try {
 			// control operation...
 			s.saveOrUpdate( new VersionedEntity( "test", "test-3" ) );
 			fail( "saveOrUpdate() should fail here" );
 		}
 		catch( NonUniqueObjectException expected ) {
 			// expected behavior
 		}
 
 		tx.commit();
 		s.close();
 
 		cleanup();
 	}
 
 	@Test
 	public void testPersistThenMergeInSameTxnWithTimestamp() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		TimestampedEntity entity = new TimestampedEntity( "test", "test" );
 		s.persist( entity );
 		s.merge( new TimestampedEntity( "test", "test-2" ) );
 
 		try {
 			// control operation...
 			s.saveOrUpdate( new TimestampedEntity( "test", "test-3" ) );
 			fail( "saveOrUpdate() should fail here" );
 		}
 		catch( NonUniqueObjectException expected ) {
 			// expected behavior
 		}
 
 		tx.commit();
 		s.close();
 
 		cleanup();
 	}
 
 	@Test
 	public void testMergeDeepTree() {
 		clearCounts();
 
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Node root = new Node("root");
 		Node child = new Node("child");
 		Node grandchild = new Node("grandchild");
 		root.addChild(child);
 		child.addChild(grandchild);
 		s.merge(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(3);
 		assertUpdateCount(0);
 		clearCounts();
 
 		grandchild.setDescription("the grand child");
 		Node grandchild2 = new Node("grandchild2");
 		child.addChild( grandchild2 );
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.merge(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(1);
 		assertUpdateCount(1);
 		clearCounts();
 
 		Node child2 = new Node("child2");
 		Node grandchild3 = new Node("grandchild3");
 		child2.addChild( grandchild3 );
 		root.addChild(child2);
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.merge(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(2);
 		assertUpdateCount(0);
 		clearCounts();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.delete(grandchild);
 		s.delete(grandchild2);
 		s.delete(grandchild3);
 		s.delete(child);
 		s.delete(child2);
 		s.delete(root);
 		tx.commit();
 		s.close();
 
 	}
 
 	@SuppressWarnings( {"UnusedAssignment"})
 	@Test
 	public void testMergeDeepTreeWithGeneratedId() {
 		clearCounts();
 
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		NumberedNode root = new NumberedNode("root");
 		NumberedNode child = new NumberedNode("child");
 		NumberedNode grandchild = new NumberedNode("grandchild");
 		root.addChild(child);
 		child.addChild(grandchild);
 		root = (NumberedNode) s.merge(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(3);
 		assertUpdateCount(0);
 		clearCounts();
 
 		child = (NumberedNode) root.getChildren().iterator().next();
 		grandchild = (NumberedNode) child.getChildren().iterator().next();
 		grandchild.setDescription("the grand child");
 		NumberedNode grandchild2 = new NumberedNode("grandchild2");
 		child.addChild( grandchild2 );
 
 		s = openSession();
 		tx = s.beginTransaction();
 		root = (NumberedNode) s.merge(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(1);
 		assertUpdateCount(1);
 		clearCounts();
 
 		sessionFactory().getCache().evictEntityRegion( NumberedNode.class );
 
 		NumberedNode child2 = new NumberedNode("child2");
 		NumberedNode grandchild3 = new NumberedNode("grandchild3");
 		child2.addChild( grandchild3 );
 		root.addChild(child2);
 
 		s = openSession();
 		tx = s.beginTransaction();
 		root = (NumberedNode) s.merge( root );
 		tx.commit();
 		s.close();
 
 		assertInsertCount(2);
 		assertUpdateCount(0);
 		clearCounts();
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.createQuery("delete from NumberedNode where name like 'grand%'").executeUpdate();
 		s.createQuery("delete from NumberedNode where name like 'child%'").executeUpdate();
 		s.createQuery("delete from NumberedNode").executeUpdate();
 		tx.commit();
 		s.close();
 	}
 
 	@Test
 	public void testMergeTree() {
 		clearCounts();
 
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Node root = new Node("root");
 		Node child = new Node("child");
 		root.addChild(child);
 		s.persist(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(2);
 		clearCounts();
 
 		root.setDescription("The root node");
 		child.setDescription("The child node");
 
 		Node secondChild = new Node("second child");
 
 		root.addChild(secondChild);
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.merge(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(1);
 		assertUpdateCount(2);
 
 		cleanup();
 	}
 
 	@Test
 	public void testMergeTreeWithGeneratedId() {
 		clearCounts();
 
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		NumberedNode root = new NumberedNode("root");
 		NumberedNode child = new NumberedNode("child");
 		root.addChild(child);
 		s.persist(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(2);
 		clearCounts();
 
 		root.setDescription("The root node");
 		child.setDescription("The child node");
 
 		NumberedNode secondChild = new NumberedNode("second child");
 
 		root.addChild(secondChild);
 
 		s = openSession();
 		tx = s.beginTransaction();
 		s.merge(root);
 		tx.commit();
 		s.close();
 
 		assertInsertCount(1);
 		assertUpdateCount(2);
 
 		cleanup();
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	@Test
 	public void testMergeManaged() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		NumberedNode root = new NumberedNode("root");
 		s.persist(root);
 		tx.commit();
 
 		clearCounts();
 
 		tx = s.beginTransaction();
 		NumberedNode child = new NumberedNode("child");
 		root.addChild(child);
 		assertSame( root, s.merge(root) );
 		Object mergedChild = root.getChildren().iterator().next();
 		assertNotSame( mergedChild, child );
 		assertTrue( s.contains(mergedChild) );
 		assertFalse( s.contains(child) );
 		assertEquals( root.getChildren().size(), 1 );
 		assertTrue( root.getChildren().contains(mergedChild) );
 		//assertNotSame( mergedChild, s.merge(child) ); //yucky :(
 		tx.commit();
 
 		assertInsertCount(1);
 		assertUpdateCount(0);
 
 		assertEquals( root.getChildren().size(), 1 );
 		assertTrue( root.getChildren().contains(mergedChild) );
 
 		s.beginTransaction();
 		assertEquals(
 				Long.valueOf( 2 ),
 				s.createCriteria( NumberedNode.class )
 						.setProjection( Projections.rowCount() )
 						.uniqueResult()
 		);
 		s.getTransaction().commit();
 		s.close();
 
 		cleanup();
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	@Test
 	public void testMergeManagedUninitializedCollection() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		NumberedNode root = new NumberedNode( "root" );
 		root.addChild( new NumberedNode( "child" ) );
 		s.persist(root);
 		tx.commit();
 		s.close();
 
 		clearCounts();
 
 		NumberedNode newRoot = new NumberedNode( "root" );
 		newRoot.setId( root.getId() );
 
 		s = openSession();
 		tx = s.beginTransaction();
 		root = ( NumberedNode ) s.get( NumberedNode.class, root.getId() );
 		Set managedChildren = root.getChildren();
 		assertFalse( Hibernate.isInitialized( managedChildren ) );
 		newRoot.setChildren( managedChildren );
 		assertSame( root, s.merge( newRoot ) );
 		assertSame( managedChildren, root.getChildren() );
 		assertFalse( Hibernate.isInitialized( managedChildren ) );
 		tx.commit();
 
 		assertInsertCount(0);
 		assertUpdateCount(0);
 		assertDeleteCount(0);
 
 		tx = s.beginTransaction();
 		assertEquals(
 				Long.valueOf( 2 ),
 				s.createCriteria(NumberedNode.class)
 						.setProjection( Projections.rowCount() )
 						.uniqueResult()
 		);
 		tx.commit();
 
 		s.close();
 
 		cleanup();
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	@Test
 	public void testMergeManagedInitializedCollection() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		NumberedNode root = new NumberedNode( "root" );
 		root.addChild( new NumberedNode( "child" ) );
 		s.persist(root);
 		tx.commit();
 		s.close();
 
 		clearCounts();
 
 		NumberedNode newRoot = new NumberedNode( "root" );
 		newRoot.setId( root.getId() );
 
 		s = openSession();
 		tx = s.beginTransaction();
 		root = ( NumberedNode ) s.get( NumberedNode.class, root.getId() );
 		Set managedChildren = root.getChildren();
 		Hibernate.initialize( managedChildren );
 		assertTrue( Hibernate.isInitialized( managedChildren ) );
 		newRoot.setChildren( managedChildren );
 		assertSame( root, s.merge( newRoot ) );
 		assertSame( managedChildren, root.getChildren() );
 		assertTrue( Hibernate.isInitialized( managedChildren ) );
 		tx.commit();
 
 		assertInsertCount(0);
 		assertUpdateCount(0);
 		assertDeleteCount(0);
 
 		tx = s.beginTransaction();
 		assertEquals(
 				Long.valueOf( 2 ),
 				s.createCriteria(NumberedNode.class)
 						.setProjection( Projections.rowCount() )
 						.uniqueResult()
 		);
 		tx.commit();
 
 		s.close();
 
 		cleanup();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testRecursiveMergeTransient() {
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Employer jboss = new Employer();
 		Employee gavin = new Employee();
 		jboss.setEmployees( new ArrayList() );
 		jboss.getEmployees().add(gavin);
 		s.merge(jboss);
 		s.flush();
 		jboss = (Employer) s.createQuery("from Employer e join fetch e.employees").uniqueResult();
 		assertTrue( Hibernate.isInitialized( jboss.getEmployees() )  );
 		assertEquals( 1, jboss.getEmployees().size() );
 		s.clear();
 		s.merge( jboss.getEmployees().iterator().next() );
 		tx.commit();
 		s.close();
 
 		cleanup();
 	}
 
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	@Test
 	public void testDeleteAndMerge() throws Exception {
 		Session s = openSession();
 		s.getTransaction().begin();
 		Employer jboss = new Employer();
 		s.persist( jboss );
 		s.getTransaction().commit();
 		s.clear();
 
 		s.getTransaction().begin();
 		Employer otherJboss;
 		otherJboss = (Employer) s.get( Employer.class, jboss.getId() );
 		s.delete( otherJboss );
 		s.getTransaction().commit();
 		s.clear();
 		jboss.setVers( Integer.valueOf( 1 ) );
 		s.getTransaction().begin();
 		s.merge( jboss );
 		s.getTransaction().commit();
 		s.close();
 
 		cleanup();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testMergeManyToManyWithCollectionDeference() throws Exception {
 		// setup base data...
 		Session s = openSession();
 		Transaction tx = s.beginTransaction();
 		Competition competition = new Competition();
 		competition.getCompetitors().add( new Competitor( "Name" ) );
 		competition.getCompetitors().add( new Competitor() );
 		competition.getCompetitors().add( new Competitor() );
 		s.persist( competition );
 		tx.commit();
 		s.close();
 
 		// the competition graph is now detached:
 		//   1) create a new List reference to represent the competitors
 		s = openSession();
 		tx = s.beginTransaction();
 		List newComp = new ArrayList();
 		Competitor originalCompetitor = ( Competitor ) competition.getCompetitors().get( 0 );
 		originalCompetitor.setName( "Name2" );
 		newComp.add( originalCompetitor );
 		newComp.add( new Competitor() );
 		//   2) set that new List reference unto the Competition reference
 		competition.setCompetitors( newComp );
 		//   3) attempt the merge
 		Competition competition2 = ( Competition ) s.merge( competition );
 		tx.commit();
 		s.close();
 
 		assertFalse( competition == competition2 );
 		assertFalse( competition.getCompetitors() == competition2.getCompetitors() );
 		assertEquals( 2, competition2.getCompetitors().size() );
 
 		s = openSession();
 		tx = s.beginTransaction();
 		competition = ( Competition ) s.get( Competition.class, competition.getId() );
 		assertEquals( 2, competition.getCompetitors().size() );
 		s.delete( competition );
 		tx.commit();
 		s.close();
 
 		cleanup();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	private void cleanup() {
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete from NumberedNode where parent is not null" ).executeUpdate();
 		s.createQuery( "delete from NumberedNode" ).executeUpdate();
 
 		s.createQuery( "delete from Node where parent is not null" ).executeUpdate();
 		s.createQuery( "delete from Node" ).executeUpdate();
 
 		s.createQuery( "delete from VersionedEntity where parent is not null" ).executeUpdate();
 		s.createQuery( "delete from VersionedEntity" ).executeUpdate();
 		s.createQuery( "delete from TimestampedEntity" ).executeUpdate();
 
 		s.createQuery( "delete from Competitor" ).executeUpdate();
 		s.createQuery( "delete from Competition" ).executeUpdate();
 
 		for ( Employer employer : (List<Employer>) s.createQuery( "from Employer" ).list() ) {
 			s.delete( employer );
 		}
 
 		s.getTransaction().commit();
 		s.close();
 	}
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/optlock/OptimisticLockTest.java b/hibernate-core/src/test/java/org/hibernate/test/optlock/OptimisticLockTest.java
index d4abb8e636..5c236d1a80 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/optlock/OptimisticLockTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/optlock/OptimisticLockTest.java
@@ -1,202 +1,201 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.optlock;
 
 
 import org.junit.Test;
 
 import org.hibernate.JDBCException;
 import org.hibernate.Session;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.StaleStateException;
 import org.hibernate.dialect.SQLServerDialect;
 import org.hibernate.testing.DialectChecks;
 import org.hibernate.testing.RequiresDialectFeature;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.fail;
 
 /**
  * Tests relating to the optimistic-lock mapping option.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 @RequiresDialectFeature(
 		value = DialectChecks.DoesRepeatableReadNotCauseReadersToBlockWritersCheck.class,
 		comment = "potential deadlock"
 )
 public class OptimisticLockTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "optlock/Document.hbm.xml" };
 	}
 	
 	@Test
 	public void testOptimisticLockDirty() {
 		testUpdateOptimisticLockFailure( "LockDirty" );
 	}
 
 	@Test
 	public void testOptimisticLockAll() {
 		testUpdateOptimisticLockFailure( "LockAll" );
 	}
 
 	@Test
 	public void testOptimisticLockDirtyDelete() {
 		testDeleteOptimisticLockFailure( "LockDirty" );
 	}
 
 	@Test
 	public void testOptimisticLockAllDelete() {
 		testDeleteOptimisticLockFailure( "LockAll" );
 	}
 
 	private void testUpdateOptimisticLockFailure(String entityName) {
 		Session mainSession = openSession();
 		mainSession.beginTransaction();
 		Document doc = new Document();
 		doc.setTitle( "Hibernate in Action" );
 		doc.setAuthor( "Bauer et al" );
 		doc.setSummary( "Very boring book about persistence" );
 		doc.setText( "blah blah yada yada yada" );
 		doc.setPubDate( new PublicationDate( 2004 ) );
 		mainSession.save( entityName, doc );
 		mainSession.getTransaction().commit();
 		mainSession.close();
 
 		mainSession = openSession();
 		mainSession.beginTransaction();
 		doc = ( Document ) mainSession.get( entityName, doc.getId() );
 
 		Session otherSession = sessionFactory().openSession();
 		otherSession.beginTransaction();
 		Document otherDoc = ( Document ) otherSession.get( entityName, doc.getId() );
 		otherDoc.setSummary( "A modern classic" );
 		otherSession.getTransaction().commit();
 		otherSession.close();
 
 		try {
 			doc.setSummary( "A machiavellian achievement of epic proportions" );
 			mainSession.flush();
 			fail( "expecting opt lock failure" );
 		}
 		catch ( StaleObjectStateException expected ) {
 			// expected result...
 		}
 		catch( StaleStateException expected ) {
 			// expected result (if using versioned batching)...
 		}
 		catch( JDBCException e ) {
 			// SQLServer will report this condition via a SQLException
 			// when using its SNAPSHOT transaction isolation...
 			if ( ! ( getDialect() instanceof SQLServerDialect && e.getErrorCode() == 3960 ) ) {
 				throw e;
 			}
 			else {
 				// it seems to "lose track" of the transaction as well...
 				mainSession.getTransaction().rollback();
 				mainSession.beginTransaction();
 			}
 		}
 		mainSession.clear();
 		mainSession.getTransaction().commit();
 		mainSession.close();
 
 		mainSession = openSession();
 		mainSession.beginTransaction();
 		doc = ( Document ) mainSession.load( entityName, doc.getId() );
 		mainSession.delete( entityName, doc );
 		mainSession.getTransaction().commit();
 		mainSession.close();
 	}
 
-	@SuppressWarnings({ "UnnecessaryBoxing" })
 	private void testDeleteOptimisticLockFailure(String entityName) {
 		Session mainSession = openSession();
 		mainSession.beginTransaction();
 		Document doc = new Document();
 		doc.setTitle( "Hibernate in Action" );
 		doc.setAuthor( "Bauer et al" );
 		doc.setSummary( "Very boring book about persistence" );
 		doc.setText( "blah blah yada yada yada" );
 		doc.setPubDate( new PublicationDate( 2004 ) );
 		mainSession.save( entityName, doc );
 		mainSession.flush();
 		doc.setSummary( "A modern classic" );
 		mainSession.flush();
 		doc.getPubDate().setMonth( Integer.valueOf( 3 ) );
 		mainSession.flush();
 		mainSession.getTransaction().commit();
 		mainSession.close();
 
 		mainSession = openSession();
 		mainSession.beginTransaction();
 		doc = ( Document ) mainSession.get( entityName, doc.getId() );
 
 		Session otherSession = openSession();
 		otherSession.beginTransaction();
 		Document otherDoc = ( Document ) otherSession.get( entityName, doc.getId() );
 		otherDoc.setSummary( "my other summary" );
 		otherSession.flush();
 		otherSession.getTransaction().commit();
 		otherSession.close();
 
 		try {
 			mainSession.delete( doc );
 			mainSession.flush();
 			fail( "expecting opt lock failure" );
 		}
 		catch ( StaleObjectStateException e ) {
 			// expected
 		}
 		catch( StaleStateException expected ) {
 			// expected result (if using versioned batching)...
 		}
 		catch( JDBCException e ) {
 			// SQLServer will report this condition via a SQLException
 			// when using its SNAPSHOT transaction isolation...
 			if ( ! ( getDialect() instanceof SQLServerDialect && e.getErrorCode() == 3960 ) ) {
 				throw e;
 			}
 			else {
 				// it seems to "lose track" of the transaction as well...
 				mainSession.getTransaction().rollback();
 				mainSession.beginTransaction();
 			}
 		}
 		mainSession.clear();
 		mainSession.getTransaction().commit();
 		mainSession.close();
 
 		mainSession = openSession();
 		mainSession.beginTransaction();
 		doc = ( Document ) mainSession.load( entityName, doc.getId() );
 		mainSession.delete( entityName, doc );
 		mainSession.getTransaction().commit();
 		mainSession.close();
 	}
 
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/bidirectional/DeleteOneToOneOrphansTest.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/bidirectional/DeleteOneToOneOrphansTest.java
index 18a8cf33a4..b455adbad8 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/bidirectional/DeleteOneToOneOrphansTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/bidirectional/DeleteOneToOneOrphansTest.java
@@ -1,94 +1,94 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.fk.bidirectional;
 
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 
 /**
  * @author Steve Ebersole
  */
 public class DeleteOneToOneOrphansTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "orphan/one2one/fk/bidirectional/Mapping.hbm.xml" };
 	}
 
 	private void createData() {
 		Session session = openSession();
 		session.beginTransaction();
 		Employee emp = new Employee();
 		emp.setInfo( new EmployeeInfo( emp ) );
 		session.save( emp );
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	private void cleanupData() {
 		Session session = openSession();
 		session.beginTransaction();
 		session.createQuery( "delete EmployeeInfo" ).executeUpdate();
 		session.createQuery( "delete Employee" ).executeUpdate();
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	@Test
 	public void testOrphanedWhileManaged() {
 		createData();
 
 		Session session = openSession();
 		session.beginTransaction();
 		List results = session.createQuery( "from EmployeeInfo" ).list();
 		assertEquals( 1, results.size() );
 		results = session.createQuery( "from Employee" ).list();
 		assertEquals( 1, results.size() );
 		Employee emp = ( Employee ) results.get( 0 );
 		assertNotNull( emp.getInfo() );
 		emp.setInfo( null );
 		session.getTransaction().commit();
 		session.close();
 
 		session = openSession();
 		session.beginTransaction();
 		emp = ( Employee ) session.get( Employee.class, emp.getId() );
 		assertNull( emp.getInfo() );
 		results = session.createQuery( "from EmployeeInfo" ).list();
 		assertEquals( 0, results.size() );
 		results = session.createQuery( "from Employee" ).list();
 		assertEquals( 1, results.size() );
 		session.getTransaction().commit();
 		session.close();
 
 		cleanupData();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/bidirectional/Employee.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/bidirectional/Employee.java
index 7bc5ca7318..752078b7b8 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/bidirectional/Employee.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/bidirectional/Employee.java
@@ -1,51 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.fk.bidirectional;
 
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class Employee {
 	private Long id;
 	private EmployeeInfo info;
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public EmployeeInfo getInfo() {
 		return info;
 	}
 
 	public void setInfo(EmployeeInfo info) {
 		this.info = info;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/bidirectional/EmployeeInfo.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/bidirectional/EmployeeInfo.java
index acf49d827e..af02c3f45e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/bidirectional/EmployeeInfo.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/bidirectional/EmployeeInfo.java
@@ -1,58 +1,58 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.fk.bidirectional;
 
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class EmployeeInfo {
 	private Long id;
 	private Employee employee;
 
 	public EmployeeInfo() {
 	}
 
 	public EmployeeInfo(Employee employee) {
 		this.employee = employee;
 	}
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public Employee getEmployee() {
 		return employee;
 	}
 
 	public void setEmployee(Employee employee) {
 		this.employee = employee;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/composite/DeleteOneToOneOrphansTest.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/composite/DeleteOneToOneOrphansTest.java
index eff8102af5..25859be101 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/composite/DeleteOneToOneOrphansTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/composite/DeleteOneToOneOrphansTest.java
@@ -1,94 +1,94 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.fk.composite;
 
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 
 /**
  * @author Steve Ebersole
  */
 public class DeleteOneToOneOrphansTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "orphan/one2one/fk/composite/Mapping.hbm.xml" };
 	}
 
 	private void createData() {
 		Session session = openSession();
 		session.beginTransaction();
 		Employee emp = new Employee();
 		emp.setInfo( new EmployeeInfo( 1L, 1L) );
 		session.save( emp );
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	private void cleanupData() {
 		Session session = openSession();
 		session.beginTransaction();
 		session.createQuery( "delete EmployeeInfo" ).executeUpdate();
 		session.createQuery( "delete Employee" ).executeUpdate();
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	@Test
 	public void testOrphanedWhileManaged() {
 		createData();
 
 		Session session = openSession();
 		session.beginTransaction();
 		List results = session.createQuery( "from EmployeeInfo" ).list();
 		assertEquals( 1, results.size() );
 		results = session.createQuery( "from Employee" ).list();
 		assertEquals( 1, results.size() );
 		Employee emp = ( Employee ) results.get( 0 );
 		assertNotNull( emp.getInfo() );
 		emp.setInfo( null );
 		session.getTransaction().commit();
 		session.close();
 
 		session = openSession();
 		session.beginTransaction();
 		emp = ( Employee ) session.get( Employee.class, emp.getId() );
 		assertNull( emp.getInfo() );
 		results = session.createQuery( "from EmployeeInfo" ).list();
 		assertEquals( 0, results.size() );
 		results = session.createQuery( "from Employee" ).list();
 		assertEquals( 1, results.size() );
 		session.getTransaction().commit();
 		session.close();
 
 		cleanupData();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/composite/Employee.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/composite/Employee.java
index b50f920f67..45919e48af 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/composite/Employee.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/composite/Employee.java
@@ -1,51 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.fk.composite;
 
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class Employee {
 	private Long id;
 	private EmployeeInfo info;
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public EmployeeInfo getInfo() {
 		return info;
 	}
 
 	public void setInfo(EmployeeInfo info) {
 		this.info = info;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/composite/EmployeeInfo.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/composite/EmployeeInfo.java
index 61ee6c153c..12bbfafe6f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/composite/EmployeeInfo.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/composite/EmployeeInfo.java
@@ -1,105 +1,105 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.fk.composite;
 import java.io.Serializable;
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class EmployeeInfo {
 	public static class Id implements Serializable {
 		private Long companyId;
 		private Long personId;
 
 		public Id() {
 		}
 
 		public Id(Long companyId, Long personId) {
 			this.companyId = companyId;
 			this.personId = personId;
 		}
 
 		public Long getCompanyId() {
 			return companyId;
 		}
 
 		public void setCompanyId(Long companyId) {
 			this.companyId = companyId;
 		}
 
 		public Long getPersonId() {
 			return personId;
 		}
 
 		public void setPersonId(Long personId) {
 			this.personId = personId;
 		}
 
 		@Override
 		public boolean equals(Object o) {
 			if ( this == o ) {
 				return true;
 			}
 			if ( o == null || getClass() != o.getClass() ) {
 				return false;
 			}
 
 			Id id = (Id) o;
 
 			return companyId.equals( id.companyId )
 					&& personId.equals( id.personId );
 
 		}
 
 		@Override
 		public int hashCode() {
 			int result = companyId.hashCode();
 			result = 31 * result + personId.hashCode();
 			return result;
 		}
 	}
 
 	private Id id;
 
 	public EmployeeInfo() {
 	}
 
 	public EmployeeInfo(Long companyId, Long personId) {
 		this( new Id( companyId, personId ) );
 	}
 
 	public EmployeeInfo(Id id) {
 		this.id = id;
 	}
 
 	public Id getId() {
 		return id;
 	}
 
 	public void setId(Id id) {
 		this.id = id;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/bidirectional/DeleteOneToOneOrphansTest.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/bidirectional/DeleteOneToOneOrphansTest.java
index 516fae7382..a55a0ee55e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/bidirectional/DeleteOneToOneOrphansTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/bidirectional/DeleteOneToOneOrphansTest.java
@@ -1,93 +1,93 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.fk.reversed.bidirectional;
 
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 
 /**
  * @author Steve Ebersole
  */
 public class DeleteOneToOneOrphansTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] { "orphan/one2one/fk/reversed/bidirectional/Mapping.hbm.xml" };
 	}
 
 	private void createData() {
 		Session session = openSession();
 		session.beginTransaction();
 		Employee emp = new Employee();
 		emp.setInfo( new EmployeeInfo( emp ) );
 		session.save( emp );
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	private void cleanupData() {
 		Session session = openSession();
 		session.beginTransaction();
 		session.createQuery( "delete EmployeeInfo" ).executeUpdate();
 		session.createQuery( "delete Employee" ).executeUpdate();
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	@Test
 	public void testOrphanedWhileManaged() {
 		createData();
 
 		Session session = openSession();
 		session.beginTransaction();
 		List results = session.createQuery( "from EmployeeInfo" ).list();
 		assertEquals( 1, results.size() );
 		results = session.createQuery( "from Employee" ).list();
 		assertEquals( 1, results.size() );
 		Employee emp = ( Employee ) results.get( 0 );
 		assertNotNull( emp.getInfo() );
 		emp.setInfo( null );
 		session.getTransaction().commit();
 		session.close();
 
 		session = openSession();
 		session.beginTransaction();
 		emp = ( Employee ) session.get( Employee.class, emp.getId() );
 		assertNull( emp.getInfo() );
 		results = session.createQuery( "from EmployeeInfo" ).list();
 		assertEquals( 0, results.size() );
 		results = session.createQuery( "from Employee" ).list();
 		assertEquals( 1, results.size() );
 		session.getTransaction().commit();
 		session.close();
 
 		cleanupData();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/bidirectional/Employee.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/bidirectional/Employee.java
index b8b1532325..d2c628eb92 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/bidirectional/Employee.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/bidirectional/Employee.java
@@ -1,51 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.fk.reversed.bidirectional;
 
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class Employee {
 	private Long id;
 	private EmployeeInfo info;
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public EmployeeInfo getInfo() {
 		return info;
 	}
 
 	public void setInfo(EmployeeInfo info) {
 		this.info = info;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/bidirectional/EmployeeInfo.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/bidirectional/EmployeeInfo.java
index 816756eafb..40a3dbaada 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/bidirectional/EmployeeInfo.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/bidirectional/EmployeeInfo.java
@@ -1,58 +1,58 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.fk.reversed.bidirectional;
 
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class EmployeeInfo {
 	private Long id;
 	private Employee employee;
 
 	public EmployeeInfo() {
 	}
 
 	public EmployeeInfo(Employee employee) {
 		this.employee = employee;
 	}
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public Employee getEmployee() {
 		return employee;
 	}
 
 	public void setEmployee(Employee employee) {
 		this.employee = employee;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/unidirectional/DeleteOneToOneOrphansTest.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/unidirectional/DeleteOneToOneOrphansTest.java
index b7f56ad5fa..e6026c8664 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/unidirectional/DeleteOneToOneOrphansTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/unidirectional/DeleteOneToOneOrphansTest.java
@@ -1,140 +1,140 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.fk.reversed.unidirectional;
 
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.testing.FailureExpected;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 
 /**
  * @author Steve Ebersole
  */
 public class DeleteOneToOneOrphansTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] { "orphan/one2one/fk/reversed/unidirectional/Mapping.hbm.xml" };
 	}
 
 	private void createData() {
 		Session session = openSession();
 		session.beginTransaction();
 		Employee emp = new Employee();
 		emp.setInfo( new EmployeeInfo() );
 		session.save( emp );
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	private void cleanupData() {
 		Session session = openSession();
 		session.beginTransaction();
 		session.createQuery( "delete EmployeeInfo" ).executeUpdate();
 		session.createQuery( "delete Employee" ).executeUpdate();
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	@Test
 	public void testOrphanedWhileManaged() {
 		createData();
 
 		Session session = openSession();
 		session.beginTransaction();
 		List results = session.createQuery( "from EmployeeInfo" ).list();
 		assertEquals( 1, results.size() );
 		results = session.createQuery( "from Employee" ).list();
 		assertEquals( 1, results.size() );
 		Employee emp = ( Employee ) results.get( 0 );
 		assertNotNull( emp.getInfo() );
 		emp.setInfo( null );
 		session.getTransaction().commit();
 		session.close();
 
 		session = openSession();
 		session.beginTransaction();
 		emp = ( Employee ) session.get( Employee.class, emp.getId() );
 		assertNull( emp.getInfo() );
 		results = session.createQuery( "from EmployeeInfo" ).list();
 		assertEquals( 0, results.size() );
 		results = session.createQuery( "from Employee" ).list();
 		assertEquals( 1, results.size() );
 		session.getTransaction().commit();
 		session.close();
 
 		cleanupData();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-5267" )
 	public void testOrphanedWhileDetached() {
 		createData();
 
 		Session session = openSession();
 		session.beginTransaction();
 		List results = session.createQuery( "from EmployeeInfo" ).list();
 		assertEquals( 1, results.size() );
 		results = session.createQuery( "from Employee" ).list();
 		assertEquals( 1, results.size() );
 		Employee emp = ( Employee ) results.get( 0 );
 		assertNotNull( emp.getInfo() );
 
 		//only fails if the object is detached
 		session.getTransaction().commit();
 		session.close();
 		session = openSession();
 		session.beginTransaction();
 
 		emp.setInfo( null );
 
 		//save using the new session (this used to work prior to 3.5.x)
 		session.saveOrUpdate(emp);
 
 		session.getTransaction().commit();
 		session.close();
 
 		session = openSession();
 		session.beginTransaction();
 		emp = ( Employee ) session.get( Employee.class, emp.getId() );
 		assertNull( emp.getInfo() );
 		// TODO: If merge was used instead of saveOrUpdate, this would work.
 		// However, re-attachment does not currently support handling orphans.
 		// See HHH-3795
 //		results = session.createQuery( "from EmployeeInfo" ).list();
 //		assertEquals( 0, results.size() );
 		results = session.createQuery( "from Employee" ).list();
 		assertEquals( 1, results.size() );
 		session.getTransaction().commit();
 		session.close();
 
 		cleanupData();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/unidirectional/Employee.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/unidirectional/Employee.java
index 84e8b7e1d8..4d1c13d863 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/unidirectional/Employee.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/unidirectional/Employee.java
@@ -1,51 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.fk.reversed.unidirectional;
 
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class Employee {
 	private Long id;
 	private EmployeeInfo info;
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public EmployeeInfo getInfo() {
 		return info;
 	}
 
 	public void setInfo(EmployeeInfo info) {
 		this.info = info;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/unidirectional/EmployeeInfo.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/unidirectional/EmployeeInfo.java
index c61d909d2e..d003529bc8 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/unidirectional/EmployeeInfo.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/fk/reversed/unidirectional/EmployeeInfo.java
@@ -1,45 +1,45 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.fk.reversed.unidirectional;
 
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class EmployeeInfo {
 	private Long id;
 
 	public EmployeeInfo() {
 	}
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/pk/unidirectional/DeleteOneToOneOrphansTest.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/pk/unidirectional/DeleteOneToOneOrphansTest.java
index d60246cea6..00c855d46d 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/pk/unidirectional/DeleteOneToOneOrphansTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/pk/unidirectional/DeleteOneToOneOrphansTest.java
@@ -1,101 +1,101 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.pk.unidirectional;
 
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 
 /**
  * @author Steve Ebersole
  */
 public class DeleteOneToOneOrphansTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "orphan/one2one/pk/unidirectional/Mapping.hbm.xml" };
 	}
 
 	private void createData() {
 		Session session = openSession();
 		session.beginTransaction();
 		Employee emp = new Employee();
 		session.save( emp );
 		emp.setInfo( new EmployeeInfo( emp.getId() ) );
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	private void cleanupData() {
 		Session session = openSession();
 		session.beginTransaction();
 		session.createQuery( "delete EmployeeInfo" ).executeUpdate();
 		session.createQuery( "delete Employee" ).executeUpdate();
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	@Test
 	public void testOrphanedWhileManaged() {
 		createData();
 
 		Session session = openSession();
 		session.beginTransaction();
 		List results = session.createQuery( "from EmployeeInfo" ).list();
 		assertEquals( 1, results.size() );
 		results = session.createQuery( "from Employee" ).list();
 		assertEquals( 1, results.size() );
 		Employee emp = ( Employee ) results.get( 0 );
 		assertNotNull( emp.getInfo() );
 		results = session.createQuery( "from Employee e, EmployeeInfo i where e.info = i" ).list();
 		assertEquals( 1, results.size() );
 		Object [] result = ( Object [] ) results.get( 0 );
 		emp = ( Employee ) result[ 0 ];
 		assertNotNull( result[ 1 ] );
 		assertSame( emp.getInfo(), result[ 1 ] );
 		emp.setInfo( null );
 		session.getTransaction().commit();
 		session.close();
 
 		session = openSession();
 		session.beginTransaction();
 		emp = ( Employee ) session.get( Employee.class, emp.getId() );
 		assertNull( emp.getInfo() );
 		results = session.createQuery( "from EmployeeInfo" ).list();
 		assertEquals( 0, results.size() );
 		results = session.createQuery( "from Employee" ).list();
 		assertEquals( 1, results.size() );
 		session.getTransaction().commit();
 		session.close();
 
 		cleanupData();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/pk/unidirectional/Employee.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/pk/unidirectional/Employee.java
index c0a538e8a7..68c4f55fce 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/pk/unidirectional/Employee.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/pk/unidirectional/Employee.java
@@ -1,51 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.pk.unidirectional;
 
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class Employee {
 	private Long id;
 	private EmployeeInfo info;
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public EmployeeInfo getInfo() {
 		return info;
 	}
 
 	public void setInfo(EmployeeInfo info) {
 		this.info = info;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/pk/unidirectional/EmployeeInfo.java b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/pk/unidirectional/EmployeeInfo.java
index 552b7f43a8..87f566f81e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/pk/unidirectional/EmployeeInfo.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/orphan/one2one/pk/unidirectional/EmployeeInfo.java
@@ -1,49 +1,49 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.orphan.one2one.pk.unidirectional;
 
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class EmployeeInfo {
 	private Long id;
 
 	public EmployeeInfo() {
 	}
 
 	public EmployeeInfo(Long id) {
 		this.id = id;
 	}
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/propertyref/DoesNotWorkPk.java b/hibernate-core/src/test/java/org/hibernate/test/propertyref/DoesNotWorkPk.java
index f753f19313..28c4a0fefb 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/propertyref/DoesNotWorkPk.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/propertyref/DoesNotWorkPk.java
@@ -1,100 +1,100 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.propertyref;
 
 import javax.persistence.Column;
 import javax.persistence.Embeddable;
 import java.io.Serializable;
 
 /**
  * @author Steve Ebersole
  */
 @Embeddable
 public class DoesNotWorkPk implements Serializable {
 
 	private static final long serialVersionUID = 1L;
 
 	@Column(name = "track_no")
 	private String id1;
 
 	@Column(name = "track_ext")
 	private String id2;
 
 	public String getId1() {
 		return id1;
 	}
 
 	public void setId1(String id1) {
 		this.id1 = id1;
 	}
 
 	public String getId2() {
 		return id2;
 	}
 
 	public void setId2(String id2) {
 		this.id2 = id2;
 	}
 
 	@Override
 	public int hashCode() {
 		final int prime = 31;
 		int result = 1;
 		result = prime * result + ((id1 == null) ? 0 : id1.hashCode());
 		result = prime * result + ((id2 == null) ? 0 : id2.hashCode());
 		return result;
 	}
 
 	@Override
 	public boolean equals(Object obj) {
 		if ( this == obj ) {
 			return true;
 		}
 		if ( obj == null ) {
 			return false;
 		}
 		if ( !(obj instanceof DoesNotWorkPk) ) {
 			return false;
 		}
 		DoesNotWorkPk other = (DoesNotWorkPk) obj;
 		if ( id1 == null ) {
 			if ( other.id1 != null ) {
 				return false;
 			}
 		}
 		else if ( !id1.equals( other.id1 ) ) {
 			return false;
 		}
 		if ( id2 == null ) {
 			if ( other.id2 != null ) {
 				return false;
 			}
 		}
 		else if ( !id2.equals( other.id2 ) ) {
 			return false;
 		}
 		return true;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/querycache/Address.java b/hibernate-core/src/test/java/org/hibernate/test/querycache/Address.java
index 8ab9331393..68edc2d15e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/querycache/Address.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/querycache/Address.java
@@ -1,135 +1,135 @@
 // $Id: Address.java 7996 2005-08-22 14:49:57Z steveebersole $
 package org.hibernate.test.querycache;
 
 
 /**
  * Implementation of Address.
  *
  * @author Steve Ebersole
  */
 public class Address {
 	private long id;
 	private String addressType;
 	private String street;
 	private String city;
 	private String stateProvince;
 	private String postalCode;
 	private String country;
 	private Student student;
 
 	public Address() {}
 
 	public Address(Student student, String type, String street, String city, String stateProvince, String postalCode, String country) {
 		this.student = student;
 		this.addressType = type;
 		this.street = street;
 		this.city = city;
 		this.stateProvince = stateProvince;
 		this.postalCode = postalCode;
 		this.country = country;
 	}
 
 	public long getId() {
 		return id;
 	}
 
 	public void setId(long id) {
 		this.id = id;
 	}
 
 	public Student getStudent() {
 		return student;
 	}
 
 	public void setStudent(Student student) {
 		this.student = student;
 	}
 
 	public String getAddressType() {
 		return addressType;
 	}
 
 	public void setAddressType(String addressType) {
 		this.addressType = addressType;
 	}
 
 	public String getStreet() {
 		return street;
 	}
 
 	public void setStreet(String street) {
 		this.street = street;
 	}
 
 	public String getCity() {
 		return city;
 	}
 
 	public void setCity(String city) {
 		this.city = city;
 	}
 
 	public String getPostalCode() {
 		return postalCode;
 	}
 
 	public void setPostalCode(String postalCode) {
 		this.postalCode = postalCode;
 	}
 
 	public String getCountry() {
 		return country;
 	}
 
 	public void setCountry(String country) {
 		this.country = country;
 	}
 
 	public String getStateProvince() {
 		return stateProvince;
 	}
 
 	public void setStateProvince(String stateProvince) {
 		this.stateProvince = stateProvince;
 	}
 
 	@Override
 	public boolean equals(Object o) {
 		if ( this == o ) {
 			return true;
 		}
 		if ( o == null || getClass() != o.getClass() ) {
 			return false;
 		}
 
 		Address address = ( Address ) o;
 
 		if ( city != null ? !city.equals( address.city ) : address.city != null ) {
 			return false;
 		}
 		if ( country != null ? !country.equals( address.country ) : address.country != null ) {
 			return false;
 		}
 		if ( postalCode != null ? !postalCode.equals( address.postalCode ) : address.postalCode != null ) {
 			return false;
 		}
 		if ( stateProvince != null ? !stateProvince.equals( address.stateProvince ) : address.stateProvince != null ) {
 			return false;
 		}
 		if ( street != null ? !street.equals( address.street ) : address.street != null ) {
 			return false;
 		}
 
 		return true;
 	}
 
 	@Override
 	public int hashCode() {
 		int result = street != null ? street.hashCode() : 0;
 		result = 31 * result + ( city != null ? city.hashCode() : 0 );
 		result = 31 * result + ( stateProvince != null ? stateProvince.hashCode() : 0 );
 		result = 31 * result + ( postalCode != null ? postalCode.hashCode() : 0 );
 		result = 31 * result + ( country != null ? country.hashCode() : 0 );
 		return result;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/querycache/Course.java b/hibernate-core/src/test/java/org/hibernate/test/querycache/Course.java
index c0bb069d29..2b454560c5 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/querycache/Course.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/querycache/Course.java
@@ -1,59 +1,59 @@
 //$Id: Course.java 5686 2005-02-12 07:27:32Z steveebersole $
 package org.hibernate.test.querycache;
 import java.io.Serializable;
 import java.util.HashSet;
 import java.util.Set;
 
 /**
  * @author Gavin King
  */
 public class Course implements Serializable {
 	private String courseCode;
 	private String description;
 	private Set courseMeetings = new HashSet();
 
 	public String getCourseCode() {
 		return courseCode;
 	}
 	public void setCourseCode(String courseCode) {
 		this.courseCode = courseCode;
 	}
 	public String getDescription() {
 		return description;
 	}
 	public void setDescription(String description) {
 		this.description = description;
 	}
 	public Set getCourseMeetings() {
 		return courseMeetings;
 	}
 	public void setCourseMeetings(Set courseMeetings) {
 		this.courseMeetings = courseMeetings;
 	}
 
 	public boolean equals(Object o) {
 		if ( this == o ) {
 			return true;
 		}
 		if ( o == null || ! ( o instanceof Course ) ) {
 			return false;
 		}
 
 		Course course = ( Course ) o;
 
 		if ( courseCode != null ? !courseCode.equals( course.getCourseCode() ) : course.getCourseCode() != null ) {
 			return false;
 		}
 		if ( description != null ? !description.equals( course.getDescription() ) : course.getDescription() != null ) {
 			return false;
 		}
 
 		return true;
 	}
 
 	public int hashCode() {
 		int result = courseCode != null ? courseCode.hashCode() : 0;
 		result = 31 * result + ( description != null ? description.hashCode() : 0 );
 		return result;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/querycache/CourseMeeting.java b/hibernate-core/src/test/java/org/hibernate/test/querycache/CourseMeeting.java
index d917c4786e..30ec34aa90 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/querycache/CourseMeeting.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/querycache/CourseMeeting.java
@@ -1,56 +1,56 @@
 package org.hibernate.test.querycache;
 
 
 /**
  * @author Gail Badner
  */
 public class CourseMeeting {
 	private CourseMeetingId id;
 	private Course course;
 
 	public CourseMeeting() {}
 
 	public CourseMeeting(Course course, String day, int period, String location) {
 		this.id = new CourseMeetingId( course, day, period, location );
 		this.course = course;
 	}
 
 	public CourseMeetingId getId() {
 		return id;
 	}
 	public void setId(CourseMeetingId id) {
 		this.id = id;
 	}
 	public  Course getCourse() {
 		return course;
 	}
 	public void setCourse(Course course) {
 		this.course = course;
 	}
 
 	public boolean equals(Object o) {
 		if ( this == o ) {
 			return true;
 		}
 		if ( o == null || getClass() != o.getClass() ) {
 			return false;
 		}
 
 		CourseMeeting that = ( CourseMeeting ) o;
 
 		if ( course != null ? !course.equals( that.course ) : that.course != null ) {
 			return false;
 		}
 		if ( id != null ? !id.equals( that.id ) : that.id != null ) {
 			return false;
 		}
 
 		return true;
 	}
 
 	public int hashCode() {
 		int result = id != null ? id.hashCode() : 0;
 		result = 31 * result + ( course != null ? course.hashCode() : 0 );
 		return result;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/querycache/CourseMeetingId.java b/hibernate-core/src/test/java/org/hibernate/test/querycache/CourseMeetingId.java
index ce6f5c197f..0b44aab3d9 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/querycache/CourseMeetingId.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/querycache/CourseMeetingId.java
@@ -1,80 +1,80 @@
 package org.hibernate.test.querycache;
 import java.io.Serializable;
 
 /**
  * @author Gail Badner
  */
 public class CourseMeetingId implements Serializable {
 	private String courseCode;
 	private String day;
 	private int period;
 	private String location;
 
 	public CourseMeetingId() {}
 
 	public CourseMeetingId(Course course, String day, int period, String location) {
 		this.courseCode = course.getCourseCode();
 		this.day = day;
 		this.period = period;
 		this.location = location;
 	}
 
 	public String getCourseCode() {
 		return courseCode;
 	}
 	public void setCourseCode(String courseCode) {
 		this.courseCode = courseCode;
 	}
 	public String getDay() {
 		return day;
 	}
 	public void setDay(String day) {
 		this.day = day;
 	}
 	public int getPeriod() {
 		return period;
 	}
 	public void setPeriod(int period) {
 		this.period = period;
 	}
 	public String getLocation() {
 		return location;
 	}
 	public void setLocation(String location) {
 		this.location = location;
 	}
 
 	public boolean equals(Object o) {
 		if ( this == o ) {
 			return true;
 		}
 		if ( o == null || getClass() != o.getClass() ) {
 			return false;
 		}
 
 		CourseMeetingId that = ( CourseMeetingId ) o;
 
 		if ( period != that.period ) {
 			return false;
 		}
 		if ( courseCode != null ? !courseCode.equals( that.courseCode ) : that.courseCode != null ) {
 			return false;
 		}
 		if ( day != null ? !day.equals( that.day ) : that.day != null ) {
 			return false;
 		}
 		if ( location != null ? !location.equals( that.location ) : that.location != null ) {
 			return false;
 		}
 
 		return true;
 	}
 
 	public int hashCode() {
 		int result = courseCode != null ? courseCode.hashCode() : 0;
 		result = 31 * result + ( day != null ? day.hashCode() : 0 );
 		result = 31 * result + period;
 		result = 31 * result + ( location != null ? location.hashCode() : 0 );
 		return result;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/querycache/Enrolment.java b/hibernate-core/src/test/java/org/hibernate/test/querycache/Enrolment.java
index b00b7dd407..7c7a8cc4b8 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/querycache/Enrolment.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/querycache/Enrolment.java
@@ -1,86 +1,86 @@
 //$Id: Enrolment.java 6970 2005-05-31 20:24:41Z oneovthafew $
 package org.hibernate.test.querycache;
 import java.io.Serializable;
 
 /**
  * @author Gavin King
  */
 public class Enrolment implements Serializable {
 	private Student student;
 	private Course course;
 	private long studentNumber;
 	private String courseCode;
 	private short year;
 	private short semester;
 
 	public String getCourseCode() {
 		return courseCode;
 	}
 	public void setCourseCode(String courseId) {
 		this.courseCode = courseId;
 	}
 	public long getStudentNumber() {
 		return studentNumber;
 	}
 	public void setStudentNumber(long studentId) {
 		this.studentNumber = studentId;
 	}
 	public Course getCourse() {
 		return course;
 	}
 	public void setCourse(Course course) {
 		this.course = course;
 	}
 	public Student getStudent() {
 		return student;
 	}
 	public void setStudent(Student student) {
 		this.student = student;
 	}
 	public short getSemester() {
 		return semester;
 	}
 	public void setSemester(short semester) {
 		this.semester = semester;
 	}
 	public short getYear() {
 		return year;
 	}
 	public void setYear(short year) {
 		this.year = year;
 	}
 
 	public boolean equals(Object o) {
 		if ( this == o ) {
 			return true;
 		}
 		if ( o == null || getClass() != o.getClass() ) {
 			return false;
 		}
 
 		Enrolment enrolment = ( Enrolment ) o;
 
 		if ( semester != enrolment.semester ) {
 			return false;
 		}
 		if ( studentNumber != enrolment.studentNumber ) {
 			return false;
 		}
 		if ( year != enrolment.year ) {
 			return false;
 		}
 		if ( courseCode != null ? !courseCode.equals( enrolment.courseCode ) : enrolment.courseCode != null ) {
 			return false;
 		}
 
 		return true;
 	}
 
 	public int hashCode() {
 		int result = ( int ) ( studentNumber ^ ( studentNumber >>> 32 ) );
 		result = 31 * result + ( courseCode != null ? courseCode.hashCode() : 0 );
 		result = 31 * result + ( int ) year;
 		result = 31 * result + ( int ) semester;
 		return result;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/querycache/PersonName.java b/hibernate-core/src/test/java/org/hibernate/test/querycache/PersonName.java
index 8b107934ae..ca2ea1f22b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/querycache/PersonName.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/querycache/PersonName.java
@@ -1,97 +1,97 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.test.querycache;
 
 
 /**
  * @author Gail Badner
  */
 
 public class PersonName {
 	private String first;
 	private String middle;
 	private String last;
 
 	public PersonName() {}
 
 	public PersonName(String first, String middle, String state) {
 		this.first = first;
 		this.middle = middle;
 		this.last = state;
 	}
 
 	public String getFirst() {
 		return first;
 	}
 
 	public void setFirst(String first) {
 		this.first = first;
 	}
 
 	public String getMiddle() {
 		return middle;
 	}
 
 	public void setMiddle(String middle) {
 		this.middle = middle;
 	}
 
 	public String getLast() {
 		return last;
 	}
 
 	public void setLast(String last) {
 		this.last = last;
 	}
 
 	public boolean equals(Object o) {
 		if ( this == o ) {
 			return true;
 		}
 		if ( o == null || getClass() != o.getClass() ) {
 			return false;
 		}
 
 		PersonName name = ( PersonName ) o;
 
 		if ( first != null ? !first.equals( name.first ) : name.first != null ) {
 			return false;
 		}
 		if ( middle != null ? !middle.equals( name.middle ) : name.middle != null ) {
 			return false;
 		}
 		if ( last != null ? !last.equals( name.last ) : name.last != null ) {
 			return false;
 		}
 
 		return true;
 	}
 
 	public int hashCode() {
 		int result = first != null ? first.hashCode() : 0;
 		result = 31 * result + ( last != null ? last.hashCode() : 0 );
 		return result;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/querycache/StringCompositeKey.java b/hibernate-core/src/test/java/org/hibernate/test/querycache/StringCompositeKey.java
index 01024f0b38..7fac34c6f0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/querycache/StringCompositeKey.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/querycache/StringCompositeKey.java
@@ -1,60 +1,60 @@
 package org.hibernate.test.querycache;
 
 import java.io.Serializable;
 
 import javax.persistence.Column;
 import javax.persistence.Embeddable;
 
 @Embeddable
 public class StringCompositeKey implements Serializable {
 	
     private static final long serialVersionUID = 1L;
 
  private String substation;
     
     private String deviceType;
     
     private String device;
 
     private String analog;
     
     // For some dialects, the sum of a primary key column lengths cannot
     // be larger than 255 (DB2).  Restrict them to a sufficiently
     // small size.  See HHH-8085.
     
     @Column( length = 50 )
 	public String getSubstation() {
 		return substation;
 	}
 
 	public void setSubstation(String substation) {
 		this.substation = substation;
 	}
 
 	@Column( length = 50 )
 	public String getDeviceType() {
 		return deviceType;
 	}
 
 	public void setDeviceType(String deviceType) {
 		this.deviceType = deviceType;
 	}
 
 	@Column( length = 50 )
 	public String getDevice() {
 		return device;
 	}
 
 	public void setDevice(String device) {
 		this.device = device;
 	}
 
 	@Column( length = 50 )
 	public String getAnalog() {
 		return analog;
 	}
 
 	public void setAnalog(String analog) {
 		this.analog = analog;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/querycache/Student.java b/hibernate-core/src/test/java/org/hibernate/test/querycache/Student.java
index dae8271fdc..6762db85d1 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/querycache/Student.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/querycache/Student.java
@@ -1,101 +1,101 @@
 //$Id: Student.java 9116 2006-01-23 21:21:01Z steveebersole $
 package org.hibernate.test.querycache;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 /**
  * @author Gavin King
  */
 public class Student {
 	private long studentNumber;
 	private PersonName name;
 	private Course preferredCourse;
 	private Set enrolments = new HashSet();
 	private Map addresses = new HashMap();
 	private List secretCodes = new ArrayList();
 
 	public Student() {}
 
 	public Student(long studentNumber, PersonName name) {
 		this.studentNumber = studentNumber;
 		this.name = name;
 	}
 
 	public PersonName getName() {
 		return name;
 	}
 
 	public void setName(PersonName name) {
 		this.name = name;
 	}
 
 	public long getStudentNumber() {
 		return studentNumber;
 	}
 
 	public void setStudentNumber(long studentNumber) {
 		this.studentNumber = studentNumber;
 	}
 
 	public Map getAddresses() {
 		return addresses;
 	}
 
 	public void setAddresses(Map addresses) {
 		this.addresses = addresses;
 	}
 
 	public Course getPreferredCourse() {
 		return preferredCourse;
 	}
 
 	public void setPreferredCourse(Course preferredCourse) {
 		this.preferredCourse = preferredCourse;
 	}
 
 	public Set getEnrolments() {
 		return enrolments;
 	}
 
 	public void setEnrolments(Set employments) {
 		this.enrolments = employments;
 	}
 
 	public List getSecretCodes() {
 		return secretCodes;
 	}
 
 	public void setSecretCodes(List secretCodes) {
 		this.secretCodes = secretCodes;
 	}
 
 	public boolean equals(Object o) {
 		if ( this == o ) {
 			return true;
 		}
 		if ( o == null || ! ( o instanceof Student ) ) {
 			return false;
 		}
 
 		Student student = ( Student ) o;
 
 		if ( studentNumber != student.getStudentNumber() ) {
 			return false;
 		}
 		if ( name != null ? !name.equals( student.getName() ) : student.getName() != null ) {
 			return false;
 		}
 
 		return true;
 	}
 
 	public int hashCode() {
 		int result = ( int ) ( studentNumber ^ ( studentNumber >>> 32 ) );
 		result = 31 * result + ( name != null ? name.hashCode() : 0 );
 		return result;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/querycache/StudentDTO.java b/hibernate-core/src/test/java/org/hibernate/test/querycache/StudentDTO.java
index 67fb53ba3d..de4a6cd13c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/querycache/StudentDTO.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/querycache/StudentDTO.java
@@ -1,61 +1,61 @@
 /*
  * Created on 28-Jan-2005
  *
  */
 package org.hibernate.test.querycache;
 
 
 /**
  * @author max
  *
  */
 public class StudentDTO {
 
 	private PersonName studentName;
 	private String courseDescription;
 
 	public StudentDTO() { }
 
 	public StudentDTO(PersonName name) {
 		this.studentName = name;
 	}
 
 	public StudentDTO(PersonName name, String description) {
 		this.studentName = name;
 		this.courseDescription = description;
 	}
 
 	public PersonName getName() {
 		return studentName;
 	}
 
 	public String getDescription() {
 		return courseDescription;
 	}
 
 	public boolean equals(Object o) {
 		if ( this == o ) {
 			return true;
 		}
 		if ( o == null || getClass() != o.getClass() ) {
 			return false;
 		}
 
 		StudentDTO that = ( StudentDTO ) o;
 
 		if ( courseDescription != null ? !courseDescription.equals( that.courseDescription ) : that.courseDescription != null ) {
 			return false;
 		}
 		if ( studentName != null ? !studentName.equals( that.studentName ) : that.studentName != null ) {
 			return false;
 		}
 
 		return true;
 	}
 
 	public int hashCode() {
 		int result = studentName != null ? studentName.hashCode() : 0;
 		result = 31 * result + ( courseDescription != null ? courseDescription.hashCode() : 0 );
 		return result;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/queryplan/GetHqlQueryPlanTest.java b/hibernate-core/src/test/java/org/hibernate/test/queryplan/GetHqlQueryPlanTest.java
index 3efdefd681..041951a619 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/queryplan/GetHqlQueryPlanTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/queryplan/GetHqlQueryPlanTest.java
@@ -1,117 +1,116 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.queryplan;
 
 import java.util.Map;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.engine.query.spi.HQLQueryPlan;
 import org.hibernate.engine.query.spi.QueryPlanCache;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertNotSame;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Tests for HQL query plans
  *
  * @author Gail Badner
  */
 public class GetHqlQueryPlanTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[]{
 			"queryplan/filter-defs.hbm.xml",
 			"queryplan/Joined.hbm.xml"
 		};
 	}
 
 	protected Map getEnabledFilters(Session s) {
 		return ( ( SessionImplementor ) s ).getLoadQueryInfluencers().getEnabledFilters();
 	}
 
 	@Test
 	public void testHqlQueryPlan() {
 		Session s = openSession();
 		QueryPlanCache cache = ( ( SessionImplementor ) s ).getFactory().getQueryPlanCache();
 		assertTrue( getEnabledFilters( s ).isEmpty() );
 
 		HQLQueryPlan plan1 = cache.getHQLQueryPlan( "from Person", false, getEnabledFilters( s ) );
 		HQLQueryPlan plan2 = cache.getHQLQueryPlan( "from Person where name is null", false, getEnabledFilters( s ) );
 		HQLQueryPlan plan3 = cache.getHQLQueryPlan( "from Person where name = :name", false, getEnabledFilters( s ) );
 		HQLQueryPlan plan4 = cache.getHQLQueryPlan( "from Person where name = ?", false, getEnabledFilters( s ) );
 
 		assertNotSame( plan1, plan2 );
 		assertNotSame( plan1, plan3 );
 		assertNotSame( plan1, plan4 );
 		assertNotSame( plan2, plan3 );
 		assertNotSame( plan2, plan4 );
 		assertNotSame( plan3, plan4 );
 
 		assertSame( plan1, cache.getHQLQueryPlan( "from Person", false, getEnabledFilters( s ) ) );
 		assertSame( plan2, cache.getHQLQueryPlan( "from Person where name is null", false, getEnabledFilters( s ) ) );
 		assertSame( plan3, cache.getHQLQueryPlan( "from Person where name = :name", false, getEnabledFilters( s ) ) );
 		assertSame( plan4, cache.getHQLQueryPlan( "from Person where name = ?", false, getEnabledFilters( s ) ) );
 
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testHqlQueryPlanWithEnabledFilter() {
 		Session s = openSession();
 		QueryPlanCache cache = ( (SessionImplementor) s ).getFactory().getQueryPlanCache();
 
 		HQLQueryPlan plan1A = cache.getHQLQueryPlan( "from Person", true, getEnabledFilters( s ) );
 		HQLQueryPlan plan1B = cache.getHQLQueryPlan( "from Person", false, getEnabledFilters( s ) );
 
 		s.enableFilter( "sex" ).setParameter( "sexCode", Character.valueOf( 'F' ) );
 		HQLQueryPlan plan2A = cache.getHQLQueryPlan( "from Person", true, getEnabledFilters( s ) );
 		HQLQueryPlan plan2B = cache.getHQLQueryPlan( "from Person", false, getEnabledFilters( s ) );
 
 		s.disableFilter( "sex" );
 		HQLQueryPlan plan3A = cache.getHQLQueryPlan( "from Person", true, getEnabledFilters( s ) );
 		HQLQueryPlan plan3B = cache.getHQLQueryPlan( "from Person", false, getEnabledFilters( s ) );
 
 		s.enableFilter( "sex" ).setParameter( "sexCode", Character.valueOf( 'M' ) );
 		HQLQueryPlan plan4A = cache.getHQLQueryPlan( "from Person", true, getEnabledFilters( s ) );
 		HQLQueryPlan plan4B = cache.getHQLQueryPlan( "from Person", false, getEnabledFilters( s ) );
 
 		assertSame( plan1A, plan3A );
 		assertSame( plan1B, plan3B );
 		assertSame( plan2A, plan4A );
 		assertSame( plan2B, plan4B );
 
 		assertNotSame( plan1A, plan1B );
 		assertNotSame( plan1A, plan2A );
 		assertNotSame( plan1A, plan2B );
 		assertNotSame( plan1B, plan2A );
 		assertNotSame( plan1B, plan2B );
 
 		s.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/queryplan/NativeSQLQueryReturnEqualsAndHashCodeTest.java b/hibernate-core/src/test/java/org/hibernate/test/queryplan/NativeSQLQueryReturnEqualsAndHashCodeTest.java
index f51687be2d..9dfea18b99 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/queryplan/NativeSQLQueryReturnEqualsAndHashCodeTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/queryplan/NativeSQLQueryReturnEqualsAndHashCodeTest.java
@@ -1,277 +1,277 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.queryplan;
 
 import java.util.Collections;
 import java.util.HashMap;
 
 import org.junit.Test;
 
 import org.hibernate.LockMode;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryCollectionReturn;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryJoinReturn;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryReturn;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryRootReturn;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryScalarReturn;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Tests equals() and hashCode() for NativeSQLQueryReturn implementations.
  *
  * @author Gail Badner
  */
 public class NativeSQLQueryReturnEqualsAndHashCodeTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] {};
 	}
 
 	@Test
 	public void testNativeSQLQueryScalarReturn() {
 		NativeSQLQueryScalarReturn typeNoAlias = new NativeSQLQueryScalarReturn( null,sessionFactory().getTypeResolver().basic( "int" ) );
 		NativeSQLQueryScalarReturn aliasNoType = new NativeSQLQueryScalarReturn( "abc", null );
 		NativeSQLQueryScalarReturn aliasTypeInt = new NativeSQLQueryScalarReturn( "abc",sessionFactory().getTypeResolver().basic( "int" ) );
 		NativeSQLQueryScalarReturn aliasTypeLong =  new NativeSQLQueryScalarReturn( "abc",sessionFactory().getTypeResolver().basic( "long" ) );
 		NativeSQLQueryScalarReturn aliasTypeLongClass =  new NativeSQLQueryScalarReturn( "abc",sessionFactory().getTypeResolver().basic( Long.class.getName() ) );
 		NativeSQLQueryScalarReturn aliasTypeString =  new NativeSQLQueryScalarReturn( "abc",sessionFactory().getTypeResolver().basic( "string" ) );
 		NativeSQLQueryScalarReturn aliasTypeStringClass =  new NativeSQLQueryScalarReturn( "abc",sessionFactory().getTypeResolver().basic( String.class.getName() ) );
 
 		check( false, typeNoAlias, aliasNoType );
 		check( false, typeNoAlias, aliasTypeInt );
 		check( false, typeNoAlias, aliasTypeLong );
 		check( false, typeNoAlias, aliasTypeLongClass );
 		check( false, typeNoAlias, aliasTypeString );
 		check( false, typeNoAlias, aliasTypeStringClass );
 
 		check( false, aliasNoType, aliasTypeInt );
 		check( false, aliasNoType, aliasTypeLong );
 		check( false, aliasNoType, aliasTypeLongClass );
 		check( false, aliasNoType, aliasTypeString );
 		check( false, aliasNoType, aliasTypeStringClass );
 
 		check( false, aliasTypeInt, aliasTypeLong );
 		check( false, aliasTypeInt, aliasTypeLongClass );
 		check( false, aliasTypeInt, aliasTypeString );
 		check( false, aliasTypeInt, aliasTypeStringClass );
 
 		check( true, aliasTypeLong, aliasTypeLongClass );
 		check( false, aliasTypeLong, aliasTypeString );
 		check( false, aliasTypeLong, aliasTypeStringClass );
 
 		check( false, aliasTypeLongClass, aliasTypeString );
 		check( false, aliasTypeLongClass, aliasTypeStringClass );
 
 		check( true, aliasTypeString, aliasTypeStringClass );
 
 		check( true, typeNoAlias, new NativeSQLQueryScalarReturn( null,sessionFactory().getTypeResolver().basic( "int" ) ) );
 		check( true, aliasNoType, new NativeSQLQueryScalarReturn( "abc", null ) );
 		check( true, aliasTypeInt, new NativeSQLQueryScalarReturn( "abc",sessionFactory().getTypeResolver().basic( "int" ) ) );
 		check( true, aliasTypeLong, new NativeSQLQueryScalarReturn( "abc",sessionFactory().getTypeResolver().basic( "long" ) ) );
 		check( true, aliasTypeLongClass,  new NativeSQLQueryScalarReturn( "abc",sessionFactory().getTypeResolver().basic( Long.class.getName() ) ) );
 		check( true, aliasTypeString, new NativeSQLQueryScalarReturn( "abc",sessionFactory().getTypeResolver().basic( "string" ) ) );
 		check( true, aliasTypeStringClass, new NativeSQLQueryScalarReturn( "abc",sessionFactory().getTypeResolver().basic( String.class.getName() ) ) );
 	}
 
 	@Test
 	public void testNativeSQLQueryRootReturn() {
 		NativeSQLQueryRootReturn alias = new NativeSQLQueryRootReturn( "abc", null, null);
 		NativeSQLQueryRootReturn diffAlias = new NativeSQLQueryRootReturn( "def", null, null);
 		NativeSQLQueryRootReturn aliasEntityName = new NativeSQLQueryRootReturn( "abc", "Person", null);
 		NativeSQLQueryRootReturn aliasDiffEntityName = new NativeSQLQueryRootReturn( "abc", "Customer", null);
 		NativeSQLQueryRootReturn aliasEntityNameLockMode = new NativeSQLQueryRootReturn( "abc", "Person", LockMode.NONE );
 		NativeSQLQueryRootReturn aliasEntityNameDiffLockMode = new NativeSQLQueryRootReturn( "abc", "Person", LockMode.OPTIMISTIC );
 
 		check( false, alias, diffAlias );
 		check( false, alias, aliasEntityName );
 		check( false, alias, aliasDiffEntityName );
 		check( false, alias, aliasEntityNameLockMode );
 		check( false, alias, aliasEntityNameDiffLockMode );
 
 		check( false, diffAlias, aliasEntityName );
 		check( false, diffAlias, aliasDiffEntityName );
 		check( false, diffAlias, aliasEntityNameLockMode );
 		check( false, diffAlias, aliasEntityNameDiffLockMode );
 
 		check( false, aliasEntityName, aliasDiffEntityName );
 		check( false, aliasEntityName, aliasEntityNameLockMode );
 		check( false, aliasEntityName, aliasEntityNameDiffLockMode );
 
 		check( false, aliasDiffEntityName, aliasEntityNameLockMode );
 		check( false, aliasDiffEntityName, aliasEntityNameDiffLockMode );
 
 		check( false, aliasEntityNameLockMode, aliasEntityNameDiffLockMode );
 
 		check( true, alias, new NativeSQLQueryRootReturn( "abc", null, null) );
 		check( true, diffAlias, new NativeSQLQueryRootReturn( "def", null, null) );
 		check( true, aliasEntityName, new NativeSQLQueryRootReturn( "abc", "Person", null) );
 		check( true, aliasDiffEntityName, new NativeSQLQueryRootReturn( "abc", "Customer", null) );
 		check( true, aliasEntityNameLockMode, new NativeSQLQueryRootReturn( "abc", "Person", LockMode.NONE ) );
 		check( true, aliasEntityNameDiffLockMode, new NativeSQLQueryRootReturn( "abc", "Person", LockMode.OPTIMISTIC ) );
 	}
 
 	@Test
 	public void testNativeSQLQueryJoinReturn() {
 		NativeSQLQueryJoinReturn r1 = new NativeSQLQueryJoinReturn( "a", "b", "c", null, null);
 		NativeSQLQueryJoinReturn r2 = new NativeSQLQueryJoinReturn( "a", "c", "b", null, null);
 		NativeSQLQueryJoinReturn r3NullMap = new NativeSQLQueryJoinReturn( "b", "c", "a", null, null);
 		NativeSQLQueryJoinReturn r3EmptyMap= new NativeSQLQueryJoinReturn( "b", "c", "a", new HashMap(), null);
 		NativeSQLQueryJoinReturn r4 = new NativeSQLQueryJoinReturn( "b", "c", "a", Collections.singletonMap( "key", "value" ), null);
 		NativeSQLQueryJoinReturn r5 = new NativeSQLQueryJoinReturn( "b", "c", "a", Collections.singletonMap( "otherkey", "othervalue" ), null);
 		NativeSQLQueryJoinReturn r6 = new NativeSQLQueryJoinReturn( "b", "c", "a", Collections.singletonMap( "key", "value" ), LockMode.NONE );
 		NativeSQLQueryJoinReturn r7 = new NativeSQLQueryJoinReturn( "b", "c", "a", null, LockMode.NONE );
 
 		check( false, r1, r2 );
 		check( false, r1, r3NullMap );
 		check( false, r1, r3EmptyMap );
 		check( false, r1, r4 );
 		check( false, r1, r5 );
 		check( false, r1, r6 );
 		check( false, r1, r7 );
 
 		check( false, r2, r3NullMap );
 		check( false, r2, r3EmptyMap );
 		check( false, r2, r4 );
 		check( false, r2, r5 );
 		check( false, r2, r6 );
 		check( false, r2, r7 );
 
 		check( true, r3NullMap, r3EmptyMap );
 		check( false, r3NullMap, r4 );
 		check( false, r3NullMap, r5 );
 		check( false, r3NullMap, r6 );
 		check( false, r3NullMap, r7 );
 
 		check( false, r3EmptyMap, r4 );
 		check( false, r3EmptyMap, r5 );
 		check( false, r3EmptyMap, r6 );
 		check( false, r3EmptyMap, r7 );
 
 		check( false, r4, r5 );
 		check( false, r4, r6 );
 		check( false, r4, r7 );
 
 		check( false, r5, r6 );
 		check( false, r5, r7 );
 
 		check( false, r6, r7 );
 
 		check( true, r1, new NativeSQLQueryJoinReturn( "a", "b", "c", null, null) );
 		check( true, r2, new NativeSQLQueryJoinReturn( "a", "c", "b", null, null) );
 		check( true, r3NullMap, new NativeSQLQueryJoinReturn( "b", "c", "a", null, null) );
 		check( true, r3EmptyMap, new NativeSQLQueryJoinReturn( "b", "c", "a", new HashMap(), null) );
 		check( true, r4, new NativeSQLQueryJoinReturn( "b", "c", "a", Collections.singletonMap( "key", "value" ), null) );
 		check( true, r5, new NativeSQLQueryJoinReturn( "b", "c", "a", Collections.singletonMap( "otherkey", "othervalue" ), null) );
 		check( true, r6, new NativeSQLQueryJoinReturn( "b", "c", "a", Collections.singletonMap( "key", "value" ), LockMode.NONE ) );
 		check( true, r7, new NativeSQLQueryJoinReturn( "b", "c", "a", null, LockMode.NONE ) );
 	}
 
 	@Test
 	public void testNativeSQLQueryCollectionReturn() {
 		NativeSQLQueryCollectionReturn r1 = new NativeSQLQueryCollectionReturn( "a", "b", "c", null, null);
 		NativeSQLQueryCollectionReturn r2 = new NativeSQLQueryCollectionReturn( "a", "c", "b", null, null);
 		NativeSQLQueryCollectionReturn r3NullMap = new NativeSQLQueryCollectionReturn( "b", "c", "a", null, null);
 		NativeSQLQueryCollectionReturn r3EmptyMap= new NativeSQLQueryCollectionReturn( "b", "c", "a", new HashMap(), null);
 		NativeSQLQueryCollectionReturn r4 = new NativeSQLQueryCollectionReturn( "b", "c", "a", Collections.singletonMap( "key", "value" ), null);
 		NativeSQLQueryCollectionReturn r5 = new NativeSQLQueryCollectionReturn( "b", "c", "a", Collections.singletonMap( "otherkey", "othervalue" ), null);
 		NativeSQLQueryCollectionReturn r6 = new NativeSQLQueryCollectionReturn( "b", "c", "a", Collections.singletonMap( "key", "value" ), LockMode.NONE );
 		NativeSQLQueryCollectionReturn r7 = new NativeSQLQueryCollectionReturn( "b", "c", "a", null, LockMode.NONE );
 
 		check( false, r1, r2 );
 		check( false, r1, r3NullMap );
 		check( false, r1, r3EmptyMap );
 		check( false, r1, r4 );
 		check( false, r1, r5 );
 		check( false, r1, r6 );
 		check( false, r1, r7 );
 
 		check( false, r2, r3NullMap );
 		check( false, r2, r3EmptyMap );
 		check( false, r2, r4 );
 		check( false, r2, r5 );
 		check( false, r2, r6 );
 		check( false, r2, r7 );
 
 		check( true, r3NullMap, r3EmptyMap );
 		check( false, r3NullMap, r4 );
 		check( false, r3NullMap, r5 );
 		check( false, r3NullMap, r6 );
 		check( false, r3NullMap, r7 );
 
 		check( false, r3EmptyMap, r4 );
 		check( false, r3EmptyMap, r5 );
 		check( false, r3EmptyMap, r6 );
 		check( false, r3EmptyMap, r7 );
 
 		check( false, r4, r5 );
 		check( false, r4, r6 );
 		check( false, r4, r7 );
 
 		check( false, r5, r6 );
 		check( false, r5, r7 );
 
 		check( false, r6, r7 );
 
 		check( true, r1, new NativeSQLQueryCollectionReturn( "a", "b", "c", null, null) );
 		check( true, r2, new NativeSQLQueryCollectionReturn( "a", "c", "b", null, null) );
 		check( true, r3NullMap, new NativeSQLQueryCollectionReturn( "b", "c", "a", null, null) );
 		check( true, r3EmptyMap, new NativeSQLQueryCollectionReturn( "b", "c", "a", new HashMap(), null) );
 		check( true, r4, new NativeSQLQueryCollectionReturn( "b", "c", "a", Collections.singletonMap( "key", "value" ), null) );
 		check( true, r5, new NativeSQLQueryCollectionReturn( "b", "c", "a", Collections.singletonMap( "otherkey", "othervalue" ), null) );
 		check( true, r6, new NativeSQLQueryCollectionReturn( "b", "c", "a", Collections.singletonMap( "key", "value" ), LockMode.NONE ) );
 		check( true, r7, new NativeSQLQueryCollectionReturn( "b", "c", "a", null, LockMode.NONE ) );
 	}
 
 	@Test
 	public void testNativeSQLQueryReturnTypes() {
 		NativeSQLQueryScalarReturn r1 = new NativeSQLQueryScalarReturn( "a",sessionFactory().getTypeResolver().basic( "int" ) );
 		NativeSQLQueryRootReturn r2 = new NativeSQLQueryRootReturn( "a", "b", LockMode.NONE );
 		NativeSQLQueryJoinReturn r3 = new NativeSQLQueryJoinReturn( "a", "b", "c", Collections.singletonMap( "key", "value" ), LockMode.NONE );
 		NativeSQLQueryCollectionReturn r4 = new NativeSQLQueryCollectionReturn( "a", "b", "c", Collections.singletonMap( "key", "value" ), LockMode.NONE);
 
 		check( false, r1, r2 );
 		check( false, r1, r3 );
 		check( false, r1, r4 );
 
 		check( false, r2, r3 );
 		check( false, r2, r4 );
 
 		check( false, r3, r4 );
 	}
 
 	private void check(boolean expectedEquals, NativeSQLQueryReturn queryReturn1, NativeSQLQueryReturn queryReturn2) {
 		if ( expectedEquals ) {
 			assertTrue( queryReturn1.equals( queryReturn2 ) );
 			assertTrue( queryReturn2.equals( queryReturn1 ) );
 			assertTrue( queryReturn1.hashCode() == queryReturn2.hashCode() );
 		}
 		else {
 			assertFalse( queryReturn1.equals( queryReturn2 ) );
 			assertFalse( queryReturn2.equals( queryReturn1 ) );
 			assertFalse( queryReturn1.hashCode() == queryReturn2.hashCode() );
 		}
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/readonly/AbstractReadOnlyTest.java b/hibernate-core/src/test/java/org/hibernate/test/readonly/AbstractReadOnlyTest.java
index cf19688a51..d2d25e3d71 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/readonly/AbstractReadOnlyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/readonly/AbstractReadOnlyTest.java
@@ -1,77 +1,77 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.readonly;
 
 import org.hibernate.CacheMode;
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Gail Badner
  */
 public abstract class AbstractReadOnlyTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public void configure(Configuration cfg) {
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true");
 		cfg.setProperty( Environment.STATEMENT_BATCH_SIZE, "0" );
 	}
 
 	@Override
 	public String getCacheConcurrencyStrategy() {
 		return null;
 	}
 
 	public Session openSession() {
 		Session s = super.openSession();
 		s.setCacheMode( getSessionCacheMode() );
 		return s;
 	}
 
 	protected CacheMode getSessionCacheMode() {
 		return CacheMode.IGNORE;
 	}
 
 	protected void clearCounts() {
 		sessionFactory().getStatistics().clear();
 	}
 
 	protected void assertInsertCount(int expected) {
 		int inserts = ( int ) sessionFactory().getStatistics().getEntityInsertCount();
 		assertEquals( "unexpected insert count", expected, inserts );
 	}
 
 	protected void assertUpdateCount(int expected) {
 		int updates = ( int ) sessionFactory().getStatistics().getEntityUpdateCount();
 		assertEquals( "unexpected update counts", expected, updates );
 	}
 
 	protected void assertDeleteCount(int expected) {
 		int deletes = ( int ) sessionFactory().getStatistics().getEntityDeleteCount();
 		assertEquals( "unexpected delete counts", expected, deletes );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/readonly/Container.java b/hibernate-core/src/test/java/org/hibernate/test/readonly/Container.java
index da8442e279..80124c6c45 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/readonly/Container.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/readonly/Container.java
@@ -1,116 +1,116 @@
 package org.hibernate.test.readonly;
 import java.io.Serializable;
 import java.util.HashSet;
 import java.util.Set;
 
 /**
  * @author Steve Ebersole, Gail Badner (adapted this from "proxy" tests version)
  */
 public class Container implements Serializable {
 	private Long id;
 	private String name;
 	private Owner noProxyOwner;
 	private Owner proxyOwner;
 	private Owner nonLazyOwner;
 	private Info noProxyInfo;
 	private Info proxyInfo;
 	private Info nonLazyInfo;
 	private Set lazyDataPoints = new HashSet();
 	private Set nonLazyJoinDataPoints = new HashSet();
 	private Set nonLazySelectDataPoints = new HashSet();
 
 	public Container() {
 	}
 
 	public Container(String name) {
 		this.name = name;
 	}
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	public Owner getNoProxyOwner() {
 		return noProxyOwner;
 	}
 
 	public void setNoProxyOwner(Owner noProxyOwner) {
 		this.noProxyOwner = noProxyOwner;
 	}
 
 	public Owner getProxyOwner() {
 		return proxyOwner;
 	}
 
 	public void setProxyOwner(Owner proxyOwner) {
 		this.proxyOwner = proxyOwner;
 	}
 
 	public Owner getNonLazyOwner() {
 		return nonLazyOwner;
 	}
 
 	public void setNonLazyOwner(Owner nonLazyOwner) {
 		this.nonLazyOwner = nonLazyOwner;
 	}
 
 	public Info getNoProxyInfo() {
 		return noProxyInfo;
 	}
 
 	public void setNoProxyInfo(Info noProxyInfo) {
 		this.noProxyInfo = noProxyInfo;
 	}
 
 	public Info getProxyInfo() {
 		return proxyInfo;
 	}
 
 	public void setProxyInfo(Info proxyInfo) {
 		this.proxyInfo = proxyInfo;
 	}
 
 	public Info getNonLazyInfo() {
 		return nonLazyInfo;
 	}
 
 	public void setNonLazyInfo(Info nonLazyInfo) {
 		this.nonLazyInfo = nonLazyInfo;
 	}
 
 	public Set getLazyDataPoints() {
 		return lazyDataPoints;
 	}
 
 	public void setLazyDataPoints(Set lazyDataPoints) {
 		this.lazyDataPoints = lazyDataPoints;
 	}
 
 	public Set getNonLazyJoinDataPoints() {
 		return nonLazyJoinDataPoints;
 	}
 
 	public void setNonLazyJoinDataPoints(Set nonLazyJoinDataPoints) {
 		this.nonLazyJoinDataPoints = nonLazyJoinDataPoints;
 	}
 
 	public Set getNonLazySelectDataPoints() {
 		return nonLazySelectDataPoints;
 	}
 
 	public void setNonLazySelectDataPoints(Set nonLazySelectDataPoints) {
 		this.nonLazySelectDataPoints = nonLazySelectDataPoints;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/readonly/Info.java b/hibernate-core/src/test/java/org/hibernate/test/readonly/Info.java
index 80cc92d209..67179573c0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/readonly/Info.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/readonly/Info.java
@@ -1,35 +1,35 @@
 package org.hibernate.test.readonly;
 
 
 /**
  * todo: describe Info
  *
  * @author Steve Ebersole, Gail Badner (adapted this from "proxy" tests version)
  */
 public class Info {
 	private Long id;
 	private String details;
 
 	public Info() {
 	}
 
 	public Info(String details) {
 		this.details = details;
 	}
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public String getDetails() {
 		return details;
 	}
 
 	public void setDetails(String details) {
 		this.details = details;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/readonly/Owner.java b/hibernate-core/src/test/java/org/hibernate/test/readonly/Owner.java
index 208af25805..a4a0002448 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/readonly/Owner.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/readonly/Owner.java
@@ -1,33 +1,33 @@
 package org.hibernate.test.readonly;
 import java.io.Serializable;
 
 /**
  * @author Steve Ebersole, Gail Badner (adapted this from "proxy" tests version)
  */
 public class Owner implements Serializable {
 	private Long id;
 	private String name;
 
 	public Owner() {
 	}
 
 	public Owner(String name) {
 		this.name = name;
 	}
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/readonly/ReadOnlySessionLazyNonLazyTest.java b/hibernate-core/src/test/java/org/hibernate/test/readonly/ReadOnlySessionLazyNonLazyTest.java
index 9bde45d620..88e8577e82 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/readonly/ReadOnlySessionLazyNonLazyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/readonly/ReadOnlySessionLazyNonLazyTest.java
@@ -392,1001 +392,1001 @@ public class ReadOnlySessionLazyNonLazyTest extends AbstractReadOnlyTest {
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		expectedReadOnlyObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNoProxyInfo(),
 						c.getProxyInfo(),
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						//c.getLazyDataPoints(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( false );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getNoProxyInfo() ) );
 		Hibernate.initialize( c.getNoProxyInfo() );
 		expectedInitializedObjects.add( c.getNoProxyInfo() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getProxyInfo() ) );
 		Hibernate.initialize( c.getProxyInfo() );
 		expectedInitializedObjects.add( c.getProxyInfo() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( true );
 		DataPoint lazyDataPoint = ( DataPoint ) s.get( DataPoint.class, lazyDataPointOrig.getId() );
 		s.setDefaultReadOnly( false );
 		assertFalse( Hibernate.isInitialized( c.getLazyDataPoints() ) );
 		Hibernate.initialize( c.getLazyDataPoints() );
 		assertSame( lazyDataPoint, c.getLazyDataPoints().iterator().next() );
 		expectedInitializedObjects.add( c.getLazyDataPoints().iterator().next() );
 		expectedReadOnlyObjects.add( lazyDataPoint );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery("delete from DataPoint").executeUpdate();
 		s.createQuery("delete from Container").executeUpdate();
 		s.createQuery("delete from Info").executeUpdate();
 		s.createQuery("delete from Owner").executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testExistingReadOnlyAfterSetSessionModifiableProxyExisting() {
 		Container cOrig = createContainer();
 		Set expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						cOrig,
 						cOrig.getNoProxyInfo(),
 						cOrig.getProxyInfo(),
 						cOrig.getNonLazyInfo(),
 						cOrig.getNoProxyOwner(),
 						cOrig.getProxyOwner(),
 						cOrig.getNonLazyOwner(),
 						cOrig.getLazyDataPoints().iterator().next(),
 						cOrig.getNonLazyJoinDataPoints().iterator().next(),
 						cOrig.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		Set expectedReadOnlyObjects = new HashSet();
 		DataPoint lazyDataPointOrig = ( DataPoint ) cOrig.getLazyDataPoints().iterator().next();
 		Session s = openSession();
 		assertFalse( s.isDefaultReadOnly() );
 		Transaction t = s.beginTransaction();
 		s.save( cOrig );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.setDefaultReadOnly( true );
 		Container c = ( Container ) s.get( Container.class, cOrig.getId()  );
 		assertNotSame( cOrig, c );
 		expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		expectedReadOnlyObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNoProxyInfo(),
 						c.getProxyInfo(),
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						//c.getLazyDataPoints(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( false );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getNoProxyInfo() ) );
 		Hibernate.initialize( c.getNoProxyInfo() );
 		expectedInitializedObjects.add( c.getNoProxyInfo() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getProxyInfo() ) );
 		Hibernate.initialize( c.getProxyInfo() );
 		expectedInitializedObjects.add( c.getProxyInfo() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		DataPoint lazyDataPoint = ( DataPoint ) s.load( DataPoint.class, lazyDataPointOrig.getId() );
 		assertFalse( Hibernate.isInitialized( c.getLazyDataPoints() ) );
 		Hibernate.initialize( c.getLazyDataPoints() );
 		assertSame( lazyDataPoint, c.getLazyDataPoints().iterator().next() );
 		expectedInitializedObjects.add( c.getLazyDataPoints().iterator().next() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery("delete from DataPoint").executeUpdate();
 		s.createQuery("delete from Container").executeUpdate();
 		s.createQuery("delete from Info").executeUpdate();
 		s.createQuery("delete from Owner").executeUpdate();
 		t.commit();
 		s.close();
 
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testExistingReadOnlyAfterSetSessionModifiableExistingProxyReadOnly() {
 		Container cOrig = createContainer();
 		Set expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						cOrig,
 						cOrig.getNoProxyInfo(),
 						cOrig.getProxyInfo(),
 						cOrig.getNonLazyInfo(),
 						cOrig.getNoProxyOwner(),
 						cOrig.getProxyOwner(),
 						cOrig.getNonLazyOwner(),
 						cOrig.getLazyDataPoints().iterator().next(),
 						cOrig.getNonLazyJoinDataPoints().iterator().next(),
 						cOrig.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		Set expectedReadOnlyObjects = new HashSet();
 		DataPoint lazyDataPointOrig = ( DataPoint ) cOrig.getLazyDataPoints().iterator().next();
 		Session s = openSession();
 		assertFalse( s.isDefaultReadOnly() );
 		Transaction t = s.beginTransaction();
 		s.save( cOrig );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.setDefaultReadOnly( true );
 		Container c = ( Container ) s.get( Container.class, cOrig.getId()  );
 		assertNotSame( cOrig, c );
 		expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		expectedReadOnlyObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNoProxyInfo(),
 						c.getProxyInfo(),
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						//c.getLazyDataPoints(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( false );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getNoProxyInfo() ) );
 		Hibernate.initialize( c.getNoProxyInfo() );
 		expectedInitializedObjects.add( c.getNoProxyInfo() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getProxyInfo() ) );
 		Hibernate.initialize( c.getProxyInfo() );
 		expectedInitializedObjects.add( c.getProxyInfo() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( true );
 		DataPoint lazyDataPoint = ( DataPoint ) s.load( DataPoint.class, lazyDataPointOrig.getId() );
 		s.setDefaultReadOnly( false );
 		assertFalse( Hibernate.isInitialized( c.getLazyDataPoints() ) );
 		Hibernate.initialize( c.getLazyDataPoints() );
 		assertSame( lazyDataPoint, c.getLazyDataPoints().iterator().next() );
 		expectedInitializedObjects.add( c.getLazyDataPoints().iterator().next() );
 		expectedReadOnlyObjects.add( lazyDataPoint );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery("delete from DataPoint").executeUpdate();
 		s.createQuery("delete from Container").executeUpdate();
 		s.createQuery("delete from Info").executeUpdate();
 		s.createQuery("delete from Owner").executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testDefaultModifiableWithReadOnlyQueryForEntity() {
 		Container cOrig = createContainer();
 		Set expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						cOrig,
 						cOrig.getNoProxyInfo(),
 						cOrig.getProxyInfo(),
 						cOrig.getNonLazyInfo(),
 						cOrig.getNoProxyOwner(),
 						cOrig.getProxyOwner(),
 						cOrig.getNonLazyOwner(),
 						cOrig.getLazyDataPoints().iterator().next(),
 						cOrig.getNonLazyJoinDataPoints().iterator().next(),
 						cOrig.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		Set expectedReadOnlyObjects = new HashSet();
 
 		Session s = openSession();
 		assertFalse( s.isDefaultReadOnly() );
 		Transaction t = s.beginTransaction();
 		s.save( cOrig );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		assertFalse( s.isDefaultReadOnly() );
 		Container c = ( Container ) s.createQuery( "from Container where id=" + cOrig.getId() )
 				.setReadOnly( true ).uniqueResult();
 		expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		expectedReadOnlyObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNoProxyInfo(),
 						c.getProxyInfo(),
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						//c.getLazyDataPoints(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getNoProxyInfo() ) );
 		Hibernate.initialize( c.getNoProxyInfo() );
 		expectedInitializedObjects.add( c.getNoProxyInfo() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getProxyInfo() ) );
 		Hibernate.initialize( c.getProxyInfo() );
 		expectedInitializedObjects.add( c.getProxyInfo() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getLazyDataPoints() ) );
 		Hibernate.initialize( c.getLazyDataPoints() );
 		expectedInitializedObjects.add( c.getLazyDataPoints().iterator().next() );
 		//expectedReadOnlyObjects.add(c.getLazyDataPoints().iterator().next() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery("delete from DataPoint").executeUpdate();
 		s.createQuery("delete from Container").executeUpdate();
 		s.createQuery("delete from Info").executeUpdate();
 		s.createQuery("delete from Owner").executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testDefaultReadOnlyWithModifiableQueryForEntity() {
 		Container cOrig = createContainer();
 		Set expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						cOrig,
 						cOrig.getNoProxyInfo(),
 						cOrig.getProxyInfo(),
 						cOrig.getNonLazyInfo(),
 						cOrig.getNoProxyOwner(),
 						cOrig.getProxyOwner(),
 						cOrig.getNonLazyOwner(),
 						cOrig.getLazyDataPoints().iterator().next(),
 						cOrig.getNonLazyJoinDataPoints().iterator().next(),
 						cOrig.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		Set expectedReadOnlyObjects = new HashSet();
 
 		Session s = openSession();
 		assertFalse( s.isDefaultReadOnly() );
 		Transaction t = s.beginTransaction();
 		s.save( cOrig );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		Container c = ( Container ) s.createQuery( "from Container where id=" + cOrig.getId() )
 				.setReadOnly( false ).uniqueResult();
 		expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		expectedReadOnlyObjects = new HashSet();
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getNoProxyInfo() ) );
 		Hibernate.initialize( c.getNoProxyInfo() );
 		expectedInitializedObjects.add( c.getNoProxyInfo() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getProxyInfo() ) );
 		Hibernate.initialize( c.getProxyInfo() );
 		expectedInitializedObjects.add( c.getProxyInfo() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getLazyDataPoints() ) );
 		Hibernate.initialize( c.getLazyDataPoints() );
 		expectedInitializedObjects.add( c.getLazyDataPoints().iterator().next() );
 		expectedReadOnlyObjects.add(c.getLazyDataPoints().iterator().next() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery("delete from DataPoint").executeUpdate();
 		s.createQuery("delete from Container").executeUpdate();
 		s.createQuery("delete from Info").executeUpdate();
 		s.createQuery("delete from Owner").executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testDefaultReadOnlyWithQueryForEntity() {
 		Container cOrig = createContainer();
 		Set expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						cOrig,
 						cOrig.getNoProxyInfo(),
 						cOrig.getProxyInfo(),
 						cOrig.getNonLazyInfo(),
 						cOrig.getNoProxyOwner(),
 						cOrig.getProxyOwner(),
 						cOrig.getNonLazyOwner(),
 						cOrig.getLazyDataPoints().iterator().next(),
 						cOrig.getNonLazyJoinDataPoints().iterator().next(),
 						cOrig.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		Set expectedReadOnlyObjects = new HashSet();
 
 		Session s = openSession();
 		assertFalse( s.isDefaultReadOnly() );
 		Transaction t = s.beginTransaction();
 		s.save( cOrig );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		Container c = ( Container ) s.createQuery( "from Container where id=" + cOrig.getId() )
 				.uniqueResult();
 		expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		expectedReadOnlyObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNoProxyInfo(),
 						c.getProxyInfo(),
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						//c.getLazyDataPoints(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getNoProxyInfo() ) );
 		Hibernate.initialize( c.getNoProxyInfo() );
 		expectedInitializedObjects.add( c.getNoProxyInfo() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getProxyInfo() ) );
 		Hibernate.initialize( c.getProxyInfo() );
 		expectedInitializedObjects.add( c.getProxyInfo() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getLazyDataPoints() ) );
 		Hibernate.initialize( c.getLazyDataPoints() );
 		expectedInitializedObjects.add( c.getLazyDataPoints().iterator().next() );
 		expectedReadOnlyObjects.add(c.getLazyDataPoints().iterator().next() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery("delete from DataPoint").executeUpdate();
 		s.createQuery("delete from Container").executeUpdate();
 		s.createQuery("delete from Info").executeUpdate();
 		s.createQuery("delete from Owner").executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testDefaultModifiableWithQueryForEntity() {
 		Container cOrig = createContainer();
 		Set expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						cOrig,
 						cOrig.getNoProxyInfo(),
 						cOrig.getProxyInfo(),
 						cOrig.getNonLazyInfo(),
 						cOrig.getNoProxyOwner(),
 						cOrig.getProxyOwner(),
 						cOrig.getNonLazyOwner(),
 						cOrig.getLazyDataPoints().iterator().next(),
 						cOrig.getNonLazyJoinDataPoints().iterator().next(),
 						cOrig.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		Set expectedReadOnlyObjects = new HashSet();
 
 		Session s = openSession();
 		assertFalse( s.isDefaultReadOnly() );
 		Transaction t = s.beginTransaction();
 		s.save( cOrig );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		assertFalse( s.isDefaultReadOnly() );
 		Container c = ( Container ) s.createQuery( "from Container where id=" + cOrig.getId() )
 				.uniqueResult();
 		expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		expectedReadOnlyObjects = new HashSet();
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getNoProxyInfo() ) );
 		Hibernate.initialize( c.getNoProxyInfo() );
 		expectedInitializedObjects.add( c.getNoProxyInfo() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getProxyInfo() ) );
 		Hibernate.initialize( c.getProxyInfo() );
 		expectedInitializedObjects.add( c.getProxyInfo() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		assertFalse( Hibernate.isInitialized( c.getLazyDataPoints() ) );
 		Hibernate.initialize( c.getLazyDataPoints() );
 		expectedInitializedObjects.add( c.getLazyDataPoints().iterator().next() );
 		//expectedReadOnlyObjects.add(c.getLazyDataPoints().iterator().next() );
 		checkContainer( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery("delete from DataPoint").executeUpdate();
 		s.createQuery("delete from Container").executeUpdate();
 		s.createQuery("delete from Info").executeUpdate();
 		s.createQuery("delete from Owner").executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testDefaultModifiableWithReadOnlyQueryForCollectionEntities() {
 		Container cOrig = createContainer();
 		Set expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						cOrig,
 						cOrig.getNoProxyInfo(),
 						cOrig.getProxyInfo(),
 						cOrig.getNonLazyInfo(),
 						cOrig.getNoProxyOwner(),
 						cOrig.getProxyOwner(),
 						cOrig.getNonLazyOwner(),
 						cOrig.getLazyDataPoints().iterator().next(),
 						cOrig.getNonLazyJoinDataPoints().iterator().next(),
 						cOrig.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		Set expectedReadOnlyObjects = new HashSet();
 
 		Session s = openSession();
 		assertFalse( s.isDefaultReadOnly() );
 		Transaction t = s.beginTransaction();
 		s.save( cOrig );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		assertFalse( s.isDefaultReadOnly() );
 		DataPoint dp = ( DataPoint ) s.createQuery( "select c.lazyDataPoints from Container c join c.lazyDataPoints where c.id=" + cOrig.getId() )
 				.setReadOnly( true ).uniqueResult();
 		assertTrue( s.isReadOnly( dp ) );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery("delete from DataPoint").executeUpdate();
 		s.createQuery("delete from Container").executeUpdate();
 		s.createQuery("delete from Info").executeUpdate();
 		s.createQuery("delete from Owner").executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testDefaultReadOnlyWithModifiableFilterCollectionEntities() {
 		Container cOrig = createContainer();
 		Set expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						cOrig,
 						cOrig.getNoProxyInfo(),
 						cOrig.getProxyInfo(),
 						cOrig.getNonLazyInfo(),
 						cOrig.getNoProxyOwner(),
 						cOrig.getProxyOwner(),
 						cOrig.getNonLazyOwner(),
 						cOrig.getLazyDataPoints().iterator().next(),
 						cOrig.getNonLazyJoinDataPoints().iterator().next(),
 						cOrig.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		Set expectedReadOnlyObjects = new HashSet();
 
 		Session s = openSession();
 		assertFalse( s.isDefaultReadOnly() );
 		Transaction t = s.beginTransaction();
 		s.save( cOrig );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		Container c = ( Container ) s.get( Container.class, cOrig.getId() );
 		assertNotSame( cOrig, c );
 		expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		expectedReadOnlyObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNoProxyInfo(),
 						c.getProxyInfo(),
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						//c.getLazyDataPoints(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		List list = s.createFilter( c.getLazyDataPoints(), "" )
 				.setMaxResults(1)
 				.setReadOnly( false )
 				.list();
 		assertEquals( 1, list.size() );
 		assertFalse( s.isReadOnly( list.get( 0 ) ) );
 		list = s.createFilter( c.getNonLazyJoinDataPoints(), "" )
 				.setMaxResults(1)
 				.setReadOnly( false )
 				.list();
 		assertEquals( 1, list.size() );
 		assertTrue( s.isReadOnly( list.get( 0 ) ) );
 		list = s.createFilter( c.getNonLazySelectDataPoints(), "" )
 				.setMaxResults(1)
 				.setReadOnly( false )
 				.list();
 		assertEquals( 1, list.size() );
 		assertTrue( s.isReadOnly( list.get( 0 ) ) );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery("delete from DataPoint").executeUpdate();
 		s.createQuery("delete from Container").executeUpdate();
 		s.createQuery("delete from Info").executeUpdate();
 		s.createQuery("delete from Owner").executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testDefaultModifiableWithReadOnlyFilterCollectionEntities() {
 		Container cOrig = createContainer();
 		Set expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						cOrig,
 						cOrig.getNoProxyInfo(),
 						cOrig.getProxyInfo(),
 						cOrig.getNonLazyInfo(),
 						cOrig.getNoProxyOwner(),
 						cOrig.getProxyOwner(),
 						cOrig.getNonLazyOwner(),
 						cOrig.getLazyDataPoints().iterator().next(),
 						cOrig.getNonLazyJoinDataPoints().iterator().next(),
 						cOrig.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		Set expectedReadOnlyObjects = new HashSet();
 
 		Session s = openSession();
 		assertFalse( s.isDefaultReadOnly() );
 		Transaction t = s.beginTransaction();
 		s.save( cOrig );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		assertFalse( s.isDefaultReadOnly() );
 		Container c = ( Container ) s.get( Container.class, cOrig.getId() );
 		assertNotSame( cOrig, c );
 		expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		expectedReadOnlyObjects = new HashSet();
 		List list = s.createFilter( c.getLazyDataPoints(), "" )
 				.setMaxResults(1)
 				.setReadOnly( true )
 				.list();
 		assertEquals( 1, list.size() );
 		assertTrue( s.isReadOnly( list.get( 0 ) ) );
 		list = s.createFilter( c.getNonLazyJoinDataPoints(), "" )
 				.setMaxResults(1)
 				.setReadOnly( true )
 				.list();
 		assertEquals( 1, list.size() );
 		assertFalse( s.isReadOnly( list.get( 0 ) ) );
 		list = s.createFilter( c.getNonLazySelectDataPoints(), "" )
 				.setMaxResults(1)
 				.setReadOnly( true )
 				.list();
 		assertEquals( 1, list.size() );
 		assertFalse( s.isReadOnly( list.get( 0 ) ) );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery("delete from DataPoint").executeUpdate();
 		s.createQuery("delete from Container").executeUpdate();
 		s.createQuery("delete from Info").executeUpdate();
 		s.createQuery("delete from Owner").executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testDefaultReadOnlyWithFilterCollectionEntities() {
 		Container cOrig = createContainer();
 		Set expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						cOrig,
 						cOrig.getNoProxyInfo(),
 						cOrig.getProxyInfo(),
 						cOrig.getNonLazyInfo(),
 						cOrig.getNoProxyOwner(),
 						cOrig.getProxyOwner(),
 						cOrig.getNonLazyOwner(),
 						cOrig.getLazyDataPoints().iterator().next(),
 						cOrig.getNonLazyJoinDataPoints().iterator().next(),
 						cOrig.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		Set expectedReadOnlyObjects = new HashSet();
 
 		Session s = openSession();
 		assertFalse( s.isDefaultReadOnly() );
 		Transaction t = s.beginTransaction();
 		s.save( cOrig );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		Container c = ( Container ) s.get( Container.class, cOrig.getId() );
 		assertNotSame( cOrig, c );
 		expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		expectedReadOnlyObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNoProxyInfo(),
 						c.getProxyInfo(),
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						//c.getLazyDataPoints(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		List list = s.createFilter( c.getLazyDataPoints(), "" )
 				.setMaxResults( 1 )
 				.list();
 		assertEquals( 1, list.size() );
 		assertTrue( s.isReadOnly( list.get( 0 ) ) );
 		list = s.createFilter( c.getNonLazyJoinDataPoints(), "" )
 				.setMaxResults( 1 )
 				.list();
 		assertEquals( 1, list.size() );
 		assertTrue( s.isReadOnly( list.get( 0 ) ) );
 		list = s.createFilter( c.getNonLazySelectDataPoints(), "" )
 				.setMaxResults( 1 )
 				.list();
 		assertEquals( 1, list.size() );
 		assertTrue( s.isReadOnly( list.get( 0 ) ) );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery("delete from DataPoint").executeUpdate();
 		s.createQuery("delete from Container").executeUpdate();
 		s.createQuery("delete from Info").executeUpdate();
 		s.createQuery("delete from Owner").executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	@Test
 	public void testDefaultModifiableWithFilterCollectionEntities() {
 		Container cOrig = createContainer();
 		Set expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						cOrig,
 						cOrig.getNoProxyInfo(),
 						cOrig.getProxyInfo(),
 						cOrig.getNonLazyInfo(),
 						cOrig.getNoProxyOwner(),
 						cOrig.getProxyOwner(),
 						cOrig.getNonLazyOwner(),
 						cOrig.getLazyDataPoints().iterator().next(),
 						cOrig.getNonLazyJoinDataPoints().iterator().next(),
 						cOrig.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		Set expectedReadOnlyObjects = new HashSet();
 
 		Session s = openSession();
 		assertFalse( s.isDefaultReadOnly() );
 		Transaction t = s.beginTransaction();
 		s.save( cOrig );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		s.setDefaultReadOnly( true );
 		assertTrue( s.isDefaultReadOnly() );
 		checkContainer( cOrig, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		assertFalse( s.isDefaultReadOnly() );
 		Container c = ( Container ) s.get( Container.class, cOrig.getId() );
 		assertNotSame( cOrig, c );
 		expectedInitializedObjects = new HashSet(
 				Arrays.asList(
 						c,
 						c.getNonLazyInfo(),
 						c.getNoProxyOwner(),
 						c.getProxyOwner(),
 						c.getNonLazyOwner(),
 						c.getNonLazyJoinDataPoints().iterator().next(),
 						c.getNonLazySelectDataPoints().iterator().next()
 				)
 		);
 		expectedReadOnlyObjects = new HashSet();
 		List list = s.createFilter( c.getLazyDataPoints(), "" )
 				.setMaxResults( 1 )
 				.list();
 		assertEquals( 1, list.size() );
 		assertFalse( s.isReadOnly( list.get( 0 ) ) );
 		list = s.createFilter( c.getNonLazyJoinDataPoints(), "" )
 				.setMaxResults( 1 )
 				.list();
 		assertEquals( 1, list.size() );
 		assertFalse( s.isReadOnly( list.get( 0 ) ) );
 		list = s.createFilter( c.getNonLazySelectDataPoints(), "" )
 				.setMaxResults( 1 )
 				.list();
 		assertEquals( 1, list.size() );
 		assertFalse( s.isReadOnly( list.get( 0 ) ) );
 		t.commit();
 		s.close();
 		s = openSession();
 		t = s.beginTransaction();
 		s.createQuery("delete from DataPoint").executeUpdate();
 		s.createQuery("delete from Container").executeUpdate();
 		s.createQuery("delete from Info").executeUpdate();
 		s.createQuery("delete from Owner").executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	private Container createContainer() {
 		Container c = new Container( "container" );
 		c.setNoProxyInfo( new Info( "no-proxy info" ) );
 		c.setProxyInfo( new Info( "proxy info" ) );
 		c.setNonLazyInfo( new Info( "non-lazy info" ) );
 		c.setNoProxyOwner( new Owner( "no-proxy owner" ) );
 		c.setProxyOwner( new Owner( "proxy owner" ) );
 		c.setNonLazyOwner( new Owner( "non-lazy owner" ) );
 		c.getLazyDataPoints().add( new DataPoint( new BigDecimal( 1 ), new BigDecimal( 1 ), "lazy data point" ) );
 		c.getNonLazyJoinDataPoints().add( new DataPoint( new BigDecimal( 2 ), new BigDecimal( 2 ), "non-lazy join data point" ) );
 		c.getNonLazySelectDataPoints().add( new DataPoint( new BigDecimal( 3 ), new BigDecimal( 3 ), "non-lazy select data point" ) );
 		return c;
 	}
 
 	private void checkContainer(Container c, Set expectedInitializedObjects, Set expectedReadOnlyObjects, Session s) {
 		checkObject( c, expectedInitializedObjects, expectedReadOnlyObjects, s );
 		if ( ! expectedInitializedObjects.contains( c ) ) {
 			return;
 		}
 		checkObject( c.getNoProxyInfo(), expectedInitializedObjects, expectedReadOnlyObjects, s);
 		checkObject( c.getProxyInfo(), expectedInitializedObjects, expectedReadOnlyObjects, s);
 		checkObject( c.getNonLazyInfo(), expectedInitializedObjects, expectedReadOnlyObjects, s );
 		checkObject( c.getNoProxyOwner(), expectedInitializedObjects, expectedReadOnlyObjects, s );
 		checkObject( c.getProxyOwner(), expectedInitializedObjects, expectedReadOnlyObjects, s );
 		checkObject( c.getNonLazyOwner(), expectedInitializedObjects, expectedReadOnlyObjects, s );
 		if ( Hibernate.isInitialized( c.getLazyDataPoints() ) ) {
 			for ( Iterator it=c.getLazyDataPoints().iterator(); it.hasNext(); ) {
 				checkObject( it.next(), expectedInitializedObjects, expectedReadOnlyObjects, s );
 			}
 		}
 		for ( Iterator it=c.getNonLazyJoinDataPoints().iterator(); it.hasNext(); ) {
 			checkObject( it.next(), expectedInitializedObjects, expectedReadOnlyObjects, s );
 		}
 		for ( Iterator it=c.getNonLazySelectDataPoints().iterator(); it.hasNext(); ) {
 			checkObject( it.next(), expectedInitializedObjects, expectedReadOnlyObjects, s );
 		}
 	}
 
 	private void checkObject(Object entityOrProxy, Set expectedInitializedObjects, Set expectedReadOnlyObjects, Session s) {
 		boolean isExpectedToBeInitialized = expectedInitializedObjects.contains( entityOrProxy );
 		boolean isExpectedToBeReadOnly = expectedReadOnlyObjects.contains( entityOrProxy );
 		SessionImplementor si = (SessionImplementor) s;
 		assertEquals( isExpectedToBeInitialized, Hibernate.isInitialized( entityOrProxy ) );
 		assertEquals( isExpectedToBeReadOnly, s.isReadOnly( entityOrProxy ) );
 		if ( Hibernate.isInitialized( entityOrProxy ) ) {
 			Object entity = ( entityOrProxy instanceof HibernateProxy ?
 					( ( HibernateProxy ) entityOrProxy ).getHibernateLazyInitializer().getImplementation( si ) :
 					entityOrProxy
 			);
 			assertNotNull( entity );
 			assertEquals( isExpectedToBeReadOnly, s.isReadOnly( entity ));
 		}
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/resulttransformer/PartnerA.java b/hibernate-core/src/test/java/org/hibernate/test/resulttransformer/PartnerA.java
index 552055b7e5..ac96506e72 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/resulttransformer/PartnerA.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/resulttransformer/PartnerA.java
@@ -1,56 +1,56 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009, Red Hat, Inc. and/or its affiliates or third-
  * party contributors as indicated by the @author tags or express 
  * copyright attribution statements applied by the authors.  
  * All third-party contributions are distributed under license by 
  * Red Hat, Inc.
  *
  * This copyrighted material is made available to anyone wishing to 
  * use, modify, copy, or redistribute it subject to the terms and 
  * conditions of the GNU Lesser General Public License, as published 
  * by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of 
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU 
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public 
  * License along with this distribution; if not, write to:
  * 
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
 package org.hibernate.test.resulttransformer;
 
 
 /**
  * @author Sharath Reddy
  *
  */
 public class PartnerA {
 
 	private Long id;
 	private String name;
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/schemaupdate/SchemaExportManagedConnectionTest.java b/hibernate-core/src/test/java/org/hibernate/test/schemaupdate/SchemaExportManagedConnectionTest.java
index da607b6e15..5ec0f4e4f6 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/schemaupdate/SchemaExportManagedConnectionTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/schemaupdate/SchemaExportManagedConnectionTest.java
@@ -1,37 +1,37 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.schemaupdate;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.tool.hbm2ddl.SchemaExport;
 
 /**
  * @author Gail Badner
  */
 public class SchemaExportManagedConnectionTest extends SchemaExportTest {
 	@Override
 	protected SchemaExport createSchemaExport(Configuration cfg) {
 		return new SchemaExport( cfg );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/schemaupdate/SchemaExportSuppliedConnectionTest.java b/hibernate-core/src/test/java/org/hibernate/test/schemaupdate/SchemaExportSuppliedConnectionTest.java
index 4fc2d0fcb2..451f66be42 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/schemaupdate/SchemaExportSuppliedConnectionTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/schemaupdate/SchemaExportSuppliedConnectionTest.java
@@ -1,44 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.schemaupdate;
 
 import org.junit.After;
 import org.junit.Before;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.testing.ServiceRegistryBuilder;
 import org.hibernate.tool.hbm2ddl.SchemaExport;
 
 /**
  * @author Gail Badner
  */
 public class SchemaExportSuppliedConnectionTest extends SchemaExportTest {
 
 	@Override
 	protected SchemaExport createSchemaExport(Configuration cfg) {
 		return new SchemaExport( serviceRegistry, cfg );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/sql/check/ResultCheckStyleTest.java b/hibernate-core/src/test/java/org/hibernate/test/sql/check/ResultCheckStyleTest.java
index 9449d4148f..19f23acfea 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/sql/check/ResultCheckStyleTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/sql/check/ResultCheckStyleTest.java
@@ -1,165 +1,161 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.sql.check;
 
 import org.junit.Test;
 
 import org.hibernate.HibernateException;
 import org.hibernate.JDBCException;
 import org.hibernate.Session;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.fail;
 
 /**
  * @author Steve Ebersole
  */
 @SuppressWarnings( {"UnusedDeclaration"})
 public abstract class ResultCheckStyleTest extends BaseCoreFunctionalTestCase {
 	public String getCacheConcurrencyStrategy() {
 		return null;
 	}
 
 	@Test
 	public void testInsertionFailureWithExceptionChecking() {
 		Session s = openSession();
 		s.beginTransaction();
 		ExceptionCheckingEntity e = new ExceptionCheckingEntity();
 		e.setName( "dummy" );
 		s.save( e );
 		try {
 			s.flush();
 			fail( "expection flush failure!" );
 		}
 		catch( JDBCException ex ) {
 			// these should specifically be JDBCExceptions...
 		}
 		s.clear();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testInsertionFailureWithParamChecking() {
 		Session s = openSession();
 		s.beginTransaction();
 		ParamCheckingEntity e = new ParamCheckingEntity();
 		e.setName( "dummy" );
 		s.save( e );
 		try {
 			s.flush();
 			fail( "expection flush failure!" );
 		}
 		catch( HibernateException ex ) {
 			// these should specifically be HibernateExceptions...
 		}
 		s.clear();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testUpdateFailureWithExceptionChecking() {
 		Session s = openSession();
 		s.beginTransaction();
 		ExceptionCheckingEntity e = new ExceptionCheckingEntity();
 		e.setId( Long.valueOf( 1 ) );
 		e.setName( "dummy" );
 		s.update( e );
 		try {
 			s.flush();
 			fail( "expection flush failure!" );
 		}
 		catch( JDBCException ex ) {
 			// these should specifically be JDBCExceptions...
 		}
 		s.clear();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testUpdateFailureWithParamChecking() {
 		Session s = openSession();
 		s.beginTransaction();
 		ParamCheckingEntity e = new ParamCheckingEntity();
 		e.setId( Long.valueOf( 1 ) );
 		e.setName( "dummy" );
 		s.update( e );
 		try {
 			s.flush();
 			fail( "expection flush failure!" );
 		}
 		catch( HibernateException ex ) {
 			// these should specifically be HibernateExceptions...
 		}
 		s.clear();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testDeleteWithExceptionChecking() {
 		Session s = openSession();
 		s.beginTransaction();
 		ExceptionCheckingEntity e = new ExceptionCheckingEntity();
 		e.setId( Long.valueOf( 1 ) );
 		e.setName( "dummy" );
 		s.delete( e );
 		try {
 			s.flush();
 			fail( "expection flush failure!" );
 		}
 		catch( JDBCException ex ) {
 			// these should specifically be JDBCExceptions...
 		}
 		s.clear();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testDeleteWithParamChecking() {
 		Session s = openSession();
 		s.beginTransaction();
 		ParamCheckingEntity e = new ParamCheckingEntity();
 		e.setId( Long.valueOf( 1 ) );
 		e.setName( "dummy" );
 		s.delete( e );
 		try {
 			s.flush();
 			fail( "expection flush failure!" );
 		}
 		catch( HibernateException ex ) {
 			// these should specifically be HibernateExceptions...
 		}
 		s.clear();
 		s.getTransaction().commit();
 		s.close();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/sql/hand/ImageHolder.java b/hibernate-core/src/test/java/org/hibernate/test/sql/hand/ImageHolder.java
index 6ee23fbe47..b6e5f107d0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/sql/hand/ImageHolder.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/sql/hand/ImageHolder.java
@@ -1,66 +1,66 @@
 /*
  * Copyright (c) 2009, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.sql.hand;
 
 
 /**
  * @author Gail Badner
  */
 public class ImageHolder {
 	private Long id;
 	private byte[] photo;
 
 	public ImageHolder(byte[] photo) {
 		this.photo = photo;
 	}
 
 	public ImageHolder() {
 	}
 
 	/**
 	 * @return Returns the id.
 	 */
 	public Long getId() {
 		return id;
 	}
 
 	/**
 	 * @param id The id to set.
 	 */
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	/**
 	 * @return Returns the photo.
 	 */
 	public byte[] getPhoto() {
 		return photo;
 	}
 
 	/**
 	 * @param photo The photo to set.
 	 */
 	public void setPhoto(byte[] photo) {
 		this.photo = photo;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/sql/hand/TextHolder.java b/hibernate-core/src/test/java/org/hibernate/test/sql/hand/TextHolder.java
index f77382a857..7f4ebfe9e9 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/sql/hand/TextHolder.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/sql/hand/TextHolder.java
@@ -1,66 +1,66 @@
 /*
  * Copyright (c) 2009, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.sql.hand;
 
 
 /**
  * @author Gail Badner
  */
 public class TextHolder {
 	private Long id;
 	private String description;
 
 	public TextHolder(String description) {
 		this.description = description;
 	}
 
 	public TextHolder() {
 	}
 
 	/**
 	 * @return Returns the id.
 	 */
 	public Long getId() {
 		return id;
 	}
 
 	/**
 	 * @param id The id to set.
 	 */
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	/**
 	 * @return Returns the description.
 	 */
 	public String getDescription() {
 		return description;
 	}
 
 	/**
 	 * @param description The description to set.
 	 */
 	public void setDescription(String description) {
 		this.description = description;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/sql/hand/custom/CustomStoredProcTestSupport.java b/hibernate-core/src/test/java/org/hibernate/test/sql/hand/custom/CustomStoredProcTestSupport.java
index b43ccac65f..80e6b46126 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/sql/hand/custom/CustomStoredProcTestSupport.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/sql/hand/custom/CustomStoredProcTestSupport.java
@@ -1,112 +1,110 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.sql.hand.custom;
 
 import java.sql.SQLException;
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Query;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.test.sql.hand.Employment;
 import org.hibernate.test.sql.hand.Organization;
 import org.hibernate.test.sql.hand.Person;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Abstract test case defining tests of stored procedure support.
  *
  * @author Gail Badner
  */
 @SuppressWarnings( {"UnusedDeclaration"})
 public abstract class CustomStoredProcTestSupport extends CustomSQLTestSupport {
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testScalarStoredProcedure() throws HibernateException, SQLException {
 		Session s = openSession();
 		Query namedQuery = s.getNamedQuery( "simpleScalar" );
 		namedQuery.setLong( "number", 43 );
 		List list = namedQuery.list();
 		Object o[] = ( Object[] ) list.get( 0 );
 		assertEquals( o[0], "getAll" );
 		assertEquals( o[1], Long.valueOf( 43 ) );
 		s.close();
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public void testParameterHandling() throws HibernateException, SQLException {
 		Session s = openSession();
 
 		Query namedQuery = s.getNamedQuery( "paramhandling" );
 		namedQuery.setLong( 0, 10 );
 		namedQuery.setLong( 1, 20 );
 		List list = namedQuery.list();
 		Object[] o = ( Object[] ) list.get( 0 );
 		assertEquals( o[0], Long.valueOf( 10 ) );
 		assertEquals( o[1], Long.valueOf( 20 ) );
 
 		namedQuery = s.getNamedQuery( "paramhandling_mixed" );
 		namedQuery.setLong( 0, 10 );
 		namedQuery.setLong( "second", 20 );
 		list = namedQuery.list();
 		o = ( Object[] ) list.get( 0 );
 		assertEquals( o[0], Long.valueOf( 10 ) );
 		assertEquals( o[1], Long.valueOf( 20 ) );
 		s.close();
 	}
 
 	@Test
 	public void testEntityStoredProcedure() throws HibernateException, SQLException {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Organization ifa = new Organization( "IFA" );
 		Organization jboss = new Organization( "JBoss" );
 		Person gavin = new Person( "Gavin" );
 		Employment emp = new Employment( gavin, jboss, "AU" );
 		s.persist( ifa );
 		s.persist( jboss );
 		s.persist( gavin );
 		s.persist( emp );
 
 		Query namedQuery = s.getNamedQuery( "selectAllEmployments" );
 		List list = namedQuery.list();
 		assertTrue( list.get( 0 ) instanceof Employment );
 		s.delete( emp );
 		s.delete( ifa );
 		s.delete( jboss );
 		s.delete( gavin );
 
 		t.commit();
 		s.close();
 	}
 
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/sql/hand/custom/sqlserver/SQLServerCustomSQLTest.java b/hibernate-core/src/test/java/org/hibernate/test/sql/hand/custom/sqlserver/SQLServerCustomSQLTest.java
index 051dc85fbb..5f39f6bc43 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/sql/hand/custom/sqlserver/SQLServerCustomSQLTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/sql/hand/custom/sqlserver/SQLServerCustomSQLTest.java
@@ -1,40 +1,40 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.sql.hand.custom.sqlserver;
 
 import org.hibernate.dialect.SQLServerDialect;
 import org.hibernate.test.sql.hand.custom.CustomStoredProcTestSupport;
 import org.hibernate.testing.RequiresDialect;
 
 /**
  * Custom SQL tests for SQLServer
  *
  * @author Gail Badner
  */
 @RequiresDialect( SQLServerDialect.class )
 public class SQLServerCustomSQLTest extends CustomStoredProcTestSupport {
 	public String[] getMappings() {
 		return new String[] { "sql/hand/custom/sqlserver/Mappings.hbm.xml" };
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/sql/hand/query/NativeSQLQueriesTest.java b/hibernate-core/src/test/java/org/hibernate/test/sql/hand/query/NativeSQLQueriesTest.java
index b7ae12442f..9251269f1f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/sql/hand/query/NativeSQLQueriesTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/sql/hand/query/NativeSQLQueriesTest.java
@@ -1,886 +1,885 @@
 package org.hibernate.test.sql.hand.query;
 
 import java.io.Serializable;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.HibernateException;
 import org.hibernate.Query;
 import org.hibernate.QueryException;
 import org.hibernate.SQLQuery;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.dialect.MySQL5Dialect;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.test.sql.hand.Dimension;
 import org.hibernate.test.sql.hand.Employment;
 import org.hibernate.test.sql.hand.Group;
 import org.hibernate.test.sql.hand.ImageHolder;
 import org.hibernate.test.sql.hand.Order;
 import org.hibernate.test.sql.hand.Organization;
 import org.hibernate.test.sql.hand.Person;
 import org.hibernate.test.sql.hand.Product;
 import org.hibernate.test.sql.hand.SpaceShip;
 import org.hibernate.test.sql.hand.Speech;
 import org.hibernate.test.sql.hand.TextHolder;
 import org.hibernate.testing.FailureExpected;
 import org.hibernate.testing.RequiresDialect;
 import org.hibernate.testing.SkipForDialect;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.hibernate.transform.BasicTransformerAdapter;
 import org.hibernate.transform.DistinctRootEntityResultTransformer;
 import org.hibernate.transform.Transformers;
 import org.hibernate.type.FloatType;
 import org.hibernate.type.LongType;
 import org.hibernate.type.StringType;
 import org.hibernate.type.TimestampType;
 
 import static org.hibernate.testing.junit4.ExtraAssertions.assertClassAssignability;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * Tests of various features of native SQL queries.
  *
  * @author Steve Ebersole
  */
-@SuppressWarnings({ "UnnecessaryBoxing", "UnnecessaryUnboxing" })
 public class NativeSQLQueriesTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] { "sql/hand/query/NativeSQLQueries.hbm.xml" };
 	}
 
 	@Override
     public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 	}
 
 	protected String getOrganizationFetchJoinEmploymentSQL() {
 		return "SELECT org.ORGID as {org.id}, " +
 		       "        org.NAME as {org.name}, " +
 		       "        emp.EMPLOYER as {emp.key}, " +
 		       "        emp.EMPID as {emp.element}, " +
 		       "        {emp.element.*}  " +
 		       "FROM ORGANIZATION org " +
 		       "    LEFT OUTER JOIN EMPLOYMENT emp ON org.ORGID = emp.EMPLOYER";
 	}
 
 	protected String getOrganizationJoinEmploymentSQL() {
 		return "SELECT org.ORGID as {org.id}, " +
 		       "        org.NAME as {org.name}, " +
 		       "        {emp.*}  " +
 		       "FROM ORGANIZATION org " +
 		       "    LEFT OUTER JOIN EMPLOYMENT emp ON org.ORGID = emp.EMPLOYER";
 	}
 
 	protected String getEmploymentSQL() {
 		return "SELECT * FROM EMPLOYMENT";
 	}
 
 	protected String getEmploymentSQLMixedScalarEntity() {
 		return "SELECT e.*, e.employer as employerid  FROM EMPLOYMENT e" ;
 	}
 
 	protected String getOrgEmpRegionSQL() {
 		return "select {org.*}, {emp.*}, emp.REGIONCODE " +
 		       "from ORGANIZATION org " +
 		       "     left outer join EMPLOYMENT emp on org.ORGID = emp.EMPLOYER";
 	}
 
 	protected String getOrgEmpPersonSQL() {
 		return "select {org.*}, {emp.*}, {pers.*} " +
 		       "from ORGANIZATION org " +
 		       "    join EMPLOYMENT emp on org.ORGID = emp.EMPLOYER " +
 		       "    join PERSON pers on pers.PERID = emp.EMPLOYEE ";
 	}
 
 	protected String getDescriptionsSQL() {
 		return "select DESCRIPTION from TEXT_HOLDER";
 	}
 
 	protected String getPhotosSQL() {
 		return "select PHOTO from IMAGE_HOLDER";
 	}
 
 	@Test
     @SkipForDialect( H2Dialect.class )
 	public void testFailOnNoAddEntityOrScalar() {
 		// Note: this passes, but for the wrong reason.
 		//      there is actually an exception thrown, but it is the database
 		//      throwing a sql exception because the SQL gets passed
 		//      "un-processed"...
 		//
 		// Oddly, H2 accepts this query.
 		Session s = openSession();
 		s.beginTransaction();
 		try {
 			String sql = "select {org.*} " +
 			             "from organization org";
 			s.createSQLQuery( sql ).list();
 			fail( "Should throw an exception since no addEntity nor addScalar has been performed." );
 		}
 		catch( HibernateException he) {
 			// expected behavior
 		}
 		finally {
 			s.getTransaction().rollback();
 			s.close();
 		}
 	}
 
 	@Test
 	public void testManualSynchronization() {
 		Session s = openSession();
 		s.beginTransaction();
 
 		sessionFactory().getStatistics().clear();
 
 		// create an Organization...
 		Organization jboss = new Organization( "JBoss" );
 		s.persist( jboss );
 
 		// now query on Employment, this should not cause an auto-flush
 		s.createSQLQuery( getEmploymentSQL() ).list();
 		assertEquals( 0, sessionFactory().getStatistics().getEntityInsertCount() );
 
 		// now try to query on Employment but this time add Organization as a synchronized query space...
 		s.createSQLQuery( getEmploymentSQL() ).addSynchronizedEntityClass( Organization.class ).list();
 		assertEquals( 1, sessionFactory().getStatistics().getEntityInsertCount() );
 
 		// clean up
 		s.delete( jboss );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testSQLQueryInterface() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Organization ifa = new Organization("IFA");
 		Organization jboss = new Organization("JBoss");
 		Person gavin = new Person("Gavin");
 		Employment emp = new Employment(gavin, jboss, "AU");
 
 		s.persist(ifa);
 		s.persist(jboss);
 		s.persist(gavin);
 		s.persist(emp);
 
 		List l = s.createSQLQuery( getOrgEmpRegionSQL() )
 				.addEntity("org", Organization.class)
 				.addJoin("emp", "org.employments")
 				.addScalar("regionCode", StringType.INSTANCE)
 				.list();
 		assertEquals( 2, l.size() );
 
 		l = s.createSQLQuery( getOrgEmpPersonSQL() )
 				.addEntity("org", Organization.class)
 				.addJoin("emp", "org.employments")
 				.addJoin("pers", "emp.employee")
 				.list();
 		assertEquals( l.size(), 1 );
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 
 		l = s.createSQLQuery( "select {org.*}, {emp.*} " +
 			       "from ORGANIZATION org " +
 			       "     left outer join EMPLOYMENT emp on org.ORGID = emp.EMPLOYER, ORGANIZATION org2" )
 		.addEntity("org", Organization.class)
 		.addJoin("emp", "org.employments")
 		.setResultTransformer( DistinctRootEntityResultTransformer.INSTANCE )
 		.list();
 		assertEquals( l.size(), 2 );
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 
 		s.delete(emp);
 		s.delete(gavin);
 		s.delete(ifa);
 		s.delete(jboss);
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testResultSetMappingDefinition() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Organization ifa = new Organization("IFA");
 		Organization jboss = new Organization("JBoss");
 		Person gavin = new Person("Gavin");
 		Employment emp = new Employment(gavin, jboss, "AU");
 
 		s.persist(ifa);
 		s.persist(jboss);
 		s.persist(gavin);
 		s.persist(emp);
 
 		List l = s.createSQLQuery( getOrgEmpRegionSQL() )
 				.setResultSetMapping( "org-emp-regionCode" )
 				.list();
 		assertEquals( l.size(), 2 );
 
 		l = s.createSQLQuery( getOrgEmpPersonSQL() )
 				.setResultSetMapping( "org-emp-person" )
 				.list();
 		assertEquals( l.size(), 1 );
 
 		s.delete(emp);
 		s.delete(gavin);
 		s.delete(ifa);
 		s.delete(jboss);
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testScalarValues() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Organization ifa = new Organization( "IFA" );
 		Organization jboss = new Organization( "JBoss" );
 
 		Serializable idIfa = s.save( ifa );
 		Serializable idJBoss = s.save( jboss );
 
 		s.flush();
 
 		List result = s.getNamedQuery( "orgNamesOnly" ).list();
 		assertTrue( result.contains( "IFA" ) );
 		assertTrue( result.contains( "JBoss" ) );
 
 		result = s.getNamedQuery( "orgNamesOnly" ).setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP).list();
 		Map m = (Map) result.get(0);
 		assertEquals( 2, result.size() );
 		assertEquals( 1, m.size() );
 		assertTrue( m.containsKey("NAME") );
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 
 		Iterator iter = s.getNamedQuery( "orgNamesAndOrgs" ).list().iterator();
 		Object[] o = ( Object[] ) iter.next();
 		assertEquals( o[0], "IFA" );
 		assertEquals( ( ( Organization ) o[1] ).getName(), "IFA" );
 		o = ( Object[] ) iter.next();
 		assertEquals( o[0], "JBoss" );
 		assertEquals( ( ( Organization ) o[1] ).getName(), "JBoss" );
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 
 		// test that the ordering of the results is truly based on the order in which they were defined
 		iter = s.getNamedQuery( "orgsAndOrgNames" ).list().iterator();
 		Object[] row = ( Object[] ) iter.next();
 		assertEquals( "expecting non-scalar result first", Organization.class, row[0].getClass() );
 		assertEquals( "expecting scalar result second", String.class, row[1].getClass() );
 		assertEquals( ( ( Organization ) row[0] ).getName(), "IFA" );
 		assertEquals( row[1], "IFA" );
 		row = ( Object[] ) iter.next();
 		assertEquals( "expecting non-scalar result first", Organization.class, row[0].getClass() );
 		assertEquals( "expecting scalar result second", String.class, row[1].getClass() );
 		assertEquals( ( ( Organization ) row[0] ).getName(), "JBoss" );
 		assertEquals( row[1], "JBoss" );
 		assertFalse( iter.hasNext() );
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 
 		iter = s.getNamedQuery( "orgIdsAndOrgNames" ).list().iterator();
 		o = ( Object[] ) iter.next();
 		assertEquals( o[1], "IFA" );
 		assertEquals( o[0], idIfa );
 		o = ( Object[] ) iter.next();
 		assertEquals( o[1], "JBoss" );
 		assertEquals( o[0], idJBoss );
 
 		s.delete( ifa );
 		s.delete( jboss );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"deprecation", "UnusedDeclaration"})
 	public void testMappedAliasStrategy() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Organization ifa = new Organization("IFA");
 		Organization jboss = new Organization("JBoss");
 		Person gavin = new Person("Gavin");
 		Employment emp = new Employment(gavin, jboss, "AU");
 		Serializable orgId = s.save(jboss);
 		Serializable orgId2 = s.save(ifa);
 		s.save(gavin);
 		s.save(emp);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query namedQuery = s.getNamedQuery("AllEmploymentAsMapped");
 		List list = namedQuery.list();
 		assertEquals(1,list.size());
 		Employment emp2 = (Employment) list.get(0);
 		assertEquals(emp2.getEmploymentId(), emp.getEmploymentId() );
 		assertEquals(emp2.getStartDate().getDate(), emp.getStartDate().getDate() );
 		assertEquals(emp2.getEndDate(), emp.getEndDate() );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Query sqlQuery = s.getNamedQuery("EmploymentAndPerson");
 		sqlQuery.setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP);
 		list = sqlQuery.list();
 		assertEquals(1,list.size() );
 		Object res = list.get(0);
 		assertClassAssignability( Map.class, res.getClass() );
 		Map m = (Map) res;
 		assertEquals(2,m.size());
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		sqlQuery = s.getNamedQuery( "organizationreturnproperty" );
 		sqlQuery.setResultTransformer( Transformers.ALIAS_TO_ENTITY_MAP );
 		list = sqlQuery.list();
 		assertEquals( 2,list.size() );
 		m = (Map) list.get(0);
 		assertEquals( 2, m.size() );
 		assertTrue( m.containsKey("org") );
 		assertTrue( m.containsKey("emp") );
 		assertClassAssignability( m.get("org").getClass(), Organization.class );
 		if ( jboss.getId() == ( (Organization) m.get("org") ).getId() ) {
 			assertClassAssignability( m.get("emp").getClass(), Employment.class );
 		}
 		Map m2 = (Map) list.get(1);
 		assertEquals( 2, m.size() );
 		assertTrue( m2.containsKey("org") );
 		assertTrue( m2.containsKey("emp") );
 		assertClassAssignability( m2.get("org").getClass(), Organization.class );
 		if ( jboss.getId() == ( (Organization) m2.get("org") ).getId() ) {
 			assertClassAssignability( m2.get("emp").getClass(), Employment.class );
 		}
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		namedQuery = s.getNamedQuery("EmploymentAndPerson");
 		list = namedQuery.list();
 		assertEquals(1,list.size() );
 		Object[] objs = (Object[]) list.get(0);
 		assertEquals(2, objs.length);
 		emp2 = (Employment) objs[0];
 		gavin = (Person) objs[1];
 		s.delete(emp2);
 		s.delete(jboss);
 		s.delete(gavin);
 		s.delete(ifa);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	@FailureExpected( jiraKey = "unknown" )
 	public void testCompositeIdJoins() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Person person = new Person();
 		person.setName( "Noob" );
 
 		Product product = new Product();
 		product.setProductId( new Product.ProductId() );
 		product.getProductId().setOrgid( "x" );
 		product.getProductId().setProductnumber( "1234" );
 		product.setName( "Hibernate 3" );
 
 		Order order = new Order();
 		order.setOrderId( new Order.OrderId() );
 		order.getOrderId().setOrdernumber( "1" );
 		order.getOrderId().setOrgid( "y" );
 
 		product.getOrders().add( order );
 		order.setProduct( product );
 		order.setPerson( person );
 
 		s.save( product );
 		s.save( order);
 		s.save( person );
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Product p = (Product) s.createQuery( "from Product p join fetch p.orders" ).list().get(0);
 		assertTrue(Hibernate.isInitialized( p.getOrders()));
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Object[] o =  (Object[]) s.createSQLQuery( "select\r\n" +
 				"        product.orgid as {product.id.orgid}," +
 				"        product.productnumber as {product.id.productnumber}," +
 				"        {prod_orders}.orgid as orgid3_1_,\r\n" +
 				"        {prod_orders}.ordernumber as ordernum2_3_1_,\r\n" +
 				"        product.name as {product.name}," +
 				"        {prod_orders.element.*}" +
 				/*"        orders.PROD_NO as PROD4_3_1_,\r\n" +
 				"        orders.person as person3_1_,\r\n" +
 				"        orders.PROD_ORGID as PROD3_0__,\r\n" +
 				"        orders.PROD_NO as PROD4_0__,\r\n" +
 				"        orders.orgid as orgid0__,\r\n" +
 				"        orders.ordernumber as ordernum2_0__ \r\n" +*/
 				"    from\r\n" +
 				"        Product product \r\n" +
 				"    inner join\r\n" +
 				"        TBL_ORDER {prod_orders} \r\n" +
 				"            on product.orgid={prod_orders}.PROD_ORGID \r\n" +
 				"            and product.productnumber={prod_orders}.PROD_NO" )
 				.addEntity( "product", Product.class )
 				.addJoin( "prod_orders", "product.orders" )
 				.list().get(0);
 
 		p = (Product) o[0];
 		assertTrue(Hibernate.isInitialized( p.getOrders() ));
 		assertNotNull(p.getOrders().iterator().next());
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedDeclaration", "deprecation", "UnusedAssignment"})
 	public void testAutoDetectAliasing() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Organization ifa = new Organization("IFA");
 		Organization jboss = new Organization("JBoss");
 		Person gavin = new Person("Gavin");
 		Employment emp = new Employment(gavin, jboss, "AU");
 		Serializable orgId = s.save(jboss);
 		Serializable orgId2 = s.save(ifa);
 		s.save(gavin);
 		s.save(emp);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		List list = s.createSQLQuery( getEmploymentSQL() )
 				.addEntity( Employment.class.getName() )
 				.list();
 		assertEquals( 1,list.size() );
 
 		Employment emp2 = (Employment) list.get(0);
 		assertEquals(emp2.getEmploymentId(), emp.getEmploymentId() );
 		assertEquals(emp2.getStartDate().getDate(), emp.getStartDate().getDate() );
 		assertEquals(emp2.getEndDate(), emp.getEndDate() );
 
 		s.clear();
 
 		list = s.createSQLQuery( getEmploymentSQL() )
 		.addEntity( Employment.class.getName() )
 		.setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP)
 		.list();
 		assertEquals( 1,list.size() );
 		Map m = (Map) list.get(0);
 		assertTrue(m.containsKey("Employment"));
 		assertEquals(1,m.size());
 
 		list = s.createSQLQuery(getEmploymentSQL()).list();
 		assertEquals(1, list.size());
 		Object[] o = (Object[]) list.get(0);
 		assertEquals(8, o.length);
 
 		list = s.createSQLQuery( getEmploymentSQL() ).setResultTransformer( new UpperCasedAliasToEntityMapResultTransformer() ).list();
 		assertEquals(1, list.size());
 		m = (Map) list.get(0);
 		assertTrue(m.containsKey("EMPID"));
 		assertTrue(m.containsKey("AMOUNT"));
 		assertTrue(m.containsKey("ENDDATE"));
 		assertEquals(8, m.size());
 
 		list = s.createSQLQuery( getEmploymentSQLMixedScalarEntity() ).addScalar( "employerid" ).addEntity( Employment.class ).list();
 		assertEquals(1, list.size());
 		o = (Object[]) list.get(0);
 		assertEquals(2, o.length);
 		assertClassAssignability( Number.class, o[0].getClass() );
 		assertClassAssignability( Employment.class, o[1].getClass() );
 
 
 
 		Query queryWithCollection = s.getNamedQuery("organizationEmploymentsExplicitAliases");
 		queryWithCollection.setLong("id",  jboss.getId() );
 		list = queryWithCollection.list();
 		assertEquals(list.size(),1);
 
 		s.clear();
 
 		list = s.createSQLQuery( getOrganizationJoinEmploymentSQL() )
 				.addEntity( "org", Organization.class )
 				.addJoin( "emp", "org.employments" )
 				.list();
 		assertEquals( 2,list.size() );
 
 		s.clear();
 
 		list = s.createSQLQuery( getOrganizationFetchJoinEmploymentSQL() )
 				.addEntity( "org", Organization.class )
 				.addJoin( "emp", "org.employments" )
 				.list();
 		assertEquals( 2,list.size() );
 
 		s.clear();
 
 		// TODO : why twice?
 		s.getNamedQuery( "organizationreturnproperty" ).list();
 		list = s.getNamedQuery( "organizationreturnproperty" ).list();
 		assertEquals( 2,list.size() );
 
 		s.clear();
 
 		list = s.getNamedQuery( "organizationautodetect" ).list();
 		assertEquals( 2,list.size() );
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete(emp2);
 
 		s.delete(jboss);
 		s.delete(gavin);
 		s.delete(ifa);
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		Dimension dim = new Dimension( 3, Integer.MAX_VALUE );
 		s.save( dim );
 		list = s.createSQLQuery( "select d_len * d_width as surface, d_len * d_width * 10 as volume from Dimension" ).list();
 		s.delete( dim );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		SpaceShip enterprise = new SpaceShip();
 		enterprise.setModel( "USS" );
 		enterprise.setName( "Entreprise" );
 		enterprise.setSpeed( 50d );
 		Dimension d = new Dimension(45, 10);
 		enterprise.setDimensions( d );
 		s.save( enterprise );
 		Object[] result = (Object[]) s.getNamedQuery( "spaceship" ).uniqueResult();
 		enterprise = ( SpaceShip ) result[0];
 		assertTrue(50d == enterprise.getSpeed() );
 		assertTrue( 450d == extractDoubleValue( result[1] ) );
 		assertTrue( 4500d == extractDoubleValue( result[2] ) );
 		s.delete( enterprise );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public void testExplicitReturnAPI() {
 		Session s = openSession();
 		s.beginTransaction();
 		Organization jboss = new Organization( "JBoss" );
 		Person me = new Person( "Steve" );
 		Employment emp = new Employment( me, jboss, "US" );
 		Serializable jbossId = s.save( jboss );
 		s.save( me );
 		s.save( emp );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 
 		String sql =
 				"SELECT org.ORGID 		as orgid," +
 				"       org.NAME 		as name," +
 				"       emp.EMPLOYER 	as employer," +
 				"       emp.EMPID 		as empid," +
 				"       emp.EMPLOYEE 	as employee," +
 				"       emp.EMPLOYER 	as employer," +
 				"       emp.STARTDATE 	as startDate," +
 				"       emp.ENDDATE 	as endDate," +
 				"       emp.REGIONCODE 	as regionCode," +
 				"       emp.AMOUNT 		as AMOUNT," +
 				"       emp.CURRENCY 	as CURRENCY" +
 				" FROM 	ORGANIZATION org" +
 				"    LEFT OUTER JOIN EMPLOYMENT emp ON org.ORGID = emp.EMPLOYER";
 
 		// as a control, lets apply an existing rs mapping
 		SQLQuery sqlQuery = s.createSQLQuery( sql );
 		sqlQuery.setResultSetMapping( "org-description" );
 		sqlQuery.list();
 
 		// next try a partial mapping def
 		sqlQuery.addRoot( "org", Organization.class );
 		sqlQuery.addFetch( "emp", "org", "employments" );
 		sqlQuery.list();
 
 		// now try full explicit mappings
 		sqlQuery.addRoot( "org", Organization.class )
 				.addProperty( "id", "orgid" )
 				.addProperty( "name" ).addColumnAlias( "name" );
 		sqlQuery.addFetch( "emp", "org", "employments" )
 				.addProperty( "key", "employer" )
 				.addProperty( "element", "empid" )
 				.addProperty( "element.employee", "employee" )
 				.addProperty( "element.employer", "employer" )
 				.addProperty( "element.startDate", "startDate" )
 				.addProperty( "element.endDate", "endDate" )
 				.addProperty( "element.regionCode", "regionCode" )
 				.addProperty( "element.employmentId", "empId" )
 				.addProperty( "element.salary" ).addColumnAlias( "AMOUNT" ).addColumnAlias( "CURRENCY" );
 		sqlQuery.list();
 
 		// lets try a totally different approach now and pull back scalars, first with explicit types
 		sqlQuery.addScalar( "orgid", LongType.INSTANCE )
 				.addScalar( "name", StringType.INSTANCE )
 				.addScalar( "empid", LongType.INSTANCE )
 				.addScalar( "employee", LongType.INSTANCE )
 				.addScalar( "startDate", TimestampType.INSTANCE )
 				.addScalar( "endDate", TimestampType.INSTANCE )
 				.addScalar( "regionCode", StringType.INSTANCE )
 				.addScalar( "empId", LongType.INSTANCE )
 				.addScalar( "AMOUNT", FloatType.INSTANCE )
 				.addScalar( "CURRENCY", StringType.INSTANCE );
 
 
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( emp );
 		s.delete( jboss );
 		s.delete( me );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testMixAndMatchEntityScalar() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Speech speech = new Speech();
 		speech.setLength( new Double( 23d ) );
 		speech.setName( "Mine" );
 		s.persist( speech );
 		s.flush();
 		s.clear();
 
 		List l = s.createSQLQuery( "select name, id, flength, name as scalarName from Speech" )
 				.setResultSetMapping( "speech" )
 				.list();
 		assertEquals( l.size(), 1 );
 
 		t.rollback();
 		s.close();
 	}
 
 	private double extractDoubleValue(Object value) {
 		if ( value instanceof BigInteger ) {
 			return ( ( BigInteger ) value ).doubleValue();
 		}
 		else if ( value instanceof BigDecimal ) {
 			return ( ( BigDecimal ) value ).doubleValue();
 		}
 		else {
 			return Double.valueOf( value.toString() ).doubleValue();
 		}
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked", "UnusedDeclaration"})
 	public void testAddJoinForManyToMany() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Person gavin = new Person( "Gavin" );
 		Person max = new Person( "Max" );
 		Person pete = new Person( "Pete" );
 
 		Group hibernate = new Group( "Hibernate" );
 		Group seam = new Group( "Seam" );
 
 		s.persist( gavin );
 		s.persist( max );
 		s.persist( pete );
 		s.persist( seam );
 		s.persist( hibernate );
 
 		hibernate.getPersons().add( gavin );
 		hibernate.getPersons().add( max );
 		seam.getPersons().add( gavin );
 		seam.getPersons().add( pete );
 
 		s.flush();
 		s.clear();
 
 		// todo : see http://opensource.atlassian.com/projects/hibernate/browse/HHH-3908
 //		String sqlStr = "SELECT {groupp.*} , {gp.*} " +
 //				"FROM GROUPP groupp, GROUP_PERSON gp, PERSON person WHERE groupp.ID = gp.GROUP_ID and person.PERID = gp.PERSON_ID";
 //
 //		List l = s.createSQLQuery( sqlStr )
 //				.addEntity("groupp", Group.class)
 //				.addJoin("gp","groupp.persons")
 //				.list();
 		List l = s.getNamedQuery( "manyToManyFetch" ).list();
 		//assertEquals( 2, l.size() );
 
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 
 		seam.getPersons().remove( gavin );
 		seam.getPersons().remove( pete );
 
 		hibernate.getPersons().remove( gavin );
 		hibernate.getPersons().remove( max );
 
 		s.delete( seam );
 		s.delete( hibernate );
 		s.delete( gavin );
 		s.delete( max );
 		s.delete( pete );
 
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testTextTypeInSQLQuery() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		String description = buildLongString( 15000, 'a' );
 		TextHolder holder = new TextHolder( description );
 		s.persist( holder );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		String descriptionRead = ( String ) s.createSQLQuery( getDescriptionsSQL() )
 				.uniqueResult();
 		assertEquals( description, descriptionRead );
 		s.delete( holder );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testImageTypeInSQLQuery() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		byte[] photo = buildLongByteArray( 15000, true );
 		ImageHolder holder = new ImageHolder( photo );
 		s.persist( holder );
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		byte[] photoRead = ( byte[] ) s.createSQLQuery( getPhotosSQL() )
 				.uniqueResult();
 		assertTrue( ArrayHelper.isEquals( photo, photoRead ) );
 		s.delete( holder );
 		t.commit();
 		s.close();
 	}
 	@Test
 	@RequiresDialect(MySQL5Dialect.class)
 	public void testEscapeColonInSQL() throws QueryException {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		SQLQuery query = s.createSQLQuery( "SELECT @row \\:= 1" );
 		List list = query.list();
 		assertTrue( list.get( 0 ).toString().equals( "1" ) );
 		t.commit();
 		s.close();
 	}
 
 	private String buildLongString(int size, char baseChar) {
 		StringBuilder buff = new StringBuilder();
 		for( int i = 0; i < size; i++ ) {
 			buff.append( baseChar );
 		}
 		return buff.toString();
 	}
 
 	private byte[] buildLongByteArray(int size, boolean on) {
 		byte[] data = new byte[size];
 		data[0] = mask( on );
 		for ( int i = 0; i < size; i++ ) {
 			data[i] = mask( on );
 			on = !on;
 		}
 		return data;
 	}
 
 	private byte mask(boolean on) {
 		return on ? ( byte ) 1 : ( byte ) 0;
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	private static class UpperCasedAliasToEntityMapResultTransformer extends BasicTransformerAdapter implements Serializable {
 		public Object transformTuple(Object[] tuple, String[] aliases) {
 			Map result = new HashMap( tuple.length );
 			for ( int i = 0; i < tuple.length; i++ ) {
 				String alias = aliases[i];
 				if ( alias != null ) {
 					result.put( alias.toUpperCase(), tuple[i] );
 				}
 			}
 			return result;
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/sql/refcursor/NumValue.java b/hibernate-core/src/test/java/org/hibernate/test/sql/refcursor/NumValue.java
index 2f73207acb..486e563764 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/sql/refcursor/NumValue.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/sql/refcursor/NumValue.java
@@ -1,95 +1,95 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2013 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.test.sql.refcursor;
 
 import java.io.Serializable;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.NamedNativeQueries;
 import javax.persistence.NamedNativeQuery;
 import javax.persistence.QueryHint;
 import javax.persistence.Table;
 
 @Entity
 @Table(name = "BOT_NUMVALUE")
 @NamedNativeQueries({
 		@NamedNativeQuery(name = "NumValue.getSomeValues",
 				query = "{ ? = call f_test_return_cursor() }",
 				resultClass = NumValue.class, hints = { @QueryHint(name = "org.hibernate.callable", value = "true") })
 })
 public class NumValue implements Serializable {
 	@Id
 	@Column(name = "BOT_NUM", nullable = false)
 	private long num;
 
 	@Column(name = "BOT_VALUE")
 	private String value;
 
 	public NumValue() {
 	}
 
 	public NumValue(long num, String value) {
 		this.num = num;
 		this.value = value;
 	}
 
 	@Override
 	public boolean equals(Object o) {
 		if ( this == o ) return true;
 		if ( !( o instanceof NumValue ) ) return false;
 
 		NumValue numValue = (NumValue) o;
 
 		if ( num != numValue.num ) return false;
 		if ( value != null ? !value.equals( numValue.value ) : numValue.value != null ) return false;
 
 		return true;
 	}
 
 	@Override
 	public int hashCode() {
 		int result = (int) ( num ^ ( num >>> 32 ) );
 		result = 31 * result + ( value != null ? value.hashCode() : 0 );
 		return result;
 	}
 
 	@Override
 	public String toString() {
 		return "NumValue(num = " + num + ", value = " + value + ")";
 	}
 
 	public long getNum() {
 		return num;
 	}
 
 	public void setNum(long num) {
 		this.num = num;
 	}
 
 	public String getValue() {
 		return value;
 	}
 
 	public void setValue(String value) {
 		this.value = value;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/subselect/Employee.java b/hibernate-core/src/test/java/org/hibernate/test/subselect/Employee.java
index 17852a2f0c..ed5cc80b22 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/subselect/Employee.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/subselect/Employee.java
@@ -1,53 +1,53 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2013, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.subselect;
 
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 
 @Entity
 public class Employee {
 	@Id
 	@GeneratedValue
 	private Long id;
 	private String name;
 
 	public String getName() {
 		return name;
 	}
 
 	@SuppressWarnings("unused")
 	private Employee() {
 	}
 
 	public Employee(String name) {
 		this.name = name;
 	}
 
 	@Override
 	public String toString() {
 		return name;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/type/TypeTest.java b/hibernate-core/src/test/java/org/hibernate/test/type/TypeTest.java
index 3f6a6de910..67f3c0d2f0 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/type/TypeTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/type/TypeTest.java
@@ -1,411 +1,410 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.type;
 import java.io.Serializable;
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import java.math.BigDecimal;
 import java.math.BigInteger;
 import java.sql.Time;
 import java.sql.Timestamp;
 import java.util.Calendar;
 import java.util.Currency;
 import java.util.GregorianCalendar;
 import java.util.Locale;
 import java.util.SimpleTimeZone;
 import java.util.TimeZone;
 
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.EntityMode;
 import org.hibernate.Session;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.SerializationHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.type.AbstractSingleColumnStandardBasicType;
 import org.hibernate.type.BigDecimalType;
 import org.hibernate.type.BigIntegerType;
 import org.hibernate.type.BinaryType;
 import org.hibernate.type.BooleanType;
 import org.hibernate.type.ByteType;
 import org.hibernate.type.CalendarDateType;
 import org.hibernate.type.CalendarType;
 import org.hibernate.type.CharArrayType;
 import org.hibernate.type.CharacterArrayType;
 import org.hibernate.type.CharacterType;
 import org.hibernate.type.ClassType;
 import org.hibernate.type.CurrencyType;
 import org.hibernate.type.DateType;
 import org.hibernate.type.DoubleType;
 import org.hibernate.type.FloatType;
 import org.hibernate.type.ImageType;
 import org.hibernate.type.IntegerType;
 import org.hibernate.type.LocaleType;
 import org.hibernate.type.LongType;
 import org.hibernate.type.MaterializedBlobType;
 import org.hibernate.type.MaterializedClobType;
 import org.hibernate.type.NumericBooleanType;
 import org.hibernate.type.SerializableType;
 import org.hibernate.type.ShortType;
 import org.hibernate.type.StringType;
 import org.hibernate.type.TextType;
 import org.hibernate.type.TimeType;
 import org.hibernate.type.TimeZoneType;
 import org.hibernate.type.TimestampType;
 import org.hibernate.type.TrueFalseType;
 import org.hibernate.type.YesNoType;
 
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Steve Ebersole
  */
-@SuppressWarnings( {"UnnecessaryBoxing"})
 public class TypeTest extends BaseUnitTestCase {
 	private SessionImplementor session;
 
 	@Before
 	public void setUp() throws Exception {
 		session = (SessionImplementor) Proxy.newProxyInstance(
 				getClass().getClassLoader(),
 				new Class[] { Session.class, SessionImplementor.class },
 				new SessionProxyHandler()
 		);
 	}
 
 	public static class SessionProxyHandler implements InvocationHandler {
 		public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 			if ( "getEntityMode".equals( method.getName() ) ) {
 				return EntityMode.POJO;
 			}
 			throw new UnsupportedOperationException( "Unexpected method call : " + method.getName() );
 		}
 	}
 
 	@Test
 	public void testBigDecimalType() {
 		final BigDecimal original = BigDecimal.valueOf( 100 );
 		final BigDecimal copy = BigDecimal.valueOf( 100 );
 		final BigDecimal different = BigDecimal.valueOf( 999 );
 
 		runBasicTests( BigDecimalType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testBigIntegerType() {
 		final BigInteger original = BigInteger.valueOf( 100 );
 		final BigInteger copy = BigInteger.valueOf( 100 );
 		final BigInteger different = BigInteger.valueOf( 999 );
 
 		runBasicTests( BigIntegerType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testBinaryType() {
 		final byte[] original = new byte[] { 1, 2, 3, 4 };
 		final byte[] copy = new byte[] { 1, 2, 3, 4 };
 		final byte[] different = new byte[] { 4, 3, 2, 1 };
 
 		runBasicTests( BinaryType.INSTANCE, original, copy, different );
 		runBasicTests( ImageType.INSTANCE, original, copy, different );
 		runBasicTests( MaterializedBlobType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	@SuppressWarnings( {"BooleanConstructorCall"})
 	public void testBooleanType() {
 		final Boolean original = Boolean.TRUE;
 		final Boolean copy = new Boolean( true );
 		final Boolean different = Boolean.FALSE;
 
 		runBasicTests( BooleanType.INSTANCE, original, copy, different );
 		runBasicTests( NumericBooleanType.INSTANCE, original, copy, different );
 		runBasicTests( YesNoType.INSTANCE, original, copy, different );
 		runBasicTests( TrueFalseType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testByteType() {
 		final Byte original = 0;
 		final Byte copy = new Byte( (byte) 0 );
 		final Byte different = 9;
 
 		runBasicTests( ByteType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testCalendarDateType() {
 		final Calendar original = new GregorianCalendar();
 		final Calendar copy = new GregorianCalendar();
 		final Calendar different = new GregorianCalendar();
 		different.set( Calendar.MONTH, 9 );
 		different.set( Calendar.DAY_OF_MONTH, 9 );
 		different.set( Calendar.YEAR, 2999 );
 
 		runBasicTests( CalendarDateType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testCalendarType() {
 		final long now = System.currentTimeMillis();
 		final Calendar original = new GregorianCalendar();
 		original.clear();
 		original.setTimeInMillis( now );
 		final Calendar copy = new GregorianCalendar();
 		copy.clear();
 		copy.setTimeInMillis( now );
 		final Calendar different = new GregorianCalendar();
 		different.setTimeInMillis( now + 9999 );
 
 		runBasicTests( CalendarType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testCharacterArrayType() {
 		final Character[] original = new Character[] { 'a', 'b' };
 		final Character[] copy = new Character[] { 'a', 'b' };
 		final Character[] different = new Character[] { 'a', 'b', 'c' };
 
 		runBasicTests( CharacterArrayType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testCharacterType() {
 		final Character original = 'a';
 		final Character copy = new Character( 'a' );
 		final Character different = 'b';
 
 		runBasicTests( CharacterType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testCharArrayType() {
 		final char[] original = new char[] { 'a', 'b' };
 		final char[] copy = new char[] { 'a', 'b' };
 		final char[] different = new char[] { 'a', 'b', 'c' };
 
 		runBasicTests( CharArrayType.INSTANCE, original, copy, different );
 		runBasicTests( CharArrayType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testClassType() {
 		final Class original = TypeTest.class;
 		final Class copy = (Class) SerializationHelper.clone( original );
 		final Class different = String.class;
 
 		runBasicTests( ClassType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testCurrencyType() {
 		final Currency original = Currency.getInstance( Locale.US );
 		final Currency copy = Currency.getInstance( Locale.US );
 		final Currency different = Currency.getInstance( Locale.UK );
 
 		runBasicTests( CurrencyType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testDateType() {
 		final long now = System.currentTimeMillis();
 		final java.sql.Date original = new java.sql.Date( now );
 		final java.sql.Date copy = new java.sql.Date( now );
 		Calendar cal = new GregorianCalendar();
 		cal.clear();
 		cal.setTimeInMillis( now );
 		cal.add( Calendar.YEAR, 1 );
 		final java.sql.Date different = new java.sql.Date( cal.getTime().getTime() );
 
 		runBasicTests( DateType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testDoubleType() {
 		final Double original = Double.valueOf( 100 );
 		final Double copy = Double.valueOf( 100 );
 		final Double different = Double.valueOf( 999 );
 
 		runBasicTests( DoubleType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testFloatType() {
 		final Float original = Float.valueOf( 100 );
 		final Float copy = Float.valueOf( 100 );
 		final Float different = Float.valueOf( 999 );
 
 		runBasicTests( FloatType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testIntegerType() {
 		final Integer original = 100;
 		final Integer copy = new Integer( 100 );
 		final Integer different = 999;
 
 		runBasicTests( IntegerType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testLocaleType() {
 		final Locale original = new Locale( "ab" );
 		final Locale copy = new Locale( "ab" );
 		final Locale different = new Locale( "yz" );
 
 		runBasicTests( LocaleType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testLongType() {
 		final Long original = 100L;
 		final Long copy = new Long( 100L );
 		final Long different = 999L;
 
 		runBasicTests( LongType.INSTANCE, original, copy, different );
 	}
 
 	private static class SerializableImpl implements Serializable {
 		private final int number;
 		SerializableImpl(int number) {
 			this.number = number;
 		}
 		@SuppressWarnings( {"EqualsWhichDoesntCheckParameterClass"})
 		public boolean equals(Object obj) {
 			return this.number == ( (SerializableImpl) obj ).number;
 		}
 	}
 
 	@Test
 	public void testSerializableType() {
 		final SerializableImpl original = new SerializableImpl(1);
 		final SerializableImpl copy = new SerializableImpl(1);
 		final SerializableImpl different = new SerializableImpl(2);
 
 		runBasicTests( SerializableType.INSTANCE, original, copy, different );
 		runBasicTests( new SerializableType<SerializableImpl>( SerializableImpl.class ), original, copy, different );
 	}
 
 	@Test
 	public void testShortType() {
 		final Short original = 100;
 		final Short copy = new Short( (short) 100 );
 		final Short different = 999;
 
 		runBasicTests( ShortType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testStringType() {
 		final String original = "abc";
 		final String copy = new String( original.toCharArray() );
 		final String different = "xyz";
 
 		runBasicTests( StringType.INSTANCE, original, copy, different );
 		runBasicTests( TextType.INSTANCE, original, copy, different );
 		runBasicTests( MaterializedClobType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testTimestampType() {
 		final long now = System.currentTimeMillis();
 		final Timestamp original = new Timestamp( now );
 		final Timestamp copy = new Timestamp( now );
 		final Timestamp different = new Timestamp( now + 9999 );
 
 		runBasicTests( TimestampType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testTimeType() {
 		final long now = System.currentTimeMillis();
 		final Time original = new Time( now );
 		final Time copy = new Time( now );
 		final Time different = new Time( now + 9999 );
 
 		runBasicTests( TimeType.INSTANCE, original, copy, different );
 	}
 
 	@Test
 	public void testDates() {
 		final long now = System.currentTimeMillis();
 		final java.util.Date original = new java.util.Date( now );
 		final java.util.Date copy = new java.util.Date( now );
 		final java.util.Date different = new java.util.Date( now + 9999 );
 		final java.util.Date different2 = new java.util.Date( now + ( 1000L * 60L * 60L * 24L * 365L ) );
 
 		runBasicTests( TimeType.INSTANCE, original, copy, different );
 		runBasicTests( TimestampType.INSTANCE, original, copy, different );
 		runBasicTests( DateType.INSTANCE, original, copy, different2 );
 	}
 
 	@Test
 	public void testTimeZoneType() {
 		final TimeZone original = new SimpleTimeZone( -1, "abc" );
 		final TimeZone copy = new SimpleTimeZone( -1, "abc" );
 		final TimeZone different = new SimpleTimeZone( -2, "xyz" );
 
 		runBasicTests( TimeZoneType.INSTANCE, original, copy, different );
 	}
 
 	protected <T> void runBasicTests(AbstractSingleColumnStandardBasicType<T> type, T original, T copy, T different) {
 		final boolean nonCopyable = Class.class.isInstance( original ) || Currency.class.isInstance( original );
 		if ( ! nonCopyable ) {
 			// these checks exclude classes which cannot really be cloned (singetons/enums)
 			assertFalse( original == copy );
 		}
 
 		assertTrue( original == type.replace( original, copy, null, null, null ) );
 
 		assertTrue( type.isSame( original, copy ) );
 		assertTrue( type.isEqual( original, copy ) );
 		assertTrue( type.isEqual( original, copy ) );
 		assertTrue( type.isEqual( original, copy, null ) );
 
 		assertFalse( type.isSame( original, different ) );
 		assertFalse( type.isEqual( original, different ) );
 		assertFalse( type.isEqual( original, different ) );
 		assertFalse( type.isEqual( original, different, null ) );
 
 		assertFalse( type.isDirty( original, copy , session ) );
 		assertFalse( type.isDirty( original, copy , ArrayHelper.FALSE, session ) );
 		assertFalse( type.isDirty( original, copy , ArrayHelper.TRUE, session ) );
 
 		assertTrue( type.isDirty( original, different , session ) );
 		assertFalse( type.isDirty( original, different , ArrayHelper.FALSE, session ) );
 		assertTrue( type.isDirty( original, different , ArrayHelper.TRUE, session ) );
 
 		assertFalse( type.isModified( original, copy, ArrayHelper.FALSE, session ) );
 		assertFalse( type.isModified( original, copy, ArrayHelper.TRUE, session ) );
 
 		assertTrue( type.isModified( original, different, ArrayHelper.FALSE, session ) );
 		assertTrue( type.isModified( original, different, ArrayHelper.TRUE, session ) );
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/type/descriptor/java/BigIntegerDescriptorTest.java b/hibernate-core/src/test/java/org/hibernate/test/type/descriptor/java/BigIntegerDescriptorTest.java
index 76ec3e94bb..1b34fbe892 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/type/descriptor/java/BigIntegerDescriptorTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/type/descriptor/java/BigIntegerDescriptorTest.java
@@ -1,50 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.type.descriptor.java;
 import java.math.BigInteger;
 
 import org.hibernate.type.descriptor.java.BigIntegerTypeDescriptor;
 
 /**
  * @author Steve Ebersole
  */
 public class BigIntegerDescriptorTest extends AbstractDescriptorTest<BigInteger> {
 	final BigInteger original = BigInteger.valueOf( 100 );
 	final BigInteger copy = BigInteger.valueOf( 100 );
 	final BigInteger different = BigInteger.valueOf( 999 );
 
 	public BigIntegerDescriptorTest() {
 		super( BigIntegerTypeDescriptor.INSTANCE );
 	}
 
 	@Override
 	protected Data<BigInteger> getTestData() {
 		return new Data<BigInteger>( original, copy, different );
 	}
 
 	@Override
 	protected boolean shouldBeMutable() {
 		return false;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/type/descriptor/java/BlobDescriptorTest.java b/hibernate-core/src/test/java/org/hibernate/test/type/descriptor/java/BlobDescriptorTest.java
index c79c0b233b..52cceb20fc 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/type/descriptor/java/BlobDescriptorTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/type/descriptor/java/BlobDescriptorTest.java
@@ -1,101 +1,101 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.type.descriptor.java;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 import java.io.IOException;
 import java.sql.Blob;
 import java.sql.SQLException;
 
 import org.hibernate.engine.jdbc.BlobImplementer;
 import org.hibernate.engine.jdbc.BlobProxy;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.type.descriptor.java.BlobTypeDescriptor;
 import org.hibernate.type.descriptor.java.DataHelper;
 import org.hibernate.type.descriptor.java.PrimitiveByteArrayTypeDescriptor;
 import org.junit.Test;
 
 /**
  * @author Steve Ebersole
  */
 public class BlobDescriptorTest extends AbstractDescriptorTest<Blob> {
 	final Blob original = BlobProxy.generateProxy( new byte[] { 1, 2, 3 } );
 	final Blob copy = BlobProxy.generateProxy( new byte[] { 1, 2, 3 } );
 	final Blob different = BlobProxy.generateProxy( new byte[] { 3, 2, 1 } );
 
 	public BlobDescriptorTest() {
 		super( BlobTypeDescriptor.INSTANCE );
 	}
 
 	@Override
 	protected Data<Blob> getTestData() {
 		return new Data<Blob>( original, copy, different );
 	}
 
 	@Override
 	protected boolean shouldBeMutable() {
 		return false;
 	}
 
 	@Test
 	@Override
 	public void testEquality() {
 		// blobs of the same internal value are not really comparable
 		assertFalse( original == copy );
 		assertTrue( BlobTypeDescriptor.INSTANCE.areEqual( original, original ) );
 		assertFalse( BlobTypeDescriptor.INSTANCE.areEqual( original, copy ) );
 		assertFalse( BlobTypeDescriptor.INSTANCE.areEqual( original, different ) );
 	}
 
 	@Test
 	@Override
 	public void testExternalization() {
 		// blobs of the same internal value are not really comparable
 		String externalized = BlobTypeDescriptor.INSTANCE.toString( original );
 		Blob consumed = BlobTypeDescriptor.INSTANCE.fromString( externalized );
 		try {
 			PrimitiveByteArrayTypeDescriptor.INSTANCE.areEqual(
 					DataHelper.extractBytes( original.getBinaryStream() ),
 					DataHelper.extractBytes( consumed.getBinaryStream() )
 			);
 		}
 		catch ( SQLException e ) {
 			fail( "SQLException accessing blob : " + e.getMessage() );
 		}
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-8193" )
 	public void testStreamResetOnAccess() throws IOException {
 		byte[] bytes = new byte[] { 1, 2, 3, 4 };
 		BlobImplementer blob = (BlobImplementer) BlobProxy.generateProxy( bytes );
 		int value = blob.getUnderlyingStream().getInputStream().read();
 		// Call to BlobImplementer#getUnderlyingStream() should mark input stream for reset.
 		assertEquals( bytes.length, blob.getUnderlyingStream().getInputStream().available() );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/type/descriptor/java/BooleanDescriptorTest.java b/hibernate-core/src/test/java/org/hibernate/test/type/descriptor/java/BooleanDescriptorTest.java
index a045f548c6..da7a032157 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/type/descriptor/java/BooleanDescriptorTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/type/descriptor/java/BooleanDescriptorTest.java
@@ -1,50 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.type.descriptor.java;
 
 
 import org.hibernate.type.descriptor.java.BooleanTypeDescriptor;
 
 /**
  * @author Steve Ebersole
  */
 public class BooleanDescriptorTest extends AbstractDescriptorTest<Boolean> {
 	final Boolean original = Boolean.TRUE;
 	final Boolean copy = new Boolean( true );
 	final Boolean different = Boolean.FALSE;
 
 	public BooleanDescriptorTest() {
 		super( BooleanTypeDescriptor.INSTANCE );
 	}
 
 	@Override
 	protected Data<Boolean> getTestData() {
 		return new Data<Boolean>( original, copy, different );
 	}
 
 	@Override
 	protected boolean shouldBeMutable() {
 		return false;
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/typedescriptor/CharInNativeQueryTest.java b/hibernate-core/src/test/java/org/hibernate/test/typedescriptor/CharInNativeQueryTest.java
index 1a8548af7b..a14e704757 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/typedescriptor/CharInNativeQueryTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/typedescriptor/CharInNativeQueryTest.java
@@ -1,72 +1,72 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
  package org.hibernate.test.typedescriptor;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
  /**
   * @author Strong Liu
   */
 public class CharInNativeQueryTest extends BaseCoreFunctionalTestCase {
     @Override
     protected Class<?>[] getAnnotatedClasses() {
         return new Class[] {
                 Issue.class
         };
     }
     @Test
     @TestForIssue(jiraKey = "HHH-2304")
     public void testNativeQuery() {
         Issue issue = new Issue();
         issue.setIssueNumber( "HHH-2304" );
         issue.setDescription( "Wrong type detection for sql type char(x) columns" );
 
         Session session = openSession();
         session.beginTransaction();
         session.persist( issue );
         session.getTransaction().commit();
         session.close();
 
         session = openSession(  );
         session.beginTransaction();
         Object issueNumber = session.createSQLQuery( "select issue.issueNumber from Issue issue" ).uniqueResult();
         session.getTransaction().commit();
         session.close();
 
         assertNotNull( issueNumber );
         assertTrue( issueNumber instanceof String );
         assertEquals( "HHH-2304", issueNumber );
 
 
     }
 
- }
\ No newline at end of file
+ }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/typedescriptor/Issue.java b/hibernate-core/src/test/java/org/hibernate/test/typedescriptor/Issue.java
index 2f162719f9..52a7063030 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/typedescriptor/Issue.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/typedescriptor/Issue.java
@@ -1,67 +1,67 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
  package org.hibernate.test.typedescriptor;
  
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 
  /**
   * @author Strong Liu
   */
 @Entity
  public class Issue {
     @Id
     @GeneratedValue
     private Long id;
     private String description;
     @Column(columnDefinition = "char(8)")
     private String issueNumber;
 
 
     public String getDescription() {
         return description;
     }
 
     public void setDescription(String description) {
         this.description = description;
     }
 
     public Long getId() {
         return id;
     }
 
     public void setId(Long id) {
         this.id = id;
     }
 
     public String getIssueNumber() {
         return issueNumber;
     }
 
     public void setIssueNumber(String issueNumber) {
         this.issueNumber = issueNumber;
     }
- }
\ No newline at end of file
+ }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/typeoverride/StoredPrefixedStringType.java b/hibernate-core/src/test/java/org/hibernate/test/typeoverride/StoredPrefixedStringType.java
index 18601dd2eb..a9bc8effbd 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/typeoverride/StoredPrefixedStringType.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/typeoverride/StoredPrefixedStringType.java
@@ -1,127 +1,127 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.typeoverride;
 
 import java.sql.CallableStatement;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.type.AbstractSingleColumnStandardBasicType;
 import org.hibernate.type.DiscriminatorType;
 import org.hibernate.type.StringType;
 import org.hibernate.type.descriptor.ValueBinder;
 import org.hibernate.type.descriptor.ValueExtractor;
 import org.hibernate.type.descriptor.WrapperOptions;
 import org.hibernate.type.descriptor.java.JavaTypeDescriptor;
 import org.hibernate.type.descriptor.sql.BasicBinder;
 import org.hibernate.type.descriptor.sql.BasicExtractor;
 import org.hibernate.type.descriptor.sql.SqlTypeDescriptor;
 import org.hibernate.type.descriptor.sql.VarcharTypeDescriptor;
 
 /**
  *
  * @author Gail Badner
  */
 public class StoredPrefixedStringType
 		extends AbstractSingleColumnStandardBasicType<String>
 		implements DiscriminatorType<String> {
 
 	public static final String PREFIX = "PRE:";
 
 	public static final SqlTypeDescriptor PREFIXED_VARCHAR_TYPE_DESCRIPTOR =
 			new VarcharTypeDescriptor() {
 				public <X> ValueBinder<X> getBinder(final JavaTypeDescriptor<X> javaTypeDescriptor) {
 					return new BasicBinder<X>( javaTypeDescriptor, this ) {
 						@Override
 						protected void doBind(PreparedStatement st, X value, int index, WrapperOptions options) throws SQLException {
 							String stringValue = javaTypeDescriptor.unwrap( value, String.class, options );
 							st.setString( index, PREFIX + stringValue );
 						}
 					};
 				}
 
 				public <X> ValueExtractor<X> getExtractor(final JavaTypeDescriptor<X> javaTypeDescriptor) {
 					return new BasicExtractor<X>( javaTypeDescriptor, this ) {
 						@Override
 						protected X doExtract(ResultSet rs, String name, WrapperOptions options) throws SQLException {
 							String stringValue = rs.getString( name );
 							if ( ! stringValue.startsWith( PREFIX ) ) {
 								throw new AssertionFailure( "Value read from resultset does not have prefix." );
 							}
 							return javaTypeDescriptor.wrap( stringValue.substring( PREFIX.length() ), options );
 						}
 
 						@Override
 						protected X doExtract(CallableStatement statement, int index, WrapperOptions options)
 								throws SQLException {
 							String stringValue = statement.getString( index );
 							if ( ! stringValue.startsWith( PREFIX ) ) {
 								throw new AssertionFailure( "Value read from procedure output param does not have prefix." );
 							}
 							return javaTypeDescriptor.wrap( stringValue.substring( PREFIX.length() ), options );
 						}
 
 						@Override
 						protected X doExtract(CallableStatement statement, String name, WrapperOptions options) throws SQLException {
 							String stringValue = statement.getString( name );
 							if ( ! stringValue.startsWith( PREFIX ) ) {
 								throw new AssertionFailure( "Value read from procedure output param does not have prefix." );
 							}
 							return javaTypeDescriptor.wrap( stringValue.substring( PREFIX.length() ), options );
 						}
 					};
 				}
 			};
 
 
 	public static final StoredPrefixedStringType INSTANCE = new StoredPrefixedStringType();
 
 	public StoredPrefixedStringType() {
 		super( PREFIXED_VARCHAR_TYPE_DESCRIPTOR, StringType.INSTANCE.getJavaTypeDescriptor() );
 	}
 
 	public String getName() {
 		return StringType.INSTANCE.getName();
 	}
 
 	@Override
 	protected boolean registerUnderJavaType() {
 		return true;
 	}
 
 	public String objectToSQLString(String value, Dialect dialect) throws Exception {
 		return StringType.INSTANCE.objectToSQLString( value, dialect );
 	}
 
 	public String stringToObject(String xml) throws Exception {
 		return StringType.INSTANCE.stringToObject( xml );
 	}
 
 	public String toString(String value) {
 		return StringType.INSTANCE.toString( value );
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/typeparameters/TypeParameterTest.java b/hibernate-core/src/test/java/org/hibernate/test/typeparameters/TypeParameterTest.java
index f87fcdd776..4ac8c9b213 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/typeparameters/TypeParameterTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/typeparameters/TypeParameterTest.java
@@ -1,153 +1,152 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.typeparameters;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.jdbc.Work;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.junit.Test;
 
 /**
  * Test for parameterizable types.
  * 
  * @author Michael Gloegl
  */
 public class TypeParameterTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] {
 				"typeparameters/Typedef.hbm.xml",
 				"typeparameters/Widget.hbm.xml"
 		};
 	}
 
 	@Test
-	@SuppressWarnings( {"UnnecessaryUnboxing"})
 	public void testSave() throws Exception {
 		deleteData();
 
 		Session s = openSession();
 		s.beginTransaction();
 		Widget obj = new Widget();
 		obj.setValueThree(5);
 		final Integer id = (Integer) s.save(obj);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 
 		doWork(id, s);
 
 		s.getTransaction().commit();
 		s.close();
 
 		deleteData();
 	}
 	
 	private void doWork(final Integer id, final Session s) {
 		s.doWork(
 				new Work() {
 					@Override
 					public void execute(Connection connection) throws SQLException {
 						PreparedStatement statement = ((SessionImplementor)s).getTransactionCoordinator().getJdbcCoordinator().getStatementPreparer().prepareStatement( "SELECT * FROM STRANGE_TYPED_OBJECT WHERE ID=?" );
 						statement.setInt(1, id.intValue());
 						ResultSet resultSet = ((SessionImplementor)s).getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( statement );
 
 						assertTrue("A row should have been returned", resultSet.next());
 						assertTrue("Default value should have been mapped to null", resultSet.getObject("VALUE_ONE") == null);
 						assertTrue("Default value should have been mapped to null", resultSet.getObject("VALUE_TWO") == null);
 						assertEquals("Non-Default value should not be changed", resultSet.getInt("VALUE_THREE"), 5);
 						assertTrue("Default value should have been mapped to null", resultSet.getObject("VALUE_FOUR") == null);
 					}
 				}
 		);
 	}
 
 	@Test
 	public void testLoading() throws Exception {
 		initData();
 
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Widget obj = (Widget) s.createQuery("from Widget o where o.string = :string").setString("string", "all-normal").uniqueResult();
 		assertEquals("Non-Default value incorrectly loaded", obj.getValueOne(), 7);
 		assertEquals("Non-Default value incorrectly loaded", obj.getValueTwo(), 8);
 		assertEquals("Non-Default value incorrectly loaded", obj.getValueThree(), 9);
 		assertEquals("Non-Default value incorrectly loaded", obj.getValueFour(), 10);
 
 		obj = (Widget) s.createQuery("from Widget o where o.string = :string").setString("string", "all-default").uniqueResult();
 		assertEquals("Default value incorrectly loaded", obj.getValueOne(), 1);
 		assertEquals("Default value incorrectly loaded", obj.getValueTwo(), 2);
 		assertEquals("Default value incorrectly loaded", obj.getValueThree(), -1);
 		assertEquals("Default value incorrectly loaded", obj.getValueFour(), -5);
 
 		
 		t.commit();
 		s.close();
 		deleteData();
 	}
 
 	private void initData() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 
 		Widget obj = new Widget();
 		obj.setValueOne(7);
 		obj.setValueTwo(8);
 		obj.setValueThree(9);
 		obj.setValueFour(10);
 		obj.setString("all-normal");
 		s.save(obj);
 
 		obj = new Widget();
 		obj.setValueOne(1);
 		obj.setValueTwo(2);
 		obj.setValueThree(-1);
 		obj.setValueFour(-5);
 		obj.setString("all-default");
 		s.save(obj);
 
 		t.commit();
 		s.close();
 	}
 
 	private void deleteData() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		s.createQuery( "delete from Widget" ).executeUpdate();
 		t.commit();
 		s.close();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/unidir/Parent1.java b/hibernate-core/src/test/java/org/hibernate/test/unidir/Parent1.java
index fcc21838ed..b896b1afe5 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/unidir/Parent1.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/unidir/Parent1.java
@@ -1,35 +1,35 @@
 /* 
  * Hibernate, Relational Persistence for Idiomatic Java
  * 
  * JBoss, Home of Professional Open Source
  * Copyright 2012 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.test.unidir;
 
 import javax.persistence.*;
 
 @Entity
 @Table(name = "PARENT1")
 public class Parent1 {
     @Id
     @Column(name = "ID")
     Long id;
 
     public Long getId() {
         return this.id;
     }
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/unionsubclass/UnionSubclassTest.java b/hibernate-core/src/test/java/org/hibernate/test/unionsubclass/UnionSubclassTest.java
index 1708acbe90..42a63fc9d5 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/unionsubclass/UnionSubclassTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/unionsubclass/UnionSubclassTest.java
@@ -1,426 +1,424 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.unionsubclass;
 
-import java.util.Iterator;
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.FetchMode;
 import org.hibernate.Hibernate;
 import org.hibernate.Query;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.criterion.Order;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Gavin King
  */
+@SuppressWarnings("unchecked")
 public class UnionSubclassTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "unionsubclass/Beings.hbm.xml" };
 	}
 
 	@Test
 	public void testUnionSubclassCollection() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Location mel = new Location("Earth");
 		s.save(mel);
 		
 		Human gavin = new Human();
 		gavin.setIdentity("gavin");
 		gavin.setSex('M');
 		gavin.setLocation(mel);
 		mel.addBeing(gavin);
 		
 		gavin.getInfo().put("foo", "bar");
 		gavin.getInfo().put("x", "y");
 		
 		t.commit();
 		s.close();
 
 		s = openSession();
 		t = s.beginTransaction();
 		gavin = (Human) s.createCriteria(Human.class).uniqueResult();
 		assertEquals( gavin.getInfo().size(), 2 );
 		s.delete(gavin);
 		s.delete( gavin.getLocation() );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testUnionSubclassFetchMode() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Location mel = new Location("Earth");
 		s.save(mel);
 		
 		Human gavin = new Human();
 		gavin.setIdentity("gavin");
 		gavin.setSex('M');
 		gavin.setLocation(mel);
 		mel.addBeing(gavin);
 		Human max = new Human();
 		max.setIdentity("max");
 		max.setSex('M');
 		max.setLocation(mel);
 		mel.addBeing(gavin);
 		
 		s.flush();
 		s.clear();
 		
 		List list = s.createCriteria(Human.class)
 			.setFetchMode("location", FetchMode.JOIN)
 			.setFetchMode("location.beings", FetchMode.JOIN)
 			.list();
-		
-		for (int i=0; i<list.size(); i++ ) {
-			Human h = (Human) list.get(i);
+
+		for ( Object aList : list ) {
+			Human h = (Human) aList;
 			assertTrue( Hibernate.isInitialized( h.getLocation() ) );
 			assertTrue( Hibernate.isInitialized( h.getLocation().getBeings() ) );
-			s.delete(h);
+			s.delete( h );
 		}
-		s.delete( s.get( Location.class, new Long(mel.getId()) ) );
+		s.delete( s.get( Location.class, mel.getId() ) );
 		t.commit();
 		s.close();
 	}
 	
 	@Test
 	public void testUnionSubclassOneToMany() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Location mel = new Location("Melbourne, Australia");
 		Location mars = new Location("Mars");
 		s.save(mel);
 		s.save(mars);
 		
 		Human gavin = new Human();
 		gavin.setIdentity("gavin");
 		gavin.setSex('M');
 		gavin.setLocation(mel);
 		mel.addBeing(gavin);
 		
 		Alien x23y4 = new Alien();
 		x23y4.setIdentity("x23y4$$hu%3");
 		x23y4.setLocation(mars);
 		x23y4.setSpecies("martian");
 		mars.addBeing(x23y4);
 		
 		Alien yy3dk = new Alien();
 		yy3dk.setIdentity("yy3dk&*!!!");
 		yy3dk.setLocation(mars);
 		yy3dk.setSpecies("martian");
 		mars.addBeing(yy3dk);
 		
 		Hive hive = new Hive();
 		hive.setLocation(mars);
 		hive.getMembers().add(x23y4);
 		x23y4.setHive(hive);
 		hive.getMembers().add(yy3dk);
 		yy3dk.setHive(hive);
 		s.persist(hive);
 		
 		yy3dk.getHivemates().add(x23y4);
 		x23y4.getHivemates().add(yy3dk);
 		
 		s.flush();
 		s.clear();
 		
 		hive = (Hive) s.createQuery("from Hive h").uniqueResult();
 		assertFalse( Hibernate.isInitialized( hive.getMembers() ) );
 		assertEquals( hive.getMembers().size(), 2 );
 		
 		s.clear();
 		
 		hive = (Hive) s.createQuery("from Hive h left join fetch h.location left join fetch h.members").uniqueResult();
 		assertTrue( Hibernate.isInitialized( hive.getMembers() ) );
 		assertEquals( hive.getMembers().size(), 2 );
 		
 		s.clear();
 		
 		x23y4 = (Alien) s.createQuery("from Alien a left join fetch a.hivemates where a.identity like 'x%'").uniqueResult();
 		assertTrue( Hibernate.isInitialized( x23y4.getHivemates() ) );
 		assertEquals( x23y4.getHivemates().size(), 1 );
 		
 		s.clear();
 		
 		x23y4 = (Alien) s.createQuery("from Alien a where a.identity like 'x%'").uniqueResult();
 		assertFalse( Hibernate.isInitialized( x23y4.getHivemates() ) );
 		assertEquals( x23y4.getHivemates().size(), 1 );
 		
 		s.clear();
 		
 		x23y4 = (Alien) s.createCriteria(Alien.class).addOrder( Order.asc("identity") ).list().get(0);
 		s.delete( x23y4.getHive() );
-		s.delete( s.get(Location.class, new Long( mel.getId() ) ) );
-		s.delete( s.get(Location.class, new Long( mars.getId() ) ) );
+		s.delete( s.get(Location.class, mel.getId() ) );
+		s.delete( s.get(Location.class, mars.getId() ) );
 		assertTrue( s.createQuery("from Being").list().isEmpty() );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testUnionSubclassManyToOne() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Location mel = new Location("Melbourne, Australia");
 		Location mars = new Location("Mars");
 		s.save(mel);
 		s.save(mars);
 		
 		Human gavin = new Human();
 		gavin.setIdentity("gavin");
 		gavin.setSex('M');
 		gavin.setLocation(mel);
 		mel.addBeing(gavin);
 		
 		Alien x23y4 = new Alien();
 		x23y4.setIdentity("x23y4$$hu%3");
 		x23y4.setLocation(mars);
 		x23y4.setSpecies("martian");
 		mars.addBeing(x23y4);
 		
 		Hive hive = new Hive();
 		hive.setLocation(mars);
 		hive.getMembers().add(x23y4);
 		x23y4.setHive(hive);
 		s.persist(hive);
 		
 		Thing thing = new Thing();
 		thing.setDescription("some thing");
 		thing.setOwner(gavin);
 		gavin.getThings().add(thing);
 		s.save(thing);
 		s.flush();
 		
 		s.clear();
 		
 		thing = (Thing) s.createQuery("from Thing t left join fetch t.owner").uniqueResult();
 		assertTrue( Hibernate.isInitialized( thing.getOwner() ) );
 		assertEquals( thing.getOwner().getIdentity(), "gavin" );
 		s.clear();
 		
 		thing = (Thing) s.createQuery("select t from Thing t left join t.owner where t.owner.identity='gavin'").uniqueResult();
 		assertFalse( Hibernate.isInitialized( thing.getOwner() ) );
 		assertEquals( thing.getOwner().getIdentity(), "gavin" );
 		s.clear();
 		
 		gavin = (Human) s.createQuery("from Human h left join fetch h.things").uniqueResult();
 		assertTrue( Hibernate.isInitialized( gavin.getThings() ) );
 		assertEquals( ( (Thing) gavin.getThings().get(0) ).getDescription(), "some thing" );
 		s.clear();
 		
 		assertTrue( s.createQuery("from Being b left join fetch b.things").list().size()==2 );
 		s.clear();
 		
 		gavin = (Human) s.createQuery("from Being b join fetch b.things").uniqueResult();
 		assertTrue( Hibernate.isInitialized( gavin.getThings() ) );
 		assertEquals( ( (Thing) gavin.getThings().get(0) ).getDescription(), "some thing" );
 		s.clear();
 		
 		gavin = (Human) s.createQuery("select h from Human h join h.things t where t.description='some thing'").uniqueResult();
 		assertFalse( Hibernate.isInitialized( gavin.getThings() ) );
 		assertEquals( ( (Thing) gavin.getThings().get(0) ).getDescription(), "some thing" );
 		s.clear();
 		
 		gavin = (Human) s.createQuery("select b from Being b join b.things t where t.description='some thing'").uniqueResult();
 		assertFalse( Hibernate.isInitialized( gavin.getThings() ) );
 		assertEquals( ( (Thing) gavin.getThings().get(0) ).getDescription(), "some thing" );
 		s.clear();
 		
-		thing = (Thing) s.get( Thing.class, new Long( thing.getId() ) );
+		thing = (Thing) s.get( Thing.class, thing.getId() );
 		assertFalse( Hibernate.isInitialized( thing.getOwner() ) );
 		assertEquals( thing.getOwner().getIdentity(), "gavin" );
 		
 		thing.getOwner().getThings().remove(thing);
 		thing.setOwner(x23y4);
 		x23y4.getThings().add(thing);
 		
 		s.flush();
 		
 		s.clear();
 
-		thing = (Thing) s.get( Thing.class, new Long( thing.getId() ) );
+		thing = (Thing) s.get( Thing.class, thing.getId() );
 		assertFalse( Hibernate.isInitialized( thing.getOwner() ) );
 		assertEquals( thing.getOwner().getIdentity(), "x23y4$$hu%3" );
 		
 		s.delete(thing);
 		x23y4 = (Alien) s.createCriteria(Alien.class).uniqueResult();
 		s.delete( x23y4.getHive() );
-		s.delete( s.get(Location.class, new Long( mel.getId() ) ) );
-		s.delete( s.get(Location.class, new Long( mars.getId() ) ) );
+		s.delete( s.get(Location.class, mel.getId() ) );
+		s.delete( s.get(Location.class, mars.getId() ) );
 		assertTrue( s.createQuery("from Being").list().isEmpty() );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testUnionSubclass() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Location mel = new Location("Melbourne, Australia");
 		Location atl = new Location("Atlanta, GA");
 		Location mars = new Location("Mars");
 		s.save(mel); 
 		s.save(atl); 
 		s.save(mars);
 		
 		Human gavin = new Human();
 		gavin.setIdentity("gavin");
 		gavin.setSex('M');
 		gavin.setLocation(mel);
 		mel.addBeing(gavin);
 		
 		Alien x23y4 = new Alien();
 		x23y4.setIdentity("x23y4$$hu%3");
 		x23y4.setLocation(mars);
 		x23y4.setSpecies("martian");
 		mars.addBeing(x23y4);
 		
 		Hive hive = new Hive();
 		hive.setLocation(mars);
 		hive.getMembers().add(x23y4);
 		x23y4.setHive(hive);
 		s.persist(hive);
 		
 		assertEquals( s.createQuery("from Being").list().size(), 2 );
 		assertEquals( s.createQuery("from Being b where b.class = Alien").list().size(), 1 );
 		assertEquals( s.createQuery("from Being b where type(b) = :what").setParameter("what", Alien.class).list().size(), 1 );
 		assertEquals( s.createQuery("from Being b where type(b) in :what").setParameterList("what", new Class[] { Alien.class, Human.class }).list().size(), 2 );
 		assertEquals( s.createQuery("from Alien").list().size(), 1 );
 		s.clear();
 
 		List beings = s.createQuery("from Being b left join fetch b.location").list();
-		for ( Iterator iter = beings.iterator(); iter.hasNext(); ) {
-			Being b = (Being) iter.next();
+		for ( Object being : beings ) {
+			Being b = (Being) being;
 			assertTrue( Hibernate.isInitialized( b.getLocation() ) );
 			assertNotNull( b.getLocation().getName() );
 			assertNotNull( b.getIdentity() );
 			assertNotNull( b.getSpecies() );
 		}
 		assertEquals( beings.size(), 2 );
 		s.clear();
 		
 		beings = s.createQuery("from Being").list();
-		for ( Iterator iter = beings.iterator(); iter.hasNext(); ) {
-			Being b = (Being) iter.next();
+		for ( Object being : beings ) {
+			Being b = (Being) being;
 			assertFalse( Hibernate.isInitialized( b.getLocation() ) );
 			assertNotNull( b.getLocation().getName() );
 			assertNotNull( b.getIdentity() );
 			assertNotNull( b.getSpecies() );
 		}
 		assertEquals( beings.size(), 2 );
 		s.clear();
 		
 		List locations = s.createQuery("from Location").list(); 
 		int count = 0;
-		for ( Iterator iter = locations.iterator(); iter.hasNext(); ) {
-			Location l = (Location) iter.next();
+		for ( Object location : locations ) {
+			Location l = (Location) location;
 			assertNotNull( l.getName() );
-			Iterator iter2 = l.getBeings().iterator();
-			while ( iter2.hasNext() ) {
+			for ( Object o : l.getBeings() ) {
 				count++;
-				assertSame( ( (Being) iter2.next() ).getLocation(), l );
+				assertSame( ( (Being) o ).getLocation(), l );
 			}
 		}
 		assertEquals(count, 2);
 		assertEquals( locations.size(), 3 );
 		s.clear();
 
 		locations = s.createQuery("from Location loc left join fetch loc.beings").list(); 
 		count = 0;
-		for ( Iterator iter = locations.iterator(); iter.hasNext(); ) {
-			Location l = (Location) iter.next();
+		for ( Object location : locations ) {
+			Location l = (Location) location;
 			assertNotNull( l.getName() );
-			Iterator iter2 = l.getBeings().iterator();
-			while ( iter2.hasNext() ) {
+			for ( Object o : l.getBeings() ) {
 				count++;
-				assertSame( ( (Being) iter2.next() ).getLocation(), l );
+				assertSame( ( (Being) o ).getLocation(), l );
 			}
 		}
 		assertEquals(count, 2);
 		assertEquals( locations.size(), 3 );
 		s.clear();
 
-		gavin = (Human) s.get( Human.class, new Long( gavin.getId() ) );
-		atl = (Location) s.get( Location.class, new Long( atl.getId() ) );
+		gavin = (Human) s.get( Human.class, gavin.getId() );
+		atl = (Location) s.get( Location.class, atl.getId() );
 		
  		atl.addBeing(gavin);
 		assertEquals( s.createQuery("from Human h where h.location.name like '%GA'").list().size(), 1 );
 		s.delete(gavin);
 		x23y4 = (Alien) s.createCriteria(Alien.class).uniqueResult();
 		s.delete( x23y4.getHive() );
 		assertTrue( s.createQuery("from Being").list().isEmpty() );
 		
 		s.createQuery("delete from Location").executeUpdate();
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testNestedUnionedSubclasses() throws Exception {
 		Session s;
 		Transaction tx;
 		s = openSession();
 		tx = s.beginTransaction();
 		Location mel = new Location("Earth");
 		Human marcf = new Human();
 		marcf.setIdentity("marc");
 		marcf.setSex('M');
 		mel.addBeing(marcf);
 		Employee steve = new Employee();
 		steve.setIdentity("steve");
 		steve.setSex('M');
-		steve.setSalary( new Double(0) );
+		steve.setSalary( (double) 0 );
 		mel.addBeing(steve);
 		s.persist(mel);
 		tx.commit();
 		s.close();
 		s = openSession();
 		tx = s.beginTransaction();
 		Query q = s.createQuery( "from Being h where h.identity = :name1 or h.identity = :name2" );
 		q.setString("name1", "marc");
 		q.setString("name2", "steve");
 		final List result = q.list();
 		assertEquals( 2, result.size() );
 		s.delete( result.get(0) );
 		s.delete( result.get(1) );
 		s.delete( ( (Human) result.get(0) ).getLocation() );
 		tx.commit();
 		s.close();
 	}
 
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/unionsubclass/alias/SellCarTest.java b/hibernate-core/src/test/java/org/hibernate/test/unionsubclass/alias/SellCarTest.java
index b5423b16c3..18961c3bc6 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/unionsubclass/alias/SellCarTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/unionsubclass/alias/SellCarTest.java
@@ -1,86 +1,85 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.unionsubclass.alias;
 
 import org.junit.Test;
 
 import org.hibernate.Query;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 
 /**
  * @author Strong Liu <stliu@redhat.com>
  */
 @TestForIssue( jiraKey = "HHH-4825" )
 public class SellCarTest extends BaseCoreFunctionalTestCase {
     public String[] getMappings() {
         return new String[] { "unionsubclass/alias/mapping.hbm.xml" };
     }
 
 	@Test
     public void testSellCar() throws Exception {
         prepareData();
         Session session = openSession();
         Transaction tx = session.beginTransaction();
         Query query = session.createQuery( "from Seller" );
         Seller seller = (Seller) query.uniqueResult();
         assertNotNull( seller );
         assertEquals( 1, seller.getBuyers().size() );
         tx.commit();
         session.close();
     }
 
     private void prepareData() {
         Session session = openSession();
         Transaction tx = session.beginTransaction();
         session.save( createData() );
         tx.commit();
         session.close();
     }
 
     @SuppressWarnings( {"unchecked"})
 	private Object createData() {
         Seller stliu = new Seller();
         stliu.setId( createID( "stliu" ) );
         CarBuyer zd = new CarBuyer();
         zd.setId( createID( "zd" ) );
         zd.setSeller( stliu );
         zd.setSellerName( stliu.getId().getName() );
         stliu.getBuyers().add( zd );
         return stliu;
     }
 
-    @SuppressWarnings( {"UnnecessaryBoxing"})
 	private PersonID createID( String name ) {
         PersonID id = new PersonID();
         id.setName( name );
         id.setNum( Long.valueOf( 100 ) );
         return id;
     }
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/unionsubclass2/UnionSubclassTest.java b/hibernate-core/src/test/java/org/hibernate/test/unionsubclass2/UnionSubclassTest.java
index 813cc134f8..9059834764 100755
--- a/hibernate-core/src/test/java/org/hibernate/test/unionsubclass2/UnionSubclassTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/unionsubclass2/UnionSubclassTest.java
@@ -1,256 +1,255 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.unionsubclass2;
 
 import java.math.BigDecimal;
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.criterion.Property;
 import org.hibernate.criterion.Restrictions;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Gavin King
  */
-@SuppressWarnings( {"UnnecessaryBoxing"})
 public class UnionSubclassTest extends BaseCoreFunctionalTestCase {
 	protected String[] getMappings() {
 		return new String[] { "unionsubclass2/Person.hbm.xml" };
 	}
 
 	@Test
 	public void testUnionSubclass() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		
 		Employee mark = new Employee();
 		mark.setName("Mark");
 		mark.setTitle("internal sales");
 		mark.setSex('M');
 		mark.setAddress("buckhead");
 		mark.setZip("30305");
 		mark.setCountry("USA");
 		
 		Customer joe = new Customer();
 		joe.setName("Joe");
 		joe.setAddress("San Francisco");
 		joe.setZip("XXXXX");
 		joe.setCountry("USA");
 		joe.setComments("Very demanding");
 		joe.setSex('M');
 		joe.setSalesperson(mark);
 		
 		Person yomomma = new Person();
 		yomomma.setName("mum");
 		yomomma.setSex('F');
 		
 		s.save(yomomma);
 		s.save(mark);
 		s.save(joe);
 		
 		assertEquals( s.createQuery("from java.io.Serializable").list().size(), 0 );
 		
 		assertEquals( s.createQuery("from Person").list().size(), 3 );
 		assertEquals( s.createQuery("from Person p where p.class = Customer").list().size(), 1 );
 		assertEquals( s.createQuery("from Person p where p.class = Person").list().size(), 1 );
 		assertEquals( s.createQuery("from Person p where type(p) in :who").setParameter("who", Customer.class).list().size(), 1 );
 		assertEquals( s.createQuery("from Person p where type(p) in :who").setParameterList("who", new Class[] {Customer.class, Person.class}).list().size(), 2 );
 		s.clear();
 
 		List customers = s.createQuery("from Customer c left join fetch c.salesperson").list();
 		for ( Object customer : customers ) {
 			Customer c = (Customer) customer;
 			assertTrue( Hibernate.isInitialized( c.getSalesperson() ) );
 			assertEquals( c.getSalesperson().getName(), "Mark" );
 		}
 		assertEquals( customers.size(), 1 );
 		s.clear();
 		
 		customers = s.createQuery("from Customer").list();
 		for ( Object customer : customers ) {
 			Customer c = (Customer) customer;
 			assertFalse( Hibernate.isInitialized( c.getSalesperson() ) );
 			assertEquals( c.getSalesperson().getName(), "Mark" );
 		}
 		assertEquals( customers.size(), 1 );
 		s.clear();
 		
 
 		mark = (Employee) s.get( Employee.class, Long.valueOf( mark.getId() ) );
 		joe = (Customer) s.get( Customer.class, Long.valueOf( joe.getId() ) );
 		
  		mark.setZip("30306");
 		assertEquals( s.createQuery("from Person p where p.address.zip = '30306'").list().size(), 1 );
 
         s.createCriteria( Person.class ).add(
                 Restrictions.in( "address", new Address[] { mark.getAddress(),
                         joe.getAddress() } ) ).list();
 		
 		s.delete(mark);
 		s.delete(joe);
 		s.delete(yomomma);
 		assertTrue( s.createQuery("from Person").list().isEmpty() );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testQuerySubclassAttribute() {
 		if ( getDialect() instanceof HSQLDialect ) {
 			return; // TODO : why??
 		}
 		
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		Person p = new Person();
 		p.setName("Emmanuel");
 		p.setSex('M');
 		s.persist(p);
 		Employee q = new Employee();
 		q.setName("Steve");
 		q.setSex('M');
 		q.setTitle("Mr");
 		q.setSalary( new BigDecimal(1000) );
 		s.persist(q);
 
 		List result = s.createQuery("from Person where salary > 100").list();
 		assertEquals( result.size(), 1 );
 		assertSame( result.get(0), q );
 		
 		result = s.createQuery("from Person where salary > 100 or name like 'E%'").list();
 		assertEquals( result.size(), 2 );		
 
 		result = s.createCriteria(Person.class)
 			.add( Property.forName("salary").gt( new BigDecimal(100) ) )
 			.list();
 		assertEquals( result.size(), 1 );
 		assertSame( result.get(0), q );
 
 		result = s.createQuery("select salary from Person where salary > 100").list();
 		assertEquals( result.size(), 1 );
 		assertEquals( ( (BigDecimal) result.get(0) ).intValue(), 1000 );
 		
 		s.delete(p);
 		s.delete(q);
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCustomColumnReadAndWrite() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		final double HEIGHT_INCHES = 73;
 		final double HEIGHT_CENTIMETERS = HEIGHT_INCHES * 2.54d;
 		Person p = new Person();
 		p.setName("Emmanuel");
 		p.setSex('M');
 		p.setHeightInches(HEIGHT_INCHES);
 		s.persist(p);
 		final double PASSWORD_EXPIRY_WEEKS = 4;
 		final double PASSWORD_EXPIRY_DAYS = PASSWORD_EXPIRY_WEEKS * 7d;
 		Employee e = new Employee();
 		e.setName("Steve");
 		e.setSex('M');
 		e.setTitle("Mr");		
 		e.setPasswordExpiryDays(PASSWORD_EXPIRY_DAYS);
 		s.persist(e);
 		s.flush();
 		
 		// Test value conversion during insert
 		// Value returned by Oracle native query is a Types.NUMERIC, which is mapped to a BigDecimalType;
 		// Cast returned value to Number then call Number.doubleValue() so it works on all dialects.
 		Double heightViaSql =
 				( (Number)s.createSQLQuery("select height_centimeters from UPerson where name='Emmanuel'").uniqueResult() ).doubleValue();
 		assertEquals(HEIGHT_CENTIMETERS, heightViaSql, 0.01d);
 		Double expiryViaSql =
 				( (Number)s.createSQLQuery("select pwd_expiry_weeks from UEmployee where person_id=?")
 						.setLong(0, e.getId())
 						.uniqueResult()
 				).doubleValue();
 		assertEquals(PASSWORD_EXPIRY_WEEKS, expiryViaSql, 0.01d);
 		
 		// Test projection
 		Double heightViaHql = (Double)s.createQuery("select p.heightInches from Person p where p.name = 'Emmanuel'").uniqueResult();
 		assertEquals(HEIGHT_INCHES, heightViaHql, 0.01d);
 		Double expiryViaHql = (Double)s.createQuery("select e.passwordExpiryDays from Employee e where e.name = 'Steve'").uniqueResult();
 		assertEquals(PASSWORD_EXPIRY_DAYS, expiryViaHql, 0.01d);
 		
 		// Test restriction and entity load via criteria
 		p = (Person)s.createCriteria(Person.class)
 			.add(Restrictions.between("heightInches", HEIGHT_INCHES - 0.01d, HEIGHT_INCHES + 0.01d))
 			.uniqueResult();
 		assertEquals(HEIGHT_INCHES, p.getHeightInches(), 0.01d);
 		e = (Employee)s.createCriteria(Employee.class)
 			.add(Restrictions.between("passwordExpiryDays", PASSWORD_EXPIRY_DAYS - 0.01d, PASSWORD_EXPIRY_DAYS + 0.01d))
 			.uniqueResult();
 		assertEquals(PASSWORD_EXPIRY_DAYS, e.getPasswordExpiryDays(), 0.01d);
 		
 		// Test predicate and entity load via HQL
 		p = (Person)s.createQuery("from Person p where p.heightInches between ? and ?")
 			.setDouble(0, HEIGHT_INCHES - 0.01d)
 			.setDouble(1, HEIGHT_INCHES + 0.01d)
 			.uniqueResult();
 		assertEquals(HEIGHT_INCHES, p.getHeightInches(), 0.01d);
 		e = (Employee)s.createQuery("from Employee e where e.passwordExpiryDays between ? and ?")
 			.setDouble(0, PASSWORD_EXPIRY_DAYS - 0.01d)
 			.setDouble(1, PASSWORD_EXPIRY_DAYS + 0.01d)
 			.uniqueResult();
 		assertEquals(PASSWORD_EXPIRY_DAYS, e.getPasswordExpiryDays(), 0.01d);
 		
 		// Test update
 		p.setHeightInches(1);
 		e.setPasswordExpiryDays(7);
 		s.flush();
 		heightViaSql =
 				( (Number)s.createSQLQuery("select height_centimeters from UPerson where name='Emmanuel'").uniqueResult() )
 						.doubleValue();
 		assertEquals(2.54d, heightViaSql, 0.01d);
 		expiryViaSql =
 				( (Number)s.createSQLQuery("select pwd_expiry_weeks from UEmployee where person_id=?")
 						.setLong(0, e.getId())
 						.uniqueResult()
 				).doubleValue();
 		assertEquals(1d, expiryViaSql, 0.01d);
 		s.delete(p);
 		s.delete(e);
 		t.commit();
 		s.close();
 		
 	}
 	
 	
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/version/db/DbVersionTest.java b/hibernate-core/src/test/java/org/hibernate/test/version/db/DbVersionTest.java
index 428bac6989..98f320ac35 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/version/db/DbVersionTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/version/db/DbVersionTest.java
@@ -1,134 +1,134 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.version.db;
 
 import java.sql.Timestamp;
 
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.hibernate.type.StandardBasicTypes;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Steve Ebersole
  */
 public class DbVersionTest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "version/db/User.hbm.xml" };
 	}
 
 	@Test
 	public void testCollectionVersion() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		User steve = new User( "steve" );
 		s.persist( steve );
 		Group admin = new Group( "admin" );
 		s.persist( admin );
 		t.commit();
 		s.close();
 
 		Timestamp steveTimestamp = steve.getTimestamp();
 
 		// For dialects (Oracle8 for example) which do not return "true
 		// timestamps" sleep for a bit to allow the db date-time increment...
 		Thread.sleep( 1500 );
 
 		s = openSession();
 		t = s.beginTransaction();
 		steve = ( User ) s.get( User.class, steve.getId() );
 		admin = ( Group ) s.get( Group.class, admin.getId() );
 		steve.getGroups().add( admin );
 		admin.getUsers().add( steve );
 		t.commit();
 		s.close();
 
 		assertFalse( "owner version not incremented", StandardBasicTypes.TIMESTAMP.isEqual( steveTimestamp, steve.getTimestamp() ) );
 
 		steveTimestamp = steve.getTimestamp();
 		Thread.sleep( 1500 );
 
 		s = openSession();
 		t = s.beginTransaction();
 		steve = ( User ) s.get( User.class, steve.getId() );
 		steve.getGroups().clear();
 		t.commit();
 		s.close();
 
 		assertFalse( "owner version not incremented", StandardBasicTypes.TIMESTAMP.isEqual( steveTimestamp, steve.getTimestamp() ) );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete( s.load( User.class, steve.getId() ) );
 		s.delete( s.load( Group.class, admin.getId() ) );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCollectionNoVersion() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		User steve = new User( "steve" );
 		s.persist( steve );
 		Permission perm = new Permission( "silly", "user", "rw" );
 		s.persist( perm );
 		t.commit();
 		s.close();
 
 		Timestamp steveTimestamp = steve.getTimestamp();
 
 		s = openSession();
 		t = s.beginTransaction();
 		steve = ( User ) s.get( User.class, steve.getId() );
 		perm = ( Permission ) s.get( Permission.class, perm.getId() );
 		steve.getPermissions().add( perm );
 		t.commit();
 		s.close();
 
 		assertTrue( "owner version was incremented", StandardBasicTypes.TIMESTAMP.isEqual( steveTimestamp, steve.getTimestamp() ) );
 
 		s = openSession();
 		t = s.beginTransaction();
 		steve = ( User ) s.get( User.class, steve.getId() );
 		steve.getPermissions().clear();
 		t.commit();
 		s.close();
 
 		assertTrue( "owner version was incremented", StandardBasicTypes.TIMESTAMP.isEqual( steveTimestamp, steve.getTimestamp() ) );
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete( s.load( User.class, steve.getId() ) );
 		s.delete( s.load( Permission.class, perm.getId() ) );
 		t.commit();
 		s.close();
 	}
-}
\ No newline at end of file
+}
diff --git a/hibernate-core/src/test/java/org/hibernate/test/version/sybase/SybaseTimestampVersioningTest.java b/hibernate-core/src/test/java/org/hibernate/test/version/sybase/SybaseTimestampVersioningTest.java
index a580396e7e..b3696ba122 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/version/sybase/SybaseTimestampVersioningTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/version/sybase/SybaseTimestampVersioningTest.java
@@ -1,236 +1,236 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.version.sybase;
 
 import org.junit.Test;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.dialect.SybaseASE15Dialect;
 import org.hibernate.testing.RequiresDialect;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 import org.hibernate.type.BinaryType;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * Implementation of VersionTest.
  *
  * @author Steve Ebersole
  */
 @RequiresDialect( SybaseASE15Dialect.class )
 public class SybaseTimestampVersioningTest extends BaseCoreFunctionalTestCase {
 	public String[] getMappings() {
 		return new String[] { "version/sybase/User.hbm.xml" };
 	}
 
 	@Test
 	public void testLocking() throws Throwable {
 		// First, create the needed row...
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		User steve = new User( "steve" );
 		s.persist( steve );
 		t.commit();
 		s.close();
 
 		// next open two sessions, and try to update from each "simultaneously"...
 		Session s1 = null;
 		Session s2 = null;
 		Transaction t1 = null;
 		Transaction t2 = null;
 		try {
 			s1 = sessionFactory().openSession();
 			t1 = s1.beginTransaction();
 			s2 = sessionFactory().openSession();
 			t2 = s2.beginTransaction();
 
 			User user1 = ( User ) s1.get( User.class, steve.getId() );
 			User user2 = ( User ) s2.get( User.class, steve.getId() );
 
 			user1.setUsername( "se" );
 			t1.commit();
 			t1 = null;
 
 			user2.setUsername( "steve-e" );
 			try {
 				t2.commit();
 				fail( "optimistic lock check did not fail" );
 			}
 			catch( HibernateException e ) {
 				// expected...
 				try {
 					t2.rollback();
 				}
 				catch( Throwable ignore ) {
 				}
 			}
 		}
 		catch( Throwable error ) {
 			if ( t1 != null ) {
 				try {
 					t1.rollback();
 				}
 				catch( Throwable ignore ) {
 				}
 			}
 			if ( t2 != null ) {
 				try {
 					t2.rollback();
 				}
 				catch( Throwable ignore ) {
 				}
 			}
 			throw error;
 		}
 		finally {
 			if ( s1 != null ) {
 				try {
 					s1.close();
 				}
 				catch( Throwable ignore ) {
 				}
 			}
 			if ( s2 != null ) {
 				try {
 					s2.close();
 				}
 				catch( Throwable ignore ) {
 				}
 			}
 		}
 
 		// lastly, clean up...
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete( s.load( User.class, steve.getId() ) );
 		t.commit();
 		s.close();
 	}
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testCollectionVersion() throws Exception {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		User steve = new User( "steve" );
 		s.persist( steve );
 		Group admin = new Group( "admin" );
 		s.persist( admin );
 		t.commit();
 		s.close();
 
 		byte[] steveTimestamp = steve.getTimestamp();
 
 		s = openSession();
 		t = s.beginTransaction();
 		steve = ( User ) s.get( User.class, steve.getId() );
 		admin = ( Group ) s.get( Group.class, admin.getId() );
 		steve.getGroups().add( admin );
 		admin.getUsers().add( steve );
 		t.commit();
 		s.close();
 
 		assertFalse(
 				"owner version not incremented", BinaryType.INSTANCE.isEqual(
 				steveTimestamp, steve.getTimestamp()
 		)
 		);
 
 		steveTimestamp = steve.getTimestamp();
 
 		s = openSession();
 		t = s.beginTransaction();
 		steve = ( User ) s.get( User.class, steve.getId() );
 		steve.getGroups().clear();
 		t.commit();
 		s.close();
 
 		assertFalse(
 				"owner version not incremented", BinaryType.INSTANCE.isEqual(
 				steveTimestamp, steve.getTimestamp()
 		)
 		);
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete( s.load( User.class, steve.getId() ) );
 		s.delete( s.load( Group.class, admin.getId() ) );
 		t.commit();
 		s.close();
 	}
 
 
 	@Test
 	@SuppressWarnings( {"unchecked"})
 	public void testCollectionNoVersion() {
 		Session s = openSession();
 		Transaction t = s.beginTransaction();
 		User steve = new User( "steve" );
 		s.persist( steve );
 		Permission perm = new Permission( "silly", "user", "rw" );
 		s.persist( perm );
 		t.commit();
 		s.close();
 
 		byte[] steveTimestamp = steve.getTimestamp();
 
 		s = openSession();
 		t = s.beginTransaction();
 		steve = ( User ) s.get( User.class, steve.getId() );
 		perm = ( Permission ) s.get( Permission.class, perm.getId() );
 		steve.getPermissions().add( perm );
 		t.commit();
 		s.close();
 
 		assertTrue(
 				"owner version was incremented", BinaryType.INSTANCE.isEqual(
 				steveTimestamp, steve.getTimestamp()
 		)
 		);
 
 		s = openSession();
 		t = s.beginTransaction();
 		steve = ( User ) s.get( User.class, steve.getId() );
 		steve.getPermissions().clear();
 		t.commit();
 		s.close();
 
 		assertTrue(
 				"owner version was incremented", BinaryType.INSTANCE.isEqual(
 				steveTimestamp, steve.getTimestamp()
 		)
 		);
 
 		s = openSession();
 		t = s.beginTransaction();
 		s.delete( s.load( User.class, steve.getId() ) );
 		s.delete( s.load( Permission.class, perm.getId() ) );
 		t.commit();
 		s.close();
 	}
-}
\ No newline at end of file
+}
