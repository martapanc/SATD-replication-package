diff --git a/CONTRIBUTORS b/CONTRIBUTORS
index 172058b3b..1b1d8698f 100644
--- a/CONTRIBUTORS
+++ b/CONTRIBUTORS
@@ -1,393 +1,394 @@
 Amongst other, the following people contributed to ant:
 
 Adam Blinkinsop
 Adam Bryzak
 Adam Sotona
 Aleksandr Ishutin
 Alex Rosen
 Alexei Yudichev
 Alexey Panchenko
 Alexey Solofnenko
 Alfred Theorin
 Alison Winters
 Andreas Ames
 Andreas Mross
 Andrew Eisenberg
 Andrew Everitt
 Andrew Stevens
 Andrey Urazov
+André-John Mas
 Andy Wood
 Anil K. Vijendran
 Anli Shundi
 Anthony Goubard
 Anthony Green
 Anthony Wat
 Antoine Baudoux
 Antoine Levy-Lambert
 Anton Mazkovoi
 Arjan Veenstra
 Arnaud Vandyck
 Arnout J. Kuiper
 Aslak Hellesôy
 Atsuhiko Yamanaka
 Avik Sengupta
 Balazs Fejes 2
 Bart Vanhaute
 Benjamin Burgess
 Ben Galbraith
 Benoit Moussaud
 Bernd Dutkowski
 Bernhard Rosenkraenzer
 Brad Clark
 Brant Langer Gurganus
 Brian Curnow
 Brian Deitte
 Brian Felder
 Brian Repko
 Bruce Atherton
 Cedomir Igaly
 Charles Hudak
 Charlie Hubbard
 Chris Povirk
 Christian Knorr
 Christoph Gysin
 Christoph Wilhelms
 Christophe Labouisse
 Christopher A. Longo
 Christopher Charlier
 Clark Archer
 Clemens Hammacher
 Clement OUDOT
 Clive Brettingham-Moore
 Conor MacNeill
 Craeg Strong
 Craig Cottingham
 Craig R. McClanahan
 Craig Richardson
 Craig Ryan
 Craig Sandvik
 Curt Arnold
 Curtis White
 Cyrille Morvan
 D'Arcy Smith
 Dale Anson
 Dale Sherwood
 Dan Armbrust
 Daniel Henrique
 Daniel Ribagnac
 Daniel Spilker
 Daniel Trebbien
 Danno Ferrin
 Danny Yates
 Dante Briones
 Davanum Srinivas
 Dave Brondsema
 Dave Brosius
 David A. Herman
 David Crossley
 David Gärtner
 David S. Johnson
 David Kavanagh
 David LeRoy
 David Leal
 David M. Lloyd
 David Maclean
 David Rees
 Denis Hennessy
 Derek Slager
 Devon C. Miller
 Diane Holt
 dIon Gillard
 Dmitry A. Kuminov
 Dominique Devienne
 Donal Quinlan
 Don Brown
 Don Ferguson
 Don Jeffery
 Drew Sudell
 Eduard Wirch
 Edwin Woudt
 Eli Tucker
 Emmanuel Bourg
 Eric Barboni
 Eric Olsen
 Eric Pugh
 Erik Costlow
 Erik Hatcher
 Erik Langenbach
 Erik Meade
 Ernst de Haan
 Frank Harnack
 Frank Somers
 Frank Zeyda
 Frederic Bothamy
 Frederic Lavigne
 Gary S. Weaver
 Gautam Guliani
 Gene-Sung Chung
 Georges-Etienne Legendre
 Gero Vermaas
 Gerrit Riessen
 Gilbert Rebhan
 Gilles Scokart
 Glenn McAllister
 Glenn Twiggs
 Greg Nelson
 Greg Roodt
 Greg Schueler
 Günther Kögel
 Harish Prabandham
 Haroon Rafique
 Hiroaki Nakamura
 Holger Engels
 Holger Joest
 Ignacio Coloma
 Ingenonsya France
 Ingmar Stein
 Irene Rusman
 Isaac Shabtay
 Ivan Ivanov
 J Bleijenbergh
 Jack J. Woehr
 James Duncan Davidson
 Jan Cumps
 Jan Matèrne
 Jan Mynarik
 Jan Stolze
 Jason Hunter
 Jason Pettiss
 Jason Salter
 Jason Yip
 Jay Dickon Glanville
 Jay Peck
 Jay van der Meer
 JC Mann
 J D Glanville
 Jean-Francois Brousseau
 Jean-Louis Boudart
 Jeff Gettle
 Jeff Martin
 Jeff Tulley
 Jeff Turner
 Jene Jasper
 Jeremy Mawson
 Jerome Lacoste
 Jesse Glick
 Jesse Stockall
 Jim Allers
 Joerg Wassmer
 Joey Richey
 Johann Herunter
 John Sisson
 Jon Dickinson
 Jon S. Stevens
 Jon Skeet
 Jose Alberto Fernandez
 Joseph Walton
 Josh Lucas
 Juerg Wanner
 Julian Simpson
 Justin Vallon
 Keiron Liddle
 Keith Visco
 Kevin Connor Arpe
 Kevin Greiner
 Kevin Jackson
 Kevin Ross
 Kevin Z Grey
 Kim Hansen
 Kirk Wylie
 Kyle Adams
 Larry Shatzer
 Larry Streepy
 Les Hughes
 Levi Cook
 lucas
 Ludovic Claude
 Maarten Coene
 Magesh Umasankar
 Maneesh Sahu
 Marcel Schutte
 Marcus B&ouml;rger
 Mario Frasca 
 Mariusz Nowostawski
 Mark A. Ziesemer
 Mark DeLaFranier
 Mark Hecker
 Mark R. Diggory
 Mark Salter
 Markus Kahl
 Martijn Kruithof
 Martin Landers
 Martin Poeschl
 Martin van den Bemt
 Martin von Gagern
 Mathieu Champlon
 Mathieu Peltier
 Matt Albrecht
 Matt Benson
 Matt Bishop
 Matt Foemmel
 Matt Grosso
 Matt Humphrey
 Matt Small
 Matt Wildig
 Matthew Hawthorne
 Matthew Inger
 Matthew Kuperus Heun
 Matthew Watson
 Michael Bayne
 Michael Clarke
 Michael Davey
 Michael J. Sikorsky
 Michael McCallum
 Michael Montuori
 Michael Newcomb
 Micheal Nygard
 Michael Saunders
 Miha
 Mike Davis
 Mike Roberts
 mnowostawski
 Mounir El Hajj
 Nathan Beyer
 Nick Chalko
 Nick Fortescue
 Nick Crossley
 Nick Pellow
 Nicola Ken Barozzi
 Nico Seessle
 Nigel Magnay
 Oliver Merkel
 Oliver Rossmueller
 Ondra Medek
 Omer Shapira
 Oystein Gisnas
 Patrick Altaie
 Patrick C. Beard
 Patrick Chanezon
 Patrick G. Heck (Gus Heck)
 Patrick Martin
 Paul Austin
 Paul Christmann
 Paul Galbraith
 Paul King
 Paulo Gaspar
 Pavan Bayyapu
 Pavel Jisl
 Pawel Zuzelski
 Peter B. West
 Peter Donald
 Peter Doornbosch
 Peter Hulst
 Peter Janes
 Peter Reilly
 Phil Hanna
 Philip Hourihane
 Phillip Wells
 Pierre Delisle
 Pierre Dittgen
 riasol
 R Handerson
 Rami Ojares
 Randy Watler
 Raphael Pierquin
 Ray Waldin
 Remie Bolte
 Richard Evans
 Richard Steele
 Rick Beton
 Robert Anderson
 Robert Clark
 Robert Flaherty
 Robert Shaw
 Robert Streich
 Robert Watkins
 Roberto Scaramuzzi
 Robin Green
 Robin Power
 Robin Verduijn
 Rob Oxspring
 Rob van Oostrum
 Rodrigo Schmidt
 Roger Vaughn
 Roman Ivashin
 Ronen Mashal
 Russell Gold
 Sam Ruby
 Sandra Metz
 Scott Carlson
 Scott Ellsworth
 Scott Johnson
 Scott M. Stirling
 Sean Egan
 Sean P. Kane
 Sebastien Arod
 Shiraz Kanga
 Sebastian Kantha
 Simon Law
 Simone Bordet
 Stefan Bodewig
 Stefan Heimann
 Stefano Mazzocchi
 Stephan Strittmatter
 Stephane Bailliez
 stephan
 Stephan Michels
 Stephen Chin
 Stephen Goetze
 Steve Cohen
 Steve Langley
 Steve Loughran
 Steve Morin
 Steve Wadsworth
 Steven E. Newton
 Sudheer Chigurupati
 Takashi Okamoto
 TAMURA Kent
 Taoufik Romdhane
 Tariq Master
 Thomas Aglassinger
 Thomas Butz
 Thomas Christen
 Thomas Christensen
 Thomas Haas
 Thomas Quas
 Tim Drury
 Tim Fennell
 Tim Stephenson
 Timoteo Ohara
 Timothy Gerard Endres
 Tom Ball
 Tom Brus
 Tom Cunningham
 Tom Dimock
 Tom Eugelink
 Tom May
 Tomasz Bech
 Trejkaz Xaoza
 Ulrich Schmidt
 Uwe Schindler
 Valentino Miazzo
 Victor Toni
 Vimil Saju
 Vincent Legoll
 Volker Leidl
 Waldek Herka
 Wang Weijun
 Will Wang
 William Bernardet
 William Ferguson
 William Webber
 Wolf Siberski
 Wolfgang Baer
 Wolfgang Frech
 Wolfgang Glas
 Wolfgang Werner
 Xavier Hanin
 Xavier Witdouck
 Yohann Roussel
 Yuji Yamano
 Yves Martin
 Zach Garner
 Zdenek Wagner
diff --git a/contributors.xml b/contributors.xml
index 9b663e7b6..88cd45221 100644
--- a/contributors.xml
+++ b/contributors.xml
@@ -1,1093 +1,1097 @@
 <?xml version="1.0" encoding="utf-8"?>
 <!--
    Licensed to the Apache Software Foundation (ASF) under one or more
    contributor license agreements.  See the NOTICE file distributed with
    this work for additional information regarding copyright ownership.
    The ASF licenses this file to You under the Apache License, Version 2.0
    (the "License"); you may not use this file except in compliance with
    the License.  You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
 -->
 <!DOCTYPE contributors
 [
 <!ELEMENT name (first?, middle?, last)>
 <!ELEMENT contributors (introduction, name+)>
 <!ELEMENT first (#PCDATA)>
 <!ELEMENT introduction (#PCDATA)>
 <!ELEMENT middle (#PCDATA)>
 <!ELEMENT last (#PCDATA)>
 ]
 >
 
 <contributors>
   <introduction>
   These are some of the many people who have helped Ant become so successful.
   </introduction>
   <name>
     <first>Adam</first>
     <last>Blinkinsop</last>
   </name>
   <name>
     <first>Adam</first>
     <last>Bryzak</last>
   </name>
   <name>
     <first>Adam</first>
     <last>Sotona</last>
   </name>
   <name>
     <first>Aleksandr</first>
     <last>Ishutin</last>
   </name>
   <name>
     <first>Alex</first>
     <last>Rosen</last>
   </name>
   <name>
     <first>Alexei</first>
     <last>Yudichev</last>
   </name>
   <name>
     <first>Alexey</first>
     <last>Panchenko</last>
   </name>
   <name>
     <first>Alexey</first>
     <last>Solofnenko</last>
   </name>
   <name>
     <first>Alfred</first>
     <last>Theorin</last>
   </name>
   <name>
     <first>Alison</first>
     <last>Winters</last>
   </name>
   <name>
     <first>Andreas</first>
     <last>Ames</last>
   </name>
   <name>
     <first>Andrew</first>
     <last>Eisenberg</last>
   </name>
   <name>
     <first>Andrew</first>
     <last>Everitt</last>
   </name>
   <name>
     <first>Andrew</first>
     <last>Stevens</last>
   </name>
   <name>
     <first>Andrey</first>
     <last>Urazov</last>
   </name>
   <name>
+    <first>André-John</first>
+    <last>Mas</last>
+  </name>
+  <name>
     <first>Andy</first>
     <last>Wood</last>
   </name>
   <name>
     <first>Anil</first>
     <middle>K.</middle>
     <last>Vijendran</last>
   </name>
   <name>
     <first>Anli</first>
     <last>Shundi</last>
   </name>
   <name>
     <first>Anthony</first>
     <last>Green</last>
   </name>
   <name>
     <first>Anthony</first>
     <last>Wat</last>
   </name>
   <name>
     <first>Antoine</first>
     <last>Baudoux</last>
   </name>
   <name>
     <first>Antoine</first>
     <last>Levy-Lambert</last>
   </name>
   <name>
     <first>Anton</first>
     <last>Mazkovoi</last>
   </name>
   <name>
     <first>Arjan</first>
     <last>Veenstra</last>
   </name>
   <name>
     <first>Arnaud</first>
     <last>Vandyck</last>
   </name>
   <name>
     <first>Arnout</first>
     <middle>J.</middle>
     <last>Kuiper</last>
   </name>
   <name>
     <first>Aslak</first>
     <last>Helles&#244;y</last>
   </name>
   <name>
     <first>Atsuhiko</first>
     <last>Yamanaka</last>
   </name>
   <name>
     <first>Avik</first>
     <last>Sengupta</last>
   </name>
   <name>
     <first>Balazs</first>
     <last>Fejes 2</last>
   </name>
   <name>
     <first>Bart</first>
     <last>Vanhaute</last>
   </name>
   <name>
     <first>Benjamin</first>
     <last>Burgess</last>
   </name>
   <name>
     <first>Ben</first>
     <last>Galbraith</last>
   </name>
   <name>
     <first>Benoit</first>
     <last>Moussaud</last>
   </name>
   <name>
     <first>Bernd</first>
     <last>Dutkowski</last>
   </name>
   <name>
     <first>Bernhard</first>
     <last>Rosenkraenzer</last>
   </name>
   <name>
     <first>Brad</first>
     <last>Clark</last>
   </name>
   <name>
     <first>Brant</first>
     <middle>Langer</middle>
     <last>Gurganus</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Curnow</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Deitte</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Felder</last>
   </name>
   <name>
     <first>Brian</first>
     <last>Repko</last>
   </name>
   <name>
     <first>Bruce</first>
     <last>Atherton</last>
   </name>
   <name>
     <first>Charles</first>
     <last>Hudak</last>
   </name>
   <name>
     <first>Charlie</first>
     <last>Hubbard</last>
   </name>
   <name>
     <first>Chris</first>
     <last>Povirk</last>
   </name>
   <name>
     <first>Christian</first>
     <last>Knorr</last>
   </name>
   <name>
     <first>Christoph</first>
     <last>Gysin</last>
   </name>
   <name>
     <first>Christoph</first>
     <last>Wilhelms</last>
   </name>
   <name>
     <first>Christophe</first>
     <last>Labouisse</last>
   </name>
   <name>
     <first>Christopher</first>
     <middle>A.</middle>
     <last>Longo</last>
   </name>
   <name>
     <first>Christopher</first>
     <last>Charlier</last>
   </name>
   <name>
     <first>Clark</first>
     <last>Archer</last>
   </name>
   <name>
     <first>Clemens</first>
     <last>Hammacher</last>
   </name>
   <name>
     <first>Clement</first>
     <last>OUDOT</last>
   </name>
   <name>
     <first>Clive</first>
     <last>Brettingham-Moore</last>
   </name>
   <name>
     <first>Conor</first>
     <last>MacNeill</last>
   </name>
   <name>
     <first>Craeg</first>
     <last>Strong</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Cottingham</last>
   </name>
   <name>
     <first>Craig</first>
     <middle>R.</middle>
     <last>McClanahan</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Ryan</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Richardson</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Sandvik</last>
   </name>
   <name>
     <first>Curt</first>
     <last>Arnold</last>
   </name>
   <name>
     <first>Curtis</first>
     <last>White</last>
   </name>
   <name>
     <first>Cyrille</first>
     <last>Morvan</last>
   </name>
   <name>
     <first>D'Arcy</first>
     <last>Smith</last>
   </name>
   <name>
     <first>Dale</first>
     <last>Anson</last>
   </name>
   <name>
     <first>Dale</first>
     <last>Sherwood</last>
   </name>
   <name>
     <first>Dan</first>
     <last>Armbrust</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Henrique</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Ribagnac</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Spilker</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Trebbien</last>
   </name>
   <name>
     <first>Danno</first>
     <last>Ferrin</last>
   </name>
   <name>
     <first>Danny</first>
     <last>Yates</last>
   </name>
   <name>
     <first>Dante</first>
     <last>Briones</last>
   </name>
   <name>
     <first>Davanum</first>
     <last>Srinivas</last>
   </name>
   <name>
     <first>Dave</first>
     <last>Brondsema</last>
   </name>
   <name>
     <first>Dave</first>
     <last>Brosius</last>
   </name>
   <name>
     <first>David</first>
     <last>A.</last>
   </name>
   <name>
     <first>David</first>
     <last>Crossley</last>
   </name>
   <name>
     <first>David</first>
     <last>G&#228;rtner</last>
   </name>
   <name>
     <first>David</first>
     <middle>S.</middle>
     <last>Johnson</last>
   </name>
   <name>
     <first>David</first>
     <last>Kavanagh</last>
   </name>
   <name>
     <first>David</first>
     <last>LeRoy</last>
   </name>
   <name>
     <first>David</first>
     <last>Leal</last>
   </name>
   <name>
     <first>David</first>
     <middle>M.</middle>
     <last>Lloyd</last>
   </name>
   <name>
     <first>David</first>
     <last>Maclean</last>
   </name>
   <name>
     <first>David</first>
     <last>Rees</last>
   </name>
   <name>
     <first>Denis</first>
     <last>Hennessy</last>
   </name>
   <name>
     <first>Derek</first>
     <last>Slager</last>
   </name>
   <name>
     <first>Devon</first>
     <middle>C.</middle>
     <last>Miller</last>
   </name>
   <name>
     <first>Diane</first>
     <last>Holt</last>
   </name>
   <name>
     <first>dIon</first>
     <last>Gillard</last>
   </name>
   <name>
     <first>Dmitry</first>
     <middle>A.</middle>
     <last>Kuminov</last>
   </name>
   <name>
     <first>Dominique</first>
     <last>Devienne</last>
   </name>
   <name>
     <first>Donal</first>
     <last>Quinlan</last>
   </name>
   <name>
     <first>Don</first>
     <last>Bnamen</last>
   </name>
   <name>
     <first>Don</first>
     <last>Ferguson</last>
   </name>
   <name>
     <first>Don</first>
     <last>Jeffery</last>
   </name>
   <name>
     <first>Drew</first>
     <last>Sudell</last>
   </name>
   <name>
     <first>Eduard</first>
     <last>Wirch</last>
   </name>
   <name>
     <first>Edwin</first>
     <last>Woudt</last>
   </name>
   <name>
     <first>Eli</first>
     <last>Tucker</last>
   </name>
   <name>
     <first>Emmanuel</first>
     <last>Bourg</last>
   </name>
   <name>
     <first>Eric</first>
     <last>Olsen</last>
   </name>
   <name>
     <first>Eric</first>
     <last>Pugh</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Costlow</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Hatcher</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Langenbach</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Meade</last>
   </name>
   <name>
     <first>Ernst</first>
     <last>de Haan</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Harnack</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Somers</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Zeyda</last>
   </name>
   <name>
     <first>Frédéric</first>
     <last>Bothamy</last>
   </name>
   <name>
     <first>Frederic</first>
     <last>Lavigne</last>
   </name>
   <name>
     <first>Gary</first>
     <middle>S.</middle>
     <last>Weaver</last>
   </name>
   <name>
     <first>Gautam</first>
     <last>Guliani</last>
   </name>
   <name>
     <first>Gene-Sung</first>
     <last>Chung</last>
   </name>
   <name>
     <first>Georges-Etienne</first>
     <last>Legendre</last>
   </name>
   <name>
     <first>Gero</first>
     <last>Vermaas</last>
   </name>
   <name>
     <first>Gerrit</first>
     <last>Riessen</last>
   </name>
   <name>
     <first>Gilbert</first>
     <last>Rebhan</last>
   </name>
   <name>
     <first>Gilles</first>
     <last>Scokart</last>
   </name>
   <name>
     <first>Glenn</first>
     <last>McAllister</last>
   </name>
   <name>
     <first>Glenn</first>
     <last>Twiggs</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Nelson</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Roodt</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Schueler</last>
   </name>
   <name>
     <first>Günther</first>
     <last>Kögel</last>
   </name>
   <name>
     <first>Harish</first>
     <last>Prabandham</last>
   </name>
   <name>
     <first>Haroon</first>
     <last>Rafique</last>
   </name>
   <name>
     <first>Hiroaki</first>
     <last>Nakamura</last>
   </name>
   <name>
     <first>Holger</first>
     <last>Engels</last>
   </name>
   <name>
     <first>Holger</first>
     <last>Joest</last>
   </name>
   <name>
     <first>Ignacio</first>
     <last>Coloma</last>
   </name>
   <name>
     <first>Ingenonsya</first>
     <last>France</last>
   </name>
   <name>
     <first>Ingmar</first>
     <last>Stein</last>
   </name>
   <name>
     <first>Irene</first>
     <last>Rusman</last>
   </name>
   <name>
     <first>Isaac</first>
     <last>Shabtay</last>
   </name>
   <name>
     <first>Ivan</first>
     <last>Ivanov</last>
   </name>
   <name>
     <first>J</first>
     <last>Bleijenbergh</last>
   </name>
   <name>
     <first>Jack</first>
     <middle>J.</middle>
     <last>Woehr</last>
   </name>
   <name>
     <first>James</first>
     <middle>Duncan</middle>
     <last>Davidson</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Cumps</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Mat&#232;rne</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Mynarik</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Stolze</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Hunter</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Pettiss</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Salter</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Yip</last>
   </name>
   <name>
     <first>Jay</first>
     <middle>Dickon</middle>
     <last>Glanville</last>
   </name>
   <name>
     <first>Jay</first>
     <last>Peck</last>
   </name>
   <name>
     <first>Jay</first>
     <last>van der Meer</last>
   </name>
   <name>
     <first>JC</first>
     <last>Mann</last>
   </name>
   <name>
     <first>J</first>
     <last>D</last>
   </name>
   <name>
     <first>Jean-Francois</first>
     <last>Brousseau</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Gettle</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Martin</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Tulley</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Turner</last>
   </name>
   <name>
     <first>Jene</first>
     <last>Jasper</last>
   </name>
   <name>
     <first>Jeremy</first>
     <last>Mawson</last>
   </name>
   <name>
     <first>Jerome</first>
     <last>Lacoste</last>
   </name>
   <name>
     <first>Jesse</first>
     <last>Glick</last>
   </name>
   <name>
     <first>Jesse</first>
     <last>Stockall</last>
   </name>
   <name>
     <first>Jim</first>
     <last>Allers</last>
   </name>
   <name>
     <first>Joerg</first>
     <last>Wassmer</last>
   </name>
   <name>
     <first>Joey</first>
     <last>Richey</last>
   </name>
   <name>
     <first>Johann</first>
     <last>Herunter</last>
   </name>
   <name>
     <first>John</first>
     <last>Sisson</last>
   </name>
   <name>
     <first>Jon</first>
     <last>Dickinson</last>
   </name>
   <name>
     <first>Jon</first>
     <last>Skeet</last>
   </name>
   <name>
     <first>Jon</first>
     <middle>S.</middle>
     <last>Stevens</last>
   </name>
   <name>
     <first>Jose</first>
     <middle>Alberto</middle>
     <last>Fernandez</last>
   </name>
   <name>
     <first>Josh</first>
     <last>Lucas</last>
   </name>
   <name>
     <first>Joseph</first>
     <last>Walton</last>
   </name>
   <name>
     <first>Juerg</first>
     <last>Wanner</last>
   </name>
   <name>
     <first>Julian</first>
     <last>Simpson</last>
   </name>
   <name>
     <first>Justin</first>
     <last>Vallon</last>
   </name>
   <name>
     <first>Keiron</first>
     <last>Liddle</last>
   </name>
   <name>
     <first>Keith</first>
     <last>Visco</last>
   </name>
   <name>
     <first>Kevin</first>
     <middle>Connor</middle>
     <last>Arpe</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Greiner</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Jackson</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Ross</last>
   </name>
   <name>
     <first>Kevin</first>
     <middle>Z</middle>
     <last>Grey</last>
   </name>
   <name>
     <first>Kim</first>
     <last>Hansen</last>
   </name>
   <name>
     <first>Kirk</first>
     <last>Wylie</last>
   </name>
   <name>
     <first>Kyle</first>
     <last>Adams</last>
   </name>
   <name>
     <first>Larry</first>
     <last>Shatzer</last>
   </name>
   <name>
     <first>Larry</first>
     <last>Streepy</last>
   </name>
   <name>
     <first>Les</first>
     <last>Hughes</last>
   </name>
   <name>
     <first>Levi</first>
     <last>Cook</last>
   </name>
   <name>
     <last>lucas</last>
   </name>
   <name>
     <first>Ludovic</first>
     <last>Claude</last>
   </name>
   <name>
     <first>Magesh</first>
     <last>Umasankar</last>
   </name>
   <name>
     <first>Maneesh</first>
     <last>Sahu</last>
   </name>
   <name>
     <first>Marcel</first>
     <last>Schutte</last>
   </name>
   <name>
     <first>Marcus</first>
     <last>Börger</last>
   </name>
   <name>
     <first>Mario</first>
     <last>Frasca</last>
   </name>
   <name>
     <first>Mariusz</first>
     <last>Nowostawski</last>
   </name>
   <name>
     <first>Mark</first>
     <last>DeLaFranier</last>
   </name>
   <name>
     <first>Mark</first>
     <last>Hecker</last>
   </name>
   <name>
     <first>Mark</first>
     <last>Salter</last>
   </name>
   <name>
     <first>Mark</first>
     <middle>R.</middle>
     <last>Diggory</last>
   </name>
   <name>
     <first>Mark</first>
     <middle>A.</middle>
     <last>Ziesemer</last>
   </name>
   <name>
     <first>Markus</first>
     <last>Kahl</last>
   </name>
   <name>
     <first>Martijn</first>
     <last>Kruithof</last>
   </name>
   <name>
     <first>Martin</first>
     <last>Landers</last>
   </name>
   <name>
     <first>Martin</first>
     <last>Poeschl</last>
   </name>
   <name>
     <first>Martin</first>
     <last>van den Bemt</last>
   </name>
   <name>
     <first>Martin</first>
     <last>von Gagern</last>
   </name>
   <name>
     <first>Mathieu</first>
     <last>Champlon</last>
   </name>
   <name>
     <first>Mathieu</first>
     <last>Peltier</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Albrecht</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Benson</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Bishop</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Foemmel</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Grosso</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Humphrey</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Small</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Hawthorne</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Inger</last>
   </name>
   <name>
     <first>Matthew</first>
     <middle>Kuperus</middle>
     <last>Heun</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Watson</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Bayne</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Clarke</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Davey</last>
   </name>
   <name>
     <first>Michael</first>
     <middle>J.</middle>
     <last>Sikorsky</last>
   </name>
   <name>
     <first>Michael</first>
     <last>McCallum</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Newcomb</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Nygard</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Saunders</last>
   </name>
   <name>
     <last>Miha</last>
   </name>
   <name>
     <first>Mike</first>
     <last>Davis</last>
   </name>
   <name>
     <first>Mike</first>
     <last>Roberts</last>
   </name>
   <name>
     <last>mnowostawski</last>
   </name>
   <name>
     <first>Mounir</first>
     <last>El Hajj</last>
   </name>
   <name>
     <first>Nathan</first>
     <last>Beyer</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Chalko</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Crossley</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Fortescue</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Pellow</last>
   </name>
   <name>
     <first>Nicola</first>
     <last>Ken</last>
   </name>
   <name>
     <first>Nico</first>
     <last>Seessle</last>
   </name>
   <name>
     <first>Nigel</first>
     <last>Magnay</last>
   </name>
   <name>
     <first>Oliver</first>
     <last>Merkel</last>
   </name>
   <name>
     <first>Oliver</first>
     <last>Rossmueller</last>
   </name>
   <name>
     <first>Omer</first>
     <last>Shapira</last>
   </name>
   <name>
     <first>Ondra</first>
     <last>Medek</last>
   </name>
   <name>
     <first>&#216;ystein</first>
     <last>Gisn&#229;s</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Altaie</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>C.</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Chanezon</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Gus</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Austin</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Christmann</last>
diff --git a/src/main/org/apache/tools/ant/MagicNames.java b/src/main/org/apache/tools/ant/MagicNames.java
index 01668b11b..bc39a2578 100644
--- a/src/main/org/apache/tools/ant/MagicNames.java
+++ b/src/main/org/apache/tools/ant/MagicNames.java
@@ -1,286 +1,293 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant;
 
 import org.apache.tools.ant.launch.Launcher;
 
 /**
  * Magic names used within Ant.
  *
  * Not all magic names are here yet.
  *
  * @since Ant 1.6
  */
 public final class MagicNames {
 
     private MagicNames() {
     }
 
     /**
      * prefix for antlib URIs:
      * {@value}
      */
     public static final String ANTLIB_PREFIX = "antlib:";
 
     /**
      * Ant version property.
      * Value: {@value}
      */
     public static final String ANT_VERSION = "ant.version";
 
     /**
      * System classpath policy.
      * Value: {@value}
      */
     public static final String BUILD_SYSCLASSPATH = "build.sysclasspath";
 
     /**
      * The name of the script repository used by the script repo task.
      * Value {@value}
      */
     public static final String SCRIPT_REPOSITORY = "org.apache.ant.scriptrepo";
 
     /**
      * The name of the reference to the System Class Loader.
      * Value {@value}
      **/
     public static final String SYSTEM_LOADER_REF = "ant.coreLoader";
 
     /**
      * Name of the property which can provide an override of the repository dir.
      * for the libraries task
      * Value {@value}
      */
     public static final String REPOSITORY_DIR_PROPERTY = "ant.maven.repository.dir";
 
     /**
      * Name of the property which can provide an override of the repository URL.
      * for the libraries task
      * Value {@value}
      */
     public static final String REPOSITORY_URL_PROPERTY = "ant.maven.repository.url";
 
     /**
      * name of the resource that taskdefs are stored under.
      * Value: {@value}
      */
     public static final String TASKDEF_PROPERTIES_RESOURCE =
             "/org/apache/tools/ant/taskdefs/defaults.properties";
 
     /**
      * name of the resource that typedefs are stored under.
      * Value: {@value}
      */
     public static final String TYPEDEFS_PROPERTIES_RESOURCE =
             "/org/apache/tools/ant/types/defaults.properties";
 
     /**
      * Reference to the current Ant executor.
      * Value: {@value}
      */
     public static final String ANT_EXECUTOR_REFERENCE = "ant.executor";
 
     /**
      * Property defining the classname of an executor.
      * Value: {@value}
      */
     public static final String ANT_EXECUTOR_CLASSNAME = "ant.executor.class";
 
     /**
      * property name for basedir of the project.
      * Value: {@value}
      */
     public static final String PROJECT_BASEDIR = "basedir";
 
     /**
      * property for ant file name.
      * Value: {@value}
      */
     public static final String ANT_FILE = "ant.file";
 
     /**
      * property for type of ant build file (either file or url)
      * Value: {@value}
      * @since Ant 1.8.0
      */
     public static final String ANT_FILE_TYPE = "ant.file.type";
 
     /**
      * ant build file of type file
      * Value: {@value}
      * @since Ant 1.8.0
      */
     public static final String ANT_FILE_TYPE_FILE = "file";
 
     /**
      * ant build file of type url
      * Value: {@value}
      * @since Ant 1.8.0
      */
     public static final String ANT_FILE_TYPE_URL = "url";
 
     /**
      * Property used to store the java version ant is running in.
      * Value: {@value}
      * @since Ant 1.7
      */
     public static final String ANT_JAVA_VERSION = "ant.java.version";
 
     /**
      * Property used to store the location of ant.
      * Value: {@value}
      * @since Ant 1.7
      */
     public static final String ANT_HOME = Launcher.ANTHOME_PROPERTY;
 
     /**
      * Property used to store the location of the ant library (typically the ant.jar file.)
      * Value: {@value}
      * @since Ant 1.7
      */
     public static final String ANT_LIB = "ant.core.lib";
 
     /**
      * property for regular expression implementation.
      * Value: {@value}
      */
     public static final String REGEXP_IMPL = "ant.regexp.regexpimpl";
 
     /**
      * property that provides the default value for javac's and
      * javadoc's source attribute.
      * Value: {@value}
      * @since Ant 1.7
      */
     public static final String BUILD_JAVAC_SOURCE = "ant.build.javac.source";
 
     /**
      * property that provides the default value for javac's target attribute.
      * Value: {@value}
      * @since Ant 1.7
      */
     public static final String BUILD_JAVAC_TARGET = "ant.build.javac.target";
 
     /**
      * Name of the magic property that controls classloader reuse.
      * Value: {@value}
      * @since Ant 1.4.
      */
     public static final String REFID_CLASSPATH_REUSE_LOADER = "ant.reuse.loader";
 
     /**
      * Prefix used to store classloader references.
      * Value: {@value}
      */
     public static final String REFID_CLASSPATH_LOADER_PREFIX = "ant.loader.";
 
     /**
      * Reference used to store the property helper.
      * Value: {@value}
      */
     public static final String REFID_PROPERTY_HELPER = "ant.PropertyHelper";
 
     /**
      * Reference used to store the local properties.
      * Value: {@value}
      */
     public static final String REFID_LOCAL_PROPERTIES = "ant.LocalProperties";
 
     /**
      * Name of JVM system property which provides the name of the ProjectHelper class to use.
      * Value: {@value}
      */
     public static final String PROJECT_HELPER_CLASS = "org.apache.tools.ant.ProjectHelper";
 
     /**
      * The service identifier in jars which provide ProjectHelper implementations.
      * Value: {@value}
      */
     public static final String PROJECT_HELPER_SERVICE =
         "META-INF/services/org.apache.tools.ant.ProjectHelper";
 
     /**
      * Name of ProjectHelper reference that we add to a project.
      * Value: {@value}
      */
     public static final String REFID_PROJECT_HELPER = "ant.projectHelper";
 
     /**
      * Name of the property holding the name of the currently
      * executing project, if one has been specified.
      *
      * Value: {@value}
      * @since Ant 1.8.0
      */
     public static final String PROJECT_NAME = "ant.project.name";
 
     /**
      * Name of the property holding the default target of the
      * currently executing project, if one has been specified.
      *
      * Value: {@value}
      * @since Ant 1.8.0
      */
     public static final String PROJECT_DEFAULT_TARGET
         = "ant.project.default-target";
 
     /**
      * Name of the property holding a comma separated list of targets
      * that have been invoked (from the command line).
      *
      * Value: {@value}
      * @since Ant 1.8.0
      */
     public static final String PROJECT_INVOKED_TARGETS
         = "ant.project.invoked-targets";
 
     /**
      * Name of the project reference holding an instance of {@link
      * org.apache.tools.ant.taskdefs.launcher.CommandLauncher} to use
      * when executing commands with the help of an external skript.
      *
      * <p>Alternatively this is the name of a system property holding
      * the fully qualified class name of a {@link
      * org.apache.tools.ant.taskdefs.launcher.CommandLauncher}.</p>
      *
      * Value: {@value}
      * @since Ant 1.9.0
      */
     public static final String ANT_SHELL_LAUNCHER_REF_ID = "ant.shellLauncher";
 
     /**
      * Name of the project reference holding an instance of {@link
      * org.apache.tools.ant.taskdefs.launcher.CommandLauncher} to use
      * when executing commands without the help of an external skript.
      *
      * <p>Alternatively this is the name of a system property holding
      * the fully qualified class name of a {@link
      * org.apache.tools.ant.taskdefs.launcher.CommandLauncher}.</p>
      *
      * Value: {@value}
      * @since Ant 1.9.0
      */
     public static final String ANT_VM_LAUNCHER_REF_ID = "ant.vmLauncher";
     /**
      * Name of the namespace "type".
      * (Note: cannot be used as an element.)
      * @since Ant 1.9.1
      */
     public static final String ATTRIBUTE_NAMESPACE = "attribute namespace";
+
+    /**
+     * Name of the property which can provide an override of the
+     * User-Agent used in &lt;get&gt; tasks.
+     * Value {@value}
+     */
+    public static final String HTTP_AGENT_PROPERTY = "ant.http.agent";
 }
 
diff --git a/src/main/org/apache/tools/ant/Main.java b/src/main/org/apache/tools/ant/Main.java
index debfb8843..6be945d2f 100644
--- a/src/main/org/apache/tools/ant/Main.java
+++ b/src/main/org/apache/tools/ant/Main.java
@@ -64,1228 +64,1252 @@ import org.apache.tools.ant.util.ProxySetup;
 public class Main implements AntMain {
 
     /**
      * A Set of args that are handled by the launcher and should
      * not be seen by Main.
      */
     private static final Set<String> LAUNCH_COMMANDS = Collections
             .unmodifiableSet(new HashSet<String>(Arrays.asList("-lib", "-cp", "-noclasspath",
                     "--noclasspath", "-nouserlib", "-main")));
 
     /** The default build file name. {@value} */
     public static final String DEFAULT_BUILD_FILENAME = "build.xml";
 
     /** Our current message output status. Follows Project.MSG_XXX. */
     private int msgOutputLevel = Project.MSG_INFO;
 
     /** File that we are using for configuration. */
     private File buildFile; /* null */
 
     /** Stream to use for logging. */
     private static PrintStream out = System.out;
 
     /** Stream that we are using for logging error messages. */
     private static PrintStream err = System.err;
 
     /** The build targets. */
     private Vector<String> targets = new Vector<String>();
 
     /** Set of properties that can be used by tasks. */
     private Properties definedProps = new Properties();
 
     /** Names of classes to add as listeners to project. */
     private Vector<String> listeners = new Vector<String>(1);
 
     /** File names of property files to load on startup. */
     private Vector<String> propertyFiles = new Vector<String>(1);
 
     /** Indicates whether this build is to support interactive input */
     private boolean allowInput = true;
 
     /** keep going mode */
     private boolean keepGoingMode = false;
 
     /**
      * The Ant logger class. There may be only one logger. It will have
      * the right to use the 'out' PrintStream. The class must implements the
      * BuildLogger interface.
      */
     private String loggerClassname = null;
 
     /**
      * The Ant InputHandler class.  There may be only one input
      * handler.
      */
     private String inputHandlerClassname = null;
 
     /**
      * Whether or not output to the log is to be unadorned.
      */
     private boolean emacsMode = false;
 
     /**
      * Whether or not log output should be reduced to the minimum
      */
     private boolean silent = false;
 
     /**
      * Whether or not this instance has successfully been
      * constructed and is ready to run.
      */
     private boolean readyToRun = false;
 
     /**
      * Whether or not we should only parse and display the project help
      * information.
      */
     private boolean projectHelp = false;
 
     /**
      * Whether or not a logfile is being used. This is used to
      * check if the output streams must be closed.
      */
     private static boolean isLogFileUsed = false;
 
     /**
      * optional thread priority
      */
     private Integer threadPriority = null;
 
     /**
      * proxy flag: default is false
      */
     private boolean proxy = false;
 
     private Map<Class<?>, List<String>> extraArguments = new HashMap<Class<?>, List<String>>();
 
     private static final GetProperty NOPROPERTIES = new GetProperty(){
         public Object getProperty(String aName) {
             // No existing property takes precedence
             return null;
         }};
 
 
 
 
     /**
      * Prints the message of the Throwable if it (the message) is not
      * <code>null</code>.
      *
      * @param t Throwable to print the message of.
      *          Must not be <code>null</code>.
      */
     private static void printMessage(Throwable t) {
         String message = t.getMessage();
         if (message != null) {
             System.err.println(message);
         }
     }
 
     /**
      * Creates a new instance of this class using the
      * arguments specified, gives it any extra user properties which have been
      * specified, and then runs the build using the classloader provided.
      *
      * @param args Command line arguments. Must not be <code>null</code>.
      * @param additionalUserProperties Any extra properties to use in this
      *        build. May be <code>null</code>, which is the equivalent to
      *        passing in an empty set of properties.
      * @param coreLoader Classloader used for core classes. May be
      *        <code>null</code> in which case the system classloader is used.
      */
     public static void start(String[] args, Properties additionalUserProperties,
                              ClassLoader coreLoader) {
         Main m = new Main();
         m.startAnt(args, additionalUserProperties, coreLoader);
     }
 
     /**
      * Start Ant
      * @param args command line args
      * @param additionalUserProperties properties to set beyond those that
      *        may be specified on the args list
      * @param coreLoader - not used
      *
      * @since Ant 1.6
      */
     public void startAnt(String[] args, Properties additionalUserProperties,
                          ClassLoader coreLoader) {
 
         try {
             processArgs(args);
         } catch (Throwable exc) {
             handleLogfile();
             printMessage(exc);
             exit(1);
             return;
         }
 
         if (additionalUserProperties != null) {
             for (Enumeration<?> e = additionalUserProperties.keys();
                     e.hasMoreElements();) {
                 String key = (String) e.nextElement();
                 String property = additionalUserProperties.getProperty(key);
                 definedProps.put(key, property);
             }
         }
 
         // expect the worst
         int exitCode = 1;
         try {
             try {
                 runBuild(coreLoader);
                 exitCode = 0;
             } catch (ExitStatusException ese) {
                 exitCode = ese.getStatus();
                 if (exitCode != 0) {
                     throw ese;
                 }
             }
         } catch (BuildException be) {
             if (err != System.err) {
                 printMessage(be);
             }
         } catch (Throwable exc) {
             exc.printStackTrace();
             printMessage(exc);
         } finally {
             handleLogfile();
         }
         exit(exitCode);
     }
 
     /**
      * This operation is expected to call {@link System#exit(int)}, which
      * is what the base version does.
      * However, it is possible to do something else.
      * @param exitCode code to exit with
      */
     protected void exit(int exitCode) {
         System.exit(exitCode);
     }
 
     /**
      * Close logfiles, if we have been writing to them.
      *
      * @since Ant 1.6
      */
     private static void handleLogfile() {
         if (isLogFileUsed) {
             FileUtils.close(out);
             FileUtils.close(err);
         }
     }
 
     /**
      * Command line entry point. This method kicks off the building
      * of a project object and executes a build using either a given
      * target or the default target.
      *
      * @param args Command line arguments. Must not be <code>null</code>.
      */
     public static void main(String[] args) {
         start(args, null, null);
     }
 
     /**
      * Constructor used when creating Main for later arg processing
      * and startup
      */
     public Main() {
     }
 
     /**
      * Sole constructor, which parses and deals with command line
      * arguments.
      *
      * @param args Command line arguments. Must not be <code>null</code>.
      *
      * @exception BuildException if the specified build file doesn't exist
      *                           or is a directory.
      *
      * @deprecated since 1.6.x
      */
     protected Main(String[] args) throws BuildException {
         processArgs(args);
     }
 
     /**
      * Process command line arguments.
      * When ant is started from Launcher, launcher-only arguments do not get
      * passed through to this routine.
      *
      * @param args the command line arguments.
      *
      * @since Ant 1.6
      */
     private void processArgs(String[] args) {
         String searchForThis = null;
         boolean searchForFile = false;
         PrintStream logTo = null;
 
         // cycle through given args
 
         boolean justPrintUsage = false;
         boolean justPrintVersion = false;
         boolean justPrintDiagnostics = false;
 
         ArgumentProcessorRegistry processorRegistry = ArgumentProcessorRegistry.getInstance();
         
         for (int i = 0; i < args.length; i++) {
             String arg = args[i];
 
             if (arg.equals("-help") || arg.equals("-h")) {
                 justPrintUsage = true;
             } else if (arg.equals("-version")) {
                 justPrintVersion = true;
             } else if (arg.equals("-diagnostics")) {
                 justPrintDiagnostics = true;
             } else if (arg.equals("-quiet") || arg.equals("-q")) {
                 msgOutputLevel = Project.MSG_WARN;
             } else if (arg.equals("-verbose") || arg.equals("-v")) {
                 msgOutputLevel = Project.MSG_VERBOSE;
             } else if (arg.equals("-debug") || arg.equals("-d")) {
                 msgOutputLevel = Project.MSG_DEBUG;
             } else if (arg.equals("-silent") || arg.equals("-S")) {
                 silent = true;
             } else if (arg.equals("-noinput")) {
                 allowInput = false;
             } else if (arg.equals("-logfile") || arg.equals("-l")) {
                 try {
                     File logFile = new File(args[i + 1]);
                     i++;
                     logTo = new PrintStream(new FileOutputStream(logFile));
                     isLogFileUsed = true;
                 } catch (IOException ioe) {
                     String msg = "Cannot write on the specified log file. "
                         + "Make sure the path exists and you have write "
                         + "permissions.";
                     throw new BuildException(msg);
                 } catch (ArrayIndexOutOfBoundsException aioobe) {
                     String msg = "You must specify a log file when "
                         + "using the -log argument";
                     throw new BuildException(msg);
                 }
             } else if (arg.equals("-buildfile") || arg.equals("-file")
                        || arg.equals("-f")) {
                 i = handleArgBuildFile(args, i);
             } else if (arg.equals("-listener")) {
                 i = handleArgListener(args, i);
             } else if (arg.startsWith("-D")) {
                 i = handleArgDefine(args, i);
             } else if (arg.equals("-logger")) {
                 i = handleArgLogger(args, i);
             } else if (arg.equals("-inputhandler")) {
                 i = handleArgInputHandler(args, i);
             } else if (arg.equals("-emacs") || arg.equals("-e")) {
                 emacsMode = true;
             } else if (arg.equals("-projecthelp") || arg.equals("-p")) {
                 // set the flag to display the targets and quit
                 projectHelp = true;
             } else if (arg.equals("-find") || arg.equals("-s")) {
                 searchForFile = true;
                 // eat up next arg if present, default to build.xml
                 if (i < args.length - 1) {
                     searchForThis = args[++i];
                 }
             } else if (arg.startsWith("-propertyfile")) {
                 i = handleArgPropertyFile(args, i);
             } else if (arg.equals("-k") || arg.equals("-keep-going")) {
                 keepGoingMode = true;
             } else if (arg.equals("-nice")) {
                 i = handleArgNice(args, i);
             } else if (LAUNCH_COMMANDS.contains(arg)) {
                 //catch script/ant mismatch with a meaningful message
                 //we could ignore it, but there are likely to be other
                 //version problems, so we stamp down on the configuration now
                 String msg = "Ant's Main method is being handed "
                         + "an option " + arg + " that is only for the launcher class."
                         + "\nThis can be caused by a version mismatch between "
                         + "the ant script/.bat file and Ant itself.";
                 throw new BuildException(msg);
             } else if (arg.equals("-autoproxy")) {
                 proxy = true;
             } else if (arg.startsWith("-")) {
                 boolean processed = false;
                 for (ArgumentProcessor processor : processorRegistry.getProcessors()) {
                     int newI = processor.readArguments(args, i);
                     if (newI != -1) {
                         List<String> extraArgs = extraArguments.get(processor.getClass());
                         if (extraArgs == null) {
                             extraArgs = new ArrayList<String>();
                             extraArguments.put(processor.getClass(), extraArgs);
                         }
                         for (; i < newI && i < args.length; i++) {
                             extraArgs.add(args[i]);
                         }
                         processed = true;
                         break;
                     }
                 }
                 if (!processed) {
                     // we don't have any more args to recognize!
                     String msg = "Unknown argument: " + arg;
                     System.err.println(msg);
                     printUsage();
                     throw new BuildException("");
                 }
             } else {
                 // if it's no other arg, it may be the target
                 targets.addElement(arg);
             }
         }
 
         if (msgOutputLevel >= Project.MSG_VERBOSE || justPrintVersion) {
             printVersion(msgOutputLevel);
         }
 
         if (justPrintUsage || justPrintVersion || justPrintDiagnostics) {
             if (justPrintUsage) {
                 printUsage();
             }
             if (justPrintDiagnostics) {
                 Diagnostics.doReport(System.out, msgOutputLevel);
             }
             return;
         }
 
         // if buildFile was not specified on the command line,
         if (buildFile == null) {
             // but -find then search for it
             if (searchForFile) {
                 if (searchForThis != null) {
                     buildFile = findBuildFile(System.getProperty("user.dir"), searchForThis);
                     if (buildFile == null) {
                         throw new BuildException("Could not locate a build file!");
                     }
                 } else {
                     // no search file specified: so search an existing default file
                     Iterator<ProjectHelper> it = ProjectHelperRepository.getInstance().getHelpers();
                     do {
                         ProjectHelper helper = it.next();
                         searchForThis = helper.getDefaultBuildFile();
                         if (msgOutputLevel >= Project.MSG_VERBOSE) {
                             System.out.println("Searching the default build file: " + searchForThis);
                         }
                         buildFile = findBuildFile(System.getProperty("user.dir"), searchForThis);
                     } while (buildFile == null && it.hasNext());
                     if (buildFile == null) {
                         throw new BuildException("Could not locate a build file!");
                     }
                 }
             } else {
                 // no build file specified: so search an existing default file
                 Iterator<ProjectHelper> it = ProjectHelperRepository.getInstance().getHelpers();
                 do {
                     ProjectHelper helper = it.next();
                     buildFile = new File(helper.getDefaultBuildFile());
                     if (msgOutputLevel >= Project.MSG_VERBOSE) {
                         System.out.println("Trying the default build file: " + buildFile);
                     }
                 } while (!buildFile.exists() && it.hasNext());
             }
         }
 
         // make sure buildfile exists
         if (!buildFile.exists()) {
             System.out.println("Buildfile: " + buildFile + " does not exist!");
             throw new BuildException("Build failed");
         }
 
         if (buildFile.isDirectory()) {
             File whatYouMeant = new File(buildFile, "build.xml");
             if (whatYouMeant.isFile()) {
                 buildFile = whatYouMeant;
             } else {
                 System.out.println("What? Buildfile: " + buildFile + " is a dir!");
                 throw new BuildException("Build failed");
             }
         }
 
         // Normalize buildFile for re-import detection
         buildFile =
             FileUtils.getFileUtils().normalize(buildFile.getAbsolutePath());
 
         // Load the property files specified by -propertyfile
         loadPropertyFiles();
 
         if (msgOutputLevel >= Project.MSG_INFO) {
             System.out.println("Buildfile: " + buildFile);
         }
 
         if (logTo != null) {
             out = logTo;
             err = logTo;
             System.setOut(out);
             System.setErr(err);
         }
         readyToRun = true;
     }
 
     // --------------------------------------------------------
     //    Methods for handling the command line arguments
     // --------------------------------------------------------
 
     /** Handle the -buildfile, -file, -f argument */
     private int handleArgBuildFile(String[] args, int pos) {
         try {
             buildFile = new File(
                 args[++pos].replace('/', File.separatorChar));
         } catch (ArrayIndexOutOfBoundsException aioobe) {
             throw new BuildException(
                 "You must specify a buildfile when using the -buildfile argument");
         }
         return pos;
     }
 
     /** Handle -listener argument */
     private int handleArgListener(String[] args, int pos) {
         try {
             listeners.addElement(args[pos + 1]);
             pos++;
         } catch (ArrayIndexOutOfBoundsException aioobe) {
             String msg = "You must specify a classname when "
                 + "using the -listener argument";
             throw new BuildException(msg);
         }
         return pos;
     }
 
     /** Handler -D argument */
     private int handleArgDefine(String[] args, int argPos) {
         /* Interestingly enough, we get to here when a user
          * uses -Dname=value. However, in some cases, the OS
          * goes ahead and parses this out to args
          *   {"-Dname", "value"}
          * so instead of parsing on "=", we just make the "-D"
          * characters go away and skip one argument forward.
          *
          * I don't know how to predict when the JDK is going
          * to help or not, so we simply look for the equals sign.
          */
         String arg = args[argPos];
         String name = arg.substring(2, arg.length());
         String value = null;
         int posEq = name.indexOf("=");
         if (posEq > 0) {
             value = name.substring(posEq + 1);
             name = name.substring(0, posEq);
         } else if (argPos < args.length - 1) {
             value = args[++argPos];
         } else {
             throw new BuildException("Missing value for property "
                                      + name);
         }
         definedProps.put(name, value);
         return argPos;
     }
 
     /** Handle the -logger argument. */
     private int handleArgLogger(String[] args, int pos) {
         if (loggerClassname != null) {
             throw new BuildException(
                 "Only one logger class may be specified.");
         }
         try {
             loggerClassname = args[++pos];
         } catch (ArrayIndexOutOfBoundsException aioobe) {
             throw new BuildException(
                 "You must specify a classname when using the -logger argument");
         }
         return pos;
     }
 
     /** Handle the -inputhandler argument. */
     private int handleArgInputHandler(String[] args, int pos) {
         if (inputHandlerClassname != null) {
             throw new BuildException("Only one input handler class may "
                                      + "be specified.");
         }
         try {
             inputHandlerClassname = args[++pos];
         } catch (ArrayIndexOutOfBoundsException aioobe) {
             throw new BuildException("You must specify a classname when"
                                      + " using the -inputhandler"
                                      + " argument");
         }
         return pos;
     }
 
     /** Handle the -propertyfile argument. */
     private int handleArgPropertyFile(String[] args, int pos) {
         try {
             propertyFiles.addElement(args[++pos]);
         } catch (ArrayIndexOutOfBoundsException aioobe) {
             String msg = "You must specify a property filename when "
                 + "using the -propertyfile argument";
             throw new BuildException(msg);
         }
         return pos;
     }
 
     /** Handle the -nice argument. */
     private int handleArgNice(String[] args, int pos) {
         try {
             threadPriority = Integer.decode(args[++pos]);
         } catch (ArrayIndexOutOfBoundsException aioobe) {
             throw new BuildException(
                 "You must supply a niceness value (1-10)"
                 + " after the -nice option");
         } catch (NumberFormatException e) {
             throw new BuildException("Unrecognized niceness value: "
                                      + args[pos]);
         }
 
         if (threadPriority.intValue() < Thread.MIN_PRIORITY
             || threadPriority.intValue() > Thread.MAX_PRIORITY) {
             throw new BuildException(
                 "Niceness value is out of the range 1-10");
         }
         return pos;
     }
 
     // --------------------------------------------------------
     //    other methods
     // --------------------------------------------------------
 
     /** Load the property files specified by -propertyfile */
     private void loadPropertyFiles() {
         for (String filename : propertyFiles) {
             Properties props = new Properties();
             FileInputStream fis = null;
             try {
                 fis = new FileInputStream(filename);
                 props.load(fis);
             } catch (IOException e) {
                 System.out.println("Could not load property file "
                                    + filename + ": " + e.getMessage());
             } finally {
                 FileUtils.close(fis);
             }
 
             // ensure that -D properties take precedence
             Enumeration<?> propertyNames = props.propertyNames();
             while (propertyNames.hasMoreElements()) {
                 String name = (String) propertyNames.nextElement();
                 if (definedProps.getProperty(name) == null) {
                     definedProps.put(name, props.getProperty(name));
                 }
             }
         }
     }
 
     /**
      * Helper to get the parent file for a given file.
      * <p>
      * Added to simulate File.getParentFile() from JDK 1.2.
      * @deprecated since 1.6.x
      *
      * @param file   File to find parent of. Must not be <code>null</code>.
      * @return       Parent file or null if none
      */
     private File getParentFile(File file) {
         File parent = file.getParentFile();
 
         if (parent != null && msgOutputLevel >= Project.MSG_VERBOSE) {
             System.out.println("Searching in " + parent.getAbsolutePath());
         }
 
         return parent;
     }
 
     /**
      * Search parent directories for the build file.
      * <p>
      * Takes the given target as a suffix to append to each
      * parent directory in search of a build file.  Once the
      * root of the file-system has been reached <code>null</code>
      * is returned.
      *
      * @param start  Leaf directory of search.
      *               Must not be <code>null</code>.
      * @param suffix  Suffix filename to look for in parents.
      *                Must not be <code>null</code>.
      *
      * @return A handle to the build file if one is found, <code>null</code> if not
      */
     private File findBuildFile(String start, String suffix) {
         if (msgOutputLevel >= Project.MSG_INFO) {
             System.out.println("Searching for " + suffix + " ...");
         }
 
         File parent = new File(new File(start).getAbsolutePath());
         File file = new File(parent, suffix);
 
         // check if the target file exists in the current directory
         while (!file.exists()) {
             // change to parent directory
             parent = getParentFile(parent);
 
             // if parent is null, then we are at the root of the fs,
             // complain that we can't find the build file.
             if (parent == null) {
                 return null;
             }
 
             // refresh our file handle
             file = new File(parent, suffix);
         }
 
         return file;
     }
 
     /**
      * Executes the build. If the constructor for this instance failed
      * (e.g. returned after issuing a warning), this method returns
      * immediately.
      *
      * @param coreLoader The classloader to use to find core classes.
      *                   May be <code>null</code>, in which case the
      *                   system classloader is used.
      *
      * @exception BuildException if the build fails
      */
     private void runBuild(ClassLoader coreLoader) throws BuildException {
 
         if (!readyToRun) {
             return;
         }
 
         ArgumentProcessorRegistry processorRegistry = ArgumentProcessorRegistry.getInstance();
 
         for (ArgumentProcessor processor : processorRegistry.getProcessors()) {
             List<String> extraArgs = extraArguments.get(processor.getClass());
             if (extraArgs != null) {
                 if (processor.handleArg(extraArgs)) {
                     return;
                 }
             }
         }
 
         final Project project = new Project();
         project.setCoreLoader(coreLoader);
 
         Throwable error = null;
 
         try {
             addBuildListeners(project);
             addInputHandler(project);
 
             PrintStream savedErr = System.err;
             PrintStream savedOut = System.out;
             InputStream savedIn = System.in;
 
             // use a system manager that prevents from System.exit()
             SecurityManager oldsm = null;
             oldsm = System.getSecurityManager();
 
                 //SecurityManager can not be installed here for backwards
                 //compatibility reasons (PD). Needs to be loaded prior to
                 //ant class if we are going to implement it.
                 //System.setSecurityManager(new NoExitSecurityManager());
             try {
                 if (allowInput) {
                     project.setDefaultInputStream(System.in);
                 }
                 System.setIn(new DemuxInputStream(project));
                 System.setOut(new PrintStream(new DemuxOutputStream(project, false)));
                 System.setErr(new PrintStream(new DemuxOutputStream(project, true)));
 
 
                 if (!projectHelp) {
                     project.fireBuildStarted();
                 }
 
                 // set the thread priorities
                 if (threadPriority != null) {
                     try {
                         project.log("Setting Ant's thread priority to "
                                 + threadPriority, Project.MSG_VERBOSE);
                         Thread.currentThread().setPriority(threadPriority.intValue());
                     } catch (SecurityException swallowed) {
                         //we cannot set the priority here.
                         project.log("A security manager refused to set the -nice value");
                     }
                 }
 
                 setProperties(project);
 
                 project.setKeepGoingMode(keepGoingMode);
                 if (proxy) {
                     //proxy setup if enabled
                     ProxySetup proxySetup = new ProxySetup(project);
                     proxySetup.enableProxies();
                 }
 
                 for (ArgumentProcessor processor : processorRegistry.getProcessors()) {
                     List<String> extraArgs = extraArguments.get(processor.getClass());
                     if (extraArgs != null) {
                         processor.prepareConfigure(project, extraArgs);
                     }
                 }
 
                 ProjectHelper.configureProject(project, buildFile);
 
                 for (ArgumentProcessor processor : processorRegistry.getProcessors()) {
                     List<String> extraArgs = extraArguments.get(processor.getClass());
                     if (extraArgs != null) {
                         if (processor.handleArg(project, extraArgs)) {
                             return;
                         }
                     }
                 }
 
                 if (projectHelp) {
                     printDescription(project);
                     printTargets(project, msgOutputLevel > Project.MSG_INFO,
                             msgOutputLevel > Project.MSG_VERBOSE);
                     return;
                 }
 
                 // make sure that we have a target to execute
                 if (targets.size() == 0) {
                     if (project.getDefaultTarget() != null) {
                         targets.addElement(project.getDefaultTarget());
                     }
                 }
 
                 project.executeTargets(targets);
             } finally {
                 // put back the original security manager
                 //The following will never eval to true. (PD)
                 if (oldsm != null) {
                     System.setSecurityManager(oldsm);
                 }
 
                 System.setOut(savedOut);
                 System.setErr(savedErr);
                 System.setIn(savedIn);
             }
         } catch (RuntimeException exc) {
             error = exc;
             throw exc;
         } catch (Error e) {
             error = e;
             throw e;
         } finally {
             if (!projectHelp) {
                 try {
                     project.fireBuildFinished(error);
                 } catch (Throwable t) {
                     // yes, I know it is bad style to catch Throwable,
                     // but if we don't, we lose valuable information
                     System.err.println("Caught an exception while logging the"
                                        + " end of the build.  Exception was:");
                     t.printStackTrace();
                     if (error != null) {
                         System.err.println("There has been an error prior to"
                                            + " that:");
                         error.printStackTrace();
                     }
                     throw new BuildException(t);
                 }
             } else if (error != null) {
                 project.log(error.toString(), Project.MSG_ERR);
             }
         }
     }
 
     private void setProperties(final Project project) {
 
         project.init();
 
         // resolve properties
         PropertyHelper propertyHelper = PropertyHelper.getPropertyHelper(project);
         @SuppressWarnings({ "rawtypes", "unchecked" })
         Map raw = new HashMap(definedProps);
         @SuppressWarnings("unchecked")
         Map<String, Object> props = raw;
 
         ResolvePropertyMap resolver = new ResolvePropertyMap(project,
                 NOPROPERTIES, propertyHelper.getExpanders());
         resolver.resolveAllProperties(props, null, false);
 
         // set user-define properties
         for (Entry<String, Object> ent : props.entrySet()) {
             String arg = ent.getKey();
             Object value = ent.getValue();
             project.setUserProperty(arg, String.valueOf(value));
         }
 
         project.setUserProperty(MagicNames.ANT_FILE,
                                 buildFile.getAbsolutePath());
         project.setUserProperty(MagicNames.ANT_FILE_TYPE,
                                 MagicNames.ANT_FILE_TYPE_FILE);
     }
 
     /**
      * Adds the listeners specified in the command line arguments,
      * along with the default listener, to the specified project.
      *
      * @param project The project to add listeners to.
      *                Must not be <code>null</code>.
      */
     protected void addBuildListeners(Project project) {
 
         // Add the default listener
         project.addBuildListener(createLogger());
 
         final int count = listeners.size();
         for (int i = 0; i < count; i++) {
             String className = (String) listeners.elementAt(i);
             BuildListener listener =
                     (BuildListener) ClasspathUtils.newInstance(className,
                             Main.class.getClassLoader(), BuildListener.class);
             project.setProjectReference(listener);
 
             project.addBuildListener(listener);
         }
     }
 
     /**
      * Creates the InputHandler and adds it to the project.
      *
      * @param project the project instance.
      *
      * @exception BuildException if a specified InputHandler
      *                           implementation could not be loaded.
      */
     private void addInputHandler(Project project) throws BuildException {
         InputHandler handler = null;
         if (inputHandlerClassname == null) {
             handler = new DefaultInputHandler();
         } else {
             handler = (InputHandler) ClasspathUtils.newInstance(
                     inputHandlerClassname, Main.class.getClassLoader(),
                     InputHandler.class);
             project.setProjectReference(handler);
         }
         project.setInputHandler(handler);
     }
 
     // TODO: (Jon Skeet) Any reason for writing a message and then using a bare
     // RuntimeException rather than just using a BuildException here? Is it
     // in case the message could end up being written to no loggers (as the
     // loggers could have failed to be created due to this failure)?
     /**
      * Creates the default build logger for sending build events to the ant
      * log.
      *
      * @return the logger instance for this build.
      */
     private BuildLogger createLogger() {
         BuildLogger logger = null;
         if (silent) {
             logger = new SilentLogger();
             msgOutputLevel = Project.MSG_WARN;
             emacsMode = true;
         } else if (loggerClassname != null) {
             try {
                 logger = (BuildLogger) ClasspathUtils.newInstance(
                         loggerClassname, Main.class.getClassLoader(),
                         BuildLogger.class);
             } catch (BuildException e) {
                 System.err.println("The specified logger class "
                     + loggerClassname
                     + " could not be used because " + e.getMessage());
                 throw new RuntimeException();
             }
         } else {
             logger = new DefaultLogger();
         }
 
         logger.setMessageOutputLevel(msgOutputLevel);
         logger.setOutputPrintStream(out);
         logger.setErrorPrintStream(err);
         logger.setEmacsMode(emacsMode);
 
         return logger;
     }
 
     /**
      * Prints the usage information for this class to <code>System.out</code>.
      */
     private static void printUsage() {
         System.out.println("ant [options] [target [target2 [target3] ...]]");
         System.out.println("Options: ");
         System.out.println("  -help, -h              print this message");
         System.out.println("  -projecthelp, -p       print project help information");
         System.out.println("  -version               print the version information and exit");
         System.out.println("  -diagnostics           print information that might be helpful to");
         System.out.println("                         diagnose or report problems.");
         System.out.println("  -quiet, -q             be extra quiet");
         System.out.println("  -silent, -S            print nothing but task outputs and build failures");
         System.out.println("  -verbose, -v           be extra verbose");
         System.out.println("  -debug, -d             print debugging information");
         System.out.println("  -emacs, -e             produce logging information without adornments");
         System.out.println("  -lib <path>            specifies a path to search for jars and classes");
         System.out.println("  -logfile <file>        use given file for log");
         System.out.println("    -l     <file>                ''");
         System.out.println("  -logger <classname>    the class which is to perform logging");
         System.out.println("  -listener <classname>  add an instance of class as a project listener");
         System.out.println("  -noinput               do not allow interactive input");
         System.out.println("  -buildfile <file>      use given buildfile");
         System.out.println("    -file    <file>              ''");
         System.out.println("    -f       <file>              ''");
         System.out.println("  -D<property>=<value>   use value for given property");
         System.out.println("  -keep-going, -k        execute all targets that do not depend");
         System.out.println("                         on failed target(s)");
         System.out.println("  -propertyfile <name>   load all properties from file with -D");
         System.out.println("                         properties taking precedence");
         System.out.println("  -inputhandler <class>  the class which will handle input requests");
         System.out.println("  -find <file>           (s)earch for buildfile towards the root of");
         System.out.println("    -s  <file>           the filesystem and use it");
         System.out.println("  -nice  number          A niceness value for the main thread:"
                 + "                         1 (lowest) to 10 (highest); 5 is the default");
         System.out.println("  -nouserlib             Run ant without using the jar files from"
                 + "                         ${user.home}/.ant/lib");
         System.out.println("  -noclasspath           Run ant without using CLASSPATH");
         System.out.println("  -autoproxy             Java1.5+: use the OS proxy settings");
         System.out.println("  -main <class>          override Ant's normal entry point");
         for (ArgumentProcessor processor : ArgumentProcessorRegistry.getInstance().getProcessors()) {
             processor.printUsage(System.out);
         }
     }
 
     /**
      * Prints the Ant version information to <code>System.out</code>.
      *
      * @exception BuildException if the version information is unavailable
      */
     private static void printVersion(int logLevel) throws BuildException {
         System.out.println(getAntVersion());
     }
 
     /**
      * Cache of the Ant version information when it has been loaded.
      */
     private static String antVersion = null;
 
     /**
+     * Cache of the short Ant version information when it has been loaded.
+     */
+    private static String shortAntVersion = null;
+    
+    /**
      * Returns the Ant version information, if available. Once the information
      * has been loaded once, it's cached and returned from the cache on future
      * calls.
      *
      * @return the Ant version information as a String
      *         (always non-<code>null</code>)
      *
      * @exception BuildException if the version information is unavailable
      */
     public static synchronized String getAntVersion() throws BuildException {
         if (antVersion == null) {
             try {
                 Properties props = new Properties();
                 InputStream in =
                     Main.class.getResourceAsStream("/org/apache/tools/ant/version.txt");
                 props.load(in);
                 in.close();
+                shortAntVersion = props.getProperty("VERSION");
 
                 StringBuffer msg = new StringBuffer();
                 msg.append("Apache Ant(TM) version ");
-                msg.append(props.getProperty("VERSION"));
+                msg.append(shortAntVersion);
                 msg.append(" compiled on ");
                 msg.append(props.getProperty("DATE"));
                 antVersion = msg.toString();
             } catch (IOException ioe) {
                 throw new BuildException("Could not load the version information:"
                                          + ioe.getMessage());
             } catch (NullPointerException npe) {
                 throw new BuildException("Could not load the version information.");
             }
         }
         return antVersion;
     }
+    
+    /**
+     * Returns the short Ant version information, if available. Once the information
+     * has been loaded once, it's cached and returned from the cache on future
+     * calls.
+     * 
+     * @return the short Ant version information as a String
+     *         (always non-<code>null</code>)
+     *         
+     * @throws BuildException BuildException if the version information is unavailable
+     * @since Ant 1.9.3
+     */
+    public static String getShortAntVersion() throws BuildException {
+        if (shortAntVersion == null) {
+            getAntVersion();
+        }
+        return shortAntVersion;
+    }
 
      /**
       * Prints the description of a project (if there is one) to
       * <code>System.out</code>.
       *
       * @param project The project to display a description of.
       *                Must not be <code>null</code>.
       */
     private static void printDescription(Project project) {
        if (project.getDescription() != null) {
           project.log(project.getDescription());
        }
     }
 
     /**
      * Targets in imported files with a project name
      * and not overloaded by the main build file will
      * be in the target map twice. This method
      * removes the duplicate target.
      * @param targets the targets to filter.
      * @return the filtered targets.
      */
     private static Map<String, Target> removeDuplicateTargets(Map<String, Target> targets) {
         Map<Location, Target> locationMap = new HashMap<Location, Target>();
         for (Entry<String, Target> entry : targets.entrySet()) {
             String name = entry.getKey();
             Target target = entry.getValue();
             Target otherTarget = locationMap.get(target.getLocation());
             // Place this entry in the location map if
             //  a) location is not in the map
             //  b) location is in map, but its name is longer
             //     (an imported target will have a name. prefix)
             if (otherTarget == null
                 || otherTarget.getName().length() > name.length()) {
                 locationMap.put(
                     target.getLocation(), target); // Smallest name wins
             }
         }
         Map<String, Target> ret = new HashMap<String, Target>();
         for (Target target : locationMap.values()) {
             ret.put(target.getName(), target);
         }
         return ret;
     }
 
     /**
      * Prints a list of all targets in the specified project to
      * <code>System.out</code>, optionally including subtargets.
      *
      * @param project The project to display a description of.
      *                Must not be <code>null</code>.
      * @param printSubTargets Whether or not subtarget names should also be
      *                        printed.
      */
     private static void printTargets(Project project, boolean printSubTargets,
             boolean printDependencies) {
         // find the target with the longest name
         int maxLength = 0;
         Map<String, Target> ptargets = removeDuplicateTargets(project.getTargets());
         // split the targets in top-level and sub-targets depending
         // on the presence of a description
         Vector<String> topNames = new Vector<String>();
         Vector<String> topDescriptions = new Vector<String>();
         Vector<Enumeration<String>> topDependencies = new Vector<Enumeration<String>>();
         Vector<String> subNames = new Vector<String>();
         Vector<Enumeration<String>> subDependencies = new Vector<Enumeration<String>>();
 
         for (Target currentTarget : ptargets.values()) {
             String targetName = currentTarget.getName();
             if (targetName.equals("")) {
                 continue;
             }
             String targetDescription = currentTarget.getDescription();
             // maintain a sorted list of targets
             if (targetDescription == null) {
                 int pos = findTargetPosition(subNames, targetName);
                 subNames.insertElementAt(targetName, pos);
                 if (printDependencies) {
                     subDependencies.insertElementAt(currentTarget.getDependencies(), pos);
                 }
             } else {
                 int pos = findTargetPosition(topNames, targetName);
                 topNames.insertElementAt(targetName, pos);
                 topDescriptions.insertElementAt(targetDescription, pos);
                 if (targetName.length() > maxLength) {
                     maxLength = targetName.length();
                 }
                 if (printDependencies) {
                     topDependencies.insertElementAt(currentTarget.getDependencies(), pos);
                 }
             }
         }
 
         printTargets(project, topNames, topDescriptions, topDependencies,
                 "Main targets:", maxLength);
         //if there were no main targets, we list all subtargets
         //as it means nothing has a description
         if (topNames.size() == 0) {
             printSubTargets = true;
         }
         if (printSubTargets) {
             printTargets(project, subNames, null, subDependencies, "Other targets:", 0);
         }
 
         String defaultTarget = project.getDefaultTarget();
         if (defaultTarget != null && !"".equals(defaultTarget)) {
             // shouldn't need to check but...
             project.log("Default target: " + defaultTarget);
         }
     }
 
     /**
      * Searches for the correct place to insert a name into a list so as
      * to keep the list sorted alphabetically.
      *
      * @param names The current list of names. Must not be <code>null</code>.
      * @param name  The name to find a place for.
      *              Must not be <code>null</code>.
      *
      * @return the correct place in the list for the given name
      */
     private static int findTargetPosition(Vector<String> names, String name) {
         final int size = names.size();
         int res = size;
         for (int i = 0; i < size && res == size; i++) {
             if (name.compareTo(names.elementAt(i)) < 0) {
                 res = i;
             }
         }
         return res;
     }
 
     /**
      * Writes a formatted list of target names to <code>System.out</code>
      * with an optional description.
      *
      *
      * @param project the project instance.
      * @param names The names to be printed.
      *              Must not be <code>null</code>.
      * @param descriptions The associated target descriptions.
      *                     May be <code>null</code>, in which case
      *                     no descriptions are displayed.
      *                     If non-<code>null</code>, this should have
      *                     as many elements as <code>names</code>.
      * @param topDependencies The list of dependencies for each target.
      *                        The dependencies are listed as a non null
      *                        enumeration of String.
      * @param heading The heading to display.
      *                Should not be <code>null</code>.
      * @param maxlen The maximum length of the names of the targets.
      *               If descriptions are given, they are padded to this
      *               position so they line up (so long as the names really
      *               <i>are</i> shorter than this).
      */
     private static void printTargets(Project project, Vector<String> names,
                                      Vector<String> descriptions, Vector<Enumeration<String>> dependencies,
                                      String heading,
                                      int maxlen) {
         // now, start printing the targets and their descriptions
         String lSep = System.getProperty("line.separator");
         // got a bit annoyed that I couldn't find a pad function
         String spaces = "    ";
         while (spaces.length() <= maxlen) {
             spaces += spaces;
         }
         StringBuilder msg = new StringBuilder();
         msg.append(heading + lSep + lSep);
         final int size = names.size();
         for (int i = 0; i < size; i++) {
             msg.append(" ");
             msg.append(names.elementAt(i));
             if (descriptions != null) {
                 msg.append(
                     spaces.substring(0, maxlen - names.elementAt(i).length() + 2));
                 msg.append(descriptions.elementAt(i));
             }
             msg.append(lSep);
             if (!dependencies.isEmpty()) {
                 Enumeration<String> deps = dependencies.elementAt(i);
                 if (deps.hasMoreElements()) {
                     msg.append("   depends on: ");
                     while (deps.hasMoreElements()) {
                         msg.append(deps.nextElement());
                         if (deps.hasMoreElements()) {
                             msg.append(", ");
                         }
                     }
                     msg.append(lSep);
                 }
             }
         }
         project.log(msg.toString(), Project.MSG_WARN);
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Get.java b/src/main/org/apache/tools/ant/taskdefs/Get.java
index 70529e69d..d1125ae26 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Get.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Get.java
@@ -1,829 +1,838 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
 import java.io.PrintStream;
 import java.net.HttpURLConnection;
 import java.net.URL;
 import java.net.URLConnection;
 import java.util.Date;
 
 import org.apache.tools.ant.BuildException;
+import org.apache.tools.ant.MagicNames;
 import org.apache.tools.ant.Main;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.types.Mapper;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.ResourceCollection;
 import org.apache.tools.ant.types.resources.Resources;
 import org.apache.tools.ant.types.resources.URLProvider;
 import org.apache.tools.ant.types.resources.URLResource;
 import org.apache.tools.ant.util.FileNameMapper;
 import org.apache.tools.ant.util.FileUtils;
 
 /**
  * Gets a particular file from a URL source.
  * Options include verbose reporting, timestamp based fetches and controlling
  * actions on failures. NB: access through a firewall only works if the whole
  * Java runtime is correctly configured.
  *
  * @since Ant 1.1
  *
  * @ant.task category="network"
  */
 public class Get extends Task {
     private static final int NUMBER_RETRIES = 3;
     private static final int DOTS_PER_LINE = 50;
     private static final int BIG_BUFFER_SIZE = 100 * 1024;
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
     private static final int REDIRECT_LIMIT = 25;
     // HttpURLConnection doesn't have a constant for this in Java5 and
     // what it calls HTTP_MOVED_TEMP would better be FOUND
     private static final int HTTP_MOVED_TEMP = 307;
 
     private static final String HTTP = "http";
     private static final String HTTPS = "https";
 
     private static final String DEFAULT_AGENT_PREFIX = "Apache Ant";
 
     private Resources sources = new Resources();
     private File destination; // required
     private boolean verbose = false;
     private boolean useTimestamp = false; //off by default
     private boolean ignoreErrors = false;
     private String uname = null;
     private String pword = null;
     private long maxTime = 0;
     private int numberRetries = NUMBER_RETRIES;
     private boolean skipExisting = false;
     private boolean httpUseCaches = true; // on by default
     private Mapper mapperElement = null;
-    private String userAgent = System.getProperty("http.agent", DEFAULT_AGENT_PREFIX + "/" + Main.getAntVersion()); 
+    private String userAgent = 
+        System.getProperty(MagicNames.HTTP_AGENT_PROPERTY,
+                           DEFAULT_AGENT_PREFIX + "/"
+                           + Main.getShortAntVersion());
 
     /**
      * Does the work.
      *
      * @exception BuildException Thrown in unrecoverable error.
      */
     public void execute() throws BuildException {
         checkAttributes();
 
         for (Resource r : sources) {
             URLProvider up = r.as(URLProvider.class);
             URL source = up.getURL();
 
             File dest = destination;
             if (destination.isDirectory()) {
                 if (mapperElement == null) {
                     String path = source.getPath();
                     if (path.endsWith("/")) {
                         path = path.substring(0, path.length() - 1);
                     }
                     int slash = path.lastIndexOf("/");
                     if (slash > -1) {
                         path = path.substring(slash + 1);
                     }
                     dest = new File(destination, path);
                 } else {
                     FileNameMapper mapper = mapperElement.getImplementation();
                     String[] d = mapper.mapFileName(source.toString());
                     if (d == null) {
                         log("skipping " + r + " - mapper can't handle it",
                             Project.MSG_WARN);
                         continue;
                     } else if (d.length == 0) {
                         log("skipping " + r + " - mapper returns no file name",
                             Project.MSG_WARN);
                         continue;
                     } else if (d.length > 1) {
                         log("skipping " + r + " - mapper returns multiple file"
                             + " names", Project.MSG_WARN);
                         continue;
                     }
                     dest = new File(destination, d[0]);
                 }
             }
 
         //set up logging
         int logLevel = Project.MSG_INFO;
         DownloadProgress progress = null;
         if (verbose) {
             progress = new VerboseProgress(System.out);
         }
 
         //execute the get
         try {
             doGet(source, dest, logLevel, progress);
         } catch (IOException ioe) {
             log("Error getting " + source + " to " + dest);
             if (!ignoreErrors) {
                 throw new BuildException(ioe, getLocation());
             }
         }
         }
     }
 
     /**
      * make a get request, with the supplied progress and logging info.
      * All the other config parameters are set at the task level,
      * source, dest, ignoreErrors, etc.
      * @param logLevel level to log at, see {@link Project#log(String, int)}
      * @param progress progress callback; null for no-callbacks
      * @return true for a successful download, false otherwise.
      * The return value is only relevant when {@link #ignoreErrors} is true, as
      * when false all failures raise BuildExceptions.
      * @throws IOException for network trouble
      * @throws BuildException for argument errors, or other trouble when ignoreErrors
      * is false.
      * @deprecated only gets the first configured resource
      */
     public boolean doGet(int logLevel, DownloadProgress progress)
             throws IOException {
         checkAttributes();
         for (Resource r : sources) {
             URLProvider up = r.as(URLProvider.class);
             URL source = up.getURL();
             return doGet(source, destination, logLevel, progress);
         }
         /*NOTREACHED*/
         return false;
     }
 
     /**
      * make a get request, with the supplied progress and logging info.
      *
      * All the other config parameters like ignoreErrors are set at
      * the task level.
      * @param source the URL to get
      * @param dest the target file
      * @param logLevel level to log at, see {@link Project#log(String, int)}
      * @param progress progress callback; null for no-callbacks
      * @return true for a successful download, false otherwise.
      * The return value is only relevant when {@link #ignoreErrors} is true, as
      * when false all failures raise BuildExceptions.
      * @throws IOException for network trouble
      * @throws BuildException for argument errors, or other trouble when ignoreErrors
      * is false.
      * @since Ant 1.8.0
      */
     public boolean doGet(URL source, File dest, int logLevel,
                          DownloadProgress progress)
         throws IOException {
 
         if (dest.exists() && skipExisting) {
             log("Destination already exists (skipping): "
                 + dest.getAbsolutePath(), logLevel);
             return true;
         }
 
         //dont do any progress, unless asked
         if (progress == null) {
             progress = new NullProgress();
         }
         log("Getting: " + source, logLevel);
         log("To: " + dest.getAbsolutePath(), logLevel);
 
         //set the timestamp to the file date.
         long timestamp = 0;
 
         boolean hasTimestamp = false;
         if (useTimestamp && dest.exists()) {
             timestamp = dest.lastModified();
             if (verbose) {
                 Date t = new Date(timestamp);
                 log("local file date : " + t.toString(), logLevel);
             }
             hasTimestamp = true;
         }
 
         GetThread getThread = new GetThread(source, dest,
                                             hasTimestamp, timestamp, progress,
                                             logLevel, userAgent);
         getThread.setDaemon(true);
         getProject().registerThreadTask(getThread, this);
         getThread.start();
         try {
             getThread.join(maxTime * 1000);
         } catch (InterruptedException ie) {
             log("interrupted waiting for GET to finish",
                 Project.MSG_VERBOSE);
         }
 
         if (getThread.isAlive()) {
             String msg = "The GET operation took longer than " + maxTime
                 + " seconds, stopping it.";
             if (ignoreErrors) {
                 log(msg);
             }
             getThread.closeStreams();
             if (!ignoreErrors) {
                 throw new BuildException(msg);
             }
             return false;
         }
 
         return getThread.wasSuccessful();
     }
 
     /**
      * Check the attributes.
      */
     private void checkAttributes() {
 
         if (userAgent == null || userAgent.trim().length() == 0) {
             throw new BuildException("userAgent may not be null or empty");
         }
 
         if (sources.size() == 0) {
             throw new BuildException("at least one source is required",
                                      getLocation());
         }
         for (Resource r : sources) {
             URLProvider up = r.as(URLProvider.class);
             if (up == null) {
                 throw new BuildException("Only URLProvider resources are"
                                          + " supported", getLocation());
             }
         }
 
         if (destination == null) {
             throw new BuildException("dest attribute is required", getLocation());
         }
 
         if (destination.exists() && sources.size() > 1
             && !destination.isDirectory()) {
             throw new BuildException("The specified destination is not a"
                                      + " directory",
                                      getLocation());
         }
 
         if (destination.exists() && !destination.canWrite()) {
             throw new BuildException("Can't write to "
                                      + destination.getAbsolutePath(),
                                      getLocation());
         }
 
         if (sources.size() > 1 && !destination.exists()) {
             destination.mkdirs();
         }
     }
 
     /**
      * Set an URL to get.
      *
      * @param u URL for the file.
      */
     public void setSrc(URL u) {
         add(new URLResource(u));
     }
 
     /**
      * Adds URLs to get.
      * @since Ant 1.8.0
      */
     public void add(ResourceCollection rc) {
         sources.add(rc);
     }
 
     /**
      * Where to copy the source file.
      *
      * @param dest Path to file.
      */
     public void setDest(File dest) {
         this.destination = dest;
     }
 
     /**
      * If true, show verbose progress information.
      *
      * @param v if "true" then be verbose
      */
     public void setVerbose(boolean v) {
         verbose = v;
     }
 
     /**
      * If true, log errors but do not treat as fatal.
      *
      * @param v if "true" then don't report download errors up to ant
      */
     public void setIgnoreErrors(boolean v) {
         ignoreErrors = v;
     }
 
     /**
      * If true, conditionally download a file based on the timestamp
      * of the local copy.
      *
      * <p>In this situation, the if-modified-since header is set so
      * that the file is only fetched if it is newer than the local
      * file (or there is no local file) This flag is only valid on
      * HTTP connections, it is ignored in other cases.  When the flag
      * is set, the local copy of the downloaded file will also have
      * its timestamp set to the remote file time.</p>
      *
      * <p>Note that remote files of date 1/1/1970 (GMT) are treated as
      * 'no timestamp', and web servers often serve files with a
      * timestamp in the future by replacing their timestamp with that
      * of the current time. Also, inter-computer clock differences can
      * cause no end of grief.</p>
      * @param v "true" to enable file time fetching
      */
     public void setUseTimestamp(boolean v) {
         useTimestamp = v;
     }
 
 
     /**
      * Username for basic auth.
      *
      * @param u username for authentication
      */
     public void setUsername(String u) {
         this.uname = u;
     }
 
     /**
      * password for the basic authentication.
      *
      * @param p password for authentication
      */
     public void setPassword(String p) {
         this.pword = p;
     }
 
     /**
      * The time in seconds the download is allowed to take before
      * being terminated.
      *
      * @since Ant 1.8.0
      */
     public void setMaxTime(long maxTime) {
         this.maxTime = maxTime;
     }
 
     /**
      * The number of retries to attempt upon error, defaults to 3.
      *
      * @param r retry count
      *
      * @since Ant 1.8.0
      */
     public void setRetries(int r) {
         this.numberRetries = r;
     }
 
     /**
      * Skip files that already exist locally.
      *
      * @param s "true" to skip existing destination files
      *
      * @since Ant 1.8.0
      */
     public void setSkipExisting(boolean s) {
         this.skipExisting = s;
     }
+    
+    /**
+     * HTTP connections only - set the user-agent to be used
+     * when communicating with remote server. if null, then
+     * the value is considered unset and the behaviour falls
+     * back to the default of the http API.
+     *
+     * @since Ant 1.9.3
+     */
+    public void setUserAgent(String userAgent) {
+        this.userAgent = userAgent;
+    }
 
     /**
      * HTTP connections only - control caching on the
      * HttpUrlConnection: httpConnection.setUseCaches(); if false, do
      * not allow caching on the HttpUrlConnection.
      *
      * <p>Defaults to true (allow caching, which is also the
      * HttpUrlConnection default value.</p>
      *
      * @since Ant 1.8.0
      */
     public void setHttpUseCaches(boolean httpUseCache) {
         this.httpUseCaches = httpUseCache;
     }
     
     /**
-     * HTTP connections only - set the user-agent to be used
-     * when communicating with remote server. if null, then
-     * the value is considered unset and the behaviour falls
-     * back to the default of the http API.
-     */
-    public void setUserAgent(String userAgent) {
-        this.userAgent = userAgent;
-    }
-
-    /**
      * Define the mapper to map source to destination files.
      * @return a mapper to be configured.
      * @exception BuildException if more than one mapper is defined.
      * @since Ant 1.8.0
      */
     public Mapper createMapper() throws BuildException {
         if (mapperElement != null) {
             throw new BuildException("Cannot define more than one mapper",
                                      getLocation());
         }
         mapperElement = new Mapper(getProject());
         return mapperElement;
     }
 
     /**
      * Add a nested filenamemapper.
      * @param fileNameMapper the mapper to add.
      * @since Ant 1.8.0
      */
     public void add(FileNameMapper fileNameMapper) {
         createMapper().add(fileNameMapper);
     }
 
     /**
      * Provide this for Backward Compatibility.
      */
     protected static class Base64Converter
         extends org.apache.tools.ant.util.Base64Converter {
     }
 
     /**
      * Interface implemented for reporting
      * progress of downloading.
      */
     public interface DownloadProgress {
         /**
          * begin a download
          */
         void beginDownload();
 
         /**
          * tick handler
          *
          */
         void onTick();
 
         /**
          * end a download
          */
         void endDownload();
     }
 
     /**
      * do nothing with progress info
      */
     public static class NullProgress implements DownloadProgress {
 
         /**
          * begin a download
          */
         public void beginDownload() {
 
         }
 
         /**
          * tick handler
          *
          */
         public void onTick() {
         }
 
         /**
          * end a download
          */
         public void endDownload() {
 
         }
     }
 
     /**
      * verbose progress system prints to some output stream
      */
     public static class VerboseProgress implements DownloadProgress  {
         private int dots = 0;
         // CheckStyle:VisibilityModifier OFF - bc
         PrintStream out;
         // CheckStyle:VisibilityModifier ON
 
         /**
          * Construct a verbose progress reporter.
          * @param out the output stream.
          */
         public VerboseProgress(PrintStream out) {
             this.out = out;
         }
 
         /**
          * begin a download
          */
         public void beginDownload() {
             dots = 0;
         }
 
         /**
          * tick handler
          *
          */
         public void onTick() {
             out.print(".");
             if (dots++ > DOTS_PER_LINE) {
                 out.flush();
                 dots = 0;
             }
         }
 
         /**
          * end a download
          */
         public void endDownload() {
             out.println();
             out.flush();
         }
     }
 
     private class GetThread extends Thread {
 
         private final URL source;
         private final File dest;
         private final boolean hasTimestamp;
         private final long timestamp;
         private final DownloadProgress progress;
         private final int logLevel;
 
         private boolean success = false;
         private IOException ioexception = null;
         private BuildException exception = null;
         private InputStream is = null;
         private OutputStream os = null;
         private URLConnection connection;
         private int redirections = 0;
         private String userAgent = null;
         
         GetThread(URL source, File dest,
                   boolean h, long t, DownloadProgress p, int l, String userAgent) {
             this.source = source;
             this.dest = dest;
             hasTimestamp = h;
             timestamp = t;
             progress = p;
             logLevel = l;
             this.userAgent = userAgent;
         }
 
         public void run() {
             try {
                 success = get();
             } catch (IOException ioex) {
                 ioexception = ioex;
             } catch (BuildException bex) {
                 exception = bex;
             }
         }
 
         private boolean get() throws IOException, BuildException {
 
             connection = openConnection(source);
 
             if (connection == null)
             {
                 return false;
             }
 
             boolean downloadSucceeded = downloadFile();
 
             //if (and only if) the use file time option is set, then
             //the saved file now has its timestamp set to that of the
             //downloaded file
             if (downloadSucceeded && useTimestamp)  {
                 updateTimeStamp();
             }
 
             return downloadSucceeded;
         }
 
 
         private boolean redirectionAllowed(URL aSource, URL aDest) {
             if (!(aSource.getProtocol().equals(aDest.getProtocol()) || (HTTP
                     .equals(aSource.getProtocol()) && HTTPS.equals(aDest
                     .getProtocol())))) {
                 String message = "Redirection detected from "
                         + aSource.getProtocol() + " to " + aDest.getProtocol()
                         + ". Protocol switch unsafe, not allowed.";
                 if (ignoreErrors) {
                     log(message, logLevel);
                     return false;
                 } else {
                     throw new BuildException(message);
                 }
             }
 
             redirections++;
             if (redirections > REDIRECT_LIMIT) {
                 String message = "More than " + REDIRECT_LIMIT
                         + " times redirected, giving up";
                 if (ignoreErrors) {
                     log(message, logLevel);
                     return false;
                 } else {
                     throw new BuildException(message);
                 }
             }
 
 
             return true;
         }
 
         private URLConnection openConnection(URL aSource) throws IOException {
 
             // set up the URL connection
             URLConnection connection = aSource.openConnection();
             // modify the headers
             // NB: things like user authentication could go in here too.
             if (hasTimestamp) {
                 connection.setIfModifiedSince(timestamp);
             }
+            // Set the user agent
+            connection.addRequestProperty("User-Agent", this.userAgent);
+            
             // prepare Java 1.1 style credentials
             if (uname != null || pword != null) {
                 String up = uname + ":" + pword;
                 String encoding;
                 // we do not use the sun impl for portability,
                 // and always use our own implementation for consistent
                 // testing
                 Base64Converter encoder = new Base64Converter();
                 encoding = encoder.encode(up.getBytes());
                 connection.setRequestProperty("Authorization", "Basic "
                         + encoding);
             }
 
             if (connection instanceof HttpURLConnection) {
                 ((HttpURLConnection) connection)
                         .setInstanceFollowRedirects(false);
                 ((HttpURLConnection) connection)
                         .setUseCaches(httpUseCaches);
             }
             // connect to the remote site (may take some time)
             try {
                 connection.connect();
             } catch (NullPointerException e) {
                 //bad URLs can trigger NPEs in some JVMs
                 throw new BuildException("Failed to parse " + source.toString(), e);
             }
 
             // First check on a 301 / 302 (moved) response (HTTP only)
             if (connection instanceof HttpURLConnection) {
                 HttpURLConnection httpConnection = (HttpURLConnection) connection;
                 int responseCode = httpConnection.getResponseCode();
                 if (responseCode == HttpURLConnection.HTTP_MOVED_PERM || 
                         responseCode == HttpURLConnection.HTTP_MOVED_TEMP ||
                         responseCode == HttpURLConnection.HTTP_SEE_OTHER ||
                         responseCode == HTTP_MOVED_TEMP)
                 {
                     String newLocation = httpConnection.getHeaderField("Location");
                     String message = aSource
                             + (responseCode == HttpURLConnection.HTTP_MOVED_PERM ? " permanently"
                                     : "") + " moved to " + newLocation;
                     log(message, logLevel);
                     URL newURL = new URL(aSource, newLocation);
                     if (!redirectionAllowed(aSource, newURL))
                     {
                         return null;
                     }
                     return openConnection(newURL);
                 }
                 // next test for a 304 result (HTTP only)
                 long lastModified = httpConnection.getLastModified();
                 if (responseCode == HttpURLConnection.HTTP_NOT_MODIFIED
                         || (lastModified != 0 && hasTimestamp && timestamp >= lastModified)) {
                     // not modified so no file download. just return
                     // instead and trace out something so the user
                     // doesn't think that the download happened when it
                     // didn't
                     log("Not modified - so not downloaded", logLevel);
                     return null;
                 }
                 // test for 401 result (HTTP only)
                 if (responseCode == HttpURLConnection.HTTP_UNAUTHORIZED) {
                     String message = "HTTP Authorization failure";
                     if (ignoreErrors) {
                         log(message, logLevel);
                         return null;
                     } else {
                         throw new BuildException(message);
                     }
                 }
             }
 
             //REVISIT: at this point even non HTTP connections may
             //support the if-modified-since behaviour -we just check
             //the date of the content and skip the write if it is not
             //newer. Some protocols (FTP) don't include dates, of
             //course.
             return connection;
         }
 
         private boolean downloadFile()
                 throws FileNotFoundException, IOException {
             for (int i = 0; i < numberRetries; i++) {
                 // this three attempt trick is to get round quirks in different
                 // Java implementations. Some of them take a few goes to bind
                 // property; we ignore the first couple of such failures.
                 try {
                     is = connection.getInputStream();
                     break;
                 } catch (IOException ex) {
                     log("Error opening connection " + ex, logLevel);
                 }
             }
             if (is == null) {
                 log("Can't get " + source + " to " + dest, logLevel);
                 if (ignoreErrors) {
                     return false;
                 }
                 throw new BuildException("Can't get " + source + " to " + dest,
                         getLocation());
             }
 
             os = new FileOutputStream(dest);
             progress.beginDownload();
             boolean finished = false;
             try {
                 byte[] buffer = new byte[BIG_BUFFER_SIZE];
                 int length;
                 while (!isInterrupted() && (length = is.read(buffer)) >= 0) {
                     os.write(buffer, 0, length);
                     progress.onTick();
                 }
                 finished = !isInterrupted();
             } finally {
                 FileUtils.close(os);
                 FileUtils.close(is);
 
                 // we have started to (over)write dest, but failed.
                 // Try to delete the garbage we'd otherwise leave
                 // behind.
                 if (!finished) {
                     dest.delete();
                 }
             }
             progress.endDownload();
             return true;
         }
 
         private void updateTimeStamp() {
             long remoteTimestamp = connection.getLastModified();
             if (verbose)  {
                 Date t = new Date(remoteTimestamp);
                 log("last modified = " + t.toString()
                     + ((remoteTimestamp == 0)
                        ? " - using current time instead"
                        : ""), logLevel);
             }
             if (remoteTimestamp != 0) {
                 FILE_UTILS.setFileLastModified(dest, remoteTimestamp);
             }
         }
 
         /**
          * Has the download completed successfully?
          *
          * <p>Re-throws any exception caught during executaion.</p>
          */
         boolean wasSuccessful() throws IOException, BuildException {
             if (ioexception != null) {
                 throw ioexception;
             }
             if (exception != null) {
                 throw exception;
             }
             return success;
         }
 
         /**
          * Closes streams, interrupts the download, may delete the
          * output file.
          */
         void closeStreams() {
             interrupt();
             FileUtils.close(os);
             FileUtils.close(is);
             if (!success && dest.exists()) {
                 dest.delete();
             }
         }
     }
 }
