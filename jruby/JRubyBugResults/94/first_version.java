package org.jruby.compiler.ir.targets;

import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Stack;
import org.jruby.RubyInstanceConfig;
import org.jruby.compiler.ir.CALL_Instr;
import org.jruby.compiler.ir.COPY_Instr;
import org.jruby.compiler.ir.CompilerTarget;
import org.jruby.compiler.ir.Constant;
import org.jruby.compiler.ir.Fixnum;
import org.jruby.compiler.ir.IR_Builder;
import org.jruby.compiler.ir.IR_Class;
import org.jruby.compiler.ir.IR_Instr;
import org.jruby.compiler.ir.IR_Method;
import org.jruby.compiler.ir.IR_Scope;
import org.jruby.compiler.ir.IR_Script;
import org.jruby.compiler.ir.Operand;
import org.jruby.compiler.ir.RECV_ARG_Instr;
import org.jruby.compiler.ir.RETURN_Instr;
import org.jruby.compiler.ir.Variable;
import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.ClassWriter;
import org.objectweb.asm.Type;
import org.objectweb.asm.commons.GeneratorAdapter;
import org.objectweb.asm.commons.Method;
import org.objectweb.asm.util.TraceClassVisitor;
import static org.objectweb.asm.Opcodes.*;
import static org.jruby.util.CodegenUtils.*;

// This class represents JVM as the target of compilation
// and outputs bytecode
public class JVM implements CompilerTarget {
    private static final boolean DEBUG = true;
    
    Stack<ClassVisitor> cvStack = new Stack();
    List<ClassVisitor> cwAccum = new ArrayList<ClassVisitor>();
    Stack<GeneratorAdapter> mvStack = new Stack();
    Map<Variable, Integer> varMap;
    IR_Script script;

    public static void main(String[] args) {
        IR_Scope scope = IR_Builder.buildFromMain(args);

        System.out.println("INTERMEDIATE REPRESENTATION:");
        System.out.println(scope);

        JVM jvm = new JVM();
        System.out.println("\nGENERATED BYTECODE:");
        jvm.codegen(scope);
    }

    public JVM() {
    }

    public ClassVisitor cls() {
        return cvStack.peek();
    }

    public void pushclass() {
        if (DEBUG) {
            PrintWriter pw = new PrintWriter(System.out);
            cvStack.push(new TraceClassVisitor(pw));
            pw.flush();
        } else {
            cvStack.push(new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS));
        }
    }

    public void popclass() {
        cvStack.pop();
    }

    public GeneratorAdapter method() {
        return mvStack.peek();
    }

    public void pushmethod(String name) {
        mvStack.push(new GeneratorAdapter(ACC_PUBLIC | ACC_STATIC, Method.getMethod("void " + name + " ()"), null, null, cls()));
        varMap = new HashMap<Variable, Integer>();
    }

    public void popmethod() {
        method().endMethod();
        mvStack.pop();
    }

    public void codegen(IR_Scope scope) {
        if (scope instanceof IR_Script) {
            codegen((IR_Script)scope);
        }
    }

    public void codegen(IR_Script script) {
        this.script = script;
        emit(script.getRootClass());
    }

    public void emit(IR_Class cls) {
        pushclass();
        cls().visit(RubyInstanceConfig.JAVA_VERSION, ACC_PUBLIC + ACC_SUPER, cls._className, null, p(Object.class), null);
        cls().visitSource(script.getFileName().toString(), null);

        // root-level logic
        pushmethod("__class__");
        for (IR_Instr instr: cls.getInstrs()) {
            emit(instr);
        }
        popmethod();

        // root-level methods
        for (IR_Method method : cls._methods) {
            emit(method);
        }

        // root-level classes
        for (IR_Class cls2 : cls._classes) {
            emit(cls2);
        }

        cls().visitEnd();
        popclass();
    }

    public void emit(IR_Method method) {
        pushmethod(method._name);
        for (IR_Instr instr: method.getInstrs()) {
            emit(instr);
        }
        popmethod();
    }

    public void emit(IR_Instr instr) {
        switch (instr._op) {
        case CALL:
            emitCALL((CALL_Instr)instr); break;
        case COPY:
            emitCOPY((COPY_Instr)instr); break;
        case RECV_ARG:
            emitRECV_ARG((RECV_ARG_Instr)instr); break;
        case RETURN:
            emitRETURN((RETURN_Instr) instr); break;
        default:
            System.err.println("unsupported: " + instr._op);
        }
    }

    public void emit(Operand operand) {
        if (operand.isConstant()) {
            emit((Constant)operand);
        } else if (operand instanceof Variable) {
            emit((Variable)operand);
        }
    }

    public void emit(Constant constant) {
        if (constant instanceof Fixnum) {
            method().push(((Fixnum)constant)._value);
        }
    }

    public void emit(Variable variable) {
        int index = getVariableIndex(variable);
        method().loadLocal(index);
    }

    public void emitCOPY(COPY_Instr copy) {
        int index = getVariableIndex(copy._result);
        emit(copy._arg);
        method().storeLocal(index);
    }

    public void emitCALL(CALL_Instr call) {
        for (Operand operand : call._args) {
            emit(operand);
        }
        method().invokeVirtual(Type.getType(Object.class), Method.getMethod("Object " + call._methAddr + " ()"));
    }

    public void emitRETURN(RETURN_Instr ret) {
        emit(ret._arg);
        method().returnValue();
    }

    public void emitRECV_ARG(RECV_ARG_Instr recvArg) {
        int index = getVariableIndex(recvArg._result);
        // TODO: need to get this back into the method signature...now is too late...
    }

    private int getVariableIndex(Variable variable) {
        Integer index = varMap.get(variable);
        if (index == null) {
            index = method().newLocal(Type.getType(Object.class));
            varMap.put(variable, index);
        }
        return index;
    }
}
