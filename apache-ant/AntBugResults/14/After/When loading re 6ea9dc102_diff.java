diff --git a/CONTRIBUTORS b/CONTRIBUTORS
index f019bb923..2914fed69 100644
--- a/CONTRIBUTORS
+++ b/CONTRIBUTORS
@@ -1,399 +1,400 @@
 Amongst other, the following people contributed to ant:
 
 Adam Blinkinsop
 Adam Bryzak
 Adam Sotona
 Aleksandr Ishutin
 Alex Rosen
 Alexei Yudichev
 Alexey Panchenko
 Alexey Solofnenko
 Alfred Theorin
 Alison Winters
 Andreas Ames
 Andreas Mross
 Andrew Eisenberg
 Andrew Everitt
 Andrew Stevens
 Andrey Urazov
 André-John Mas
 Andy Wood
 Anil K. Vijendran
 Anli Shundi
 Anthony Goubard
 Anthony Green
 Anthony Wat
 Antoine Baudoux
 Antoine Levy-Lambert
 Anton Mazkovoi
 Arjan Veenstra
 Arnaud Vandyck
 Arnout J. Kuiper
 Aslak Hellesôy
 Atsuhiko Yamanaka
 Avik Sengupta
 Balazs Fejes 2
 Bart Vanhaute
 Benjamin Burgess
 Ben Galbraith
 Ben Gertzfield
 Benoit Moussaud
 Bernd Dutkowski
 Bernhard Rosenkraenzer
 Brad Clark
 Brant Langer Gurganus
 Brian Curnow
 Brian Deitte
 Brian Felder
 Brian Repko
 Bruce Atherton
 Cedomir Igaly
 Charles Hudak
 Charlie Hubbard
 Chris Povirk
 Christian Knorr
 Christoph Gysin
 Christoph Wilhelms
 Christophe Labouisse
 Christopher A. Longo
 Christopher Charlier
 Clark Archer
 Clemens Hammacher
 Clement OUDOT
 Clive Brettingham-Moore
 Conor MacNeill
 Craeg Strong
 Craig Cottingham
 Craig R. McClanahan
 Craig Richardson
 Craig Ryan
 Craig Sandvik
 Curt Arnold
 Curtis White
 Cyrille Morvan
 D'Arcy Smith
 Dale Anson
 Dale Sherwood
 Dan Armbrust
 Daniel Henrique
 Daniel Ribagnac
 Daniel Spilker
 Daniel Trebbien
 Danno Ferrin
 Danny Yates
 Dante Briones
 Davanum Srinivas
 Dave Brondsema
 Dave Brosius
 David A. Herman
 David Crossley
 David Gärtner
 David S. Johnson
 David Kavanagh
 David LeRoy
 David Leal
 David M. Lloyd
 David Maclean
 David Rees
 Denis Hennessy
 Derek Slager
 Devon C. Miller
 Diane Holt
 dIon Gillard
 Dmitry A. Kuminov
 Dominique Devienne
 Donal Quinlan
 Don Brown
 Don Ferguson
 Don Jeffery
 Drew Sudell
 Eduard Wirch
 Edwin Woudt
 Eli Tucker
 Emmanuel Bourg
 Eric Barboni
 Eric Olsen
 Eric Pugh
 Erik Costlow
 Erik Hatcher
 Erik Langenbach
 Erik Meade
 Ernst de Haan
 Frank Harnack
 Frank Somers
 Frank Zeyda
 Frantisek Kucera
 Frederic Bothamy
 Frederic Lavigne
 Gary S. Weaver
 Gautam Guliani
 Gene-Sung Chung
 Georges-Etienne Legendre
 Gero Vermaas
 Gerrit Riessen
 Gilbert Rebhan
 Gilles Scokart
 Glenn McAllister
 Glenn Twiggs
 Greg Nelson
 Greg Roodt
 Greg Schueler
 Grégoire Vatry
 Günther Kögel
 Harish Prabandham
 Haroon Rafique
 Hiroaki Nakamura
 Holger Engels
 Holger Joest
 Ignacio Coloma
 Ingenonsya France
 Ingmar Stein
 Irene Rusman
 Isaac Shabtay
 Ivan Ivanov
 J Bleijenbergh
 Jack J. Woehr
 James Duncan Davidson
 Jan Cumps
 Jan Matèrne
 Jan Mynarik
 Jan Stolze
 Jason Hunter
 Jason Pettiss
 Jason Salter
 Jason Yip
 Jay Dickon Glanville
 Jay Peck
 Jay van der Meer
 JC Mann
 J D Glanville
 Jean-Francois Brousseau
 Jean-Louis Boudart
 Jeff Gettle
 Jeff Martin
 Jeff Tulley
 Jeff Turner
 Jene Jasper
 Jeremy Mawson
 Jerome Lacoste
 Jesse Glick
 Jesse Stockall
 Jim Allers
 Joerg Wassmer
 Joey Richey
 Johann Herunter
 John Sisson
 Jon Dickinson
 Jon S. Stevens
 Jon Skeet
 Jose Alberto Fernandez
 Joseph Walton
 Josh Lucas
 Juerg Wanner
 Julian Simpson
 Justin Vallon
 Keiron Liddle
 Keith Visco
 Kevin Connor Arpe
 Kevin Greiner
 Kevin Jackson
 Kevin Ross
 Kevin Z Grey
 Kim Hansen
 Kirk Wylie
 Kyle Adams
 Larry Shatzer
 Larry Streepy
 Les Hughes
 Levi Cook
 lucas
 Ludovic Claude
 Maarten Coene
 Magesh Umasankar
 Maneesh Sahu
 Marcel Schutte
 Marcus B&ouml;rger
 Mario Frasca 
 Mariusz Nowostawski
 Mark A. Ziesemer
 Mark DeLaFranier
 Mark Hecker
 Mark R. Diggory
 Mark Salter
 Markus Kahl
 Martijn Kruithof
 Martin Landers
 Martin Poeschl
 Martin van den Bemt
 Martin von Gagern
 Mathieu Champlon
 Mathieu Peltier
 Matt Albrecht
 Matt Benson
 Matt Bishop
 Matt Foemmel
 Matt Grosso
 Matt Humphrey
 Matt Small
 Matt Wildig
 Matthew Hawthorne
 Matthew Inger
 Matthew Kuperus Heun
 Matthew Watson
 Matthias Bhend
 Michael Bayne
 Michael Clarke
 Michael Davey
 Michael J. Sikorsky
 Michael McCallum
 Michael Montuori
 Michael Newcomb
 Micheal Nygard
 Michael Saunders
 Miha
 Mike Davis
 Mike Roberts
 mnowostawski
 Mounir El Hajj
 Nathan Beyer
 Nick Chalko
 Nick Fortescue
 Nick Crossley
 Nick Pellow
 Nicola Ken Barozzi
 Nico Seessle
 Nigel Magnay
 Oliver Merkel
 Oliver Rossmueller
 Ondra Medek
 Omer Shapira
 Oystein Gisnas
 Patrick Altaie
 Patrick C. Beard
 Patrick Chanezon
 Patrick G. Heck (Gus Heck)
 Patrick Martin
 Paul Austin
 Paul Christmann
 Paul Galbraith
 Paul King
 Paulo Gaspar
 Pavan Bayyapu
 Pavel Jisl
 Pawel Zuzelski
 Peter B. West
 Peter Donald
 Peter Doornbosch
 Peter Hulst
 Peter Janes
 Peter Reilly
 Phil Hanna
 Philip Hourihane
 Phillip Wells
 Pierre Delisle
 Pierre Dittgen
 riasol
 R Handerson
 Rami Ojares
 Randy Watler
 Raphael Pierquin
 Ray Waldin
 Remie Bolte
+René Krell
 Richard Evans
 Richard Steele
 Rick Beton
 Robert Anderson
 Robert Clark
 Robert Flaherty
 Robert Shaw
 Robert Streich
 Robert Watkins
 Roberto Scaramuzzi
 Robin Green
 Robin Power
 Robin Verduijn
 Rob Oxspring
 Rob van Oostrum
 Rodrigo Schmidt
 Roger Vaughn
 Roman Ivashin
 Ronen Mashal
 Russell Gold
 Sam Ruby
 Sandra Metz
 Scott Carlson
 Scott Ellsworth
 Scott Johnson
 Scott M. Stirling
 Sean Egan
 Sean P. Kane
 Sebastien Arod
 Shiraz Kanga
 Sebastian Kantha
 Simon Law
 Simone Bordet
 Stefan Bodewig
 Stefan Heimann
 Stefano Mazzocchi
 Stephan Strittmatter
 Stephane Bailliez
 stephan
 Stephan Michels
 Stephen Chin
 Stephen Goetze
 Steve Cohen
 Steve Langley
 Steve Loughran
 Steve Morin
 Steve Wadsworth
 Steven E. Newton
 Sudheer Chigurupati
 Takashi Okamoto
 TAMURA Kent
 Taoufik Romdhane
 Tariq Master
 Thomas Aglassinger
 Thomas Butz
 Thomas Christen
 Thomas Christensen
 Thomas Haas
 Thomas Quas
 Tim Drury
 Tim Fennell
 Tim Stephenson
 Tim Whittington
 Timoteo Ohara
 Timothy Gerard Endres
 Tom Ball
 Tom Brus
 Tom Cunningham
 Tom Dimock
 Tom Eugelink
 Tom May
 Tomasz Bech
 Trejkaz Xaoza
 Ulrich Schmidt
 Uwe Schindler
 Valentino Miazzo
 Victor Toni
 Vimil Saju
 Vincent Legoll
 Volker Leidl
 Waldek Herka
 Wang Weijun
 Will Wang
 William Bernardet
 William Ferguson
 William Webber
 Wolf Siberski
 Wolfgang Baer
 Wolfgang Frech
 Wolfgang Glas
 Wolfgang Werner
 Xavier Hanin
 Xavier Witdouck
 Yohann Roussel
 Yuji Yamano
 Yves Martin
 Zach Garner
 Zdenek Wagner
diff --git a/WHATSNEW b/WHATSNEW
index 6ed7b150e..4f2b9f7e4 100644
--- a/WHATSNEW
+++ b/WHATSNEW
@@ -1,1038 +1,1042 @@
 Changes from Ant 1.9.3 TO current
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * the prefixValues attribute of <property> didn't work as expected
    when set to false (the default).
    It is quite likely existing build files relied on the wrong
    behavior and expect Ant to resolve the value side against the
    properties defined in the property file itself - these build files
    must now explicitly set the prefixValues attribute to true.
    Bugzilla Report 54769
 
 Fixed bugs:
 -----------
 
  * <import>/<include> failed when the importing file was loaded from an
    URI or a jar and it imported a file from the local file system via
    an absolute path.
    Bugzilla Report 50953
 
  * <import> could import the same resource twice when imported via
    different resource types.
    Bugzilla Report 55097
 
  * several calls to File#mkdirs could fall victim to a race condition
    where another thread already created the same directory.
    Bugzilla Report 55290
 
  * <manifestclasspath> created '/' rather than './' for the parent
    directory of the given jarfile.
    Bugzilla Report 55049
 
  * <concat>'s fixlastline="true" didn't work when using certain filter
    readers.
    Bugzilla Report 54672
 
+ * several places where resources are read from jars will now
+   explicitly disable caching to avoid problems with reloading jars.
+   Bugzilla Report 54473
+
 Other changes:
 --------------
 
 
 Changes from Ant 1.9.2 TO Ant 1.9.3
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
 
 Fixed bugs:
 -----------
 
  * <parallel> swallowed the status code of nested <fail> tasks.
    Bugzilla Report 55539.
 
  * a race condition could make <fixcrlf> tasks of parallel builds to
    interfere with each other.
    Bugzilla Report 54393.
 
  * <mail>'s mailport still didn't work properly when using smtps.
    Bugzilla Report 49267.
 
  * using attributes belonging to the if and unless namespaces
    made macrodef fail.
    Bugzilla Report 55885.
 
  * Ant 1.8 exec task changes have slowed exec to a crawl
    Bugzilla Report 54128.
 
  * Apt is not available under JDK 1.8
    Bugzilla Report 55922.
 
 
 Other changes:
 --------------
 
  * Documentation fix for if/unless attributes.  PR 55359.
 
  * tar entries with long link names are now handled the same way as
    entries with long names.
 
  * Addition of 'skipNonTests' attribute to <junit> and <batchtest>
    tasks to allow the tasks to skip classes that don't contain tests.
 
  * <filterset> now supports a nested <propertyset> to specify filters.
    Bugzilla Report 55794.
 
  * <xslt>'s params can now be typed.
    Bugzilla Report 21525.
 
  * build of Mac OS X pkg installer
    Bugzilla Report 55899.
 
 Changes from Ant 1.9.1 TO Ant 1.9.2
 ===================================
 
 Fixed bugs:
 -----------
 
  * Parsing of zip64 extra fields has become more lenient in order to
    be able to read archives created by DotNetZip and maybe other
    archivers as well.
 
  * TarInputStream should now properly read GNU longlink entries' names.
    Bugzilla Report 55040.
 
  * <java> and <exec> used to be too restrictive when evaluating
    whether a given set of options is compatible with spawning the new
    process.
    Bugzilla Report 55112.
 
 Other changes:
 --------------
 
  * <javadoc> will now post-process the generated in order to mitigate
    the frame injection attack possible in javadocs generated by Oracle
    JDKs prior to Java7 Update 25.  The vulnerability is known as
    CVE-2013-1571.
    There is an option to turn off the post-processing but it is only
    recommended you do so if all your builds use a JDK that's not
    vulnerable.
    Bugzilla Report 55132.
 
 Changes from Ant 1.9.0 TO Ant 1.9.1
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Users who have their own ProjectHelper implementation will need to change it because the import and include tasks
    will now default the targetPrefix to ProjectHelper.USE_PROJECT_NAME_AS_TARGET_PREFIX.
    Users using the default ProjectHelper2 with ant need not worry about this change done to fix Bugzilla Report 54940.
 
 
 Fixed bugs:
 -----------
 
  * Corrected XSLTC error in <junitreport>.
    Bugzilla Report 54641.
 
  * Provide more control over Zip64 extensions created by <zip> and
    related tasks.  In particular no Zip64 extensions will be used at
    all by the <jar> task family by default - this is required for jars
    to be readably by Java5.
    Bugzilla Report 54762.
 
  * Fixed loading of external dependencies in JUnit task.
    Bugzilla Report 54835.
 
  * Target rewriting for nested "include" only works when "as" is specified.
    See also "Changes that could break older environments"
    Bugzilla Report 54940.
 
 
 Other changes:
 --------------
 
  * strict attribute added to <signjar>.
    Bugzilla Report 54889.
 
  * simplifying Execute.getEnvironmentVariables since we are only running on Java 1.5 or higher now
 
  * Added conditional attributes.
    Bugzilla Report 43362
 
  * Recommending to upgrade jsch to 0.1.50, particularly if you are using Java 1.7.
    jsch is the library behind the sshexec and scp Ant tasks.
    Versions of jsch older than 0.1.50 fail randomly under Java 1.7 with an error message "verify: false"
 
 Changes from Ant 1.8.4 TO Ant 1.9.0
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Ant now requires at least Java 1.5 to compile and to run
 
  * FixCRLF used to treat the EOL value ASIS to convert to the system property
    line.separator. Specified was that ASIS would leave the EOL characters alone,
    the task now really leaves the EOL characters alone. This also implies that
    EOL ASIS will not insert a newline even if fixlast is set to true.
    Bugzilla report 53036
 
  * The CommandLauncher hierarchy that used to be a set of inner
    classes of Execute has been extracted to the
    org.apache.tools.ant.taskdefs.launcher package.
 
  * Any FileResource whose represented File has a parent also has a basedir.
 
  * Removing the Perforce Ant tasks replaced by tasks supplied by Perforce Inc.
 
  * Setting the default encoding of StringResource to UTF-8 instead of null
 
  * Upgrade JUnit 4 to JUnit 4.11
 
 Fixed bugs:
 -----------
 
  * Made VectorSet faster.
    Bugzilla Report 53622.
 
  * Incorrect URLs in Ant child POMs.
    Bugzilla Report 53617.
 
  * Subclasses of JUnitTask did not correctly find junit.jar.
    Bugzilla Report 53571.
 
  * External XML catalog resolver failed to use project basedir when given an
    unmentioned relative path like the internal resolver does.
    Bugzilla Report 52754.
 
  * Fixed some potential stream leaks.
    Bugzilla Reports 52738, 52740, 52742, 52743.
 
  * Updated documentation to fix spelling errors / broken links.
    Bugzilla Reports 53215, 53291, 53202
    
  * Unable to override system properties. It was not possible not to override
    system properties from the command line (or from a property file).
    Bugzilla Report 51792
    
  * <javac> by default fails when run on JDK 8.
    Bugzilla Report 53347.
 
  * ExtensionPoint doesn't work with nested import/include
    Bugzilla Report 53405.
 
  * <packagemapper> failed to strip the non-matched parts with
    handledirsep="true".
    Bugzilla Report 53399.
 
  * <expandproperties> filter caused a NullPointerException when input
    was empty.
    Bugzilla Report 53626.
 
  * <get> now supports HTTP redirects using status code 307.
    Bugzilla Report 54374.
 
  * ssh tasks prompt for kerberos username/password under Java 7
    Bugzilla Report 53437.
 
  * Zip task on <mappedresources> that excludes certain files by way of the mapper resulted in a NullPointerException
    Bugzilla Report 54026
 
  * The ant launcher script should properly detect JAVA_HOME on
    MacOS X 10.7
    Bugzilla Report 52632
 
  * Depend task does not handle invokeDynamic constant pool entries - java.lang.ClassFormatError: Invalid Constant Pool entry Type 18
    Bugzilla Report 54090
 
  * Base64Converter not properly handling bytes with MSB set (not masking byte to int conversion)
    Bugzilla Report 54460
 
  * The size resource comparator would return wrong results if file
    sizes differed by more than 2 GB.
    Bugzilla Report 54623
 
  * Unable to encode properly into UTF-8 when the system property file.encoding is
    set to ANSI_X3.4-1968.
    Bugzilla Report 54606
 
  * JUnit4 tests marked @Ignore do not appear in XML output
    Bugzilla Report 43969
 
 Other changes:
 --------------
 
  * merged the ZIP package from Commons Compress, it can now read
    archives using Zip64 extensions (files and archives bigger that 4GB
    and with more that 64k entries).
 
  * a new task <commandlauncher> can be used to configure the
    CommandLauncher used by Ant when forking external programs or new
    Java VMs.
    Bugzilla Report 52706.
 
  * merged the TAR package from Commons Compress, it can now read
    archives using POSIX extension headers and STAR extensions.
 
  * merged the BZIP2 package from Commons Compress, it can now
    optionally read files that contain multiple streams properly.
 
  * <bunzip2> will now properly expand files created by pbzip2 and
    similar tools that create files with multiple bzip2 streams.
 
  * <tar> now supports a new "posix" option for longfile-mode which
    will make it create PAX extension headers for long file names.  PAX
    extension headers are supported by all modern implementations of
    tar including GNU tar.
    This option should now be used in preference to "warn" or "gnu" as
    it is more portable.  For backwards compatibility reasons "warn"
    will still create "gnu" extensions rather than "posix" extensions.
 
  * The ProjectHelper class now exposes a method to be used by third party
    implementations to properly resolve the binding between target extensions
    and extension points.
    Bugzilla Report 53549.
 
  * Make extension point bindable to imported prefixed targets
    Bugzilla Report 53550.
 
  * Add the possibility to register a custom command line argument processor.
    See org.apache.tools.ant.ArgumentProcessor and manual/argumentprocessor.html
 
  * add the possibility to suppress stdout in the sshexec task.
    Bugzilla Report 50270.
 
  * add an encoding attribute to the contains selector.
    This will be useful to use the contains selector if the encoding of the VM is different from the encoding
    of the files being selected.
 
  * support for GNU Classpath.
    Bugzilla report 54760.
 
 Changes from Ant 1.8.3 TO Ant 1.8.4
 ===================================
 
 Fixed bugs:
 -----------
 
  * Ported libbzip2's fallback sort algorithm to CBZip2OutputStream to
    speed up compression in certain edge cases.  Merge from Commons
    Compress.
 
    Using specially crafted inputs this can be used as a denial of
    service attack.
    See http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2098
 
 Changes from Ant 1.8.2 TO Ant 1.8.3
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * The Enumeration returned by AntClassLoader#getResources used to
    return null in nextElement after hasNextElement would return false.
    It has been changed to throw a NoSuchElementException instead so
    that it now adheres to the contract of java.util.Enumeration.
    Bugzilla Report 51579.
 
 Fixed bugs:
 -----------
 
  * Removed buggy duplicate JAR list in RPM mode.
    Bugzilla Report 52556.
 
  * Launcher fixed to pass the right class loader parent.
    Bugzilla Report 48633.
 
  * <junitreport> mishandled ${line.separator}.
    Bugzilla Report 51049.
 
  * <junitreport> did not work in embedded environments on JDK 7.
    Nor did <xslt> when using Xalan redirects.
    Bugzilla Report 51668, 52382.
 
  * Encoding of unicode escape sequences by the property file task
    Bugzilla Report 50515.
 
  * The code that implicitly sets the -source switch if only -target
    has been specified in <javac> was broken for Java 5 and 6.
    Bugzilla Report 50578.
 
  * MailLogger ignore the Maillogger.starttls.enable property.
    Bugzilla Report 50668.
 
  * Delete task example does not work
    Bugzilla Report 50816.
 
  * <splash>'s proxy handling has been delegated to <setproxy>
    internally so the two tasks are consistent.  <splash>'s way of not
    setting a proxy caused problems with other Java libraries.
    Bugzilla Report 50888.
 
  * Include task breaks dependencies or extension-points for multiple
    files.
    Bugzilla Report 50866.
 
  * Read on System.in hangs for forked java task.
    Bugzilla Report 50960.
 
  * FileResource specified using basedir/name attributes was non-functional.
 
  * Resource collection implementation of mapped PropertySet returned
    unusable resources.
 
  * The hasmethod condition failed with a NullPointerException when
    ignoresystemclasses is true and Ant tried to load a "restricted
    class" - i.e. a class that the Java VM will only accept when loaded
    via the bootclassloader (a java.* class).
    It will now fail with a more useful error message.
    Bugzilla Report 51035.
 
  * Exec task may mix the stderr and stdout output while logging it
    Bugzilla Report 50507.
 
  * Missing space between "finished" and timestamp in task/target 
    finish message from ProfileLogger.
    Bugzilla Report 51109.
 
  * Redirecting the output of a java, exec or apply task could print in the
    error output stream some "Pipe broken" errors.
    Bugzilla Report 48789.
 
  * ZipFile failed to clean up some resources which could lead to
    OutOfMemoryException while unzipping large archives.
    A similar problem in ZipArchiveOutputStream has been fixed as well.
    Bugzilla Report 42696.
 
  * quiet attribute added to the copy and move tasks, to be used together
    with failonerror=false, so warnings won't get logged 
    Bugzilla Report 48789.
 
  * System.in was closed and not readable anymore by the DefaultInputHandler 
    when Ant is used via its Java API.
    Bugzilla Report 51161
 
  * <sync> only supported a single non-fileset resource collection even
    though the manual said it could be multiple.
 
  * <sync> didn't work properly when working on resource collections.
    Bugzilla Report 51462.
 
  * <augment> cause a NullPointerException if it was used in a target
    that was invoked by multiple targets from the command line.
    Bugzilla Report 50894.
 
  * The ZipFile class could read past the start of the file if the
    given file is not a ZIP archive and it is smaller than the size of
    a ZIP "end of central directory record".
 
  * <javac> would create the empty package-info.class file in the wrong
    directory if no destdir was specified.  Note it may still pick the
    wrong directory if you specify more than one source directory but
    no destDir.  It is highly recommended that you always explicitly
    specify the destDir attribute.
    Bugzilla Report 51947.
 
  * packagemapper now honors the handleDirSep attribute.
    Bugzilla Report 51086.
 
  * the attributes of macrodef tasks had their values run through
    property expansion twice. Still true by default, but can be disabled.
    Bugzilla Report 42046.
 
  * jvc doesn't like it if source file names in argument files are
    quoted.
    Bugzilla Report 31667.
 
  * ZipFile didn't work properly for archives using unicode extra
    fields rather than UTF-8 filenames and the EFS-Flag.
 
  * Access to DirectoryScanner's default excludes wasn't synchronized.
    Bugzilla Report 52188.
 
  * When a Project instance was created by a custom tasks its
    createTask method didn't work.
    Bugzilla Report 50788.
 
 Other changes:
 --------------
 
  * -f/-file/-buildfile accepts a directory containing build.xml.
 
  * The <javacc>, <jjtree> and <jjdoc> now support a new maxmemory
    attribute.
    Bugzilla Report 50513.
 
  * the documented inputstring attribute of sshexec has been
    implemented and the actually existing attribute inputproperty
    documented.
    Bugzilla Report 50576.
 
  * The concat task now permits the name of its exposed resource
    by means of its 'resourcename' attribute.
 
  * The expandproperties filter now accepts a nested propertyset
    which, if specified, provides the properties for expansion.
    Bugzilla Report 51044.
 
  * <junit filtertrace="true"/> will no longer filter out the very
    first line of the stacktrace containing the original exception
    message even if it matches one of the filter expressions.
 
  * Upgraded to Apache AntUnit 1.2
 
  * Provide read access to Mkdir.dir.  Bugzilla Report 51684.
 
  * <delete> and <move> have a new attribute performGCOnFailedDelete
    that may - when set to true - help resolve some problems with
    deleting empty directories on NFS shares.
    Bugzilla Report 45786.
 
  * <loadfile> and <loadresource> used to log at level INFO to signal a
    property hasn't been set when the resource was empty even if the
    quiet attribute was set to true.  They will now use VERBOSE
    instead.
    Bugzilla Report 52107.
 
  * <javac> has a new attribute createMissingPackageInfoClass that can
    be set to false to prevent Ant from creating empty dummy classes
    used for up-to-date-ness checks.
    Bugzilla Report 52096.
 
  * URLResources#isExists has become less noisy.
    Bugzilla Report 51829.
 
  * The <retry> task has a new optional attribute retryDelay that can
    be used to make the task sleep between retry attempts.
    Bugzilla Report 52076.
 
  * <signjar> has new attributes that control the signature and digest
    algorithms.
    Bugzilla Report 52344.
 
  * Initial support for Java 8.
 
  * <sshexec> can optionally create a pseudo terminal (like ssh -t)
    Bugzilla Report 52554.
 
 Changes from Ant 1.8.1 TO Ant 1.8.2
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * Prior to Ant 1.8.0 the <copy> task and several other tasks would
    overwrite read-only destination files.  Starting with 1.8.0 they
    would only do so under special circumstances.  Ant 1.8.2 now
    consistently won't replace a read-only file by default. The same is
    true for a number of other tasks.
    The <copy>, <move> and <echo> tasks now have a new force attribute
    and <concat> has a new forceReadonly attribute that can be used to
    make the task overwrite read-only destinations.
    Bugzilla Report 49261.
 
  * Removed ant-nodeps.jar; it is now merged into ant.jar.
 
  * DOMElementWriter#encode used to employ special code before encoding
    ampersands so that &#123; remained &#123; rather than being turned
    into &amp;#123;.  This is no longer the case, ampersands will now
    be encoded unconditionally.
    Also DOMElementWriter#encodeData will treat CDATA sections containing a
    literal "]]>" sequence different now - it will split the CDATA
    section between the second "]" and ">" and create two sections.
    This affects <echoxml> task as well as the XML logger or JUnit
    formatter where ampersands will now always get encoded.
    In addition DOMElementWriter will now replace the characters \t, \r
    and \n in attribute values by entity references.
    Bugzilla Report 49404.
 
  * The list elements returned by ProjectHelper#getExtensionStack are
    now String arrays of length 3 rather than 2 in order to support the
    onMissingExtensionPoint attribute.
    Bugzilla Report 49473.
 
  * When using <property file="..." prefix="..."/> properties defined
    inside the same file will only get used in expansions if the ${}
    reference uses the same prefix.  This is different from Ant 1.8.1
    but is the same behavior Ant 1.8.0 and earlier exhibited.
    A new attribute prefixValues can be used to re-enable the behavior
    of Ant 1.8.1.
    Bugzilla Report 49373.
 
  * The files and directories used by Git, Mercurial and Bazaar to
    store their information are now excluded by the defaultexcludes.
    Bugzilla Report 49624.
 
  * The <junit> task no longer generates TestListener events - which
    have been introduced in ant 1.7.0 - by default.  The task has a new
    attribute enableTestListenerEvents and a new "magic" property
    ant.junit.enabletestlistenerevents has been added that can be used
    to reinstate the old behavior.
 
 Fixed bugs:
 -----------
 
  * hostinfo now prefers addresses with a hostname over addresses without 
    a hostname, provided the addresses have the same scope.
    For local lookup, no IP address will be put in NAME / DOMAIN anymore.
    For remote lookup, if a host name was provided and only an IP address is 
    found, the IP address will no longer overwrite the host name provided to the
    task.
    Bugzilla Report 49513
 
  * mmap-based file copy problems under JDK 1.4 on Linux.
    Bugzilla Report 49430.
 
  * The Sun JVM tries to mmap the entire file during a copy. 
    For large files this is not feasible. 
    We now explicitly request to copy at most 16 MiB per request.
    Bugzilla Report 49326.
 
  * DemuxInputStream.read() should return unsigned values
    Bugzilla Report 49279.
 
  * The MIME mailer ignored the port parameter when using SSL.
    Bugzilla Report 49267.
 
  * <xslt> ignored the classpath when using the default TraX processor.
    Bugzilla Report 49271.
 
  * <checksum>'s totalproperty only worked reliably if the same file
    name didn't occur inside more than one directory.
    Bugzilla Report 36748.
 
  * <ftp> could fail to download files from remote subdirectories under
    certain circumstances.
    Bugzilla Report 49296.
 
  * <junit> will now produce better diagnostics when it fails to delete
    a temporary file.
    Bugzilla Report 49419.
 
  * Ant would often scan directories even though there were known to
    only hold excluded files when evaluating filesets.  This never
    resulted in wrong results but degraded performance of the scan
    itself.
    Bugzilla Report 49420.
 
  * <javac> failed for long command lines on OS/2.
    Bugzilla Report 49425.
 
  * <junitreport> did not handle encodings well for stdout/stderr.
    Bugzilla Report 49418.
 
  * <junit> could issue a warning about multiple versions of Ant on the
    CLASSPATH if two CLASSPATH entries differed in case on a
    case-insensitive file system.
    Bugzilla Report 49041.
 
  * The <restrict> resource collection was checking every resource even if
    we actually just want the first one, like in the example of use of
    resourcelist in the documentation (getting the first available resource
    from a mirror list).
 
  * A race condition could lead to build failures if multiple <mkdir>
    tasks were trying to create the same directory.
    Bugzilla Report 49572.
 
  * the toString() method of the Resources class - and thus any
    ${toString:} expansion of a reference to a <resources> element -
    didn't iterate over its nested elements if it hadn't done so prior
    to the toString invocation already.
    Bugzilla Report 49588.
 
  * <apply> in parallel mode didn't work together with a nested
    <redirector> if maxparallel was <= 0 (the default) or no source
    files matched.
    Bugzilla Report 49594.
 
  * <jar filesetmanifest="merge"> didn't work for manifests added via
    <zipfileset>s that used the prefix or fullpath attributes.
    Bugzilla Report 49605.
 
  * <tempfile createfile="true"> would cause an error unless the prefix
    attribute has been specified.
    Bugzilla Report 49755.
 
  * If forked, after finished <java> was still reading the input stream
    for a bunch of characters, then stealing them from a following <input>.
    Bugzilla Report 49119.
 
  * Ant could be leaking threads for each forked process (started by
    <exec>, <apply>, <java> or similar tasks) that didn't receive input
    from a resource or string explicitly.
    Bugzilla Report 49587.
 
  * Project#setDefault threw an exception when null was passed in as
    argument, even though the Javadoc says null is a valid value.
    Bugzilla Report 49803.
 
  * runant.py would swallow the first argument if CLASSPATH wasn't set.
    Bugzilla Report 49963.
 
  * <taskdef> failed to load resources from jar files contained in a
    directory that has a "!" in its name.
    Bugzilla Report 50007.
 
  * ant.bat exit strategy improvements and issues
    make the exit codes work in environments where 4NT or MKS are installed
    Bugzilla Report 41039.
 
  * <signjar> would fail if used via its Java API and the File passed
    into the setJar method was not "normalized" (i.e. contained ".."
    segments).
    Bugzilla Report 50081.
 
  * <delete> ignored <fileset>'s errorOnMissingDir attribute
    Bugzilla Report 50124.
 
  * <symlink> failed to close files when reading a list of symbolic
    links from a properties file.
    Bugzilla Report 50136.
 
  * <parallel> could allow tasks to start executing even if a task
    scheduled to run before them timed out.
    Bugzilla Report 49527.
 
  * If a <junit> batch with multiple tests times out Ant logs a message
    about a test named Batch-With-Multiple-Tests since 1.8.0 but the
    logic that determined the Java package of this pseudo-test has been
    wrong.
    Bugzilla Report 45227.
 
  * <propertyfile> didn't preserve the original linefeed style when
    updating a file.
    Bugzilla Report 50049.
 
  * <zip>'s whenEmpty behavior never consulted the non-fileset
    resources so the task could fail even though resources have been
    provided using non-fileset resource collections.
    Bugzilla Issue 50115.
 
 *  ftp chmod could throw a NPE.
    Bugzilla report 50217.
 
 *  The project help (-p option in the command line) will now print
    the dependencies of the targets in debug mode (-d on the command
    line)
 
 Other changes:
 --------------
 
  * <concat>'s force attribute has been deprecated in favor of a new
    overwrite attribute that is consistent with <copy>'s attribute
    names.
 
  * You can now specify a list of methods to run in a JUnit test case.
    Bugzilla Report 34748.
 
  * properties in files read because of the -propertyfile command line
    option will now get resolved against other properties that are
    defined before the project starts executing (those from the same or
    earlier -propertfiles or defined via the -D option).
    Bugzilla Report 18732.
 
  * <pathelement>s can now contain wildcards in order to use wildcard
    CLASSPATH entries introduced with Java6.
    The wildcards are not expanded or even evaluated by Ant and will be
    used literally.  The resulting path may be unusable as a CLASSPATH
    for Java versions prior to Java6 and likely doesn't mean anything
    when used in any other way than a CLASSPATH for a forked Java VM. 
    Bugzilla Report 46842.
 
  * A new attribute allows targets to deal with nonexistent extension
    points, i.e. they can extend an extension-point if it has been
    defined or silently work as plain targets if it hasn't.  This is
    useful for targets that get included/imported in different
    scenarios where a given extension-point may or may not exist.
    Bugzilla Report 49473.
 
  * Ant now logs a warning message if it fails to change the file
    modification time in for example when using <touch> or preserving
    timestamps in various tasks.
    Bugzilla Report 49485.
 
  * ProjectHelpers can now be installed dynamically via the <projecthelper>
    Ant task.
 
  * <import> is now able to switch to the proper ProjectHelper to parse
    the imported resource. This means that several kinds of different build
    files can import each other.
 
  * <copy tofile=""> now also works for non-filesystem resources.
    Bugzilla Report 49756.
 
  * The <linecontainsregexp> filter now supports a casesensitive
    attribute.
 
  * The <containsregexp> selector now supports casesensitive, multiline
    and singleline attributes.
    Bugzilla Report 49764.
 
  * A new <cutdirsmapper> can be used like wget's --cut-dirs option to
    strip leading directories from file names.
 
  * <javah> now supports the GNU project's gcjh compiler.
    Bugzilla Report 50149.
 
  * <checksum> supports additional views of a file's path as elements
    for a custom pattern.
    Bugzilla Report 50114.
 
  * JUnit XMLResultAggregator logs the stack trace of caught IO exceptions
    in verbose runs.
    Bugzilla Report 48836.
 
  * StringUtils.parseHumanSizes() should turn parse failures into
    BuildExceptions.
    Bugzilla Report 48835.
 
  * New task <bindtargets> to make a list of targets bound to some
    specified extension point.
 
  * Initial support for OpenJDK7 has been added.
 
  * Ant now uses java.net.CookieStore rather than
    java.util.ServiceLocator to detect whether the environment is a
    Java 1.6 system.  This means releases of gcj/gij at the time of
    this release of Ant are detected as Java 1.5 and not 1.6.
    Bugzilla Report 50256.
 
  * It is now possible to write a compiler adapter for <javac> that
    compiles sources with extensions other than .java (but that still
    compile to .class files).
    Bugzilla Report 48829.
 
  * The performance of VectorSet#add(Object) has been improved which
    should also benefit any operation that scans directories in Ant.
    Bugzilla Report 50200.
 
 Changes from Ant 1.8.0 TO Ant 1.8.1 
 ===================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * ant-trax.jar is no longer produced since TrAX is included in JDK 1.4+.
 
  * Ant no longer ships with Apache Xerces-J or the XML APIs but relies
    on the Java runtime to provide a parser and matching API versions.
 
  * The stylebook ant task and the ant-stylebook.jar are removed.
 
 Fixed bugs:
 -----------
 
  * Tasks that iterate over task or type definitions, references or
    targets now iterate over copies instead of the live maps to avoid
    ConcurrentModificationExceptions if another thread changes the
    maps.
    Bugzilla Report 48310.
 
  * The filesmatch condition threw a NullPointerException when
    comparing text files and the second file contained fewer lines than
    the first one.
    Bugzilla Report 48715.
 
  * Regression: The <ear> task would allow multiple
    META-INF/application.xml files to be added.
    Bugzilla Report 6836.
 
  * VectorSet#remove(Object) would fail if the size of the vector
    equaled its capacity.
 
  * Regression : ant -diagnostics was returning with exit code 1
    Bugzilla Report 48782
 
  * Fix for exec task sometimes inserts extraneous newlines
    Bugzilla Report 48746
 
  * SymlinkTest#testSymbolicLinkUtilsMethods failing on MacOS
    Bugzilla Report 48785.
 
  * If <concat>'s first resourcecollection child is a <resources>,
    any subsequently added child resourcecollection joins the first.
    Bugzilla Report 48816.
 
  * <get> with an invalid URL could trigger an NPE in some JVMs.
    Bugzilla Report 48833
 
  * Broken Pipe issue under Ubuntu Linux
    Bugzilla Report 48789
 
  * Properties wrongly read from file or not update during read
    Bugzilla Report 48768
 
  * AntClassLoader in Ant 1.8.0 has been considerably slower than in
    1.7.1
    Bugzilla Report 48853
 
  * ANT_CMD_LINE_ARGS are rippling through lower level Ant usage 
    Bugzilla Report 48876
 
  * email : IO error sending mail with plain mimetype
    Bugzilla Report 48932
 
  * the complete-ant-cmd.pl script failed to create a proper cache of
    target if "ant -p" failed.
    Bugzilla Report 48980
 
  * <rmic>'s sourcebase attribute was broken.
    Bugzilla Report 48970
 
  * <copy>'s failonerror didn't work as expected when copying a single
    element resource collection to a file.
    Bugzilla Report 49070
 
  * <get> no longer followed redirects if the redirect URL was relative
    and not an absolute URL.
    Bugzilla Report 48972
 
  * fixed a performance degradation in the code that expands property
    references.
    Bugzilla Reports 48961 and 49079
 
  * <jar filesetmanifest="merge"> was broken on Windows.
    Bugzilla Report 49090
 
  * <symlink> delete failed if the link attribute was a relative path
    to a link inside the current directory without a leading ".".
    Bugzilla Report 49137
 
  * <telnet> and <rexec> failed to find the expected strings when
    waiting for responses and thus always failed.
    Bugzilla Report 49173
 
 Other changes:
 --------------
 
  * Project provides new get methods that return copies instead of the
    live maps of task and type definitions, references and targets.
 
  * Ant is now more lenient with ZIP extra fields and will be able to
    read archives that it failed to read in earlier versions.
    Bugzilla Report 48781.
 
  * The <zip> family of tasks has been sped up for bigger archives.
    Bugzilla Report 48755.
 
  * Add removeKeepExtension option to NetRexxC task.
    Bugzilla Report 48788.
 
  * Add prefix attribute to loadproperties task.
 
  * Add resource attribute to length task.
 
  * PropertyResource will effectively proxy another Resource if ${name}
    evaluates to a Resource object.
 
  * Added forcestring attribute to equals condition to force evaluation
    of Object args as strings; previously only API-level usage of the
    equals condition allowed Object args, but Ant 1.8.x+ property
    evaluation may yield values of any type.
 
  * BuildFileTest.assertPropertyUnset() fails with a slightly more 
    meaningful error message
    Bugzilla Report 48834
 
  * <junit> will now throw an exception if a test name is empty.  This
    used to manifest itself in unrelated errors like
    Bugzilla Report 43586.
 
  * A change that made <exec> more reliable on Windows (Bugzilla Report
    5003) strongly impacts the performance for commands that execute
    quickly, like attrib.  Basically no single execution of a command
    could take less than a second on Windows.
    A few timeouts have been tweaked to allow these commands to finish
    more quickly but still they will take longer than they did with Ant
    1.7.1.
    Bugzilla Report 48734.
 
  * Added SimpleBigProjectLogger, intermediate between NoBannerLogger and
    BigProjectLogger.
 
  * <mappedresources> supports new attributes enablemultiplemappings
    and cache.
 
  * Added the augment task to manipulate existing references via Ant's basic
    introspection mechanisms.
 
 Changes from Ant 1.8.0RC1 TO Ant 1.8.0
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * the appendtolines filter has been renamed to suffixlines.
 
 Fixed bugs:
 -----------
 
  * stack traces were not reported at all by <junit/>
    when filtertrace="on", which is the default.
 
  * ant.bat can now also process the -noclasspath switch when it is 
    the first switch on a command line.
    Bugzilla Report 48186.
 
  * <fixcrlf> now tries to delete the created temporary files earlier.
    Bugzilla Report 48506.
 
  * the implementation of <zip> had been changed in a way that broke
    the jarjar links task and protentially other third-party subclasses
    as well.
    Bugzilla Report 48541.
 
  * <scp> task didn't report build file location when a remote operation failed
    Bugzilla Report 48578.
 
  * <propertyfile> would add the same comment and a date line each time
    it updated an existing property file.
    Bugzilla Report 48558.
 
  * <sound> didn't work properly in recent Java VMs.
    Bugzilla Report 48637.
 
 Other changes:
 --------------
 
 Changes from Ant 1.7.1 TO Ant 1.8.0RC1
 ======================================
 
 Changes that could break older environments:
 -------------------------------------------
 
  * if and unless attributes (on <target> as well as various tasks and other
    elements) have long permitted ${property} interpolation. Now, if the result
    evaluates to "true" or "false" (or "yes", "no", "on", "off"), that boolean
    value will be used; otherwise the traditional behavior of treating the value
    as a property name (defined ~ true, undefined ~ false) is used. Existing
    scripts could be broken if they perversely defined a property named "false"
    and expected if="false" to be true, or used if="true" expecting this to be
    triggered only if a property named "true" were defined.
 
  * Ant now requires Java 1.4 or later.
 
  * Improved handling of InterruptException (lets suppose someone/thing
    is trying to kill the thread when we receive an
    InterruptException), when an InterruptException is received, we do
    not wait anymore in a while loop till the end time has been
    reached.
    Bugzilla Report 42924.
 
  * Refactor PropertyHelper and introspection APIs to make extension
    more granular and support setting task/type attribute values to
    objects decoded by custom PropertyEvaluator delegates. Also add
    <propertyhelper> task for registering delegates and/or replacing
    the registered PropertyHelper instance.
    Bugzilla Report 42736.
 
  * Added a restricted form of typedef called <componentdef>. This
    allows definition of elements that can only be within tasks or
    types. This method is now used to define conditions, selectors,
    comparators and filterreaders. This means that tasks may now have
    nested conditions just by implementing the Condition interface,
diff --git a/contributors.xml b/contributors.xml
index ffb452b43..6c86cd6fd 100644
--- a/contributors.xml
+++ b/contributors.xml
@@ -213,1387 +213,1391 @@
     <first>Bruce</first>
     <last>Atherton</last>
   </name>
   <name>
     <first>Charles</first>
     <last>Hudak</last>
   </name>
   <name>
     <first>Charlie</first>
     <last>Hubbard</last>
   </name>
   <name>
     <first>Chris</first>
     <last>Povirk</last>
   </name>
   <name>
     <first>Christian</first>
     <last>Knorr</last>
   </name>
   <name>
     <first>Christoph</first>
     <last>Gysin</last>
   </name>
   <name>
     <first>Christoph</first>
     <last>Wilhelms</last>
   </name>
   <name>
     <first>Christophe</first>
     <last>Labouisse</last>
   </name>
   <name>
     <first>Christopher</first>
     <middle>A.</middle>
     <last>Longo</last>
   </name>
   <name>
     <first>Christopher</first>
     <last>Charlier</last>
   </name>
   <name>
     <first>Clark</first>
     <last>Archer</last>
   </name>
   <name>
     <first>Clemens</first>
     <last>Hammacher</last>
   </name>
   <name>
     <first>Clement</first>
     <last>OUDOT</last>
   </name>
   <name>
     <first>Clive</first>
     <last>Brettingham-Moore</last>
   </name>
   <name>
     <first>Conor</first>
     <last>MacNeill</last>
   </name>
   <name>
     <first>Craeg</first>
     <last>Strong</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Cottingham</last>
   </name>
   <name>
     <first>Craig</first>
     <middle>R.</middle>
     <last>McClanahan</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Ryan</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Richardson</last>
   </name>
   <name>
     <first>Craig</first>
     <last>Sandvik</last>
   </name>
   <name>
     <first>Curt</first>
     <last>Arnold</last>
   </name>
   <name>
     <first>Curtis</first>
     <last>White</last>
   </name>
   <name>
     <first>Cyrille</first>
     <last>Morvan</last>
   </name>
   <name>
     <first>D'Arcy</first>
     <last>Smith</last>
   </name>
   <name>
     <first>Dale</first>
     <last>Anson</last>
   </name>
   <name>
     <first>Dale</first>
     <last>Sherwood</last>
   </name>
   <name>
     <first>Dan</first>
     <last>Armbrust</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Henrique</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Ribagnac</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Spilker</last>
   </name>
   <name>
     <first>Daniel</first>
     <last>Trebbien</last>
   </name>
   <name>
     <first>Danno</first>
     <last>Ferrin</last>
   </name>
   <name>
     <first>Danny</first>
     <last>Yates</last>
   </name>
   <name>
     <first>Dante</first>
     <last>Briones</last>
   </name>
   <name>
     <first>Davanum</first>
     <last>Srinivas</last>
   </name>
   <name>
     <first>Dave</first>
     <last>Brondsema</last>
   </name>
   <name>
     <first>Dave</first>
     <last>Brosius</last>
   </name>
   <name>
     <first>David</first>
     <last>A.</last>
   </name>
   <name>
     <first>David</first>
     <last>Crossley</last>
   </name>
   <name>
     <first>David</first>
     <last>G&#228;rtner</last>
   </name>
   <name>
     <first>David</first>
     <middle>S.</middle>
     <last>Johnson</last>
   </name>
   <name>
     <first>David</first>
     <last>Kavanagh</last>
   </name>
   <name>
     <first>David</first>
     <last>LeRoy</last>
   </name>
   <name>
     <first>David</first>
     <last>Leal</last>
   </name>
   <name>
     <first>David</first>
     <middle>M.</middle>
     <last>Lloyd</last>
   </name>
   <name>
     <first>David</first>
     <last>Maclean</last>
   </name>
   <name>
     <first>David</first>
     <last>Rees</last>
   </name>
   <name>
     <first>Denis</first>
     <last>Hennessy</last>
   </name>
   <name>
     <first>Derek</first>
     <last>Slager</last>
   </name>
   <name>
     <first>Devon</first>
     <middle>C.</middle>
     <last>Miller</last>
   </name>
   <name>
     <first>Diane</first>
     <last>Holt</last>
   </name>
   <name>
     <first>dIon</first>
     <last>Gillard</last>
   </name>
   <name>
     <first>Dmitry</first>
     <middle>A.</middle>
     <last>Kuminov</last>
   </name>
   <name>
     <first>Dominique</first>
     <last>Devienne</last>
   </name>
   <name>
     <first>Donal</first>
     <last>Quinlan</last>
   </name>
   <name>
     <first>Don</first>
     <last>Bnamen</last>
   </name>
   <name>
     <first>Don</first>
     <last>Ferguson</last>
   </name>
   <name>
     <first>Don</first>
     <last>Jeffery</last>
   </name>
   <name>
     <first>Drew</first>
     <last>Sudell</last>
   </name>
   <name>
     <first>Eduard</first>
     <last>Wirch</last>
   </name>
   <name>
     <first>Edwin</first>
     <last>Woudt</last>
   </name>
   <name>
     <first>Eli</first>
     <last>Tucker</last>
   </name>
   <name>
     <first>Emmanuel</first>
     <last>Bourg</last>
   </name>
   <name>
     <first>Eric</first>
     <last>Olsen</last>
   </name>
   <name>
     <first>Eric</first>
     <last>Pugh</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Costlow</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Hatcher</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Langenbach</last>
   </name>
   <name>
     <first>Erik</first>
     <last>Meade</last>
   </name>
   <name>
     <first>Ernst</first>
     <last>de Haan</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Harnack</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Somers</last>
   </name>
   <name>
     <first>Frank</first>
     <last>Zeyda</last>
   </name>
   <name>
     <first>František</first>
     <last>Kučera</last>
   </name>
   <name>
     <first>Frédéric</first>
     <last>Bothamy</last>
   </name>
   <name>
     <first>Frederic</first>
     <last>Lavigne</last>
   </name>
   <name>
     <first>Gary</first>
     <middle>S.</middle>
     <last>Weaver</last>
   </name>
   <name>
     <first>Gautam</first>
     <last>Guliani</last>
   </name>
   <name>
     <first>Gene-Sung</first>
     <last>Chung</last>
   </name>
   <name>
     <first>Georges-Etienne</first>
     <last>Legendre</last>
   </name>
   <name>
     <first>Gero</first>
     <last>Vermaas</last>
   </name>
   <name>
     <first>Gerrit</first>
     <last>Riessen</last>
   </name>
   <name>
     <first>Gilbert</first>
     <last>Rebhan</last>
   </name>
   <name>
     <first>Gilles</first>
     <last>Scokart</last>
   </name>
   <name>
     <first>Glenn</first>
     <last>McAllister</last>
   </name>
   <name>
     <first>Glenn</first>
     <last>Twiggs</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Nelson</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Roodt</last>
   </name>
   <name>
     <first>Greg</first>
     <last>Schueler</last>
   </name>
   <name>
     <first>Grégoire</first>
     <last>Vatry</last>
   </name>
   <name>
     <first>Günther</first>
     <last>Kögel</last>
   </name>
   <name>
     <first>Harish</first>
     <last>Prabandham</last>
   </name>
   <name>
     <first>Haroon</first>
     <last>Rafique</last>
   </name>
   <name>
     <first>Hiroaki</first>
     <last>Nakamura</last>
   </name>
   <name>
     <first>Holger</first>
     <last>Engels</last>
   </name>
   <name>
     <first>Holger</first>
     <last>Joest</last>
   </name>
   <name>
     <first>Ignacio</first>
     <last>Coloma</last>
   </name>
   <name>
     <first>Ingenonsya</first>
     <last>France</last>
   </name>
   <name>
     <first>Ingmar</first>
     <last>Stein</last>
   </name>
   <name>
     <first>Irene</first>
     <last>Rusman</last>
   </name>
   <name>
     <first>Isaac</first>
     <last>Shabtay</last>
   </name>
   <name>
     <first>Ivan</first>
     <last>Ivanov</last>
   </name>
   <name>
     <first>J</first>
     <last>Bleijenbergh</last>
   </name>
   <name>
     <first>Jack</first>
     <middle>J.</middle>
     <last>Woehr</last>
   </name>
   <name>
     <first>James</first>
     <middle>Duncan</middle>
     <last>Davidson</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Cumps</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Mat&#232;rne</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Mynarik</last>
   </name>
   <name>
     <first>Jan</first>
     <last>Stolze</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Hunter</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Pettiss</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Salter</last>
   </name>
   <name>
     <first>Jason</first>
     <last>Yip</last>
   </name>
   <name>
     <first>Jay</first>
     <middle>Dickon</middle>
     <last>Glanville</last>
   </name>
   <name>
     <first>Jay</first>
     <last>Peck</last>
   </name>
   <name>
     <first>Jay</first>
     <last>van der Meer</last>
   </name>
   <name>
     <first>JC</first>
     <last>Mann</last>
   </name>
   <name>
     <first>J</first>
     <last>D</last>
   </name>
   <name>
     <first>Jean-Francois</first>
     <last>Brousseau</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Gettle</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Martin</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Tulley</last>
   </name>
   <name>
     <first>Jeff</first>
     <last>Turner</last>
   </name>
   <name>
     <first>Jene</first>
     <last>Jasper</last>
   </name>
   <name>
     <first>Jeremy</first>
     <last>Mawson</last>
   </name>
   <name>
     <first>Jerome</first>
     <last>Lacoste</last>
   </name>
   <name>
     <first>Jesse</first>
     <last>Glick</last>
   </name>
   <name>
     <first>Jesse</first>
     <last>Stockall</last>
   </name>
   <name>
     <first>Jim</first>
     <last>Allers</last>
   </name>
   <name>
     <first>Joerg</first>
     <last>Wassmer</last>
   </name>
   <name>
     <first>Joey</first>
     <last>Richey</last>
   </name>
   <name>
     <first>Johann</first>
     <last>Herunter</last>
   </name>
   <name>
     <first>John</first>
     <last>Sisson</last>
   </name>
   <name>
     <first>Jon</first>
     <last>Dickinson</last>
   </name>
   <name>
     <first>Jon</first>
     <last>Skeet</last>
   </name>
   <name>
     <first>Jon</first>
     <middle>S.</middle>
     <last>Stevens</last>
   </name>
   <name>
     <first>Jose</first>
     <middle>Alberto</middle>
     <last>Fernandez</last>
   </name>
   <name>
     <first>Josh</first>
     <last>Lucas</last>
   </name>
   <name>
     <first>Joseph</first>
     <last>Walton</last>
   </name>
   <name>
     <first>Juerg</first>
     <last>Wanner</last>
   </name>
   <name>
     <first>Julian</first>
     <last>Simpson</last>
   </name>
   <name>
     <first>Justin</first>
     <last>Vallon</last>
   </name>
   <name>
     <first>Keiron</first>
     <last>Liddle</last>
   </name>
   <name>
     <first>Keith</first>
     <last>Visco</last>
   </name>
   <name>
     <first>Kevin</first>
     <middle>Connor</middle>
     <last>Arpe</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Greiner</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Jackson</last>
   </name>
   <name>
     <first>Kevin</first>
     <last>Ross</last>
   </name>
   <name>
     <first>Kevin</first>
     <middle>Z</middle>
     <last>Grey</last>
   </name>
   <name>
     <first>Kim</first>
     <last>Hansen</last>
   </name>
   <name>
     <first>Kirk</first>
     <last>Wylie</last>
   </name>
   <name>
     <first>Kyle</first>
     <last>Adams</last>
   </name>
   <name>
     <first>Larry</first>
     <last>Shatzer</last>
   </name>
   <name>
     <first>Larry</first>
     <last>Streepy</last>
   </name>
   <name>
     <first>Les</first>
     <last>Hughes</last>
   </name>
   <name>
     <first>Levi</first>
     <last>Cook</last>
   </name>
   <name>
     <last>lucas</last>
   </name>
   <name>
     <first>Ludovic</first>
     <last>Claude</last>
   </name>
   <name>
     <first>Magesh</first>
     <last>Umasankar</last>
   </name>
   <name>
     <first>Maneesh</first>
     <last>Sahu</last>
   </name>
   <name>
     <first>Marcel</first>
     <last>Schutte</last>
   </name>
   <name>
     <first>Marcus</first>
     <last>Börger</last>
   </name>
   <name>
     <first>Mario</first>
     <last>Frasca</last>
   </name>
   <name>
     <first>Mariusz</first>
     <last>Nowostawski</last>
   </name>
   <name>
     <first>Mark</first>
     <last>DeLaFranier</last>
   </name>
   <name>
     <first>Mark</first>
     <last>Hecker</last>
   </name>
   <name>
     <first>Mark</first>
     <last>Salter</last>
   </name>
   <name>
     <first>Mark</first>
     <middle>R.</middle>
     <last>Diggory</last>
   </name>
   <name>
     <first>Mark</first>
     <middle>A.</middle>
     <last>Ziesemer</last>
   </name>
   <name>
     <first>Markus</first>
     <last>Kahl</last>
   </name>
   <name>
     <first>Martijn</first>
     <last>Kruithof</last>
   </name>
   <name>
     <first>Martin</first>
     <last>Landers</last>
   </name>
   <name>
     <first>Martin</first>
     <last>Poeschl</last>
   </name>
   <name>
     <first>Martin</first>
     <last>van den Bemt</last>
   </name>
   <name>
     <first>Martin</first>
     <last>von Gagern</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Albrecht</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Benson</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Bishop</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Foemmel</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Grosso</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Humphrey</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Small</last>
   </name>
   <name>
     <first>Matt</first>
     <last>Wildig</last>
   </name>
   <name>
     <first>Mathieu</first>
     <last>Champlon</last>
   </name>
   <name>
     <first>Mathieu</first>
     <last>Peltier</last>
   </name>
   <name>
     <first>Matthias</first>
     <last>Bhend</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Hawthorne</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Inger</last>
   </name>
   <name>
     <first>Matthew</first>
     <middle>Kuperus</middle>
     <last>Heun</last>
   </name>
   <name>
     <first>Matthew</first>
     <last>Watson</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Bayne</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Clarke</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Davey</last>
   </name>
   <name>
     <first>Michael</first>
     <middle>J.</middle>
     <last>Sikorsky</last>
   </name>
   <name>
     <first>Michael</first>
     <last>McCallum</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Newcomb</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Nygard</last>
   </name>
   <name>
     <first>Michael</first>
     <last>Saunders</last>
   </name>
   <name>
     <last>Miha</last>
   </name>
   <name>
     <first>Mike</first>
     <last>Davis</last>
   </name>
   <name>
     <first>Mike</first>
     <last>Roberts</last>
   </name>
   <name>
     <last>mnowostawski</last>
   </name>
   <name>
     <first>Mounir</first>
     <last>El Hajj</last>
   </name>
   <name>
     <first>Nathan</first>
     <last>Beyer</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Chalko</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Crossley</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Fortescue</last>
   </name>
   <name>
     <first>Nick</first>
     <last>Pellow</last>
   </name>
   <name>
     <first>Nicola</first>
     <last>Ken</last>
   </name>
   <name>
     <first>Nico</first>
     <last>Seessle</last>
   </name>
   <name>
     <first>Nigel</first>
     <last>Magnay</last>
   </name>
   <name>
     <first>Oliver</first>
     <last>Merkel</last>
   </name>
   <name>
     <first>Oliver</first>
     <last>Rossmueller</last>
   </name>
   <name>
     <first>Omer</first>
     <last>Shapira</last>
   </name>
   <name>
     <first>Ondra</first>
     <last>Medek</last>
   </name>
   <name>
     <first>&#216;ystein</first>
     <last>Gisn&#229;s</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Altaie</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>C.</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Chanezon</last>
   </name>
   <name>
     <first>Patrick</first>
     <last>Gus</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Austin</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Christmann</last>
   </name>
   <name>
     <first>Paul</first>
     <last>Galbraith</last>
   </name>
   <name>
     <first>Paul</first>
     <last>King</last>
   </name>
   <name>
     <first>Paulo</first>
     <last>Gaspar</last>
   </name>
   <name>
     <first>Pavan</first>
     <last>Bayyapu</last>
   </name>
   <name>
     <first>Pavel</first>
     <last>Jisl</last>
   </name>
   <name>
     <first>Paweł</first>
     <last>Zuzelski</last>
   </name>
   <name>
     <first>Peter</first>
     <middle>B.</middle>
     <last>West</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Donald</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Doornbosch</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Hulst</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Janes</last>
   </name>
   <name>
     <first>Peter</first>
     <last>Reilly</last>
   </name>
   <name>
     <first>Phil</first>
     <last>Hanna</last>
   </name>
   <name>
     <first>Philip</first>
     <last>Hourihane</last>
   </name>
   <name>
     <first>Phillip</first>
     <last>Wells</last>
   </name>
   <name>
     <first>Pierre</first>
     <last>Delisle</last>
   </name>
   <name>
     <first>Pierre</first>
     <last>Dittgen</last>
   </name>
   <name>
     <first>R</first>
     <last>Handerson</last>
   </name>
   <name>
     <first>Rami</first>
     <last>Ojares</last>
   </name>
   <name>
     <first>Randy</first>
     <last>Watler</last>
   </name>
   <name>
     <first>Raphael</first>
     <last>Pierquin</last>
   </name>
   <name>
     <first>Ray</first>
     <last>Waldin</last>
   </name>
   <name>
     <first>Remie</first>
     <last>Bolte</last>
   </name>
   <name>
+    <first>René</first>
+    <last>Krell</last>
+  </name>
+  <name>
     <first>Richard</first>
     <last>Evans</last>
   </name>
   <name>
     <first>Richard</first>
     <last>Steele</last>
   </name>
   <name>
     <first>Rick</first>
     <last>Beton</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Anderson</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Clark</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Flaherty</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Shaw</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Streich</last>
   </name>
   <name>
     <first>Robert</first>
     <last>Watkins</last>
   </name>
   <name>
     <first>Roberto</first>
     <last>Scaramuzzi</last>
   </name>
   <name>
     <first>Robin</first>
     <last>Green</last>
   </name>
   <name>
     <first>Robin</first>
     <last>Power</last>
   </name>
   <name>
     <first>Robin</first>
     <last>Verduijn</last>
   </name>
   <name>
     <first>Rob</first>
     <last>Oxspring</last>
   </name>
   <name>
     <first>Rob</first>
     <last>van Oostrum</last>
   </name>
   <name>
     <first>Rodrigo</first>
     <last>Schmidt</last>
   </name>
   <name>
     <first>Roger</first>
     <last>Vaughn</last>
   </name>
   <name>
     <first>Roman</first>
     <last>Ivashin</last>
   </name>
   <name>
     <first>Ronen</first>
     <last>Mashal</last>
   </name>
   <name>
     <first>Russell</first>
     <last>Gold</last>
   </name>
   <name>
     <first>Sam</first>
     <last>Ruby</last>
   </name>
   <name>
     <first>Sandra</first>
     <last>Metz</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Carlson</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Ellsworth</last>
   </name>
   <name>
     <first>Scott</first>
     <last>Johnson</last>
   </name>
   <name>
     <first>Scott</first>
     <middle>M.</middle>
     <last>Stirling</last>
   </name>
   <name>
     <first>Sean</first>
     <last>Egan</last>
   </name>
   <name>
     <first>Sean</first>
     <middle>P.</middle>
     <last>Kane</last>
   </name>
   <name>
     <first>Sebastien</first>
     <last>Arod</last>
   </name>
   <name>
     <first>Shiraz</first>
     <last>Kanga</last>
   </name>
   <name>
     <first>Sebastian</first>
     <last>Kantha</last>
   </name>
   <name>
       <first>Simon</first>
       <last>Law</last>
   </name>
   <name>
     <first>Simone</first>
     <last>Bordet</last>
   </name>
   <name>
     <first>Stefan</first>
     <last>Bodewig</last>
   </name>
   <name>
     <first>Stefan</first>
     <last>Heimann</last>
   </name>
   <name>
     <first>Stefano</first>
     <last>Mazzocchi</last>
   </name>
   <name>
     <first>Stephan</first>
     <last>Strittmatter</last>
   </name>
   <name>
     <first>Stephane</first>
     <last>Bailliez</last>
   </name>
   <name>
     <last>stephan</last>
   </name>
   <name>
     <first>Stephan</first>
     <last>Michels</last>
   </name>
   <name>
     <first>Stephen</first>
     <last>Chin</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Cohen</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Langley</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Loughran</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Morin</last>
   </name>
   <name>
     <first>Steve</first>
     <last>Wadsworth</last>
   </name>
   <name>
     <first>Steven</first>
     <middle>E.</middle>
     <last>Newton</last>
   </name>
   <name>
     <first>Sudheer</first>
     <last>Chigurupati</last>
   </name>
   <name>
     <first>Takashi</first>
     <last>Okamoto</last>
   </name>
   <name>
     <first>TAMURA</first>
     <last>Kent</last>
   </name>
   <name>
     <first>Taoufik</first>
     <last>Romdhane</last>
   </name>
   <name>
     <first>Tariq</first>
     <last>Master</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Aglassinger</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Butz</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Christen</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Christensen</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Haas</last>
   </name>
   <name>
     <first>Thomas</first>
     <last>Quas</last>
   </name>
   <name>
     <first>Tim</first>
     <last>Drury</last>
   </name>
   <name>
     <first>Tim</first>
     <last>Fennell</last>
   </name>
   <name>
     <first>Tim</first>
     <last>Whittington</last>
   </name>
   <name>
     <first>Timoteo</first>
     <last>Ohara</last>
   </name>
   <name>
     <first>Timothy</first>
     <middle>Gerard</middle>
     <last>Endres</last>
   </name>
   <name>
     <first>Tim</first>
     <last>Stephenson</last>
   </name>
   <name>
     <first>Tom</first>
     <last>Ball</last>
   </name>
   <name>
     <first>Tom</first>
     <last>Cunningham</last>
   </name>
   <name>
     <first>Tom</first>
     <last>Dimock</last>
   </name>
   <name>
     <first>Tom</first>
     <last>Eugelink</last>
   </name>
   <name>
     <first>Tom</first>
     <last>May</last>
   </name>
   <name>
     <first>Tomasz</first>
     <last>Bech</last>
   </name>
   <name>
     <first>Trejkaz</first>
     <last>Xaoz</last>
   </name>
   <name>
     <first>Ulrich</first>
     <last>Schmidt</last>
   </name>
   <name>
     <first>Uwe</first>
     <last>Schindler</last>
   </name>
   <name>
     <first>Valentino</first>
     <last>Miazzo</last>
   </name>
   <name>
     <first>Victor</first>
     <last>Toni</last>
   </name>
   <name>
     <first>Vincent</first>
     <last>Legoll</last>
   </name>
   <name>
     <first>Vimil</first>
     <last>Saju</last>
   </name>
   <name>
     <first>Volker</first>
     <last>Leidl</last>
   </name>
   <name>
     <first>Wang</first>
     <last>Weijun</last>
   </name>
   <name>
     <first>Will</first>
     <last>Wang</last>
   </name>
   <name>
     <first>William</first>
     <last>Bernardet</last>
   </name>
   <name>
     <first>William</first>
     <last>Ferguson</last>
   </name>
   <name>
     <first>William</first>
     <last>Webber</last>
   </name>
   <name>
     <first>Wolf</first>
     <last>Siberski</last>
   </name>
   <name>
     <first>Wolfgang</first>
     <last>Baer</last>
   </name>
   <name>
     <first>Wolfgang</first>
     <last>Frech</last>
   </name>
   <name>
     <first>Wolfgang</first>
     <last>Glas</last>
   </name>
   <name>
     <first>Wolfgang</first>
     <last>Werner</last>
   </name>
   <name>
     <first>Xavier</first>
     <last>Hanin</last>
   </name>
   <name>
     <first>Xavier</first>
     <last>Witdouck</last>
   </name>
   <name>
     <first>Yohann</first>
     <last>Roussel</last>
   </name>
   <name>
     <first>Yuji</first>
     <last>Yamano</last>
   </name>
   <name>
     <first>Yves</first>
     <last>Martin</last>
   </name>
   <name>
     <first>Zach</first>
     <last>Garner</last>
   </name>
   <name>
     <first>Zdenek</first>
     <last>Wagner</last>
   </name>
   <name>
     <first/>
     <last>riasol</last>
   </name>
 </contributors>
diff --git a/src/main/org/apache/tools/ant/ArgumentProcessorRegistry.java b/src/main/org/apache/tools/ant/ArgumentProcessorRegistry.java
index 286433aa7..f889d501b 100644
--- a/src/main/org/apache/tools/ant/ArgumentProcessorRegistry.java
+++ b/src/main/org/apache/tools/ant/ArgumentProcessorRegistry.java
@@ -1,168 +1,171 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant;
 
 import java.io.BufferedReader;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.net.URL;
+import java.net.URLConnection;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.List;
 
 import org.apache.tools.ant.util.LoaderUtils;
 
 /**
  * The global registry for {@link ArgumentProcessor}s.
  * <p>
  * An {@link ArgumentProcessor} implementation can be registered via the system
  * property <code>org.apache.tools.ant.ArgumentProcessor</code>, or via a JDK1.3
  * 'service', by putting the fully qualified name of the implementation into the
  * file <code>META-INF/services/org.apache.tools.ant.ArgumentProcessor</code>
  * <p>
  * Use the system property <code>ant.argument-processor.debug</code> to enable
  * the print of debug log.
  * 
  * @since 1.9
  */
 public class ArgumentProcessorRegistry {
 
     private static final String DEBUG_ARGUMENT_PROCESSOR_REPOSITORY = "ant.argument-processor-repo.debug";
 
     // The message log level is not accessible here because everything
     // is instanciated statically
     private static final boolean DEBUG = "true".equals(System.getProperty(DEBUG_ARGUMENT_PROCESSOR_REPOSITORY));
 
     private static final String SERVICE_ID = "META-INF/services/org.apache.tools.ant.ArgumentProcessor";
 
     private static ArgumentProcessorRegistry instance = new ArgumentProcessorRegistry();
 
     private List<ArgumentProcessor> processors = new ArrayList<ArgumentProcessor>();
 
     public static ArgumentProcessorRegistry getInstance() {
         return instance;
     }
 
     private ArgumentProcessorRegistry() {
         collectArgumentProcessors();
     }
 
     public List<ArgumentProcessor> getProcessors() {
         return processors;
     }
 
     private void collectArgumentProcessors() {
         try {
             ClassLoader classLoader = LoaderUtils.getContextClassLoader();
             if (classLoader != null) {
                 Enumeration<URL> resources = classLoader.getResources(SERVICE_ID);
                 while (resources.hasMoreElements()) {
                     URL resource = resources.nextElement();
-                    ArgumentProcessor processor = getProcessorByService(resource.openStream());
+                    URLConnection conn = resource.openConnection();
+                    conn.setDefaultUseCaches(false);
+                    ArgumentProcessor processor = getProcessorByService(conn.getInputStream());
                     registerArgumentProcessor(processor);
                 }
             }
 
             InputStream systemResource = ClassLoader.getSystemResourceAsStream(SERVICE_ID);
             if (systemResource != null) {
                 ArgumentProcessor processor = getProcessorByService(systemResource);
                 registerArgumentProcessor(processor);
             }
         } catch (Exception e) {
             System.err.println("Unable to load ArgumentProcessor from service "
                     + SERVICE_ID + " (" + e.getClass().getName() + ": "
                     + e.getMessage() + ")");
             if (DEBUG) {
                 e.printStackTrace(System.err);
             }
         }
     }
 
     public void registerArgumentProcessor(String helperClassName)
             throws BuildException {
         registerArgumentProcessor(getProcessor(helperClassName));
     }
 
     public void registerArgumentProcessor(
             Class< ? extends ArgumentProcessor> helperClass)
             throws BuildException {
         registerArgumentProcessor(getProcessor(helperClass));
     }
 
     private ArgumentProcessor getProcessor(String helperClassName) {
         try {
             @SuppressWarnings("unchecked")
             Class< ? extends ArgumentProcessor> cl = (Class< ? extends ArgumentProcessor>) Class.forName(helperClassName);
             return getProcessor(cl);
         } catch (ClassNotFoundException e) {
             throw new BuildException("Argument processor class "
                     + helperClassName + " was not found", e);
         }
     }
 
     private ArgumentProcessor getProcessor(
             Class< ? extends ArgumentProcessor> processorClass) {
         ArgumentProcessor processor;
         try {
             processor = processorClass.getConstructor().newInstance();
         } catch (Exception e) {
             throw new BuildException("The argument processor class"
                     + processorClass.getClass().getName()
                     + " could not be instanciated with a default constructor",
                     e);
         }
         return processor;
     }
 
     public void registerArgumentProcessor(ArgumentProcessor processor) {
         if (processor == null) {
             return;
         }
         processors.add(processor);
         if (DEBUG) {
             System.out.println("Argument processor "
                     + processor.getClass().getName() + " registered.");
         }
     }
 
     private ArgumentProcessor getProcessorByService(InputStream is)
             throws IOException {
         InputStreamReader isr = null;
         try {
             try {
                 isr = new InputStreamReader(is, "UTF-8");
             } catch (java.io.UnsupportedEncodingException e) {
                 isr = new InputStreamReader(is);
             }
             BufferedReader rd = new BufferedReader(isr);
             String processorClassName = rd.readLine();
             if (processorClassName != null && !"".equals(processorClassName)) {
                 return getProcessor(processorClassName);
             }
         } finally {
             try {
                 isr.close();
             } catch (IOException e) {
                 // ignore
             }
         }
         return null;
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/ProjectHelperRepository.java b/src/main/org/apache/tools/ant/ProjectHelperRepository.java
index f83c97326..75c2476ff 100644
--- a/src/main/org/apache/tools/ant/ProjectHelperRepository.java
+++ b/src/main/org/apache/tools/ant/ProjectHelperRepository.java
@@ -1,334 +1,337 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant;
 
 import java.io.BufferedReader;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.lang.reflect.Constructor;
 import java.net.URL;
+import java.net.URLConnection;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.Iterator;
 import java.util.List;
 
 import org.apache.tools.ant.helper.ProjectHelper2;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.util.LoaderUtils;
 
 /**
  * Repository of {@link ProjectHelper} found in the classpath or via
  * some System properties.
  *
  * <p>See the ProjectHelper documentation in the manual.</p>
  *
  * @since Ant 1.8.0
  */
 public class ProjectHelperRepository {
 
     private static final String DEBUG_PROJECT_HELPER_REPOSITORY =
         "ant.project-helper-repo.debug";
 
     // The message log level is not accessible here because everything
     // is instanciated statically
     private static final boolean DEBUG =
         "true".equals(System.getProperty(DEBUG_PROJECT_HELPER_REPOSITORY));
 
     private static ProjectHelperRepository instance =
         new ProjectHelperRepository();
 
     private List<Constructor<? extends ProjectHelper>> helpers = new ArrayList<Constructor<? extends ProjectHelper>>();
 
     private static Constructor<ProjectHelper2> PROJECTHELPER2_CONSTRUCTOR;
 
     static {
         try {
             PROJECTHELPER2_CONSTRUCTOR = ProjectHelper2.class.getConstructor();
         } catch (Exception e) {
             // ProjectHelper2 must be available
             throw new RuntimeException(e);
         }
     }
 
     public static ProjectHelperRepository getInstance() {
         return instance;
     }
 
     private ProjectHelperRepository() {
         collectProjectHelpers();
     }
 
     private void collectProjectHelpers() {
         // First, try the system property
         Constructor<? extends ProjectHelper> projectHelper = getProjectHelperBySystemProperty();
         registerProjectHelper(projectHelper);
 
         // A JDK1.3 'service' ( like in JAXP ). That will plug a helper
         // automatically if in CLASSPATH, with the right META-INF/services.
         try {
             ClassLoader classLoader = LoaderUtils.getContextClassLoader();
             if (classLoader != null) {
                 Enumeration<URL> resources =
                     classLoader.getResources(ProjectHelper.SERVICE_ID);
                 while (resources.hasMoreElements()) {
                     URL resource = resources.nextElement();
+                    URLConnection conn = resource.openConnection();
+                    conn.setDefaultUseCaches(false);
                     projectHelper =
-                        getProjectHelperByService(resource.openStream());
+                        getProjectHelperByService(conn.getInputStream());
                     registerProjectHelper(projectHelper);
                 }
             }
 
             InputStream systemResource =
                 ClassLoader.getSystemResourceAsStream(ProjectHelper.SERVICE_ID);
             if (systemResource != null) {
                 projectHelper = getProjectHelperByService(systemResource);
                 registerProjectHelper(projectHelper);
             }
         } catch (Exception e) {
             System.err.println("Unable to load ProjectHelper from service "
                                + ProjectHelper.SERVICE_ID + " ("
                                + e.getClass().getName()
                                + ": " + e.getMessage() + ")");
             if (DEBUG) {
                 e.printStackTrace(System.err);
             }
         }
     }
 
     /**
      * Register the specified project helper into the repository.
      * <p>
      * The helper will be added after all the already registered helpers, but
      * before the default one (ProjectHelper2)
      *
      * @param helperClassName
      *            the fully qualified name of the helper
      * @throws BuildException
      *             if the class cannot be loaded or if there is no constructor
      *             with no argument
      * @since Ant 1.8.2
      */
     public void registerProjectHelper(String helperClassName)
             throws BuildException {
         registerProjectHelper(getHelperConstructor(helperClassName));
     }
 
     /**
      * Register the specified project helper into the repository.
      * <p>
      * The helper will be added after all the already registered helpers, but
      * before the default one (ProjectHelper2)
      *
      * @param helperClass
      *            the class of the helper
      * @throws BuildException
      *             if there is no constructor with no argument
      * @since Ant 1.8.2
      */
     public void registerProjectHelper(Class<? extends ProjectHelper> helperClass) throws BuildException {
         try {
             registerProjectHelper(helperClass.getConstructor());
         } catch (NoSuchMethodException e) {
             throw new BuildException("Couldn't find no-arg constructor in "
                     + helperClass.getName());
         }
     }
 
     private void registerProjectHelper(Constructor<? extends ProjectHelper> helperConstructor) {
         if (helperConstructor == null) {
             return;
         }
         if (DEBUG) {
             System.out.println("ProjectHelper "
                     + helperConstructor.getClass().getName() + " registered.");
         }
         helpers.add(helperConstructor);
     }
 
     private Constructor<? extends ProjectHelper> getProjectHelperBySystemProperty() {
         String helperClass = System.getProperty(ProjectHelper.HELPER_PROPERTY);
         try {
             if (helperClass != null) {
                 return getHelperConstructor(helperClass);
             }
         } catch (SecurityException e) {
             System.err.println("Unable to load ProjectHelper class \""
                                + helperClass + " specified in system property "
                                + ProjectHelper.HELPER_PROPERTY + " ("
                                + e.getMessage() + ")");
             if (DEBUG) {
                 e.printStackTrace(System.err);
             }
         }
         return null;
     }
 
     private Constructor<? extends ProjectHelper> getProjectHelperByService(InputStream is) {
         try {
             // This code is needed by EBCDIC and other strange systems.
             // It's a fix for bugs reported in xerces
             InputStreamReader isr;
             try {
                 isr = new InputStreamReader(is, "UTF-8");
             } catch (java.io.UnsupportedEncodingException e) {
                 isr = new InputStreamReader(is);
             }
             BufferedReader rd = new BufferedReader(isr);
 
             String helperClassName = rd.readLine();
             rd.close();
 
             if (helperClassName != null && !"".equals(helperClassName)) {
                 return getHelperConstructor(helperClassName);
             }
         } catch (Exception e) {
             System.out.println("Unable to load ProjectHelper from service "
                     + ProjectHelper.SERVICE_ID + " (" + e.getMessage() + ")");
             if (DEBUG) {
                 e.printStackTrace(System.err);
             }
         }
         return null;
     }
 
     /**
      * Get the constructor with not argument of an helper from its class name.
      * It'll first try the thread class loader, then Class.forName() will load
      * from the same loader that loaded this class.
      *
      * @param helperClass
      *            The name of the class to create an instance of. Must not be
      *            <code>null</code>.
      *
      * @return the constructor of the specified class.
      *
      * @exception BuildException
      *                if the class cannot be found or if a constructor with no
      *                argument cannot be found.
      */
     private Constructor<? extends ProjectHelper> getHelperConstructor(String helperClass) throws BuildException {
         ClassLoader classLoader = LoaderUtils.getContextClassLoader();
         try {
             Class<?> clazz = null;
             if (classLoader != null) {
                 try {
                     clazz = classLoader.loadClass(helperClass);
                 } catch (ClassNotFoundException ex) {
                     // try next method
                 }
             }
             if (clazz == null) {
                 clazz = Class.forName(helperClass);
             }
             return clazz.asSubclass(ProjectHelper.class).getConstructor();
         } catch (Exception e) {
             throw new BuildException(e);
         }
     }
 
     /**
      * Get the helper that will be able to parse the specified build file. The helper
      * will be chosen among the ones found in the classpath
      *
      * @return the first ProjectHelper that fit the requirement (never <code>null</code>).
      */
     public ProjectHelper getProjectHelperForBuildFile(Resource buildFile) throws BuildException {
         for (Iterator<ProjectHelper> it = getHelpers(); it.hasNext();) {
             ProjectHelper helper = it.next();
             if (helper.canParseBuildFile(buildFile)) {
                 if (DEBUG) {
                     System.out.println("ProjectHelper "
                                        + helper.getClass().getName()
                                        + " selected for the build file "
                                        + buildFile);
                 }
                 return helper;
             }
         }
         throw new RuntimeException("BUG: at least the ProjectHelper2 should "
                                    + "have supported the file " + buildFile);
     }
 
     /**
      * Get the helper that will be able to parse the specified antlib. The helper
      * will be chosen among the ones found in the classpath
      *
      * @return the first ProjectHelper that fit the requirement (never <code>null</code>).
      */
     public ProjectHelper getProjectHelperForAntlib(Resource antlib) throws BuildException {
         for (Iterator<ProjectHelper> it = getHelpers(); it.hasNext();) {
             ProjectHelper helper = it.next();
             if (helper.canParseAntlibDescriptor(antlib)) {
                 if (DEBUG) {
                     System.out.println("ProjectHelper "
                                        + helper.getClass().getName()
                                        + " selected for the antlib "
                                        + antlib);
                 }
                 return helper;
             }
         }
         throw new RuntimeException("BUG: at least the ProjectHelper2 should "
                                    + "have supported the file " + antlib);
     }
 
     /**
      * Get an iterator on the list of project helpers configured. The iterator
      * will always return at least one element as there will always be the
      * default project helper configured.
      *
      * @return an iterator of {@link ProjectHelper}
      */
     public Iterator<ProjectHelper> getHelpers() {
         return new ConstructingIterator(helpers.iterator());
     }
 
     private static class ConstructingIterator implements Iterator<ProjectHelper> {
         private final Iterator<Constructor<? extends ProjectHelper>> nested;
         private boolean empty = false;
 
         ConstructingIterator(Iterator<Constructor<? extends ProjectHelper>> nested) {
             this.nested = nested;
         }
 
         public boolean hasNext() {
             return nested.hasNext() || !empty;
         }
 
         public ProjectHelper next() {
             Constructor<? extends ProjectHelper> c;
             if (nested.hasNext()) {
                 c = nested.next();
             } else {
                 // last but not least, ant default project helper
                 empty = true;
                 c = PROJECTHELPER2_CONSTRUCTOR;
             }
             try {
                 return c.newInstance();
             } catch (Exception e) {
                 throw new BuildException("Failed to invoke no-arg constructor"
                                          + " on " + c.getName());
             }
         }
 
         public void remove() {
             throw new UnsupportedOperationException("remove is not supported");
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/helper/ProjectHelper2.java b/src/main/org/apache/tools/ant/helper/ProjectHelper2.java
index dc19512b1..fa48f03a2 100644
--- a/src/main/org/apache/tools/ant/helper/ProjectHelper2.java
+++ b/src/main/org/apache/tools/ant/helper/ProjectHelper2.java
@@ -1,1235 +1,1238 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 package org.apache.tools.ant.helper;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.ExtensionPoint;
 import org.apache.tools.ant.Location;
 import org.apache.tools.ant.MagicNames;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.ProjectHelper;
 import org.apache.tools.ant.RuntimeConfigurable;
 import org.apache.tools.ant.Target;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.UnknownElement;
 import org.apache.tools.ant.types.Resource;
 import org.apache.tools.ant.types.resources.FileProvider;
 import org.apache.tools.ant.types.resources.URLProvider;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.JAXPUtils;
 import org.apache.tools.zip.ZipFile;
 import org.xml.sax.Attributes;
 import org.xml.sax.InputSource;
 import org.xml.sax.Locator;
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXParseException;
 import org.xml.sax.XMLReader;
 import org.xml.sax.helpers.DefaultHandler;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.UnsupportedEncodingException;
 import java.net.URL;
+import java.net.URLConnection;
 import java.util.HashMap;
 import java.util.Hashtable;
 import java.util.Map;
 import java.util.Stack;
 
 /**
  * Sax2 based project reader
  *
  */
 public class ProjectHelper2 extends ProjectHelper {
 
     /** Reference holding the (ordered) target Vector */
     public static final String REFID_TARGETS = "ant.targets";
 
     /* Stateless */
 
     // singletons - since all state is in the context
     private static AntHandler elementHandler = new ElementHandler();
     private static AntHandler targetHandler = new TargetHandler();
     private static AntHandler mainHandler = new MainHandler();
     private static AntHandler projectHandler = new ProjectHandler();
 
     /** Specific to ProjectHelper2 so not a true Ant "magic name:" */
     private static final String REFID_CONTEXT = "ant.parsing.context";
 
     /**
      * helper for path -> URI and URI -> path conversions.
      */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     /**
      * Whether this instance of ProjectHelper can parse an Antlib
      * descriptor given by the URL and return its content as an
      * UnknownElement ready to be turned into an Antlib task.
      *
      * <p>This implementation returns true.</p>
      *
      * @since Ant 1.8.0
      */
     public boolean canParseAntlibDescriptor(Resource resource) {
         return true;
     }
 
     /**
      * Parse the given URL as an antlib descriptor and return the
      * content as something that can be turned into an Antlib task.
      *
      * <p>simply delegates to {@link #parseUnknownElement
      * parseUnknownElement} if the resource provides an URL and throws
      * an exception otherwise.</p>
      *
      * @since Ant 1.8.0
      */
     public UnknownElement parseAntlibDescriptor(Project containingProject,
                                                 Resource resource) {
         URLProvider up = resource.as(URLProvider.class);
         if (up == null) {
             throw new BuildException("Unsupported resource type: " + resource);
         }
         return parseUnknownElement(containingProject, up.getURL());
     }
 
     /**
      * Parse an unknown element from a url
      *
      * @param project the current project
      * @param source  the url containing the task
      * @return a configured task
      * @exception BuildException if an error occurs
      */
     public UnknownElement parseUnknownElement(Project project, URL source)
         throws BuildException {
         Target dummyTarget = new Target();
         dummyTarget.setProject(project);
 
         AntXMLContext context = new AntXMLContext(project);
         context.addTarget(dummyTarget);
         context.setImplicitTarget(dummyTarget);
 
         parse(context.getProject(), source, new RootHandler(context, elementHandler));
         Task[] tasks = dummyTarget.getTasks();
         if (tasks.length != 1) {
             throw new BuildException("No tasks defined");
         }
         return (UnknownElement) tasks[0];
     }
 
     /**
      * Parse a source xml input.
      *
      * @param project the current project
      * @param source  the xml source
      * @exception BuildException if an error occurs
      */
     public void parse(Project project, Object source) throws BuildException {
         getImportStack().addElement(source);
         AntXMLContext context = null;
         context = (AntXMLContext) project.getReference(REFID_CONTEXT);
         if (context == null) {
             context = new AntXMLContext(project);
             project.addReference(REFID_CONTEXT, context);
             project.addReference(REFID_TARGETS, context.getTargets());
         }
         if (getImportStack().size() > 1) {
             // we are in an imported file.
             context.setIgnoreProjectTag(true);
             Target currentTarget = context.getCurrentTarget();
             Target currentImplicit = context.getImplicitTarget();
             Map<String, Target>    currentTargets = context.getCurrentTargets();
             try {
                 Target newCurrent = new Target();
                 newCurrent.setProject(project);
                 newCurrent.setName("");
                 context.setCurrentTarget(newCurrent);
                 context.setCurrentTargets(new HashMap<String, Target>());
                 context.setImplicitTarget(newCurrent);
                 parse(project, source, new RootHandler(context, mainHandler));
                 newCurrent.execute();
             } finally {
                 context.setCurrentTarget(currentTarget);
                 context.setImplicitTarget(currentImplicit);
                 context.setCurrentTargets(currentTargets);
             }
         } else {
             // top level file
             context.setCurrentTargets(new HashMap<String, Target>());
             parse(project, source, new RootHandler(context, mainHandler));
             // Execute the top-level target
             context.getImplicitTarget().execute();
 
             // resolve extensionOf attributes
             resolveExtensionOfAttributes(project);
         }
     }
 
     /**
      * Parses the project file, configuring the project as it goes.
      *
      * @param project the current project
      * @param source  the xml source
      * @param handler the root handler to use (contains the current context)
      * @exception BuildException if the configuration is invalid or cannot
      *                           be read
      */
     public void parse(Project project, Object source, RootHandler handler) throws BuildException {
 
         AntXMLContext context = handler.context;
 
         File buildFile = null;
         URL  url = null;
         String buildFileName = null;
 
         if (source instanceof File) {
             buildFile = (File) source;
         } else if (source instanceof URL) {
             url = (URL) source;
         } else if (source instanceof Resource) {
             FileProvider fp =
                 ((Resource) source).as(FileProvider.class);
             if (fp != null) {
                 buildFile = fp.getFile();
             } else {
                 URLProvider up =
                     ((Resource) source).as(URLProvider.class);
                 if (up != null) {
                     url = up.getURL();
                 }
             }
         }
         if (buildFile != null) {
             buildFile = FILE_UTILS.normalize(buildFile.getAbsolutePath());
             context.setBuildFile(buildFile);
             buildFileName = buildFile.toString();
         } else if (url != null) {
             try {
                 context.setBuildFile((File) null);
                 context.setBuildFile(url);
             } catch (java.net.MalformedURLException ex) {
                 throw new BuildException(ex);
             }
             buildFileName = url.toString();
         } else {
             throw new BuildException("Source " + source.getClass().getName()
                                      + " not supported by this plugin");
         }
         InputStream inputStream = null;
         InputSource inputSource = null;
         ZipFile zf = null;
 
         try {
             /**
              * SAX 2 style parser used to parse the given file.
              */
             XMLReader parser = JAXPUtils.getNamespaceXMLReader();
 
             String uri = null;
             if (buildFile != null) {
                 uri = FILE_UTILS.toURI(buildFile.getAbsolutePath());
                 inputStream = new FileInputStream(buildFile);
             } else {
                 uri = url.toString();
                 int pling = -1;
                 if (uri.startsWith("jar:file")
                     && (pling = uri.indexOf("!/")) > -1) {
                     zf = new ZipFile(org.apache.tools.ant.launch.Locator
                                      .fromJarURI(uri), "UTF-8");
                     inputStream =
                         zf.getInputStream(zf.getEntry(uri.substring(pling + 1)));
                 } else {
-                    inputStream = url.openStream();
+                    URLConnection conn = url.openConnection();
+                    conn.setDefaultUseCaches(false);
+                    inputStream = conn.getInputStream();
                 }
             }
 
             inputSource = new InputSource(inputStream);
             if (uri != null) {
                 inputSource.setSystemId(uri);
             }
             project.log("parsing buildfile " + buildFileName + " with URI = "
                         + uri + (zf != null ? " from a zip file" : ""),
                         Project.MSG_VERBOSE);
 
             DefaultHandler hb = handler;
 
             parser.setContentHandler(hb);
             parser.setEntityResolver(hb);
             parser.setErrorHandler(hb);
             parser.setDTDHandler(hb);
             parser.parse(inputSource);
         } catch (SAXParseException exc) {
             Location location = new Location(exc.getSystemId(), exc.getLineNumber(), exc
                                              .getColumnNumber());
 
             Throwable t = exc.getException();
             if (t instanceof BuildException) {
                 BuildException be = (BuildException) t;
                 if (be.getLocation() == Location.UNKNOWN_LOCATION) {
                     be.setLocation(location);
                 }
                 throw be;
             }
             throw new BuildException(exc.getMessage(), t == null ? exc : t, location);
         } catch (SAXException exc) {
             Throwable t = exc.getException();
             if (t instanceof BuildException) {
                 throw (BuildException) t;
             }
             throw new BuildException(exc.getMessage(), t == null ? exc : t);
         } catch (FileNotFoundException exc) {
             throw new BuildException(exc);
         } catch (UnsupportedEncodingException exc) {
             throw new BuildException("Encoding of project file " + buildFileName + " is invalid.",
                                      exc);
         } catch (IOException exc) {
             throw new BuildException("Error reading project file " + buildFileName + ": "
                                      + exc.getMessage(), exc);
         } finally {
             FileUtils.close(inputStream);
             ZipFile.closeQuietly(zf);
         }
     }
 
     /**
      * Returns main handler
      * @return main handler
      */
     protected static AntHandler getMainHandler() {
         return mainHandler;
     }
 
     /**
      * Sets main handler
      * @param handler  new main handler
      */
     protected static void setMainHandler(AntHandler handler) {
         mainHandler = handler;
     }
 
     /**
      * Returns project handler
      * @return project handler
      */
     protected static AntHandler getProjectHandler() {
         return projectHandler;
     }
 
     /**
      * Sets project handler
      * @param handler  new project handler
      */
     protected static void setProjectHandler(AntHandler handler) {
         projectHandler = handler;
     }
 
     /**
      * Returns target handler
      * @return target handler
      */
     protected static AntHandler getTargetHandler() {
         return targetHandler;
     }
 
     /**
      * Sets target handler
      * @param handler  new target handler
      */
     protected static void setTargetHandler(AntHandler handler) {
         targetHandler = handler;
     }
 
     /**
      * Returns element handler
      * @return element handler
      */
     protected static AntHandler getElementHandler() {
         return elementHandler;
     }
 
     /**
      * Sets element handler
      * @param handler  new element handler
      */
     protected static void setElementHandler(AntHandler handler) {
         elementHandler = handler;
     }
 
     /**
      * The common superclass for all SAX event handlers used to parse
      * the configuration file.
      *
      * The context will hold all state information. At each time
      * there is one active handler for the current element. It can
      * use onStartChild() to set an alternate handler for the child.
      */
     public static class AntHandler  {
         /**
          * Handles the start of an element. This base implementation does
          * nothing.
          *
          * @param uri the namespace URI for the tag
          * @param tag The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name of the element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The context that this element is in.
          *
          * @exception SAXParseException if this method is not overridden, or in
          *                              case of error in an overridden version
          */
         public void onStartElement(String uri, String tag, String qname, Attributes attrs,
                                    AntXMLContext context) throws SAXParseException {
         }
 
         /**
          * Handles the start of an element. This base implementation just
          * throws an exception - you must override this method if you expect
          * child elements.
          *
          * @param uri The namespace uri for this element.
          * @param tag The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The current context.
          * @return a handler (in the derived classes)
          *
          * @exception SAXParseException if this method is not overridden, or in
          *                              case of error in an overridden version
          */
         public AntHandler onStartChild(String uri, String tag, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             throw new SAXParseException("Unexpected element \"" + qname + " \"", context
                                         .getLocator());
         }
 
         /**
          * Handle the end of a element.
          *
          * @param uri the namespace uri of the element
          * @param tag the tag of the element
          * @param qname the qualified name of the element
          * @param context the current context
          * @exception SAXParseException if an error occurs
          */
         public void onEndChild(String uri, String tag, String qname, AntXMLContext context)
             throws SAXParseException {
         }
 
         /**
          * This method is called when this element and all elements nested into it have been
          * handled. I.e., this happens at the &lt;/end_tag_of_the_element&gt;.
          * @param uri the namespace uri for this element
          * @param tag the element name
          * @param context the current context
          */
         public void onEndElement(String uri, String tag, AntXMLContext context) {
         }
 
         /**
          * Handles text within an element. This base implementation just
          * throws an exception, you must override it if you expect content.
          *
          * @param buf A character array of the text within the element.
          *            Will not be <code>null</code>.
          * @param start The start element in the array.
          * @param count The number of characters to read from the array.
          * @param context The current context.
          *
          * @exception SAXParseException if this method is not overridden, or in
          *                              case of error in an overridden version
          */
         public void characters(char[] buf, int start, int count, AntXMLContext context)
             throws SAXParseException {
             String s = new String(buf, start, count).trim();
 
             if (s.length() > 0) {
                 throw new SAXParseException("Unexpected text \"" + s + "\"", context.getLocator());
             }
         }
 
         /**
          * Will be called every time a namespace is reached.
          * It'll verify if the ns was processed, and if not load the task definitions.
          * @param uri The namespace uri.
          */
         protected void checkNamespace(String uri) {
         }
     }
 
     /**
      * Handler for ant processing. Uses a stack of AntHandlers to
      * implement each element ( the original parser used a recursive behavior,
      * with the implicit execution stack )
      */
     public static class RootHandler extends DefaultHandler {
         private Stack<AntHandler> antHandlers = new Stack<AntHandler>();
         private AntHandler currentHandler = null;
         private AntXMLContext context;
 
         /**
          * Creates a new RootHandler instance.
          *
          * @param context The context for the handler.
          * @param rootHandler The handler for the root element.
          */
         public RootHandler(AntXMLContext context, AntHandler rootHandler) {
             currentHandler = rootHandler;
             antHandlers.push(currentHandler);
             this.context = context;
         }
 
         /**
          * Returns the current ant handler object.
          * @return the current ant handler.
          */
         public AntHandler getCurrentAntHandler() {
             return currentHandler;
         }
 
         /**
          * Resolves file: URIs relative to the build file.
          *
          * @param publicId The public identifier, or <code>null</code>
          *                 if none is available. Ignored in this
          *                 implementation.
          * @param systemId The system identifier provided in the XML
          *                 document. Will not be <code>null</code>.
          * @return an inputsource for this identifier
          */
         public InputSource resolveEntity(String publicId, String systemId) {
 
             context.getProject().log("resolving systemId: " + systemId, Project.MSG_VERBOSE);
 
             if (systemId.startsWith("file:")) {
                 String path = FILE_UTILS.fromURI(systemId);
 
                 File file = new File(path);
                 if (!file.isAbsolute()) {
                     file = FILE_UTILS.resolveFile(context.getBuildFileParent(), path);
                     context.getProject().log(
                                              "Warning: '" + systemId + "' in " + context.getBuildFile()
                                              + " should be expressed simply as '" + path.replace('\\', '/')
                                              + "' for compliance with other XML tools", Project.MSG_WARN);
                 }
                 context.getProject().log("file=" + file, Project.MSG_DEBUG);
                 try {
                     InputSource inputSource = new InputSource(new FileInputStream(file));
                     inputSource.setSystemId(FILE_UTILS.toURI(file.getAbsolutePath()));
                     return inputSource;
                 } catch (FileNotFoundException fne) {
                     context.getProject().log(file.getAbsolutePath() + " could not be found",
                                              Project.MSG_WARN);
                 }
 
             }
             // use default if not file or file not found
             context.getProject().log("could not resolve systemId", Project.MSG_DEBUG);
             return null;
         }
 
         /**
          * Handles the start of a project element. A project handler is created
          * and initialised with the element name and attributes.
          *
          * @param uri The namespace uri for this element.
          * @param tag The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          *
          * @exception org.xml.sax.SAXParseException if the tag given is not
          *                              <code>"project"</code>
          */
         public void startElement(String uri, String tag, String qname, Attributes attrs)
             throws SAXParseException {
             AntHandler next = currentHandler.onStartChild(uri, tag, qname, attrs, context);
             antHandlers.push(currentHandler);
             currentHandler = next;
             currentHandler.onStartElement(uri, tag, qname, attrs, context);
         }
 
         /**
          * Sets the locator in the project helper for future reference.
          *
          * @param locator The locator used by the parser.
          *                Will not be <code>null</code>.
          */
         public void setDocumentLocator(Locator locator) {
             context.setLocator(locator);
         }
 
         /**
          * Handles the end of an element. Any required clean-up is performed
          * by the onEndElement() method and then the original handler is restored to the parser.
          *
          * @param uri  The namespace URI for this element.
          * @param name The name of the element which is ending.
          *             Will not be <code>null</code>.
          * @param qName The qualified name for this element.
          *
          * @exception SAXException in case of error (not thrown in this implementation)
          */
         public void endElement(String uri, String name, String qName) throws SAXException {
             currentHandler.onEndElement(uri, name, context);
             AntHandler prev = (AntHandler) antHandlers.pop();
             currentHandler = prev;
             if (currentHandler != null) {
                 currentHandler.onEndChild(uri, name, qName, context);
             }
         }
 
         /**
          * Handle text within an element, calls currentHandler.characters.
          *
          * @param buf  A character array of the test.
          * @param start The start offset in the array.
          * @param count The number of characters to read.
          * @exception SAXParseException if an error occurs
          */
         public void characters(char[] buf, int start, int count) throws SAXParseException {
             currentHandler.characters(buf, start, count, context);
         }
 
         /**
          * Start a namespace prefix to uri mapping
          *
          * @param prefix the namespace prefix
          * @param uri the namespace uri
          */
         public void startPrefixMapping(String prefix, String uri) {
             context.startPrefixMapping(prefix, uri);
         }
 
         /**
          * End a namespace prefix to uri mapping
          *
          * @param prefix the prefix that is not mapped anymore
          */
         public void endPrefixMapping(String prefix) {
             context.endPrefixMapping(prefix);
         }
     }
 
     /**
      * The main handler - it handles the &lt;project&gt; tag.
      *
      * @see org.apache.tools.ant.helper.ProjectHelper2.AntHandler
      */
     public static class MainHandler extends AntHandler {
 
         /**
          * Handle the project tag
          *
          * @param uri The namespace uri.
          * @param name The element tag.
          * @param qname The element qualified name.
          * @param attrs The attributes of the element.
          * @param context The current context.
          * @return The project handler that handles subelements of project
          * @exception SAXParseException if the qualified name is not "project".
          */
         public AntHandler onStartChild(String uri, String name, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             if (name.equals("project")
                 && (uri.equals("") || uri.equals(ANT_CORE_URI))) {
                 return ProjectHelper2.projectHandler;
             }
             if (name.equals(qname)) {
                 throw new SAXParseException("Unexpected element \"{" + uri
                                             + "}" + name + "\" {" + ANT_CORE_URI + "}" + name, context.getLocator());
             }
             throw new SAXParseException("Unexpected element \"" + qname
                                         + "\" " + name, context.getLocator());
         }
     }
 
     /**
      * Handler for the top level "project" element.
      */
     public static class ProjectHandler extends AntHandler {
 
         /**
          * Initialisation routine called after handler creation
          * with the element name and attributes. The attributes which
          * this handler can deal with are: <code>"default"</code>,
          * <code>"name"</code>, <code>"id"</code> and <code>"basedir"</code>.
          *
          * @param uri The namespace URI for this element.
          * @param tag Name of the element which caused this handler
          *            to be created. Should not be <code>null</code>.
          *            Ignored in this implementation.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element which caused this
          *              handler to be created. Must not be <code>null</code>.
          * @param context The current context.
          *
          * @exception SAXParseException if an unexpected attribute is
          *            encountered or if the <code>"default"</code> attribute
          *            is missing.
          */
         public void onStartElement(String uri, String tag, String qname, Attributes attrs,
                                    AntXMLContext context) throws SAXParseException {
             String baseDir = null;
             boolean nameAttributeSet = false;
 
             Project project = context.getProject();
             // Set the location of the implicit target associated with the project tag
             context.getImplicitTarget().setLocation(new Location(context.getLocator()));
 
             /** TODO I really don't like this - the XML processor is still
              * too 'involved' in the processing. A better solution (IMO)
              * would be to create UE for Project and Target too, and
              * then process the tree and have Project/Target deal with
              * its attributes ( similar with Description ).
              *
              * If we eventually switch to ( or add support for ) DOM,
              * things will work smoothly - UE can be avoided almost completely
              * ( it could still be created on demand, for backward compatibility )
              */
 
             for (int i = 0; i < attrs.getLength(); i++) {
                 String attrUri = attrs.getURI(i);
                 if (attrUri != null && !attrUri.equals("") && !attrUri.equals(uri)) {
                     continue; // Ignore attributes from unknown uris
                 }
                 String key = attrs.getLocalName(i);
                 String value = attrs.getValue(i);
 
                 if (key.equals("default")) {
                     if (value != null && !value.equals("")) {
                         if (!context.isIgnoringProjectTag()) {
                             project.setDefault(value);
                         }
                     }
                 } else if (key.equals("name")) {
                     if (value != null) {
                         context.setCurrentProjectName(value);
                         nameAttributeSet = true;
                         if (!context.isIgnoringProjectTag()) {
                             project.setName(value);
                             project.addReference(value, project);
                         } else if (isInIncludeMode()) {
                             if (!"".equals(value) && getCurrentTargetPrefix()!= null && getCurrentTargetPrefix().endsWith(ProjectHelper.USE_PROJECT_NAME_AS_TARGET_PREFIX))  {
                                 String newTargetPrefix = getCurrentTargetPrefix().replace(ProjectHelper.USE_PROJECT_NAME_AS_TARGET_PREFIX, value);
                                 // help nested include tasks
                                 setCurrentTargetPrefix(newTargetPrefix);
                             }
                         }
                     }
                 } else if (key.equals("id")) {
                     if (value != null) {
                         // What's the difference between id and name ?
                         if (!context.isIgnoringProjectTag()) {
                             project.addReference(value, project);
                         }
                     }
                 } else if (key.equals("basedir")) {
                     if (!context.isIgnoringProjectTag()) {
                         baseDir = value;
                     }
                 } else {
                     // TODO ignore attributes in a different NS ( maybe store them ? )
                     throw new SAXParseException("Unexpected attribute \"" + attrs.getQName(i)
                                                 + "\"", context.getLocator());
                 }
             }
 
             // TODO Move to Project ( so it is shared by all helpers )
             String antFileProp =
                 MagicNames.ANT_FILE + "." + context.getCurrentProjectName();
             String dup = project.getProperty(antFileProp);
             String typeProp =
                 MagicNames.ANT_FILE_TYPE + "." + context.getCurrentProjectName();
             String dupType = project.getProperty(typeProp);
             if (dup != null && nameAttributeSet) {
                 Object dupFile = null;
                 Object contextFile = null;
                 if (MagicNames.ANT_FILE_TYPE_URL.equals(dupType)) {
                     try {
                         dupFile = new URL(dup);
                     } catch (java.net.MalformedURLException mue) {
                         throw new BuildException("failed to parse "
                                                  + dup + " as URL while looking"
                                                  + " at a duplicate project"
                                                  + " name.", mue);
                     }
                     contextFile = context.getBuildFileURL();
                 } else {
                     dupFile = new File(dup);
                     contextFile = context.getBuildFile();
                 }
 
                 if (context.isIgnoringProjectTag() && !dupFile.equals(contextFile)) {
                     project.log("Duplicated project name in import. Project "
                                 + context.getCurrentProjectName() + " defined first in " + dup
                                 + " and again in " + contextFile, Project.MSG_WARN);
                 }
             }
             if (nameAttributeSet) {
                 if (context.getBuildFile() != null) {
                     project.setUserProperty(antFileProp,
                                             context.getBuildFile().toString());
                     project.setUserProperty(typeProp,
                                             MagicNames.ANT_FILE_TYPE_FILE);
                 } else if (context.getBuildFileURL() != null) {
                     project.setUserProperty(antFileProp,
                                             context.getBuildFileURL().toString());
                     project.setUserProperty(typeProp,
                                             MagicNames.ANT_FILE_TYPE_URL);
                 }
             }
             if (context.isIgnoringProjectTag()) {
                 // no further processing
                 return;
             }
             // set explicitly before starting ?
             if (project.getProperty("basedir") != null) {
                 project.setBasedir(project.getProperty("basedir"));
             } else {
                 // Default for baseDir is the location of the build file.
                 if (baseDir == null) {
                     project.setBasedir(context.getBuildFileParent().getAbsolutePath());
                 } else {
                     // check whether the user has specified an absolute path
                     if ((new File(baseDir)).isAbsolute()) {
                         project.setBasedir(baseDir);
                     } else {
                         project.setBaseDir(FILE_UTILS.resolveFile(context.getBuildFileParent(),
                                                                   baseDir));
                     }
                 }
             }
             project.addTarget("", context.getImplicitTarget());
             context.setCurrentTarget(context.getImplicitTarget());
         }
 
         /**
          * Handles the start of a top-level element within the project. An
          * appropriate handler is created and initialised with the details
          * of the element.
          *
          * @param uri The namespace URI for this element.
          * @param name The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The context for this element.
          * @return a target or an element handler.
          *
          * @exception org.xml.sax.SAXParseException if the tag given is not
          *            <code>"taskdef"</code>, <code>"typedef"</code>,
          *            <code>"property"</code>, <code>"target"</code>,
          *            <code>"extension-point"</code>
          *            or a data type definition
          */
         public AntHandler onStartChild(String uri, String name, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             return (name.equals("target") || name.equals("extension-point"))
                 && (uri.equals("") || uri.equals(ANT_CORE_URI))
                 ? ProjectHelper2.targetHandler : ProjectHelper2.elementHandler;
         }
     }
 
     /**
      * Handler for "target" and "extension-point" elements.
      */
     public static class TargetHandler extends AntHandler {
 
         /**
          * Initialisation routine called after handler creation
          * with the element name and attributes. The attributes which
          * this handler can deal with are: <code>"name"</code>,
          * <code>"depends"</code>, <code>"if"</code>,
          * <code>"unless"</code>, <code>"id"</code> and
          * <code>"description"</code>.
          *
          * @param uri The namespace URI for this element.
          * @param tag Name of the element which caused this handler
          *            to be created. Should not be <code>null</code>.
          *            Ignored in this implementation.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element which caused this
          *              handler to be created. Must not be <code>null</code>.
          * @param context The current context.
          *
          * @exception SAXParseException if an unexpected attribute is encountered
          *            or if the <code>"name"</code> attribute is missing.
          */
         public void onStartElement(String uri, String tag, String qname, Attributes attrs,
                                    AntXMLContext context) throws SAXParseException {
             String name = null;
             String depends = "";
             String extensionPoint = null;
             OnMissingExtensionPoint extensionPointMissing = null;
 
             Project project = context.getProject();
             Target target = "target".equals(tag)
                 ? new Target() : new ExtensionPoint();
             target.setProject(project);
             target.setLocation(new Location(context.getLocator()));
             context.addTarget(target);
 
             for (int i = 0; i < attrs.getLength(); i++) {
                 String attrUri = attrs.getURI(i);
                 if (attrUri != null && !attrUri.equals("") && !attrUri.equals(uri)) {
                     continue; // Ignore attributes from unknown uris
                 }
                 String key = attrs.getLocalName(i);
                 String value = attrs.getValue(i);
 
                 if (key.equals("name")) {
                     name = value;
                     if ("".equals(name)) {
                         throw new BuildException("name attribute must " + "not be empty");
                     }
                 } else if (key.equals("depends")) {
                     depends = value;
                 } else if (key.equals("if")) {
                     target.setIf(value);
                 } else if (key.equals("unless")) {
                     target.setUnless(value);
                 } else if (key.equals("id")) {
                     if (value != null && !value.equals("")) {
                         context.getProject().addReference(value, target);
                     }
                 } else if (key.equals("description")) {
                     target.setDescription(value);
                 } else if (key.equals("extensionOf")) {
                     extensionPoint = value;
                 } else if (key.equals("onMissingExtensionPoint")) {
                     try {
                         extensionPointMissing = OnMissingExtensionPoint.valueOf(value);
                     } catch (IllegalArgumentException e) {
                         throw new BuildException("Invalid onMissingExtensionPoint " + value);
                     }
                 } else {
                     throw new SAXParseException("Unexpected attribute \"" + key + "\"", context
                                                 .getLocator());
                 }
             }
 
             if (name == null) {
                 throw new SAXParseException("target element appears without a name attribute",
                                             context.getLocator());
             }
 
             String prefix = null;
             boolean isInIncludeMode =
                 context.isIgnoringProjectTag() && isInIncludeMode();
             String sep = getCurrentPrefixSeparator();
 
             if (isInIncludeMode) {
                 prefix = getTargetPrefix(context);
                 if (prefix == null) {
                     throw new BuildException("can't include build file "
                                              + context.getBuildFileURL()
                                              + ", no as attribute has been given"
                                              + " and the project tag doesn't"
                                              + " specify a name attribute");
                 }
                 name = prefix + sep + name;
             }
 
             // Check if this target is in the current build file
             if (context.getCurrentTargets().get(name) != null) {
                 throw new BuildException("Duplicate target '" + name + "'",
                                          target.getLocation());
             }
             Hashtable<String, Target> projectTargets = project.getTargets();
             boolean   usedTarget = false;
             // If the name has not already been defined define it
             if (projectTargets.containsKey(name)) {
                 project.log("Already defined in main or a previous import, ignore " + name,
                             Project.MSG_VERBOSE);
             } else {
                 target.setName(name);
                 context.getCurrentTargets().put(name, target);
                 project.addOrReplaceTarget(name, target);
                 usedTarget = true;
             }
 
             if (depends.length() > 0) {
                 if (!isInIncludeMode) {
                     target.setDepends(depends);
                 } else {
                     for (String string : Target.parseDepends(depends, name, "depends")) {
                         target.addDependency(prefix + sep + string);
                    }
                 }
             }
             if (!isInIncludeMode && context.isIgnoringProjectTag()
                 && (prefix = getTargetPrefix(context)) != null) {
                 // In an imported file (and not completely
                 // ignoring the project tag or having a preconfigured prefix)
                 String newName = prefix + sep + name;
                 Target newTarget = target;
                 if (usedTarget) {
                     newTarget = "target".equals(tag)
                             ? new Target(target) : new ExtensionPoint(target);
                 }
                 newTarget.setName(newName);
                 context.getCurrentTargets().put(newName, newTarget);
                 project.addOrReplaceTarget(newName, newTarget);
             }
             if (extensionPointMissing != null && extensionPoint == null) {
                 throw new BuildException("onMissingExtensionPoint attribute cannot " +
                                          "be specified unless extensionOf is specified",
                                          target.getLocation());
 
             }
             if (extensionPoint != null) {
                 ProjectHelper helper =
                     (ProjectHelper) context.getProject().
                     getReference(ProjectHelper.PROJECTHELPER_REFERENCE);
                 for (String extPointName : Target.parseDepends(extensionPoint, name, "extensionOf")) {
                     if (extensionPointMissing == null) {
                         extensionPointMissing = OnMissingExtensionPoint.FAIL;
                     }
                     // defer extensionpoint resolution until the full
                     // import stack has been processed
                     if (isInIncludeMode()) {
                         // if in include mode, provide prefix we're including by
                         // so that we can try and resolve extension point from
                         // the local file first
                         helper.getExtensionStack().add(
                                 new String[] {extPointName, target.getName(),
                                         extensionPointMissing.name(), prefix + sep});
                     } else {
                         helper.getExtensionStack().add(
                                 new String[] {extPointName, target.getName(),
                                         extensionPointMissing.name()});
                     }
                 }
             }
         }
 
         private String getTargetPrefix(AntXMLContext context) {
             String configuredValue = getCurrentTargetPrefix();
             if (configuredValue != null && configuredValue.length() == 0) {
                 configuredValue = null;
             }
             if (configuredValue != null) {
                 return configuredValue;
             }
 
             String projectName = context.getCurrentProjectName();
             if ("".equals(projectName)) {
                 projectName = null;
             }
 
             return projectName;
         }
 
         /**
          * Handles the start of an element within a target.
          *
          * @param uri The namespace URI for this element.
          * @param name The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The current context.
          * @return an element handler.
          *
          * @exception SAXParseException if an error occurs when initialising
          *                              the appropriate child handler
          */
         public AntHandler onStartChild(String uri, String name, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             return ProjectHelper2.elementHandler;
         }
 
         /**
          * Handle the end of the project, sets the current target of the
          * context to be the implicit target.
          *
          * @param uri The namespace URI of the element.
          * @param tag The name of the element.
          * @param context The current context.
          */
         public void onEndElement(String uri, String tag, AntXMLContext context) {
             context.setCurrentTarget(context.getImplicitTarget());
         }
     }
 
     /**
      * Handler for all project elements ( tasks, data types )
      */
     public static class ElementHandler extends AntHandler {
 
         /**
          * Constructor.
          */
         public ElementHandler() {
         }
 
         /**
          * Initialisation routine called after handler creation
          * with the element name and attributes. This configures
          * the element with its attributes and sets it up with
          * its parent container (if any). Nested elements are then
          * added later as the parser encounters them.
          *
          * @param uri The namespace URI for this element.
          * @param tag Name of the element which caused this handler
          *            to be created. Must not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element which caused this
          *              handler to be created. Must not be <code>null</code>.
          * @param context The current context.
          *
          * @exception SAXParseException in case of error (not thrown in
          *                              this implementation)
          */
         public void onStartElement(String uri, String tag, String qname, Attributes attrs,
                                    AntXMLContext context) throws SAXParseException {
             RuntimeConfigurable parentWrapper = context.currentWrapper();
             Object parent = null;
 
             if (parentWrapper != null) {
                 parent = parentWrapper.getProxy();
             }
 
             /* UnknownElement is used for tasks and data types - with
                delayed eval */
             UnknownElement task = new UnknownElement(tag);
             task.setProject(context.getProject());
             task.setNamespace(uri);
             task.setQName(qname);
             task.setTaskType(ProjectHelper.genComponentName(task.getNamespace(), tag));
             task.setTaskName(qname);
 
             Location location = new Location(context.getLocator().getSystemId(), context
                                              .getLocator().getLineNumber(), context.getLocator().getColumnNumber());
             task.setLocation(location);
             task.setOwningTarget(context.getCurrentTarget());
 
             if (parent != null) {
                 // Nested element
                 ((UnknownElement) parent).addChild(task);
             }  else {
                 // Task included in a target ( including the default one ).
                 context.getCurrentTarget().addTask(task);
             }
 
             context.configureId(task, attrs);
 
             // container.addTask(task);
             // This is a nop in UE: task.init();
 
             RuntimeConfigurable wrapper = new RuntimeConfigurable(task, task.getTaskName());
 
             for (int i = 0; i < attrs.getLength(); i++) {
                 String name = attrs.getLocalName(i);
                 String attrUri = attrs.getURI(i);
                 if (attrUri != null && !attrUri.equals("") && !attrUri.equals(uri)) {
                     name = attrUri + ":" + attrs.getQName(i);
                 }
                 String value = attrs.getValue(i);
                 // PR: Hack for ant-type value
                 //  an ant-type is a component name which can
                 // be namespaced, need to extract the name
                 // and convert from qualified name to uri/name
                 if (ANT_TYPE.equals(name)
                     || (ANT_CORE_URI.equals(attrUri)
                         && ANT_TYPE.equals(attrs.getLocalName(i)))) {
                     name = ANT_TYPE;
                     int index = value.indexOf(":");
                     if (index >= 0) {
                         String prefix = value.substring(0, index);
                         String mappedUri = context.getPrefixMapping(prefix);
                         if (mappedUri == null) {
                             throw new BuildException("Unable to find XML NS prefix \"" + prefix
                                                      + "\"");
                         }
                         value = ProjectHelper.genComponentName(mappedUri, value
                                                                .substring(index + 1));
                     }
                 }
                 wrapper.setAttribute(name, value);
             }
             if (parentWrapper != null) {
                 parentWrapper.addChild(wrapper);
             }
             context.pushWrapper(wrapper);
         }
 
         /**
          * Adds text to the task, using the wrapper
          *
          * @param buf A character array of the text within the element.
          *            Will not be <code>null</code>.
          * @param start The start element in the array.
          * @param count The number of characters to read from the array.
          * @param context The current context.
          *
          * @exception SAXParseException if the element doesn't support text
          *
          * @see ProjectHelper#addText(Project,java.lang.Object,char[],int,int)
          */
         public void characters(char[] buf, int start, int count,
                                AntXMLContext context) throws SAXParseException {
             RuntimeConfigurable wrapper = context.currentWrapper();
             wrapper.addText(buf, start, count);
         }
 
         /**
          * Handles the start of an element within a target. Task containers
          * will always use another task handler, and all other tasks
          * will always use a nested element handler.
          *
          * @param uri The namespace URI for this element.
          * @param tag The name of the element being started.
          *            Will not be <code>null</code>.
          * @param qname The qualified name for this element.
          * @param attrs Attributes of the element being started.
          *              Will not be <code>null</code>.
          * @param context The current context.
          * @return The handler for elements.
          *
          * @exception SAXParseException if an error occurs when initialising
          *                              the appropriate child handler
          */
         public AntHandler onStartChild(String uri, String tag, String qname, Attributes attrs,
                                        AntXMLContext context) throws SAXParseException {
             return ProjectHelper2.elementHandler;
         }
 
         /**
          * Handles the end of the element. This pops the wrapper from
          * the context.
          *
          * @param uri The namespace URI for the element.
          * @param tag The name of the element.
          * @param context The current context.
          */
         public void onEndElement(String uri, String tag, AntXMLContext context) {
             context.popWrapper();
         }
     }
 }
diff --git a/src/main/org/apache/tools/ant/taskdefs/Antlib.java b/src/main/org/apache/tools/ant/taskdefs/Antlib.java
index d4eb23f13..44aaab272 100644
--- a/src/main/org/apache/tools/ant/taskdefs/Antlib.java
+++ b/src/main/org/apache/tools/ant/taskdefs/Antlib.java
@@ -1,181 +1,184 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.taskdefs;
 
 import java.io.IOException;
 import java.net.URL;
+import java.net.URLConnection;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.ComponentHelper;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.ProjectHelper;
 import org.apache.tools.ant.ProjectHelperRepository;
 import org.apache.tools.ant.Task;
 import org.apache.tools.ant.TaskContainer;
 import org.apache.tools.ant.UnknownElement;
 import org.apache.tools.ant.types.resources.URLResource;
 
 
 /**
  * Antlib task. It does not
  * occur in an ant build file. It is the root element
  * an antlib xml file.
  *
  * @since Ant 1.6
  */
 public class Antlib extends Task implements TaskContainer {
     //
     // Static
     //
 
     /** The name of this task */
     public static final String TAG = "antlib";
 
     /**
      * Static method to read an ant lib definition from
      * a url.
      *
      * @param project   the current project
      * @param antlibUrl the url to read the definitions from
      * @param uri       the uri that the antlib is to be placed in
      * @return the ant lib task
      */
     public static Antlib createAntlib(Project project, URL antlibUrl,
                                       String uri) {
         // Check if we can contact the URL
         try {
-            antlibUrl.openConnection().connect();
+            URLConnection conn = antlibUrl.openConnection();
+            conn.setDefaultUseCaches(false);
+            conn.connect();
         } catch (IOException ex) {
             throw new BuildException(
                 "Unable to find " + antlibUrl, ex);
         }
         ComponentHelper helper =
             ComponentHelper.getComponentHelper(project);
         helper.enterAntLib(uri);
         URLResource antlibResource = new URLResource(antlibUrl);
         try {
             // Should be safe to parse
             ProjectHelper parser = null;
             Object p =
                 project.getReference(ProjectHelper.PROJECTHELPER_REFERENCE);
             if (p instanceof ProjectHelper) {
                 parser = (ProjectHelper) p;
                 if (!parser.canParseAntlibDescriptor(antlibResource)) {
                     parser = null;
                 }
             }
             if (parser == null) {
                 ProjectHelperRepository helperRepository =
                     ProjectHelperRepository.getInstance();
                 parser = helperRepository.getProjectHelperForAntlib(antlibResource);
             }
             UnknownElement ue =
                 parser.parseAntlibDescriptor(project, antlibResource);
             // Check name is "antlib"
             if (!(ue.getTag().equals(TAG))) {
                 throw new BuildException(
                     "Unexpected tag " + ue.getTag() + " expecting "
                     + TAG, ue.getLocation());
             }
             Antlib antlib = new Antlib();
             antlib.setProject(project);
             antlib.setLocation(ue.getLocation());
             antlib.setTaskName("antlib");
             antlib.init();
             ue.configure(antlib);
             return antlib;
         } finally {
             helper.exitAntLib();
         }
     }
 
     //
     // Instance
     //
     private ClassLoader classLoader;
     private String uri = "";
     private List<Object> tasks = new ArrayList<Object>();
 
     /**
      * Set the class loader for this antlib.
      * This class loader is used for any tasks that
      * derive from Definer.
      *
      * @param classLoader the class loader
      */
     protected void setClassLoader(ClassLoader classLoader) {
         this.classLoader = classLoader;
     }
 
     /**
      * Set the URI for this antlib.
      * @param uri the namespace uri
      */
     protected void setURI(String uri) {
         this.uri = uri;
     }
 
     private ClassLoader getClassLoader() {
         if (classLoader == null) {
             classLoader = Antlib.class.getClassLoader();
         }
         return classLoader;
     }
 
     /**
      * add a task to the list of tasks
      *
      * @param nestedTask Nested task to execute in antlib
      */
     public void addTask(Task nestedTask) {
         tasks.add(nestedTask);
     }
 
     /**
      * Execute the nested tasks, setting the classloader for
      * any tasks that derive from Definer.
      */
     public void execute() {
         //TODO handle tasks added via #addTask()
         for (Iterator<Object> i = tasks.iterator(); i.hasNext();) {
             UnknownElement ue = (UnknownElement) i.next();
             setLocation(ue.getLocation());
             ue.maybeConfigure();
             Object configuredObject = ue.getRealThing();
             if (configuredObject == null) {
                 continue;
             }
             if (!(configuredObject instanceof AntlibDefinition)) {
                 throw new BuildException(
                     "Invalid task in antlib " + ue.getTag()
                     + " " + configuredObject.getClass() + " does not "
                     + "extend org.apache.tools.ant.taskdefs.AntlibDefinition");
             }
             AntlibDefinition def = (AntlibDefinition) configuredObject;
             def.setURI(uri);
             def.setAntlibClassLoader(getClassLoader());
             def.init();
             def.execute();
         }
     }
 
 }
diff --git a/src/main/org/apache/tools/ant/types/XMLCatalog.java b/src/main/org/apache/tools/ant/types/XMLCatalog.java
index a05305741..e93f6416e 100644
--- a/src/main/org/apache/tools/ant/types/XMLCatalog.java
+++ b/src/main/org/apache/tools/ant/types/XMLCatalog.java
@@ -1,1121 +1,1127 @@
 /*
  *  Licensed to the Apache Software Foundation (ASF) under one or more
  *  contributor license agreements.  See the NOTICE file distributed with
  *  this work for additional information regarding copyright ownership.
  *  The ASF licenses this file to You under the Apache License, Version 2.0
  *  (the "License"); you may not use this file except in compliance with
  *  the License.  You may obtain a copy of the License at
  *
  *      http://www.apache.org/licenses/LICENSE-2.0
  *
  *  Unless required by applicable law or agreed to in writing, software
  *  distributed under the License is distributed on an "AS IS" BASIS,
  *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  *  See the License for the specific language governing permissions and
  *  limitations under the License.
  *
  */
 
 package org.apache.tools.ant.types;
 
 import java.lang.reflect.Method;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.MalformedURLException;
 import java.net.URL;
+import java.net.URLConnection;
 import java.util.Stack;
 import java.util.Vector;
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.parsers.SAXParserFactory;
 import javax.xml.transform.Source;
 import javax.xml.transform.TransformerException;
 import javax.xml.transform.URIResolver;
 import javax.xml.transform.sax.SAXSource;
 import org.apache.tools.ant.AntClassLoader;
 import org.apache.tools.ant.BuildException;
 import org.apache.tools.ant.Project;
 import org.apache.tools.ant.util.FileUtils;
 import org.apache.tools.ant.util.JAXPUtils;
 import org.xml.sax.EntityResolver;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 import org.xml.sax.XMLReader;
 
 
 
 /**
  * <p>This data type provides a catalog of resource locations (such as
  * DTDs and XML entities), based on the <a
  * href="http://oasis-open.org/committees/entity/spec-2001-08-06.html">
  * OASIS "Open Catalog" standard</a>.  The catalog entries are used
  * both for Entity resolution and URI resolution, in accordance with
  * the {@link org.xml.sax.EntityResolver EntityResolver} and {@link
  * javax.xml.transform.URIResolver URIResolver} interfaces as defined
  * in the <a href="http://java.sun.com/xml/jaxp">Java API for XML
  * Processing Specification</a>.</p>
  *
  * <p>Resource locations can be specified either in-line or in
  * external catalog file(s), or both.  In order to use an external
  * catalog file, the xml-commons resolver library ("resolver.jar")
  * must be in your classpath.  External catalog files may be either <a
  * href="http://oasis-open.org/committees/entity/background/9401.html">
  * plain text format</a> or <a
  * href="http://www.oasis-open.org/committees/entity/spec-2001-08-06.html">
  * XML format</a>.  If the xml-commons resolver library is not found
  * in the classpath, external catalog files, specified in
  * <code>&lt;catalogpath&gt;</code> paths, will be ignored and a warning will
  * be logged.  In this case, however, processing of inline entries will proceed
  * normally.</p>
  *
  * <p>Currently, only <code>&lt;dtd&gt;</code> and
  * <code>&lt;entity&gt;</code> elements may be specified inline; these
  * correspond to OASIS catalog entry types <code>PUBLIC</code> and
  * <code>URI</code> respectively.</p>
  *
  * <p>The following is a usage example:</p>
  *
  * <code>
  * &lt;xmlcatalog&gt;<br>
  * &nbsp;&nbsp;&lt;dtd publicId="" location="/path/to/file.jar" /&gt;<br>
  * &nbsp;&nbsp;&lt;dtd publicId="" location="/path/to/file2.jar" /&gt;<br>
  * &nbsp;&nbsp;&lt;entity publicId="" location="/path/to/file3.jar" /&gt;<br>
  * &nbsp;&nbsp;&lt;entity publicId="" location="/path/to/file4.jar" /&gt;<br>
  * &nbsp;&nbsp;&lt;catalogpath&gt;<br>
  * &nbsp;&nbsp;&nbsp;&nbsp;&lt;pathelement location="/etc/sgml/catalog"/&gt;<br>
  * &nbsp;&nbsp;&lt;/catalogpath&gt;<br>
  * &nbsp;&nbsp;&lt;catalogfiles dir="/opt/catalogs/" includes="**\catalog.xml" /&gt;<br>
  * &lt;/xmlcatalog&gt;<br>
  * </code>
  * <p>
  * Tasks wishing to use <code>&lt;xmlcatalog&gt;</code> must provide a method called
  * <code>createXMLCatalog</code> which returns an instance of
  * <code>XMLCatalog</code>. Nested DTD and entity definitions are handled by
  * the XMLCatalog object and must be labeled <code>dtd</code> and
  * <code>entity</code> respectively.</p>
  *
  * <p>The following is a description of the resolution algorithm:
  * entities/URIs/dtds are looked up in each of the following contexts,
  * stopping when a valid and readable resource is found:
  * <ol>
  * <li>In the local filesystem</li>
  * <li>In the classpath</li>
  * <li>Using the Apache xml-commons resolver (if it is available)</li>
  * <li>In URL-space</li>
  * </ol>
  * </p>
  *
  * <p>See {@link
  * org.apache.tools.ant.taskdefs.optional.XMLValidateTask
  * XMLValidateTask} for an example of a task that has integrated
  * support for XMLCatalogs.</p>
  *
  * <p>Possible future extension could provide for additional OASIS
  * entry types to be specified inline.</p>
  *
  */
 public class XMLCatalog extends DataType
     implements Cloneable, EntityResolver, URIResolver {
 
     /** helper for some File.toURL connversions */
     private static final FileUtils FILE_UTILS = FileUtils.getFileUtils();
 
     //-- Fields ----------------------------------------------------------------
 
     /** Holds dtd/entity objects until needed. */
     private Vector<ResourceLocation> elements = new Vector<ResourceLocation>();
 
     /**
      * Classpath in which to attempt to resolve resources.
      */
     private Path classpath;
 
     /**
      * Path listing external catalog files to search when resolving entities
      */
     private Path catalogPath;
 
     /**
      * The name of the bridge to the Apache xml-commons resolver
      * class, used to determine whether resolver.jar is present in the
      * classpath.
      */
     public static final String APACHE_RESOLVER
         = "org.apache.tools.ant.types.resolver.ApacheCatalogResolver";
 
     /**
      * Resolver base class
      */
     public static final String CATALOG_RESOLVER
         = "org.apache.xml.resolver.tools.CatalogResolver";
 
         //-- Methods ---------------------------------------------------------------
 
     /**
      * Default constructor
      */
     public XMLCatalog() {
         setChecked(false);
     }
 
     /**
      * Returns the elements of the catalog - ResourceLocation objects.
      *
      * @return the elements of the catalog - ResourceLocation objects
      */
     private Vector<ResourceLocation> getElements() {
         return getRef().elements;
     }
 
     /**
      * Returns the classpath in which to attempt to resolve resources.
      *
      * @return the classpath
      */
     private Path getClasspath() {
         return getRef().classpath;
     }
 
     /**
      * Allows nested classpath elements. Not allowed if this catalog
      * is itself a reference to another catalog -- that is, a catalog
      * cannot both refer to another <em>and</em> contain elements or
      * other attributes.
      *
      * @return a Path instance to be configured.
      */
     public Path createClasspath() {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         if (this.classpath == null) {
             this.classpath = new Path(getProject());
         }
         setChecked(false);
         return this.classpath.createPath();
     }
 
     /**
      * Allows simple classpath string.  Not allowed if this catalog is
      * itself a reference to another catalog -- that is, a catalog
      * cannot both refer to another <em>and</em> contain elements or
      * other attributes.
      *
      * @param classpath the classpath to use to look up entities.
      */
     public void setClasspath(Path classpath) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         if (this.classpath == null) {
             this.classpath = classpath;
         } else {
             this.classpath.append(classpath);
         }
         setChecked(false);
     }
 
     /**
      * Allows classpath reference.  Not allowed if this catalog is
      * itself a reference to another catalog -- that is, a catalog
      * cannot both refer to another <em>and</em> contain elements or
      * other attributes.
      *
      * @param r an Ant reference containing a classpath.
      */
     public void setClasspathRef(Reference r) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         createClasspath().setRefid(r);
         setChecked(false);
     }
 
     /** Creates a nested <code>&lt;catalogpath&gt;</code> element.
      * Not allowed if this catalog is itself a reference to another
      * catalog -- that is, a catalog cannot both refer to another
      * <em>and</em> contain elements or other attributes.
      *
      * @return a path to be configured as the catalog path.
      * @exception BuildException
      * if this is a reference and no nested elements are allowed.
      */
     public Path createCatalogPath() {
         if (isReference()) {
             throw noChildrenAllowed();
         }
         if (this.catalogPath == null) {
             this.catalogPath = new Path(getProject());
         }
         setChecked(false);
         return this.catalogPath.createPath();
     }
 
     /**
      * Allows catalogpath reference.  Not allowed if this catalog is
      * itself a reference to another catalog -- that is, a catalog
      * cannot both refer to another <em>and</em> contain elements or
      * other attributes.
      *
      * @param r an Ant reference containing a classpath to be used as
      * the catalog path.
      */
     public void setCatalogPathRef(Reference r) {
         if (isReference()) {
             throw tooManyAttributes();
         }
         createCatalogPath().setRefid(r);
         setChecked(false);
     }
 
 
     /**
      * Returns the catalog path in which to attempt to resolve DTDs.
      *
      * @return the catalog path
      */
     public Path getCatalogPath() {
         return getRef().catalogPath;
     }
 
 
     /**
      * Creates the nested <code>&lt;dtd&gt;</code> element.  Not
      * allowed if this catalog is itself a reference to another
      * catalog -- that is, a catalog cannot both refer to another
      * <em>and</em> contain elements or other attributes.
      *
      * @param dtd the information about the PUBLIC resource mapping to
      *            be added to the catalog
      * @exception BuildException if this is a reference and no nested
      *       elements are allowed.
      */
     public void addDTD(ResourceLocation dtd) throws BuildException {
         if (isReference()) {
             throw noChildrenAllowed();
         }
 
         getElements().addElement(dtd);
         setChecked(false);
     }
 
     /**
      * Creates the nested <code>&lt;entity&gt;</code> element.    Not
      * allowed if this catalog is itself a reference to another
      * catalog -- that is, a catalog cannot both refer to another
      * <em>and</em> contain elements or other attributes.
      *
      * @param entity the information about the URI resource mapping to be
      *       added to the catalog.
      * @exception BuildException if this is a reference and no nested
      *       elements are allowed.
      */
     public void addEntity(ResourceLocation entity) throws BuildException {
         addDTD(entity);
     }
 
     /**
      * Loads a nested <code>&lt;xmlcatalog&gt;</code> into our
      * definition.  Not allowed if this catalog is itself a reference
      * to another catalog -- that is, a catalog cannot both refer to
      * another <em>and</em> contain elements or other attributes.
      *
      * @param catalog Nested XMLCatalog
      */
     public void addConfiguredXMLCatalog(XMLCatalog catalog) {
         if (isReference()) {
             throw noChildrenAllowed();
         }
 
         // Add all nested elements to our catalog
         getElements().addAll(catalog.getElements());
 
         // Append the classpath of the nested catalog
         Path nestedClasspath = catalog.getClasspath();
         createClasspath().append(nestedClasspath);
 
         // Append the catalog path of the nested catalog
         Path nestedCatalogPath = catalog.getCatalogPath();
         createCatalogPath().append(nestedCatalogPath);
         setChecked(false);
     }
 
     /**
      * Makes this instance in effect a reference to another XMLCatalog
      * instance.
      *
      * <p>You must not set another attribute or nest elements inside
      * this element if you make it a reference.  That is, a catalog
      * cannot both refer to another <em>and</em> contain elements or
      * attributes.</p>
      *
      * @param r the reference to which this catalog instance is associated
      * @exception BuildException if this instance already has been configured.
      */
     public void setRefid(Reference r) throws BuildException {
         if (!elements.isEmpty()) {
             throw tooManyAttributes();
         }
         super.setRefid(r);
     }
 
     /**
      * Implements the EntityResolver.resolveEntity() interface method.
      * @param publicId the public id to resolve.
      * @param systemId the system id to resolve.
      * @throws SAXException if there is a parsing problem.
      * @throws IOException if there is an IO problem.
      * @return the resolved entity.
      * @see org.xml.sax.EntityResolver#resolveEntity
      */
     public InputSource resolveEntity(String publicId, String systemId)
         throws SAXException, IOException {
 
         if (isReference()) {
             return getRef().resolveEntity(publicId, systemId);
         }
 
         dieOnCircularReference();
 
         log("resolveEntity: '" + publicId + "': '" + systemId + "'",
             Project.MSG_DEBUG);
 
         InputSource inputSource =
             getCatalogResolver().resolveEntity(publicId, systemId);
 
         if (inputSource == null) {
             log("No matching catalog entry found, parser will use: '"
                 + systemId + "'", Project.MSG_DEBUG);
         }
 
         return inputSource;
     }
 
     /**
      * Implements the URIResolver.resolve() interface method.
      * @param href an href attribute.
      * @param base the base URI.
      * @return a Source object, or null if href cannot be resolved.
      * @throws TransformerException if an error occurs.
      * @see javax.xml.transform.URIResolver#resolve
      */
     public Source resolve(String href, String base)
         throws TransformerException {
 
         if (isReference()) {
             return getRef().resolve(href, base);
         }
 
         dieOnCircularReference();
 
         SAXSource source = null;
 
         String uri = removeFragment(href);
 
         log("resolve: '" + uri + "' with base: '" + base + "'", Project.MSG_DEBUG);
 
         source = (SAXSource) getCatalogResolver().resolve(uri, base);
 
         if (source == null) {
             log("No matching catalog entry found, parser will use: '"
                 + href + "'", Project.MSG_DEBUG);
             //
             // Cannot return a null source, because we have to call
             // setEntityResolver (see setEntityResolver javadoc comment)
             //
             source = new SAXSource();
             URL baseURL = null;
             try {
                 if (base == null) {
                     baseURL = FILE_UTILS.getFileURL(getProject().getBaseDir());
                 } else {
                     baseURL = new URL(base);
                 }
                 URL url = (uri.length() == 0 ? baseURL : new URL(baseURL, uri));
                 source.setInputSource(new InputSource(url.toString()));
             } catch (MalformedURLException ex) {
                 // At this point we are probably in failure mode, but
                 // try to use the bare URI as a last gasp
                 source.setInputSource(new InputSource(uri));
             }
         }
 
         setEntityResolver(source);
         return source;
     }
 
     protected synchronized void dieOnCircularReference(Stack<Object> stk, Project p)
         throws BuildException {
         if (isChecked()) {
             return;
         }
         if (isReference()) {
             super.dieOnCircularReference(stk, p);
         } else {
             if (classpath != null) {
                 pushAndInvokeCircularReferenceCheck(classpath, stk, p);
             }
             if (catalogPath != null) {
                 pushAndInvokeCircularReferenceCheck(catalogPath, stk, p);
             }
             setChecked(true);
         }
     }
 
     /**
      * @since Ant 1.6
      */
     private XMLCatalog getRef() {
         if (!isReference()) {
             return this;
         }
         return getCheckedRef(XMLCatalog.class, "xmlcatalog");
     }
 
     /**
      * The instance of the CatalogResolver strategy to use.
      */
     private CatalogResolver catalogResolver = null;
 
     /**
      * Factory method for creating the appropriate CatalogResolver
      * strategy implementation.
      * <p> Until we query the classpath, we don't know whether the Apache
      * resolver (Norm Walsh's library from xml-commons) is available or not.
      * This method determines whether the library is available and creates the
      * appropriate implementation of CatalogResolver based on the answer.</p>
      * <p>This is an application of the Gang of Four Strategy Pattern
      * combined with Template Method.</p>
      */
     private CatalogResolver getCatalogResolver() {
 
         if (catalogResolver == null) {
 
             AntClassLoader loader = null;
             // Memory-Leak in line below
             loader = getProject().createClassLoader(Path.systemClasspath);
 
             try {
                 Class<?> clazz = Class.forName(APACHE_RESOLVER, true, loader);
 
                 // The Apache resolver is present - Need to check if it can
                 // be seen by the catalog resolver class. Start by getting
                 // the actual loader
                 ClassLoader apacheResolverLoader = clazz.getClassLoader();
 
                 // load the base class through this loader.
                 Class<?> baseResolverClass
                     = Class.forName(CATALOG_RESOLVER, true, apacheResolverLoader);
 
                 // and find its actual loader
                 ClassLoader baseResolverLoader
                     = baseResolverClass.getClassLoader();
 
                 // We have the loader which is being used to load the
                 // CatalogResolver. Can it see the ApacheResolver? The
                 // base resolver will only be able to create the ApacheResolver
                 // if it can see it - doesn't use the context loader.
                 clazz = Class.forName(APACHE_RESOLVER, true, baseResolverLoader);
 
                 Object obj  = clazz.newInstance();
                 //
                 // Success!  The xml-commons resolver library is
                 // available, so use it.
                 //
                 catalogResolver = new ExternalResolver(clazz, obj);
             } catch (Throwable ex) {
                 //
                 // The xml-commons resolver library is not
                 // available, so we can't use it.
                 //
                 catalogResolver = new InternalResolver();
                 if (getCatalogPath() != null
                     && getCatalogPath().list().length != 0) {
                         log("Warning: XML resolver not found; external catalogs"
                             + " will be ignored", Project.MSG_WARN);
                     }
                 log("Failed to load Apache resolver: " + ex, Project.MSG_DEBUG);
             }
         }
         return catalogResolver;
     }
 
     /**
      * <p>This is called from the URIResolver to set an EntityResolver
      * on the SAX parser to be used for new XML documents that are
      * encountered as a result of the document() function, xsl:import,
      * or xsl:include.  This is done because the XSLT processor calls
      * out to the SAXParserFactory itself to create a new SAXParser to
      * parse the new document.  The new parser does not automatically
      * inherit the EntityResolver of the original (although arguably
      * it should).  See below:</p>
      *
      * <tt>"If an application wants to set the ErrorHandler or
      * EntityResolver for an XMLReader used during a transformation,
      * it should use a URIResolver to return the SAXSource which
      * provides (with getXMLReader) a reference to the XMLReader"</tt>
      *
      * <p>...quoted from page 118 of the Java API for XML
      * Processing 1.1 specification</p>
      *
      */
     private void setEntityResolver(SAXSource source) throws TransformerException {
 
         XMLReader reader = source.getXMLReader();
         if (reader == null) {
             SAXParserFactory spFactory = SAXParserFactory.newInstance();
             spFactory.setNamespaceAware(true);
             try {
                 reader = spFactory.newSAXParser().getXMLReader();
             } catch (ParserConfigurationException ex) {
                 throw new TransformerException(ex);
             } catch (SAXException ex) {
                 throw new TransformerException(ex);
             }
         }
         reader.setEntityResolver(this);
         source.setXMLReader(reader);
     }
 
     /**
      * Find a ResourceLocation instance for the given publicId.
      *
      * @param publicId the publicId of the Resource for which local information
      *        is required.
      * @return a ResourceLocation instance with information on the local location
      *         of the Resource or null if no such information is available.
      */
     private ResourceLocation findMatchingEntry(String publicId) {
         for (ResourceLocation element : getElements()) {
             if (element.getPublicId().equals(publicId)) {
                 return element;
             }
         }
         return null;
     }
 
     /**
      * Utility method to remove trailing fragment from a URI.
      * For example,
      * <code>http://java.sun.com/index.html#chapter1</code>
      * would return <code>http://java.sun.com/index.html</code>.
      *
      * @param uri The URI to process.  It may or may not contain a
      *            fragment.
      * @return The URI sans fragment.
      */
     private String removeFragment(String uri) {
         String result = uri;
         int hashPos = uri.indexOf("#");
         if (hashPos >= 0) {
             result = uri.substring(0, hashPos);
         }
         return result;
     }
 
     /**
      * Utility method to lookup a ResourceLocation in the filesystem.
      *
      * @return An InputSource for reading the file, or <code>null</code>
      *     if the file does not exist or is not readable.
      */
     private InputSource filesystemLookup(ResourceLocation matchingEntry) {
 
         String uri = matchingEntry.getLocation();
         // the following line seems to be necessary on Windows under JDK 1.2
         uri = uri.replace(File.separatorChar, '/');
         URL baseURL = null;
 
         //
         // The ResourceLocation may specify a relative path for its
         // location attribute.  This is resolved using the appropriate
         // base.
         //
         if (matchingEntry.getBase() != null) {
             baseURL = matchingEntry.getBase();
         } else {
             try {
                 baseURL = FILE_UTILS.getFileURL(getProject().getBaseDir());
             } catch (MalformedURLException ex) {
                 throw new BuildException("Project basedir cannot be converted to a URL");
             }
         }
 
         InputSource source = null;
         URL url = null;
         try {
             url = new URL(baseURL, uri);
         } catch (MalformedURLException ex) {
             // this processing is useful under Windows when the location of the DTD
             // has been given as an absolute path
             // see Bugzilla Report 23913
             File testFile = new File(uri);
             if (testFile.exists() && testFile.canRead()) {
                 log("uri : '"
                     + uri + "' matches a readable file", Project.MSG_DEBUG);
                 try {
                     url = FILE_UTILS.getFileURL(testFile);
                 } catch (MalformedURLException ex1) {
                     throw new BuildException(
                         "could not find an URL for :" + testFile.getAbsolutePath());
                 }
             } else {
                 log("uri : '"
                     + uri + "' does not match a readable file", Project.MSG_DEBUG);
 
             }
         }
 
         if (url != null && url.getProtocol().equals("file")) {
             String fileName = FILE_UTILS.fromURI(url.toString());
             if (fileName != null) {
                 log("fileName " + fileName, Project.MSG_DEBUG);
                 File resFile = new File(fileName);
                 if (resFile.exists() && resFile.canRead()) {
                     try {
                         source = new InputSource(new FileInputStream(resFile));
                         String sysid = JAXPUtils.getSystemId(resFile);
                         source.setSystemId(sysid);
                         log("catalog entry matched a readable file: '"
                             + sysid + "'", Project.MSG_DEBUG);
                     } catch (IOException ex) {
                         // ignore
                     }
                 }
             }
         }
         return source;
     }
 
     /**
      * Utility method to lookup a ResourceLocation in the classpath.
      *
      * @return An InputSource for reading the resource, or <code>null</code>
      *    if the resource does not exist in the classpath or is not readable.
      */
     private InputSource classpathLookup(ResourceLocation matchingEntry) {
 
         InputSource source = null;
 
         AntClassLoader loader = null;
         Path cp = classpath;
         if (cp != null) {
             cp = classpath.concatSystemClasspath("ignore");
         } else {
             cp = (new Path(getProject())).concatSystemClasspath("last");
         }
         loader = getProject().createClassLoader(cp);
 
         //
         // for classpath lookup we ignore the base directory
         //
         InputStream is
             = loader.getResourceAsStream(matchingEntry.getLocation());
 
         if (is != null) {
             source = new InputSource(is);
             URL entryURL = loader.getResource(matchingEntry.getLocation());
             String sysid = entryURL.toExternalForm();
             source.setSystemId(sysid);
             log("catalog entry matched a resource in the classpath: '"
                 + sysid + "'", Project.MSG_DEBUG);
         }
 
         return source;
     }
 
     /**
      * Utility method to lookup a ResourceLocation in URL-space.
      *
      * @return An InputSource for reading the resource, or <code>null</code>
      *    if the resource does not identify a valid URL or is not readable.
      */
     private InputSource urlLookup(ResourceLocation matchingEntry) {
 
         String uri = matchingEntry.getLocation();
         URL baseURL = null;
 
         //
         // The ResourceLocation may specify a relative url for its
         // location attribute.  This is resolved using the appropriate
         // base.
         //
         if (matchingEntry.getBase() != null) {
             baseURL = matchingEntry.getBase();
         } else {
             try {
                 baseURL = FILE_UTILS.getFileURL(getProject().getBaseDir());
             } catch (MalformedURLException ex) {
                 throw new BuildException("Project basedir cannot be converted to a URL");
             }
         }
 
         InputSource source = null;
         URL url = null;
 
         try {
             url = new URL(baseURL, uri);
         } catch (MalformedURLException ex) {
             // ignore
         }
 
         if (url != null) {
             try {
-                InputStream is = url.openStream();
+                InputStream is = null;
+                URLConnection conn = url.openConnection();
+                if (conn != null) {
+                    conn.setDefaultUseCaches(false);
+                    is = conn.getInputStream();
+                }
                 if (is != null) {
                     source = new InputSource(is);
                     String sysid = url.toExternalForm();
                     source.setSystemId(sysid);
                     log("catalog entry matched as a URL: '"
                         + sysid + "'", Project.MSG_DEBUG);
                 }
             } catch (IOException ex) {
                 // ignore
             }
         }
 
         return source;
 
     }
 
     /**
      * Interface implemented by both the InternalResolver strategy and
      * the ExternalResolver strategy.
      */
     private interface CatalogResolver extends URIResolver, EntityResolver {
 
         InputSource resolveEntity(String publicId, String systemId);
 
         Source resolve(String href, String base) throws TransformerException;
     }
 
     /**
      * The InternalResolver strategy is used if the Apache resolver
      * library (Norm Walsh's library from xml-commons) is not
      * available.  In this case, external catalog files will be
      * ignored.
      *
      */
     private class InternalResolver implements CatalogResolver {
 
         public InternalResolver() {
             log("Apache resolver library not found, internal resolver will be used",
                 Project.MSG_VERBOSE);
         }
 
         public InputSource resolveEntity(String publicId,
                                          String systemId) {
             InputSource result = null;
             ResourceLocation matchingEntry = findMatchingEntry(publicId);
 
             if (matchingEntry != null) {
 
                 log("Matching catalog entry found for publicId: '"
                     + matchingEntry.getPublicId() + "' location: '"
                     + matchingEntry.getLocation() + "'",
                     Project.MSG_DEBUG);
 
                 result = filesystemLookup(matchingEntry);
 
                 if (result == null) {
                     result = classpathLookup(matchingEntry);
                 }
 
                 if (result == null) {
                     result = urlLookup(matchingEntry);
                 }
             }
             return result;
         }
 
         public Source resolve(String href, String base)
             throws TransformerException {
 
             SAXSource result = null;
             InputSource source = null;
 
             ResourceLocation matchingEntry = findMatchingEntry(href);
 
             if (matchingEntry != null) {
 
                 log("Matching catalog entry found for uri: '"
                     + matchingEntry.getPublicId() + "' location: '"
                     + matchingEntry.getLocation() + "'",
                     Project.MSG_DEBUG);
 
                 //
                 // Use the passed in base in preference to the base
                 // from matchingEntry, which is either null or the
                 // directory in which the external catalog file from
                 // which it was obtained is located.  We make a copy
                 // so matchingEntry's original base is untouched.
                 //
                 // This is the standard behavior as per my reading of
                 // the JAXP and XML Catalog specs.  CKS 11/7/2002
                 //
                 ResourceLocation entryCopy = matchingEntry;
                 if (base != null) {
                     try {
                         URL baseURL = new URL(base);
                         entryCopy = new ResourceLocation();
                         entryCopy.setBase(baseURL);
                     } catch (MalformedURLException ex) {
                         // ignore
                     }
                 }
                 entryCopy.setPublicId(matchingEntry.getPublicId());
                 entryCopy.setLocation(matchingEntry.getLocation());
 
                 source = filesystemLookup(entryCopy);
 
                 if (source == null) {
                     source = classpathLookup(entryCopy);
                 }
 
                 if (source == null) {
                     source = urlLookup(entryCopy);
                 }
 
                 if (source != null) {
                     result = new SAXSource(source);
                 }
             }
             return result;
         }
     }
 
     /**
      * The ExternalResolver strategy is used if the Apache resolver
      * library (Norm Walsh's library from xml-commons) is available in
      * the classpath.  The ExternalResolver is a essentially a superset
      * of the InternalResolver.
      *
      */
     private class ExternalResolver implements CatalogResolver {
 
         private Method setXMLCatalog = null;
         private Method parseCatalog = null;
         private Method resolveEntity = null;
         private Method resolve = null;
 
         /** The instance of the ApacheCatalogResolver bridge class */
         private Object resolverImpl = null;
 
         private boolean externalCatalogsProcessed = false;
 
         public ExternalResolver(Class<?> resolverImplClass,
                               Object resolverImpl) {
 
             this.resolverImpl = resolverImpl;
 
             //
             // Get Method instances for each of the methods we need to
             // call on the resolverImpl using reflection.  We can't
             // call them directly, because they require on the
             // xml-commons resolver library which may not be available
             // in the classpath.
             //
             try {
                 setXMLCatalog =
                     resolverImplClass.getMethod("setXMLCatalog",
                                                 new Class[] {XMLCatalog.class});
 
                 parseCatalog =
                     resolverImplClass.getMethod("parseCatalog",
                                                 new Class[] {String.class});
 
                 resolveEntity =
                     resolverImplClass.getMethod("resolveEntity",
                                                 new Class[] {String.class, String.class});
 
                 resolve =
                     resolverImplClass.getMethod("resolve",
                                                 new Class[] {String.class, String.class});
             } catch (NoSuchMethodException ex) {
                 throw new BuildException(ex);
             }
 
             log("Apache resolver library found, xml-commons resolver will be used",
                 Project.MSG_VERBOSE);
         }
 
         public InputSource resolveEntity(String publicId,
                                          String systemId) {
             InputSource result = null;
 
             processExternalCatalogs();
 
             ResourceLocation matchingEntry = findMatchingEntry(publicId);
 
             if (matchingEntry != null) {
 
                 log("Matching catalog entry found for publicId: '"
                     + matchingEntry.getPublicId() + "' location: '"
                     + matchingEntry.getLocation() + "'",
                     Project.MSG_DEBUG);
 
                 result = filesystemLookup(matchingEntry);
 
                 if (result == null) {
                     result = classpathLookup(matchingEntry);
                 }
 
                 if (result == null) {
                     try {
                         result =
                             (InputSource) resolveEntity.invoke(resolverImpl,
                                                               new Object[] {publicId, systemId});
                     } catch (Exception ex) {
                         throw new BuildException(ex);
                     }
                 }
             } else {
                 //
                 // We didn't match a ResourceLocation, but since we
                 // only support PUBLIC and URI entry types internally,
                 // it is still possible that there is another entry in
                 // an external catalog that will match.  We call
                 // Apache resolver's resolveEntity method to cover
                 // this possibility.
                 //
                 try {
                     result =
                         (InputSource) resolveEntity.invoke(resolverImpl,
                                                           new Object[] {publicId, systemId});
                 } catch (Exception ex) {
                     throw new BuildException(ex);
                 }
             }
 
             return result;
         }
 
         public Source resolve(String href, String base)
             throws TransformerException {
 
             SAXSource result = null;
             InputSource source = null;
 
             processExternalCatalogs();
 
             ResourceLocation matchingEntry = findMatchingEntry(href);
 
             if (matchingEntry != null) {
 
                 log("Matching catalog entry found for uri: '"
                     + matchingEntry.getPublicId() + "' location: '"
                     + matchingEntry.getLocation() + "'",
                     Project.MSG_DEBUG);
 
                 //
                 // Use the passed in base in preference to the base
                 // from matchingEntry, which is either null or the
                 // directory in which the external catalog file from
                 // which it was obtained is located.  We make a copy
                 // so matchingEntry's original base is untouched.  Of
                 // course, if there is no base, no need to make a
                 // copy...
                 //
                 // This is the standard behavior as per my reading of
                 // the JAXP and XML Catalog specs.  CKS 11/7/2002
                 //
                 ResourceLocation entryCopy = matchingEntry;
                 if (base != null) {
                     try {
                         URL baseURL = new URL(base);
                         entryCopy = new ResourceLocation();
                         entryCopy.setBase(baseURL);
                     } catch (MalformedURLException ex) {
                         // ignore
                     }
                 }
                 entryCopy.setPublicId(matchingEntry.getPublicId());
                 entryCopy.setLocation(matchingEntry.getLocation());
 
                 source = filesystemLookup(entryCopy);
 
                 if (source == null) {
                     source = classpathLookup(entryCopy);
                 }
 
                 if (source != null) {
                     result = new SAXSource(source);
                 } else {
                     try {
                         result =
                             (SAXSource) resolve.invoke(resolverImpl,
                                                       new Object[] {href, base});
                     } catch (Exception ex) {
                         throw new BuildException(ex);
                     }
                 }
             } else {
                 //
                 // We didn't match a ResourceLocation, but since we
                 // only support PUBLIC and URI entry types internally,
                 // it is still possible that there is another entry in
                 // an external catalog that will match.  We call
                 // Apache resolver's resolveEntity method to cover
                 // this possibility.
                 //
                 if (base == null) {
                     try {
                         base = FILE_UTILS.getFileURL(getProject().getBaseDir()).toString();
                     } catch (MalformedURLException x) {
                         throw new TransformerException(x);
                     }
                 }
                 try {
                     result =
                         (SAXSource) resolve.invoke(resolverImpl,
                                                   new Object[] {href, base});
                 } catch (Exception ex) {
                     throw new BuildException(ex);
                 }
             }
             return result;
         }
 
         /**
          * Process each external catalog file specified in a
          * <code>&lt;catalogpath&gt;</code>.  It will be
          * parsed by the resolver library, and the individual elements
          * will be added back to us (that is, the controlling
          * XMLCatalog instance) via a callback mechanism.
          */
         private void processExternalCatalogs() {
 
             if (!externalCatalogsProcessed) {
 
                 try {
                     setXMLCatalog.invoke(resolverImpl,
                                          new Object[] {XMLCatalog.this});
                 } catch (Exception ex) {
                     throw new BuildException(ex);
                 }
 
                 // Parse each catalog listed in nested <catalogpath> elements
                 Path catPath = getCatalogPath();
                 if (catPath != null) {
                     log("Using catalogpath '" + getCatalogPath() + "'",
                         Project.MSG_DEBUG);
                     String[] catPathList = getCatalogPath().list();
 
                     for (int i = 0; i < catPathList.length; i++) {
                         File catFile = new File(catPathList[i]);
                         log("Parsing " + catFile, Project.MSG_DEBUG);
                         try {
                             parseCatalog.invoke(resolverImpl,
                                     new Object[] {catFile.getPath()});
                         } catch (Exception ex) {
                             throw new BuildException(ex);
                         }
                     }
                 }
             }
             externalCatalogsProcessed = true;
         }
     }
 } //-- XMLCatalog
