diff --git a/hibernate-core/hibernate-core.gradle b/hibernate-core/hibernate-core.gradle
index 447730ea3d..accc04e707 100644
--- a/hibernate-core/hibernate-core.gradle
+++ b/hibernate-core/hibernate-core.gradle
@@ -1,107 +1,107 @@
 apply plugin: 'java'
 apply plugin: 'antlr'
 apply plugin: org.hibernate.build.gradle.inject.InjectionPlugin
 
 dependencies {
 	compile( libraries.commons_collections )
     compile( libraries.jta )
     compile( libraries.dom4j ) {
         transitive = false
     }
     compile( libraries.commons_annotations )
     compile( libraries.jandex )
     compile( libraries.classmate )
     compile( libraries.jpa )
     compile( libraries.javassist )
     compile( libraries.antlr )
     antlr( libraries.antlr )
     provided( libraries.ant )
     provided( libraries.jacc )
     provided( libraries.validation )
     testCompile( project(':hibernate-testing') )
     testCompile( libraries.validation )
     testCompile( libraries.validator ) {
         // for test runtime
         transitive = true
     }
     testRuntime( 'jaxen:jaxen:1.1' )
     testRuntime( libraries.javassist )
 }
 
 manifest.mainAttributes(
         'Main-Class': 'org.hibernate.Version'
 )
 
 
 sourceSets.main {
     originalJavaSrcDirs = java.srcDirs
     jaxbTargetDir = file( "${buildDir}/generated-src/jaxb/main" )
     java.srcDir jaxbTargetDir
 }
 
 // resources inherently exclude sources
 sourceSets.test.resources {
     setSrcDirs( ['src/test/java','src/test/resources'] )
 }
 
 ideaModule {
     sourceDirs.add( file( '$buildDir/generated-src/antlr/main' ) )
 }
 
 task jaxb {
     // output directory
     jaxbTargetDir = file( "${buildDir}/generated-src/jaxb/main" )
 
     // input schemas
     cfgXsd = file( 'src/main/resources/org/hibernate/hibernate-configuration-4.0.xsd')
     hbmXsd = file( 'src/main/resources/org/hibernate/hibernate-mapping-4.0.xsd' )
     ormXsd = file( 'src/main/resources/org/hibernate/ejb/orm_2_0.xsd' )
 
     // input bindings
     cfgXjb = file( 'src/main/xjb/hbm-configuration-bindings.xjb' )
     hbmXjb = file( 'src/main/xjb/hbm-mapping-bindings.xjb' )
     ormXjb = file( 'src/main/xjb/orm-bindings.xjb' )
 
     // configure Gradle up-to-date checking
     inputs.files( [cfgXsd, hbmXsd, ormXsd, cfgXjb, hbmXjb, ormXjb] )
     outputs.dir( jaxbTargetDir )
 
     // perform actions
     doLast {
         jaxbTargetDir.mkdirs()
 
         ant.taskdef(name: 'xjc', classname: 'org.jvnet.jaxb2_commons.xjc.XJC2Task', classpath: configurations.jaxb.asPath)
         ant.jaxbTargetDir = jaxbTargetDir
 
         // hibernate-configuration
         ant.xjc(
                 destdir: '${jaxbTargetDir}',
-                package: 'org.hibernate.metamodel.source.hbm.xml.config',
+                package: 'org.hibernate.metamodel.source.hbm.jaxb.config',
                 binding: 'src/main/xjb/hbm-configuration-bindings.xjb',
                 schema: cfgXsd.path
         )
 
         // hibernate-mapping
         ant.xjc(
                 destdir: '${jaxbTargetDir}',
-                package: 'org.hibernate.metamodel.source.hbm.xml.mapping',
+                package: 'org.hibernate.metamodel.source.hbm.jaxb.mapping',
                 binding: hbmXjb.path,
                 schema: hbmXsd.path,
                 extension: 'true'
         ) {
             arg line:     '-Xinheritance'
         }
 
         // orm.xml (jpa)
         ant.xjc(
                 destdir: '${jaxbTargetDir}',
-                package: 'org.hibernate.metamodel.source.annotation.xml',
+                package: 'org.hibernate.metamodel.source.annotation.jaxb',
                 binding: 'src/main/xjb/orm-bindings.xjb',
                 schema: ormXsd.path
         )
     }
 
 }
 compileJava.dependsOn jaxb
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/InvalidMappingException.java b/hibernate-core/src/main/java/org/hibernate/InvalidMappingException.java
index 61396392a3..afee84203c 100644
--- a/hibernate-core/src/main/java/org/hibernate/InvalidMappingException.java
+++ b/hibernate-core/src/main/java/org/hibernate/InvalidMappingException.java
@@ -1,79 +1,79 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 20082011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate;
 
 import org.hibernate.internal.util.xml.XmlDocument;
-import org.hibernate.metamodel.binder.Origin;
+import org.hibernate.metamodel.source.Origin;
 
 /**
  * Thrown when a mapping is found to be invalid.
  * Similar to MappingException, but this contains more info about the path and type of mapping (e.g. file, resource or url)
  * 
  * @author Max Rydahl Andersen
  * @author Steve Ebersole
  */
 public class InvalidMappingException extends MappingException {
 	private final String path;
 	private final String type;
 
 	public InvalidMappingException(String customMessage, String type, String path, Throwable cause) {
 		super(customMessage, cause);
 		this.type=type;
 		this.path=path;
 	}
 
 	public InvalidMappingException(String customMessage, String type, String path) {
 		super(customMessage);
 		this.type=type;
 		this.path=path;
 	}
 
 	public InvalidMappingException(String customMessage, XmlDocument xmlDocument, Throwable cause) {
 		this( customMessage, xmlDocument.getOrigin().getType(), xmlDocument.getOrigin().getName(), cause );
 	}
 
 	public InvalidMappingException(String customMessage, XmlDocument xmlDocument) {
 		this( customMessage, xmlDocument.getOrigin().getType(), xmlDocument.getOrigin().getName() );
 	}
 
 	public InvalidMappingException(String customMessage, Origin origin) {
 		this( customMessage, origin.getType().toString(), origin.getName() );
 	}
 
 	public InvalidMappingException(String type, String path) {
 		this("Could not parse mapping document from " + type + (path==null?"":" " + path), type, path);
 	}
 
 	public InvalidMappingException(String type, String path, Throwable cause) {
 		this("Could not parse mapping document from " + type + (path==null?"":" " + path), type, path, cause);		
 	}
 
 	public String getType() {
 		return type;
 	}
 	
 	public String getPath() {
 		return path;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerServiceInitiator.java b/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerServiceInitiator.java
index 04a49bf5c9..c4eec7b474 100644
--- a/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerServiceInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/event/service/internal/EventListenerServiceInitiator.java
@@ -1,61 +1,61 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.event.service.internal;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceInitiator;
 
 /**
  * Service initiator for {@link EventListenerRegistry}
  *
  * @author Steve Ebersole
  */
 public class EventListenerServiceInitiator implements SessionFactoryServiceInitiator<EventListenerRegistry> {
 	public static final EventListenerServiceInitiator INSTANCE = new EventListenerServiceInitiator();
 
 	@Override
 	public Class<EventListenerRegistry> getServiceInitiated() {
 		return EventListenerRegistry.class;
 	}
 
 	@Override
 	public EventListenerRegistry initiateService(
 			SessionFactoryImplementor sessionFactory,
 			Configuration configuration,
 			ServiceRegistryImplementor registry) {
 		return new EventListenerRegistryImpl();
 	}
 
 	@Override
 	public EventListenerRegistry initiateService(
 			SessionFactoryImplementor sessionFactory,
 			MetadataImplementor metadata,
 			ServiceRegistryImplementor registry) {
 		return new EventListenerRegistryImpl();
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java
index 2b95802fb2..4dfbc42c86 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java
@@ -1,1115 +1,1115 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import javax.naming.NamingException;
 import javax.naming.Reference;
 import javax.naming.StringRefAddr;
 import java.io.IOException;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.ObjectStreamException;
 import java.io.Serializable;
 import java.sql.Connection;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.concurrent.ConcurrentMap;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.Cache;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.MappingException;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.QueryException;
 import org.hibernate.Session;
 import org.hibernate.SessionBuilder;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.StatelessSession;
 import org.hibernate.StatelessSessionBuilder;
 import org.hibernate.TypeHelper;
 import org.hibernate.cache.internal.CacheDataDescriptionImpl;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.cache.spi.CollectionRegion;
 import org.hibernate.cache.spi.EntityRegion;
 import org.hibernate.cache.spi.QueryCache;
 import org.hibernate.cache.spi.Region;
 import org.hibernate.cache.spi.UpdateTimestampsCache;
 import org.hibernate.cache.spi.access.AccessType;
 import org.hibernate.cache.spi.access.CollectionRegionAccessStrategy;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.access.RegionAccessStrategy;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.Settings;
 import org.hibernate.cfg.SettingsFactory;
 import org.hibernate.context.internal.JTASessionContext;
 import org.hibernate.context.internal.ManagedSessionContext;
 import org.hibernate.context.internal.ThreadLocalSessionContext;
 import org.hibernate.context.spi.CurrentSessionContext;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.function.SQLFunctionRegistry;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.profile.Association;
 import org.hibernate.engine.profile.Fetch;
 import org.hibernate.engine.profile.FetchProfile;
 import org.hibernate.engine.query.spi.QueryPlanCache;
 import org.hibernate.engine.query.spi.sql.NativeSQLQuerySpecification;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
 import org.hibernate.engine.transaction.spi.TransactionEnvironment;
 import org.hibernate.exception.spi.SQLExceptionConverter;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.UUIDGenerator;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.integrator.spi.IntegratorService;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.metadata.CollectionMetadata;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.binding.PluralAttributeBinding;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.persister.spi.PersisterFactory;
 import org.hibernate.pretty.MessageHelper;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.config.spi.ConfigurationService;
 import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.jndi.spi.JndiService;
 import org.hibernate.service.jta.platform.spi.JtaPlatform;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.service.spi.SessionFactoryServiceRegistryFactory;
 import org.hibernate.stat.Statistics;
 import org.hibernate.stat.spi.StatisticsImplementor;
 import org.hibernate.tool.hbm2ddl.SchemaExport;
 import org.hibernate.tool.hbm2ddl.SchemaUpdate;
 import org.hibernate.tool.hbm2ddl.SchemaValidator;
 import org.hibernate.tuple.entity.EntityTuplizer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeResolver;
 
 
 /**
  * Concrete implementation of the <tt>SessionFactory</tt> interface. Has the following
  * responsibilities
  * <ul>
  * <li>caches configuration settings (immutably)
  * <li>caches "compiled" mappings ie. <tt>EntityPersister</tt>s and
  *     <tt>CollectionPersister</tt>s (immutable)
  * <li>caches "compiled" queries (memory sensitive cache)
  * <li>manages <tt>PreparedStatement</tt>s
  * <li> delegates JDBC <tt>Connection</tt> management to the <tt>ConnectionProvider</tt>
  * <li>factory for instances of <tt>SessionImpl</tt>
  * </ul>
  * This class must appear immutable to clients, even if it does all kinds of caching
  * and pooling under the covers. It is crucial that the class is not only thread
  * safe, but also highly concurrent. Synchronization must be used extremely sparingly.
  *
  * @see org.hibernate.service.jdbc.connections.spi.ConnectionProvider
  * @see org.hibernate.Session
  * @see org.hibernate.hql.spi.QueryTranslator
  * @see org.hibernate.persister.entity.EntityPersister
  * @see org.hibernate.persister.collection.CollectionPersister
  * @author Gavin King
  */
 public final class SessionFactoryImpl
 		implements SessionFactory, SessionFactoryImplementor {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, SessionFactoryImpl.class.getName());
 	private static final IdentifierGenerator UUID_GENERATOR = UUIDGenerator.buildSessionFactoryUniqueIdentifierGenerator();
 
 	private final String name;
 	private final String uuid;
 
 	private final transient Map entityPersisters;
 	private final transient Map<String,ClassMetadata> classMetadata;
 	private final transient Map collectionPersisters;
 	private final transient Map collectionMetadata;
 	private final transient Map<String,Set<String>> collectionRolesByEntityParticipant;
 	private final transient Map identifierGenerators;
 	private final transient Map<String, NamedQueryDefinition> namedQueries;
 	private final transient Map<String, NamedSQLQueryDefinition> namedSqlQueries;
 	private final transient Map<String, ResultSetMappingDefinition> sqlResultSetMappings;
 	private final transient Map<String, FilterDefinition> filters;
 	private final transient Map fetchProfiles;
 	private final transient Map<String,String> imports;
 	private final transient SessionFactoryServiceRegistry serviceRegistry;
         private final transient JdbcServices jdbcServices;
         private final transient Dialect dialect;
 	private final transient Settings settings;
 	private final transient Properties properties;
 	private transient SchemaExport schemaExport;
 	private final transient QueryCache queryCache;
 	private final transient UpdateTimestampsCache updateTimestampsCache;
 	private final transient Map<String,QueryCache> queryCaches;
 	private final transient ConcurrentMap<String,Region> allCacheRegions = new ConcurrentHashMap<String, Region>();
 	private final transient CurrentSessionContext currentSessionContext;
 	private final transient SQLFunctionRegistry sqlFunctionRegistry;
 	private final transient SessionFactoryObserverChain observer = new SessionFactoryObserverChain();
 	private final transient ConcurrentHashMap<EntityNameResolver,Object> entityNameResolvers = new ConcurrentHashMap<EntityNameResolver, Object>();
 	private final transient QueryPlanCache queryPlanCache;
 	private final transient Cache cacheAccess = new CacheImpl();
 	private transient boolean isClosed = false;
 	private final transient TypeResolver typeResolver;
 	private final transient TypeHelper typeHelper;
 	private final transient TransactionEnvironment transactionEnvironment;
 	private final transient SessionFactoryOptions sessionFactoryOptions;
 
 	@SuppressWarnings( {"unchecked"} )
 	public SessionFactoryImpl(
 			final Configuration cfg,
 	        Mapping mapping,
 			ServiceRegistry serviceRegistry,
 	        Settings settings,
 			SessionFactoryObserver observer) throws HibernateException {
         LOG.debug( "Building session factory" );
 
 		sessionFactoryOptions = new SessionFactoryOptions() {
 			private EntityNotFoundDelegate entityNotFoundDelegate;
 
 			@Override
 			public Interceptor getInterceptor() {
 				return cfg.getInterceptor();
 			}
 
 			@Override
 			public EntityNotFoundDelegate getEntityNotFoundDelegate() {
 				if ( entityNotFoundDelegate == null ) {
 					if ( cfg.getEntityNotFoundDelegate() != null ) {
 						entityNotFoundDelegate = cfg.getEntityNotFoundDelegate();
 					}
 					else {
 						entityNotFoundDelegate = new EntityNotFoundDelegate() {
 							public void handleEntityNotFound(String entityName, Serializable id) {
 								throw new ObjectNotFoundException( id, entityName );
 							}
 						};
 					}
 				}
 				return entityNotFoundDelegate;
 			}
 		};
 
 		this.settings = settings;
 
 		this.properties = new Properties();
 		this.properties.putAll( cfg.getProperties() );
 
 		this.serviceRegistry = serviceRegistry.getService( SessionFactoryServiceRegistryFactory.class ).buildServiceRegistry(
 				this,
 				cfg
 		);
                 this.jdbcServices = this.serviceRegistry.getService( JdbcServices.class );
                 this.dialect = this.jdbcServices.getDialect();
 		this.sqlFunctionRegistry = new SQLFunctionRegistry( getDialect(), cfg.getSqlFunctions() );
 		if ( observer != null ) {
 			this.observer.addObserver( observer );
 		}
 
 		this.typeResolver = cfg.getTypeResolver().scope( this );
 		this.typeHelper = new TypeLocatorImpl( typeResolver );
 
 		this.filters = new HashMap<String, FilterDefinition>();
 		this.filters.putAll( cfg.getFilterDefinitions() );
 
         LOG.debugf("Session factory constructed with filter configurations : %s", filters);
         LOG.debugf("Instantiating session factory with properties: %s", properties);
 
 		// Caches
 		settings.getRegionFactory().start( settings, properties );
 		this.queryPlanCache = new QueryPlanCache( this );
 
 		// todo : everything above here consider implementing as standard SF service.  specifically: stats, caches, types, function-reg
 
 		class IntegratorObserver implements SessionFactoryObserver {
 			private ArrayList<Integrator> integrators = new ArrayList<Integrator>();
 
 			@Override
 			public void sessionFactoryCreated(SessionFactory factory) {
 			}
 
 			@Override
 			public void sessionFactoryClosed(SessionFactory factory) {
 				for ( Integrator integrator : integrators ) {
 					integrator.disintegrate( SessionFactoryImpl.this, SessionFactoryImpl.this.serviceRegistry );
 				}
 			}
 		}
 
 		final IntegratorObserver integratorObserver = new IntegratorObserver();
 		this.observer.addObserver( integratorObserver );
 		for ( Integrator integrator : serviceRegistry.getService( IntegratorService.class ).getIntegrators() ) {
 			integrator.integrate( cfg, this, this.serviceRegistry );
 			integratorObserver.integrators.add( integrator );
 		}
 
 		//Generators:
 
 		identifierGenerators = new HashMap();
 		Iterator classes = cfg.getClassMappings();
 		while ( classes.hasNext() ) {
 			PersistentClass model = (PersistentClass) classes.next();
 			if ( !model.isInherited() ) {
 				IdentifierGenerator generator = model.getIdentifier().createIdentifierGenerator(
 						cfg.getIdentifierGeneratorFactory(),
 						getDialect(),
 				        settings.getDefaultCatalogName(),
 				        settings.getDefaultSchemaName(),
 				        (RootClass) model
 				);
 				identifierGenerators.put( model.getEntityName(), generator );
 			}
 		}
 
 
 		///////////////////////////////////////////////////////////////////////
 		// Prepare persisters and link them up with their cache
 		// region/access-strategy
 
 		final String cacheRegionPrefix = settings.getCacheRegionPrefix() == null ? "" : settings.getCacheRegionPrefix() + ".";
 
 		entityPersisters = new HashMap();
 		Map entityAccessStrategies = new HashMap();
 		Map<String,ClassMetadata> classMeta = new HashMap<String,ClassMetadata>();
 		classes = cfg.getClassMappings();
 		while ( classes.hasNext() ) {
 			final PersistentClass model = (PersistentClass) classes.next();
 			model.prepareTemporaryTables( mapping, getDialect() );
 			final String cacheRegionName = cacheRegionPrefix + model.getRootClass().getCacheRegionName();
 			// cache region is defined by the root-class in the hierarchy...
 			EntityRegionAccessStrategy accessStrategy = ( EntityRegionAccessStrategy ) entityAccessStrategies.get( cacheRegionName );
 			if ( accessStrategy == null && settings.isSecondLevelCacheEnabled() ) {
 				final AccessType accessType = AccessType.fromExternalName( model.getCacheConcurrencyStrategy() );
 				if ( accessType != null ) {
                     LOG.trace("Building cache for entity data [" + model.getEntityName() + "]");
 					EntityRegion entityRegion = settings.getRegionFactory().buildEntityRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
 					accessStrategy = entityRegion.buildAccessStrategy( accessType );
 					entityAccessStrategies.put( cacheRegionName, accessStrategy );
 					allCacheRegions.put( cacheRegionName, entityRegion );
 				}
 			}
 			EntityPersister cp = serviceRegistry.getService( PersisterFactory.class ).createEntityPersister(
 					model,
 					accessStrategy,
 					this,
 					mapping
 			);
 			entityPersisters.put( model.getEntityName(), cp );
 			classMeta.put( model.getEntityName(), cp.getClassMetadata() );
 		}
 		this.classMetadata = Collections.unmodifiableMap(classMeta);
 
 		Map<String,Set<String>> tmpEntityToCollectionRoleMap = new HashMap<String,Set<String>>();
 		collectionPersisters = new HashMap();
 		Iterator collections = cfg.getCollectionMappings();
 		while ( collections.hasNext() ) {
 			Collection model = (Collection) collections.next();
 			final String cacheRegionName = cacheRegionPrefix + model.getCacheRegionName();
 			final AccessType accessType = AccessType.fromExternalName( model.getCacheConcurrencyStrategy() );
 			CollectionRegionAccessStrategy accessStrategy = null;
 			if ( accessType != null && settings.isSecondLevelCacheEnabled() ) {
                 LOG.trace("Building cache for collection data [" + model.getRole() + "]");
 				CollectionRegion collectionRegion = settings.getRegionFactory().buildCollectionRegion( cacheRegionName, properties, CacheDataDescriptionImpl
 						.decode( model ) );
 				accessStrategy = collectionRegion.buildAccessStrategy( accessType );
 				entityAccessStrategies.put( cacheRegionName, accessStrategy );
 				allCacheRegions.put( cacheRegionName, collectionRegion );
 			}
 			CollectionPersister persister = serviceRegistry.getService( PersisterFactory.class ).createCollectionPersister(
 					cfg,
 					model,
 					accessStrategy,
 					this
 			) ;
 			collectionPersisters.put( model.getRole(), persister.getCollectionMetadata() );
 			Type indexType = persister.getIndexType();
 			if ( indexType != null && indexType.isAssociationType() && !indexType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) indexType ).getAssociatedEntityName( this );
 				Set roles = tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 			Type elementType = persister.getElementType();
 			if ( elementType.isAssociationType() && !elementType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) elementType ).getAssociatedEntityName( this );
 				Set roles = tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 		}
 		collectionMetadata = Collections.unmodifiableMap(collectionPersisters);
 		Iterator itr = tmpEntityToCollectionRoleMap.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			entry.setValue( Collections.unmodifiableSet( ( Set ) entry.getValue() ) );
 		}
 		collectionRolesByEntityParticipant = Collections.unmodifiableMap( tmpEntityToCollectionRoleMap );
 
 		//Named Queries:
 		namedQueries = new HashMap<String, NamedQueryDefinition>( cfg.getNamedQueries() );
 		namedSqlQueries = new HashMap<String, NamedSQLQueryDefinition>( cfg.getNamedSQLQueries() );
 		sqlResultSetMappings = new HashMap<String, ResultSetMappingDefinition>( cfg.getSqlResultSetMappings() );
 		imports = new HashMap<String,String>( cfg.getImports() );
 
 		// after *all* persisters and named queries are registered
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			final EntityPersister persister = ( ( EntityPersister ) iter.next() );
 			persister.postInstantiate();
 			registerEntityNameResolvers( persister );
 
 		}
 		iter = collectionPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			final CollectionPersister persister = ( ( CollectionPersister ) iter.next() );
 			persister.postInstantiate();
 		}
 
 		//JNDI + Serialization:
 
 		name = settings.getSessionFactoryName();
 		try {
 			uuid = (String) UUID_GENERATOR.generate(null, null);
 		}
 		catch (Exception e) {
 			throw new AssertionFailure("Could not generate UUID");
 		}
 		SessionFactoryRegistry.INSTANCE.addSessionFactory( uuid, name, this, serviceRegistry.getService( JndiService.class ) );
 
         LOG.debugf("Instantiated session factory");
 
 		if ( settings.isAutoCreateSchema() ) {
 			new SchemaExport( serviceRegistry, cfg ).create( false, true );
 		}
 		if ( settings.isAutoUpdateSchema() ) {
 			new SchemaUpdate( serviceRegistry, cfg ).execute( false, true );
 		}
 		if ( settings.isAutoValidateSchema() ) {
 			new SchemaValidator( serviceRegistry, cfg ).validate();
 		}
 		if ( settings.isAutoDropSchema() ) {
 			schemaExport = new SchemaExport( serviceRegistry, cfg );
 		}
 
 		currentSessionContext = buildCurrentSessionContext();
 
 		if ( settings.isQueryCacheEnabled() ) {
 			updateTimestampsCache = new UpdateTimestampsCache(settings, properties);
 			queryCache = settings.getQueryCacheFactory()
 			        .getQueryCache(null, updateTimestampsCache, settings, properties);
 			queryCaches = new HashMap<String,QueryCache>();
 			allCacheRegions.put( updateTimestampsCache.getRegion().getName(), updateTimestampsCache.getRegion() );
 			allCacheRegions.put( queryCache.getRegion().getName(), queryCache.getRegion() );
 		}
 		else {
 			updateTimestampsCache = null;
 			queryCache = null;
 			queryCaches = null;
 		}
 
 		//checking for named queries
 		if ( settings.isNamedQueryStartupCheckingEnabled() ) {
 			Map errors = checkNamedQueries();
 			if ( !errors.isEmpty() ) {
 				Set keys = errors.keySet();
 				StringBuffer failingQueries = new StringBuffer( "Errors in named queries: " );
 				for ( Iterator iterator = keys.iterator() ; iterator.hasNext() ; ) {
 					String queryName = ( String ) iterator.next();
 					HibernateException e = ( HibernateException ) errors.get( queryName );
 					failingQueries.append( queryName );
                     if (iterator.hasNext()) failingQueries.append(", ");
                     LOG.namedQueryError(queryName, e);
 				}
 				throw new HibernateException( failingQueries.toString() );
 			}
 		}
 
 		// this needs to happen after persisters are all ready to go...
 		this.fetchProfiles = new HashMap();
 		itr = cfg.iterateFetchProfiles();
 		while ( itr.hasNext() ) {
 			final org.hibernate.mapping.FetchProfile mappingProfile =
 					( org.hibernate.mapping.FetchProfile ) itr.next();
 			final FetchProfile fetchProfile = new FetchProfile( mappingProfile.getName() );
 			Iterator fetches = mappingProfile.getFetches().iterator();
 			while ( fetches.hasNext() ) {
 				final org.hibernate.mapping.FetchProfile.Fetch mappingFetch =
 						( org.hibernate.mapping.FetchProfile.Fetch ) fetches.next();
 				// resolve the persister owning the fetch
 				final String entityName = getImportedClassName( mappingFetch.getEntity() );
 				final EntityPersister owner = ( EntityPersister ) ( entityName == null ? null : entityPersisters.get( entityName ) );
 				if ( owner == null ) {
 					throw new HibernateException(
 							"Unable to resolve entity reference [" + mappingFetch.getEntity()
 									+ "] in fetch profile [" + fetchProfile.getName() + "]"
 					);
 				}
 
 				// validate the specified association fetch
 				Type associationType = owner.getPropertyType( mappingFetch.getAssociation() );
 				if ( associationType == null || !associationType.isAssociationType() ) {
 					throw new HibernateException( "Fetch profile [" + fetchProfile.getName() + "] specified an invalid association" );
 				}
 
 				// resolve the style
 				final Fetch.Style fetchStyle = Fetch.Style.parse( mappingFetch.getStyle() );
 
 				// then construct the fetch instance...
 				fetchProfile.addFetch( new Association( owner, mappingFetch.getAssociation() ), fetchStyle );
 				( ( Loadable ) owner ).registerAffectingFetchProfile( fetchProfile.getName() );
 			}
 			fetchProfiles.put( fetchProfile.getName(), fetchProfile );
 		}
 
 		this.transactionEnvironment = new TransactionEnvironmentImpl( this );
 		this.observer.sessionFactoryCreated( this );
 	}
 
 	public SessionFactoryImpl(
 			MetadataImplementor metadata,
 			SessionFactoryOptions sessionFactoryOptions,
 			SessionFactoryObserver observer) throws HibernateException {
         LOG.debug( "Building session factory" );
 
 		// TODO: remove initialization of final variables; just setting to null to make compiler happy
 		this.name = null;
 		this.uuid = null;
 		this.fetchProfiles = null;
 		this.queryCache = null;
 		this.updateTimestampsCache = null;
 		this.queryCaches = null;
 		this.currentSessionContext = null;
 		this.sqlFunctionRegistry = null;
 		this.transactionEnvironment = null;
 
 		this.sessionFactoryOptions = sessionFactoryOptions;
 
 		this.properties = createPropertiesFromMap(
 				metadata.getServiceRegistry().getService( ConfigurationService.class ).getSettings()
 		);
 
 		// TODO: these should be moved into SessionFactoryOptions
 		this.settings = new SettingsFactory().buildSettings(
 				properties,
 				metadata.getServiceRegistry()
 		);
 
 		this.serviceRegistry =
 				metadata.getServiceRegistry()
 						.getService( SessionFactoryServiceRegistryFactory.class )
 						.buildServiceRegistry( this, metadata );
 
 		this.jdbcServices = this.serviceRegistry.getService( JdbcServices.class );
 		this.dialect = this.jdbcServices.getDialect();
 
 		// TODO: get SQL functions from a new service
 		// this.sqlFunctionRegistry = new SQLFunctionRegistry( getDialect(), cfg.getSqlFunctions() );
 
 		if ( observer != null ) {
 			this.observer.addObserver( observer );
 		}
 
 		this.typeResolver = metadata.getTypeResolver().scope( this );
 		this.typeHelper = new TypeLocatorImpl( typeResolver );
 
 		this.filters = new HashMap<String, FilterDefinition>();
 		for ( FilterDefinition filterDefinition : metadata.getFilterDefinitions() ) {
 			filters.put( filterDefinition.getFilterName(), filterDefinition );
 		}
 
         LOG.debugf("Session factory constructed with filter configurations : %s", filters);
         LOG.debugf("Instantiating session factory with properties: %s", properties );
 
 		// TODO: get RegionFactory from service registry
 		settings.getRegionFactory().start( settings, properties );
 		this.queryPlanCache = new QueryPlanCache( this );
 
 		class IntegratorObserver implements SessionFactoryObserver {
 			private ArrayList<Integrator> integrators = new ArrayList<Integrator>();
 
 			@Override
 			public void sessionFactoryCreated(SessionFactory factory) {
 			}
 
 			@Override
 			public void sessionFactoryClosed(SessionFactory factory) {
 				for ( Integrator integrator : integrators ) {
 					integrator.disintegrate( SessionFactoryImpl.this, SessionFactoryImpl.this.serviceRegistry );
 				}
 			}
 		}
 
 		final IntegratorObserver integratorObserver = new IntegratorObserver();
 		this.observer.addObserver( integratorObserver );
 		for ( Integrator integrator : serviceRegistry.getService( IntegratorService.class ).getIntegrators() ) {
 			// TODO: add Integrator.integrate(MetadataImplementor, ...)
 			// integrator.integrate( cfg, this, this.serviceRegistry );
 			integratorObserver.integrators.add( integrator );
 		}
 
 
 		//Generators:
 
 		identifierGenerators = new HashMap();
 		for ( EntityBinding entityBinding : metadata.getEntityBindings() ) {
 			if ( entityBinding.isRoot() ) {
 				// TODO: create the IdentifierGenerator while the metadata is being build, then simply
 				// use EntityBinding.getIdentifierGenerator() (also remove getIdentifierGeneratorFactory from Mappings)
 				// TODO: this is broken; throws NullPointerException
 				//IdentifierGenerator generator = entityBinding.getEntityIdentifier().createIdentifierGenerator(
 				//		metadata.getIdentifierGeneratorFactory()
 				//);
 				//identifierGenerators.put( entityBinding.getEntity().getName(), generator );
 			}
 		}
 
 		///////////////////////////////////////////////////////////////////////
 		// Prepare persisters and link them up with their cache
 		// region/access-strategy
 
 		StringBuilder stringBuilder = new StringBuilder();
 		if ( settings.getCacheRegionPrefix() != null) {
 			stringBuilder
 					.append( settings.getCacheRegionPrefix() )
 					.append( '.' );
 		}
 		final String cacheRegionPrefix = stringBuilder.toString();
 
 		entityPersisters = new HashMap();
 		Map<String, RegionAccessStrategy> entityAccessStrategies = new HashMap<String, RegionAccessStrategy>();
 		Map<String,ClassMetadata> classMeta = new HashMap<String,ClassMetadata>();
 		for ( EntityBinding model : metadata.getEntityBindings() ) {
 			// TODO: should temp table prep happen when metadata is being built?
 			//model.prepareTemporaryTables( metadata, getDialect() );
 			// cache region is defined by the root-class in the hierarchy...
 			EntityBinding rootEntityBinding = metadata.getRootEntityBinding( model.getEntity().getName() );
 			EntityRegionAccessStrategy accessStrategy = null;
 			if ( settings.isSecondLevelCacheEnabled() &&
 					rootEntityBinding.getCaching() != null &&
 					model.getCaching() != null &&
 					model.getCaching().getAccessType() != null ) {
 				final String cacheRegionName = cacheRegionPrefix + rootEntityBinding.getCaching().getRegion();
 				accessStrategy = EntityRegionAccessStrategy.class.cast( entityAccessStrategies.get( cacheRegionName ) );
 				if ( accessStrategy == null ) {
 					final AccessType accessType = model.getCaching().getAccessType();
 					LOG.trace("Building cache for entity data [" + model.getEntity().getName() + "]");
 					EntityRegion entityRegion =
 							settings.getRegionFactory().buildEntityRegion(
 									cacheRegionName,
 									properties,
 									CacheDataDescriptionImpl.decode( model )
 							);
 					accessStrategy = entityRegion.buildAccessStrategy( accessType );
 					entityAccessStrategies.put( cacheRegionName, accessStrategy );
 					allCacheRegions.put( cacheRegionName, entityRegion );
 				}
 			}
 			EntityPersister cp = serviceRegistry.getService( PersisterFactory.class ).createEntityPersister(
 					model, accessStrategy, this, metadata
 			);
 			entityPersisters.put( model.getEntity().getName(), cp );
 			classMeta.put( model.getEntity().getName(), cp.getClassMetadata() );
 		}
 		this.classMetadata = Collections.unmodifiableMap(classMeta);
 
 		Map<String,Set<String>> tmpEntityToCollectionRoleMap = new HashMap<String,Set<String>>();
 		collectionPersisters = new HashMap();
 		for ( PluralAttributeBinding model : metadata.getCollectionBindings() ) {
 			if ( model.getAttribute() == null ) {
 				throw new IllegalStateException( "No attribute defined for a PluralAttributeBinding: " +  model );
 			}
 			if ( model.getAttribute().isSingular() ) {
 				throw new IllegalStateException(
 						"PluralAttributeBinding has a Singular attribute defined: " + model.getAttribute().getName()
 				);
 			}
 			// TODO: Add PluralAttributeBinding.getCaching()
 			final String cacheRegionName = cacheRegionPrefix + model.getCacheRegionName();
 			final AccessType accessType = AccessType.fromExternalName( model.getCacheConcurrencyStrategy() );
 			CollectionRegionAccessStrategy accessStrategy = null;
 			if ( accessType != null && settings.isSecondLevelCacheEnabled() ) {
 				// TODO: is model.getAttribute().getName() the collection's role??? For now, assuming it is
                 LOG.trace("Building cache for collection data [" + model.getAttribute().getName() + "]");
 				CollectionRegion collectionRegion =
 						settings.getRegionFactory()
 								.buildCollectionRegion(
 										cacheRegionName, properties, CacheDataDescriptionImpl.decode( model )
 								);
 				accessStrategy = collectionRegion.buildAccessStrategy( accessType );
 				entityAccessStrategies.put( cacheRegionName, accessStrategy );
 				allCacheRegions.put( cacheRegionName, collectionRegion );
 			}
 			CollectionPersister persister =
 					serviceRegistry
 							.getService( PersisterFactory.class )
 							.createCollectionPersister( metadata, model, accessStrategy, this );
 			// TODO: is model.getAttribute().getName() the collection's role??? For now, assuming it is
 			collectionPersisters.put( model.getAttribute().getName(), persister.getCollectionMetadata() );
 			Type indexType = persister.getIndexType();
 			if ( indexType != null && indexType.isAssociationType() && !indexType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) indexType ).getAssociatedEntityName( this );
 				Set roles = tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 			Type elementType = persister.getElementType();
 			if ( elementType.isAssociationType() && !elementType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) elementType ).getAssociatedEntityName( this );
 				Set roles = tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 		}
 		collectionMetadata = Collections.unmodifiableMap(collectionPersisters);
 		Iterator itr = tmpEntityToCollectionRoleMap.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			entry.setValue( Collections.unmodifiableSet( ( Set ) entry.getValue() ) );
 		}
 		collectionRolesByEntityParticipant = Collections.unmodifiableMap( tmpEntityToCollectionRoleMap );
 
 		//Named Queries:
 		namedQueries = new HashMap<String,NamedQueryDefinition>();
 		for ( NamedQueryDefinition namedQueryDefinition :  metadata.getNamedQueryDefinitions() ) {
 			namedQueries.put( namedQueryDefinition.getName(), namedQueryDefinition );
 		}
 		namedSqlQueries = new HashMap<String, NamedSQLQueryDefinition>();
 		for ( NamedSQLQueryDefinition namedNativeQueryDefinition: metadata.getNamedNativeQueryDefinitions() ) {
 			namedSqlQueries.put( namedNativeQueryDefinition.getName(), namedNativeQueryDefinition );
 		}
 		sqlResultSetMappings = new HashMap<String, ResultSetMappingDefinition>();
 		for( ResultSetMappingDefinition resultSetMappingDefinition : metadata.getResultSetMappingDefinitions() ) {
 			sqlResultSetMappings.put( resultSetMappingDefinition.getName(), resultSetMappingDefinition );
 		}
 		imports = new HashMap<String,String>();
 		for ( Map.Entry<String,String> importEntry : metadata.getImports() ) {
 			imports.put( importEntry.getKey(), importEntry.getValue() );
 		}
 
 		// after *all* persisters and named queries are registered
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			final EntityPersister persister = ( ( EntityPersister ) iter.next() );
 			persister.postInstantiate();
 			registerEntityNameResolvers( persister );
 
 		}
 		iter = collectionPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			final CollectionPersister persister = ( ( CollectionPersister ) iter.next() );
 			persister.postInstantiate();
 		}
 
 		// TODO: implement
 	}
 
 	@SuppressWarnings( {"unchecked"} )
 	private static Properties createPropertiesFromMap(Map map) {
 		Properties properties = new Properties();
 		properties.putAll( map );
 		return properties;
 	}
 
 	public Session openSession() throws HibernateException {
 		return withOptions().openSession();
 	}
 
 	public Session openTemporarySession() throws HibernateException {
 		return withOptions()
 				.autoClose( false )
 				.flushBeforeCompletion( false )
 				.connectionReleaseMode( ConnectionReleaseMode.AFTER_STATEMENT )
 				.openSession();
 	}
 
 	public Session getCurrentSession() throws HibernateException {
 		if ( currentSessionContext == null ) {
 			throw new HibernateException( "No CurrentSessionContext configured!" );
 		}
 		return currentSessionContext.currentSession();
 	}
 
 	@Override
 	public SessionBuilder withOptions() {
 		return new SessionBuilderImpl( this );
 	}
 
 	@Override
 	public StatelessSessionBuilder withStatelessOptions() {
 		return new StatelessSessionBuilderImpl( this );
 	}
 
 	public StatelessSession openStatelessSession() {
 		return withStatelessOptions().openStatelessSession();
 	}
 
 	public StatelessSession openStatelessSession(Connection connection) {
 		return withStatelessOptions().connection( connection ).openStatelessSession();
 	}
 
 	@Override
 	public void addObserver(SessionFactoryObserver observer) {
 		this.observer.addObserver( observer );
 	}
 
 	public TransactionEnvironment getTransactionEnvironment() {
 		return transactionEnvironment;
 	}
 
 	public Properties getProperties() {
 		return properties;
 	}
 
 	public IdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 		return null;
 	}
 
 	public TypeResolver getTypeResolver() {
 		return typeResolver;
 	}
 
 	private void registerEntityNameResolvers(EntityPersister persister) {
 		if ( persister.getEntityMetamodel() == null || persister.getEntityMetamodel().getTuplizer() == null ) {
 			return;
 		}
 		registerEntityNameResolvers( persister.getEntityMetamodel().getTuplizer() );
 	}
 
 	private void registerEntityNameResolvers(EntityTuplizer tuplizer) {
 		EntityNameResolver[] resolvers = tuplizer.getEntityNameResolvers();
 		if ( resolvers == null ) {
 			return;
 		}
 
 		for ( EntityNameResolver resolver : resolvers ) {
 			registerEntityNameResolver( resolver );
 		}
 	}
 
 	private static final Object ENTITY_NAME_RESOLVER_MAP_VALUE = new Object();
 
 	public void registerEntityNameResolver(EntityNameResolver resolver) {
 		entityNameResolvers.put( resolver, ENTITY_NAME_RESOLVER_MAP_VALUE );
 	}
 
 	public Iterable<EntityNameResolver> iterateEntityNameResolvers() {
 		return entityNameResolvers.keySet();
 	}
 
 	public QueryPlanCache getQueryPlanCache() {
 		return queryPlanCache;
 	}
 
 	private Map checkNamedQueries() throws HibernateException {
 		Map errors = new HashMap();
 
 		// Check named HQL queries
 		if(LOG.isDebugEnabled())
         LOG.debugf("Checking %s named HQL queries", namedQueries.size());
 		Iterator itr = namedQueries.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			final String queryName = ( String ) entry.getKey();
 			final NamedQueryDefinition qd = ( NamedQueryDefinition ) entry.getValue();
 			// this will throw an error if there's something wrong.
 			try {
                 LOG.debugf("Checking named query: %s", queryName);
 				//TODO: BUG! this currently fails for named queries for non-POJO entities
 				queryPlanCache.getHQLQueryPlan( qd.getQueryString(), false, CollectionHelper.EMPTY_MAP );
 			}
 			catch ( QueryException e ) {
 				errors.put( queryName, e );
 			}
 			catch ( MappingException e ) {
 				errors.put( queryName, e );
 			}
 		}
 		if(LOG.isDebugEnabled())
         LOG.debugf("Checking %s named SQL queries", namedSqlQueries.size());
 		itr = namedSqlQueries.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			final String queryName = ( String ) entry.getKey();
 			final NamedSQLQueryDefinition qd = ( NamedSQLQueryDefinition ) entry.getValue();
 			// this will throw an error if there's something wrong.
 			try {
                 LOG.debugf("Checking named SQL query: %s", queryName);
 				// TODO : would be really nice to cache the spec on the query-def so as to not have to re-calc the hash;
 				// currently not doable though because of the resultset-ref stuff...
 				NativeSQLQuerySpecification spec;
 				if ( qd.getResultSetRef() != null ) {
 					ResultSetMappingDefinition definition = ( ResultSetMappingDefinition ) sqlResultSetMappings.get( qd.getResultSetRef() );
 					if ( definition == null ) {
 						throw new MappingException( "Unable to find resultset-ref definition: " + qd.getResultSetRef() );
 					}
 					spec = new NativeSQLQuerySpecification(
 							qd.getQueryString(),
 					        definition.getQueryReturns(),
 					        qd.getQuerySpaces()
 					);
 				}
 				else {
 					spec =  new NativeSQLQuerySpecification(
 							qd.getQueryString(),
 					        qd.getQueryReturns(),
 					        qd.getQuerySpaces()
 					);
 				}
 				queryPlanCache.getNativeSQLQueryPlan( spec );
 			}
 			catch ( QueryException e ) {
 				errors.put( queryName, e );
 			}
 			catch ( MappingException e ) {
 				errors.put( queryName, e );
 			}
 		}
 
 		return errors;
 	}
 
 	public EntityPersister getEntityPersister(String entityName) throws MappingException {
 		EntityPersister result = (EntityPersister) entityPersisters.get(entityName);
 		if (result==null) {
 			throw new MappingException( "Unknown entity: " + entityName );
 		}
 		return result;
 	}
 
 	public CollectionPersister getCollectionPersister(String role) throws MappingException {
 		CollectionPersister result = (CollectionPersister) collectionPersisters.get(role);
 		if (result==null) {
 			throw new MappingException( "Unknown collection role: " + role );
 		}
 		return result;
 	}
 
 	public Settings getSettings() {
 		return settings;
 	}
 
 	@Override
 	public SessionFactoryOptions getSessionFactoryOptions() {
 		return sessionFactoryOptions;
 	}
 
 	public JdbcServices getJdbcServices() {
 		return jdbcServices;
 	}
 
 	public Dialect getDialect() {
 		if ( serviceRegistry == null ) {
 			throw new IllegalStateException( "Cannot determine dialect because serviceRegistry is null." );
 		}
 		return dialect;
 	}
 
 	public Interceptor getInterceptor() {
 		return sessionFactoryOptions.getInterceptor();
 	}
 
 	public SQLExceptionConverter getSQLExceptionConverter() {
 		return getSQLExceptionHelper().getSqlExceptionConverter();
 	}
 
 	public SqlExceptionHelper getSQLExceptionHelper() {
 		return getJdbcServices().getSqlExceptionHelper();
 	}
 
 	public Set<String> getCollectionRolesByEntityParticipant(String entityName) {
 		return collectionRolesByEntityParticipant.get( entityName );
 	}
 
 	@Override
 	public Reference getReference() throws NamingException {
 		// from javax.naming.Referenceable
         LOG.debug( "Returning a Reference to the SessionFactory" );
 		return new Reference(
 				SessionFactoryImpl.class.getName(),
 				new StringRefAddr("uuid", uuid),
 				SessionFactoryRegistry.ObjectFactoryImpl.class.getName(),
 				null
 		);
 	}
 
 	private Object readResolve() throws ObjectStreamException {
         LOG.trace("Resolving serialized SessionFactory");
 		// look for the instance by uuid
 		Object result = SessionFactoryRegistry.INSTANCE.getSessionFactory( uuid );
 		if ( result == null ) {
 			// in case we were deserialized in a different JVM, look for an instance with the same name
 			// (alternatively we could do an actual JNDI lookup here....)
 			result = SessionFactoryRegistry.INSTANCE.getNamedSessionFactory( name );
             if ( result == null ) {
 				throw new InvalidObjectException( "Could not find a SessionFactory [uuid=" + uuid + ",name=" + name + "]" );
 			}
             LOG.debugf("Resolved SessionFactory by name");
         }
 		else {
 			LOG.debugf("Resolved SessionFactory by UUID");
 		}
 		return result;
 	}
 
 	public NamedQueryDefinition getNamedQuery(String queryName) {
 		return (NamedQueryDefinition) namedQueries.get(queryName);
 	}
 
 	public NamedSQLQueryDefinition getNamedSQLQuery(String queryName) {
 		return (NamedSQLQueryDefinition) namedSqlQueries.get(queryName);
 	}
 
 	public ResultSetMappingDefinition getResultSetMapping(String resultSetName) {
 		return (ResultSetMappingDefinition) sqlResultSetMappings.get(resultSetName);
 	}
 
 	public Type getIdentifierType(String className) throws MappingException {
 		return getEntityPersister(className).getIdentifierType();
 	}
 	public String getIdentifierPropertyName(String className) throws MappingException {
 		return getEntityPersister(className).getIdentifierPropertyName();
 	}
 
 	private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
         LOG.trace( "Deserializing" );
 		in.defaultReadObject();
         LOG.debugf( "Deserialized: %s", uuid );
 	}
 
 	private void writeObject(ObjectOutputStream out) throws IOException {
         LOG.debugf("Serializing: %s", uuid);
 		out.defaultWriteObject();
         LOG.trace("Serialized");
 	}
 
 	public Type[] getReturnTypes(String queryString) throws HibernateException {
 		return queryPlanCache.getHQLQueryPlan( queryString, false, CollectionHelper.EMPTY_MAP ).getReturnMetadata().getReturnTypes();
 	}
 
 	public String[] getReturnAliases(String queryString) throws HibernateException {
 		return queryPlanCache.getHQLQueryPlan( queryString, false, CollectionHelper.EMPTY_MAP ).getReturnMetadata().getReturnAliases();
 	}
 
 	public ClassMetadata getClassMetadata(Class persistentClass) throws HibernateException {
 		return getClassMetadata( persistentClass.getName() );
 	}
 
 	public CollectionMetadata getCollectionMetadata(String roleName) throws HibernateException {
 		return (CollectionMetadata) collectionMetadata.get(roleName);
 	}
 
 	public ClassMetadata getClassMetadata(String entityName) throws HibernateException {
 		return classMetadata.get(entityName);
 	}
 
 	/**
 	 * Return the names of all persistent (mapped) classes that extend or implement the
 	 * given class or interface, accounting for implicit/explicit polymorphism settings
 	 * and excluding mapped subclasses/joined-subclasses of other classes in the result.
 	 */
 	public String[] getImplementors(String className) throws MappingException {
 
 		final Class clazz;
 		try {
 			clazz = ReflectHelper.classForName(className);
 		}
 		catch (ClassNotFoundException cnfe) {
 			return new String[] { className }; //for a dynamic-class
 		}
 
 		ArrayList results = new ArrayList();
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			//test this entity to see if we must query it
 			EntityPersister testPersister = (EntityPersister) iter.next();
 			if ( testPersister instanceof Queryable ) {
 				Queryable testQueryable = (Queryable) testPersister;
 				String testClassName = testQueryable.getEntityName();
 				boolean isMappedClass = className.equals(testClassName);
 				if ( testQueryable.isExplicitPolymorphism() ) {
 					if ( isMappedClass ) {
 						return new String[] {className}; //NOTE EARLY EXIT
 					}
 				}
 				else {
 					if (isMappedClass) {
 						results.add(testClassName);
 					}
 					else {
 						final Class mappedClass = testQueryable.getMappedClass();
 						if ( mappedClass!=null && clazz.isAssignableFrom( mappedClass ) ) {
 							final boolean assignableSuperclass;
 							if ( testQueryable.isInherited() ) {
 								Class mappedSuperclass = getEntityPersister( testQueryable.getMappedSuperclass() ).getMappedClass();
 								assignableSuperclass = clazz.isAssignableFrom(mappedSuperclass);
 							}
 							else {
 								assignableSuperclass = false;
 							}
 							if ( !assignableSuperclass ) {
 								results.add( testClassName );
 							}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataSources.java b/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataSources.java
index dc59dbbf46..21fdeb22ac 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataSources.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataSources.java
@@ -1,382 +1,382 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.jar.JarFile;
 import java.util.zip.ZipEntry;
 
 import org.jboss.logging.Logger;
 import org.w3c.dom.Document;
 import org.xml.sax.EntityResolver;
 
 import org.hibernate.cfg.EJB3DTDEntityResolver;
 import org.hibernate.cfg.EJB3NamingStrategy;
 import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.metamodel.binder.MappingException;
-import org.hibernate.metamodel.binder.MappingNotFoundException;
-import org.hibernate.metamodel.binder.Origin;
-import org.hibernate.metamodel.binder.SourceType;
-import org.hibernate.metamodel.binder.source.internal.JaxbHelper;
-import org.hibernate.metamodel.binder.source.internal.JaxbRoot;
-import org.hibernate.metamodel.binder.source.internal.MetadataBuilderImpl;
+import org.hibernate.metamodel.source.MappingException;
+import org.hibernate.metamodel.source.MappingNotFoundException;
+import org.hibernate.metamodel.source.Origin;
+import org.hibernate.metamodel.source.SourceType;
+import org.hibernate.metamodel.source.internal.JaxbHelper;
+import org.hibernate.metamodel.source.internal.JaxbRoot;
+import org.hibernate.metamodel.source.internal.MetadataBuilderImpl;
 import org.hibernate.service.BasicServiceRegistry;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 
 /**
  * @author Steve Ebersole
  */
 public class MetadataSources {
 	private static final Logger LOG = Logger.getLogger( MetadataSources.class );
 
 	private List<JaxbRoot> jaxbRootList = new ArrayList<JaxbRoot>();
 	private LinkedHashSet<Class<?>> annotatedClasses = new LinkedHashSet<Class<?>>();
 	private LinkedHashSet<String> annotatedPackages = new LinkedHashSet<String>();
 
 	private final JaxbHelper jaxbHelper;
 
 	private final BasicServiceRegistry serviceRegistry;
 	private final EntityResolver entityResolver;
 	private final NamingStrategy namingStrategy;
 
 	private final MetadataBuilderImpl metadataBuilder;
 
 	public MetadataSources(BasicServiceRegistry serviceRegistry) {
 		this( serviceRegistry, EJB3DTDEntityResolver.INSTANCE, EJB3NamingStrategy.INSTANCE );
 	}
 
 	public MetadataSources(BasicServiceRegistry serviceRegistry, EntityResolver entityResolver, NamingStrategy namingStrategy) {
 		this.serviceRegistry = serviceRegistry;
 		this.entityResolver = entityResolver;
 		this.namingStrategy = namingStrategy;
 
 		this.jaxbHelper = new JaxbHelper( this );
 		this.metadataBuilder = new MetadataBuilderImpl( this );
 	}
 
 	public List<JaxbRoot> getJaxbRootList() {
 		return jaxbRootList;
 	}
 
 	public Iterable<String> getAnnotatedPackages() {
 		return annotatedPackages;
 	}
 
 	public Iterable<Class<?>> getAnnotatedClasses() {
 		return annotatedClasses;
 	}
 
 	public BasicServiceRegistry getServiceRegistry() {
 		return serviceRegistry;
 	}
 
 	public NamingStrategy getNamingStrategy() {
 		return namingStrategy;
 	}
 
 	public MetadataBuilder getMetadataBuilder() {
 		return metadataBuilder;
 	}
 
 	public Metadata buildMetadata() {
 		return getMetadataBuilder().buildMetadata();
 	}
 
 	/**
 	 * Read metadata from the annotations attached to the given class.
 	 *
 	 * @param annotatedClass The class containing annotations
 	 *
 	 * @return this (for method chaining)
 	 */
 	public MetadataSources addAnnotatedClass(Class annotatedClass) {
 		annotatedClasses.add( annotatedClass );
 		return this;
 	}
 
 	/**
 	 * Read package-level metadata.
 	 *
 	 * @param packageName java package name without trailing '.', cannot be {@code null}
 	 *
 	 * @return this (for method chaining)
 	 */
 	public MetadataSources addPackage(String packageName) {
 		if ( packageName == null ) {
 			throw new IllegalArgumentException( "The specified package name cannot be null" );
 		}
 		if ( packageName.endsWith( "." ) ) {
 			packageName = packageName.substring( 0, packageName.length() - 1 );
 		}
 		annotatedPackages.add( packageName );
 		return this;
 	}
 
 	/**
 	 * Read mappings as a application resourceName (i.e. classpath lookup).
 	 *
 	 * @param name The resource name
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addResource(String name) {
 		LOG.tracef( "reading mappings from resource : %s", name );
 
 		final Origin origin = new Origin( SourceType.RESOURCE, name );
 		InputStream resourceInputStream = classLoaderService().locateResourceStream( name );
 		if ( resourceInputStream == null ) {
 			throw new MappingNotFoundException( origin );
 		}
 		add( resourceInputStream, origin, true );
 
 		return this;
 	}
 
 	private ClassLoaderService classLoaderService() {
 		return serviceRegistry.getService( ClassLoaderService.class );
 	}
 
 	private JaxbRoot add(InputStream inputStream, Origin origin, boolean close) {
 		try {
 			JaxbRoot jaxbRoot = jaxbHelper.unmarshal( inputStream, origin );
 			jaxbRootList.add( jaxbRoot );
 			return jaxbRoot;
 		}
 		finally {
 			if ( close ) {
 				try {
 					inputStream.close();
 				}
 				catch ( IOException ignore ) {
 					LOG.trace( "Was unable to close input stream" );
 				}
 			}
 		}
 	}
 
 	/**
 	 * Read a mapping as an application resource using the convention that a class named {@code foo.bar.Foo} is
 	 * mapped by a file named {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 	 *
 	 * @param entityClass The mapped class. Cannot be {@code null} null.
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addClass(Class entityClass) {
 		if ( entityClass == null ) {
 			throw new IllegalArgumentException( "The specified class cannot be null" );
 		}
 		LOG.debugf( "adding resource mappings from class convention : %s", entityClass.getName() );
 		final String mappingResourceName = entityClass.getName().replace( '.', '/' ) + ".hbm.xml";
 		addResource( mappingResourceName );
 		return this;
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param path The path to a file.  Expected to be resolvable by {@link File#File(String)}
 	 *
 	 * @return this (for method chaining purposes)
 	 *
 	 * @see #addFile(java.io.File)
 	 */
 	public MetadataSources addFile(String path) {
 		return addFile( new File( path ) );
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param file The reference to the XML file
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addFile(File file) {
 		final String name = file.getAbsolutePath();
 		LOG.tracef( "reading mappings from file : %s", name );
 		final Origin origin = new Origin( SourceType.FILE, name );
 		try {
 			add( new FileInputStream( file ), origin, true );
 		}
 		catch ( FileNotFoundException e ) {
 			throw new MappingNotFoundException( e, origin );
 		}
 		return this;
 	}
 
 	/**
 	 * See {@link #addCacheableFile(java.io.File)} for description
 	 *
 	 * @param path The path to a file.  Expected to be resolvable by {@link File#File(String)}
 	 *
 	 * @return this (for method chaining purposes)
 	 *
 	 * @see #addCacheableFile(java.io.File)
 	 */
 	public MetadataSources addCacheableFile(String path) {
 		return this; // todo : implement method body
 	}
 
 	/**
 	 * Add a cached mapping file.  A cached file is a serialized representation of the DOM structure of a
 	 * particular mapping.  It is saved from a previous call as a file with the name {@code {xmlFile}.bin}
 	 * where {@code {xmlFile}} is the name of the original mapping file.
 	 * </p>
 	 * If a cached {@code {xmlFile}.bin} exists and is newer than {@code {xmlFile}}, the {@code {xmlFile}.bin}
 	 * file will be read directly. Otherwise {@code {xmlFile}} is read and then serialized to {@code {xmlFile}.bin} for
 	 * use the next time.
 	 *
 	 * @param file The cacheable mapping file to be added, {@code {xmlFile}} in above discussion.
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addCacheableFile(File file) {
 		return this; // todo : implement method body
 	}
 
 	/**
 	 * Read metadata from an {@link InputStream}.
 	 *
 	 * @param xmlInputStream The input stream containing a DOM.
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addInputStream(InputStream xmlInputStream) {
 		add( xmlInputStream, new Origin( SourceType.INPUT_STREAM, "<unknown>" ), false );
 		return this;
 	}
 
 	/**
 	 * Read mappings from a {@link URL}
 	 *
 	 * @param url The url for the mapping document to be read.
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addURL(URL url) {
 		final String urlExternalForm = url.toExternalForm();
 		LOG.debugf( "Reading mapping document from URL : %s", urlExternalForm );
 
 		final Origin origin = new Origin( SourceType.URL, urlExternalForm );
 		try {
 			add( url.openStream(), origin, true );
 		}
 		catch ( IOException e ) {
 			throw new MappingNotFoundException( "Unable to open url stream [" + urlExternalForm + "]", e, origin );
 		}
 		return this;
 	}
 
 	/**
 	 * Read mappings from a DOM {@link Document}
 	 *
 	 * @param document The DOM document
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addDocument(Document document) {
 		final Origin origin = new Origin( SourceType.DOM, "<unknown>" );
 		JaxbRoot jaxbRoot = jaxbHelper.unmarshal( document, origin );
 		jaxbRootList.add( jaxbRoot );
 		return this;
 	}
 
 	/**
 	 * Read all mappings from a jar file.
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param jar a jar file
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addJar(File jar) {
 		LOG.debugf( "Seeking mapping documents in jar file : %s", jar.getName() );
 		final Origin origin = new Origin( SourceType.JAR, jar.getAbsolutePath() );
 		try {
 			JarFile jarFile = new JarFile( jar );
 			try {
 				Enumeration jarEntries = jarFile.entries();
 				while ( jarEntries.hasMoreElements() ) {
 					final ZipEntry zipEntry = (ZipEntry) jarEntries.nextElement();
 					if ( zipEntry.getName().endsWith( ".hbm.xml" ) ) {
 						LOG.tracef( "found mapping document : %s", zipEntry.getName() );
 						try {
 							add( jarFile.getInputStream( zipEntry ), origin, true );
 						}
 						catch ( Exception e ) {
 							throw new MappingException( "could not read mapping documents", e, origin );
 						}
 					}
 				}
 			}
 			finally {
 				try {
 					jarFile.close();
 				}
 				catch ( Exception ignore ) {
 				}
 			}
 		}
 		catch ( IOException e ) {
 			throw new MappingNotFoundException( e, origin );
 		}
 		return this;
 	}
 
 	/**
 	 * Read all mapping documents from a directory tree.
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param dir The directory
 	 *
 	 * @return this (for method chaining purposes)
 	 *
 	 * @throws org.hibernate.MappingException Indicates problems reading the jar file or
 	 * processing the contained mapping documents.
 	 */
 	public MetadataSources addDirectory(File dir) {
 		File[] files = dir.listFiles();
 		for ( File file : files ) {
 			if ( file.isDirectory() ) {
 				addDirectory( file );
 			}
 			else if ( file.getName().endsWith( ".hbm.xml" ) ) {
 				addFile( file );
 			}
 		}
 		return this;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/DiscriminatorSubClassEntityDescriptor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/DiscriminatorSubClassEntityDescriptor.java
deleted file mode 100644
index 806eb16631..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/DiscriminatorSubClassEntityDescriptor.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binder.source;
-
-/**
- * @author Steve Ebersole
- */
-public interface DiscriminatorSubClassEntityDescriptor extends EntityDescriptor {
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/EntityDescriptor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/EntityDescriptor.java
deleted file mode 100644
index b1b6399b77..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/EntityDescriptor.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binder.source;
-
-import java.util.Set;
-
-import org.hibernate.EntityMode;
-import org.hibernate.metamodel.binding.Caching;
-import org.hibernate.metamodel.binding.CustomSQL;
-import org.hibernate.metamodel.binding.InheritanceType;
-import org.hibernate.metamodel.domain.Hierarchical;
-import org.hibernate.persister.entity.EntityPersister;
-import org.hibernate.tuple.entity.EntityTuplizer;
-
-/**
- * Represents the normalized set of mapping information about a specific entity.
- *
- * @author Gail Badner
- * @author Steve Ebersole
- */
-public interface EntityDescriptor extends UnifiedDescriptorObject {
-	/**
-	 * Obtain the Hibernate entity name.
-	 *
-	 * @return The entity name.
-	 */
-	public String getEntityName();
-
-	/**
-	 * Obtain the JPA entity name.
-	 *
-	 * @return  The JPA entity name
-	 */
-	public String getJpaEntityName();
-
-	/**
-	 * Obtain the entity mode represented by this state.
-	 *
-	 * @return The entity mode.
-	 */
-	public EntityMode getEntityMode();
-
-	/**
-	 * Obtain the name of the entity class.
-	 *
-	 * @return The entity class name.
-	 */
-	public String getClassName();
-
-	/**
-	 * The name of an interface to use for creating instance proxies for this entity.
-	 *
-	 * @return The name of the proxy interface.
-	 */
-	public String getProxyInterfaceName();
-
-	/**
-	 * Obtains the type of inheritance defined for this entity hierarchy
-	 *
-	 * @return The inheritance strategy for this entity.
-	 */
-	public InheritanceType getEntityInheritanceType();
-
-	/**
-	 * Obtain the super type for this entity.
-	 *
-	 * @return This entity's super type.
-	 */
-	public String getSuperEntityName();
-
-	/**
-	 * Obtain the custom {@link EntityPersister} class defined in this mapping.  {@code null} indicates the default
-	 * should be used.
-	 *
-	 * @return The custom {@link EntityPersister} class to use; or {@code null}
-	 */
-	public Class<? extends EntityPersister> getCustomEntityPersisterClass();
-
-	/**
-	 * Obtain the custom {@link EntityTuplizer} class defined in this mapping.  {@code null} indicates the default
-	 * should be used.
-	 *
-	 * @return The custom {@link EntityTuplizer} class to use; or {@code null}
-	 */
-	public Class<? extends EntityTuplizer> getCustomEntityTuplizerClass();
-
-
-	boolean isLazy();
-
-	boolean isDynamicUpdate();
-
-	boolean isDynamicInsert();
-
-	int getBatchSize();
-
-	boolean isSelectBeforeUpdate();
-
-	Boolean isAbstract();
-
-	String getCustomLoaderName();
-
-	CustomSQL getCustomInsert();
-
-	CustomSQL getCustomUpdate();
-
-	CustomSQL getCustomDelete();
-
-	Set<String> getSynchronizedTableNames();
-
-
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/JoinedSubClassEntityDescriptor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/JoinedSubClassEntityDescriptor.java
deleted file mode 100644
index 1aef70103c..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/JoinedSubClassEntityDescriptor.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binder.source;
-
-/**
- * @author Steve Ebersole
- */
-public interface JoinedSubClassEntityDescriptor extends EntityDescriptor {
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/RootEntityDescriptor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/RootEntityDescriptor.java
deleted file mode 100644
index 5dd824d10e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/RootEntityDescriptor.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binder.source;
-
-import org.hibernate.engine.OptimisticLockStyle;
-import org.hibernate.metamodel.binding.Caching;
-
-/**
- * @author Steve Ebersole
- */
-public interface RootEntityDescriptor extends EntityDescriptor {
-	public boolean isMutable();
-
-	public boolean isExplicitPolymorphism();
-
-	public String getWhereFilter();
-
-	public String getRowId();
-
-	public Caching getCaching();
-
-	public OptimisticLockStyle getOptimisticLockStyle();
-
-	public TableDescriptor getBaseTable();
-
-	// todo : add ->
-	//		1) identifier descriptor
-	//		2) discriminator descriptor
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/TableDescriptor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/TableDescriptor.java
deleted file mode 100644
index 3383f55770..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/TableDescriptor.java
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binder.source;
-
-/**
- * @author Steve Ebersole
- */
-public interface TableDescriptor extends UnifiedDescriptorObject {
-	public String getExplicitSchemaName();
-	public String getExplicitCatalogName();
-	public String getTableName();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/UnifiedDescriptorObject.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/UnifiedDescriptorObject.java
deleted file mode 100644
index 76233a88df..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/UnifiedDescriptorObject.java
+++ /dev/null
@@ -1,35 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binder.source;
-
-import org.hibernate.metamodel.binder.Origin;
-
-/**
- * @author Steve Ebersole
- */
-public interface UnifiedDescriptorObject {
-	public Origin getOrigin();
-	public UnifiedDescriptorObject getContainingDescriptor();
-	public MetaAttributeContext getMetaAttributeContext();
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/UnionSubClassEntityDescriptor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/UnionSubClassEntityDescriptor.java
deleted file mode 100644
index f8883f4b35..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/UnionSubClassEntityDescriptor.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binder.source;
-
-/**
- * @author Steve Ebersole
- */
-public interface UnionSubClassEntityDescriptor extends EntityDescriptor {
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/AbstractEntityDescriptorImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/AbstractEntityDescriptorImpl.java
deleted file mode 100644
index a638fc664b..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/AbstractEntityDescriptorImpl.java
+++ /dev/null
@@ -1,358 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binder.source.annotations;
-
-import java.util.Arrays;
-import java.util.HashSet;
-import java.util.Set;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationValue;
-
-import org.hibernate.EntityMode;
-import org.hibernate.annotations.ResultCheckStyle;
-import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
-import org.hibernate.metamodel.binder.Origin;
-import org.hibernate.metamodel.binder.source.EntityDescriptor;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
-import org.hibernate.metamodel.binder.source.UnifiedDescriptorObject;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClass;
-import org.hibernate.metamodel.binding.CustomSQL;
-import org.hibernate.metamodel.binding.InheritanceType;
-import org.hibernate.persister.entity.EntityPersister;
-import org.hibernate.tuple.entity.EntityTuplizer;
-
-/**
- * @author Steve Ebersole
- */
-public abstract class AbstractEntityDescriptorImpl implements EntityDescriptor {
-	private final ConfiguredClass configuredClass;
-	@SuppressWarnings( {"FieldCanBeLocal", "UnusedDeclaration"}) // for now this is not used.
-	private final AnnotationsBindingContext bindingContext;
-
-	private final String jpaEntityName;
-
-	private final String superEntityName;
-	private final InheritanceType inheritanceType;
-
-	private final boolean lazy;
-	private final String proxyInterfaceName;
-
-	private final Class<EntityPersister> entityPersisterClass;
-	private final Class<EntityTuplizer> tuplizerClass;
-
-	private final int batchSize;
-
-	private final boolean dynamicUpdate;
-	private final boolean dynamicInsert;
-
-	private final boolean selectBeforeUpdate;
-
-	private final String customLoaderName;
-	private final CustomSQL customInsert;
-	private final CustomSQL customUpdate;
-	private final CustomSQL customDelete;
-
-	private final Set<String> synchronizedTableNames;
-
-	public AbstractEntityDescriptorImpl(
-			ConfiguredClass configuredClass,
-			String superEntityName,
-			InheritanceType inheritanceType,
-			AnnotationsBindingContext bindingContext) {
-		this.configuredClass = configuredClass;
-		this.superEntityName = superEntityName;
-		this.inheritanceType = inheritanceType;
-		this.bindingContext = bindingContext;
-
-		final AnnotationInstance jpaEntityAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), JPADotNames.ENTITY
-		);
-
-		final AnnotationValue explicitJpaEntityName = jpaEntityAnnotation.value( "name" );
-		if ( explicitJpaEntityName == null ) {
-			jpaEntityName = configuredClass.getName();
-		}
-		else {
-			jpaEntityName = explicitJpaEntityName.asString();
-		}
-
-		final AnnotationInstance hibernateEntityAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.ENTITY
-		);
-
-		this.dynamicInsert = hibernateEntityAnnotation != null
-				&& hibernateEntityAnnotation.value( "dynamicInsert" ) != null
-				&& hibernateEntityAnnotation.value( "dynamicInsert" ).asBoolean();
-
-		this.dynamicUpdate = hibernateEntityAnnotation != null
-				&& hibernateEntityAnnotation.value( "dynamicUpdate" ) != null
-				&& hibernateEntityAnnotation.value( "dynamicUpdate" ).asBoolean();
-
-		this.selectBeforeUpdate = hibernateEntityAnnotation != null
-				&& hibernateEntityAnnotation.value( "selectBeforeUpdate" ) != null
-				&& hibernateEntityAnnotation.value( "selectBeforeUpdate" ).asBoolean();
-
-		final AnnotationInstance sqlLoaderAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.LOADER
-		);
-		this.customLoaderName = sqlLoaderAnnotation == null
-				? null
-				: sqlLoaderAnnotation.value( "namedQuery" ).asString();
-		final AnnotationInstance sqlInsertAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.SQL_INSERT
-		);
-		this.customInsert = createCustomSQL( sqlInsertAnnotation );
-		final AnnotationInstance sqlUpdateAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.SQL_UPDATE
-		);
-		this.customUpdate = createCustomSQL( sqlUpdateAnnotation );
-		final AnnotationInstance sqlDeleteAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.SQL_DELETE
-		);
-		this.customDelete = createCustomSQL( sqlDeleteAnnotation );
-
-		final AnnotationInstance batchSizeAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.BATCH_SIZE
-		);
-		this.batchSize = batchSizeAnnotation == null
-				? -1
-				: batchSizeAnnotation.value( "size" ).asInt();
-
-		final AnnotationInstance hibernateProxyAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.PROXY
-		);
-		if ( hibernateProxyAnnotation != null ) {
-			this.lazy = hibernateProxyAnnotation.value( "lazy" ) == null
-					|| hibernateProxyAnnotation.value( "lazy" ).asBoolean();
-			final AnnotationValue proxyClassValue = hibernateProxyAnnotation.value( "proxyClass" );
-			if ( proxyClassValue == null ) {
-				this.proxyInterfaceName = null;
-			}
-			else {
-				this.proxyInterfaceName = bindingContext.locateClassByName( proxyClassValue.asString() ).getName();
-			}
-		}
-		else {
-			this.lazy = true;
-			this.proxyInterfaceName = configuredClass.getName();
-		}
-
-		final AnnotationInstance persisterAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.PERSISTER
-		);
-		if ( persisterAnnotation == null || persisterAnnotation.value( "impl" ) == null ) {
-			if ( hibernateEntityAnnotation != null && hibernateEntityAnnotation.value( "persister" ) != null ) {
-				this.entityPersisterClass = bindingContext.locateClassByName( hibernateEntityAnnotation.value( "persister" ).asString() );
-			}
-			else {
-				this.entityPersisterClass = null;
-			}
-		}
-		else {
-			if ( hibernateEntityAnnotation != null && hibernateEntityAnnotation.value( "persister" ) != null ) {
-				// todo : error?
-			}
-			this.entityPersisterClass = bindingContext.locateClassByName( persisterAnnotation.value( "impl" ).asString() );
-		}
-
-		final AnnotationInstance pojoTuplizerAnnotation = locatePojoTuplizerAnnotation();
-		if ( pojoTuplizerAnnotation == null ) {
-			tuplizerClass = null;
-		}
-		else {
-			tuplizerClass = bindingContext.locateClassByName( pojoTuplizerAnnotation.value( "impl" ).asString() );
-		}
-
-		final AnnotationInstance synchronizeAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.SYNCHRONIZE
-		);
-		if ( synchronizeAnnotation != null ) {
-			synchronizedTableNames = new HashSet<String>();
-			final String[] tableNames = synchronizeAnnotation.value().asStringArray();
-			synchronizedTableNames.addAll( Arrays.asList( tableNames ) );
-		}
-		else {
-			synchronizedTableNames = java.util.Collections.emptySet();
-		}
-	}
-
-	private CustomSQL createCustomSQL(AnnotationInstance customSQLAnnotation) {
-		if ( customSQLAnnotation == null ) {
-			return null;
-		}
-
-		String sql = customSQLAnnotation.value( "sql" ).asString();
-		boolean isCallable = false;
-		AnnotationValue callableValue = customSQLAnnotation.value( "callable" );
-		if ( callableValue != null ) {
-			isCallable = callableValue.asBoolean();
-		}
-
-		ResultCheckStyle checkStyle = ResultCheckStyle.NONE;
-		AnnotationValue checkStyleValue = customSQLAnnotation.value( "check" );
-		if ( checkStyleValue != null ) {
-			checkStyle = Enum.valueOf( ResultCheckStyle.class, checkStyleValue.asEnum() );
-		}
-
-		return new CustomSQL(
-				sql,
-				isCallable,
-				Enum.valueOf( ExecuteUpdateResultCheckStyle.class, checkStyle.toString() )
-		);
-	}
-
-	private AnnotationInstance locatePojoTuplizerAnnotation() {
-		final AnnotationInstance tuplizersAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.SYNCHRONIZE
-		);
-		if ( tuplizersAnnotation == null ) {
-			return null;
-		}
-
-		for ( AnnotationInstance tuplizerAnnotation : JandexHelper.getValueAsArray(tuplizersAnnotation, "value" ) ) {
-			if ( EntityMode.valueOf( tuplizerAnnotation.value( "entityModeType" ).asEnum() ) == EntityMode.POJO ) {
-				return tuplizerAnnotation;
-			}
-		}
-
-		return null;
-	}
-
-	@Override
-	public String getClassName() {
-		return configuredClass.getName();
-	}
-
-	@Override
-	public String getEntityName() {
-		return getClassName();
-	}
-
-	@Override
-	public String getJpaEntityName() {
-		return jpaEntityName;
-	}
-
-	@Override
-	public EntityMode getEntityMode() {
-		return EntityMode.POJO;
-	}
-
-	@Override
-	public String getProxyInterfaceName() {
-		return proxyInterfaceName;
-	}
-
-	@Override
-	public Class<EntityPersister> getCustomEntityPersisterClass() {
-		return entityPersisterClass;
-	}
-
-	@Override
-	public Class<EntityTuplizer> getCustomEntityTuplizerClass() {
-		return tuplizerClass;
-	}
-
-	@Override
-	public String getSuperEntityName() {
-		return superEntityName;
-	}
-
-	@Override
-	public InheritanceType getEntityInheritanceType() {
-		return inheritanceType;
-	}
-
-	@Override
-	public MetaAttributeContext getMetaAttributeContext() {
-		return null;
-	}
-
-	@Override
-	public boolean isLazy() {
-		return lazy;
-	}
-
-	@Override
-	public boolean isDynamicUpdate() {
-		return dynamicUpdate;
-	}
-
-	@Override
-	public boolean isDynamicInsert() {
-		return dynamicInsert;
-	}
-
-	@Override
-	public int getBatchSize() {
-		return batchSize;
-	}
-
-	@Override
-	public boolean isSelectBeforeUpdate() {
-		return selectBeforeUpdate;
-	}
-
-	@Override
-	public Boolean isAbstract() {
-		return false;
-	}
-
-	@Override
-	public String getCustomLoaderName() {
-		return customLoaderName;
-	}
-
-	@Override
-	public CustomSQL getCustomInsert() {
-		return customInsert;
-	}
-
-	@Override
-	public CustomSQL getCustomUpdate() {
-		return customUpdate;
-	}
-
-	@Override
-	public CustomSQL getCustomDelete() {
-		return customDelete;
-	}
-
-	@Override
-	public Set<String> getSynchronizedTableNames() {
-		return synchronizedTableNames;
-	}
-
-	@Override
-	public UnifiedDescriptorObject getContainingDescriptor() {
-		return null;
-	}
-
-	@Override
-	public Origin getOrigin() {
-//		return bindingContext.getOrigin();
-		return null;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/AnnotationsMetadataProcessor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/AnnotationsMetadataProcessor.java
deleted file mode 100644
index f5039cf2e2..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/AnnotationsMetadataProcessor.java
+++ /dev/null
@@ -1,131 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binder.source.annotations;
-
-import java.util.List;
-
-import org.jboss.jandex.AnnotationInstance;
-import org.jboss.jandex.AnnotationValue;
-import org.jboss.jandex.Index;
-
-import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.internal.util.Value;
-import org.hibernate.metamodel.binder.source.MappingDefaults;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClass;
-import org.hibernate.metamodel.binder.source.annotations.entity.EntityBinder;
-import org.hibernate.metamodel.binder.source.internal.OverriddenMappingDefaults;
-import org.hibernate.metamodel.domain.Type;
-import org.hibernate.service.ServiceRegistry;
-
-/**
- * @author Hardy Ferentschik
- * @author Steve Ebersole
- */
-public class AnnotationsMetadataProcessor implements AnnotationsBindingContext {
-	private final AnnotationsBindingContext parentBindingContext;
-	private final ConfiguredClass configuredClass;
-
-	private final MappingDefaults mappingDefaults;
-
-	private final EntityBinder entityBinder;
-
-	public AnnotationsMetadataProcessor(
-			AnnotationsBindingContext parentBindingContext,
-			ConfiguredClass configuredClass) {
-		this.parentBindingContext = parentBindingContext;
-		this.configuredClass = configuredClass;
-
-		String explicitSchemaName = null;
-		String explicitCatalogName = null;
-		AnnotationInstance tableAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(),
-				JPADotNames.TABLE
-		);
-		if ( tableAnnotation != null ) {
-			AnnotationValue schemaValue = tableAnnotation.value( "schema" );
-			explicitSchemaName = schemaValue != null ? schemaValue.asString() : null;
-			AnnotationValue catalogValue = tableAnnotation.value( "catalog" );
-			explicitCatalogName = catalogValue != null ? catalogValue.asString() : null;
-		}
-		this.mappingDefaults = new OverriddenMappingDefaults(
-				parentBindingContext.getMappingDefaults(),
-				null,			// packageName
-				explicitSchemaName,
-				explicitCatalogName,
-				null,			// idColumnName
-				null,			// discriminatorColumnName
-				null,			// cascade
-				null,			// property accessor
-				null			// association laziness
-		);
-
-		this.entityBinder = new EntityBinder( configuredClass, this );
-	}
-
-
-	public void processMappingMetadata(List<String> processedEntityNames) {
-		entityBinder.bind( processedEntityNames );
-	}
-
-	@Override
-	public Index getIndex() {
-		return parentBindingContext.getIndex();
-	}
-
-	@Override
-	public ServiceRegistry getServiceRegistry() {
-		return parentBindingContext.getServiceRegistry();
-	}
-
-	@Override
-	public NamingStrategy getNamingStrategy() {
-		return parentBindingContext.getNamingStrategy();
-	}
-
-	@Override
-	public MappingDefaults getMappingDefaults() {
-		return mappingDefaults;
-	}
-
-	@Override
-	public MetadataImplementor getMetadataImplementor() {
-		return parentBindingContext.getMetadataImplementor();
-	}
-
-	@Override
-	public <T> Class<T> locateClassByName(String name) {
-		return parentBindingContext.locateClassByName( name );
-	}
-
-	@Override
-	public Type makeJavaType(String className) {
-		return parentBindingContext.makeJavaType( className );
-	}
-
-	@Override
-	public Value<Class<?>> makeClassReference(String className) {
-		return parentBindingContext.makeClassReference( className );
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/RootEntityDescriptorImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/RootEntityDescriptorImpl.java
deleted file mode 100644
index 549a6c860d..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/RootEntityDescriptorImpl.java
+++ /dev/null
@@ -1,209 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binder.source.annotations;
-
-import javax.persistence.SharedCacheMode;
-
-import org.jboss.jandex.AnnotationInstance;
-
-import org.hibernate.annotations.CacheConcurrencyStrategy;
-import org.hibernate.annotations.OptimisticLockType;
-import org.hibernate.annotations.PolymorphismType;
-import org.hibernate.cache.spi.access.AccessType;
-import org.hibernate.engine.OptimisticLockStyle;
-import org.hibernate.metamodel.binder.source.RootEntityDescriptor;
-import org.hibernate.metamodel.binder.source.TableDescriptor;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClass;
-import org.hibernate.metamodel.binding.Caching;
-import org.hibernate.metamodel.binding.InheritanceType;
-
-/**
- * @author Steve Ebersole
- * @author Gail Badner
- * @author Hardy Ferentschik
- */
-public class RootEntityDescriptorImpl extends AbstractEntityDescriptorImpl implements RootEntityDescriptor {
-	private final boolean mutable;
-	private final boolean explicitPolymorphism;
-	private final String whereFilter;
-	private final String rowId;
-	private final Caching caching;
-	private final OptimisticLockStyle optimisticLockStyle;
-
-	private final TableDescriptor baseTableDescriptor;
-
-	public RootEntityDescriptorImpl(ConfiguredClass configuredClass, AnnotationsBindingContext bindingContext) {
-		super( configuredClass, null, InheritanceType.NO_INHERITANCE, bindingContext );
-
-		final AnnotationInstance hibernateEntityAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.ENTITY
-		);
-
-		OptimisticLockType optimisticLockType = OptimisticLockType.VERSION;
-		if ( hibernateEntityAnnotation != null && hibernateEntityAnnotation.value( "optimisticLock" ) != null ) {
-			optimisticLockType = OptimisticLockType.valueOf( hibernateEntityAnnotation.value( "optimisticLock" ).asEnum() );
-		}
-		this.optimisticLockStyle = OptimisticLockStyle.valueOf( optimisticLockType.name() );
-
-		final PolymorphismType polymorphism = hibernateEntityAnnotation != null && hibernateEntityAnnotation.value( "polymorphism" ) != null
-				? PolymorphismType.valueOf( hibernateEntityAnnotation.value( "polymorphism" ).asEnum() )
-				: PolymorphismType.IMPLICIT;
-		this.explicitPolymorphism = polymorphism != PolymorphismType.IMPLICIT;
-
-		final AnnotationInstance hibernateImmutableAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.IMMUTABLE
-		);
-		this.mutable = hibernateImmutableAnnotation == null
-				&& hibernateEntityAnnotation != null
-				&& hibernateEntityAnnotation.value( "mutable" ) != null
-				&& hibernateEntityAnnotation.value( "mutable" ).asBoolean();
-
-		final AnnotationInstance whereAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.WHERE
-		);
-		this.whereFilter = whereAnnotation != null && whereAnnotation.value( "clause" ) != null
-				? whereAnnotation.value( "clause" ).asString()
-				: null;
-
-		final AnnotationInstance rowIdAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.ROW_ID
-		);
-		this.rowId = rowIdAnnotation != null && rowIdAnnotation.value() != null
-				? rowIdAnnotation.value().asString()
-				: null;
-
-		this.caching = interpretCaching( configuredClass, bindingContext );
-
-		final AnnotationInstance tableAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), JPADotNames.TABLE
-		);
-		this.baseTableDescriptor = new TableDescriptorImpl(
-				tableAnnotation.value( "schema" ) == null
-						? null
-						: tableAnnotation.value( "schema" ).asString(),
-				tableAnnotation.value( "catalog" ) == null
-						? null
-						: tableAnnotation.value( "catalog" ).asString(),
-				tableAnnotation.value( "name" ) == null
-						? null
-						: tableAnnotation.value( "name" ).asString(),
-				this,
-				bindingContext
-		);
-	}
-
-	private Caching interpretCaching(ConfiguredClass configuredClass, AnnotationsBindingContext bindingContext) {
-		final AnnotationInstance hibernateCacheAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), HibernateDotNames.CACHE
-		);
-		if ( hibernateCacheAnnotation != null ) {
-			final AccessType accessType = hibernateCacheAnnotation.value( "usage" ) == null
-					? bindingContext.getMappingDefaults().getCacheAccessType()
-					: CacheConcurrencyStrategy.parse( hibernateCacheAnnotation.value( "usage" ).asEnum() ).toAccessType();
-			return new Caching(
-					hibernateCacheAnnotation.value( "region" ) == null
-							? configuredClass.getName()
-							: hibernateCacheAnnotation.value( "region" ).asString(),
-					accessType,
-					hibernateCacheAnnotation.value( "include" ) != null
-							&& "all".equals( hibernateCacheAnnotation.value( "include" ).asString() )
-			);
-		}
-
-		final AnnotationInstance jpaCacheableAnnotation = JandexHelper.getSingleAnnotation(
-				configuredClass.getClassInfo(), JPADotNames.CACHEABLE
-		);
-
-		boolean cacheable = true; // true is the default
-		if ( jpaCacheableAnnotation != null && jpaCacheableAnnotation.value() != null ) {
-			cacheable = jpaCacheableAnnotation.value().asBoolean();
-		}
-
-		final boolean doCaching;
-		switch ( bindingContext.getMetadataImplementor().getOptions().getSharedCacheMode() ) {
-			case ALL: {
-				doCaching = true;
-				break;
-			}
-			case ENABLE_SELECTIVE: {
-				doCaching = cacheable;
-				break;
-			}
-			case DISABLE_SELECTIVE: {
-				doCaching = jpaCacheableAnnotation == null || cacheable;
-				break;
-			}
-			default: {
-				// treat both NONE and UNSPECIFIED the same
-				doCaching = false;
-				break;
-			}
-		}
-
-		if ( ! doCaching ) {
-			return null;
-		}
-
-		return new Caching(
-				configuredClass.getName(),
-				bindingContext.getMappingDefaults().getCacheAccessType(),
-				true
-		);
-	}
-
-	@Override
-	public boolean isMutable() {
-		return mutable;
-	}
-
-	@Override
-	public boolean isExplicitPolymorphism() {
-		return explicitPolymorphism;
-	}
-
-	@Override
-	public String getWhereFilter() {
-		return whereFilter;
-	}
-
-	@Override
-	public String getRowId() {
-		return rowId;
-	}
-
-	@Override
-	public Caching getCaching() {
-		return caching;
-	}
-
-	@Override
-	public OptimisticLockStyle getOptimisticLockStyle() {
-		return optimisticLockStyle;
-	}
-
-	@Override
-	public TableDescriptor getBaseTable() {
-		return baseTableDescriptor;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/TableDescriptorImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/TableDescriptorImpl.java
deleted file mode 100644
index 12cb40ebdf..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/TableDescriptorImpl.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binder.source.annotations;
-
-import org.hibernate.metamodel.binder.Origin;
-import org.hibernate.metamodel.binder.source.EntityDescriptor;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
-import org.hibernate.metamodel.binder.source.TableDescriptor;
-import org.hibernate.metamodel.binder.source.UnifiedDescriptorObject;
-
-/**
- * @author Steve Ebersole
- */
-public class TableDescriptorImpl implements TableDescriptor {
-	private final String explicitSchemaName;
-	private final String explicitCatalogName;
-	private final String tableName;
-
-	private final EntityDescriptor entityDescriptor;
-	private final AnnotationsBindingContext bindingContext;
-
-	public TableDescriptorImpl(
-			String explicitSchemaName,
-			String explicitCatalogName,
-			String tableName,
-			EntityDescriptor entityDescriptor, AnnotationsBindingContext bindingContext) {
-		this.explicitSchemaName = explicitSchemaName;
-		this.explicitCatalogName = explicitCatalogName;
-		this.tableName = tableName;
-		this.entityDescriptor = entityDescriptor;
-		this.bindingContext = bindingContext;
-	}
-
-	@Override
-	public String getExplicitSchemaName() {
-		return explicitSchemaName;
-	}
-
-	@Override
-	public String getExplicitCatalogName() {
-		return explicitCatalogName;
-	}
-
-	@Override
-	public String getTableName() {
-		return tableName;
-	}
-
-	@Override
-	public Origin getOrigin() {
-//		return bindingContext.getOrigin();
-		return null;
-	}
-
-	@Override
-	public UnifiedDescriptorObject getContainingDescriptor() {
-		return entityDescriptor;
-	}
-
-	@Override
-	public MetaAttributeContext getMetaAttributeContext() {
-		return null;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/state/binding/AbstractEntityDescriptorImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/state/binding/AbstractEntityDescriptorImpl.java
deleted file mode 100644
index c0e00404f1..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/state/binding/AbstractEntityDescriptorImpl.java
+++ /dev/null
@@ -1,259 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binder.source.annotations.entity.state.binding;
-
-import java.util.HashSet;
-import java.util.Set;
-
-import org.hibernate.EntityMode;
-import org.hibernate.metamodel.binder.Origin;
-import org.hibernate.metamodel.binder.source.BindingContext;
-import org.hibernate.metamodel.binder.source.EntityDescriptor;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
-import org.hibernate.metamodel.binder.source.UnifiedDescriptorObject;
-import org.hibernate.metamodel.binding.CustomSQL;
-import org.hibernate.metamodel.binding.InheritanceType;
-import org.hibernate.metamodel.source.annotations.entity.EntityClass;
-import org.hibernate.persister.entity.EntityPersister;
-import org.hibernate.tuple.entity.EntityTuplizer;
-
-/**
- * @author Hardy Ferentschik
- */
-public abstract class AbstractEntityDescriptorImpl implements EntityDescriptor {
-	private final BindingContext bindingContext;
-
-	private final String className;
-	private final String superEntityName;
-	private final InheritanceType inheritanceType;
-
-	private String jpaEntityName;
-
-	private boolean lazy;
-	private String proxyInterfaceName;
-
-	private Class<? extends EntityPersister> persisterClass;
-	private Class<? extends EntityTuplizer> tuplizerClass;
-
-	private boolean dynamicUpdate;
-	private boolean dynamicInsert;
-
-	private int batchSize = -1;
-	private boolean selectBeforeUpdate;
-
-	private String customLoaderName;
-	private CustomSQL customInsert;
-	private CustomSQL customUpdate;
-	private CustomSQL customDelete;
-
-	private Set<String> synchronizedTableNames = new HashSet<String>();
-
-	public AbstractEntityDescriptorImpl(
-			EntityClass entityClass,
-			String superEntityName,
-			BindingContext bindingContext) {
-		this.bindingContext = bindingContext;
-
-		this.className = entityClass.getName();
-		this.superEntityName = superEntityName;
-		this.inheritanceType = entityClass.getInheritanceType();
-	}
-
-	@Override
-	public String getEntityName() {
-		return className;
-	}
-
-	@Override
-	public String getClassName() {
-		return className;
-	}
-
-	@Override
-	public String getJpaEntityName() {
-		return jpaEntityName;
-	}
-
-	public void setJpaEntityName(String entityName) {
-		this.jpaEntityName = entityName;
-	}
-
-	@Override
-	public EntityMode getEntityMode() {
-		return EntityMode.POJO;
-	}
-
-	@Override
-	public String getSuperEntityName() {
-		return superEntityName;
-	}
-
-	@Override
-	public InheritanceType getEntityInheritanceType() {
-		return inheritanceType;
-	}
-
-	@Override
-	public Boolean isAbstract() {
-		// no annotations equivalent
-		return Boolean.FALSE;
-	}
-
-	@Override
-	public boolean isLazy() {
-		return lazy;
-	}
-
-	public void setLazy(boolean lazy) {
-		this.lazy = lazy;
-	}
-
-	@Override
-	public String getProxyInterfaceName() {
-		return proxyInterfaceName;
-	}
-
-	public void setProxyInterfaceName(String proxyInterfaceName) {
-		this.proxyInterfaceName = proxyInterfaceName;
-	}
-
-	@Override
-	public Class<? extends EntityPersister> getCustomEntityPersisterClass() {
-		return persisterClass;
-	}
-
-	public void setPersisterClass(Class<? extends EntityPersister> persisterClass) {
-		this.persisterClass = persisterClass;
-	}
-
-	@Override
-	public Class<? extends EntityTuplizer> getCustomEntityTuplizerClass() {
-		return tuplizerClass;
-	}
-
-	public void setTuplizerClass(Class<? extends EntityTuplizer> tuplizerClass) {
-		this.tuplizerClass = tuplizerClass;
-	}
-
-	@Override
-	public boolean isDynamicUpdate() {
-		return dynamicUpdate;
-	}
-
-	public void setDynamicUpdate(boolean dynamicUpdate) {
-		this.dynamicUpdate = dynamicUpdate;
-	}
-
-	@Override
-	public boolean isDynamicInsert() {
-		return dynamicInsert;
-	}
-
-	public void setDynamicInsert(boolean dynamicInsert) {
-		this.dynamicInsert = dynamicInsert;
-	}
-
-	@Override
-	public int getBatchSize() {
-		return batchSize;
-	}
-
-	public void setBatchSize(int batchSize) {
-		this.batchSize = batchSize;
-	}
-
-	@Override
-	public boolean isSelectBeforeUpdate() {
-		return selectBeforeUpdate;
-	}
-
-	public void setSelectBeforeUpdate(boolean selectBeforeUpdate) {
-		this.selectBeforeUpdate = selectBeforeUpdate;
-	}
-
-	@Override
-	public String getCustomLoaderName() {
-		return customLoaderName;
-	}
-
-	public void setCustomLoaderName(String customLoaderName) {
-		this.customLoaderName = customLoaderName;
-	}
-
-	@Override
-	public CustomSQL getCustomInsert() {
-		return customInsert;
-	}
-
-	public void setCustomInsert(CustomSQL customInsert) {
-		this.customInsert = customInsert;
-	}
-
-	@Override
-	public CustomSQL getCustomUpdate() {
-		return customUpdate;
-	}
-
-	public void setCustomUpdate(CustomSQL customUpdate) {
-		this.customUpdate = customUpdate;
-	}
-
-	@Override
-	public CustomSQL getCustomDelete() {
-		return customDelete;
-	}
-
-	public void setCustomDelete(CustomSQL customDelete) {
-		this.customDelete = customDelete;
-	}
-
-	@Override
-	public Set<String> getSynchronizedTableNames() {
-		return synchronizedTableNames;
-	}
-
-	public void addSynchronizedTableName(String tableName) {
-		synchronizedTableNames.add( tableName );
-	}
-
-	@Override
-	public MetaAttributeContext getMetaAttributeContext() {
-		// not needed for annotations!? (HF)
-		// probably not; this is a tools/generation thing (SE)
-		return null;
-	}
-
-	@Override
-	public Origin getOrigin() {
-		// (steve) - not sure how to best handle this.  Origin should essentially name the class file from which
-		// this information came
-		return null;
-	}
-
-	@Override
-	public UnifiedDescriptorObject getContainingDescriptor() {
-		// probably makes most sense as none for annotations.
-		return this;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/state/binding/RootEntityDescriptorImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/state/binding/RootEntityDescriptorImpl.java
deleted file mode 100644
index 0c250cd2aa..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/state/binding/RootEntityDescriptorImpl.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binder.source.annotations.entity.state.binding;
-
-import org.hibernate.annotations.OptimisticLockType;
-import org.hibernate.engine.OptimisticLockStyle;
-import org.hibernate.metamodel.binder.source.BindingContext;
-import org.hibernate.metamodel.binder.source.RootEntityDescriptor;
-import org.hibernate.metamodel.binder.source.TableDescriptor;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClass;
-import org.hibernate.metamodel.binding.Caching;
-import org.hibernate.metamodel.binding.InheritanceType;
-
-/**
- * @author Steve Ebersole
- * @author Hardy Ferentschik
- */
-public class RootEntityDescriptorImpl
-		extends AbstractEntityDescriptorImpl
-		implements RootEntityDescriptor {
-
-	private boolean mutable;
-	private boolean explicitPolymorphism;
-	private String whereFilter;
-	private String rowId;
-	private OptimisticLockStyle optimisticLockStyle;
-
-	private Caching caching;
-
-	private TableDescriptor baseTableDescriptor;
-
-	public RootEntityDescriptorImpl(
-			ConfiguredClass configuredClass,
-			String superEntityName,
-			BindingContext bindingContext) {
-		super( configuredClass, superEntityName, bindingContext );
-		if ( configuredClass.getInheritanceType() != InheritanceType.NO_INHERITANCE ) {
-			// throw exception?
-		}
-	}
-
-	@Override
-	public boolean isMutable() {
-		return mutable;
-	}
-
-	public void setMutable(boolean mutable) {
-		this.mutable = mutable;
-	}
-
-	@Override
-	public boolean isExplicitPolymorphism() {
-		return explicitPolymorphism;
-	}
-
-	public void setExplicitPolymorphism(boolean explicitPolymorphism) {
-		this.explicitPolymorphism = explicitPolymorphism;
-	}
-
-	@Override
-	public String getWhereFilter() {
-		return whereFilter;
-	}
-
-	public void setWhereFilter(String whereFilter) {
-		this.whereFilter = whereFilter;
-	}
-
-	@Override
-	public String getRowId() {
-		return rowId;
-	}
-
-	public void setRowId(String rowId) {
-		this.rowId = rowId;
-	}
-
-	@Override
-	public OptimisticLockStyle getOptimisticLockStyle() {
-		return optimisticLockStyle;
-	}
-
-	public void setOptimisticLockType(OptimisticLockType optimisticLockType) {
-		switch ( optimisticLockType ) {
-			case NONE: {
-				this.optimisticLockStyle = OptimisticLockStyle.NONE;
-				break;
-			}
-			case DIRTY: {
-				this.optimisticLockStyle = OptimisticLockStyle.DIRTY;
-				break;
-			}
-			case ALL: {
-				this.optimisticLockStyle = OptimisticLockStyle.ALL;
-				break;
-			}
-			default: {
-				this.optimisticLockStyle = OptimisticLockStyle.VERSION;
-			}
-		}
-	}
-
-	@Override
-	public Caching getCaching() {
-		return caching;
-	}
-
-	public void setCaching(Caching caching) {
-		this.caching = caching;
-	}
-
-	@Override
-	public TableDescriptor getBaseTable() {
-		return baseTableDescriptor;
-	}
-
-	public void setBaseTableDescriptor(TableDescriptor baseTableDescriptor) {
-		this.baseTableDescriptor = baseTableDescriptor;
-	}
-}
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/package-info.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/package-info.java
deleted file mode 100644
index beef15c51d..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/package-info.java
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Hibernate, Relational Persistence for Idiomatic Java
- *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
- * indicated by the @author tags or express copyright attribution
- * statements applied by the authors.  All third-party contributions are
- * distributed under license by Red Hat Inc.
- *
- * This copyrighted material is made available to anyone wishing to use, modify,
- * copy, or redistribute it subject to the terms and conditions of the GNU
- * Lesser General Public License, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
- * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
- * for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this distribution; if not, write to:
- * Free Software Foundation, Inc.
- * 51 Franklin Street, Fifth Floor
- * Boston, MA  02110-1301  USA
- */
-package org.hibernate.metamodel.binder.source.annotations;
-
-/**
- * This code in this package is responsible for performing the process of preparing metadata from annotations
- * and {@code orm.xml} into the forms needed by {@link org.hibernate.metamodel.binder.EntityBinder}.  The main driver
- * of this process is the {@link AnnotationsSourceProcessor} class.
- */
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractAttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractAttributeBinding.java
index 38d5d89d1a..a42b3fd875 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractAttributeBinding.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AbstractAttributeBinding.java
@@ -1,275 +1,275 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.binding;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 import org.hibernate.MappingException;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
+import org.hibernate.metamodel.source.MetaAttributeContext;
 import org.hibernate.metamodel.binding.state.AttributeBindingState;
 import org.hibernate.metamodel.domain.Attribute;
 import org.hibernate.metamodel.relational.Column;
 import org.hibernate.metamodel.relational.DerivedValue;
 import org.hibernate.metamodel.relational.SimpleValue;
 import org.hibernate.metamodel.relational.Tuple;
 import org.hibernate.metamodel.relational.Value;
 import org.hibernate.metamodel.relational.state.SimpleValueRelationalState;
 import org.hibernate.metamodel.relational.state.TupleRelationalState;
 import org.hibernate.metamodel.relational.state.ValueCreator;
 import org.hibernate.metamodel.relational.state.ValueRelationalState;
 
 /**
  * Basic support for {@link AttributeBinding} implementors
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractAttributeBinding implements AttributeBinding {
 	private final EntityBinding entityBinding;
 
 	private final HibernateTypeDescriptor hibernateTypeDescriptor = new HibernateTypeDescriptor();
 	private final Set<EntityReferencingAttributeBinding> entityReferencingAttributeBindings = new HashSet<EntityReferencingAttributeBinding>();
 
 	private Attribute attribute;
 	private Value value;
 
 	private boolean isLazy;
 	private String propertyAccessorName;
 	private boolean isAlternateUniqueKey;
 	private Set<CascadeType> cascadeTypes;
 	private boolean optimisticLockable;
 
 	private MetaAttributeContext metaAttributeContext;
 
 	protected AbstractAttributeBinding(EntityBinding entityBinding) {
 		this.entityBinding = entityBinding;
 	}
 
 	protected void initialize(AttributeBindingState state) {
 		hibernateTypeDescriptor.setTypeName( state.getTypeName() );
 		hibernateTypeDescriptor.setTypeParameters( state.getTypeParameters() );
 		isLazy = state.isLazy();
 		propertyAccessorName = state.getPropertyAccessorName();
 		isAlternateUniqueKey = state.isAlternateUniqueKey();
 		cascadeTypes = state.getCascadeTypes();
 		optimisticLockable = state.isOptimisticLockable();
 		metaAttributeContext = state.getMetaAttributeContext();
 	}
 
 	@Override
 	public EntityBinding getEntityBinding() {
 		return entityBinding;
 	}
 
 	@Override
 	public Attribute getAttribute() {
 		return attribute;
 	}
 
 	protected void setAttribute(Attribute attribute) {
 		this.attribute = attribute;
 	}
 
 	public void setValue(Value value) {
 		this.value = value;
 	}
 
 	protected boolean forceNonNullable() {
 		return false;
 	}
 
 	protected boolean forceUnique() {
 		return false;
 	}
 
 	protected final boolean isPrimaryKey() {
 		return this == getEntityBinding().getEntityIdentifier().getValueBinding();
 	}
 
 	protected void initializeValueRelationalState(ValueRelationalState state) {
 		// TODO: change to have ValueRelationalState generate the value
 		value = ValueCreator.createValue(
 				getEntityBinding().getBaseTable(),
 				getAttribute().getName(),
 				state,
 				forceNonNullable(),
 				forceUnique()
 		);
 		// TODO: not sure I like this here...
 		if ( isPrimaryKey() ) {
 			if ( SimpleValue.class.isInstance( value ) ) {
 				if ( !Column.class.isInstance( value ) ) {
 					// this should never ever happen..
 					throw new MappingException( "Simple ID is not a column." );
 				}
 				entityBinding.getBaseTable().getPrimaryKey().addColumn( Column.class.cast( value ) );
 			}
 			else {
 				for ( SimpleValueRelationalState val : TupleRelationalState.class.cast( state )
 						.getRelationalStates() ) {
 					if ( Column.class.isInstance( val ) ) {
 						entityBinding.getBaseTable().getPrimaryKey().addColumn( Column.class.cast( val ) );
 					}
 				}
 			}
 		}
 	}
 
 	@Override
 	public Value getValue() {
 		return value;
 	}
 
 	@Override
 	public HibernateTypeDescriptor getHibernateTypeDescriptor() {
 		return hibernateTypeDescriptor;
 	}
 
 	public Set<CascadeType> getCascadeTypes() {
 		return cascadeTypes;
 	}
 
 	public boolean isOptimisticLockable() {
 		return optimisticLockable;
 	}
 
 	@Override
 	public MetaAttributeContext getMetaAttributeContext() {
 		return metaAttributeContext;
 	}
 
 	@Override
 	public int getValuesSpan() {
 		if ( value == null ) {
 			return 0;
 		}
 		else if ( value instanceof Tuple ) {
 			return ( ( Tuple ) value ).valuesSpan();
 		}
 		else {
 			return 1;
 		}
 	}
 
 
 	@Override
 	public Iterable<SimpleValue> getValues() {
 		return value == null
 				? Collections.<SimpleValue>emptyList()
 				: value instanceof Tuple
 				? ( (Tuple) value ).values()
 				: Collections.singletonList( (SimpleValue) value );
 	}
 
 	@Override
 	public String getPropertyAccessorName() {
 		return propertyAccessorName;
 	}
 
 	@Override
 	public boolean isBasicPropertyAccessor() {
 		return propertyAccessorName==null || "property".equals( propertyAccessorName );
 	}
 
 
 	@Override
 	public boolean hasFormula() {
 		for ( SimpleValue simpleValue : getValues() ) {
 			if ( simpleValue instanceof DerivedValue ) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	@Override
 	public boolean isAlternateUniqueKey() {
 		return isAlternateUniqueKey;
 	}
 
 	public void setAlternateUniqueKey(boolean alternateUniqueKey) {
 		this.isAlternateUniqueKey = alternateUniqueKey;
 	}
 
 	@Override
 	public boolean isNullable() {
 		for ( SimpleValue simpleValue : getValues() ) {
 			if ( simpleValue instanceof DerivedValue ) {
 				return true;
 			}
 			Column column = (Column) simpleValue;
 			if ( column.isNullable() ) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	@Override
 	public boolean[] getColumnInsertability() {
 		List<Boolean> tmp = new ArrayList<Boolean>();
 		for ( SimpleValue simpleValue : getValues() ) {
 			tmp.add( !( simpleValue instanceof DerivedValue ) );
 		}
 		boolean[] rtn = new boolean[tmp.size()];
 		int i = 0;
 		for ( Boolean insertable : tmp ) {
 			rtn[i++] = insertable.booleanValue();
 		}
 		return rtn;
 	}
 
 	@Override
 	public boolean[] getColumnUpdateability() {
 		return getColumnInsertability();
 	}
 
 	@Override
 	public boolean isLazy() {
 		return isLazy;
 	}
 
 	public void setLazy(boolean isLazy) {
 		this.isLazy = isLazy;
 	}
 
 	public void addEntityReferencingAttributeBinding(EntityReferencingAttributeBinding referencingAttributeBinding) {
 		entityReferencingAttributeBindings.add( referencingAttributeBinding );
 	}
 
 	public Set<EntityReferencingAttributeBinding> getEntityReferencingAttributeBindings() {
 		return Collections.unmodifiableSet( entityReferencingAttributeBindings );
 	}
 
 	public void validate() {
 		if ( !entityReferencingAttributeBindings.isEmpty() ) {
 			// TODO; validate that this AttributeBinding can be a target of an entity reference
 			// (e.g., this attribute is the primary key or there is a unique-key)
 			// can a unique attribute be used as a target? if so, does it need to be non-null?
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AttributeBinding.java
index 0427c1503a..dca2d6cda8 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AttributeBinding.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/AttributeBinding.java
@@ -1,118 +1,118 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.binding;
 
 import java.util.Set;
 
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
+import org.hibernate.metamodel.source.MetaAttributeContext;
 import org.hibernate.metamodel.domain.Attribute;
 import org.hibernate.metamodel.relational.SimpleValue;
 import org.hibernate.metamodel.relational.Value;
 
 /**
  * The basic contract for binding between an {@link #getAttribute() attribute} and a {@link #getValue() value}
  *
  * @author Steve Ebersole
  */
 public interface AttributeBinding {
 	/**
 	 * Obtain the entity binding to which this attribute binding exists.
 	 *
 	 * @return The entity binding.
 	 */
 	public EntityBinding getEntityBinding();
 
 	/**
 	 * Obtain the attribute bound.
 	 *
 	 * @return The attribute.
 	 */
 	public Attribute getAttribute();
 
 	/**
 	 * Obtain the value bound
 	 *
 	 * @return The value
 	 */
 	public Value getValue();
 
 	/**
 	 * Obtain the descriptor for the Hibernate {@link org.hibernate.type.Type} for this binding.
 	 * <p/>
 	 * For information about the Java type, query the {@link Attribute} obtained from {@link #getAttribute()}
 	 * instead.
 	 *
 	 * @return The type descriptor
 	 */
 	public HibernateTypeDescriptor getHibernateTypeDescriptor();
 
 	/**
 	 * Obtain the meta attributes associated with this binding
 	 *
 	 * @return The meta attributes
 	 */
 	public MetaAttributeContext getMetaAttributeContext();
 
 	/**
 	 * Returns the number of {@link org.hibernate.metamodel.relational.SimpleValue}
 	 * objects that will be returned by {@link #getValues()}
 	 *
 	 * @return the number of objects that will be returned by {@link #getValues()}.
 	 *
 	 * @see {@link org.hibernate.metamodel.relational.SimpleValue}
 	 * @see {@link #getValues()}
 	 */
 	public int getValuesSpan();
 
 	/**
 	 * @return In the case that {@link #getValue()} represents a {@link org.hibernate.metamodel.relational.Tuple} this method
 	 *         gives access to its compound values.  In the case of {@link org.hibernate.metamodel.relational.SimpleValue},
 	 *         we return an Iterable over that single simple value.
 	 */
 	public Iterable<SimpleValue> getValues();
 
 	public String getPropertyAccessorName();
 
 	public boolean isBasicPropertyAccessor();
 
 	public boolean hasFormula();
 
 	public boolean isAlternateUniqueKey();
 
 	public boolean isNullable();
 
 	public boolean[] getColumnUpdateability();
 
 	public boolean[] getColumnInsertability();
 
 	public boolean isSimpleValue();
 
 	public boolean isLazy();
 
 	public void addEntityReferencingAttributeBinding(EntityReferencingAttributeBinding attributeBinding);
 
 	public Set<EntityReferencingAttributeBinding> getEntityReferencingAttributeBindings();
 
 	public void validate();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/EntityBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/EntityBinding.java
index 6777bf90b7..ed6ac30c23 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/EntityBinding.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/EntityBinding.java
@@ -1,513 +1,513 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.binding;
 
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.EntityMode;
 import org.hibernate.MappingException;
 import org.hibernate.engine.OptimisticLockStyle;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.internal.util.Value;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
+import org.hibernate.metamodel.source.MetaAttributeContext;
 import org.hibernate.metamodel.domain.Attribute;
 import org.hibernate.metamodel.domain.Entity;
 import org.hibernate.metamodel.relational.Column;
 import org.hibernate.metamodel.relational.TableSpecification;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.tuple.entity.EntityTuplizer;
 
 /**
  * Provides the link between the domain and the relational model for an entity.
  *
  * @author Steve Ebersole
  * @author Hardy Ferentschik
  * @author Gail Badner
  */
 public class EntityBinding {
 	private Entity entity;
 	private TableSpecification baseTable;
 
 	private EntityMode entityMode;
 	private Value<Class<?>> proxyInterfaceType;
 
 	private String jpaEntityName;
 
 	private Class<? extends EntityPersister> customEntityPersisterClass;
 	private Class<? extends EntityTuplizer> customEntityTuplizerClass;
 
 	private boolean isRoot;
 	private InheritanceType entityInheritanceType;
 
 	private final EntityIdentifier entityIdentifier = new EntityIdentifier( this );
 	private EntityDiscriminator entityDiscriminator;
 	private SimpleAttributeBinding versionBinding;
 
 	private Map<String, AttributeBinding> attributeBindingMap = new HashMap<String, AttributeBinding>();
 	private Set<FilterDefinition> filterDefinitions = new HashSet<FilterDefinition>( );
 	private Set<EntityReferencingAttributeBinding> entityReferencingAttributeBindings = new HashSet<EntityReferencingAttributeBinding>();
 
 	private Caching caching;
 
 	private MetaAttributeContext metaAttributeContext;
 
 	private boolean lazy;
 	private boolean mutable;
 	private boolean explicitPolymorphism;
 	private String whereFilter;
 	private String rowId;
 
 	private boolean dynamicUpdate;
 	private boolean dynamicInsert;
 
 	private int batchSize;
 	private boolean selectBeforeUpdate;
 	private boolean hasSubselectLoadableCollections;
 	private OptimisticLockStyle optimisticLockStyle;
 
 	private Boolean isAbstract;
 
 	private String customLoaderName;
 	private CustomSQL customInsert;
 	private CustomSQL customUpdate;
 	private CustomSQL customDelete;
 
 	private Set<String> synchronizedTableNames = new HashSet<String>();
 
 //	public EntityBinding initialize(BindingContext bindingContext, EntityDescriptor state) {
 //		// todo : Entity will need both entityName and className to be effective
 //		this.entity = new Entity( state.getEntityName(), state.getSuperType(), bindingContext.makeJavaType( state.getClassName() ) );
 //
 //		this.isRoot = state.isRoot();
 //		this.entityInheritanceType = state.getEntityInheritanceType();
 //
 //		this.entityMode = state.getEntityMode();
 //		this.jpaEntityName = state.getJpaEntityName();
 //
 //		// todo : handle the entity-persister-resolver stuff
 //		this.customEntityPersisterClass = state.getCustomEntityPersisterClass();
 //		this.customEntityTuplizerClass = state.getCustomEntityTuplizerClass();
 //
 //		this.caching = state.getCaching();
 //		this.metaAttributeContext = state.getMetaAttributeContext();
 //
 //		if ( entityMode == EntityMode.POJO ) {
 //			if ( state.getProxyInterfaceName() != null ) {
 //				this.proxyInterfaceType = bindingContext.makeJavaType( state.getProxyInterfaceName() );
 //				this.lazy = true;
 //			}
 //			else if ( state.isLazy() ) {
 //				this.proxyInterfaceType = entity.getJavaType();
 //				this.lazy = true;
 //			}
 //		}
 //		else {
 //			this.proxyInterfaceType = new JavaType( Map.class );
 //			this.lazy = state.isLazy();
 //		}
 //
 //		this.mutable = state.isMutable();
 //		this.explicitPolymorphism = state.isExplicitPolymorphism();
 //		this.whereFilter = state.getWhereFilter();
 //		this.rowId = state.getRowId();
 //		this.dynamicUpdate = state.isDynamicUpdate();
 //		this.dynamicInsert = state.isDynamicInsert();
 //		this.batchSize = state.getBatchSize();
 //		this.selectBeforeUpdate = state.isSelectBeforeUpdate();
 //		this.optimisticLockMode = state.getOptimisticLockMode();
 //		this.isAbstract = state.isAbstract();
 //		this.customInsert = state.getCustomInsert();
 //		this.customUpdate = state.getCustomUpdate();
 //		this.customDelete = state.getCustomDelete();
 //		if ( state.getSynchronizedTableNames() != null ) {
 //			for ( String synchronizedTableName : state.getSynchronizedTableNames() ) {
 //				addSynchronizedTable( synchronizedTableName );
 //			}
 //		}
 //		return this;
 //	}
 
 	public Entity getEntity() {
 		return entity;
 	}
 
 	public void setEntity(Entity entity) {
 		this.entity = entity;
 	}
 
 	public TableSpecification getBaseTable() {
 		return baseTable;
 	}
 
 	public void setBaseTable(TableSpecification baseTable) {
 		this.baseTable = baseTable;
 	}
 
 	public boolean isRoot() {
 		return isRoot;
 	}
 
 	public void setRoot(boolean isRoot) {
 		this.isRoot = isRoot;
 	}
 
 	public EntityIdentifier getEntityIdentifier() {
 		return entityIdentifier;
 	}
 
 	public void bindEntityIdentifier(SimpleAttributeBinding attributeBinding) {
 		if ( !Column.class.isInstance( attributeBinding.getValue() ) ) {
 			throw new MappingException(
 					"Identifier value must be a Column; instead it is: " + attributeBinding.getValue().getClass()
 			);
 		}
 		entityIdentifier.setValueBinding( attributeBinding );
 		baseTable.getPrimaryKey().addColumn( Column.class.cast( attributeBinding.getValue() ) );
 	}
 
 	public EntityDiscriminator getEntityDiscriminator() {
 		return entityDiscriminator;
 	}
 
 	public void setInheritanceType(InheritanceType entityInheritanceType) {
 		this.entityInheritanceType = entityInheritanceType;
 	}
 
 	public InheritanceType getInheritanceType() {
 		return entityInheritanceType;
 	}
 
 	public boolean isVersioned() {
 		return versionBinding != null;
 	}
 
 	public SimpleAttributeBinding getVersioningValueBinding() {
 		return versionBinding;
 	}
 
 	public Iterable<AttributeBinding> getAttributeBindings() {
 		return attributeBindingMap.values();
 	}
 
 	public AttributeBinding getAttributeBinding(String name) {
 		return attributeBindingMap.get( name );
 	}
 
 	/**
 	 * Gets the number of attribute bindings defined on this class, including the
 	 * identifier attribute binding and attribute bindings defined
 	 * as part of a join.
 	 *
 	 * @return The number of attribute bindings
 	 */
 	public int getAttributeBindingClosureSpan() {
 		// TODO: fix this after HHH-6337 is fixed; for now just return size of attributeBindingMap
 		// if this is not a root, then need to include the superclass attribute bindings
 		return attributeBindingMap.size();
 	}
 
 	/**
 	 * Gets the attribute bindings defined on this class, including the
 	 * identifier attribute binding and attribute bindings defined
 	 * as part of a join.
 	 *
 	 * @return The attribute bindings.
 	 */
 	public Iterable<AttributeBinding> getAttributeBindingClosure() {
 		// TODO: fix this after HHH-6337 is fixed. for now, just return attributeBindings
 		// if this is not a root, then need to include the superclass attribute bindings
 		return getAttributeBindings();
 	}
 
 	public Iterable<FilterDefinition> getFilterDefinitions() {
 		return filterDefinitions;
 	}
 
 	public void addFilterDefinition(FilterDefinition filterDefinition) {
 		filterDefinitions.add( filterDefinition );
 	}
 
 	public Iterable<EntityReferencingAttributeBinding> getEntityReferencingAttributeBindings() {
 		return entityReferencingAttributeBindings;
 	}
 
 	public SimpleAttributeBinding makeSimpleIdAttributeBinding(Attribute attribute) {
 		final SimpleAttributeBinding binding = makeSimpleAttributeBinding( attribute, true, true );
 		getEntityIdentifier().setValueBinding( binding );
 		return binding;
 	}
 
 	public EntityDiscriminator makeEntityDiscriminator(Attribute attribute) {
 		if ( entityDiscriminator != null ) {
 			throw new AssertionFailure( "Creation of entity discriminator was called more than once" );
 		}
 		entityDiscriminator = new EntityDiscriminator();
 		entityDiscriminator.setValueBinding( makeSimpleAttributeBinding( attribute, true, false ) );
 		return entityDiscriminator;
 	}
 
 	public SimpleAttributeBinding makeVersionBinding(Attribute attribute) {
 		versionBinding = makeSimpleAttributeBinding( attribute, true, false );
 		return versionBinding;
 	}
 
 	public SimpleAttributeBinding makeSimpleAttributeBinding(Attribute attribute) {
 		return makeSimpleAttributeBinding( attribute, false, false );
 	}
 
 	private SimpleAttributeBinding makeSimpleAttributeBinding(Attribute attribute, boolean forceNonNullable, boolean forceUnique) {
 		final SimpleAttributeBinding binding = new SimpleAttributeBinding( this, forceNonNullable, forceUnique );
 		registerAttributeBinding( attribute.getName(), binding );
 		binding.setAttribute( attribute );
 		return binding;
 	}
 
 	public ManyToOneAttributeBinding makeManyToOneAttributeBinding(String attributeName) {
 		final ManyToOneAttributeBinding binding = new ManyToOneAttributeBinding( this );
 		registerAttributeBinding( attributeName, binding );
 		binding.setAttribute( entity.getAttribute( attributeName ) );
 		return binding;
 	}
 
 	public BagBinding makeBagAttributeBinding(String attributeName, CollectionElementType collectionElementType) {
 		final BagBinding binding = new BagBinding( this, collectionElementType );
 		registerAttributeBinding( attributeName, binding );
 		binding.setAttribute( entity.getAttribute( attributeName ) );
 		return binding;
 	}
 
 	private void registerAttributeBinding(String name, EntityReferencingAttributeBinding attributeBinding) {
 		entityReferencingAttributeBindings.add( attributeBinding );
 		registerAttributeBinding( name, (AttributeBinding) attributeBinding );
 	}
 
 	private void registerAttributeBinding(String name, AttributeBinding attributeBinding) {
 		attributeBindingMap.put( name, attributeBinding );
 	}
 
 	public Caching getCaching() {
 		return caching;
 	}
 
 	public void setCaching(Caching caching) {
 		this.caching = caching;
 	}
 
 	public MetaAttributeContext getMetaAttributeContext() {
 		return metaAttributeContext;
 	}
 
 	public void setMetaAttributeContext(MetaAttributeContext metaAttributeContext) {
 		this.metaAttributeContext = metaAttributeContext;
 	}
 
 	public boolean isMutable() {
 		return mutable;
 	}
 
 	public void setMutable(boolean mutable) {
 		this.mutable = mutable;
 	}
 
 	public boolean isLazy() {
 		return lazy;
 	}
 
 	public void setLazy(boolean lazy) {
 		this.lazy = lazy;
 	}
 
 	public Value<Class<?>> getProxyInterfaceType() {
 		return proxyInterfaceType;
 	}
 
 	public void setProxyInterfaceType(Value<Class<?>> proxyInterfaceType) {
 		this.proxyInterfaceType = proxyInterfaceType;
 	}
 
 	public String getWhereFilter() {
 		return whereFilter;
 	}
 
 	public void setWhereFilter(String whereFilter) {
 		this.whereFilter = whereFilter;
 	}
 
 	public boolean isExplicitPolymorphism() {
 		return explicitPolymorphism;
 	}
 
 	public void setExplicitPolymorphism(boolean explicitPolymorphism) {
 		this.explicitPolymorphism = explicitPolymorphism;
 	}
 
 	public String getRowId() {
 		return rowId;
 	}
 
 	public void setRowId(String rowId) {
 		this.rowId = rowId;
 	}
 
 	public String getDiscriminatorValue() {
 		return entityDiscriminator == null ? null : entityDiscriminator.getDiscriminatorValue();
 	}
 
 	public boolean isDynamicUpdate() {
 		return dynamicUpdate;
 	}
 
 	public void setDynamicUpdate(boolean dynamicUpdate) {
 		this.dynamicUpdate = dynamicUpdate;
 	}
 
 	public boolean isDynamicInsert() {
 		return dynamicInsert;
 	}
 
 	public void setDynamicInsert(boolean dynamicInsert) {
 		this.dynamicInsert = dynamicInsert;
 	}
 
 	public int getBatchSize() {
 		return batchSize;
 	}
 
 	public void setBatchSize(int batchSize) {
 		this.batchSize = batchSize;
 	}
 
 	public boolean isSelectBeforeUpdate() {
 		return selectBeforeUpdate;
 	}
 
 	public void setSelectBeforeUpdate(boolean selectBeforeUpdate) {
 		this.selectBeforeUpdate = selectBeforeUpdate;
 	}
 
 	public boolean hasSubselectLoadableCollections() {
 		return hasSubselectLoadableCollections;
 	}
 
 	/* package-protected */
 	void setSubselectLoadableCollections(boolean hasSubselectLoadableCollections) {
 		this.hasSubselectLoadableCollections = hasSubselectLoadableCollections;
 	}
 
 	public OptimisticLockStyle getOptimisticLockStyle() {
 		return optimisticLockStyle;
 	}
 
 	public void setOptimisticLockStyle(OptimisticLockStyle optimisticLockStyle) {
 		this.optimisticLockStyle = optimisticLockStyle;
 	}
 
 	public Class<? extends EntityPersister> getCustomEntityPersisterClass() {
 		return customEntityPersisterClass;
 	}
 
 	public void setCustomEntityPersisterClass(Class<? extends EntityPersister> customEntityPersisterClass) {
 		this.customEntityPersisterClass = customEntityPersisterClass;
 	}
 
 	public Class<? extends EntityTuplizer> getCustomEntityTuplizerClass() {
 		return customEntityTuplizerClass;
 	}
 
 	public void setCustomEntityTuplizerClass(Class<? extends EntityTuplizer> customEntityTuplizerClass) {
 		this.customEntityTuplizerClass = customEntityTuplizerClass;
 	}
 
 	public Boolean isAbstract() {
 		return isAbstract;
 	}
 
 	public void setAbstract(Boolean isAbstract) {
 		this.isAbstract = isAbstract;
 	}
 
 	public Set<String> getSynchronizedTableNames() {
 		return synchronizedTableNames;
 	}
 
 	public void addSynchronizedTable(String tableName) {
 		synchronizedTableNames.add( tableName );
 	}
 
 	public void addSynchronizedTableNames(java.util.Collection<String> synchronizedTableNames) {
 		this.synchronizedTableNames.addAll( synchronizedTableNames );
 	}
 
 	public EntityMode getEntityMode() {
 		return entityMode;
 	}
 
 	public void setEntityMode(EntityMode entityMode) {
 		this.entityMode = entityMode;
 	}
 
 	public String getJpaEntityName() {
 		return jpaEntityName;
 	}
 
 	public void setJpaEntityName(String jpaEntityName) {
 		this.jpaEntityName = jpaEntityName;
 	}
 
 	public String getCustomLoaderName() {
 		return customLoaderName;
 	}
 
 	public void setCustomLoaderName(String customLoaderName) {
 		this.customLoaderName = customLoaderName;
 	}
 
 	public CustomSQL getCustomInsert() {
 		return customInsert;
 	}
 
 	public void setCustomInsert(CustomSQL customInsert) {
 		this.customInsert = customInsert;
 	}
 
 	public CustomSQL getCustomUpdate() {
 		return customUpdate;
 	}
 
 	public void setCustomUpdate(CustomSQL customUpdate) {
 		this.customUpdate = customUpdate;
 	}
 
 	public CustomSQL getCustomDelete() {
 		return customDelete;
 	}
 
 	public void setCustomDelete(CustomSQL customDelete) {
 		this.customDelete = customDelete;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SimpleAttributeBinding.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SimpleAttributeBinding.java
index fd5571a50e..120d85e330 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SimpleAttributeBinding.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/SimpleAttributeBinding.java
@@ -1,162 +1,161 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.binding;
 
 import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
+import org.hibernate.metamodel.source.MetaAttributeContext;
 import org.hibernate.metamodel.binding.state.SimpleAttributeBindingState;
 import org.hibernate.metamodel.domain.SingularAttribute;
-import org.hibernate.metamodel.relational.Value;
 import org.hibernate.metamodel.relational.state.ColumnRelationalState;
 import org.hibernate.metamodel.relational.state.ValueRelationalState;
 
 /**
  * TODO : javadoc
  *
  * @author Steve Ebersole
  */
 public class SimpleAttributeBinding extends AbstractAttributeBinding implements KeyValueBinding {
 	private boolean insertable;
 	private boolean updatable;
 	private PropertyGeneration generation;
 
 	private String propertyAccessorName;
 	private String unsavedValue;
 
 	private boolean forceNonNullable;
 	private boolean forceUnique;
 	private boolean keyCascadeDeleteEnabled;
 
 	private boolean includedInOptimisticLocking;
 	private MetaAttributeContext metaAttributeContext;
 
 	SimpleAttributeBinding(EntityBinding entityBinding, boolean forceNonNullable, boolean forceUnique) {
 		super( entityBinding );
 		this.forceNonNullable = forceNonNullable;
 		this.forceUnique = forceUnique;
 	}
 
 	public final SimpleAttributeBinding initialize(SimpleAttributeBindingState state) {
 		super.initialize( state );
 		insertable = state.isInsertable();
 		updatable = state.isUpdatable();
 		keyCascadeDeleteEnabled = state.isKeyCascadeDeleteEnabled();
 		unsavedValue = state.getUnsavedValue();
 		generation = state.getPropertyGeneration() == null ? PropertyGeneration.NEVER : state.getPropertyGeneration();
 		return this;
 	}
 
 	public SimpleAttributeBinding initialize(ValueRelationalState state) {
 		super.initializeValueRelationalState( state );
 		return this;
 	}
 
 	private boolean isUnique(ColumnRelationalState state) {
 		return isPrimaryKey() || state.isUnique();
 	}
 
 	@Override
 	public SingularAttribute getAttribute() {
 		return (SingularAttribute) super.getAttribute();
 	}
 
 	@Override
 	public boolean isSimpleValue() {
 		return true;
 	}
 
 	public boolean isInsertable() {
 		return insertable;
 	}
 
 	public void setInsertable(boolean insertable) {
 		this.insertable = insertable;
 	}
 
 	public boolean isUpdatable() {
 		return updatable;
 	}
 
 	public void setUpdatable(boolean updatable) {
 		this.updatable = updatable;
 	}
 
 	@Override
 	public boolean isKeyCascadeDeleteEnabled() {
 		return keyCascadeDeleteEnabled;
 	}
 
 	public void setKeyCascadeDeleteEnabled(boolean keyCascadeDeleteEnabled) {
 		this.keyCascadeDeleteEnabled = keyCascadeDeleteEnabled;
 	}
 
 	@Override
 	public String getUnsavedValue() {
 		return unsavedValue;
 	}
 
 	public void setUnsavedValue(String unsaveValue) {
 		this.unsavedValue = unsaveValue;
 	}
 
 	public boolean forceNonNullable() {
 		return forceNonNullable;
 	}
 
 	public boolean forceUnique() {
 		return forceUnique;
 	}
 
 	public PropertyGeneration getGeneration() {
 		return generation;
 	}
 
 	public void setGeneration(PropertyGeneration generation) {
 		this.generation = generation;
 	}
 
 	public String getPropertyAccessorName() {
 		return propertyAccessorName;
 	}
 
 	public void setPropertyAccessorName(String propertyAccessorName) {
 		this.propertyAccessorName = propertyAccessorName;
 	}
 
 	public boolean isIncludedInOptimisticLocking() {
 		return includedInOptimisticLocking;
 	}
 
 	public void setIncludedInOptimisticLocking(boolean includedInOptimisticLocking) {
 		this.includedInOptimisticLocking = includedInOptimisticLocking;
 	}
 
 	public MetaAttributeContext getMetaAttributeContext() {
 		return metaAttributeContext;
 	}
 
 	public void setMetaAttributeContext(MetaAttributeContext metaAttributeContext) {
 		this.metaAttributeContext = metaAttributeContext;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/state/AttributeBindingState.java b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/state/AttributeBindingState.java
index 37fd2da6ab..cfb7db211a 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binding/state/AttributeBindingState.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/binding/state/AttributeBindingState.java
@@ -1,55 +1,55 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.binding.state;
 
 import java.util.Map;
 import java.util.Set;
 
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
+import org.hibernate.metamodel.source.MetaAttributeContext;
 import org.hibernate.metamodel.binding.CascadeType;
 
 /**
  * @author Gail Badner
  */
 public interface AttributeBindingState {
 	String getAttributeName();
 
 	String getTypeName();
 
 	Map<String, String> getTypeParameters();
 
 	boolean isLazy();
 
 	String getPropertyAccessorName();
 
 	boolean isAlternateUniqueKey();
 
 	Set<CascadeType> getCascadeTypes();
 
 	boolean isOptimisticLockable();
 
 	String getNodeName();
 
 	public MetaAttributeContext getMetaAttributeContext();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AbstractAttributeContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AbstractAttributeContainer.java
index fc894ecfc1..0d64eb0095 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AbstractAttributeContainer.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AbstractAttributeContainer.java
@@ -1,267 +1,361 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.domain;
 
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedHashSet;
 import java.util.Set;
 
+import org.hibernate.HibernateException;
 import org.hibernate.internal.util.Value;
 
 /**
  * Convenient base class for {@link AttributeContainer}.  Because in our model all
  * {@link AttributeContainer AttributeContainers} are also {@link Hierarchical} we also implement that here
  * as well.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractAttributeContainer implements AttributeContainer, Hierarchical {
 	private final String name;
 	private final String className;
 	private final Value<Class<?>> classReference;
 	private final Hierarchical superType;
 	private LinkedHashSet<Attribute> attributeSet = new LinkedHashSet<Attribute>();
 	private HashMap<String, Attribute> attributeMap = new HashMap<String, Attribute>();
 
 	public AbstractAttributeContainer(String name, String className, Value<Class<?>> classReference, Hierarchical superType) {
 		this.name = name;
 		this.className = className;
 		this.classReference = classReference;
 		this.superType = superType;
 	}
 
 	@Override
 	public String getName() {
 		return name;
 	}
 
 	@Override
 	public String getClassName() {
 		return className;
 	}
 
 	@Override
 	public Class<?> getClassReference() {
 		return classReference.getValue();
 	}
 
 	@Override
 	public Value<Class<?>> getClassReferenceUnresolved() {
 		return classReference;
 	}
 
 	@Override
 	public Hierarchical getSuperType() {
 		return superType;
 	}
 
 	@Override
 	public Set<Attribute> getAttributes() {
 		return Collections.unmodifiableSet( attributeSet );
 	}
 
 	@Override
 	public Attribute getAttribute(String name) {
 		return attributeMap.get( name );
 	}
 
 	@Override
 	public SingularAttribute locateOrCreateSingularAttribute(String name) {
 		SingularAttribute attribute = (SingularAttribute) getAttribute( name );
 		if ( attribute == null ) {
 
 			attribute = new SingularAttributeImpl( name, this );
 			addAttribute( attribute );
 		}
 		return attribute;
 	}
 
 	@Override
 	public SingularAttribute locateOrCreateComponentAttribute(String name) {
-		SingularAttribute attribute = (SingularAttribute) getAttribute( name );
+		SingularAttributeImpl attribute = (SingularAttributeImpl) getAttribute( name );
 		if ( attribute == null ) {
-			Component component = new Component( name, null );
+			ComponentAttributeContainerDelegate component = new ComponentAttributeContainerDelegate();
 			attribute = new SingularAttributeImpl( name, component );
+			component.singularAttribute = attribute;
 			addAttribute( attribute );
 		}
 		return attribute;
 	}
 
+	private static class ComponentAttributeContainerDelegate implements AttributeContainer {
+		private SingularAttributeImpl singularAttribute;
+
+		private ComponentAttributeContainerDelegate() {
+		}
+
+		private Component realComponent() {
+			if ( singularAttribute.getSingularAttributeType() == null ) {
+				throw new HibernateException( "Component type was not yet bound" );
+			}
+			if ( ! Component.class.isInstance( singularAttribute.getSingularAttributeType() ) ) {
+				throw new HibernateException( "Unexpected bound type for component attribute" );
+			}
+			return (Component) singularAttribute.getSingularAttributeType();
+		}
+
+		@Override
+		public Attribute getAttribute(String name) {
+			return realComponent().getAttribute( name );
+		}
+
+		@Override
+		public Set<Attribute> getAttributes() {
+			return realComponent().getAttributes();
+		}
+
+		@Override
+		public SingularAttribute locateOrCreateSingularAttribute(String name) {
+			return realComponent().locateOrCreateSingularAttribute( name );
+		}
+
+		@Override
+		public PluralAttribute locateOrCreatePluralAttribute(String name, PluralAttributeNature nature) {
+			return realComponent().locateOrCreatePluralAttribute( name, nature );
+		}
+
+		@Override
+		public PluralAttribute locateOrCreateBag(String name) {
+			return realComponent().locateOrCreateBag( name );
+		}
+
+		@Override
+		public PluralAttribute locateOrCreateSet(String name) {
+			return realComponent().locateOrCreateBag( name );
+		}
+
+		@Override
+		public IndexedPluralAttribute locateOrCreateList(String name) {
+			return realComponent().locateOrCreateList( name );
+		}
+
+		@Override
+		public IndexedPluralAttribute locateOrCreateMap(String name) {
+			return realComponent().locateOrCreateMap( name );
+		}
+
+		@Override
+		public SingularAttribute locateOrCreateComponentAttribute(String name) {
+			return realComponent().locateOrCreateComponentAttribute( name );
+		}
+
+		@Override
+		public String getName() {
+			return realComponent().getName();
+		}
+
+		@Override
+		public String getClassName() {
+			return realComponent().getClassName();
+		}
+
+		@Override
+		public Class<?> getClassReference() {
+			return realComponent().getClassReference();
+		}
+
+		@Override
+		public Value<Class<?>> getClassReferenceUnresolved() {
+			return realComponent().getClassReferenceUnresolved();
+		}
+
+		@Override
+		public boolean isAssociation() {
+			return realComponent().isAssociation();
+		}
+
+		@Override
+		public boolean isComponent() {
+			return realComponent().isComponent();
+		}
+	}
+
 	@Override
 	public PluralAttribute locateOrCreateBag(String name) {
 		return locateOrCreatePluralAttribute( name, PluralAttributeNature.BAG );
 	}
 
 	@Override
 	public PluralAttribute locateOrCreateSet(String name) {
 		return locateOrCreatePluralAttribute( name, PluralAttributeNature.SET );
 	}
 
 	@Override
 	public IndexedPluralAttribute locateOrCreateList(String name) {
 		return (IndexedPluralAttribute) locateOrCreatePluralAttribute( name, PluralAttributeNature.LIST );
 	}
 
 	@Override
 	public IndexedPluralAttribute locateOrCreateMap(String name) {
 		return (IndexedPluralAttribute) locateOrCreatePluralAttribute( name, PluralAttributeNature.MAP );
 	}
 
 	@Override
 	public PluralAttribute locateOrCreatePluralAttribute(String name, PluralAttributeNature nature) {
 		PluralAttribute attribute = (PluralAttribute) getAttribute( name );
 		if ( attribute == null ) {
 			attribute = nature.isIndexed()
 					? new IndexedPluralAttributeImpl( name, nature, this )
 					: new PluralAttributeImpl( name, nature, this );
 			addAttribute( attribute );
 		}
 		return attribute;
 	}
 
 	@Override
 	public String toString() {
 		final StringBuilder sb = new StringBuilder();
 		sb.append( "AbstractAttributeContainer" );
 		sb.append( "{name='" ).append( name ).append( '\'' );
 		sb.append( ", superType=" ).append( superType );
 		sb.append( '}' );
 		return sb.toString();
 	}
 
 	protected void addAttribute(Attribute attribute) {
 		// todo : how to best "secure" this?
 		if ( attributeMap.put( attribute.getName(), attribute ) != null ) {
 			throw new IllegalArgumentException( "Attribute with name [" + attribute.getName() + "] already registered" );
 		}
 		attributeSet.add( attribute );
 	}
 
 	// todo : inner classes for now..
 
 	public static class SingularAttributeImpl implements SingularAttribute {
 		private final AttributeContainer attributeContainer;
 		private final String name;
 		private Type type;
 
 		public SingularAttributeImpl(String name, AttributeContainer attributeContainer) {
 			this.name = name;
 			this.attributeContainer = attributeContainer;
 		}
 
 		public boolean isTypeResolved() {
 			return type != null;
 		}
 
 		public void resolveType(Type type) {
 			if ( type == null ) {
 				throw new IllegalArgumentException( "Attempt to resolve with null type" );
 			}
 			this.type = type;
 		}
 
 		@Override
 		public Type getSingularAttributeType() {
 			return type;
 		}
 
 		@Override
 		public String getName() {
 			return name;
 		}
 
 		@Override
 		public AttributeContainer getAttributeContainer() {
 			return attributeContainer;
 		}
 
 		@Override
 		public boolean isSingular() {
 			return true;
 		}
 	}
 
 	public static class PluralAttributeImpl implements PluralAttribute {
 		private final AttributeContainer attributeContainer;
 		private final PluralAttributeNature nature;
 		private final String name;
 
 		private Type elementType;
 
 		public PluralAttributeImpl(String name, PluralAttributeNature nature, AttributeContainer attributeContainer) {
 			this.name = name;
 			this.nature = nature;
 			this.attributeContainer = attributeContainer;
 		}
 
 		@Override
 		public AttributeContainer getAttributeContainer() {
 			return attributeContainer;
 		}
 
 		@Override
 		public boolean isSingular() {
 			return false;
 		}
 
 		@Override
 		public PluralAttributeNature getNature() {
 			return nature;
 		}
 
 		@Override
 		public String getName() {
 			return name;
 		}
 
 		@Override
 		public Type getElementType() {
 			return elementType;
 		}
 
 		@Override
 		public void setElementType(Type elementType) {
 			this.elementType = elementType;
 		}
 	}
 
 	public static class IndexedPluralAttributeImpl extends PluralAttributeImpl implements IndexedPluralAttribute {
 		private Type indexType;
 
 		public IndexedPluralAttributeImpl(String name, PluralAttributeNature nature, AttributeContainer attributeContainer) {
 			super( name, nature, attributeContainer );
 		}
 
 		@Override
 		public Type getIndexType() {
 			return indexType;
 		}
 
 		@Override
 		public void setIndexType(Type indexType) {
 			this.indexType = indexType;
 		}
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AttributeContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AttributeContainer.java
index 0dabf559d4..302027bd2d 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AttributeContainer.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/AttributeContainer.java
@@ -1,58 +1,59 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.domain;
 
 import java.util.Set;
 
 /**
  * Basic contract for any container holding attributes. This allows polymorphic handling of both
  * components and entities in terms of the attributes they hold.
  *
  * @author Steve Ebersole
  */
 public interface AttributeContainer extends Type {
 	/**
 	 * Retrieve an attribute by name.
 	 *
 	 * @param name The name of the attribute to retrieve.
 	 *
 	 * @return The attribute matching the given name, or null.
 	 */
 	public Attribute getAttribute(String name);
 
 	/**
 	 * Retrieve the attributes contained in this container.
 	 *
 	 * @return The contained attributes
 	 */
 	public Set<Attribute> getAttributes();
 
 	public SingularAttribute locateOrCreateSingularAttribute(String name);
-	public SingularAttribute locateOrCreateComponentAttribute(String name);
 	public PluralAttribute locateOrCreatePluralAttribute(String name, PluralAttributeNature nature);
 	public PluralAttribute locateOrCreateBag(String name);
 	public PluralAttribute locateOrCreateSet(String name);
 	public IndexedPluralAttribute locateOrCreateList(String name);
 	public IndexedPluralAttribute locateOrCreateMap(String name);
+
+	public SingularAttribute locateOrCreateComponentAttribute(String name);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/BindingContext.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/BindingContext.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/BindingContext.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/BindingContext.java
index fac913abe5..598aa6086f 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/BindingContext.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/BindingContext.java
@@ -1,50 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source;
+package org.hibernate.metamodel.source;
 
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.internal.util.Value;
 import org.hibernate.metamodel.domain.Type;
 import org.hibernate.service.ServiceRegistry;
 
 /**
  * @author Steve Ebersole
  */
 public interface BindingContext {
     public ServiceRegistry getServiceRegistry();
 
     public NamingStrategy getNamingStrategy();
 
     public MappingDefaults getMappingDefaults();
 
 	public MetadataImplementor getMetadataImplementor();
 
     public <T> Class<T> locateClassByName(String name);
 
 	public Type makeJavaType(String className);
 
     public boolean isGloballyQuotedIdentifiers();
 
 	public Value<Class<?>> makeClassReference(String className);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/MappingDefaults.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingDefaults.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/MappingDefaults.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingDefaults.java
index fe6c0119b2..bb66dc64f0 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/MappingDefaults.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingDefaults.java
@@ -1,101 +1,101 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source;
+package org.hibernate.metamodel.source;
 
 import org.hibernate.cache.spi.access.AccessType;
 
 /**
  * Defines a (contextual) set of values to use as defaults in the absence of related mapping information.  The
  * context here is conceptually a stack.  The "global" level is configuration settings.
  *
  * @author Steve Ebersole
  * @author Gail Badner
  */
 public interface MappingDefaults {
 	/**
 	 * Identifies the default package name to use if none specified in the mapping.  Really only pertinent for
 	 * {@code hbm.xml} mappings.
 	 *
 	 * @return The default package name.
 	 */
 	public String getPackageName();
 
 	/**
 	 * Identifies the default database schema name to use if none specified in the mapping.
 	 *
 	 * @return The default schema name
 	 */
 	public String getSchemaName();
 
 	/**
 	 * Identifies the default database catalog name to use if none specified in the mapping.
 	 *
 	 * @return The default catalog name
 	 */
 	public String getCatalogName();
 
 	/**
 	 * Identifies the default column name to use for the identifier column if none specified in the mapping.
 	 *
 	 * @return The default identifier column name
 	 */
 	public String getIdColumnName();
 
 	/**
 	 * Identifies the default column name to use for the discriminator column if none specified in the mapping.
 	 *
 	 * @return The default discriminator column name
 	 */
 	public String getDiscriminatorColumnName();
 
 	/**
 	 * Identifies the default cascade style to apply to associations if none specified in the mapping.
 	 *
 	 * @return The default cascade style
 	 */
 	public String getCascadeStyle();
 
 	/**
 	 * Identifies the default {@link org.hibernate.property.PropertyAccessor} name to use if none specified in the
 	 * mapping.
 	 *
 	 * @return The default property accessor name
 	 * @see org.hibernate.property.PropertyAccessorFactory
 	 */
 	public String getPropertyAccessorName();
 
 	/**
 	 * Identifies whether associations are lazy by default if not specified in the mapping.
 	 *
 	 * @return The default association laziness
 	 */
 	public boolean areAssociationsLazy();
 
 	/**
 	 * The default cache access type to use
 	 *
 	 * @return The default cache access type.
 	 */
 	public AccessType getCacheAccessType();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/MappingException.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingException.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/MappingException.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingException.java
index 35a6032e02..279879e41f 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/MappingException.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingException.java
@@ -1,50 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
-package org.hibernate.metamodel.binder;
+package org.hibernate.metamodel.source;
 
 import org.hibernate.HibernateException;
 
 /**
  * Indicates a problem parsing a mapping document.
  *
  * @author Steve Ebersole
  */
 public class MappingException extends HibernateException {
 	private final Origin origin;
 
 	public MappingException(String message, Origin origin) {
 		super( message );
 		this.origin = origin;
 	}
 
 	public MappingException(String message, Throwable root, Origin origin) {
 		super( message, root );
 		this.origin = origin;
 	}
 
 	public Origin getOrigin() {
 		return origin;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/MappingNotFoundException.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingNotFoundException.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/MappingNotFoundException.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingNotFoundException.java
index f1b73f1649..3e56633c35 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/MappingNotFoundException.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MappingNotFoundException.java
@@ -1,46 +1,46 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
-package org.hibernate.metamodel.binder;
+package org.hibernate.metamodel.source;
 
 /**
  * @author Steve Ebersole
  */
 public class MappingNotFoundException extends MappingException {
 	public MappingNotFoundException(String message, Origin origin) {
 		super( message, origin );
 	}
 
 	public MappingNotFoundException(Origin origin) {
 		super( String.format( "Mapping (%s) not found : %s", origin.getType(), origin.getName() ), origin );
 	}
 
 	public MappingNotFoundException(String message, Throwable root, Origin origin) {
 		super( message, root, origin );
 	}
 
 	public MappingNotFoundException(Throwable root, Origin origin) {
 		super( String.format( "Mapping (%s) not found : %s", origin.getType(), origin.getName() ), root, origin );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/MetaAttributeContext.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MetaAttributeContext.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/MetaAttributeContext.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/MetaAttributeContext.java
index 231f730314..461c031863 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/MetaAttributeContext.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MetaAttributeContext.java
@@ -1,88 +1,88 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source;
+package org.hibernate.metamodel.source;
 
 import java.util.HashSet;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.hibernate.metamodel.binding.MetaAttribute;
 
 /**
  * @author Steve Ebersole
  */
 public class MetaAttributeContext {
 	private final MetaAttributeContext parentContext;
 	private final ConcurrentHashMap<String, MetaAttribute> metaAttributeMap = new ConcurrentHashMap<String, MetaAttribute>();
 
 	public MetaAttributeContext() {
 		this( null );
 	}
 
 	public MetaAttributeContext(MetaAttributeContext parentContext) {
 		this.parentContext = parentContext;
 	}
 
 
 	// read contract ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public Iterable<String> getKeys() {
 		HashSet<String> keys = new HashSet<String>();
 		addKeys( keys );
 		return keys;
 	}
 
 	private void addKeys(Set<String> keys) {
 		keys.addAll( metaAttributeMap.keySet() );
 		if ( parentContext != null ) {
 			// recursive call
 			parentContext.addKeys( keys );
 		}
 	}
 
 	public Iterable<String> getLocalKeys() {
 		return metaAttributeMap.keySet();
 	}
 
 	public MetaAttribute getMetaAttribute(String key) {
 		MetaAttribute value = getLocalMetaAttribute( key );
 		if ( value == null ) {
 			// recursive call
 			value = parentContext.getMetaAttribute( key );
 		}
 		return value;
 	}
 
 	public MetaAttribute getLocalMetaAttribute(String key) {
 		return metaAttributeMap.get( key );
 	}
 
 
 	// write contract ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void add(MetaAttribute metaAttribute) {
 		metaAttributeMap.put( metaAttribute.getName(), metaAttribute );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/MetadataImplementor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MetadataImplementor.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/MetadataImplementor.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/MetadataImplementor.java
index 6e35d0b826..7d29096fc8 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/MetadataImplementor.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/MetadataImplementor.java
@@ -1,78 +1,78 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source;
+package org.hibernate.metamodel.source;
 
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.metamodel.Metadata;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.binding.FetchProfile;
 import org.hibernate.metamodel.binding.IdGenerator;
 import org.hibernate.metamodel.binding.PluralAttributeBinding;
 import org.hibernate.metamodel.binding.TypeDef;
 import org.hibernate.metamodel.relational.AuxiliaryDatabaseObject;
 import org.hibernate.metamodel.relational.Database;
 import org.hibernate.service.BasicServiceRegistry;
 import org.hibernate.type.TypeResolver;
 
 /**
  * @author Steve Ebersole
  */
 public interface MetadataImplementor extends Metadata, BindingContext, Mapping {
 	public BasicServiceRegistry getServiceRegistry();
 
 	public Database getDatabase();
 
 	public TypeResolver getTypeResolver();
 
 	public void addImport(String entityName, String entityName1);
 
 	public void addEntity(EntityBinding entityBinding);
 
 	public void addCollection(PluralAttributeBinding collectionBinding);
 
 	public void addFetchProfile(FetchProfile profile);
 
 	public void addTypeDefinition(TypeDef typeDef);
 
 	public void addFilterDefinition(FilterDefinition filterDefinition);
 
 	public void addIdGenerator(IdGenerator generator);
 
 	public void registerIdentifierGenerator(String name, String clazz);
 
 	public void addNamedNativeQuery(NamedSQLQueryDefinition def);
 
 	public void addNamedQuery(NamedQueryDefinition def);
 
 	public void addResultSetMapping(ResultSetMappingDefinition resultSetMappingDefinition);
 
 	// todo : this needs to move to AnnotationBindingContext
 	public void setGloballyQuotedIdentifiers(boolean b);
 
 	public MetaAttributeContext getGlobalMetaAttributeContext();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/Origin.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/Origin.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/Origin.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/Origin.java
index 0ef00b2979..824d433bd8 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/Origin.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/Origin.java
@@ -1,60 +1,60 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder;
+package org.hibernate.metamodel.source;
 
 import java.io.Serializable;
 
 /**
  * Describes the origin of an xml document
  *
  * @author Steve Ebersole
  */
 public class Origin implements Serializable {
 	private final SourceType type;
 	private final String name;
 
 	public Origin(SourceType type, String name) {
 		this.type = type;
 		this.name = name;
 	}
 
 	/**
 	 * Retrieve the type of origin.
 	 *
 	 * @return The origin type.
 	 */
 	public SourceType getType() {
 		return type;
 	}
 
 	/**
 	 * The name of the document origin.  Interpretation is relative to the type, but might be the
 	 * resource name or file URL.
 	 *
 	 * @return The name.
 	 */
 	public String getName() {
 		return name;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/SourceProcessor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/SourceProcessor.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/SourceProcessor.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/SourceProcessor.java
index b42f0cf61a..6f5c17f909 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/SourceProcessor.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/SourceProcessor.java
@@ -1,81 +1,81 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source;
+package org.hibernate.metamodel.source;
 
 import java.util.List;
 
 import org.hibernate.metamodel.MetadataSources;
 
 /**
  * Handles the processing of metadata sources in a dependency-ordered manner.
  *
  * @author Steve Ebersole
  */
 public interface SourceProcessor {
 	/**
 	 * Prepare for processing the given sources.
 	 *
 	 * @param sources The metadata sources.
 	 */
 	public void prepare(MetadataSources sources);
 
 	/**
 	 * Process the independent metadata.  These have no dependency on other types of metadata being processed.
 	 *
 	 * @param sources The metadata sources.
 	 *
 	 * @see #prepare
 	 */
 	public void processIndependentMetadata(MetadataSources sources);
 
 	/**
 	 * Process the parts of the metadata that depend on type information (type definitions) having been processed
 	 * and available.
 	 *
 	 * @param sources The metadata sources.
 	 *
 	 * @see #processIndependentMetadata
 	 */
 	public void processTypeDependentMetadata(MetadataSources sources);
 
 	/**
 	 * Process the mapping (entities, et al) metadata.
 	 *
 	 * @param sources The metadata sources.
 	 * @param processedEntityNames Collection of any already processed entity names.
 	 *
 	 * @see #processTypeDependentMetadata
 	 */
 	public void processMappingMetadata(MetadataSources sources, List<String> processedEntityNames);
 
 	/**
 	 * Process the parts of the metadata that depend on mapping (entities, et al) information having been
 	 * processed and available.
 	 *
 	 * @param sources The metadata sources.
 	 *
 	 * @see #processMappingMetadata
 	 */
 	public void processMappingDependentMetadata(MetadataSources sources);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/SourceType.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/SourceType.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/SourceType.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/SourceType.java
index cd8484a6d9..07eb6046ce 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/SourceType.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/SourceType.java
@@ -1,41 +1,41 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
-package org.hibernate.metamodel.binder;
+package org.hibernate.metamodel.source;
 
 /**
  * From where did the metadata come from?
  *
  * @author Steve Ebersole
  */
 public enum SourceType {
 	RESOURCE,
 	FILE,
 	INPUT_STREAM,
 	URL,
 	STRING,
 	DOM,
 	JAR,
 	OTHER
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/XsdException.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/XsdException.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/XsdException.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/XsdException.java
index 7a2a7cb004..fac0104bf9 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/XsdException.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/XsdException.java
@@ -1,50 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
-package org.hibernate.metamodel.binder;
+package org.hibernate.metamodel.source;
 
 import org.hibernate.HibernateException;
 
 /**
  * Indicates an issue finding or loading an XSD schema.
  * 
  * @author Steve Ebersole
  */
 public class XsdException extends HibernateException {
 	private final String xsdName;
 
 	public XsdException(String message, String xsdName) {
 		super( message );
 		this.xsdName = xsdName;
 	}
 
 	public XsdException(String message, Throwable root, String xsdName) {
 		super( message, root );
 		this.xsdName = xsdName;
 	}
 
 	public String getXsdName() {
 		return xsdName;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/AnnotationsBindingContext.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationsBindingContext.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/AnnotationsBindingContext.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationsBindingContext.java
index 3a557d4c3e..cb670afa76 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/AnnotationsBindingContext.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationsBindingContext.java
@@ -1,44 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations;
+package org.hibernate.metamodel.source.annotations;
 
 import com.fasterxml.classmate.ResolvedType;
 import com.fasterxml.classmate.ResolvedTypeWithMembers;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.Index;
 
-import org.hibernate.metamodel.binder.source.BindingContext;
+import org.hibernate.metamodel.source.BindingContext;
 
 /**
  * @author Steve Ebersole
  */
 public interface AnnotationsBindingContext extends BindingContext {
 	public Index getIndex();
 	public ClassInfo getClassInfo(String name);
 
 	public void resolveAllTypes(String className);
 	public ResolvedType getResolvedType(Class<?> clazz);
 
 	public ResolvedTypeWithMembers resolveMemberTypes(ResolvedType type);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/AnnotationsSourceProcessor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationsSourceProcessor.java
similarity index 86%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/AnnotationsSourceProcessor.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationsSourceProcessor.java
index 4c2e5e926e..395a89e676 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/AnnotationsSourceProcessor.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationsSourceProcessor.java
@@ -1,296 +1,306 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations;
+package org.hibernate.metamodel.source.annotations;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import com.fasterxml.classmate.MemberResolver;
 import com.fasterxml.classmate.ResolvedType;
 import com.fasterxml.classmate.ResolvedTypeWithMembers;
 import com.fasterxml.classmate.TypeResolver;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.jboss.jandex.Indexer;
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.internal.util.Value;
 import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.binder.source.MappingDefaults;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.SourceProcessor;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClassHierarchy;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClassType;
-import org.hibernate.metamodel.binder.source.annotations.entity.EntityBinder;
-import org.hibernate.metamodel.binder.source.annotations.global.FetchProfileBinder;
-import org.hibernate.metamodel.binder.source.annotations.global.FilterDefBinder;
-import org.hibernate.metamodel.binder.source.annotations.global.IdGeneratorBinder;
-import org.hibernate.metamodel.binder.source.annotations.global.QueryBinder;
-import org.hibernate.metamodel.binder.source.annotations.global.TableBinder;
-import org.hibernate.metamodel.binder.source.annotations.global.TypeDefBinder;
-import org.hibernate.metamodel.binder.source.annotations.xml.PseudoJpaDotNames;
-import org.hibernate.metamodel.binder.source.annotations.xml.mocker.EntityMappingsMocker;
-import org.hibernate.metamodel.binder.source.internal.JaxbRoot;
-import org.hibernate.metamodel.binder.source.internal.MetadataImpl;
+import org.hibernate.metamodel.source.MappingDefaults;
+import org.hibernate.metamodel.source.MetadataImplementor;
+import org.hibernate.metamodel.source.SourceProcessor;
+import org.hibernate.metamodel.source.annotations.entity.ConfiguredClassHierarchy;
+import org.hibernate.metamodel.source.annotations.entity.ConfiguredClassType;
+import org.hibernate.metamodel.source.annotations.entity.EntityBinder;
+import org.hibernate.metamodel.source.annotations.global.FetchProfileBinder;
+import org.hibernate.metamodel.source.annotations.global.FilterDefBinder;
+import org.hibernate.metamodel.source.annotations.global.IdGeneratorBinder;
+import org.hibernate.metamodel.source.annotations.global.QueryBinder;
+import org.hibernate.metamodel.source.annotations.global.TableBinder;
+import org.hibernate.metamodel.source.annotations.global.TypeDefBinder;
+import org.hibernate.metamodel.source.annotations.xml.PseudoJpaDotNames;
+import org.hibernate.metamodel.source.annotations.xml.mocker.EntityMappingsMocker;
+import org.hibernate.metamodel.source.internal.JaxbRoot;
+import org.hibernate.metamodel.source.internal.MetadataImpl;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.domain.Hierarchical;
 import org.hibernate.metamodel.domain.Type;
 import org.hibernate.metamodel.domain.NonEntity;
 import org.hibernate.metamodel.domain.Superclass;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntityMappings;
 import org.hibernate.metamodel.source.annotations.entity.EntityClass;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 
 /**
  * Main class responsible to creating and binding the Hibernate meta-model from annotations.
  * This binder only has to deal with the (jandex) annotation index/repository. XML configuration is already processed
  * and pseudo annotations are created.
  *
  * @author Hardy Ferentschik
  * @author Steve Ebersole
  */
 public class AnnotationsSourceProcessor implements SourceProcessor, AnnotationsBindingContext {
 	private static final Logger LOG = Logger.getLogger( AnnotationsSourceProcessor.class );
 
 	private final MetadataImplementor metadata;
 	private final Value<ClassLoaderService> classLoaderService;
 
 	private Index index;
 
 	private final TypeResolver typeResolver = new TypeResolver();
 	private final Map<Class<?>, ResolvedType> resolvedTypeCache = new HashMap<Class<?>, ResolvedType>();
 
 	public AnnotationsSourceProcessor(MetadataImpl metadata) {
 		this.metadata = metadata;
 		this.classLoaderService = new Value<ClassLoaderService>(
 				new Value.DeferredInitializer<ClassLoaderService>() {
 					@Override
 					public ClassLoaderService initialize() {
 						return AnnotationsSourceProcessor.this.metadata.getServiceRegistry().getService( ClassLoaderService.class );
 					}
 				}
 		);
 	}
 
 	@Override
 	@SuppressWarnings( { "unchecked" })
 	public void prepare(MetadataSources sources) {
 		// create a jandex index from the annotated classes
 		Indexer indexer = new Indexer();
 		for ( Class<?> clazz : sources.getAnnotatedClasses() ) {
 			indexClass( indexer, clazz.getName().replace( '.', '/' ) + ".class" );
 		}
 
 		// add package-info from the configured packages
 		for ( String packageName : sources.getAnnotatedPackages() ) {
 			indexClass( indexer, packageName.replace( '.', '/' ) + "/package-info.class" );
 		}
 
 		index = indexer.complete();
 
 		List<JaxbRoot<XMLEntityMappings>> mappings = new ArrayList<JaxbRoot<XMLEntityMappings>>();
 		for ( JaxbRoot<?> root : sources.getJaxbRootList() ) {
 			if ( root.getRoot() instanceof XMLEntityMappings ) {
 				mappings.add( (JaxbRoot<XMLEntityMappings>) root );
 			}
 		}
 		if ( !mappings.isEmpty() ) {
 			index = parseAndUpdateIndex( mappings, index );
 		}
 
         if( index.getAnnotations( PseudoJpaDotNames.DEFAULT_DELIMITED_IDENTIFIERS ) != null ) {
 			// todo : this needs to move to AnnotationBindingContext
             metadata.setGloballyQuotedIdentifiers( true );
         }
 	}
 
 	private Index parseAndUpdateIndex(List<JaxbRoot<XMLEntityMappings>> mappings, Index annotationIndex) {
 		List<XMLEntityMappings> list = new ArrayList<XMLEntityMappings>( mappings.size() );
 		for ( JaxbRoot<XMLEntityMappings> jaxbRoot : mappings ) {
 			list.add( jaxbRoot.getRoot() );
 		}
 		return new EntityMappingsMocker( list, annotationIndex, metadata.getServiceRegistry() ).mockNewIndex();
 	}
 
 	private void indexClass(Indexer indexer, String className) {
 		InputStream stream = classLoaderService.getValue().locateResourceStream( className );
 		try {
 			indexer.index( stream );
 		}
 		catch ( IOException e ) {
 			throw new HibernateException( "Unable to open input stream for class " + className, e );
 		}
 	}
 
 	@Override
 	public void processIndependentMetadata(MetadataSources sources) {
         TypeDefBinder.bind( metadata, index );
 	}
 
 	@Override
 	public void processTypeDependentMetadata(MetadataSources sources) {
         IdGeneratorBinder.bind( metadata, index );
 	}
 
 	@Override
 	public void processMappingMetadata(MetadataSources sources, List<String> processedEntityNames) {
 		// need to order our annotated entities into an order we can process
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = ConfiguredClassHierarchyBuilder.createEntityHierarchies(
 				this
 		);
 
 		// now we process each hierarchy one at the time
 		Hierarchical parent = null;
 		for ( ConfiguredClassHierarchy<EntityClass> hierarchy : hierarchies ) {
 			for ( EntityClass entityClass : hierarchy ) {
 				// for classes annotated w/ @Entity we create a EntityBinding
 				if ( ConfiguredClassType.ENTITY.equals( entityClass.getConfiguredClassType() ) ) {
 					LOG.debugf( "Binding entity from annotated class: %s", entityClass.getName() );
 					EntityBinder entityBinder = new EntityBinder( entityClass, parent, this );
 					EntityBinding binding = entityBinder.bind( processedEntityNames );
 					parent = binding.getEntity();
 				}
 				// for classes annotated w/ @MappedSuperclass we just create the domain instance
 				// the attribute bindings will be part of the first entity subclass
 				else if ( ConfiguredClassType.MAPPED_SUPERCLASS.equals( entityClass.getConfiguredClassType() ) ) {
-					parent = new Superclass( entityClass.getName(), parent );
+					parent = new Superclass(
+							entityClass.getName(),
+							entityClass.getName(),
+							makeClassReference( entityClass.getName() ),
+							parent
+					);
 				}
 				// for classes which are not annotated at all we create the NonEntity domain class
 				// todo - not sure whether this is needed. It might be that we don't need this information (HF)
 				else {
-					parent = new NonEntity( entityClass.getName(), parent );
+					parent = new NonEntity(
+							entityClass.getName(), 
+							entityClass.getName(),
+							makeClassReference( entityClass.getName() ),
+							parent
+					);
 				}
 			}
 		}
 	}
 
 	private Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies() {
 		return ConfiguredClassHierarchyBuilder.createEntityHierarchies( this );
 	}
 
 	@Override
 	public void processMappingDependentMetadata(MetadataSources sources) {
 		TableBinder.bind( metadata, index );
 		FetchProfileBinder.bind( metadata, index );
 		QueryBinder.bind( metadata, index );
 		FilterDefBinder.bind( metadata, index );
 	}
 
 	@Override
 	public Index getIndex() {
 		return index;
 	}
 
 	@Override
 	public ClassInfo getClassInfo(String name) {
 		DotName dotName = DotName.createSimple( name );
 		return index.getClassByName( dotName );
 	}
 
 	@Override
 	public void resolveAllTypes(String className) {
 		// the resolved type for the top level class in the hierarchy
 		Class<?> clazz = classLoaderService.getValue().classForName( className );
 		ResolvedType resolvedType = typeResolver.resolve( clazz );
 		while ( resolvedType != null ) {
 			// todo - check whether there is already something in the map
 			resolvedTypeCache.put( clazz, resolvedType );
 			resolvedType = resolvedType.getParentClass();
 			if ( resolvedType != null ) {
 				clazz = resolvedType.getErasedType();
 			}
 		}
 	}
 
 	@Override
 	public ResolvedType getResolvedType(Class<?> clazz) {
 		// todo - error handling
 		return resolvedTypeCache.get( clazz );
 	}
 
 	@Override
 	public ResolvedTypeWithMembers resolveMemberTypes(ResolvedType type) {
 		// todo : is there a reason we create this resolver every time?
 		MemberResolver memberResolver = new MemberResolver( typeResolver );
 		return memberResolver.resolve( type, null, null );
 	}
 
 	@Override
 	public ServiceRegistry getServiceRegistry() {
 		return getMetadataImplementor().getServiceRegistry();
 	}
 
 	@Override
 	public NamingStrategy getNamingStrategy() {
 		return metadata.getNamingStrategy();
 	}
 
 	@Override
 	public MappingDefaults getMappingDefaults() {
 		return metadata.getMappingDefaults();
 	}
 
 	@Override
 	public MetadataImplementor getMetadataImplementor() {
 		return metadata;
 	}
 
 	@Override
 	public <T> Class<T> locateClassByName(String name) {
 		return classLoaderService.getValue().classForName( name );
 	}
 
 	private Map<String,Type> nameToJavaTypeMap = new HashMap<String, Type>();
 
 	@Override
 	public Type makeJavaType(String className) {
 		Type javaType = nameToJavaTypeMap.get( className );
 		if ( javaType == null ) {
 			javaType = metadata.makeJavaType( className );
 			nameToJavaTypeMap.put( className, javaType );
 		}
 		return javaType;
 	}
 
 	@Override
 	public Value<Class<?>> makeClassReference(String className) {
 		return new Value<Class<?>>( locateClassByName( className ) );
 	}
 
 	@Override
 	public boolean isGloballyQuotedIdentifiers() {
 		return metadata.isGloballyQuotedIdentifiers();
 	}
 }
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/ConfiguredClassHierarchyBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/ConfiguredClassHierarchyBuilder.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/ConfiguredClassHierarchyBuilder.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/ConfiguredClassHierarchyBuilder.java
index feed15f26e..37c5769f56 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/ConfiguredClassHierarchyBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/ConfiguredClassHierarchyBuilder.java
@@ -1,212 +1,212 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations;
+package org.hibernate.metamodel.source.annotations;
 
 import javax.persistence.AccessType;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.AssertionFailure;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClassHierarchy;
+import org.hibernate.metamodel.source.annotations.entity.ConfiguredClassHierarchy;
 import org.hibernate.metamodel.source.annotations.entity.EmbeddableClass;
 import org.hibernate.metamodel.source.annotations.entity.EntityClass;
 
 /**
  * Given a (jandex) annotation index build processes all classes with JPA relevant annotations and pre-orders
  * JPA entities respectively their inheritance hierarchy.
  *
  * @author Hardy Ferentschik
  */
 public class ConfiguredClassHierarchyBuilder {
 
 	/**
 	 * Pre-processes the annotated entities from the index and put them into a structure which can
 	 * bound to the Hibernate metamodel.
 	 *
 	 * @param bindingContext The binding context, giving access to needed services and information
 	 *
 	 * @return a set of {@code ConfiguredClassHierarchy}s. One for each "leaf" entity.
 	 */
 	public static Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(AnnotationsBindingContext bindingContext) {
 		Map<ClassInfo, List<ClassInfo>> processedClassInfos = new HashMap<ClassInfo, List<ClassInfo>>();
 
 		for ( ClassInfo info : bindingContext.getIndex().getKnownClasses() ) {
 			if ( !isEntityClass( info ) ) {
 				continue;
 			}
 
 			if ( processedClassInfos.containsKey( info ) ) {
 				continue;
 			}
 
 			List<ClassInfo> configuredClassList = new ArrayList<ClassInfo>();
 			ClassInfo tmpClassInfo = info;
 			Class<?> clazz = bindingContext.locateClassByName( tmpClassInfo.toString() );
 			while ( clazz != null && !clazz.equals( Object.class ) ) {
 				tmpClassInfo = bindingContext.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) );
 				clazz = clazz.getSuperclass();
 				if ( tmpClassInfo == null ) {
 					continue;
 				}
 
 				if ( existsHierarchyWithClassInfoAsLeaf( processedClassInfos, tmpClassInfo ) ) {
 					List<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo );
 					for ( ClassInfo tmpInfo : configuredClassList ) {
 						classInfoList.add( tmpInfo );
 						processedClassInfos.put( tmpInfo, classInfoList );
 					}
 					break;
 				}
 				else {
 					configuredClassList.add( 0, tmpClassInfo );
 					processedClassInfos.put( tmpClassInfo, configuredClassList );
 				}
 			}
 		}
 
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = new HashSet<ConfiguredClassHierarchy<EntityClass>>();
 		List<List<ClassInfo>> processedList = new ArrayList<List<ClassInfo>>();
 		for ( List<ClassInfo> classInfoList : processedClassInfos.values() ) {
 			if ( !processedList.contains( classInfoList ) ) {
 				hierarchies.add( ConfiguredClassHierarchy.createEntityClassHierarchy( classInfoList, bindingContext ) );
 				processedList.add( classInfoList );
 			}
 		}
 
 		return hierarchies;
 	}
 
 	/**
 	 * Builds the configured class hierarchy for a an embeddable class.
 	 *
 	 * @param embeddableClass the top level embedded class
 	 * @param accessType the access type inherited from the class in which the embeddable gets embedded
 	 * @param context the annotation binding context with access to the service registry and the annotation index
 	 *
 	 * @return a set of {@code ConfiguredClassHierarchy}s. One for each "leaf" entity.
 	 */
 	public static ConfiguredClassHierarchy<EmbeddableClass> createEmbeddableHierarchy(Class<?> embeddableClass, AccessType accessType, AnnotationsBindingContext context) {
 
 		ClassInfo embeddableClassInfo = context.getClassInfo( embeddableClass.getName() );
 		if ( embeddableClassInfo == null ) {
 			throw new AssertionFailure(
 					String.format(
 							"The specified class %s cannot be found in the annotation index",
 							embeddableClass.getName()
 					)
 			);
 		}
 
 		if ( JandexHelper.getSingleAnnotation( embeddableClassInfo, JPADotNames.EMBEDDABLE ) == null ) {
 			throw new AssertionFailure(
 					String.format(
 							"The specified class %s is not annotated with @Embeddable",
 							embeddableClass.getName()
 					)
 			);
 		}
 
 		List<ClassInfo> classInfoList = new ArrayList<ClassInfo>();
 		ClassInfo tmpClassInfo;
 		Class<?> clazz = embeddableClass;
 		while ( clazz != null && !clazz.equals( Object.class ) ) {
 			tmpClassInfo = context.getIndex().getClassByName( DotName.createSimple( clazz.getName() ) );
 			clazz = clazz.getSuperclass();
 			if ( tmpClassInfo == null ) {
 				continue;
 			}
 
 			classInfoList.add( 0, tmpClassInfo );
 		}
 
 		return ConfiguredClassHierarchy.createEmbeddableClassHierarchy( classInfoList, accessType, context );
 	}
 
 	/**
 	 * Checks whether the passed jandex class info needs to be processed.
 	 *
 	 * @param info the jandex class info
 	 *
 	 * @return {@code true} if the class represented by {@code info} is relevant for the JPA mappings, {@code false} otherwise.
 	 */
 	private static boolean isEntityClass(ClassInfo info) {
 		boolean isConfiguredClass = true;
 		AnnotationInstance jpaEntityAnnotation = JandexHelper.getSingleAnnotation( info, JPADotNames.ENTITY );
 		AnnotationInstance mappedSuperClassAnnotation = JandexHelper.getSingleAnnotation(
 				info, JPADotNames.MAPPED_SUPERCLASS
 		);
 
 		// we are only interested in building the class hierarchies for @Entity or @MappedSuperclass
 		if ( jpaEntityAnnotation == null && mappedSuperClassAnnotation == null ) {
 			return false;
 		}
 
 		// some sanity checks
 		String className = info.toString();
 		assertNotEntityAndMappedSuperClass( jpaEntityAnnotation, mappedSuperClassAnnotation, className );
 
 		AnnotationInstance embeddableAnnotation = JandexHelper.getSingleAnnotation(
 				info, JPADotNames.EMBEDDABLE
 		);
 		assertNotEntityAndEmbeddable( jpaEntityAnnotation, embeddableAnnotation, className );
 
 		return isConfiguredClass;
 	}
 
 	private static boolean existsHierarchyWithClassInfoAsLeaf(Map<ClassInfo, List<ClassInfo>> processedClassInfos, ClassInfo tmpClassInfo) {
 		if ( !processedClassInfos.containsKey( tmpClassInfo ) ) {
 			return false;
 		}
 
 		List<ClassInfo> classInfoList = processedClassInfos.get( tmpClassInfo );
 		return classInfoList.get( classInfoList.size() - 1 ).equals( tmpClassInfo );
 	}
 
 	private static void assertNotEntityAndMappedSuperClass(AnnotationInstance jpaEntityAnnotation, AnnotationInstance mappedSuperClassAnnotation, String className) {
 		if ( jpaEntityAnnotation != null && mappedSuperClassAnnotation != null ) {
 			throw new AnnotationException(
 					"An entity cannot be annotated with both @Entity and @MappedSuperclass. " + className + " has both annotations."
 			);
 		}
 	}
 
 	private static void assertNotEntityAndEmbeddable(AnnotationInstance jpaEntityAnnotation, AnnotationInstance embeddableAnnotation, String className) {
 		if ( jpaEntityAnnotation != null && embeddableAnnotation != null ) {
 			throw new AnnotationException(
 					"An entity cannot be annotated with both @Entity and @Embeddable. " + className + " has both annotations."
 			);
 		}
 	}
 }
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/HibernateDotNames.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/HibernateDotNames.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/HibernateDotNames.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/HibernateDotNames.java
index d1915d37ed..8709025657 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/HibernateDotNames.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/HibernateDotNames.java
@@ -1,185 +1,185 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations;
+package org.hibernate.metamodel.source.annotations;
 
 import org.jboss.jandex.DotName;
 
 import org.hibernate.annotations.AccessType;
 import org.hibernate.annotations.Any;
 import org.hibernate.annotations.AnyMetaDef;
 import org.hibernate.annotations.AnyMetaDefs;
 import org.hibernate.annotations.BatchSize;
 import org.hibernate.annotations.Cache;
 import org.hibernate.annotations.Cascade;
 import org.hibernate.annotations.Check;
 import org.hibernate.annotations.CollectionId;
 import org.hibernate.annotations.ColumnTransformer;
 import org.hibernate.annotations.ColumnTransformers;
 import org.hibernate.annotations.Columns;
 import org.hibernate.annotations.DiscriminatorFormula;
 import org.hibernate.annotations.DiscriminatorOptions;
 import org.hibernate.annotations.Entity;
 import org.hibernate.annotations.Fetch;
 import org.hibernate.annotations.FetchProfile;
 import org.hibernate.annotations.FetchProfiles;
 import org.hibernate.annotations.Filter;
 import org.hibernate.annotations.FilterDef;
 import org.hibernate.annotations.FilterDefs;
 import org.hibernate.annotations.FilterJoinTable;
 import org.hibernate.annotations.FilterJoinTables;
 import org.hibernate.annotations.Filters;
 import org.hibernate.annotations.ForeignKey;
 import org.hibernate.annotations.Formula;
 import org.hibernate.annotations.Generated;
 import org.hibernate.annotations.GenericGenerator;
 import org.hibernate.annotations.GenericGenerators;
 import org.hibernate.annotations.Immutable;
 import org.hibernate.annotations.Index;
 import org.hibernate.annotations.IndexColumn;
 import org.hibernate.annotations.JoinColumnOrFormula;
 import org.hibernate.annotations.JoinColumnsOrFormulas;
 import org.hibernate.annotations.JoinFormula;
 import org.hibernate.annotations.LazyCollection;
 import org.hibernate.annotations.LazyToOne;
 import org.hibernate.annotations.Loader;
 import org.hibernate.annotations.ManyToAny;
 import org.hibernate.annotations.MapKeyType;
 import org.hibernate.annotations.MetaValue;
 import org.hibernate.annotations.NamedNativeQueries;
 import org.hibernate.annotations.NamedNativeQuery;
 import org.hibernate.annotations.NamedQueries;
 import org.hibernate.annotations.NamedQuery;
 import org.hibernate.annotations.NaturalId;
 import org.hibernate.annotations.NotFound;
 import org.hibernate.annotations.OnDelete;
 import org.hibernate.annotations.OptimisticLock;
 import org.hibernate.annotations.OrderBy;
 import org.hibernate.annotations.ParamDef;
 import org.hibernate.annotations.Parameter;
 import org.hibernate.annotations.Parent;
 import org.hibernate.annotations.Persister;
 import org.hibernate.annotations.Proxy;
 import org.hibernate.annotations.RowId;
 import org.hibernate.annotations.SQLDelete;
 import org.hibernate.annotations.SQLDeleteAll;
 import org.hibernate.annotations.SQLInsert;
 import org.hibernate.annotations.SQLUpdate;
 import org.hibernate.annotations.Sort;
 import org.hibernate.annotations.Source;
 import org.hibernate.annotations.Subselect;
 import org.hibernate.annotations.Synchronize;
 import org.hibernate.annotations.Table;
 import org.hibernate.annotations.Tables;
 import org.hibernate.annotations.Target;
 import org.hibernate.annotations.Tuplizer;
 import org.hibernate.annotations.Tuplizers;
 import org.hibernate.annotations.Type;
 import org.hibernate.annotations.TypeDef;
 import org.hibernate.annotations.TypeDefs;
 import org.hibernate.annotations.Where;
 import org.hibernate.annotations.WhereJoinTable;
 
 /**
  * Defines the dot names for the Hibernate specific mapping annotations.
  *
  * @author Hardy Ferentschik
  */
 public interface HibernateDotNames {
 	DotName ACCESS_TYPE = DotName.createSimple( AccessType.class.getName() );
 	DotName ANY = DotName.createSimple( Any.class.getName() );
 	DotName ANY_META_DEF = DotName.createSimple( AnyMetaDef.class.getName() );
 	DotName ANY_META_DEFS = DotName.createSimple( AnyMetaDefs.class.getName() );
 	DotName BATCH_SIZE = DotName.createSimple( BatchSize.class.getName() );
 	DotName CACHE = DotName.createSimple( Cache.class.getName() );
 	DotName CASCADE = DotName.createSimple( Cascade.class.getName() );
 	DotName CHECK = DotName.createSimple( Check.class.getName() );
 	DotName COLLECTION_ID = DotName.createSimple( CollectionId.class.getName() );
 	DotName COLUMNS = DotName.createSimple( Columns.class.getName() );
 	DotName COLUMN_TRANSFORMER = DotName.createSimple( ColumnTransformer.class.getName() );
 	DotName COLUMN_TRANSFORMERS = DotName.createSimple( ColumnTransformers.class.getName() );
 	DotName DISCRIMINATOR_FORMULA = DotName.createSimple( DiscriminatorFormula.class.getName() );
 	DotName DISCRIMINATOR_OPTIONS = DotName.createSimple( DiscriminatorOptions.class.getName() );
 	DotName ENTITY = DotName.createSimple( Entity.class.getName() );
 	DotName FETCH = DotName.createSimple( Fetch.class.getName() );
 	DotName FETCH_PROFILE = DotName.createSimple( FetchProfile.class.getName() );
 	DotName FETCH_PROFILES = DotName.createSimple( FetchProfiles.class.getName() );
 	DotName FILTER = DotName.createSimple( Filter.class.getName() );
 	DotName FILTER_DEF = DotName.createSimple( FilterDef.class.getName() );
 	DotName FILTER_DEFS = DotName.createSimple( FilterDefs.class.getName() );
 	DotName FILTER_JOIN_TABLE = DotName.createSimple( FilterJoinTable.class.getName() );
 	DotName FILTER_JOIN_TABLES = DotName.createSimple( FilterJoinTables.class.getName() );
 	DotName FILTERS = DotName.createSimple( Filters.class.getName() );
 	DotName FOREIGN_KEY = DotName.createSimple( ForeignKey.class.getName() );
 	DotName FORMULA = DotName.createSimple( Formula.class.getName() );
 	DotName GENERATED = DotName.createSimple( Generated.class.getName() );
 	DotName GENERIC_GENERATOR = DotName.createSimple( GenericGenerator.class.getName() );
 	DotName GENERIC_GENERATORS = DotName.createSimple( GenericGenerators.class.getName() );
 	DotName IMMUTABLE = DotName.createSimple( Immutable.class.getName() );
 	DotName INDEX = DotName.createSimple( Index.class.getName() );
 	DotName INDEX_COLUMN = DotName.createSimple( IndexColumn.class.getName() );
 	DotName JOIN_COLUMN_OR_FORMULA = DotName.createSimple( JoinColumnOrFormula.class.getName() );
 	DotName JOIN_COLUMNS_OR_FORMULAS = DotName.createSimple( JoinColumnsOrFormulas.class.getName() );
 	DotName JOIN_FORMULA = DotName.createSimple( JoinFormula.class.getName() );
 	DotName LAZY_COLLECTION = DotName.createSimple( LazyCollection.class.getName() );
 	DotName LAZY_TO_ONE = DotName.createSimple( LazyToOne.class.getName() );
 	DotName LOADER = DotName.createSimple( Loader.class.getName() );
 	DotName MANY_TO_ANY = DotName.createSimple( ManyToAny.class.getName() );
 	DotName MAP_KEY_TYPE = DotName.createSimple( MapKeyType.class.getName() );
 	DotName META_VALUE = DotName.createSimple( MetaValue.class.getName() );
 	DotName NAMED_NATIVE_QUERIES = DotName.createSimple( NamedNativeQueries.class.getName() );
 	DotName NAMED_NATIVE_QUERY = DotName.createSimple( NamedNativeQuery.class.getName() );
 	DotName NAMED_QUERIES = DotName.createSimple( NamedQueries.class.getName() );
 	DotName NAMED_QUERY = DotName.createSimple( NamedQuery.class.getName() );
 	DotName NATURAL_ID = DotName.createSimple( NaturalId.class.getName() );
 	DotName NOT_FOUND = DotName.createSimple( NotFound.class.getName() );
 	DotName ON_DELETE = DotName.createSimple( OnDelete.class.getName() );
 	DotName OPTIMISTIC_LOCK = DotName.createSimple( OptimisticLock.class.getName() );
 	DotName ORDER_BY = DotName.createSimple( OrderBy.class.getName() );
 	DotName PARAM_DEF = DotName.createSimple( ParamDef.class.getName() );
 	DotName PARAMETER = DotName.createSimple( Parameter.class.getName() );
 	DotName PARENT = DotName.createSimple( Parent.class.getName() );
 	DotName PERSISTER = DotName.createSimple( Persister.class.getName() );
 	DotName PROXY = DotName.createSimple( Proxy.class.getName() );
 	DotName ROW_ID = DotName.createSimple( RowId.class.getName() );
 	DotName SORT = DotName.createSimple( Sort.class.getName() );
 	DotName SOURCE = DotName.createSimple( Source.class.getName() );
 	DotName SQL_DELETE = DotName.createSimple( SQLDelete.class.getName() );
 	DotName SQL_DELETE_ALL = DotName.createSimple( SQLDeleteAll.class.getName() );
 	DotName SQL_INSERT = DotName.createSimple( SQLInsert.class.getName() );
 	DotName SQL_UPDATE = DotName.createSimple( SQLUpdate.class.getName() );
 	DotName SUB_SELECT = DotName.createSimple( Subselect.class.getName() );
 	DotName SYNCHRONIZE = DotName.createSimple( Synchronize.class.getName() );
 	DotName TABLE = DotName.createSimple( Table.class.getName() );
 	DotName TABLES = DotName.createSimple( Tables.class.getName() );
 	DotName TARGET = DotName.createSimple( Target.class.getName() );
 	DotName TUPLIZER = DotName.createSimple( Tuplizer.class.getName() );
 	DotName TUPLIZERS = DotName.createSimple( Tuplizers.class.getName() );
 	DotName TYPE = DotName.createSimple( Type.class.getName() );
 	DotName TYPE_DEF = DotName.createSimple( TypeDef.class.getName() );
 	DotName TYPE_DEFS = DotName.createSimple( TypeDefs.class.getName() );
 	DotName WHERE = DotName.createSimple( Where.class.getName() );
 	DotName WHERE_JOIN_TABLE = DotName.createSimple( WhereJoinTable.class.getName() );
 }
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/JPADotNames.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JPADotNames.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/JPADotNames.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JPADotNames.java
index 5c9bcabd3b..70d0235d3f 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/JPADotNames.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JPADotNames.java
@@ -1,207 +1,207 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations;
+package org.hibernate.metamodel.source.annotations;
 
 import javax.persistence.Access;
 import javax.persistence.AccessType;
 import javax.persistence.AssociationOverride;
 import javax.persistence.AssociationOverrides;
 import javax.persistence.AttributeOverride;
 import javax.persistence.AttributeOverrides;
 import javax.persistence.Basic;
 import javax.persistence.Cacheable;
 import javax.persistence.CascadeType;
 import javax.persistence.CollectionTable;
 import javax.persistence.Column;
 import javax.persistence.ColumnResult;
 import javax.persistence.DiscriminatorColumn;
 import javax.persistence.DiscriminatorType;
 import javax.persistence.DiscriminatorValue;
 import javax.persistence.ElementCollection;
 import javax.persistence.Embeddable;
 import javax.persistence.Embedded;
 import javax.persistence.EmbeddedId;
 import javax.persistence.Entity;
 import javax.persistence.EntityListeners;
 import javax.persistence.EntityResult;
 import javax.persistence.EnumType;
 import javax.persistence.Enumerated;
 import javax.persistence.ExcludeDefaultListeners;
 import javax.persistence.ExcludeSuperclassListeners;
 import javax.persistence.FetchType;
 import javax.persistence.FieldResult;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 import javax.persistence.IdClass;
 import javax.persistence.Inheritance;
 import javax.persistence.InheritanceType;
 import javax.persistence.JoinColumn;
 import javax.persistence.JoinColumns;
 import javax.persistence.JoinTable;
 import javax.persistence.Lob;
 import javax.persistence.LockModeType;
 import javax.persistence.ManyToMany;
 import javax.persistence.ManyToOne;
 import javax.persistence.MapKey;
 import javax.persistence.MapKeyClass;
 import javax.persistence.MapKeyColumn;
 import javax.persistence.MapKeyEnumerated;
 import javax.persistence.MapKeyJoinColumn;
 import javax.persistence.MapKeyJoinColumns;
 import javax.persistence.MapKeyTemporal;
 import javax.persistence.MappedSuperclass;
 import javax.persistence.MapsId;
 import javax.persistence.NamedNativeQueries;
 import javax.persistence.NamedNativeQuery;
 import javax.persistence.NamedQueries;
 import javax.persistence.NamedQuery;
 import javax.persistence.OneToMany;
 import javax.persistence.OneToOne;
 import javax.persistence.OrderBy;
 import javax.persistence.OrderColumn;
 import javax.persistence.PersistenceContext;
 import javax.persistence.PersistenceContexts;
 import javax.persistence.PersistenceProperty;
 import javax.persistence.PersistenceUnit;
 import javax.persistence.PersistenceUnits;
 import javax.persistence.PostLoad;
 import javax.persistence.PostPersist;
 import javax.persistence.PostRemove;
 import javax.persistence.PostUpdate;
 import javax.persistence.PrePersist;
 import javax.persistence.PreRemove;
 import javax.persistence.PreUpdate;
 import javax.persistence.PrimaryKeyJoinColumn;
 import javax.persistence.PrimaryKeyJoinColumns;
 import javax.persistence.QueryHint;
 import javax.persistence.SecondaryTable;
 import javax.persistence.SecondaryTables;
 import javax.persistence.SequenceGenerator;
 import javax.persistence.SqlResultSetMapping;
 import javax.persistence.SqlResultSetMappings;
 import javax.persistence.Table;
 import javax.persistence.TableGenerator;
 import javax.persistence.Temporal;
 import javax.persistence.TemporalType;
 import javax.persistence.Transient;
 import javax.persistence.UniqueConstraint;
 import javax.persistence.Version;
 
 import org.jboss.jandex.DotName;
 
 /**
  * Defines the dot names for the JPA annotations
  *
  * @author Hardy Ferentschik
  */
 public interface JPADotNames {
 	DotName ACCESS = DotName.createSimple( Access.class.getName() );
 	DotName ACCESS_TYPE = DotName.createSimple( AccessType.class.getName() );
 	DotName ASSOCIATION_OVERRIDE = DotName.createSimple( AssociationOverride.class.getName() );
 	DotName ASSOCIATION_OVERRIDES = DotName.createSimple( AssociationOverrides.class.getName() );
 	DotName ATTRIBUTE_OVERRIDE = DotName.createSimple( AttributeOverride.class.getName() );
 	DotName ATTRIBUTE_OVERRIDES = DotName.createSimple( AttributeOverrides.class.getName() );
 	DotName BASIC = DotName.createSimple( Basic.class.getName() );
 	DotName CACHEABLE = DotName.createSimple( Cacheable.class.getName() );
 	DotName CASCADE_TYPE = DotName.createSimple( CascadeType.class.getName() );
 	DotName COLLECTION_TABLE = DotName.createSimple( CollectionTable.class.getName() );
 	DotName COLUMN = DotName.createSimple( Column.class.getName() );
 	DotName COLUMN_RESULT = DotName.createSimple( ColumnResult.class.getName() );
 	DotName DISCRIMINATOR_COLUMN = DotName.createSimple( DiscriminatorColumn.class.getName() );
 	DotName DISCRIMINATOR_TYPE = DotName.createSimple( DiscriminatorType.class.getName() );
 	DotName DISCRIMINATOR_VALUE = DotName.createSimple( DiscriminatorValue.class.getName() );
 	DotName ELEMENT_COLLECTION = DotName.createSimple( ElementCollection.class.getName() );
 	DotName EMBEDDABLE = DotName.createSimple( Embeddable.class.getName() );
 	DotName EMBEDDED = DotName.createSimple( Embedded.class.getName() );
 	DotName EMBEDDED_ID = DotName.createSimple( EmbeddedId.class.getName() );
 	DotName ENTITY = DotName.createSimple( Entity.class.getName() );
 	DotName ENTITY_LISTENERS = DotName.createSimple( EntityListeners.class.getName() );
 	DotName ENTITY_RESULT = DotName.createSimple( EntityResult.class.getName() );
 	DotName ENUMERATED = DotName.createSimple( Enumerated.class.getName() );
 	DotName ENUM_TYPE = DotName.createSimple( EnumType.class.getName() );
 	DotName EXCLUDE_DEFAULT_LISTENERS = DotName.createSimple( ExcludeDefaultListeners.class.getName() );
 	DotName EXCLUDE_SUPERCLASS_LISTENERS = DotName.createSimple( ExcludeSuperclassListeners.class.getName() );
 	DotName FETCH_TYPE = DotName.createSimple( FetchType.class.getName() );
 	DotName FIELD_RESULT = DotName.createSimple( FieldResult.class.getName() );
 	DotName GENERATION_TYPE = DotName.createSimple( GenerationType.class.getName() );
 	DotName GENERATED_VALUE = DotName.createSimple( GeneratedValue.class.getName() );
 	DotName ID = DotName.createSimple( Id.class.getName() );
 	DotName ID_CLASS = DotName.createSimple( IdClass.class.getName() );
 	DotName INHERITANCE_TYPE = DotName.createSimple( InheritanceType.class.getName() );
 	DotName JOIN_COLUMN = DotName.createSimple( JoinColumn.class.getName() );
 	DotName INHERITANCE = DotName.createSimple( Inheritance.class.getName() );
 	DotName JOIN_COLUMNS = DotName.createSimple( JoinColumns.class.getName() );
 	DotName JOIN_TABLE = DotName.createSimple( JoinTable.class.getName() );
 	DotName LOB = DotName.createSimple( Lob.class.getName() );
 	DotName LOCK_MODE_TYPE = DotName.createSimple( LockModeType.class.getName() );
 	DotName MANY_TO_MANY = DotName.createSimple( ManyToMany.class.getName() );
 	DotName MANY_TO_ONE = DotName.createSimple( ManyToOne.class.getName() );
 	DotName MAP_KEY = DotName.createSimple( MapKey.class.getName() );
 	DotName MAP_KEY_CLASS = DotName.createSimple( MapKeyClass.class.getName() );
 	DotName MAP_KEY_COLUMN = DotName.createSimple( MapKeyColumn.class.getName() );
 	DotName MAP_KEY_ENUMERATED = DotName.createSimple( MapKeyEnumerated.class.getName() );
 	DotName MAP_KEY_JOIN_COLUMN = DotName.createSimple( MapKeyJoinColumn.class.getName() );
 	DotName MAP_KEY_JOIN_COLUMNS = DotName.createSimple( MapKeyJoinColumns.class.getName() );
 	DotName MAP_KEY_TEMPORAL = DotName.createSimple( MapKeyTemporal.class.getName() );
 	DotName MAPPED_SUPERCLASS = DotName.createSimple( MappedSuperclass.class.getName() );
 	DotName MAPS_ID = DotName.createSimple( MapsId.class.getName() );
 	DotName NAMED_NATIVE_QUERIES = DotName.createSimple( NamedNativeQueries.class.getName() );
 	DotName NAMED_NATIVE_QUERY = DotName.createSimple( NamedNativeQuery.class.getName() );
 	DotName NAMED_QUERIES = DotName.createSimple( NamedQueries.class.getName() );
 	DotName NAMED_QUERY = DotName.createSimple( NamedQuery.class.getName() );
 	DotName ONE_TO_MANY = DotName.createSimple( OneToMany.class.getName() );
 	DotName ONE_TO_ONE = DotName.createSimple( OneToOne.class.getName() );
 	DotName ORDER_BY = DotName.createSimple( OrderBy.class.getName() );
 	DotName ORDER_COLUMN = DotName.createSimple( OrderColumn.class.getName() );
 	DotName PERSISTENCE_CONTEXT = DotName.createSimple( PersistenceContext.class.getName() );
 	DotName PERSISTENCE_CONTEXTS = DotName.createSimple( PersistenceContexts.class.getName() );
 	DotName PERSISTENCE_PROPERTY = DotName.createSimple( PersistenceProperty.class.getName() );
 	DotName PERSISTENCE_UNIT = DotName.createSimple( PersistenceUnit.class.getName() );
 	DotName PERSISTENCE_UNITS = DotName.createSimple( PersistenceUnits.class.getName() );
 	DotName POST_LOAD = DotName.createSimple( PostLoad.class.getName() );
 	DotName POST_PERSIST = DotName.createSimple( PostPersist.class.getName() );
 	DotName POST_REMOVE = DotName.createSimple( PostRemove.class.getName() );
 	DotName POST_UPDATE = DotName.createSimple( PostUpdate.class.getName() );
 	DotName PRE_PERSIST = DotName.createSimple( PrePersist.class.getName() );
 	DotName PRE_REMOVE = DotName.createSimple( PreRemove.class.getName() );
 	DotName PRE_UPDATE = DotName.createSimple( PreUpdate.class.getName() );
 	DotName PRIMARY_KEY_JOIN_COLUMN = DotName.createSimple( PrimaryKeyJoinColumn.class.getName() );
 	DotName PRIMARY_KEY_JOIN_COLUMNS = DotName.createSimple( PrimaryKeyJoinColumns.class.getName() );
 	DotName QUERY_HINT = DotName.createSimple( QueryHint.class.getName() );
 	DotName SECONDARY_TABLE = DotName.createSimple( SecondaryTable.class.getName() );
 	DotName SECONDARY_TABLES = DotName.createSimple( SecondaryTables.class.getName() );
 	DotName SEQUENCE_GENERATOR = DotName.createSimple( SequenceGenerator.class.getName() );
 	DotName SQL_RESULT_SET_MAPPING = DotName.createSimple( SqlResultSetMapping.class.getName() );
 	DotName SQL_RESULT_SET_MAPPINGS = DotName.createSimple( SqlResultSetMappings.class.getName() );
 	DotName TABLE = DotName.createSimple( Table.class.getName() );
 	DotName TABLE_GENERATOR = DotName.createSimple( TableGenerator.class.getName() );
 	DotName TEMPORAL = DotName.createSimple( Temporal.class.getName() );
 	DotName TEMPORAL_TYPE = DotName.createSimple( TemporalType.class.getName() );
 	DotName TRANSIENT = DotName.createSimple( Transient.class.getName() );
 	DotName UNIQUE_CONSTRAINT = DotName.createSimple( UniqueConstraint.class.getName() );
 	DotName VERSION = DotName.createSimple( Version.class.getName() );
 }
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/JandexHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JandexHelper.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/JandexHelper.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JandexHelper.java
index a7888d3b8c..6ef9d665ae 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/JandexHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JandexHelper.java
@@ -1,364 +1,364 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations;
+package org.hibernate.metamodel.source.annotations;
 
 import java.beans.Introspector;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.Array;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.FieldInfo;
 import org.jboss.jandex.Index;
 import org.jboss.jandex.Indexer;
 import org.jboss.jandex.MethodInfo;
 import org.jboss.jandex.Type;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 
 /**
  * Utility methods for working with the jandex annotation index.
  *
  * @author Hardy Ferentschik
  */
 public class JandexHelper {
 	private static final Map<String, Object> DEFAULT_VALUES_BY_ELEMENT = new HashMap<String, Object>();
 
 	/**
 	 * Retrieves a jandex annotation element value. If the value is {@code null}, the default value specified in the
 	 * annotation class is retrieved instead.
 	 * <p>
 	 * There are two special cases. {@code Class} parameters should be retrieved as strings (and then can later be
 	 * loaded) and enumerated values should be retrieved via {@link #getValueAsEnum(AnnotationInstance, String, Class)}.
 	 * </p>
 	 *
 	 * @param annotation the annotation containing the element with the supplied name
 	 * @param element the name of the element value to be retrieve
 	 * @param type the type of element to retrieve. The following types are supported:
 	 * <ul>
 	 * <li>Byte</li>
 	 * <li>Short</li>
 	 * <li>Integer</li>
 	 * <li>Character</li>
 	 * <li>Float</li>
 	 * <li>Double</li>
 	 * <li>Long</li>
 	 * <li>Boolean</li>
 	 * <li>String</li>
 	 * <li>AnnotationInstance</li>
 	 *
 	 * @return the value if not {@code null}, else the default value if not
 	 *         {@code null}, else {@code null}.
 	 *
 	 * @throws AssertionFailure in case the specified {@code type} is a class instance or the specified type causes a {@code ClassCastException}
 	 * when retrieving the value.
 	 */
 	@SuppressWarnings("unchecked")
 	public static <T> T getValue(AnnotationInstance annotation, String element, Class<T> type) throws AssertionFailure {
 		if ( Class.class.equals( type ) ) {
 			throw new AssertionFailure(
 					"Annotation parameters of type Class should be retrieved as strings (fully qualified class names)"
 			);
 		}
 
 		// try getting the untyped value from Jandex
 		AnnotationValue annotationValue = annotation.value( element );
 
 		try {
 			if ( annotationValue != null ) {
 				return explicitAnnotationParameter( annotationValue, type );
 			}
 			else {
 				return defaultAnnotationParameter( getDefaultValue( annotation, element ), type );
 			}
 		}
 		catch ( ClassCastException e ) {
 			throw new AssertionFailure(
 					String.format(
 							"the annotation property %s of annotation %s is not of type %s",
 							element,
 							annotation.name(),
 							type.getName()
 					)
 			);
 		}
 	}
 
 	/**
 	 * Retrieves a jandex annotation element value, converting it to the supplied enumerated type.  If the value is
 	 * <code>null</code>, the default value specified in the annotation class is retrieved instead.
 	 *
 	 * @param <T> an enumerated type
 	 * @param annotation the annotation containing the enumerated element with the supplied name
 	 * @param element the name of the enumerated element value to be retrieve
 	 * @param type the type to which to convert the value before being returned
 	 *
 	 * @return the value converted to the supplied enumerated type if the value is not <code>null</code>, else the default value if
 	 *         not <code>null</code>, else <code>null</code>.
 	 *
 	 * @see #getValue(AnnotationInstance, String, Class)
 	 */
 	@SuppressWarnings("unchecked")
 	public static <T extends Enum<T>> T getValueAsEnum(AnnotationInstance annotation, String element, Class<T> type) {
 		AnnotationValue val = annotation.value( element );
 		if ( val == null ) {
 			return (T) getDefaultValue( annotation, element );
 		}
 		return Enum.valueOf( type, val.asEnum() );
 	}
 
 	/**
 	 * Expects a method or field annotation target and returns the property name for this target
 	 *
 	 * @param target the annotation target
 	 *
 	 * @return the property name of the target. For a field it is the field name and for a method name it is
 	 *         the method name stripped of 'is', 'has' or 'get'
 	 */
 	public static String getPropertyName(AnnotationTarget target) {
 		if ( !( target instanceof MethodInfo || target instanceof FieldInfo ) ) {
 			throw new AssertionFailure( "Unexpected annotation target " + target.toString() );
 		}
 
 		if ( target instanceof FieldInfo ) {
 			return ( (FieldInfo) target ).name();
 		}
 		else {
 			final String methodName = ( (MethodInfo) target ).name();
 			String propertyName;
 			if ( methodName.startsWith( "is" ) ) {
 				propertyName = Introspector.decapitalize( methodName.substring( 2 ) );
 			}
 			else if ( methodName.startsWith( "has" ) ) {
 				propertyName = Introspector.decapitalize( methodName.substring( 3 ) );
 			}
 			else if ( methodName.startsWith( "get" ) ) {
 				propertyName = Introspector.decapitalize( methodName.substring( 3 ) );
 			}
 			else {
 				throw new AssertionFailure( "Expected a method following the Java Bean notation" );
 			}
 			return propertyName;
 		}
 	}
 
 	/**
 	 * @param classInfo the class info from which to retrieve the annotation instance
 	 * @param annotationName the annotation to retrieve from the class info
 	 *
 	 * @return the single annotation defined on the class or {@code null} in case the annotation is not specified at all
 	 *
 	 * @throws org.hibernate.AssertionFailure in case there is there is more than one annotation of this type.
 	 */
 	public static AnnotationInstance getSingleAnnotation(ClassInfo classInfo, DotName annotationName)
 			throws AssertionFailure {
 		return getSingleAnnotation( classInfo.annotations(), annotationName );
 	}
 
 	/**
 	 * @param annotations List of annotation instances keyed against their dot name.
 	 * @param annotationName the annotation to retrieve from map
 	 *
 	 * @return the single annotation of the specified dot name or {@code null} in case the annotation is not specified at all
 	 *
 	 * @throws org.hibernate.AssertionFailure in case there is there is more than one annotation of this type.
 	 */
 	public static AnnotationInstance getSingleAnnotation(Map<DotName, List<AnnotationInstance>> annotations, DotName annotationName)
 			throws AssertionFailure {
 		List<AnnotationInstance> annotationList = annotations.get( annotationName );
 		if ( annotationList == null ) {
 			return null;
 		}
 		else if ( annotationList.size() == 1 ) {
 			return annotationList.get( 0 );
 		}
 		else {
 			throw new AssertionFailure(
 					"Found more than one instance of the annotation "
 							+ annotationList.get( 0 ).name().toString()
 							+ ". Expected was one."
 			);
 		}
 	}
 
 	/**
 	 * Creates a jandex index for the specified classes
 	 *
 	 * @param classLoaderService class loader service
 	 * @param classes the classes to index
 	 *
 	 * @return an annotation repository w/ all the annotation discovered in the specified classes
 	 */
 	public static Index indexForClass(ClassLoaderService classLoaderService, Class<?>... classes) {
 		Indexer indexer = new Indexer();
 		for ( Class<?> clazz : classes ) {
 			InputStream stream = classLoaderService.locateResourceStream(
 					clazz.getName().replace( '.', '/' ) + ".class"
 			);
 			try {
 				indexer.index( stream );
 			}
 			catch ( IOException e ) {
 				StringBuilder builder = new StringBuilder();
 				builder.append( "[" );
 				int count = 0;
 				for ( Class<?> c : classes ) {
 					builder.append( c.getName() );
 					if ( count < classes.length - 1 ) {
 						builder.append( "," );
 					}
 					count++;
 				}
 				builder.append( "]" );
 				throw new HibernateException( "Unable to create annotation index for " + builder.toString() );
 			}
 		}
 		return indexer.complete();
 	}
 
 	public static Map<DotName, List<AnnotationInstance>> getMemberAnnotations(ClassInfo classInfo, String name) {
 		if ( classInfo == null ) {
 			throw new IllegalArgumentException( "classInfo cannot be null" );
 		}
 
 		if ( name == null ) {
 			throw new IllegalArgumentException( "name cannot be null" );
 		}
 
 		Map<DotName, List<AnnotationInstance>> annotations = new HashMap<DotName, List<AnnotationInstance>>();
 		for ( List<AnnotationInstance> annotationList : classInfo.annotations().values() ) {
 			for ( AnnotationInstance instance : annotationList ) {
 				String targetName = null;
 				if ( instance.target() instanceof FieldInfo ) {
 					targetName = ( (FieldInfo) instance.target() ).name();
 				}
 				else if ( instance.target() instanceof MethodInfo ) {
 					targetName = ( (MethodInfo) instance.target() ).name();
 				}
 				if ( targetName != null && name.equals( targetName ) ) {
 					addAnnotationToMap( instance, annotations );
 				}
 			}
 		}
 		return annotations;
 	}
 
 	public static Map<DotName, List<AnnotationInstance>> getTypeAnnotations(ClassInfo classInfo) {
 		if ( classInfo == null ) {
 			throw new IllegalArgumentException( "classInfo cannot be null" );
 		}
 
 		Map<DotName, List<AnnotationInstance>> annotations = new HashMap<DotName, List<AnnotationInstance>>();
 		for ( List<AnnotationInstance> annotationList : classInfo.annotations().values() ) {
 			for ( AnnotationInstance instance : annotationList ) {
 				if ( instance.target() instanceof ClassInfo ) {
 					addAnnotationToMap( instance, annotations );
 				}
 			}
 		}
 		return annotations;
 	}
 
 	public static void addAnnotationToMap(AnnotationInstance instance, Map<DotName, List<AnnotationInstance>> annotations) {
 		DotName dotName = instance.name();
 		List<AnnotationInstance> list;
 		if ( annotations.containsKey( dotName ) ) {
 			list = annotations.get( dotName );
 		}
 		else {
 			list = new ArrayList<AnnotationInstance>();
 			annotations.put( dotName, list );
 		}
 		list.add( instance );
 	}
 
 	private JandexHelper() {
 	}
 
 	private static Object getDefaultValue(AnnotationInstance annotation, String element) {
 		String name = annotation.name().toString();
 		String fqElement = name + '.' + element;
 		Object val = DEFAULT_VALUES_BY_ELEMENT.get( fqElement );
 		if ( val != null ) {
 			return val;
 		}
 		try {
 			val = Index.class.getClassLoader().loadClass( name ).getMethod( element ).getDefaultValue();
 			DEFAULT_VALUES_BY_ELEMENT.put( fqElement, val );
 			return val == null ? null : val;
 		}
 		catch ( RuntimeException error ) {
 			throw error;
 		}
 		catch ( Exception error ) {
 			throw new AnnotationException( error );
 		}
 	}
 
 	private static <T> T defaultAnnotationParameter(Object defaultValue, Class<T> type) {
 		Object returnValue = defaultValue;
 
 		// resolve some mismatches between what's stored in jandex and what the defaults are for annotations
 		// in case of nested annotation arrays, jandex returns arrays of AnnotationInstances, hence we return
 		// an empty array of this type here
 		if ( defaultValue.getClass().isArray() && defaultValue.getClass().getComponentType().isAnnotation() ) {
 			returnValue = new AnnotationInstance[0];
 		}
 		return type.cast( returnValue );
 	}
 
 	private static <T> T explicitAnnotationParameter(AnnotationValue annotationValue, Class<T> type) {
 		Object returnValue = annotationValue.value();
 
 		// if the jandex return type is Type we actually try to retrieve a class parameter
 		// for our purposes we just return the fqcn of the class
 		if ( returnValue instanceof Type ) {
 			returnValue = ( (Type) returnValue ).name().toString();
 		}
 
 		// arrays we have to handle explicitly
 		if ( type.isArray() ) {
 			AnnotationValue[] values = (AnnotationValue[]) returnValue;
 			Class<?> componentType = type.getComponentType();
 			Object[] arr = (Object[]) Array.newInstance( componentType, values.length );
 			for ( int i = 0; i < values.length; i++ ) {
 				arr[i] = componentType.cast( values[i].value() );
 			}
 			returnValue = arr;
 		}
 
 		return type.cast( returnValue );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/ReflectionHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/ReflectionHelper.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/ReflectionHelper.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/ReflectionHelper.java
index 06aeb66200..c21a69e426 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/ReflectionHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/ReflectionHelper.java
@@ -1,64 +1,64 @@
-package org.hibernate.metamodel.binder.source.annotations;
+package org.hibernate.metamodel.source.annotations;
 
 import java.beans.Introspector;
 import java.lang.reflect.Field;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 
 /**
  * Some helper methods for reflection tasks
  *
  * @author Hardy Ferentschik
  */
 public class ReflectionHelper {
 
 	private ReflectionHelper() {
 	}
 
 	/**
 	 * Process bean properties getter by applying the JavaBean naming conventions.
 	 *
 	 * @param member the member for which to get the property name.
 	 *
 	 * @return The bean method name with the "is" or "get" prefix stripped off, {@code null}
 	 *         the method name id not according to the JavaBeans standard.
 	 */
 	public static String getPropertyName(Member member) {
 		String name = null;
 
 		if ( member instanceof Field ) {
 			name = member.getName();
 		}
 
 		if ( member instanceof Method ) {
 			String methodName = member.getName();
 			if ( methodName.startsWith( "is" ) ) {
 				name = Introspector.decapitalize( methodName.substring( 2 ) );
 			}
 			else if ( methodName.startsWith( "has" ) ) {
 				name = Introspector.decapitalize( methodName.substring( 3 ) );
 			}
 			else if ( methodName.startsWith( "get" ) ) {
 				name = Introspector.decapitalize( methodName.substring( 3 ) );
 			}
 		}
 		return name;
 	}
 
 	public static boolean isProperty(Member m) {
 		if ( m instanceof Method ) {
 			Method method = (Method) m;
 			return !method.isSynthetic()
 					&& !method.isBridge()
 					&& !Modifier.isStatic( method.getModifiers() )
 					&& method.getParameterTypes().length == 0
 					&& ( method.getName().startsWith( "get" ) || method.getName().startsWith( "is" ) );
 		}
 		else {
 			return !Modifier.isTransient( m.getModifiers() ) && !m.isSynthetic();
 		}
 	}
 }
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/UnknownInheritanceTypeException.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/UnknownInheritanceTypeException.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/UnknownInheritanceTypeException.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/UnknownInheritanceTypeException.java
index e6f7de4066..1f492d5d6c 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/UnknownInheritanceTypeException.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/UnknownInheritanceTypeException.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations;
+package org.hibernate.metamodel.source.annotations;
 
 import org.hibernate.HibernateException;
 
 /**
  * @author Steve Ebersole
  */
 public class UnknownInheritanceTypeException extends HibernateException {
 	public UnknownInheritanceTypeException(String message) {
 		super( message );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/AssociationAttribute.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/AssociationAttribute.java
index f622922b21..d4542237fd 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/AssociationAttribute.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/AssociationAttribute.java
@@ -1,125 +1,125 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.attribute;
 
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.persistence.CascadeType;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.DotName;
 
 import org.hibernate.annotations.NotFoundAction;
-import org.hibernate.metamodel.binder.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.annotations.HibernateDotNames;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
 
 /**
  * @author Hardy Ferentschik
  */
 public class AssociationAttribute extends SimpleAttribute {
 	private final AttributeType associationType;
 	private final boolean ignoreNotFound;
 	private final String referencedEntityType;
 	private final Set<CascadeType> cascadeTypes;
 
 	public static AssociationAttribute createAssociationAttribute(String name, String type, AttributeType associationType, Map<DotName, List<AnnotationInstance>> annotations) {
 		return new AssociationAttribute( name, type, associationType, annotations );
 	}
 
 	private AssociationAttribute(String name, String type, AttributeType associationType, Map<DotName, List<AnnotationInstance>> annotations) {
 		super( name, type, annotations, false );
 		this.associationType = associationType;
 		this.ignoreNotFound = ignoreNotFound();
 
 		AnnotationInstance associationAnnotation = JandexHelper.getSingleAnnotation(
 				annotations,
 				associationType.getAnnotationDotName()
 		);
 
 		referencedEntityType = determineReferencedEntityType( associationAnnotation );
 		cascadeTypes = determineCascadeTypes( associationAnnotation );
 	}
 
 	public boolean isIgnoreNotFound() {
 		return ignoreNotFound;
 	}
 
 	public String getReferencedEntityType() {
 		return referencedEntityType;
 	}
 
 	public AttributeType getAssociationType() {
 		return associationType;
 	}
 
 	public Set<CascadeType> getCascadeTypes() {
 		return cascadeTypes;
 	}
 
 	private boolean ignoreNotFound() {
 		NotFoundAction action = NotFoundAction.EXCEPTION;
 		AnnotationInstance notFoundAnnotation = getIfExists( HibernateDotNames.NOT_FOUND );
 		if ( notFoundAnnotation != null ) {
 			AnnotationValue actionValue = notFoundAnnotation.value( "action" );
 			if ( actionValue != null ) {
 				action = Enum.valueOf( NotFoundAction.class, actionValue.asEnum() );
 			}
 		}
 
 		return NotFoundAction.IGNORE.equals( action );
 	}
 
 	private String determineReferencedEntityType(AnnotationInstance associationAnnotation) {
 		String targetTypeName = getType();
 
 		AnnotationInstance targetAnnotation = getIfExists( HibernateDotNames.TARGET );
 		if ( targetAnnotation != null ) {
 			targetTypeName = targetAnnotation.value().asClass().name().toString();
 		}
 
 		AnnotationValue targetEntityValue = associationAnnotation.value( "targetEntity" );
 		if ( targetEntityValue != null ) {
 			targetTypeName = targetEntityValue.asClass().name().toString();
 		}
 
 		return targetTypeName;
 	}
 
 	private Set<CascadeType> determineCascadeTypes(AnnotationInstance associationAnnotation) {
 		Set<CascadeType> cascadeTypes = new HashSet<CascadeType>();
 		AnnotationValue cascadeValue = associationAnnotation.value( "cascade" );
 		if ( cascadeValue != null ) {
 			String[] cascades = cascadeValue.asEnumArray();
 			for ( String s : cascades ) {
 				cascadeTypes.add( Enum.valueOf( CascadeType.class, s ) );
 			}
 		}
 		return cascadeTypes;
 	}
 }
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/DiscriminatorColumnValues.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/DiscriminatorColumnValues.java
index 5e9839febf..05cc3ac20b 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/DiscriminatorColumnValues.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/DiscriminatorColumnValues.java
@@ -1,115 +1,115 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.attribute;
 
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.DotName;
 
 import org.hibernate.metamodel.source.annotations.HibernateDotNames;
 import org.hibernate.metamodel.source.annotations.JPADotNames;
-import org.hibernate.metamodel.source.annotations.util.JandexHelper;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
 
 /**
  * Container for the properties of a discriminator column.
  *
  * @author Hardy Ferentschik
  */
 public class DiscriminatorColumnValues extends ColumnValues {
 	public static final String DEFAULT_DISCRIMINATOR_COLUMN_NAME = "DTYPE";
 	private static final int DEFAULT_DISCRIMINATOR_LENGTH = 31;
 
 	private boolean isForced = true;
 	private boolean isIncludedInSql = true;
 	private String discriminatorValue = null;
 
 	public DiscriminatorColumnValues(Map<DotName, List<AnnotationInstance>> annotations) {
 		super();
 
 		AnnotationInstance discriminatorOptionsAnnotation = JandexHelper.getSingleAnnotation(
 				annotations, JPADotNames.DISCRIMINATOR_COLUMN
 		);
 
 		if ( discriminatorOptionsAnnotation != null ) {
 			setName( discriminatorOptionsAnnotation.value( "name" ).asString() );
 			setLength( discriminatorOptionsAnnotation.value( "length" ).asInt() );
 			if ( discriminatorOptionsAnnotation.value( "columnDefinition" ) != null ) {
 				setColumnDefinition( discriminatorOptionsAnnotation.value( "columnDefinition" ).asString() );
 			}
 		}
 		else {
 			setName( DEFAULT_DISCRIMINATOR_COLUMN_NAME );
 			setLength( DEFAULT_DISCRIMINATOR_LENGTH );
 		}
 
 		setNullable( false );
 		setDiscriminatorValue( annotations );
 		setDiscriminatorOptions( annotations );
 		setDiscriminatorFormula( annotations );
 	}
 
 	private void setDiscriminatorValue(Map<DotName, List<AnnotationInstance>> annotations) {
 		AnnotationInstance discriminatorValueAnnotation = JandexHelper.getSingleAnnotation(
 				annotations, JPADotNames.DISCRIMINATOR_VALUE
 		);
 		if ( discriminatorValueAnnotation != null ) {
 			discriminatorValue = discriminatorValueAnnotation.value().asString();
 		}
 	}
 
 	private void setDiscriminatorFormula(Map<DotName, List<AnnotationInstance>> annotations) {
 		AnnotationInstance discriminatorFormulaAnnotation = JandexHelper.getSingleAnnotation(
 				annotations, HibernateDotNames.DISCRIMINATOR_FORMULA
 		);
 		if ( discriminatorFormulaAnnotation != null ) {
 			// todo
 		}
 	}
 
 	public boolean isForced() {
 		return isForced;
 	}
 
 	public boolean isIncludedInSql() {
 		return isIncludedInSql;
 	}
 
 	public String getDiscriminatorValue() {
 		return discriminatorValue;
 	}
 
 	private void setDiscriminatorOptions(Map<DotName, List<AnnotationInstance>> annotations) {
 		AnnotationInstance discriminatorOptionsAnnotation = JandexHelper.getSingleAnnotation(
 				annotations, HibernateDotNames.DISCRIMINATOR_OPTIONS
 		);
 		if ( discriminatorOptionsAnnotation != null ) {
 			isForced = discriminatorOptionsAnnotation.value( "force" ).asBoolean();
 			isIncludedInSql = discriminatorOptionsAnnotation.value( "insert" ).asBoolean();
 		}
 	}
 }
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/SimpleAttribute.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/SimpleAttribute.java
index 8a426978d1..c8af4abbc1 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/SimpleAttribute.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/SimpleAttribute.java
@@ -1,268 +1,268 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.attribute;
 
 import java.util.List;
 import java.util.Map;
 import javax.persistence.DiscriminatorType;
 import javax.persistence.FetchType;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.DotName;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.annotations.GenerationTime;
 import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.binder.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.annotations.HibernateDotNames;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
 
 /**
  * Represent a mapped attribute (explicitly or implicitly mapped). Also used for synthetic attributes like a
  * discriminator column.
  *
  * @author Hardy Ferentschik
  */
 public class SimpleAttribute extends MappedAttribute {
 	/**
 	 * Is this property an id property (or part thereof).
 	 */
 	private final boolean isId;
 
 	/**
 	 * Is this a versioned property (annotated w/ {@code @Version}.
 	 */
 	private final boolean isVersioned;
 
 	/**
 	 * Is this property a discriminator property.
 	 */
 	private final boolean isDiscriminator;
 
 	/**
 	 * Whether a change of the property's value triggers a version increment of the entity (in case of optimistic
 	 * locking).
 	 */
 	private final boolean isOptimisticLockable;
 
 	/**
 	 * Is this property lazy loaded (see {@link javax.persistence.Basic}).
 	 */
 	private boolean isLazy = false;
 
 	/**
 	 * Is this property optional  (see {@link javax.persistence.Basic}).
 	 */
 	private boolean isOptional = true;
 
 	private PropertyGeneration propertyGeneration;
 	private boolean isInsertable = true;
 	private boolean isUpdatable = true;
 
 	/**
 	 * Defines the column values (relational values) for this property.
 	 */
 	private ColumnValues columnValues;
 
 	public static SimpleAttribute createSimpleAttribute(String name, String type, Map<DotName, List<AnnotationInstance>> annotations) {
 		return new SimpleAttribute( name, type, annotations, false );
 	}
 
 	public static SimpleAttribute createSimpleAttribute(SimpleAttribute simpleAttribute, ColumnValues columnValues) {
 		SimpleAttribute attribute = new SimpleAttribute( simpleAttribute.getName(), simpleAttribute.getType(), simpleAttribute.annotations(), false );
 		attribute.columnValues = columnValues;
 		return attribute;
 	}
 
 	public static SimpleAttribute createDiscriminatorAttribute(Map<DotName, List<AnnotationInstance>> annotations) {
 		AnnotationInstance discriminatorOptionsAnnotation = JandexHelper.getSingleAnnotation(
 				annotations, JPADotNames.DISCRIMINATOR_COLUMN
 		);
 		String name = DiscriminatorColumnValues.DEFAULT_DISCRIMINATOR_COLUMN_NAME;
 		String type = String.class.toString(); // string is the discriminator default
 		if ( discriminatorOptionsAnnotation != null ) {
 			name = discriminatorOptionsAnnotation.value( "name" ).asString();
 
 			DiscriminatorType discriminatorType = Enum.valueOf(
 					DiscriminatorType.class, discriminatorOptionsAnnotation.value( "discriminatorType" ).asEnum()
 			);
 			switch ( discriminatorType ) {
 				case STRING: {
 					type = String.class.toString();
 					break;
 				}
 				case CHAR: {
 					type = Character.class.toString();
 					break;
 				}
 				case INTEGER: {
 					type = Integer.class.toString();
 					break;
 				}
 				default: {
 					throw new AnnotationException( "Unsupported discriminator type: " + discriminatorType );
 				}
 			}
 		}
 		return new SimpleAttribute( name, type, annotations, true );
 	}
 
 	SimpleAttribute(String name, String type, Map<DotName, List<AnnotationInstance>> annotations, boolean isDiscriminator) {
 		super( name, type, annotations );
 
 		this.isDiscriminator = isDiscriminator;
 
 
 		AnnotationInstance idAnnotation = JandexHelper.getSingleAnnotation( annotations, JPADotNames.ID );
         AnnotationInstance embeddedIdAnnotation = JandexHelper.getSingleAnnotation( annotations, JPADotNames.EMBEDDED_ID );
 		isId = !(idAnnotation == null && embeddedIdAnnotation == null);
 
 		AnnotationInstance versionAnnotation = JandexHelper.getSingleAnnotation( annotations, JPADotNames.VERSION );
 		isVersioned = versionAnnotation != null;
 
 		if ( isDiscriminator ) {
 			columnValues = new DiscriminatorColumnValues( annotations );
 		}
 		else {
 			AnnotationInstance columnAnnotation = JandexHelper.getSingleAnnotation( annotations, JPADotNames.COLUMN );
 			columnValues = new ColumnValues( columnAnnotation );
 		}
 
 		if ( isId ) {
 			// an id must be unique and cannot be nullable
 			columnValues.setUnique( true );
 			columnValues.setNullable( false );
 		}
 
 		this.isOptimisticLockable = checkOptimisticLockAnnotation();
 
 		checkBasicAnnotation();
 		checkGeneratedAnnotation();
 	}
 
 
 	public final ColumnValues getColumnValues() {
 		return columnValues;
 	}
 
 	public boolean isId() {
 		return isId;
 	}
 
 	public boolean isVersioned() {
 		return isVersioned;
 	}
 
 	public boolean isDiscriminator() {
 		return isDiscriminator;
 	}
 
 	public boolean isLazy() {
 		return isLazy;
 	}
 
 	public boolean isOptional() {
 		return isOptional;
 	}
 
 	public boolean isInsertable() {
 		return isInsertable;
 	}
 
 	public boolean isUpdatable() {
 		return isUpdatable;
 	}
 
 	public PropertyGeneration getPropertyGeneration() {
 		return propertyGeneration;
 	}
 
 	public boolean isOptimisticLockable() {
 		return isOptimisticLockable;
 	}
 
 	@Override
 	public String toString() {
 		final StringBuilder sb = new StringBuilder();
 		sb.append( "SimpleAttribute" );
 		sb.append( "{isId=" ).append( isId );
 		sb.append( ", isVersioned=" ).append( isVersioned );
 		sb.append( ", isDiscriminator=" ).append( isDiscriminator );
 		sb.append( ", isOptimisticLockable=" ).append( isOptimisticLockable );
 		sb.append( ", isLazy=" ).append( isLazy );
 		sb.append( ", isOptional=" ).append( isOptional );
 		sb.append( ", propertyGeneration=" ).append( propertyGeneration );
 		sb.append( ", isInsertable=" ).append( isInsertable );
 		sb.append( ", isUpdatable=" ).append( isUpdatable );
 		sb.append( '}' );
 		return sb.toString();
 	}
 
 	private boolean checkOptimisticLockAnnotation() {
 		boolean triggersVersionIncrement = true;
 		AnnotationInstance optimisticLockAnnotation = getIfExists( HibernateDotNames.OPTIMISTIC_LOCK );
 		if ( optimisticLockAnnotation != null ) {
 			boolean exclude = optimisticLockAnnotation.value( "excluded" ).asBoolean();
 			triggersVersionIncrement = !exclude;
 		}
 		return triggersVersionIncrement;
 	}
 
 	private void checkBasicAnnotation() {
 		AnnotationInstance basicAnnotation = getIfExists( JPADotNames.BASIC );
 		if ( basicAnnotation != null ) {
 			FetchType fetchType = FetchType.LAZY;
 			AnnotationValue fetchValue = basicAnnotation.value( "fetch" );
 			if ( fetchValue != null ) {
 				fetchType = Enum.valueOf( FetchType.class, fetchValue.asEnum() );
 			}
 			this.isLazy = fetchType == FetchType.LAZY;
 
 			AnnotationValue optionalValue = basicAnnotation.value( "optional" );
 			if ( optionalValue != null ) {
 				this.isOptional = optionalValue.asBoolean();
 			}
 		}
 	}
 
 	// TODO - there is more todo for updatable and insertable. Checking the @Generated annotation is only one part (HF)
 	private void checkGeneratedAnnotation() {
 		AnnotationInstance generatedAnnotation = getIfExists( HibernateDotNames.GENERATED );
 		if ( generatedAnnotation != null ) {
 			this.isInsertable = false;
 
 			AnnotationValue generationTimeValue = generatedAnnotation.value();
 			if ( generationTimeValue != null ) {
 				GenerationTime genTime = Enum.valueOf( GenerationTime.class, generationTimeValue.asEnum() );
 				if ( GenerationTime.ALWAYS.equals( genTime ) ) {
 					this.isUpdatable = false;
 					this.propertyGeneration = PropertyGeneration.parse( genTime.toString().toLowerCase() );
 				}
 			}
 		}
 	}
 }
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/state/binding/AttributeBindingStateImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/state/binding/AttributeBindingStateImpl.java
index 5b814f14a0..d52329c02a 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/state/binding/AttributeBindingStateImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/state/binding/AttributeBindingStateImpl.java
@@ -1,126 +1,126 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.attribute.state.binding;
 
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
+import org.hibernate.metamodel.source.MetaAttributeContext;
 import org.hibernate.metamodel.binding.CascadeType;
 import org.hibernate.metamodel.binding.state.SimpleAttributeBindingState;
 import org.hibernate.metamodel.source.annotations.attribute.SimpleAttribute;
 
 
 /**
  * Implementation of the attribute binding state via annotation configuration.
  *
  * @author Hardy Ferentschik
  * @todo in the end we can maybe just let MappedAttribute implement SimpleAttributeBindingState. (HF)
  */
 public class AttributeBindingStateImpl implements SimpleAttributeBindingState {
 	private final SimpleAttribute mappedAttribute;
 
 	public AttributeBindingStateImpl(SimpleAttribute mappedAttribute) {
 		this.mappedAttribute = mappedAttribute;
 	}
 
 	@Override
 	public String getAttributeName() {
 		return mappedAttribute.getName();
 	}
 
 	@Override
 	public PropertyGeneration getPropertyGeneration() {
 		return mappedAttribute.getPropertyGeneration();
 	}
 
 	@Override
 	public boolean isInsertable() {
 		return mappedAttribute.isInsertable();
 	}
 
 	@Override
 	public boolean isUpdatable() {
 		return mappedAttribute.isUpdatable();
 	}
 
 	@Override
 	public String getTypeName() {
 		return mappedAttribute.getType();
 	}
 
 	@Override
 	public Map<String, String> getTypeParameters() {
 		return mappedAttribute.getTypeParameters();
 	}
 
 	@Override
 	public boolean isLazy() {
 		return mappedAttribute.isLazy();
 	}
 
 	@Override
 	public boolean isOptimisticLockable() {
 		return mappedAttribute.isOptimisticLockable();
 	}
 
 	@Override
 	public boolean isKeyCascadeDeleteEnabled() {
 		return false;
 	}
 
 	// TODO find out more about these methods. How are they relevant for a simple attribute
 	@Override
 	public String getUnsavedValue() {
 		return null;
 	}
 
 	@Override
 	public String getPropertyAccessorName() {
 		return null;
 	}
 
 	@Override
 	public boolean isAlternateUniqueKey() {
 		return false;
 	}
 
 	@Override
 	public Set<CascadeType> getCascadeTypes() {
 		return null;
 	}
 
 	@Override
 	public String getNodeName() {
 		return null;
 	}
 
 	@Override
 	public MetaAttributeContext getMetaAttributeContext() {
 		return null;
 	}
 }
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/state/relational/ColumnRelationalStateImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/state/relational/ColumnRelationalStateImpl.java
index 9ed2072bd8..f3be699d8f 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/state/relational/ColumnRelationalStateImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/attribute/state/relational/ColumnRelationalStateImpl.java
@@ -1,224 +1,224 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.attribute.state.relational;
 
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 import org.jboss.jandex.AnnotationInstance;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.metamodel.relational.Size;
 import org.hibernate.metamodel.relational.state.ColumnRelationalState;
 import org.hibernate.metamodel.source.annotations.HibernateDotNames;
 import org.hibernate.metamodel.source.annotations.attribute.ColumnValues;
 import org.hibernate.metamodel.source.annotations.attribute.SimpleAttribute;
 
 /**
  * @author Hardy Ferentschik
  */
 public class ColumnRelationalStateImpl implements ColumnRelationalState {
 	private final NamingStrategy namingStrategy;
 	private final String columnName;
 	private final boolean unique;
 	private final boolean nullable;
     private final boolean globallyQuotedIdentifiers;
 	private final Size size;
 	private final String checkCondition;
 	private final String customWriteFragment;
 	private final String customReadFragment;
 	private final Set<String> indexes;
 
 	// todo - what about these annotations !?
 	private String defaultString;
 	private String sqlType;
 	private String comment;
 	private Set<String> uniqueKeys = new HashSet<String>();
 
 
 	public ColumnRelationalStateImpl(SimpleAttribute attribute, MetadataImplementor meta) {
 		ColumnValues columnValues = attribute.getColumnValues();
 		namingStrategy = meta.getOptions().getNamingStrategy();
         globallyQuotedIdentifiers = meta.isGloballyQuotedIdentifiers();
 		columnName = columnValues.getName().isEmpty() ? attribute.getName() : columnValues.getName();
 		unique = columnValues.isUnique();
 		nullable = columnValues.isNullable();
 		size = createSize( columnValues.getLength(), columnValues.getScale(), columnValues.getPrecision() );
 		checkCondition = parseCheckAnnotation( attribute );
 		indexes = parseIndexAnnotation( attribute );
 
 		String[] readWrite;
 		List<AnnotationInstance> columnTransformerAnnotations = getAllColumnTransformerAnnotations( attribute );
 		readWrite = createCustomReadWrite( columnTransformerAnnotations );
 		customReadFragment = readWrite[0];
 		customWriteFragment = readWrite[1];
 	}
 
 	@Override
 	public NamingStrategy getNamingStrategy() {
 		return namingStrategy;
 	}
 
     @Override
     public boolean isGloballyQuotedIdentifiers() {
         return globallyQuotedIdentifiers;
     }
 
     @Override
 	public String getExplicitColumnName() {
 		return columnName;
 	}
 
 	@Override
 	public boolean isUnique() {
 		return unique;
 	}
 
 	@Override
 	public Size getSize() {
 		return size;
 	}
 
 	@Override
 	public boolean isNullable() {
 		return nullable;
 	}
 
 	@Override
 	public String getCheckCondition() {
 		return checkCondition;
 	}
 
 	@Override
 	public String getDefault() {
 		return defaultString;
 	}
 
 	@Override
 	public String getSqlType() {
 		return sqlType;
 	}
 
 	@Override
 	public String getCustomWriteFragment() {
 		return customWriteFragment;
 	}
 
 	@Override
 	public String getCustomReadFragment() {
 		return customReadFragment;
 	}
 
 	@Override
 	public String getComment() {
 		return comment;
 	}
 
 	@Override
 	public Set<String> getUniqueKeys() {
 		return uniqueKeys;
 	}
 
 	@Override
 	public Set<String> getIndexes() {
 		return indexes;
 	}
 
 	private Size createSize(int length, int scale, int precision) {
 		Size size = new Size();
 		size.setLength( length );
 		size.setScale( scale );
 		size.setPrecision( precision );
 		return size;
 	}
 
 	private List<AnnotationInstance> getAllColumnTransformerAnnotations(SimpleAttribute attribute) {
 		List<AnnotationInstance> allColumnTransformerAnnotations = new ArrayList<AnnotationInstance>();
 
 		// not quite sure about the usefulness of @ColumnTransformers (HF)
 		AnnotationInstance columnTransformersAnnotations = attribute.getIfExists( HibernateDotNames.COLUMN_TRANSFORMERS );
 		if ( columnTransformersAnnotations != null ) {
 			AnnotationInstance[] annotationInstances = allColumnTransformerAnnotations.get( 0 ).value().asNestedArray();
 			allColumnTransformerAnnotations.addAll( Arrays.asList( annotationInstances ) );
 		}
 
 		AnnotationInstance columnTransformerAnnotation = attribute.getIfExists( HibernateDotNames.COLUMN_TRANSFORMER );
 		if ( columnTransformerAnnotation != null ) {
 			allColumnTransformerAnnotations.add( columnTransformerAnnotation );
 		}
 		return allColumnTransformerAnnotations;
 	}
 
 	private String[] createCustomReadWrite(List<AnnotationInstance> columnTransformerAnnotations) {
 		String[] readWrite = new String[2];
 
 		boolean alreadyProcessedForColumn = false;
 		for ( AnnotationInstance annotationInstance : columnTransformerAnnotations ) {
 			String forColumn = annotationInstance.value( "forColumn" ) == null ?
 					null : annotationInstance.value( "forColumn" ).asString();
 
 			if ( forColumn != null && !forColumn.equals( columnName ) ) {
 				continue;
 			}
 
 			if ( alreadyProcessedForColumn ) {
 				throw new AnnotationException( "Multiple definition of read/write conditions for column " + columnName );
 			}
 
 			readWrite[0] = annotationInstance.value( "read" ) == null ?
 					null : annotationInstance.value( "read" ).asString();
 			readWrite[1] = annotationInstance.value( "write" ) == null ?
 					null : annotationInstance.value( "write" ).asString();
 
 			alreadyProcessedForColumn = true;
 		}
 		return readWrite;
 	}
 
 	private String parseCheckAnnotation(SimpleAttribute attribute) {
 		String checkCondition = null;
 		AnnotationInstance checkAnnotation = attribute.getIfExists( HibernateDotNames.CHECK );
 		if ( checkAnnotation != null ) {
 			checkCondition = checkAnnotation.value( "constraints" ).toString();
 		}
 		return checkCondition;
 	}
 
 	private Set<String> parseIndexAnnotation(SimpleAttribute attribute) {
 		Set<String> indexNames = new HashSet<String>();
 		AnnotationInstance indexAnnotation = attribute.getIfExists( HibernateDotNames.INDEX );
 		if ( indexAnnotation != null ) {
 			String indexName = indexAnnotation.value( "name" ).toString();
 			indexNames.add( indexName );
 		}
 		return indexNames;
 	}
 }
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/ConfiguredClass.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClass.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/ConfiguredClass.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClass.java
index eae86bf3ac..69e261f4c1 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/ConfiguredClass.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClass.java
@@ -1,638 +1,637 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.entity;
+package org.hibernate.metamodel.source.annotations.entity;
 
 import javax.persistence.AccessType;
 import java.lang.reflect.Field;
 import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.Type;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.EnumMap;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.TreeMap;
 
 import com.fasterxml.classmate.ResolvedTypeWithMembers;
 import com.fasterxml.classmate.members.HierarchicType;
 import com.fasterxml.classmate.members.ResolvedMember;
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.FieldInfo;
 import org.jboss.jandex.MethodInfo;
 import org.jboss.logging.Logger;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
-import org.hibernate.metamodel.binder.source.annotations.AnnotationsBindingContext;
-import org.hibernate.metamodel.binder.source.annotations.ConfiguredClassHierarchyBuilder;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
-import org.hibernate.metamodel.binder.source.annotations.ReflectionHelper;
+import org.hibernate.metamodel.source.annotations.AnnotationsBindingContext;
+import org.hibernate.metamodel.source.annotations.ConfiguredClassHierarchyBuilder;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.annotations.ReflectionHelper;
 import org.hibernate.metamodel.source.annotations.attribute.AssociationAttribute;
 import org.hibernate.metamodel.source.annotations.attribute.AttributeOverride;
 import org.hibernate.metamodel.source.annotations.attribute.AttributeType;
 import org.hibernate.metamodel.source.annotations.attribute.MappedAttribute;
 import org.hibernate.metamodel.source.annotations.attribute.SimpleAttribute;
-import org.hibernate.metamodel.source.annotations.entity.EmbeddableClass;
 
 /**
  * Base class for a configured entity, mapped super class or embeddable
  *
  * @author Hardy Ferentschik
  */
 public class ConfiguredClass {
 	public static final Logger LOG = Logger.getLogger( ConfiguredClass.class.getName() );
 
 	/**
 	 * The parent of this configured class or {@code null} in case this configured class is the root of a hierarchy.
 	 */
 	private final ConfiguredClass parent;
 
 	/**
 	 * The Jandex class info for this configured class. Provides access to the annotation defined on this configured class.
 	 */
 	private final ClassInfo classInfo;
 
 	/**
 	 * The actual java type.
 	 */
 	private final Class<?> clazz;
 
 	/**
 	 * The default access type for this entity
 	 */
 	private final AccessType classAccessType;
 
 	/**
 	 * The type of configured class, entity, mapped super class, embeddable, ...
 	 */
 	private final ConfiguredClassType configuredClassType;
 
 	/**
 	 * The id attributes
 	 */
 	private final Map<String, SimpleAttribute> idAttributeMap;
 
 	/**
 	 * The mapped association attributes for this entity
 	 */
 	private final Map<String, AssociationAttribute> associationAttributeMap;
 
 	/**
 	 * The mapped simple attributes for this entity
 	 */
 	private final Map<String, SimpleAttribute> simpleAttributeMap;
 
 	/**
 	 * The embedded classes for this entity
 	 */
 	private final Map<String, EmbeddableClass> embeddedClasses = new HashMap<String, EmbeddableClass>();
 
 	/**
 	 * A map of all attribute overrides defined in this class. The override name is "normalised", meaning as if specified
 	 * on class level. If the override is specified on attribute level the attribute name is used as prefix.
 	 */
 	private final Map<String, AttributeOverride> attributeOverrideMap;
 
 	private final Set<String> transientFieldNames = new HashSet<String>();
 	private final Set<String> transientMethodNames = new HashSet<String>();
 
 	private final AnnotationsBindingContext context;
 
 	public ConfiguredClass(
 			ClassInfo classInfo,
 			AccessType defaultAccessType,
 			ConfiguredClass parent,
 			AnnotationsBindingContext context) {
 		this.parent = parent;
 		this.context = context;
 		this.classInfo = classInfo;
 		this.clazz = context.locateClassByName( classInfo.toString() );
 		this.configuredClassType = determineType();
 		this.classAccessType = determineClassAccessType( defaultAccessType );
 		this.simpleAttributeMap = new TreeMap<String, SimpleAttribute>();
 		this.idAttributeMap = new TreeMap<String, SimpleAttribute>();
 		this.associationAttributeMap = new TreeMap<String, AssociationAttribute>();
 
 		collectAttributes();
 		attributeOverrideMap = Collections.unmodifiableMap( findAttributeOverrides() );
 	}
 
 	public String getName() {
 		return clazz.getName();
 	}
 
 	public Class<?> getConfiguredClass() {
 		return clazz;
 	}
 
 	public ClassInfo getClassInfo() {
 		return classInfo;
 	}
 
 	public ConfiguredClass getParent() {
 		return parent;
 	}
 
 	public ConfiguredClassType getConfiguredClassType() {
 		return configuredClassType;
 	}
 
 	public Iterable<SimpleAttribute> getSimpleAttributes() {
 		return simpleAttributeMap.values();
 	}
 
 	public Iterable<SimpleAttribute> getIdAttributes() {
 		return idAttributeMap.values();
 	}
 
 	public Iterable<AssociationAttribute> getAssociationAttributes() {
 		return associationAttributeMap.values();
 	}
 
 	public Map<String, EmbeddableClass> getEmbeddedClasses() {
 		return embeddedClasses;
 	}
 
 	public MappedAttribute getMappedAttribute(String propertyName) {
 		MappedAttribute attribute;
 		attribute = simpleAttributeMap.get( propertyName );
 		if ( attribute == null ) {
 			attribute = associationAttributeMap.get( propertyName );
 		}
 		if ( attribute == null ) {
 			attribute = idAttributeMap.get( propertyName );
 		}
 		return attribute;
 	}
 
 	public Map<String, AttributeOverride> getAttributeOverrideMap() {
 		return attributeOverrideMap;
 	}
 
 	@Override
 	public String toString() {
 		final StringBuilder sb = new StringBuilder();
 		sb.append( "ConfiguredClass" );
 		sb.append( "{clazz=" ).append( clazz.getSimpleName() );
 		sb.append( ", classAccessType=" ).append( classAccessType );
 		sb.append( ", configuredClassType=" ).append( configuredClassType );
 		sb.append( ", idAttributeMap=" ).append( idAttributeMap );
 		sb.append( ", simpleAttributeMap=" ).append( simpleAttributeMap );
 		sb.append( ", associationAttributeMap=" ).append( associationAttributeMap );
 		sb.append( '}' );
 		return sb.toString();
 	}
 
 	private ConfiguredClassType determineType() {
 		if ( classInfo.annotations().containsKey( JPADotNames.ENTITY ) ) {
 			return ConfiguredClassType.ENTITY;
 		}
 		else if ( classInfo.annotations().containsKey( JPADotNames.MAPPED_SUPERCLASS ) ) {
 			return ConfiguredClassType.MAPPED_SUPERCLASS;
 		}
 		else if ( classInfo.annotations().containsKey( JPADotNames.EMBEDDABLE ) ) {
 			return ConfiguredClassType.EMBEDDABLE;
 		}
 		else {
 			return ConfiguredClassType.NON_ENTITY;
 		}
 	}
 
 	private AccessType determineClassAccessType(AccessType defaultAccessType) {
 		// default to the hierarchy access type to start with
 		AccessType accessType = defaultAccessType;
 
 		AnnotationInstance accessAnnotation = JandexHelper.getSingleAnnotation( classInfo, JPADotNames.ACCESS );
 		if ( accessAnnotation != null ) {
 			accessType = JandexHelper.getValueAsEnum( accessAnnotation, "value", AccessType.class );
 		}
 
 		return accessType;
 	}
 
 	/**
 	 * Find all attributes for this configured class and add them to the corresponding map
 	 */
 	private void collectAttributes() {
 		// find transient field and method names
 		findTransientFieldAndMethodNames();
 
 		// use the class mate library to generic types
 		ResolvedTypeWithMembers resolvedType = context.resolveMemberTypes( context.getResolvedType( clazz ) );
 		for ( HierarchicType hierarchicType : resolvedType.allTypesAndOverrides() ) {
 			if ( hierarchicType.getType().getErasedType().equals( clazz ) ) {
 				resolvedType = context.resolveMemberTypes( hierarchicType.getType() );
 				break;
 			}
 		}
 
 		if ( resolvedType == null ) {
 			throw new AssertionFailure( "Unable to resolve types for " + clazz.getName() );
 		}
 
 		Set<String> explicitlyConfiguredMemberNames = createExplicitlyConfiguredAccessProperties( resolvedType );
 
 		if ( AccessType.FIELD.equals( classAccessType ) ) {
 			Field fields[] = clazz.getDeclaredFields();
 			Field.setAccessible( fields, true );
 			for ( Field field : fields ) {
 				if ( isPersistentMember( transientFieldNames, explicitlyConfiguredMemberNames, field ) ) {
 					createMappedProperty( field, resolvedType );
 				}
 			}
 		}
 		else {
 			Method[] methods = clazz.getDeclaredMethods();
 			Method.setAccessible( methods, true );
 			for ( Method method : methods ) {
 				if ( isPersistentMember( transientMethodNames, explicitlyConfiguredMemberNames, method ) ) {
 					createMappedProperty( method, resolvedType );
 				}
 			}
 		}
 	}
 
 	private boolean isPersistentMember(Set<String> transientNames, Set<String> explicitlyConfiguredMemberNames, Member member) {
 		if ( !ReflectionHelper.isProperty( member ) ) {
 			return false;
 		}
 
 		if ( transientNames.contains( member.getName() ) ) {
 			return false;
 		}
 
 		if ( explicitlyConfiguredMemberNames.contains( member.getName() ) ) {
 			return false;
 		}
 
 		return true;
 	}
 
 	/**
 	 * Creates {@code MappedProperty} instances for the explicitly configured persistent properties
 	 *
 	 * @param resolvedMembers the resolved type parameters for this class
 	 *
 	 * @return the property names of the explicitly configured attribute names in a set
 	 */
 	private Set<String> createExplicitlyConfiguredAccessProperties(ResolvedTypeWithMembers resolvedMembers) {
 		Set<String> explicitAccessMembers = new HashSet<String>();
 
 		List<AnnotationInstance> accessAnnotations = classInfo.annotations().get( JPADotNames.ACCESS );
 		if ( accessAnnotations == null ) {
 			return explicitAccessMembers;
 		}
 
 		// iterate over all @Access annotations defined on the current class
 		for ( AnnotationInstance accessAnnotation : accessAnnotations ) {
 			// we are only interested at annotations defined on fields and methods
 			AnnotationTarget annotationTarget = accessAnnotation.target();
 			if ( !( annotationTarget.getClass().equals( MethodInfo.class ) || annotationTarget.getClass()
 					.equals( FieldInfo.class ) ) ) {
 				continue;
 			}
 
 			AccessType accessType = JandexHelper.getValueAsEnum( accessAnnotation, "value", AccessType.class );
 
 			if ( !isExplicitAttributeAccessAnnotationPlacedCorrectly( annotationTarget, accessType ) ) {
 				continue;
 			}
 
 
 			// the placement is correct, get the member
 			Member member;
 			if ( annotationTarget instanceof MethodInfo ) {
 				Method m;
 				try {
 					m = clazz.getMethod( ( (MethodInfo) annotationTarget ).name() );
 				}
 				catch ( NoSuchMethodException e ) {
 					throw new HibernateException(
 							"Unable to load method "
 									+ ( (MethodInfo) annotationTarget ).name()
 									+ " of class " + clazz.getName()
 					);
 				}
 				member = m;
 			}
 			else {
 				Field f;
 				try {
 					f = clazz.getField( ( (FieldInfo) annotationTarget ).name() );
 				}
 				catch ( NoSuchFieldException e ) {
 					throw new HibernateException(
 							"Unable to load field "
 									+ ( (FieldInfo) annotationTarget ).name()
 									+ " of class " + clazz.getName()
 					);
 				}
 				member = f;
 			}
 			if ( ReflectionHelper.isProperty( member ) ) {
 				createMappedProperty( member, resolvedMembers );
 				explicitAccessMembers.add( member.getName() );
 			}
 		}
 		return explicitAccessMembers;
 	}
 
 	private boolean isExplicitAttributeAccessAnnotationPlacedCorrectly(AnnotationTarget annotationTarget, AccessType accessType) {
 		// when the access type of the class is FIELD
 		// overriding access annotations must be placed on properties AND have the access type PROPERTY
 		if ( AccessType.FIELD.equals( classAccessType ) ) {
 			if ( !( annotationTarget instanceof MethodInfo ) ) {
 				LOG.tracef(
 						"The access type of class %s is AccessType.FIELD. To override the access for an attribute " +
 								"@Access has to be placed on the property (getter)", classInfo.name().toString()
 				);
 				return false;
 			}
 
 			if ( !AccessType.PROPERTY.equals( accessType ) ) {
 				LOG.tracef(
 						"The access type of class %s is AccessType.FIELD. To override the access for an attribute " +
 								"@Access has to be placed on the property (getter) with an access type of AccessType.PROPERTY. " +
 								"Using AccessType.FIELD on the property has no effect",
 						classInfo.name().toString()
 				);
 				return false;
 			}
 		}
 
 		// when the access type of the class is PROPERTY
 		// overriding access annotations must be placed on fields and have the access type FIELD
 		if ( AccessType.PROPERTY.equals( classAccessType ) ) {
 			if ( !( annotationTarget instanceof FieldInfo ) ) {
 				LOG.tracef(
 						"The access type of class %s is AccessType.PROPERTY. To override the access for a field " +
 								"@Access has to be placed on the field ", classInfo.name().toString()
 				);
 				return false;
 			}
 
 			if ( !AccessType.FIELD.equals( accessType ) ) {
 				LOG.tracef(
 						"The access type of class %s is AccessType.PROPERTY. To override the access for a field " +
 								"@Access has to be placed on the field with an access type of AccessType.FIELD. " +
 								"Using AccessType.PROPERTY on the field has no effect",
 						classInfo.name().toString()
 				);
 				return false;
 			}
 		}
 		return true;
 	}
 
 	private void createMappedProperty(Member member, ResolvedTypeWithMembers resolvedType) {
 		final String attributeName = ReflectionHelper.getPropertyName( member );
 		ResolvedMember[] resolvedMembers;
 		if ( member instanceof Field ) {
 			resolvedMembers = resolvedType.getMemberFields();
 		}
 		else {
 			resolvedMembers = resolvedType.getMemberMethods();
 		}
 		final Class<?> type = (Class<?>) findResolvedType( member.getName(), resolvedMembers );
 		final Map<DotName, List<AnnotationInstance>> annotations = JandexHelper.getMemberAnnotations(
 				classInfo, member.getName()
 		);
 
 		AttributeType attributeType = determineAttributeType( annotations );
 		switch ( attributeType ) {
 			case BASIC: {
 				SimpleAttribute attribute = SimpleAttribute.createSimpleAttribute(
 						attributeName,
 						type.getName(),
 						annotations
 				);
 				if ( attribute.isId() ) {
 					idAttributeMap.put( attributeName, attribute );
 				}
 				else {
 					simpleAttributeMap.put( attributeName, attribute );
 				}
 				break;
 			}
 			case ELEMENT_COLLECTION:
 			case EMBEDDED_ID:
 
 			case EMBEDDED: {
 				resolveEmbeddable( attributeName, type );
 			}
 			// TODO handle the different association types
 			default: {
 				AssociationAttribute attribute = AssociationAttribute.createAssociationAttribute(
 						attributeName, type.getName(), attributeType, annotations
 				);
 				associationAttributeMap.put( attributeName, attribute );
 			}
 		}
 	}
 
 	private void resolveEmbeddable(String attributeName, Class<?> type) {
 		ClassInfo embeddableClassInfo = context.getClassInfo( type.getName() );
 		if ( classInfo == null ) {
 			String msg = String.format(
 					"Attribute %s of entity %s is annotated with @Embedded, but no embeddable configuration for type %s can be found.",
 					attributeName,
 					getName(),
 					type.getName()
 			);
 			throw new AnnotationException( msg );
 		}
 
 		context.resolveAllTypes( type.getName() );
 		ConfiguredClassHierarchy<EmbeddableClass> hierarchy = ConfiguredClassHierarchyBuilder.createEmbeddableHierarchy(
 				context.<Object>locateClassByName( embeddableClassInfo.toString() ),
 				classAccessType,
 				context
 		);
 		embeddedClasses.put( attributeName, hierarchy.getLeaf() );
 	}
 
 	/**
 	 * Given the annotations defined on a persistent attribute this methods determines the attribute type.
 	 *
 	 * @param annotations the annotations defined on the persistent attribute
 	 *
 	 * @return an instance of the {@code AttributeType} enum
 	 */
 	private AttributeType determineAttributeType(Map<DotName, List<AnnotationInstance>> annotations) {
 		EnumMap<AttributeType, AnnotationInstance> discoveredAttributeTypes =
 				new EnumMap<AttributeType, AnnotationInstance>( AttributeType.class );
 
 		AnnotationInstance oneToOne = JandexHelper.getSingleAnnotation( annotations, JPADotNames.ONE_TO_ONE );
 		if ( oneToOne != null ) {
 			discoveredAttributeTypes.put( AttributeType.ONE_TO_ONE, oneToOne );
 		}
 
 		AnnotationInstance oneToMany = JandexHelper.getSingleAnnotation( annotations, JPADotNames.ONE_TO_MANY );
 		if ( oneToMany != null ) {
 			discoveredAttributeTypes.put( AttributeType.ONE_TO_MANY, oneToMany );
 		}
 
 		AnnotationInstance manyToOne = JandexHelper.getSingleAnnotation( annotations, JPADotNames.MANY_TO_ONE );
 		if ( manyToOne != null ) {
 			discoveredAttributeTypes.put( AttributeType.MANY_TO_ONE, manyToOne );
 		}
 
 		AnnotationInstance manyToMany = JandexHelper.getSingleAnnotation( annotations, JPADotNames.MANY_TO_MANY );
 		if ( manyToMany != null ) {
 			discoveredAttributeTypes.put( AttributeType.MANY_TO_MANY, manyToMany );
 		}
 
 		AnnotationInstance embedded = JandexHelper.getSingleAnnotation( annotations, JPADotNames.EMBEDDED );
 		if ( embedded != null ) {
 			discoveredAttributeTypes.put( AttributeType.EMBEDDED, embedded );
 		}
 
 		AnnotationInstance embeddIded = JandexHelper.getSingleAnnotation( annotations, JPADotNames.EMBEDDED_ID );
 		if ( embeddIded != null ) {
 			discoveredAttributeTypes.put( AttributeType.EMBEDDED_ID, embeddIded );
 		}
 
 		AnnotationInstance elementCollection = JandexHelper.getSingleAnnotation(
 				annotations,
 				JPADotNames.ELEMENT_COLLECTION
 		);
 		if ( elementCollection != null ) {
 			discoveredAttributeTypes.put( AttributeType.ELEMENT_COLLECTION, elementCollection );
 		}
 
 		if ( discoveredAttributeTypes.size() == 0 ) {
 			return AttributeType.BASIC;
 		}
 		else if ( discoveredAttributeTypes.size() == 1 ) {
 			return discoveredAttributeTypes.keySet().iterator().next();
 		}
 		else {
 			throw new AnnotationException( "More than one association type configured for property  " + getName() + " of class " + getName() );
 		}
 	}
 
 	private Type findResolvedType(String name, ResolvedMember[] resolvedMembers) {
 		for ( ResolvedMember resolvedMember : resolvedMembers ) {
 			if ( resolvedMember.getName().equals( name ) ) {
 				return resolvedMember.getType().getErasedType();
 			}
 		}
 		throw new AssertionFailure(
 				String.format(
 						"Unable to resolve type of attribute %s of class %s",
 						name,
 						classInfo.name().toString()
 				)
 		);
 	}
 
 	/**
 	 * Populates the sets of transient field and method names.
 	 */
 	private void findTransientFieldAndMethodNames() {
 		List<AnnotationInstance> transientMembers = classInfo.annotations().get( JPADotNames.TRANSIENT );
 		if ( transientMembers == null ) {
 			return;
 		}
 
 		for ( AnnotationInstance transientMember : transientMembers ) {
 			AnnotationTarget target = transientMember.target();
 			if ( target instanceof FieldInfo ) {
 				transientFieldNames.add( ( (FieldInfo) target ).name() );
 			}
 			else {
 				transientMethodNames.add( ( (MethodInfo) target ).name() );
 			}
 		}
 	}
 
 	private Map<String, AttributeOverride> findAttributeOverrides() {
 		Map<String, AttributeOverride> attributeOverrideList = new HashMap<String, AttributeOverride>();
 
 		AnnotationInstance attributeOverrideAnnotation = JandexHelper.getSingleAnnotation(
 				classInfo,
 				JPADotNames.ATTRIBUTE_OVERRIDE
 		);
 		if ( attributeOverrideAnnotation != null ) {
 			String prefix = createPathPrefix( attributeOverrideAnnotation );
 			AttributeOverride override = new AttributeOverride( prefix, attributeOverrideAnnotation );
 			attributeOverrideList.put( override.getAttributePath(), override );
 		}
 
 		AnnotationInstance attributeOverridesAnnotation = JandexHelper.getSingleAnnotation(
 				classInfo,
 				JPADotNames.ATTRIBUTE_OVERRIDES
 		);
 		if ( attributeOverridesAnnotation != null ) {
 			AnnotationInstance[] annotationInstances = attributeOverridesAnnotation.value().asNestedArray();
 			for ( AnnotationInstance annotationInstance : annotationInstances ) {
 				String prefix = createPathPrefix( annotationInstance );
 				AttributeOverride override = new AttributeOverride( prefix, annotationInstance );
 				attributeOverrideList.put( override.getAttributePath(), override );
 			}
 		}
 		return attributeOverrideList;
 	}
 
 	private String createPathPrefix(AnnotationInstance attributeOverrideAnnotation) {
 		String prefix = null;
 		AnnotationTarget target = attributeOverrideAnnotation.target();
 		if ( target instanceof FieldInfo || target instanceof MethodInfo ) {
 			prefix = JandexHelper.getPropertyName( target );
 		}
 		return prefix;
 	}
 
 	private List<AnnotationInstance> findAssociationOverrides() {
 		List<AnnotationInstance> associationOverrideList = new ArrayList<AnnotationInstance>();
 
 		AnnotationInstance associationOverrideAnnotation = JandexHelper.getSingleAnnotation(
 				classInfo,
 				JPADotNames.ASSOCIATION_OVERRIDE
 		);
 		if ( associationOverrideAnnotation != null ) {
 			associationOverrideList.add( associationOverrideAnnotation );
 		}
 
 		AnnotationInstance associationOverridesAnnotation = JandexHelper.getSingleAnnotation(
 				classInfo,
 				JPADotNames.ASSOCIATION_OVERRIDES
 		);
 		if ( associationOverrideAnnotation != null ) {
 			AnnotationInstance[] attributeOverride = associationOverridesAnnotation.value().asNestedArray();
 			Collections.addAll( associationOverrideList, attributeOverride );
 		}
 
 		return associationOverrideList;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/ConfiguredClassHierarchy.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClassHierarchy.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/ConfiguredClassHierarchy.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClassHierarchy.java
index d5a90abbd3..ead8cf76c9 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/ConfiguredClassHierarchy.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClassHierarchy.java
@@ -1,280 +1,278 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.entity;
+package org.hibernate.metamodel.source.annotations.entity;
 
 import javax.persistence.AccessType;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.FieldInfo;
 import org.jboss.jandex.MethodInfo;
 
 import org.hibernate.AnnotationException;
-import org.hibernate.metamodel.binder.source.annotations.AnnotationsBindingContext;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.annotations.AnnotationsBindingContext;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
 import org.hibernate.metamodel.binding.InheritanceType;
-import org.hibernate.metamodel.source.annotations.entity.EmbeddableClass;
-import org.hibernate.metamodel.source.annotations.entity.EntityClass;
 
 /**
  * Contains information about the access and inheritance type for all classes within a class hierarchy.
  *
  * @author Hardy Ferentschik
  */
 public class ConfiguredClassHierarchy<T extends ConfiguredClass> implements Iterable<T> {
 	private final AccessType defaultAccessType;
 	private final InheritanceType inheritanceType;
 	private final List<T> configuredClasses;
 
 	public static ConfiguredClassHierarchy<EntityClass> createEntityClassHierarchy(List<ClassInfo> classInfoList, AnnotationsBindingContext context) {
 		AccessType defaultAccessType = determineDefaultAccessType( classInfoList );
 		InheritanceType inheritanceType = determineInheritanceType( classInfoList );
 		return new ConfiguredClassHierarchy<EntityClass>(
 				classInfoList,
 				context,
 				defaultAccessType,
 				inheritanceType,
 				EntityClass.class
 		);
 	}
 
 	public static ConfiguredClassHierarchy<EmbeddableClass> createEmbeddableClassHierarchy(
 			List<ClassInfo> classes,
 			AccessType accessType,
 			AnnotationsBindingContext context) {
 		return new ConfiguredClassHierarchy<EmbeddableClass>(
 				classes,
 				context,
 				accessType,
 				InheritanceType.NO_INHERITANCE,
 				EmbeddableClass.class
 		);
 	}
 
 	private ConfiguredClassHierarchy(
 			List<ClassInfo> classInfoList,
 			AnnotationsBindingContext context,
 			AccessType defaultAccessType,
 			InheritanceType inheritanceType,
 			Class<T> configuredClassType) {
 		this.defaultAccessType = defaultAccessType;
 		this.inheritanceType = inheritanceType;
 
 		// the resolved type for the top level class in the hierarchy
 		context.resolveAllTypes( classInfoList.get( classInfoList.size() - 1 ).name().toString() );
 
 		configuredClasses = new ArrayList<T>();
 		T parent = null;
 		for ( ClassInfo info : classInfoList ) {
 			T configuredClass;
 			if ( EntityClass.class.equals( configuredClassType ) ) {
 				configuredClass = (T) new EntityClass(
 						info, (EntityClass) parent, defaultAccessType, inheritanceType, context
 				);
 			}
 			else {
 				configuredClass = (T) new EmbeddableClass(
 						info, (EmbeddableClass) parent, defaultAccessType, context
 				);
 			}
 			configuredClasses.add( configuredClass );
 			parent = configuredClass;
 		}
 	}
 
 	public AccessType getDefaultAccessType() {
 		return defaultAccessType;
 	}
 
 	public InheritanceType getInheritanceType() {
 		return inheritanceType;
 	}
 
 	/**
 	 * @return An iterator iterating in top down manner over the configured classes in this hierarchy.
 	 */
 	public Iterator<T> iterator() {
 		return configuredClasses.iterator();
 	}
 
 	/**
 	 * @return Returns the top level configured class
 	 */
 	public T getRoot() {
 		return configuredClasses.get( 0 );
 	}
 
 	/**
 	 * @return Returns the leaf configured class
 	 */
 	public T getLeaf() {
 		return configuredClasses.get( configuredClasses.size() - 1 );
 	}
 
 	@Override
 	public String toString() {
 		final StringBuilder sb = new StringBuilder();
 		sb.append( "ConfiguredClassHierarchy" );
 		sb.append( "{defaultAccessType=" ).append( defaultAccessType );
 		sb.append( ", configuredClasses=" ).append( configuredClasses );
 		sb.append( '}' );
 		return sb.toString();
 	}
 
 	/**
 	 * @param classes the classes in the hierarchy
 	 *
 	 * @return Returns the default access type for the configured class hierarchy independent of explicit
 	 *         {@code AccessType} annotations. The default access type is determined by the placement of the
 	 *         annotations.
 	 */
 	private static AccessType determineDefaultAccessType(List<ClassInfo> classes) {
         AccessType accessTypeByEmbeddedIdPlacement = null;
         AccessType accessTypeByIdPlacement = null;
 		for ( ClassInfo info : classes ) {
 			List<AnnotationInstance> idAnnotations = info.annotations().get( JPADotNames.ID );
             List<AnnotationInstance> embeddedIdAnnotations = info.annotations().get( JPADotNames.EMBEDDED_ID );
 
             if ( embeddedIdAnnotations != null && !embeddedIdAnnotations.isEmpty() ) {
                 accessTypeByEmbeddedIdPlacement = determineAccessTypeByIdPlacement( embeddedIdAnnotations );
             }
 			if ( idAnnotations != null && !idAnnotations.isEmpty() ) {
 				accessTypeByIdPlacement = determineAccessTypeByIdPlacement( idAnnotations );
 			}
 		}
         if ( accessTypeByEmbeddedIdPlacement != null ) {
             return accessTypeByEmbeddedIdPlacement;
         } else if (accessTypeByIdPlacement != null ){
             return accessTypeByIdPlacement;
         } else {
             return throwIdNotFoundAnnotationException( classes );
         }
 
 
 //
 //
 //		if ( accessType == null ) {
 //			return throwIdNotFoundAnnotationException( classes );
 //		}
 //
 //		return accessType;
 	}
 
 	private static AccessType determineAccessTypeByIdPlacement(List<AnnotationInstance> idAnnotations) {
 		AccessType accessType = null;
 		for ( AnnotationInstance annotation : idAnnotations ) {
 			AccessType tmpAccessType;
 			if ( annotation.target() instanceof FieldInfo ) {
 				tmpAccessType = AccessType.FIELD;
 			}
 			else if ( annotation.target() instanceof MethodInfo ) {
 				tmpAccessType = AccessType.PROPERTY;
 			}
 			else {
 				throw new AnnotationException( "Invalid placement of @Id annotation" );
 			}
 
 			if ( accessType == null ) {
 				accessType = tmpAccessType;
 			}
 			else {
 				if ( !accessType.equals( tmpAccessType ) ) {
 					throw new AnnotationException( "Inconsistent placement of @Id annotation within hierarchy " );
 				}
 			}
 		}
 		return accessType;
 	}
 
 	private static InheritanceType determineInheritanceType(List<ClassInfo> classes) {
 		if ( classes.size() == 1 ) {
 			return InheritanceType.NO_INHERITANCE;
 		}
 
 		InheritanceType inheritanceType = null;
 		for ( ClassInfo info : classes ) {
 			AnnotationInstance inheritanceAnnotation = JandexHelper.getSingleAnnotation(
 					info, JPADotNames.INHERITANCE
 			);
 			if ( inheritanceAnnotation == null ) {
 				continue;
 			}
 
 			javax.persistence.InheritanceType jpaInheritanceType = Enum.valueOf(
 					javax.persistence.InheritanceType.class, inheritanceAnnotation.value( "strategy" ).asEnum()
 			);
 			InheritanceType tmpInheritanceType = InheritanceType.get( jpaInheritanceType );
 			if ( tmpInheritanceType == null ) {
 				// default inheritance type is single table
 				inheritanceType = InheritanceType.SINGLE_TABLE;
 			}
 
 			if ( inheritanceType == null ) {
 				inheritanceType = tmpInheritanceType;
 			}
 			else {
 				if ( !inheritanceType.equals( tmpInheritanceType ) ) {
 					throw new AnnotationException(
 							"Multiple incompatible instances of @Inheritance specified within classes "
 									+ hierarchyListString( classes )
 					);
 				}
 			}
 		}
 
 		if ( inheritanceType == null ) {
 			// default inheritance type is single table
 			inheritanceType = InheritanceType.SINGLE_TABLE;
 		}
 
 		return inheritanceType;
 	}
 
 	private static AccessType throwIdNotFoundAnnotationException(List<ClassInfo> classes) {
 		StringBuilder builder = new StringBuilder();
 		builder.append( "Unable to determine identifier attribute for class hierarchy consisting of the classe(s) " );
 		builder.append( hierarchyListString( classes ) );
 		throw new AnnotationException( builder.toString() );
 	}
 
 	private static String hierarchyListString(List<ClassInfo> classes) {
 		StringBuilder builder = new StringBuilder();
 		builder.append( "[" );
 
 		int count = 0;
 		for ( ClassInfo info : classes ) {
 			builder.append( info.name().toString() );
 			if ( count < classes.size() - 1 ) {
 				builder.append( ", " );
 			}
 			count++;
 		}
 		builder.append( "]" );
 		return builder.toString();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/ConfiguredClassType.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClassType.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/ConfiguredClassType.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClassType.java
index 683c30d1c9..cf7d0207ad 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/ConfiguredClassType.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/ConfiguredClassType.java
@@ -1,34 +1,34 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.entity;
+package org.hibernate.metamodel.source.annotations.entity;
 
 /**
  * @author Hardy Ferentschik
  */
 public enum ConfiguredClassType {
 	ENTITY,
 	MAPPED_SUPERCLASS,
 	EMBEDDABLE,
 	NON_ENTITY
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EmbeddableClass.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EmbeddableClass.java
index 3bdcbc0761..a3cc40b188 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EmbeddableClass.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EmbeddableClass.java
@@ -1,47 +1,46 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.entity;
 
 import javax.persistence.AccessType;
 
 import org.jboss.jandex.ClassInfo;
 
-import org.hibernate.metamodel.binder.source.annotations.AnnotationsBindingContext;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClass;
+import org.hibernate.metamodel.source.annotations.AnnotationsBindingContext;
 
 /**
  * @author Hardy Ferentschik
  */
 public class EmbeddableClass extends ConfiguredClass {
 	// todo - need to take care of the attribute path (HF)
 	public EmbeddableClass(
 			ClassInfo classInfo,
 			EmbeddableClass parent,
 			AccessType defaultAccessType,
 			AnnotationsBindingContext context) {
 		super( classInfo, defaultAccessType, parent, context );
 	}
 }
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/EntityBinder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityBinder.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/EntityBinder.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityBinder.java
index 93d1762859..72ee4efe6a 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/EntityBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityBinder.java
@@ -1,912 +1,909 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.entity;
+package org.hibernate.metamodel.source.annotations.entity;
 
 import javax.persistence.GenerationType;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.DotName;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.AssertionFailure;
 import org.hibernate.EntityMode;
 import org.hibernate.MappingException;
 import org.hibernate.annotations.CacheConcurrencyStrategy;
 import org.hibernate.annotations.OptimisticLockType;
 import org.hibernate.annotations.PolymorphismType;
 import org.hibernate.cache.spi.access.AccessType;
 import org.hibernate.engine.OptimisticLockStyle;
 import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.Value;
-import org.hibernate.metamodel.binder.source.annotations.AnnotationsBindingContext;
-import org.hibernate.metamodel.binder.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
-import org.hibernate.metamodel.binder.source.annotations.UnknownInheritanceTypeException;
-import org.hibernate.metamodel.binder.source.annotations.global.IdGeneratorBinder;
+import org.hibernate.metamodel.source.annotations.AnnotationsBindingContext;
+import org.hibernate.metamodel.source.annotations.HibernateDotNames;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.annotations.UnknownInheritanceTypeException;
+import org.hibernate.metamodel.source.annotations.global.IdGeneratorBinder;
 import org.hibernate.metamodel.binding.Caching;
 import org.hibernate.metamodel.binding.CustomSQL;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.binding.EntityDiscriminator;
 import org.hibernate.metamodel.binding.IdGenerator;
 import org.hibernate.metamodel.binding.InheritanceType;
 import org.hibernate.metamodel.binding.ManyToOneAttributeBinding;
 import org.hibernate.metamodel.binding.SimpleAttributeBinding;
 import org.hibernate.metamodel.binding.state.DiscriminatorBindingState;
 import org.hibernate.metamodel.binding.state.ManyToOneAttributeBindingState;
 import org.hibernate.metamodel.binding.state.SimpleAttributeBindingState;
 import org.hibernate.metamodel.domain.Attribute;
 import org.hibernate.metamodel.domain.AttributeContainer;
 import org.hibernate.metamodel.domain.Entity;
 import org.hibernate.metamodel.domain.Hierarchical;
 import org.hibernate.metamodel.domain.SingularAttribute;
 import org.hibernate.metamodel.relational.Identifier;
 import org.hibernate.metamodel.relational.Schema;
 import org.hibernate.metamodel.relational.TableSpecification;
 import org.hibernate.metamodel.relational.UniqueKey;
 import org.hibernate.metamodel.source.annotations.attribute.AssociationAttribute;
 import org.hibernate.metamodel.source.annotations.attribute.AttributeOverride;
 import org.hibernate.metamodel.source.annotations.attribute.DiscriminatorColumnValues;
 import org.hibernate.metamodel.source.annotations.attribute.MappedAttribute;
 import org.hibernate.metamodel.source.annotations.attribute.SimpleAttribute;
 import org.hibernate.metamodel.source.annotations.attribute.state.binding.AttributeBindingStateImpl;
 import org.hibernate.metamodel.source.annotations.attribute.state.binding.DiscriminatorBindingStateImpl;
 import org.hibernate.metamodel.source.annotations.attribute.state.binding.ManyToOneBindingStateImpl;
 import org.hibernate.metamodel.source.annotations.attribute.state.relational.ColumnRelationalStateImpl;
 import org.hibernate.metamodel.source.annotations.attribute.state.relational.ManyToOneRelationalStateImpl;
 import org.hibernate.metamodel.source.annotations.attribute.state.relational.TupleRelationalStateImpl;
-import org.hibernate.metamodel.source.annotations.entity.EmbeddableClass;
-import org.hibernate.metamodel.source.annotations.entity.EntityClass;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.tuple.entity.EntityTuplizer;
 
 /**
  * Creates the domain and relational metamodel for a configured class and <i>binds</i> them together.
  *
  * @author Hardy Ferentschik
  */
 public class EntityBinder {
 	private final EntityClass entityClass;
 	private final Hierarchical superType;
 	private final AnnotationsBindingContext bindingContext;
 
 	private final Schema.Name schemaName;
 
 	public EntityBinder(EntityClass entityClass, Hierarchical superType, AnnotationsBindingContext bindingContext) {
 		this.entityClass = entityClass;
 		this.superType = superType;
 		this.bindingContext = bindingContext;
 		this.schemaName = determineSchemaName();
 	}
 
 	private Schema.Name determineSchemaName() {
 		String schema = bindingContext.getMappingDefaults().getSchemaName();
 		String catalog = bindingContext.getMappingDefaults().getCatalogName();
 
 		final AnnotationInstance tableAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), JPADotNames.TABLE
 		);
 		if ( tableAnnotation != null ) {
 			final AnnotationValue schemaValue = tableAnnotation.value( "schema" );
 			if ( schemaValue != null ) {
 				schema = schemaValue.asString();
 			}
 
 			final AnnotationValue catalogValue = tableAnnotation.value( "catalog" );
 			if ( catalogValue != null ) {
 				catalog = catalogValue.asString();
 			}
 		}
 
 		return new Schema.Name( schema, catalog );
 	}
 
 	public EntityBinding bind(List<String> processedEntityNames) {
 		if ( processedEntityNames.contains( entityClass.getName() ) ) {
 			return bindingContext.getMetadataImplementor().getEntityBinding( entityClass.getName() );
 		}
 
 		final EntityBinding entityBinding = doEntityBindingCreation();
 
 		bindingContext.getMetadataImplementor().addEntity( entityBinding );
 		processedEntityNames.add( entityBinding.getEntity().getName() );
 
 		return entityBinding;
 	}
 
 	private EntityBinding doEntityBindingCreation() {
 		final EntityBinding entityBinding = buildBasicEntityBinding();
 
 		// bind all attributes - simple as well as associations
 		bindAttributes( entityBinding );
 		bindEmbeddedAttributes( entityBinding );
 
 		bindTableUniqueConstraints( entityBinding );
 
-		bindingContext.getMetadataImplementor().addEntity( entityBinding );
 		return entityBinding;
 	}
 
 	private EntityBinding buildBasicEntityBinding() {
 		switch ( entityClass.getInheritanceType() ) {
 			case NO_INHERITANCE: {
 				return doRootEntityBindingCreation();
 			}
 			case SINGLE_TABLE: {
 				return doDiscriminatedSubclassBindingCreation();
 			}
 			case JOINED: {
 				return doJoinedSubclassBindingCreation();
 			}
 			case TABLE_PER_CLASS: {
 				return doUnionSubclassBindingCreation();
 			}
 			default: {
 				throw new UnknownInheritanceTypeException( "Unknown InheritanceType : " + entityClass.getInheritanceType() );
 			}
 		}
 	}
 
 	private EntityBinding doRootEntityBindingCreation() {
 		EntityBinding entityBinding = new EntityBinding();
 		entityBinding.setInheritanceType( InheritanceType.NO_INHERITANCE );
 		entityBinding.setRoot( true );
 
 		doBasicEntityBinding( entityBinding );
 
 		// technically the rest of these binds should only apply to root entities, but they are really available on all
 		// because we do not currently subtype EntityBinding
 
 		final AnnotationInstance hibernateEntityAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.ENTITY
 		);
 
 		// see HHH-6400
 		PolymorphismType polymorphism = PolymorphismType.IMPLICIT;
 		if ( hibernateEntityAnnotation != null && hibernateEntityAnnotation.value( "polymorphism" ) != null ) {
 			polymorphism = PolymorphismType.valueOf( hibernateEntityAnnotation.value( "polymorphism" ).asEnum() );
 		}
 		entityBinding.setExplicitPolymorphism( polymorphism == PolymorphismType.EXPLICIT );
 
 		// see HHH-6401
 		OptimisticLockType optimisticLockType = OptimisticLockType.VERSION;
 		if ( hibernateEntityAnnotation != null && hibernateEntityAnnotation.value( "optimisticLock" ) != null ) {
 			optimisticLockType = OptimisticLockType.valueOf( hibernateEntityAnnotation.value( "optimisticLock" ).asEnum() );
 		}
 		entityBinding.setOptimisticLockStyle( OptimisticLockStyle.valueOf( optimisticLockType.name() ) );
 
 		final AnnotationInstance hibernateImmutableAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.IMMUTABLE
 		);
 		final boolean mutable = hibernateImmutableAnnotation == null
 				&& hibernateEntityAnnotation != null
 				&& hibernateEntityAnnotation.value( "mutable" ) != null
 				&& hibernateEntityAnnotation.value( "mutable" ).asBoolean();
 		entityBinding.setMutable( mutable );
 
 		final AnnotationInstance whereAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.WHERE
 		);
 		entityBinding.setWhereFilter(
 				whereAnnotation != null && whereAnnotation.value( "clause" ) != null
 						? whereAnnotation.value( "clause" ).asString()
 						: null
 		);
 
 		final AnnotationInstance rowIdAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.ROW_ID
 		);
 		entityBinding.setRowId(
 				rowIdAnnotation != null && rowIdAnnotation.value() != null
 						? rowIdAnnotation.value().asString()
 						: null
 		);
 
 		entityBinding.setCaching( interpretCaching( entityClass, bindingContext ) );
 
 		bindPrimaryTable( entityBinding );
 		bindId( entityBinding );
 
 		if ( entityBinding.getInheritanceType() == InheritanceType.SINGLE_TABLE ) {
 			bindDiscriminatorColumn( entityBinding );
 		}
 
 		// todo : version
 
 		return entityBinding;
 	}
 
 	private Caching interpretCaching(ConfiguredClass configuredClass, AnnotationsBindingContext bindingContext) {
 		final AnnotationInstance hibernateCacheAnnotation = JandexHelper.getSingleAnnotation(
 				configuredClass.getClassInfo(), HibernateDotNames.CACHE
 		);
 		if ( hibernateCacheAnnotation != null ) {
 			final AccessType accessType = hibernateCacheAnnotation.value( "usage" ) == null
 					? bindingContext.getMappingDefaults().getCacheAccessType()
 					: CacheConcurrencyStrategy.parse( hibernateCacheAnnotation.value( "usage" ).asEnum() ).toAccessType();
 			return new Caching(
 					hibernateCacheAnnotation.value( "region" ) == null
 							? configuredClass.getName()
 							: hibernateCacheAnnotation.value( "region" ).asString(),
 					accessType,
 					hibernateCacheAnnotation.value( "include" ) != null
 							&& "all".equals( hibernateCacheAnnotation.value( "include" ).asString() )
 			);
 		}
 
 		final AnnotationInstance jpaCacheableAnnotation = JandexHelper.getSingleAnnotation(
 				configuredClass.getClassInfo(), JPADotNames.CACHEABLE
 		);
 
 		boolean cacheable = true; // true is the default
 		if ( jpaCacheableAnnotation != null && jpaCacheableAnnotation.value() != null ) {
 			cacheable = jpaCacheableAnnotation.value().asBoolean();
 		}
 
 		final boolean doCaching;
 		switch ( bindingContext.getMetadataImplementor().getOptions().getSharedCacheMode() ) {
 			case ALL: {
 				doCaching = true;
 				break;
 			}
 			case ENABLE_SELECTIVE: {
 				doCaching = cacheable;
 				break;
 			}
 			case DISABLE_SELECTIVE: {
 				doCaching = jpaCacheableAnnotation == null || cacheable;
 				break;
 			}
 			default: {
 				// treat both NONE and UNSPECIFIED the same
 				doCaching = false;
 				break;
 			}
 		}
 
 		if ( ! doCaching ) {
 			return null;
 		}
 
 		return new Caching(
 				configuredClass.getName(),
 				bindingContext.getMappingDefaults().getCacheAccessType(),
 				true
 		);
 	}
 
 	private EntityBinding doDiscriminatedSubclassBindingCreation() {
 		EntityBinding entityBinding = new EntityBinding();
 		entityBinding.setInheritanceType( InheritanceType.SINGLE_TABLE );
 
 		doBasicEntityBinding( entityBinding );
 
 		// todo : bind discriminator-based subclassing specifics...
 
 		return entityBinding;
 	}
 
 	private EntityBinding doJoinedSubclassBindingCreation() {
 		EntityBinding entityBinding = new EntityBinding();
 		entityBinding.setInheritanceType( InheritanceType.JOINED );
 
 		doBasicEntityBinding( entityBinding );
 
 		// todo : bind join-based subclassing specifics...
 
 		return entityBinding;
 	}
 
 	private EntityBinding doUnionSubclassBindingCreation() {
 		EntityBinding entityBinding = new EntityBinding();
 		entityBinding.setInheritanceType( InheritanceType.TABLE_PER_CLASS );
 
 		doBasicEntityBinding( entityBinding );
 
 		// todo : bind union-based subclassing specifics...
 
 		return entityBinding;
 	}
 
 	private void doBasicEntityBinding(EntityBinding entityBinding) {
 		entityBinding.setEntityMode( EntityMode.POJO );
 
 		final Entity entity = new Entity(
 				entityClass.getName(),
 				entityClass.getName(),
 				bindingContext.makeClassReference( entityClass.getName() ),
 				superType
 		);
 		entityBinding.setEntity( entity );
 
 		final AnnotationInstance jpaEntityAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), JPADotNames.ENTITY
 		);
 
 		final AnnotationValue explicitJpaEntityName = jpaEntityAnnotation.value( "name" );
 		if ( explicitJpaEntityName == null ) {
 			entityBinding.setJpaEntityName( entityClass.getName() );
 		}
 		else {
 			entityBinding.setJpaEntityName( explicitJpaEntityName.asString() );
 		}
 
 		final AnnotationInstance hibernateEntityAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.ENTITY
 		);
 
 		// see HHH-6397
 		entityBinding.setDynamicInsert(
 				hibernateEntityAnnotation != null
 						&& hibernateEntityAnnotation.value( "dynamicInsert" ) != null
 						&& hibernateEntityAnnotation.value( "dynamicInsert" ).asBoolean()
 		);
 
 		// see HHH-6398
 		entityBinding.setDynamicUpdate(
 				hibernateEntityAnnotation != null
 						&& hibernateEntityAnnotation.value( "dynamicUpdate" ) != null
 						&& hibernateEntityAnnotation.value( "dynamicUpdate" ).asBoolean()
 		);
 
 		// see HHH-6399
 		entityBinding.setSelectBeforeUpdate(
 				hibernateEntityAnnotation != null
 						&& hibernateEntityAnnotation.value( "selectBeforeUpdate" ) != null
 						&& hibernateEntityAnnotation.value( "selectBeforeUpdate" ).asBoolean()
 		);
 
 		// Custom sql loader
 		final AnnotationInstance sqlLoaderAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.LOADER
 		);
 		if ( sqlLoaderAnnotation != null ) {
 			entityBinding.setCustomLoaderName( sqlLoaderAnnotation.value( "namedQuery" ).asString() );
 		}
 
 		// Custom sql insert
 		final AnnotationInstance sqlInsertAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.SQL_INSERT
 		);
 		entityBinding.setCustomInsert( createCustomSQL( sqlInsertAnnotation ) );
 
 		// Custom sql update
 		final AnnotationInstance sqlUpdateAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.SQL_UPDATE
 		);
 		entityBinding.setCustomInsert( createCustomSQL( sqlUpdateAnnotation ) );
 
 		// Custom sql delete
 		final AnnotationInstance sqlDeleteAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.SQL_DELETE
 		);
 		entityBinding.setCustomInsert( createCustomSQL( sqlDeleteAnnotation ) );
 
 		// Batch size
 		final AnnotationInstance batchSizeAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.BATCH_SIZE
 		);
 		entityBinding.setBatchSize( batchSizeAnnotation == null ? -1 : batchSizeAnnotation.value( "size" ).asInt());
 
 		// Proxy generation
 		final boolean lazy;
 		final Value<Class<?>> proxyInterfaceType;
 		final AnnotationInstance hibernateProxyAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.PROXY
 		);
 		if ( hibernateProxyAnnotation != null ) {
 			lazy = hibernateProxyAnnotation.value( "lazy" ) == null
 					|| hibernateProxyAnnotation.value( "lazy" ).asBoolean();
 			final AnnotationValue proxyClassValue = hibernateProxyAnnotation.value( "proxyClass" );
 			if ( proxyClassValue == null ) {
 				proxyInterfaceType = entity.getClassReferenceUnresolved();
 			}
 			else {
 				proxyInterfaceType = bindingContext.makeClassReference( proxyClassValue.asString() );
 			}
 		}
 		else {
 			lazy = true;
 			proxyInterfaceType = entity.getClassReferenceUnresolved();
 		}
 		entityBinding.setLazy( lazy );
 		entityBinding.setProxyInterfaceType( proxyInterfaceType );
 
 		// Custom persister
 		final Class<? extends EntityPersister> entityPersisterClass;
 		final AnnotationInstance persisterAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.PERSISTER
 		);
 		if ( persisterAnnotation == null || persisterAnnotation.value( "impl" ) == null ) {
 			if ( hibernateEntityAnnotation != null && hibernateEntityAnnotation.value( "persister" ) != null ) {
 				entityPersisterClass = bindingContext.locateClassByName( hibernateEntityAnnotation.value( "persister" ).asString() );
 			}
 			else {
 				entityPersisterClass = null;
 			}
 		}
 		else {
 			if ( hibernateEntityAnnotation != null && hibernateEntityAnnotation.value( "persister" ) != null ) {
 				// todo : error?
 			}
 			entityPersisterClass = bindingContext.locateClassByName( persisterAnnotation.value( "impl" ).asString() );
 		}
 		entityBinding.setCustomEntityPersisterClass( entityPersisterClass );
 
 		// Custom tuplizer
 		final AnnotationInstance pojoTuplizerAnnotation = locatePojoTuplizerAnnotation();
 		if ( pojoTuplizerAnnotation != null ) {
 			final Class<? extends EntityTuplizer> tuplizerClass =
 					bindingContext.locateClassByName( pojoTuplizerAnnotation.value( "impl" ).asString() );
 			entityBinding.setCustomEntityTuplizerClass( tuplizerClass );
 		}
 
 		// table synchronizations
 		final AnnotationInstance synchronizeAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.SYNCHRONIZE
 		);
 		if ( synchronizeAnnotation != null ) {
 			final String[] tableNames = synchronizeAnnotation.value().asStringArray();
 			entityBinding.addSynchronizedTableNames( Arrays.asList( tableNames ) );
 		}
 	}
 
 	private CustomSQL createCustomSQL(AnnotationInstance customSqlAnnotation) {
 		if ( customSqlAnnotation == null ) {
 			return null;
 		}
 
 		final String sql = customSqlAnnotation.value( "sql" ).asString();
 		final boolean isCallable = customSqlAnnotation.value( "callable" ) != null
 				&& customSqlAnnotation.value( "callable" ).asBoolean();
 
 		final ExecuteUpdateResultCheckStyle checkStyle = customSqlAnnotation.value( "check" ) == null
 				? isCallable
 						? ExecuteUpdateResultCheckStyle.NONE
 						: ExecuteUpdateResultCheckStyle.COUNT
 				: ExecuteUpdateResultCheckStyle.valueOf( customSqlAnnotation.value( "check" ).asEnum() );
 
 		return new CustomSQL( sql, isCallable, checkStyle );
 	}
 
 	private AnnotationInstance locatePojoTuplizerAnnotation() {
 		final AnnotationInstance tuplizersAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.SYNCHRONIZE
 		);
 		if ( tuplizersAnnotation == null ) {
 			return null;
 		}
 
 		for ( AnnotationInstance tuplizerAnnotation : JandexHelper.getValue( tuplizersAnnotation, "value", AnnotationInstance[].class ) ) {
 			if ( EntityMode.valueOf( tuplizerAnnotation.value( "entityModeType" ).asEnum() ) == EntityMode.POJO ) {
 				return tuplizerAnnotation;
 			}
 		}
 
 		return null;
 	}
 
 	private void bindDiscriminatorColumn(EntityBinding entityBinding) {
 		final Map<DotName, List<AnnotationInstance>> typeAnnotations = JandexHelper.getTypeAnnotations(
 				entityClass.getClassInfo()
 		);
 		SimpleAttribute discriminatorAttribute = SimpleAttribute.createDiscriminatorAttribute( typeAnnotations );
 		bindSingleMappedAttribute( entityBinding, entityBinding.getEntity(), discriminatorAttribute );
 
 		if ( !( discriminatorAttribute.getColumnValues() instanceof DiscriminatorColumnValues) ) {
 			throw new AssertionFailure( "Expected discriminator column values" );
 		}
 	}
 
 	private void bindPrimaryTable(EntityBinding entityBinding) {
 		final Schema schema = bindingContext.getMetadataImplementor().getDatabase().getSchema( schemaName );
 
 		AnnotationInstance tableAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(),
 				JPADotNames.TABLE
 		);
 
 		String tableName = null;
 		if ( tableAnnotation != null ) {
 			String explicitTableName = JandexHelper.getValue( tableAnnotation, "name", String.class );
 			if ( StringHelper.isNotEmpty( explicitTableName ) ) {
 				tableName = bindingContext.getNamingStrategy().tableName( explicitTableName );
 			}
 		}
 
 		// no explicit table name given, let's use the entity name as table name (taking inheritance into consideration
 		if ( StringHelper.isEmpty( tableName ) ) {
 			tableName = bindingContext.getNamingStrategy().classToTableName( entityClass.getClassNameForTable() );
 		}
 
 		org.hibernate.metamodel.relational.Table table = schema.locateOrCreateTable( Identifier.toIdentifier( tableName ) );
 		entityBinding.setBaseTable( table );
 
 		AnnotationInstance checkAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), HibernateDotNames.CHECK
 		);
 		if ( checkAnnotation != null ) {
 			table.addCheckConstraint( checkAnnotation.value( "constraints" ).asString() );
 		}
 	}
 
 	private void bindTableUniqueConstraints(EntityBinding entityBinding) {
 		AnnotationInstance tableAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(),
 				JPADotNames.TABLE
 		);
 		if ( tableAnnotation == null ) {
 			return;
 		}
 		TableSpecification table = entityBinding.getBaseTable();
 		bindUniqueConstraints( tableAnnotation, table );
 	}
 
 	private void bindUniqueConstraints(AnnotationInstance tableAnnotation, TableSpecification table) {
 		AnnotationValue value = tableAnnotation.value( "uniqueConstraints" );
 		if ( value == null ) {
 			return;
 		}
 		AnnotationInstance[] uniqueConstraints = value.asNestedArray();
 		for ( AnnotationInstance unique : uniqueConstraints ) {
 			String name = unique.value( "name" ).asString();
 			UniqueKey uniqueKey = table.getOrCreateUniqueKey( name );
 			String[] columnNames = unique.value( "columnNames" ).asStringArray();
 			if ( columnNames.length == 0 ) {
 				//todo throw exception?
 			}
 			for ( String columnName : columnNames ) {
 				uniqueKey.addColumn( table.locateOrCreateColumn( columnName ) );
 			}
 		}
 	}
 
 	private void bindId(EntityBinding entityBinding) {
 		switch ( entityClass.getIdType() ) {
 			case SIMPLE: {
 				bindSingleIdAnnotation( entityBinding );
 				break;
 			}
 			case COMPOSED: {
 				// todo
 				break;
 			}
 			case EMBEDDED: {
 				bindEmbeddedIdAnnotation( entityBinding );
 				break;
 			}
 			default: {
 			}
 		}
 	}
 
 	private void bindEmbeddedIdAnnotation(EntityBinding entityBinding) {
 		AnnotationInstance idAnnotation = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), JPADotNames.EMBEDDED_ID
 		);
 
 		String idName = JandexHelper.getPropertyName( idAnnotation.target() );
 		MappedAttribute idAttribute = entityClass.getMappedAttribute( idName );
 		if ( !( idAttribute instanceof SimpleAttribute ) ) {
 			throw new AssertionFailure( "Unexpected attribute type for id attribute" );
 		}
 
 		SingularAttribute attribute = entityBinding.getEntity().locateOrCreateComponentAttribute( idName );
 
 		SimpleAttributeBinding attributeBinding = entityBinding.makeSimpleIdAttributeBinding( attribute );
 
 		attributeBinding.initialize( new AttributeBindingStateImpl( (SimpleAttribute) idAttribute ) );
 		attributeBinding.initialize( new ColumnRelationalStateImpl( (SimpleAttribute) idAttribute, bindingContext.getMetadataImplementor() ) );
 		bindSingleIdGeneratedValue( entityBinding, idName );
 
 		TupleRelationalStateImpl state = new TupleRelationalStateImpl();
 		EmbeddableClass embeddableClass = entityClass.getEmbeddedClasses().get( idName );
 		for ( SimpleAttribute attr : embeddableClass.getSimpleAttributes() ) {
 			state.addValueState( new ColumnRelationalStateImpl( attr, bindingContext.getMetadataImplementor() ) );
 		}
 		attributeBinding.initialize( state );
 		Map<String, String> parms = new HashMap<String, String>( 1 );
 		parms.put( IdentifierGenerator.ENTITY_NAME, entityBinding.getEntity().getName() );
 		IdGenerator generator = new IdGenerator( "NAME", "assigned", parms );
 		entityBinding.getEntityIdentifier().setIdGenerator( generator );
 		// entityBinding.getEntityIdentifier().createIdentifierGenerator( meta.getIdentifierGeneratorFactory() );
 	}
 
 	private void bindSingleIdAnnotation(EntityBinding entityBinding) {
 		// we know we are dealing w/ a single @Id, but potentially it is defined in a mapped super class
 		ConfiguredClass configuredClass = entityClass;
 		EntityClass superEntity = entityClass.getEntityParent();
 		Hierarchical container = entityBinding.getEntity();
 		Iterator<SimpleAttribute> iter = null;
 		while ( configuredClass != null && configuredClass != superEntity ) {
 			iter = configuredClass.getIdAttributes().iterator();
 			if ( iter.hasNext() ) {
 				break;
 			}
 			configuredClass = configuredClass.getParent();
 			container = container.getSuperType();
 		}
 
 		// if we could not find the attribute our assumptions were wrong
 		if ( iter == null || !iter.hasNext() ) {
 			throw new AnnotationException(
 					String.format(
 							"Unable to find id attribute for class %s",
 							entityClass.getName()
 					)
 			);
 		}
 
 		// now that we have the id attribute we can create the attribute and binding
 		MappedAttribute idAttribute = iter.next();
 		Attribute attribute = container.locateOrCreateSingularAttribute( idAttribute.getName() );
 
 		SimpleAttributeBinding attributeBinding = entityBinding.makeSimpleIdAttributeBinding( attribute );
 		attributeBinding.initialize( new AttributeBindingStateImpl( (SimpleAttribute) idAttribute ) );
 		attributeBinding.initialize( new ColumnRelationalStateImpl( (SimpleAttribute) idAttribute, bindingContext.getMetadataImplementor() ) );
 		bindSingleIdGeneratedValue( entityBinding, idAttribute.getName() );
 	}
 
 	private void bindSingleIdGeneratedValue(EntityBinding entityBinding, String idPropertyName) {
 		AnnotationInstance generatedValueAnn = JandexHelper.getSingleAnnotation(
 				entityClass.getClassInfo(), JPADotNames.GENERATED_VALUE
 		);
 		if ( generatedValueAnn == null ) {
 			return;
 		}
 
 		String idName = JandexHelper.getPropertyName( generatedValueAnn.target() );
 		if ( !idPropertyName.equals( idName ) ) {
 			throw new AssertionFailure(
 					String.format(
 							"Attribute[%s.%s] with @GeneratedValue doesn't have a @Id.",
 							entityClass.getName(),
 							idPropertyName
 					)
 			);
 		}
 		String generator = JandexHelper.getValue( generatedValueAnn, "generator", String.class );
 		IdGenerator idGenerator = null;
 		if ( StringHelper.isNotEmpty( generator ) ) {
 			idGenerator = bindingContext.getMetadataImplementor().getIdGenerator( generator );
 			if ( idGenerator == null ) {
 				throw new MappingException(
 						String.format(
 								"@GeneratedValue on %s.%s referring an undefined generator [%s]",
 								entityClass.getName(),
 								idName,
 								generator
 						)
 				);
 			}
 			entityBinding.getEntityIdentifier().setIdGenerator( idGenerator );
 		}
 		GenerationType generationType = JandexHelper.getValueAsEnum(
 				generatedValueAnn,
 				"strategy",
 				GenerationType.class
 		);
 		String strategy = IdGeneratorBinder.generatorType(
 				generationType,
 				bindingContext.getMetadataImplementor().getOptions().useNewIdentifierGenerators()
 		);
 		if ( idGenerator != null && !strategy.equals( idGenerator.getStrategy() ) ) {
 			//todo how to ?
 			throw new MappingException(
 					String.format(
 							"Inconsistent Id Generation strategy of @GeneratedValue on %s.%s",
 							entityClass.getName(),
 							idName
 					)
 			);
 		}
 		if ( idGenerator == null ) {
 			idGenerator = new IdGenerator( "NAME", strategy, new HashMap<String, String>() );
 			entityBinding.getEntityIdentifier().setIdGenerator( idGenerator );
 		}
 //        entityBinding.getEntityIdentifier().createIdentifierGenerator( meta.getIdentifierGeneratorFactory() );
 	}
 
 	private void bindAttributes(EntityBinding entityBinding) {
 		// collect attribute overrides as we map the attributes
 		Map<String, AttributeOverride> attributeOverrideMap = new HashMap<String, AttributeOverride>();
 
 		// bind the attributes of this entity
 		AttributeContainer entity = entityBinding.getEntity();
 		bindAttributes( entityBinding, entity, entityClass, attributeOverrideMap );
 
 		// bind potential mapped super class attributes
 		attributeOverrideMap.putAll( entityClass.getAttributeOverrideMap() );
 		ConfiguredClass parent = entityClass.getParent();
 		Hierarchical superTypeContainer = entityBinding.getEntity().getSuperType();
 		while ( containsMappedSuperclassAttributes( parent ) ) {
 			bindAttributes( entityBinding, superTypeContainer, parent, attributeOverrideMap );
 			addNewOverridesToMap( parent, attributeOverrideMap );
 			parent = parent.getParent();
 			superTypeContainer = superTypeContainer.getSuperType();
 		}
 	}
 
 	private void addNewOverridesToMap(ConfiguredClass parent, Map<String, AttributeOverride> attributeOverrideMap) {
 		Map<String, AttributeOverride> overrides = parent.getAttributeOverrideMap();
 		for ( Map.Entry<String, AttributeOverride> entry : overrides.entrySet() ) {
 			if ( !attributeOverrideMap.containsKey( entry.getKey() ) ) {
 				attributeOverrideMap.put( entry.getKey(), entry.getValue() );
 			}
 		}
 	}
 
 	private boolean containsMappedSuperclassAttributes(ConfiguredClass parent) {
 		return parent != null && ( ConfiguredClassType.MAPPED_SUPERCLASS.equals( parent.getConfiguredClassType() ) ||
 				ConfiguredClassType.NON_ENTITY.equals( parent.getConfiguredClassType() ) );
 	}
 
 	private void bindAttributes(
 				EntityBinding entityBinding,
 				AttributeContainer attributeContainer,
 				ConfiguredClass configuredClass,
 				Map<String,AttributeOverride> attributeOverrideMap) {
 		for ( SimpleAttribute simpleAttribute : configuredClass.getSimpleAttributes() ) {
 			String attributeName = simpleAttribute.getName();
 
 			// if there is a override apply it
 			AttributeOverride override = attributeOverrideMap.get( attributeName );
 			if ( override != null ) {
 				simpleAttribute = SimpleAttribute.createSimpleAttribute( simpleAttribute, override.getColumnValues() );
 			}
 
 			bindSingleMappedAttribute(
 					entityBinding,
 					attributeContainer,
 					simpleAttribute
 			);
 		}
 		for ( AssociationAttribute associationAttribute : configuredClass.getAssociationAttributes() ) {
 			bindAssociationAttribute(
 					entityBinding,
 					attributeContainer,
 					associationAttribute
 			);
 		}
 	}
 
 	private void bindEmbeddedAttributes(EntityBinding entityBinding) {
 		AttributeContainer entity = entityBinding.getEntity();
 		bindEmbeddedAttributes( entityBinding, entity, entityClass );
 
 		// bind potential mapped super class embeddables
 		ConfiguredClass parent = entityClass.getParent();
 		Hierarchical superTypeContainer = entityBinding.getEntity().getSuperType();
 		while ( containsMappedSuperclassAttributes( parent ) ) {
 			bindEmbeddedAttributes( entityBinding, superTypeContainer, parent );
 			parent = parent.getParent();
 			superTypeContainer = superTypeContainer.getSuperType();
 		}
 	}
 
 	private void bindEmbeddedAttributes(
 				EntityBinding entityBinding,
 				AttributeContainer attributeContainer,
 				ConfiguredClass configuredClass) {
 		for ( Map.Entry<String, EmbeddableClass> entry : configuredClass.getEmbeddedClasses().entrySet() ) {
 			String attributeName = entry.getKey();
 			EmbeddableClass embeddedClass = entry.getValue();
 			SingularAttribute component = attributeContainer.locateOrCreateComponentAttribute( attributeName );
 			for ( SimpleAttribute simpleAttribute : embeddedClass.getSimpleAttributes() ) {
 				bindSingleMappedAttribute(
 						entityBinding,
 						component.getAttributeContainer(),
 						simpleAttribute
 				);
 			}
 			for ( AssociationAttribute associationAttribute : embeddedClass.getAssociationAttributes() ) {
 				bindAssociationAttribute(
 						entityBinding,
 						component.getAttributeContainer(),
 						associationAttribute
 				);
 			}
 		}
 	}
 
 	private void bindAssociationAttribute(
 				EntityBinding entityBinding,
 				AttributeContainer container,
 				AssociationAttribute associationAttribute) {
 		switch ( associationAttribute.getAssociationType() ) {
 			case MANY_TO_ONE: {
 				entityBinding.getEntity().locateOrCreateSingularAttribute( associationAttribute.getName() );
 				ManyToOneAttributeBinding manyToOneAttributeBinding = entityBinding.makeManyToOneAttributeBinding(
 						associationAttribute.getName()
 				);
 
 				ManyToOneAttributeBindingState bindingState = new ManyToOneBindingStateImpl( associationAttribute );
 				manyToOneAttributeBinding.initialize( bindingState );
 
 				ManyToOneRelationalStateImpl relationalState = new ManyToOneRelationalStateImpl();
 				if ( entityClass.hasOwnTable() ) {
 					ColumnRelationalStateImpl columnRelationsState = new ColumnRelationalStateImpl(
 							associationAttribute, bindingContext.getMetadataImplementor()
 					);
 					relationalState.addValueState( columnRelationsState );
 				}
 				manyToOneAttributeBinding.initialize( relationalState );
 				break;
 			}
 			default: {
 				// todo
 			}
 		}
 	}
 
 	private void bindSingleMappedAttribute(
 				EntityBinding entityBinding,
 				AttributeContainer container,
 				SimpleAttribute simpleAttribute) {
 		if ( simpleAttribute.isId() ) {
 			return;
 		}
 
 		String attributeName = simpleAttribute.getName();
-		SingularAttribute attribute = entityBinding.getEntity().locateOrCreateSingularAttribute( attributeName );
+		SingularAttribute attribute = container.locateOrCreateSingularAttribute( attributeName );
 		SimpleAttributeBinding attributeBinding;
 
 		if ( simpleAttribute.isDiscriminator() ) {
 			EntityDiscriminator entityDiscriminator = entityBinding.makeEntityDiscriminator( attribute );
 			DiscriminatorBindingState bindingState = new DiscriminatorBindingStateImpl( simpleAttribute );
 			entityDiscriminator.initialize( bindingState );
 			attributeBinding = entityDiscriminator.getValueBinding();
 		}
 		else if ( simpleAttribute.isVersioned() ) {
 			attributeBinding = entityBinding.makeVersionBinding( attribute );
 			SimpleAttributeBindingState bindingState = new AttributeBindingStateImpl( simpleAttribute );
 			attributeBinding.initialize( bindingState );
 		}
 		else {
 			attributeBinding = entityBinding.makeSimpleAttributeBinding( attribute );
 			SimpleAttributeBindingState bindingState = new AttributeBindingStateImpl( simpleAttribute );
 			attributeBinding.initialize( bindingState );
 		}
 
 		if ( entityClass.hasOwnTable() ) {
 			ColumnRelationalStateImpl columnRelationsState = new ColumnRelationalStateImpl(
 					simpleAttribute, bindingContext.getMetadataImplementor()
 			);
 			TupleRelationalStateImpl relationalState = new TupleRelationalStateImpl();
 			relationalState.addValueState( columnRelationsState );
 
 			attributeBinding.initialize( relationalState );
 		}
 	}
 
 }
 
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityClass.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityClass.java
index 3ba07e2c99..782673e3e3 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityClass.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/EntityClass.java
@@ -1,197 +1,194 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.entity;
 
 import java.util.ArrayList;
 import java.util.List;
 import javax.persistence.AccessType;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.MappingException;
-import org.hibernate.metamodel.binder.source.annotations.AnnotationsBindingContext;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClass;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClassType;
-import org.hibernate.metamodel.binder.source.annotations.entity.IdType;
+import org.hibernate.metamodel.source.annotations.AnnotationsBindingContext;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
 import org.hibernate.metamodel.binding.InheritanceType;
 
 /**
  * Represents an entity or mapped superclass configured via annotations/xml.
  *
  * @author Hardy Ferentschik
  */
 public class EntityClass extends ConfiguredClass {
 	private final AccessType hierarchyAccessType;
 	private final InheritanceType inheritanceType;
 	private final boolean hasOwnTable;
 	private final String entityBasedTableName;
 	private final IdType idType;
 	private final EntityClass jpaEntityParent;
 
 	public EntityClass(
 			ClassInfo classInfo,
 			EntityClass parent,
 			AccessType hierarchyAccessType,
 			InheritanceType inheritanceType,
 			AnnotationsBindingContext context) {
 		super( classInfo, hierarchyAccessType, parent, context );
 		this.hierarchyAccessType = hierarchyAccessType;
 		this.inheritanceType = inheritanceType;
 		this.idType = determineIdType();
 		this.jpaEntityParent = findJpaEntitySuperClass();
 		this.hasOwnTable = definesItsOwnTable();
 		this.entityBasedTableName = determineEntityBasedTableName();
 	}
 
 	/**
 	 * @return Returns the next JPA super entity for this entity class or {@code null} in case there is none.
 	 */
 	public EntityClass getEntityParent() {
 		return jpaEntityParent;
 	}
 
 	/**
 	 * @return Returns {@code true} is this entity class is the root of the class hierarchy in the JPA sense, which
 	 *         means there are no more super classes which are annotated with @Entity. There can, however, be mapped superclasses
 	 *         or non entities in the actual java type hierarchy.
 	 */
 	public boolean isEntityRoot() {
 		return jpaEntityParent == null;
 	}
 
 	public InheritanceType getInheritanceType() {
 		return inheritanceType;
 	}
 
 	public IdType getIdType() {
 		return idType;
 	}
 
 	public boolean hasOwnTable() {
 		return hasOwnTable;
 	}
 
 	public String getClassNameForTable() {
 		return entityBasedTableName;
 	}
 
 	@Override
 	public String toString() {
 		final StringBuilder sb = new StringBuilder();
 		sb.append( "EntityClass" );
 		sb.append( "{name=" ).append( getConfiguredClass().getSimpleName() );
 		sb.append( ", hierarchyAccessType=" ).append( hierarchyAccessType );
 		sb.append( ", inheritanceType=" ).append( inheritanceType );
 		sb.append( ", hasOwnTable=" ).append( hasOwnTable );
 		sb.append( ", primaryTableName='" ).append( entityBasedTableName ).append( '\'' );
 		sb.append( ", idType=" ).append( idType );
 		sb.append( '}' );
 		return sb.toString();
 	}
 
 	private boolean definesItsOwnTable() {
 		// mapped super classes don't have their own tables
 		if ( ConfiguredClassType.MAPPED_SUPERCLASS.equals( getConfiguredClassType() ) ) {
 			return false;
 		}
 
 		if ( InheritanceType.SINGLE_TABLE.equals( inheritanceType ) ) {
 			return isEntityRoot();
 		}
 		return true;
 	}
 
 	private EntityClass findJpaEntitySuperClass() {
 		ConfiguredClass tmpConfiguredClass = this.getParent();
 		while ( tmpConfiguredClass != null ) {
 			if ( ConfiguredClassType.ENTITY.equals( tmpConfiguredClass.getConfiguredClassType() ) ) {
 				return (EntityClass) tmpConfiguredClass;
 			}
 			tmpConfiguredClass = tmpConfiguredClass.getParent();
 		}
 		return null;
 	}
 
 	private String determineEntityBasedTableName() {
 		String tableName = null;
 		if ( hasOwnTable() ) {
 			tableName = getConfiguredClass().getSimpleName();
 		}
 		else if ( jpaEntityParent != null ) {
 			tableName = jpaEntityParent.getClassNameForTable();
 		}
 		return tableName;
 	}
 
 	private IdType determineIdType() {
 		List<AnnotationInstance> idAnnotations = findIdAnnotations( JPADotNames.ID );
 		List<AnnotationInstance> embeddedIdAnnotations = findIdAnnotations( JPADotNames.EMBEDDED_ID );
 
 		if ( !idAnnotations.isEmpty() && !embeddedIdAnnotations.isEmpty() ) {
 			throw new MappingException(
 					"@EmbeddedId and @Id cannot be used together. Check the configuration for " + getName() + "."
 			);
 		}
 
 		if ( !embeddedIdAnnotations.isEmpty() ) {
 			if ( embeddedIdAnnotations.size() == 1 ) {
 				return IdType.EMBEDDED;
 			}
 			else {
 				throw new AnnotationException( "Multiple @EmbeddedId annotations are not allowed" );
 			}
 		}
 
 		if ( !idAnnotations.isEmpty() ) {
 			if ( idAnnotations.size() == 1 ) {
 				return IdType.SIMPLE;
 			}
 			else {
 				return IdType.COMPOSED;
 			}
 		}
 		return IdType.NONE;
 	}
 
 	private List<AnnotationInstance> findIdAnnotations(DotName idAnnotationType) {
 		List<AnnotationInstance> idAnnotationList = new ArrayList<AnnotationInstance>();
 		if ( getClassInfo().annotations().get( idAnnotationType ) != null ) {
 			idAnnotationList.addAll( getClassInfo().annotations().get( idAnnotationType ) );
 		}
 		ConfiguredClass parent = getParent();
 		while ( parent != null && ( ConfiguredClassType.MAPPED_SUPERCLASS.equals( parent.getConfiguredClassType() ) ||
 				ConfiguredClassType.NON_ENTITY.equals( parent.getConfiguredClassType() ) ) ) {
 			if ( parent.getClassInfo().annotations().get( idAnnotationType ) != null ) {
 				idAnnotationList.addAll( parent.getClassInfo().annotations().get( idAnnotationType ) );
 			}
 			parent = parent.getParent();
 
 		}
 		return idAnnotationList;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/IdType.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/IdType.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/IdType.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/IdType.java
index 3b6c56e416..164e756af7 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/entity/IdType.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/entity/IdType.java
@@ -1,40 +1,40 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.entity;
+package org.hibernate.metamodel.source.annotations.entity;
 
 /**
  * An emum for the type of id configuration for an entity.
  *
  * @author Hardy Ferentschik
  */
 public enum IdType {
 	// single @Id annotation
 	SIMPLE,
 	// multiple @Id annotations
 	COMPOSED,
 	// @EmbeddedId annotation
 	EMBEDDED,
 	// does not contain any identifier mappings
 	NONE
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/FetchProfileBinder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinder.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/FetchProfileBinder.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinder.java
index ce989afa2a..1c0e5d5617 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/FetchProfileBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinder.java
@@ -1,93 +1,93 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.global;
+package org.hibernate.metamodel.source.annotations.global;
 
 import java.util.HashSet;
 import java.util.Set;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.Index;
 
 import org.hibernate.MappingException;
 import org.hibernate.annotations.FetchMode;
 import org.hibernate.annotations.FetchProfiles;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.MetadataImplementor;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
 import org.hibernate.metamodel.binding.FetchProfile;
 import org.hibernate.metamodel.binding.FetchProfile.Fetch;
-import org.hibernate.metamodel.binder.source.annotations.HibernateDotNames;
+import org.hibernate.metamodel.source.annotations.HibernateDotNames;
 
 /**
  * Binds fetch profiles found in annotations.
  *
  * @author Hardy Ferentschik
  */
 public class FetchProfileBinder {
 
 	/**
 	 * Binds all {@link FetchProfiles} and {@link org.hibernate.annotations.FetchProfile} annotations to the supplied metadata.
 	 *
 	 * @param metadata the global metadata
 	 * @param jandex the jandex index
 	 */
 	// TODO verify that association exists. See former VerifyFetchProfileReferenceSecondPass
 	public static void bind(MetadataImplementor metadata, Index jandex) {
 		for ( AnnotationInstance fetchProfile : jandex.getAnnotations( HibernateDotNames.FETCH_PROFILE ) ) {
 			bind( metadata, fetchProfile );
 		}
 		for ( AnnotationInstance fetchProfiles : jandex.getAnnotations( HibernateDotNames.FETCH_PROFILES ) ) {
 			AnnotationInstance[] fetchProfileAnnotations = JandexHelper.getValue(
 					fetchProfiles,
 					"value",
 					AnnotationInstance[].class
 			);
 			for ( AnnotationInstance fetchProfile : fetchProfileAnnotations ) {
 				bind( metadata, fetchProfile );
 			}
 		}
 	}
 
 	private static void bind(MetadataImplementor metadata, AnnotationInstance fetchProfile) {
 		String name = JandexHelper.getValue( fetchProfile, "name", String.class );
 		Set<Fetch> fetches = new HashSet<Fetch>();
 		AnnotationInstance[] overrideAnnotations = JandexHelper.getValue(
 				fetchProfile,
 				"fetchOverrides",
 				AnnotationInstance[].class
 		);
 		for ( AnnotationInstance override : overrideAnnotations ) {
 			FetchMode fetchMode = JandexHelper.getValueAsEnum( override, "mode", FetchMode.class );
 			if ( !fetchMode.equals( org.hibernate.annotations.FetchMode.JOIN ) ) {
 				throw new MappingException( "Only FetchMode.JOIN is currently supported" );
 			}
 			final String entityName = JandexHelper.getValue( override, "entity", String.class );
 			final String associationName = JandexHelper.getValue( override, "association", String.class );
 			fetches.add( new Fetch( entityName, associationName, fetchMode.toString().toLowerCase() ) );
 		}
 		metadata.addFetchProfile( new FetchProfile( name, fetches ) );
 	}
 
 	private FetchProfileBinder() {
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/FilterDefBinder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/FilterDefBinder.java
similarity index 91%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/FilterDefBinder.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/FilterDefBinder.java
index bc46f7fcdc..2e83b3af10 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/FilterDefBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/FilterDefBinder.java
@@ -1,92 +1,92 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.global;
+package org.hibernate.metamodel.source.annotations.global;
 
 import java.util.HashMap;
 import java.util.Map;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.Index;
 import org.jboss.logging.Logger;
 
 import org.hibernate.annotations.FilterDef;
 import org.hibernate.annotations.FilterDefs;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.MetadataImplementor;
+import org.hibernate.metamodel.source.annotations.HibernateDotNames;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
 import org.hibernate.type.Type;
 
 public class FilterDefBinder {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			FilterDefBinder.class.getName()
 	);
 
 	/**
 	 * Binds all {@link FilterDefs} and {@link FilterDef} annotations to the supplied metadata.
 	 *
 	 * @param metadata the global metadata
 	 * @param jandex the jandex index
 	 */
 	public static void bind(MetadataImplementor metadata, Index jandex) {
 		for ( AnnotationInstance filterDef : jandex.getAnnotations( HibernateDotNames.FILTER_DEF ) ) {
 			bind( metadata, filterDef );
 		}
 		for ( AnnotationInstance filterDefs : jandex.getAnnotations( HibernateDotNames.FILTER_DEFS ) ) {
 			AnnotationInstance[] filterDefAnnotations = JandexHelper.getValue(
 					filterDefs,
 					"value",
 					AnnotationInstance[].class
 			);
 			for ( AnnotationInstance filterDef : filterDefAnnotations ) {
 				bind( metadata, filterDef );
 			}
 		}
 	}
 
 	private static void bind(MetadataImplementor metadata, AnnotationInstance filterDef) {
 		String name = JandexHelper.getValue( filterDef, "name", String.class );
 		Map<String, Type> prms = new HashMap<String, Type>();
 		for ( AnnotationInstance prm : JandexHelper.getValue( filterDef, "parameters", AnnotationInstance[].class ) ) {
 			prms.put(
 					JandexHelper.getValue( prm, "name", String.class ),
 					metadata.getTypeResolver().heuristicType( JandexHelper.getValue( prm, "type", String.class ) )
 			);
 		}
 		metadata.addFilterDefinition(
 				new FilterDefinition(
 						name,
 						JandexHelper.getValue( filterDef, "defaultCondition", String.class ),
 						prms
 				)
 		);
 		LOG.debugf( "Binding filter definition: %s", name );
 	}
 
 	private FilterDefBinder() {
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/IdGeneratorBinder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/IdGeneratorBinder.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/IdGeneratorBinder.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/IdGeneratorBinder.java
index 1daafb9f44..15c32a3b6b 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/IdGeneratorBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/IdGeneratorBinder.java
@@ -1,216 +1,216 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.global;
+package org.hibernate.metamodel.source.annotations.global;
 
 import java.util.HashMap;
 import java.util.Map;
 import javax.persistence.GenerationType;
 import javax.persistence.SequenceGenerator;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.Index;
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.annotations.GenericGenerator;
 import org.hibernate.annotations.GenericGenerators;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.id.MultipleHiLoPerTableGenerator;
 import org.hibernate.id.PersistentIdentifierGenerator;
 import org.hibernate.id.SequenceHiLoGenerator;
 import org.hibernate.id.TableHiLoGenerator;
 import org.hibernate.id.enhanced.SequenceStyleGenerator;
 import org.hibernate.id.enhanced.TableGenerator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.MetadataImplementor;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
 import org.hibernate.metamodel.binding.IdGenerator;
-import org.hibernate.metamodel.binder.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.HibernateDotNames;
 
 public class IdGeneratorBinder {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			IdGeneratorBinder.class.getName()
 	);
 
 	private IdGeneratorBinder() {
 	}
 
 	private static void addStringParameter(AnnotationInstance annotation,
 										   String element,
 										   Map<String, String> parameters,
 										   String parameter) {
 		String string = JandexHelper.getValue( annotation, element, String.class );
 		if ( StringHelper.isNotEmpty( string ) ) {
 			parameters.put( parameter, string );
 		}
 	}
 
 	/**
 	 * Binds all {@link SequenceGenerator}, {@link javax.persistence.TableGenerator}, {@link GenericGenerator}, and {
 	 * {@link GenericGenerators} annotations to the supplied metadata.
 	 *
 	 * @param metadata the global metadata
 	 * @param jandex the jandex index
 	 */
 	public static void bind(MetadataImplementor metadata, Index jandex) {
 		for ( AnnotationInstance generator : jandex.getAnnotations( JPADotNames.SEQUENCE_GENERATOR ) ) {
 			bindSequenceGenerator( metadata, generator );
 		}
 		for ( AnnotationInstance generator : jandex.getAnnotations( JPADotNames.TABLE_GENERATOR ) ) {
 			bindTableGenerator( metadata, generator );
 		}
 		for ( AnnotationInstance generator : jandex.getAnnotations( HibernateDotNames.GENERIC_GENERATOR ) ) {
 			bindGenericGenerator( metadata, generator );
 		}
 		for ( AnnotationInstance generators : jandex.getAnnotations( HibernateDotNames.GENERIC_GENERATORS ) ) {
 			for ( AnnotationInstance generator : JandexHelper.getValue(
 					generators,
 					"value",
 					AnnotationInstance[].class
 			) ) {
 				bindGenericGenerator( metadata, generator );
 			}
 		}
 	}
 
 	private static void bindGenericGenerator(MetadataImplementor metadata, AnnotationInstance generator) {
 		String name = JandexHelper.getValue( generator, "name", String.class );
 		Map<String, String> parameterMap = new HashMap<String, String>();
 		AnnotationInstance[] parameterAnnotations = JandexHelper.getValue(
 				generator,
 				"parameters",
 				AnnotationInstance[].class
 		);
 		for ( AnnotationInstance parameterAnnotation : parameterAnnotations ) {
 			parameterMap.put(
 					JandexHelper.getValue( parameterAnnotation, "name", String.class ),
 					JandexHelper.getValue( parameterAnnotation, "value", String.class )
 			);
 		}
 		metadata.addIdGenerator(
 				new IdGenerator(
 						name,
 						JandexHelper.getValue( generator, "strategy", String.class ),
 						parameterMap
 				)
 		);
 		LOG.tracef( "Add generic generator with name: %s", name );
 	}
 
 	private static void bindSequenceGenerator(MetadataImplementor metadata, AnnotationInstance generator) {
 		String name = JandexHelper.getValue( generator, "name", String.class );
 		String strategy;
 		Map<String, String> prms = new HashMap<String, String>();
 		addStringParameter( generator, "sequenceName", prms, SequenceStyleGenerator.SEQUENCE_PARAM );
 		boolean useNewIdentifierGenerators = metadata.getOptions().useNewIdentifierGenerators();
 		strategy = generatorType( GenerationType.SEQUENCE, useNewIdentifierGenerators );
 		if ( useNewIdentifierGenerators ) {
 			addStringParameter( generator, "catalog", prms, PersistentIdentifierGenerator.CATALOG );
 			addStringParameter( generator, "schema", prms, PersistentIdentifierGenerator.SCHEMA );
 			prms.put(
 					SequenceStyleGenerator.INCREMENT_PARAM,
 					String.valueOf( JandexHelper.getValue( generator, "allocationSize", Integer.class ) )
 			);
 			prms.put(
 					SequenceStyleGenerator.INITIAL_PARAM,
 					String.valueOf( JandexHelper.getValue( generator, "initialValue", Integer.class ) )
 			);
 		}
 		else {
 			if ( JandexHelper.getValue( generator, "initialValue", Integer.class ) != 1 ) {
 				LOG.unsupportedInitialValue( AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS );
 			}
 			prms.put(
 					SequenceHiLoGenerator.MAX_LO,
 					String.valueOf( JandexHelper.getValue( generator, "allocationSize", Integer.class ) - 1 )
 			);
 		}
 		metadata.addIdGenerator( new IdGenerator( name, strategy, prms ) );
 		LOG.tracef( "Add sequence generator with name: %s", name );
 	}
 
 	private static void bindTableGenerator(MetadataImplementor metadata, AnnotationInstance generator) {
 		String name = JandexHelper.getValue( generator, "name", String.class );
 		String strategy;
 		Map<String, String> prms = new HashMap<String, String>();
 		addStringParameter( generator, "catalog", prms, PersistentIdentifierGenerator.CATALOG );
 		addStringParameter( generator, "schema", prms, PersistentIdentifierGenerator.SCHEMA );
 		boolean useNewIdentifierGenerators = metadata.getOptions().useNewIdentifierGenerators();
 		strategy = generatorType( GenerationType.TABLE, useNewIdentifierGenerators );
 		if ( useNewIdentifierGenerators ) {
 			prms.put( TableGenerator.CONFIG_PREFER_SEGMENT_PER_ENTITY, "true" );
 			addStringParameter( generator, "table", prms, TableGenerator.TABLE_PARAM );
 			addStringParameter( generator, "pkColumnName", prms, TableGenerator.SEGMENT_COLUMN_PARAM );
 			addStringParameter( generator, "pkColumnValue", prms, TableGenerator.SEGMENT_VALUE_PARAM );
 			addStringParameter( generator, "valueColumnName", prms, TableGenerator.VALUE_COLUMN_PARAM );
 			prms.put(
 					TableGenerator.INCREMENT_PARAM,
 					String.valueOf( JandexHelper.getValue( generator, "allocationSize", String.class ) )
 			);
 			prms.put(
 					TableGenerator.INITIAL_PARAM,
 					String.valueOf( JandexHelper.getValue( generator, "initialValue", String.class ) + 1 )
 			);
 		}
 		else {
 			addStringParameter( generator, "table", prms, MultipleHiLoPerTableGenerator.ID_TABLE );
 			addStringParameter( generator, "pkColumnName", prms, MultipleHiLoPerTableGenerator.PK_COLUMN_NAME );
 			addStringParameter( generator, "pkColumnValue", prms, MultipleHiLoPerTableGenerator.PK_VALUE_NAME );
 			addStringParameter( generator, "valueColumnName", prms, MultipleHiLoPerTableGenerator.VALUE_COLUMN_NAME );
 			prms.put(
 					TableHiLoGenerator.MAX_LO,
 					String.valueOf( JandexHelper.getValue( generator, "allocationSize", Integer.class ) - 1 )
 			);
 		}
 		if ( JandexHelper.getValue( generator, "uniqueConstraints", AnnotationInstance[].class ).length > 0 ) {
 			LOG.ignoringTableGeneratorConstraints( name );
 		}
 		metadata.addIdGenerator( new IdGenerator( name, strategy, prms ) );
 		LOG.tracef( "Add table generator with name: %s", name );
 	}
 
 	public static String generatorType(GenerationType generatorEnum, boolean useNewGeneratorMappings) {
 		switch ( generatorEnum ) {
 			case IDENTITY:
 				return "identity";
 			case AUTO:
 				return useNewGeneratorMappings
 						? "enhanced-sequence"
 						: "native";
 			case TABLE:
 				return useNewGeneratorMappings
 						? "enhanced-table"
 						: MultipleHiLoPerTableGenerator.class.getName();
 			case SEQUENCE:
 				return useNewGeneratorMappings
 						? "enhanced-sequence"
 						: "seqhilo";
 		}
 		throw new AssertionFailure( "Unknown GeneratorType: " + generatorEnum );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/QueryBinder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/QueryBinder.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/QueryBinder.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/QueryBinder.java
index 16ac19c068..bd0fef9bcd 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/QueryBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/QueryBinder.java
@@ -1,326 +1,326 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.global;
+package org.hibernate.metamodel.source.annotations.global;
 
 import java.util.HashMap;
 import javax.persistence.NamedNativeQueries;
 import javax.persistence.NamedNativeQuery;
 import javax.persistence.NamedQueries;
 import javax.persistence.NamedQuery;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.Index;
 import org.jboss.logging.Logger;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.CacheMode;
 import org.hibernate.FlushMode;
 import org.hibernate.LockMode;
 import org.hibernate.annotations.QueryHints;
 import org.hibernate.cfg.NotYetImplementedException;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryRootReturn;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.MetadataImplementor;
+import org.hibernate.metamodel.source.annotations.HibernateDotNames;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
 
 public class QueryBinder {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			QueryBinder.class.getName()
 	);
 
 	private QueryBinder() {
 	}
 
 	/**
 	 * Binds all {@link NamedQuery}, {@link NamedQueries}, {@link NamedNativeQuery}, {@link NamedNativeQueries},
 	 * {@link org.hibernate.annotations.NamedQuery}, {@link org.hibernate.annotations.NamedQueries},
 	 * {@link org.hibernate.annotations.NamedNativeQuery}, and {@link org.hibernate.annotations.NamedNativeQueries}
 	 * annotations to the supplied metadata.
 	 *
 	 * @param metadata the global metadata
 	 * @param jandex the jandex index
 	 */
 	public static void bind(MetadataImplementor metadata, Index jandex) {
 		for ( AnnotationInstance query : jandex.getAnnotations( JPADotNames.NAMED_QUERY ) ) {
 			bindNamedQuery( metadata, query );
 		}
 		for ( AnnotationInstance queries : jandex.getAnnotations( JPADotNames.NAMED_QUERIES ) ) {
 			for ( AnnotationInstance query : JandexHelper.getValue( queries, "value", AnnotationInstance[].class ) ) {
 				bindNamedQuery( metadata, query );
 			}
 		}
 		for ( AnnotationInstance query : jandex.getAnnotations( JPADotNames.NAMED_NATIVE_QUERY ) ) {
 			bindNamedNativeQuery( metadata, query );
 		}
 		for ( AnnotationInstance queries : jandex.getAnnotations( JPADotNames.NAMED_NATIVE_QUERIES ) ) {
 			for ( AnnotationInstance query : JandexHelper.getValue( queries, "value", AnnotationInstance[].class ) ) {
 				bindNamedNativeQuery( metadata, query );
 			}
 		}
 		for ( AnnotationInstance query : jandex.getAnnotations( HibernateDotNames.NAMED_QUERY ) ) {
 			bindNamedQuery( metadata, query );
 		}
 		for ( AnnotationInstance queries : jandex.getAnnotations( HibernateDotNames.NAMED_QUERIES ) ) {
 			for ( AnnotationInstance query : JandexHelper.getValue( queries, "value", AnnotationInstance[].class ) ) {
 				bindNamedQuery( metadata, query );
 			}
 		}
 		for ( AnnotationInstance query : jandex.getAnnotations( HibernateDotNames.NAMED_NATIVE_QUERY ) ) {
 			bindNamedNativeQuery( metadata, query );
 		}
 		for ( AnnotationInstance queries : jandex.getAnnotations( HibernateDotNames.NAMED_NATIVE_QUERIES ) ) {
 			for ( AnnotationInstance query : JandexHelper.getValue( queries, "value", AnnotationInstance[].class ) ) {
 				bindNamedNativeQuery( metadata, query );
 			}
 		}
 	}
 
 	/**
 	 * Binds {@link javax.persistence.NamedQuery} as well as {@link org.hibernate.annotations.NamedQuery}.
 	 *
 	 * @param metadata the current metadata
 	 * @param annotation the named query annotation
 	 */
 	private static void bindNamedQuery(MetadataImplementor metadata, AnnotationInstance annotation) {
 		String name = JandexHelper.getValue( annotation, "name", String.class );
 		if ( StringHelper.isEmpty( name ) ) {
 			throw new AnnotationException( "A named query must have a name when used in class or package level" );
 		}
 
 		String query = JandexHelper.getValue( annotation, "query", String.class );
 
 		AnnotationInstance[] hints = JandexHelper.getValue( annotation, "hints", AnnotationInstance[].class );
 
 		String cacheRegion = getString( hints, QueryHints.CACHE_REGION );
 		if ( StringHelper.isEmpty( cacheRegion ) ) {
 			cacheRegion = null;
 		}
 
 		Integer timeout = getTimeout( hints, query );
 		if ( timeout != null && timeout < 0 ) {
 			timeout = null;
 		}
 
 		Integer fetchSize = getInteger( hints, QueryHints.FETCH_SIZE, name );
 		if ( fetchSize != null && fetchSize < 0 ) {
 			fetchSize = null;
 		}
 
 		String comment = getString( hints, QueryHints.COMMENT );
 		if ( StringHelper.isEmpty( comment ) ) {
 			comment = null;
 		}
 
 		metadata.addNamedQuery(
 				new NamedQueryDefinition(
 						name,
 						query, getBoolean( hints, QueryHints.CACHEABLE, name ), cacheRegion,
 						timeout, fetchSize, getFlushMode( hints, QueryHints.FLUSH_MODE, name ),
 						getCacheMode( hints, QueryHints.CACHE_MODE, name ),
 						getBoolean( hints, QueryHints.READ_ONLY, name ), comment, null
 				)
 		);
 		LOG.debugf( "Binding named query: %s => %s", name, query );
 	}
 
 	private static void bindNamedNativeQuery(MetadataImplementor metadata, AnnotationInstance annotation) {
 		String name = JandexHelper.getValue( annotation, "name", String.class );
 		if ( StringHelper.isEmpty( name ) ) {
 			throw new AnnotationException( "A named native query must have a name when used in class or package level" );
 		}
 
 		String query = JandexHelper.getValue( annotation, "query", String.class );
 
 		String resultSetMapping = JandexHelper.getValue( annotation, "resultSetMapping", String.class );
 
 		AnnotationInstance[] hints = JandexHelper.getValue( annotation, "hints", AnnotationInstance[].class );
 
 		boolean cacheable = getBoolean( hints, "org.hibernate.cacheable", name );
 		String cacheRegion = getString( hints, QueryHints.CACHE_REGION );
 		if ( StringHelper.isEmpty( cacheRegion ) ) {
 			cacheRegion = null;
 		}
 
 		Integer timeout = getTimeout( hints, query );
 		if ( timeout != null && timeout < 0 ) {
 			timeout = null;
 		}
 
 		Integer fetchSize = getInteger( hints, QueryHints.FETCH_SIZE, name );
 		if ( fetchSize != null && fetchSize < 0 ) {
 			fetchSize = null;
 		}
 
 		FlushMode flushMode = getFlushMode( hints, QueryHints.FLUSH_MODE, name );
 		CacheMode cacheMode = getCacheMode( hints, QueryHints.CACHE_MODE, name );
 
 		boolean readOnly = getBoolean( hints, QueryHints.READ_ONLY, name );
 
 		String comment = getString( hints, QueryHints.COMMENT );
 		if ( StringHelper.isEmpty( comment ) ) {
 			comment = null;
 		}
 
 		boolean callable = getBoolean( hints, QueryHints.CALLABLE, name );
 		NamedSQLQueryDefinition def;
 		if ( StringHelper.isNotEmpty( resultSetMapping ) ) {
 			def = new NamedSQLQueryDefinition(
 					name,
 					query, resultSetMapping, null, cacheable,
 					cacheRegion, timeout, fetchSize,
 					flushMode, cacheMode, readOnly, comment,
 					null, callable
 			);
 		}
 		else {
 			AnnotationValue annotationValue = annotation.value( "resultClass" );
 			if ( annotationValue == null ) {
 				throw new NotYetImplementedException( "Pure native scalar queries are not yet supported" );
 			}
 			NativeSQLQueryRootReturn queryRoots[] = new NativeSQLQueryRootReturn[] {
 					new NativeSQLQueryRootReturn(
 							"alias1",
 							annotationValue.asString(),
 							new HashMap<String, String[]>(),
 							LockMode.READ
 					)
 			};
 			def = new NamedSQLQueryDefinition(
 					name,
 					query,
 					queryRoots,
 					null,
 					cacheable,
 					cacheRegion,
 					timeout,
 					fetchSize,
 					flushMode,
 					cacheMode,
 					readOnly,
 					comment,
 					null,
 					callable
 			);
 		}
 		metadata.addNamedNativeQuery( def );
 		LOG.debugf( "Binding named native query: %s => %s", name, query );
 	}
 
 	private static boolean getBoolean(AnnotationInstance[] hints, String element, String query) {
 		String val = getString( hints, element );
 		if ( val == null || val.equalsIgnoreCase( "false" ) ) {
 			return false;
 		}
 		if ( val.equalsIgnoreCase( "true" ) ) {
 			return true;
 		}
 		throw new AnnotationException( "Not a boolean in hint: " + query + ":" + element );
 	}
 
 	private static CacheMode getCacheMode(AnnotationInstance[] hints, String element, String query) {
 		String val = getString( hints, element );
 		if ( val == null ) {
 			return null;
 		}
 		if ( val.equalsIgnoreCase( CacheMode.GET.toString() ) ) {
 			return CacheMode.GET;
 		}
 		if ( val.equalsIgnoreCase( CacheMode.IGNORE.toString() ) ) {
 			return CacheMode.IGNORE;
 		}
 		if ( val.equalsIgnoreCase( CacheMode.NORMAL.toString() ) ) {
 			return CacheMode.NORMAL;
 		}
 		if ( val.equalsIgnoreCase( CacheMode.PUT.toString() ) ) {
 			return CacheMode.PUT;
 		}
 		if ( val.equalsIgnoreCase( CacheMode.REFRESH.toString() ) ) {
 			return CacheMode.REFRESH;
 		}
 		throw new AnnotationException( "Unknown CacheMode in hint: " + query + ":" + element );
 	}
 
 	private static FlushMode getFlushMode(AnnotationInstance[] hints, String element, String query) {
 		String val = getString( hints, element );
 		if ( val == null ) {
 			return null;
 		}
 		if ( val.equalsIgnoreCase( FlushMode.ALWAYS.toString() ) ) {
 			return FlushMode.ALWAYS;
 		}
 		else if ( val.equalsIgnoreCase( FlushMode.AUTO.toString() ) ) {
 			return FlushMode.AUTO;
 		}
 		else if ( val.equalsIgnoreCase( FlushMode.COMMIT.toString() ) ) {
 			return FlushMode.COMMIT;
 		}
 		else if ( val.equalsIgnoreCase( FlushMode.NEVER.toString() ) ) {
 			return FlushMode.MANUAL;
 		}
 		else if ( val.equalsIgnoreCase( FlushMode.MANUAL.toString() ) ) {
 			return FlushMode.MANUAL;
 		}
 		else {
 			throw new AnnotationException( "Unknown FlushMode in hint: " + query + ":" + element );
 		}
 	}
 
 	private static Integer getInteger(AnnotationInstance[] hints, String element, String query) {
 		String val = getString( hints, element );
 		if ( val == null ) {
 			return null;
 		}
 		try {
 			return Integer.decode( val );
 		}
 		catch ( NumberFormatException nfe ) {
 			throw new AnnotationException( "Not an integer in hint: " + query + ":" + element, nfe );
 		}
 	}
 
 	private static String getString(AnnotationInstance[] hints, String element) {
 		for ( AnnotationInstance hint : hints ) {
 			if ( element.equals( JandexHelper.getValue( hint, "name", String.class ) ) ) {
 				return JandexHelper.getValue( hint, "value", String.class );
 			}
 		}
 		return null;
 	}
 
 	private static Integer getTimeout(AnnotationInstance[] hints, String query) {
 		Integer timeout = getInteger( hints, QueryHints.TIMEOUT_JPA, query );
 		if ( timeout == null ) {
 			return getInteger( hints, QueryHints.TIMEOUT_HIBERNATE, query ); // timeout is already in seconds
 		}
 		return ( ( timeout + 500 ) / 1000 ); // convert milliseconds to seconds (rounded)
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/TableBinder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/TableBinder.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/TableBinder.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/TableBinder.java
index 3fb53d814f..87e3bf86ed 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/TableBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/TableBinder.java
@@ -1,126 +1,126 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.global;
+package org.hibernate.metamodel.source.annotations.global;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.Index;
 import org.jboss.logging.Logger;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.MetadataImplementor;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
 import org.hibernate.metamodel.relational.Column;
 import org.hibernate.metamodel.relational.ObjectName;
 import org.hibernate.metamodel.relational.Schema;
 import org.hibernate.metamodel.relational.SimpleValue;
 import org.hibernate.metamodel.relational.Table;
-import org.hibernate.metamodel.binder.source.annotations.HibernateDotNames;
+import org.hibernate.metamodel.source.annotations.HibernateDotNames;
 
 /**
  * Binds table related information. This binder is called after the entities are bound.
  *
  * @author Hardy Ferentschik
  */
 public class TableBinder {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			TableBinder.class.getName()
 	);
 
 	/**
 	 * Binds {@link org.hibernate.annotations.Tables} and {@link org.hibernate.annotations.Table} annotations to the supplied
 	 * metadata.
 	 *
 	 * @param metadata the global metadata
 	 * @param jandex the annotation index repository
 	 */
 	public static void bind(MetadataImplementor metadata, Index jandex) {
 		for ( AnnotationInstance tableAnnotation : jandex.getAnnotations( HibernateDotNames.TABLE ) ) {
 			bind( metadata, tableAnnotation );
 		}
 		for ( AnnotationInstance tables : jandex.getAnnotations( HibernateDotNames.TABLES ) ) {
 			for ( AnnotationInstance table : JandexHelper.getValue( tables, "value", AnnotationInstance[].class ) ) {
 				bind( metadata, table );
 			}
 		}
 	}
 
 	private static void bind(MetadataImplementor metadata, AnnotationInstance tableAnnotation) {
 		String tableName = JandexHelper.getValue( tableAnnotation, "appliesTo", String.class );
 		ObjectName objectName = new ObjectName( tableName );
 		Schema schema = metadata.getDatabase().getSchema( objectName.getSchema(), objectName.getCatalog() );
 		Table table = schema.locateTable( objectName.getName() );
 		if ( table != null ) {
 			bindHibernateTableAnnotation( table, tableAnnotation );
 		}
 	}
 
 	private static void bindHibernateTableAnnotation(Table table, AnnotationInstance tableAnnotation) {
 		for ( AnnotationInstance indexAnnotation : JandexHelper.getValue(
 				tableAnnotation,
 				"indexes",
 				AnnotationInstance[].class
 		) ) {
 			bindIndexAnnotation( table, indexAnnotation );
 		}
 		String comment = JandexHelper.getValue( tableAnnotation, "comment", String.class );
 		if ( StringHelper.isNotEmpty( comment ) ) {
 			table.addComment( comment.trim() );
 		}
 	}
 
 	private static void bindIndexAnnotation(Table table, AnnotationInstance indexAnnotation) {
 		String indexName = JandexHelper.getValue( indexAnnotation, "appliesTo", String.class );
 		String[] columnNames = JandexHelper.getValue( indexAnnotation, "columnNames", String[].class );
 		if ( columnNames == null ) {
 			LOG.noColumnsSpecifiedForIndex( indexName, table.toLoggableString() );
 			return;
 		}
 		org.hibernate.metamodel.relational.Index index = table.getOrCreateIndex( indexName );
 		for ( String columnName : columnNames ) {
 			Column column = findColumn( table, columnName );
 			if ( column == null ) {
 				throw new AnnotationException( "@Index references a unknown column: " + columnName );
 			}
 			index.addColumn( column );
 		}
 	}
 
 	private static Column findColumn(Table table, String columnName) {
 		Column column = null;
 		for ( SimpleValue value : table.values() ) {
 			if ( value instanceof Column && ( (Column) value ).getColumnName().getName().equals( columnName ) ) {
 				column = (Column) value;
 				break;
 			}
 		}
 		return column;
 	}
 
 	private TableBinder() {
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/TypeDefBinder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/TypeDefBinder.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/TypeDefBinder.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/TypeDefBinder.java
index e1fd213c50..378f92fbde 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/global/TypeDefBinder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/global/TypeDefBinder.java
@@ -1,118 +1,118 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.global;
+package org.hibernate.metamodel.source.annotations.global;
 
 import java.util.HashMap;
 import java.util.Map;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.Index;
 import org.jboss.logging.Logger;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.annotations.TypeDefs;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.MetadataImplementor;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
 import org.hibernate.metamodel.binding.TypeDef;
-import org.hibernate.metamodel.binder.source.annotations.HibernateDotNames;
+import org.hibernate.metamodel.source.annotations.HibernateDotNames;
 
 public class TypeDefBinder {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			TypeDefBinder.class.getName()
 	);
 
 	/**
 	 * Binds all {@link org.hibernate.annotations.TypeDef} and {@link TypeDefs} annotations to the supplied metadata.
 	 *
 	 * @param metadata the global metadata
 	 * @param jandex the jandex jandex
 	 */
 	public static void bind(MetadataImplementor metadata, Index jandex) {
 		for ( AnnotationInstance typeDef : jandex.getAnnotations( HibernateDotNames.TYPE_DEF ) ) {
 			bind( metadata, typeDef );
 		}
 		for ( AnnotationInstance typeDefs : jandex.getAnnotations( HibernateDotNames.TYPE_DEFS ) ) {
 			AnnotationInstance[] typeDefAnnotations = JandexHelper.getValue(
 					typeDefs,
 					"value",
 					AnnotationInstance[].class
 			);
 			for ( AnnotationInstance typeDef : typeDefAnnotations ) {
 				bind( metadata, typeDef );
 			}
 		}
 	}
 
 	private static void bind(MetadataImplementor metadata, AnnotationInstance typeDefAnnotation) {
 		String name = JandexHelper.getValue( typeDefAnnotation, "name", String.class );
 		String defaultForType = JandexHelper.getValue( typeDefAnnotation, "defaultForType", String.class );
 		String typeClass = JandexHelper.getValue( typeDefAnnotation, "typeClass", String.class );
 
 		boolean noName = StringHelper.isEmpty( name );
 		boolean noDefaultForType = defaultForType == null || defaultForType.equals( void.class.getName() );
 
 		if ( noName && noDefaultForType ) {
 			throw new AnnotationException(
 					"Either name or defaultForType (or both) attribute should be set in TypeDef having typeClass "
 							+ typeClass
 			);
 		}
 
 		Map<String, String> parameterMaps = new HashMap<String, String>();
 		AnnotationInstance[] parameterAnnotations = JandexHelper.getValue(
 				typeDefAnnotation,
 				"parameters",
 				AnnotationInstance[].class
 		);
 		for ( AnnotationInstance parameterAnnotation : parameterAnnotations ) {
 			parameterMaps.put(
 					JandexHelper.getValue( parameterAnnotation, "name", String.class ),
 					JandexHelper.getValue( parameterAnnotation, "value", String.class )
 			);
 		}
 
 		if ( !noName ) {
 			bind( name, typeClass, parameterMaps, metadata );
 		}
 		if ( !noDefaultForType ) {
 			bind( defaultForType, typeClass, parameterMaps, metadata );
 		}
 	}
 
 	private static void bind(
 			String name,
 			String typeClass,
 			Map<String, String> prms,
 			MetadataImplementor metadata) {
 		LOG.debugf( "Binding type definition: %s", name );
 		metadata.addTypeDefinition( new TypeDef( name, typeClass, prms ) );
 	}
 
 	private TypeDefBinder() {
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/PseudoJpaDotNames.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/PseudoJpaDotNames.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/PseudoJpaDotNames.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/PseudoJpaDotNames.java
index 9920716fe5..de9a703dba 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/PseudoJpaDotNames.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/PseudoJpaDotNames.java
@@ -1,44 +1,44 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml;
+package org.hibernate.metamodel.source.annotations.xml;
 
 import org.jboss.jandex.DotName;
 
 /**
  * Pseudo JPA Annotation name to distinguish Annotations defined in <persistence-unit-metadata>
  *
  * @author Strong Liu
  */
 public interface PseudoJpaDotNames {
 	DotName DEFAULT_ACCESS = DotName.createSimple( "default.access" );
 	DotName DEFAULT_DELIMITED_IDENTIFIERS = DotName.createSimple( "default.delimited.identifiers" );
 	DotName DEFAULT_ENTITY_LISTENERS = DotName.createSimple( "default.entity.listeners" );
 	DotName DEFAULT_POST_LOAD = DotName.createSimple( "default.entity.listener.post.load" );
 	DotName DEFAULT_POST_PERSIST = DotName.createSimple( "default.entity.listener.post.persist" );
 	DotName DEFAULT_POST_REMOVE = DotName.createSimple( "default.entity.listener.post.remove" );
 	DotName DEFAULT_POST_UPDATE = DotName.createSimple( "default.entity.listener.post.update" );
 	DotName DEFAULT_PRE_PERSIST = DotName.createSimple( "default.entity.listener.pre.persist" );
 	DotName DEFAULT_PRE_REMOVE = DotName.createSimple( "default.entity.listener.pre.remove" );
 	DotName DEFAULT_PRE_UPDATE = DotName.createSimple( "default.entity.listener.pre.update" );
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/AbstractAnnotationFilter.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/AbstractAnnotationFilter.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/AbstractAnnotationFilter.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/AbstractAnnotationFilter.java
index 66830bc6bc..6e0fc9e300 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/AbstractAnnotationFilter.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/AbstractAnnotationFilter.java
@@ -1,79 +1,79 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.filter;
+package org.hibernate.metamodel.source.annotations.xml.filter;
 
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.DotName;
 
-import org.hibernate.metamodel.binder.source.annotations.xml.mocker.IndexBuilder;
+import org.hibernate.metamodel.source.annotations.xml.mocker.IndexBuilder;
 
 /**
  * @author Strong Liu
  */
 abstract class AbstractAnnotationFilter implements IndexedAnnotationFilter {
 	protected static final DotName[] EMPTY_DOTNAME_ARRAY = new DotName[0];
 	private Set<DotName> candidates;
 
 	private boolean match(DotName annName) {
 		if ( candidates == null ) {
 			candidates = new HashSet<DotName>();
 			candidates.addAll( Arrays.asList( targetAnnotation() ) );
 		}
 		return candidates.contains( annName );
 	}
 
 	@Override
 	public void beforePush(IndexBuilder indexBuilder, DotName classDotName, AnnotationInstance annotationInstance) {
 		DotName annName = annotationInstance.name();
 		if ( !match( annName ) ) {
 			return;
 		}
 		Map<DotName, List<AnnotationInstance>> map = indexBuilder.getIndexedAnnotations( classDotName );
 		overrideIndexedAnnotationMap( annName, annotationInstance, map );
 	}
 
 	protected void overrideIndexedAnnotationMap(DotName annName, AnnotationInstance annotationInstance, Map<DotName, List<AnnotationInstance>> map) {
 		if ( !map.containsKey( annName ) ) {
 			return;
 		}
 		List<AnnotationInstance> indexedAnnotationInstanceList = map.get( annName );
 		if ( indexedAnnotationInstanceList.isEmpty() ) {
 			return;
 		}
 		process( annName, annotationInstance, indexedAnnotationInstanceList );
 	}
 
 	protected void process(DotName annName, AnnotationInstance annotationInstance, List<AnnotationInstance> indexedAnnotationInstanceList) {
 	}
 
 	protected DotName[] targetAnnotation() {
 		return EMPTY_DOTNAME_ARRAY;
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/ExclusiveAnnotationFilter.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/ExclusiveAnnotationFilter.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/ExclusiveAnnotationFilter.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/ExclusiveAnnotationFilter.java
index daa577db82..59c5ddd228 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/ExclusiveAnnotationFilter.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/ExclusiveAnnotationFilter.java
@@ -1,186 +1,186 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.filter;
+package org.hibernate.metamodel.source.annotations.xml.filter;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.DotName;
 
-import org.hibernate.metamodel.binder.source.annotations.xml.mocker.MockHelper;
+import org.hibernate.metamodel.source.annotations.xml.mocker.MockHelper;
 
 /**
  * @author Strong Liu
  */
 class ExclusiveAnnotationFilter extends AbstractAnnotationFilter {
 
 	public static ExclusiveAnnotationFilter INSTANCE = new ExclusiveAnnotationFilter();
 	private DotName[] targetNames;
 	private List<ExclusiveGroup> exclusiveGroupList;
 
 	private ExclusiveAnnotationFilter() {
 		this.exclusiveGroupList = getExclusiveGroupList();
 		Set<DotName> names = new HashSet<DotName>();
 		for ( ExclusiveGroup group : exclusiveGroupList ) {
 			names.addAll( group.getNames() );
 		}
 		targetNames = names.toArray( new DotName[names.size()] );
 	}
 
 	private List<ExclusiveGroup> getExclusiveGroupList() {
 		if ( exclusiveGroupList == null ) {
 			exclusiveGroupList = new ArrayList<ExclusiveGroup>();
 			ExclusiveGroup group = new ExclusiveGroup();
 			group.add( ENTITY );
 			group.add( MAPPED_SUPERCLASS );
 			group.add( EMBEDDABLE );
 			group.scope = Scope.TYPE;
 			exclusiveGroupList.add( group );
 
 			group = new ExclusiveGroup();
 			group.add( SECONDARY_TABLES );
 			group.add( SECONDARY_TABLE );
 			group.scope = Scope.TYPE;
 			exclusiveGroupList.add( group );
 
 			group = new ExclusiveGroup();
 			group.add( PRIMARY_KEY_JOIN_COLUMNS );
 			group.add( PRIMARY_KEY_JOIN_COLUMN );
 			group.scope = Scope.ATTRIBUTE;
 			exclusiveGroupList.add( group );
 
 			group = new ExclusiveGroup();
 			group.add( SQL_RESULT_SET_MAPPING );
 			group.add( SQL_RESULT_SET_MAPPINGS );
 			group.scope = Scope.TYPE;
 			exclusiveGroupList.add( group );
 
 			group = new ExclusiveGroup();
 			group.add( NAMED_NATIVE_QUERY );
 			group.add( NAMED_NATIVE_QUERIES );
 			group.scope = Scope.TYPE;
 			exclusiveGroupList.add( group );
 
 			group = new ExclusiveGroup();
 			group.add( NAMED_QUERY );
 			group.add( NAMED_QUERIES );
 			group.scope = Scope.TYPE;
 			exclusiveGroupList.add( group );
 
 			group = new ExclusiveGroup();
 			group.add( ATTRIBUTE_OVERRIDES );
 			group.add( ATTRIBUTE_OVERRIDE );
 			group.scope = Scope.ATTRIBUTE;
 			exclusiveGroupList.add( group );
 
 			group = new ExclusiveGroup();
 			group.add( ASSOCIATION_OVERRIDE );
 			group.add( ASSOCIATION_OVERRIDES );
 			group.scope = Scope.ATTRIBUTE;
 			exclusiveGroupList.add( group );
 
 			group = new ExclusiveGroup();
 			group.add( MAP_KEY_JOIN_COLUMN );
 			group.add( MAP_KEY_JOIN_COLUMNS );
 			group.scope = Scope.ATTRIBUTE;
 			exclusiveGroupList.add( group );
 
 		}
 		return exclusiveGroupList;
 	}
 
 	@Override
 	protected void overrideIndexedAnnotationMap(DotName annName, AnnotationInstance annotationInstance, Map<DotName, List<AnnotationInstance>> map) {
 		ExclusiveGroup group = getExclusiveGroup( annName );
 		if ( group == null ) {
 			return;
 		}
 		AnnotationTarget target = annotationInstance.target();
 		for ( DotName entityAnnName : group ) {
 			if ( !map.containsKey( entityAnnName ) ) {
 				continue;
 			}
 			switch ( group.scope ) {
 				case TYPE:
 					map.put( entityAnnName, Collections.<AnnotationInstance>emptyList() );
 					break;
 				case ATTRIBUTE:
 					List<AnnotationInstance> indexedAnnotationInstanceList = map.get( entityAnnName );
 					Iterator<AnnotationInstance> iter = indexedAnnotationInstanceList.iterator();
 					while ( iter.hasNext() ) {
 						AnnotationInstance ann = iter.next();
 						if ( MockHelper.targetEquals( target, ann.target() ) ) {
 							iter.remove();
 						}
 					}
 					break;
 			}
 		}
 	}
 
 	@Override
 	protected DotName[] targetAnnotation() {
 		return targetNames;
 	}
 
 	private ExclusiveGroup getExclusiveGroup(DotName annName) {
 		for ( ExclusiveGroup group : exclusiveGroupList ) {
 			if ( group.contains( annName ) ) {
 				return group;
 			}
 		}
 		return null;
 	}
 
 	enum Scope {TYPE, ATTRIBUTE}
 
 	private class ExclusiveGroup implements Iterable<DotName> {
 		public Set<DotName> getNames() {
 			return names;
 		}
 
 		private Set<DotName> names = new HashSet<DotName>();
 		Scope scope = Scope.ATTRIBUTE;
 
 		@Override
 		public Iterator iterator() {
 			return names.iterator();
 		}
 
 		boolean contains(DotName name) {
 			return names.contains( name );
 		}
 
 		void add(DotName name) {
 			names.add( name );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/IndexedAnnotationFilter.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/IndexedAnnotationFilter.java
similarity index 87%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/IndexedAnnotationFilter.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/IndexedAnnotationFilter.java
index 83190e7204..24987526af 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/IndexedAnnotationFilter.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/IndexedAnnotationFilter.java
@@ -1,43 +1,43 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.filter;
+package org.hibernate.metamodel.source.annotations.xml.filter;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.DotName;
 
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
-import org.hibernate.metamodel.binder.source.annotations.xml.mocker.IndexBuilder;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.xml.mocker.IndexBuilder;
 
 /**
  * @author Strong Liu
  */
 public interface IndexedAnnotationFilter extends JPADotNames {
 	final IndexedAnnotationFilter[] ALL_FILTERS = new IndexedAnnotationFilter[] {
 			ExclusiveAnnotationFilter.INSTANCE,
 			NameAnnotationFilter.INSTANCE, NameTargetAnnotationFilter.INSTANCE
 	};
 
 
 	void beforePush(IndexBuilder indexBuilder, DotName classDotName, AnnotationInstance annotationInstance);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/NameAnnotationFilter.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/NameAnnotationFilter.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/NameAnnotationFilter.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/NameAnnotationFilter.java
index c2c286da00..5635134bca 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/NameAnnotationFilter.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/NameAnnotationFilter.java
@@ -1,58 +1,58 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.filter;
+package org.hibernate.metamodel.source.annotations.xml.filter;
 
 import java.util.List;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.DotName;
 
 /**
  * if class from index has matched annotations, then remove.
  *
  * @author Strong Liu
  */
 class NameAnnotationFilter extends AbstractAnnotationFilter {
 	@Override
 	protected void process(DotName annName, AnnotationInstance annotationInstance, List<AnnotationInstance> indexedAnnotationInstanceList) {
 		indexedAnnotationInstanceList.clear();
 	}
 
 	public static NameTargetAnnotationFilter INSTANCE = new NameTargetAnnotationFilter();
 
 	@Override
 	protected DotName[] targetAnnotation() {
 		return new DotName[] {
 				CACHEABLE,
 				TABLE,
 				EXCLUDE_DEFAULT_LISTENERS,
 				EXCLUDE_SUPERCLASS_LISTENERS,
 				ID_CLASS,
 				INHERITANCE,
 				DISCRIMINATOR_VALUE,
 				DISCRIMINATOR_COLUMN,
 				ENTITY_LISTENERS
 		};
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/NameTargetAnnotationFilter.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/NameTargetAnnotationFilter.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/NameTargetAnnotationFilter.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/NameTargetAnnotationFilter.java
index 8b99cc6e9d..1582c7e6db 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/filter/NameTargetAnnotationFilter.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/filter/NameTargetAnnotationFilter.java
@@ -1,94 +1,94 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.filter;
+package org.hibernate.metamodel.source.annotations.xml.filter;
 
 import java.util.Iterator;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.DotName;
 
-import org.hibernate.metamodel.binder.source.annotations.xml.mocker.MockHelper;
+import org.hibernate.metamodel.source.annotations.xml.mocker.MockHelper;
 
 /**
  * @author Strong Liu
  */
 class NameTargetAnnotationFilter extends AbstractAnnotationFilter {
 	@Override
 	protected void process(DotName annName, AnnotationInstance annotationInstance, List<AnnotationInstance> indexedAnnotationInstanceList) {
 		AnnotationTarget target = annotationInstance.target();
 
 		for ( Iterator<AnnotationInstance> iter = indexedAnnotationInstanceList.iterator(); iter.hasNext(); ) {
 			AnnotationInstance ann = iter.next();
 			if ( MockHelper.targetEquals( target, ann.target() ) ) {
 				iter.remove();
 			}
 		}
 	}
 
 	public static NameTargetAnnotationFilter INSTANCE = new NameTargetAnnotationFilter();
 
 	@Override
 	protected DotName[] targetAnnotation() {
 		return new DotName[] {
 				LOB,
 				ID,
 				BASIC,
 				GENERATED_VALUE,
 				VERSION,
 				TRANSIENT,
 				ACCESS,
 				POST_LOAD,
 				POST_PERSIST,
 				POST_REMOVE,
 				POST_UPDATE,
 				PRE_PERSIST,
 				PRE_REMOVE,
 				PRE_UPDATE,
 				EMBEDDED_ID,
 				EMBEDDED,
 				MANY_TO_ONE,
 				MANY_TO_MANY,
 				ONE_TO_ONE,
 				ONE_TO_MANY,
 				ELEMENT_COLLECTION,
 				COLLECTION_TABLE,
 				COLUMN,
 				ENUMERATED,
 				JOIN_TABLE,
 				TEMPORAL,
 				ORDER_BY,
 				ORDER_COLUMN,
 				JOIN_COLUMN,
 				JOIN_COLUMNS,
 				MAPS_ID,
 				MAP_KEY_TEMPORAL,
 				MAP_KEY,
 				MAP_KEY_CLASS,
 				MAP_KEY_COLUMN,
 				MAP_KEY_ENUMERATED
 		};
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AbstractAttributesBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractAttributesBuilder.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AbstractAttributesBuilder.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractAttributesBuilder.java
index 88abb10c59..81e26a2220 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AbstractAttributesBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractAttributesBuilder.java
@@ -1,127 +1,127 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.List;
 
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLBasic;
 import org.hibernate.metamodel.source.annotation.xml.XMLElementCollection;
 import org.hibernate.metamodel.source.annotation.xml.XMLEmbedded;
 import org.hibernate.metamodel.source.annotation.xml.XMLEmbeddedId;
 import org.hibernate.metamodel.source.annotation.xml.XMLId;
 import org.hibernate.metamodel.source.annotation.xml.XMLManyToMany;
 import org.hibernate.metamodel.source.annotation.xml.XMLManyToOne;
 import org.hibernate.metamodel.source.annotation.xml.XMLOneToMany;
 import org.hibernate.metamodel.source.annotation.xml.XMLOneToOne;
 import org.hibernate.metamodel.source.annotation.xml.XMLTransient;
 import org.hibernate.metamodel.source.annotation.xml.XMLVersion;
 
 /**
  * Abstract Parser to handle {@link org.hibernate.metamodel.source.annotation.xml.XMLAttributes XMLAttributes}
  * and {@link org.hibernate.metamodel.source.annotation.xml.XMLEmbeddableAttributes XMLEmbeddableAttributes}.
  *
  * It would be really helpful if these two classes can implement an interface with those abstract methods in this class.
  *
  * @author Strong Liu
  */
 abstract class AbstractAttributesBuilder {
 
 	private ClassInfo classInfo;
 	private EntityMappingsMocker.Default defaults;
 	private IndexBuilder indexBuilder;
 
 	AbstractAttributesBuilder(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults) {
 		this.indexBuilder = indexBuilder;
 		this.classInfo = classInfo;
 		this.defaults = defaults;
 	}
 
 	final void parser() {
 		for ( XMLId id : getId() ) {
 			new IdMocker( indexBuilder, classInfo, defaults, id ).process();
 		}
 		for ( XMLTransient transientObj : getTransient() ) {
 			new TransientMocker( indexBuilder, classInfo, defaults, transientObj ).process();
 		}
 		for ( XMLVersion version : getVersion() ) {
 			new VersionMocker( indexBuilder, classInfo, defaults, version ).process();
 		}
 
 		for ( XMLBasic basic : getBasic() ) {
 			new BasicMocker( indexBuilder, classInfo, defaults, basic ).process();
 		}
 		for ( XMLElementCollection elementCollection : getElementCollection() ) {
 			new ElementCollectionMocker(
 					indexBuilder, classInfo, defaults, elementCollection
 			).process();
 		}
 		for ( XMLEmbedded embedded : getEmbedded() ) {
 			new EmbeddedMocker( indexBuilder, classInfo, defaults, embedded ).process();
 		}
 		for ( XMLManyToMany manyToMany : getManyToMany() ) {
 			new ManyToManyMocker( indexBuilder, classInfo, defaults, manyToMany ).process();
 		}
 
 		for ( XMLManyToOne manyToOne : getManyToOne() ) {
 			new ManyToOneMocker( indexBuilder, classInfo, defaults, manyToOne ).process();
 		}
 		for ( XMLOneToMany oneToMany : getOneToMany() ) {
 			new OneToManyMocker(
 					indexBuilder, classInfo, defaults, oneToMany
 			).process();
 		}
 		for ( XMLOneToOne oneToOne : getOneToOne() ) {
 			new OneToOneMocker( indexBuilder, classInfo, defaults, oneToOne ).process();
 		}
 		if ( getEmbeddedId() != null ) {
 			new EmbeddedIdMocker(
 					indexBuilder, classInfo, defaults, getEmbeddedId()
 			).process();
 		}
 	}
 
 	abstract List<XMLId> getId();
 
 	abstract List<XMLTransient> getTransient();
 
 	abstract List<XMLVersion> getVersion();
 
 	abstract List<XMLBasic> getBasic();
 
 	abstract List<XMLElementCollection> getElementCollection();
 
 	abstract List<XMLEmbedded> getEmbedded();
 
 	abstract List<XMLManyToMany> getManyToMany();
 
 	abstract List<XMLManyToOne> getManyToOne();
 
 	abstract List<XMLOneToMany> getOneToMany();
 
 	abstract List<XMLOneToOne> getOneToOne();
 
 	abstract XMLEmbeddedId getEmbeddedId();
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AbstractEntityObjectMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractEntityObjectMocker.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AbstractEntityObjectMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractEntityObjectMocker.java
index ca1221b7fb..ada9a6efa0 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AbstractEntityObjectMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractEntityObjectMocker.java
@@ -1,186 +1,186 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLAttributes;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntityListeners;
 import org.hibernate.metamodel.source.annotation.xml.XMLIdClass;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostLoad;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostPersist;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostRemove;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostUpdate;
 import org.hibernate.metamodel.source.annotation.xml.XMLPrePersist;
 import org.hibernate.metamodel.source.annotation.xml.XMLPreRemove;
 import org.hibernate.metamodel.source.annotation.xml.XMLPreUpdate;
 
 /**
  * @author Strong Liu
  */
 abstract class AbstractEntityObjectMocker extends AnnotationMocker {
 	private ListenerMocker listenerParser;
 	protected AbstractAttributesBuilder attributesBuilder;
 	protected ClassInfo classInfo;
 
 	AbstractEntityObjectMocker(IndexBuilder indexBuilder, EntityMappingsMocker.Default defaults) {
 		super( indexBuilder, defaults );
 	}
 
 	private boolean isPreProcessCalled = false;
 
 	/**
 	 * Pre-process Entity Objects to find the default {@link javax.persistence.Access} for later attributes processing.
 	 */
 	final void preProcess() {
 		applyDefaults();
 		classInfo = indexBuilder.createClassInfo( getClassName() );
 		DotName classDotName = classInfo.name();
 		if ( isMetadataComplete() ) {
 			indexBuilder.metadataComplete( classDotName );
 		}
 		parserAccessType( getAccessType(), getTarget() );
 		isPreProcessCalled = true;
 	}
 
 	final void process() {
 		if ( !isPreProcessCalled ) {
 			throw new AssertionFailure( "preProcess should be called before process" );
 		}
 		if ( getAccessType() == null ) {
 			XMLAccessType accessType = AccessHelper.getEntityAccess( getTargetName(), indexBuilder );
 			if ( accessType == null ) {
 				accessType = getDefaults().getAccess();
 			}
 			parserAccessType( accessType, getTarget() );
 		}
 		processExtra();
 		if ( isExcludeDefaultListeners() ) {
 			create( EXCLUDE_DEFAULT_LISTENERS );
 		}
 		if ( isExcludeSuperclassListeners() ) {
 			create( EXCLUDE_SUPERCLASS_LISTENERS );
 		}
 		parserIdClass( getIdClass() );
 
 		if ( getAttributes() != null ) {
 			getAttributesBuilder().parser();
 
 		}
 		if ( getEntityListeners() != null ) {
 			getListenerParser().parser( getEntityListeners() );
 		}
 		getListenerParser().parser( getPrePersist() );
 		getListenerParser().parser( getPreRemove() );
 		getListenerParser().parser( getPreUpdate() );
 		getListenerParser().parser( getPostPersist() );
 		getListenerParser().parser( getPostUpdate() );
 		getListenerParser().parser( getPostRemove() );
 		getListenerParser().parser( getPostLoad() );
 
 		indexBuilder.finishEntityObject( getTargetName(), getDefaults() );
 	}
 
 
 	abstract protected void processExtra();
 
 	/**
 	 * give a chance to the sub-classes to override defaults configuration
 	 */
 	abstract protected void applyDefaults();
 
 	abstract protected boolean isMetadataComplete();
 
 	abstract protected boolean isExcludeDefaultListeners();
 
 	abstract protected boolean isExcludeSuperclassListeners();
 
 	abstract protected XMLIdClass getIdClass();
 
 	abstract protected XMLEntityListeners getEntityListeners();
 
 	abstract protected XMLAccessType getAccessType();
 
 	abstract protected String getClassName();
 
 	abstract protected XMLPrePersist getPrePersist();
 
 	abstract protected XMLPreRemove getPreRemove();
 
 	abstract protected XMLPreUpdate getPreUpdate();
 
 	abstract protected XMLPostPersist getPostPersist();
 
 	abstract protected XMLPostUpdate getPostUpdate();
 
 	abstract protected XMLPostRemove getPostRemove();
 
 	abstract protected XMLPostLoad getPostLoad();
 
 	abstract protected XMLAttributes getAttributes();
 
 	protected ListenerMocker getListenerParser() {
 		if ( listenerParser == null ) {
 			listenerParser = new ListenerMocker( indexBuilder, classInfo );
 		}
 		return listenerParser;
 	}
 
 	protected AbstractAttributesBuilder getAttributesBuilder() {
 		if ( attributesBuilder == null ) {
 			attributesBuilder = new AttributesBuilder(
 					indexBuilder, classInfo, getAccessType(), getDefaults(), getAttributes()
 			);
 		}
 		return attributesBuilder;
 	}
 
 	protected AnnotationInstance parserIdClass(XMLIdClass idClass) {
 		if ( idClass == null ) {
 			return null;
 		}
 		String className = MockHelper.buildSafeClassName( idClass.getClazz(), getDefaults().getPackageName() );
 		return create(
 				ID_CLASS, MockHelper.classValueArray(
 				"value", className, indexBuilder.getServiceRegistry()
 		)
 		);
 	}
 
 
 	@Override
 	protected DotName getTargetName() {
 		return classInfo.name();
 	}
 
 	@Override
 	protected AnnotationTarget getTarget() {
 		return classInfo;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AbstractMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMocker.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AbstractMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMocker.java
index 9b6c6aadbb..30b645aa4a 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AbstractMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMocker.java
@@ -1,107 +1,107 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.DotName;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLUniqueConstraint;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
 
 /**
  * Base class for the mock jandex annotations created from orm.xml.
  *
  * @author Strong Liu
  */
 abstract class AbstractMocker implements JPADotNames {
 	final protected IndexBuilder indexBuilder;
 
 	AbstractMocker(IndexBuilder indexBuilder) {
 		this.indexBuilder = indexBuilder;
 	}
 
 
 	abstract protected AnnotationInstance push(AnnotationInstance annotationInstance);
 
 
 	protected AnnotationInstance create(DotName name, AnnotationTarget target) {
 		return create( name, target, MockHelper.EMPTY_ANNOTATION_VALUE_ARRAY );
 	}
 
 
 	protected AnnotationInstance create(DotName name, AnnotationTarget target, List<AnnotationValue> annotationValueList) {
 		return create( name, target, MockHelper.toArray( annotationValueList ) );
 	}
 
 	protected AnnotationInstance create(DotName name, AnnotationTarget target, AnnotationValue[] annotationValues) {
 		AnnotationInstance annotationInstance = MockHelper.create( name, target, annotationValues );
 		push( annotationInstance );
 		return annotationInstance;
 
 	}
 
 
 	protected AnnotationInstance parserAccessType(XMLAccessType accessType, AnnotationTarget target) {
 		if ( accessType == null ) {
 			return null;
 		}
 		return create( ACCESS, target, MockHelper.enumValueArray( "value", ACCESS_TYPE, accessType ) );
 	}
 
 	protected void nestedUniqueConstraintList(String name, List<XMLUniqueConstraint> constraints, List<AnnotationValue> annotationValueList) {
 		if ( MockHelper.isNotEmpty( constraints ) ) {
 			AnnotationValue[] values = new AnnotationValue[constraints.size()];
 			for ( int i = 0; i < constraints.size(); i++ ) {
 				AnnotationInstance annotationInstance = parserUniqueConstraint( constraints.get( i ), null );
 				values[i] = MockHelper.nestedAnnotationValue(
 						"", annotationInstance
 				);
 			}
 			MockHelper.addToCollectionIfNotNull(
 					annotationValueList, AnnotationValue.createArrayValue( name, values )
 			);
 		}
 
 	}
 
 	//@UniqueConstraint
 	protected AnnotationInstance parserUniqueConstraint(XMLUniqueConstraint uniqueConstraint, AnnotationTarget target) {
 		if ( uniqueConstraint == null ) {
 			return null;
 		}
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", uniqueConstraint.getName(), annotationValueList );
 		MockHelper.stringArrayValue( "columnNames", uniqueConstraint.getColumnName(), annotationValueList );
 		return
 				create( UNIQUE_CONSTRAINT, target,
 						annotationValueList );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AccessHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AccessHelper.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AccessHelper.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AccessHelper.java
index 84299b99a9..33ea7b5943 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AccessHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AccessHelper.java
@@ -1,211 +1,211 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.MethodInfo;
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.MappingException;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
-import org.hibernate.metamodel.binder.source.annotations.xml.PseudoJpaDotNames;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.annotations.xml.PseudoJpaDotNames;
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
 
 /**
  * @author Strong Liu
  */
 class AccessHelper implements JPADotNames {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			AccessHelper.class.getName()
 	);
 
 	static XMLAccessType getAccessFromDefault(IndexBuilder indexBuilder) {
 		AnnotationInstance annotationInstance = JandexHelper.getSingleAnnotation(
 				indexBuilder.getAnnotations(),
 				PseudoJpaDotNames.DEFAULT_ACCESS
 		);
 		if ( annotationInstance == null ) {
 			return null;
 		}
 		else {
 			return JandexHelper.getValueAsEnum( annotationInstance, "value", XMLAccessType.class );
 		}
 
 	}
 
 	static XMLAccessType getAccessFromIdPosition(DotName className, IndexBuilder indexBuilder) {
 		Map<DotName, List<AnnotationInstance>> indexedAnnotations = indexBuilder.getIndexedAnnotations( className );
 		Map<DotName, List<AnnotationInstance>> ormAnnotations = indexBuilder.getClassInfoAnnotationsMap( className );
 		XMLAccessType accessType = getAccessFromIdPosition( ormAnnotations );
 		if ( accessType == null ) {
 			accessType = getAccessFromIdPosition( indexedAnnotations );
 		}
 		if ( accessType == null ) {
 			ClassInfo parent = indexBuilder.getClassInfo( className );
 			if ( parent == null ) {
 				parent = indexBuilder.getIndexedClassInfo( className );
 			}
 			if ( parent != null ) {
 				DotName parentClassName = parent.superName();
 				accessType = getAccessFromIdPosition( parentClassName, indexBuilder );
 			}
 
 		}
 
 		return accessType;
 	}
 
 	private static XMLAccessType getAccessFromIdPosition(Map<DotName, List<AnnotationInstance>> annotations) {
 		if ( annotations == null || annotations.isEmpty() || !( annotations.containsKey( ID ) ) ) {
 			return null;
 		}
 		List<AnnotationInstance> idAnnotationInstances = annotations.get( ID );
 		if ( MockHelper.isNotEmpty( idAnnotationInstances ) ) {
 			return processIdAnnotations( idAnnotationInstances );
 		}
 		return null;
 	}
 
 	private static XMLAccessType processIdAnnotations(List<AnnotationInstance> idAnnotations) {
 		XMLAccessType accessType = null;
 		for ( AnnotationInstance annotation : idAnnotations ) {
 			AnnotationTarget tmpTarget = annotation.target();
 			if ( tmpTarget == null ) {
 				throw new AssertionFailure( "@Id has no AnnotationTarget, this is mostly a internal error." );
 			}
 			if ( accessType == null ) {
 				accessType = annotationTargetToAccessType( tmpTarget );
 			}
 			else {
 				if ( !accessType.equals( annotationTargetToAccessType( tmpTarget ) ) ) {
 					throw new MappingException( "Inconsistent placement of @Id annotation within hierarchy " );
 				}
 			}
 		}
 		return accessType;
 	}
 
 	static XMLAccessType annotationTargetToAccessType(AnnotationTarget target) {
 		return ( target instanceof MethodInfo ) ? XMLAccessType.PROPERTY : XMLAccessType.FIELD;
 	}
 
 	static XMLAccessType getEntityAccess(DotName className, IndexBuilder indexBuilder) {
 		Map<DotName, List<AnnotationInstance>> indexedAnnotations = indexBuilder.getIndexedAnnotations( className );
 		Map<DotName, List<AnnotationInstance>> ormAnnotations = indexBuilder.getClassInfoAnnotationsMap( className );
 		XMLAccessType accessType = getAccess( ormAnnotations );
 		if ( accessType == null ) {
 			accessType = getAccess( indexedAnnotations );
 		}
 		if ( accessType == null ) {
 			ClassInfo parent = indexBuilder.getClassInfo( className );
 			if ( parent == null ) {
 				parent = indexBuilder.getIndexedClassInfo( className );
 			}
 			if ( parent != null ) {
 				DotName parentClassName = parent.superName();
 				accessType = getEntityAccess( parentClassName, indexBuilder );
 			}
 		}
 		return accessType;
 
 	}
 
 	private static XMLAccessType getAccess(Map<DotName, List<AnnotationInstance>> annotations) {
 		if ( annotations == null || annotations.isEmpty() || !isEntityObject( annotations ) ) {
 			return null;
 		}
 		List<AnnotationInstance> accessAnnotationInstances = annotations.get( JPADotNames.ACCESS );
 		if ( MockHelper.isNotEmpty( accessAnnotationInstances ) ) {
 			for ( AnnotationInstance annotationInstance : accessAnnotationInstances ) {
 				if ( annotationInstance.target() != null && annotationInstance.target() instanceof ClassInfo ) {
 					return JandexHelper.getValueAsEnum(
 							annotationInstance,
 							"value",
 							XMLAccessType.class
 					);
 				}
 			}
 		}
 		return null;
 	}
 
 	private static boolean isEntityObject(Map<DotName, List<AnnotationInstance>> annotations) {
 		return annotations.containsKey( ENTITY ) || annotations.containsKey( MAPPED_SUPERCLASS ) || annotations
 				.containsKey( EMBEDDABLE );
 	}
 
 	/**
 	 * Get {@link javax.persistence.AccessType } from {@link javax.persistence.Access @Access} on the attribute of the given class
 	 */
 	static XMLAccessType getAccessFromAttributeAnnotation(DotName className, String attributeName, IndexBuilder indexBuilder) {
 		Map<DotName, List<AnnotationInstance>> indexedAnnotations = indexBuilder.getIndexedAnnotations( className );
 		if ( indexedAnnotations != null && indexedAnnotations.containsKey( ACCESS ) ) {
 			List<AnnotationInstance> annotationInstances = indexedAnnotations.get( ACCESS );
 			if ( MockHelper.isNotEmpty( annotationInstances ) ) {
 				for ( AnnotationInstance annotationInstance : annotationInstances ) {
 					AnnotationTarget indexedPropertyTarget = annotationInstance.target();
 					if ( indexedPropertyTarget == null ) {
 						continue;
 					}
 					if ( JandexHelper.getPropertyName( indexedPropertyTarget ).equals( attributeName ) ) {
 						XMLAccessType accessType = JandexHelper.getValueAsEnum(
 								annotationInstance,
 								"value",
 								XMLAccessType.class
 						);
 						/**
 						 * here we ignore @Access(FIELD) on property (getter) and @Access(PROPERTY) on field
 						 */
 						XMLAccessType targetAccessType = annotationTargetToAccessType( indexedPropertyTarget );
 						if ( accessType.equals( targetAccessType ) ) {
 							return targetAccessType;
 						}
 						else {
 							LOG.warn(
 									String.format(
 											"%s.%s has @Access on %s, but it tries to assign the access type to %s, this is not allowed by JPA spec, and will be ignored.",
 											className,
 											attributeName,
 											targetAccessType,
 											accessType
 									)
 							);
 						}
 					}
 				}
 			}
 		}
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AnnotationMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AnnotationMocker.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AnnotationMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AnnotationMocker.java
index d5bea2a0cd..4be7b035bd 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AnnotationMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AnnotationMocker.java
@@ -1,557 +1,557 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.DotName;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.metamodel.source.annotation.xml.XMLAssociationOverride;
 import org.hibernate.metamodel.source.annotation.xml.XMLAttributeOverride;
 import org.hibernate.metamodel.source.annotation.xml.XMLCollectionTable;
 import org.hibernate.metamodel.source.annotation.xml.XMLColumn;
 import org.hibernate.metamodel.source.annotation.xml.XMLEnumType;
 import org.hibernate.metamodel.source.annotation.xml.XMLJoinColumn;
 import org.hibernate.metamodel.source.annotation.xml.XMLJoinTable;
 import org.hibernate.metamodel.source.annotation.xml.XMLLob;
 import org.hibernate.metamodel.source.annotation.xml.XMLOrderColumn;
 import org.hibernate.metamodel.source.annotation.xml.XMLPrimaryKeyJoinColumn;
 import org.hibernate.metamodel.source.annotation.xml.XMLTemporalType;
 
 /**
  * @author Strong Liu
  */
 abstract class AnnotationMocker extends AbstractMocker {
 	private EntityMappingsMocker.Default defaults;
 
 	AnnotationMocker(IndexBuilder indexBuilder, EntityMappingsMocker.Default defaults) {
 		super( indexBuilder );
 		this.defaults = defaults;
 	}
 
 	abstract void process();
 
 	protected EntityMappingsMocker.Default getDefaults() {
 		return defaults;
 	}
 
 	protected boolean isDefaultCascadePersist() {
 		return defaults.isCascadePersist()!=null && defaults.isCascadePersist();
 	}
 
 	//@JoinTable
 	protected AnnotationInstance parserJoinTable(XMLJoinTable joinTable, AnnotationTarget target) {
 		if ( joinTable == null ) {
 			return null;
 		}
 		DefaultConfigurationHelper.INSTANCE.applyDefaults(
 				new SchemaAware.JoinTableSchemaAware( joinTable ),
 				getDefaults()
 		);
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", joinTable.getName(), annotationValueList );
 		MockHelper.stringValue( "catalog", joinTable.getCatalog(), annotationValueList );
 		MockHelper.stringValue( "schema", joinTable.getSchema(), annotationValueList );
 		nestedJoinColumnList( "joinColumns", joinTable.getJoinColumn(), annotationValueList );
 		nestedJoinColumnList(
 				"inverseJoinColumns", joinTable.getInverseJoinColumn(), annotationValueList
 		);
 		nestedUniqueConstraintList(
 				"uniqueConstraints", joinTable.getUniqueConstraint(), annotationValueList
 		);
 		return create( JOIN_TABLE, target, annotationValueList );
 	}
 
 	//@AssociationOverride
 	private AnnotationInstance parserAssociationOverride(XMLAssociationOverride associationOverride, AnnotationTarget target) {
 		if ( associationOverride == null ) {
 			return null;
 		}
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", associationOverride.getName(), annotationValueList );
 		if ( associationOverride instanceof XMLAssociationOverrideProxy ) {
 			XMLAssociationOverrideProxy proxy = (XMLAssociationOverrideProxy) associationOverride;
 			MockHelper.addToCollectionIfNotNull( annotationValueList, proxy.getJoinColumnsAnnotationValue() );
 			MockHelper.addToCollectionIfNotNull( annotationValueList, proxy.getJoinTableAnnotationValue() );
 		}
 		else {
 			nestedJoinColumnList(
 					"joinColumns", associationOverride.getJoinColumn(), annotationValueList
 			);
 			MockHelper.nestedAnnotationValue(
 					"joinTable", parserJoinTable( associationOverride.getJoinTable(), null ), annotationValueList
 			);
 		}
 		return create( ASSOCIATION_OVERRIDE, target, annotationValueList );
 	}
 
 	private AnnotationValue[] nestedJoinColumnList(String name, List<XMLJoinColumn> columns, List<AnnotationValue> annotationValueList) {
 		if ( MockHelper.isNotEmpty( columns ) ) {
 			AnnotationValue[] values = new AnnotationValue[columns.size()];
 			for ( int i = 0; i < columns.size(); i++ ) {
 				AnnotationInstance annotationInstance = parserJoinColumn( columns.get( i ), null );
 				values[i] = MockHelper.nestedAnnotationValue(
 						"", annotationInstance
 				);
 			}
 			MockHelper.addToCollectionIfNotNull(
 					annotationValueList, AnnotationValue.createArrayValue( name, values )
 			);
 			return values;
 		}
 		return MockHelper.EMPTY_ANNOTATION_VALUE_ARRAY;
 	}
 
 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	//@Column
 	protected AnnotationInstance parserColumn(XMLColumn column, AnnotationTarget target) {
 		if ( column == null ) {
 			return null;
 		}
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", column.getName(), annotationValueList );
 		MockHelper.stringValue( "columnDefinition", column.getColumnDefinition(), annotationValueList );
 		MockHelper.stringValue( "table", column.getTable(), annotationValueList );
 		MockHelper.booleanValue( "unique", column.isUnique(), annotationValueList );
 		MockHelper.booleanValue( "nullable", column.isNullable(), annotationValueList );
 		MockHelper.booleanValue( "insertable", column.isInsertable(), annotationValueList );
 		MockHelper.booleanValue( "updatable", column.isUpdatable(), annotationValueList );
 		MockHelper.integerValue( "length", column.getLength(), annotationValueList );
 		MockHelper.integerValue( "precision", column.getPrecision(), annotationValueList );
 		MockHelper.integerValue( "scale", column.getScale(), annotationValueList );
 		return create( COLUMN, target, annotationValueList );
 	}
 
 	//@AttributeOverride
 	private AnnotationInstance parserAttributeOverride(XMLAttributeOverride attributeOverride, AnnotationTarget target) {
 		if ( attributeOverride == null ) {
 			return null;
 		}
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", attributeOverride.getName(), annotationValueList );
 		if ( attributeOverride instanceof XMLAttributeOverrideProxy ) {
 			XMLAttributeOverrideProxy proxy = (XMLAttributeOverrideProxy) attributeOverride;
 			MockHelper.addToCollectionIfNotNull( annotationValueList, proxy.getColumnAnnotationValue() );
 		}
 		else {
 			MockHelper.nestedAnnotationValue(
 					"column", parserColumn( attributeOverride.getColumn(), null ), annotationValueList
 			);
 		}
 		return
 				create(
 						ATTRIBUTE_OVERRIDE, target, annotationValueList
 
 				);
 	}
 
 
 	protected AnnotationInstance parserOrderColumn(XMLOrderColumn orderColumn, AnnotationTarget target) {
 		if ( orderColumn == null ) {
 			return null;
 		}
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", orderColumn.getName(), annotationValueList );
 		MockHelper.stringValue( "columnDefinition", orderColumn.getColumnDefinition(), annotationValueList );
 		MockHelper.booleanValue( "nullable", orderColumn.isNullable(), annotationValueList );
 		MockHelper.booleanValue( "insertable", orderColumn.isInsertable(), annotationValueList );
 		MockHelper.booleanValue( "updatable", orderColumn.isUpdatable(), annotationValueList );
 		return create( ORDER_COLUMN, target, annotationValueList );
 	}
 
 	//@JoinColumn
 	protected AnnotationInstance parserJoinColumn(XMLJoinColumn column, AnnotationTarget target) {
 		if ( column == null ) {
 			return null;
 		}
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", column.getName(), annotationValueList );
 		MockHelper.stringValue( "columnDefinition", column.getColumnDefinition(), annotationValueList );
 		MockHelper.stringValue( "table", column.getTable(), annotationValueList );
 		MockHelper.stringValue(
 				"referencedColumnName", column.getReferencedColumnName(), annotationValueList
 		);
 		MockHelper.booleanValue( "unique", column.isUnique(), annotationValueList );
 		MockHelper.booleanValue( "nullable", column.isNullable(), annotationValueList );
 		MockHelper.booleanValue( "insertable", column.isInsertable(), annotationValueList );
 		MockHelper.booleanValue( "updatable", column.isUpdatable(), annotationValueList );
 		return create( JOIN_COLUMN, target, annotationValueList );
 	}
 
 	protected AnnotationInstance parserLob(XMLLob lob, AnnotationTarget target) {
 		if ( lob == null ) {
 			return null;
 		}
 		return create( LOB, target );
 	}
 
 	protected AnnotationInstance parserTemporalType(XMLTemporalType temporalType, AnnotationTarget target) {
 		if ( temporalType == null ) {
 			return null;
 		}
 		return create( TEMPORAL, target, MockHelper.enumValueArray( "value", TEMPORAL_TYPE, temporalType ) );
 	}
 
 	protected AnnotationInstance parserEnumType(XMLEnumType enumerated, AnnotationTarget target) {
 		if ( enumerated == null ) {
 			return null;
 		}
 		return create( ENUMERATED, target, MockHelper.enumValueArray( "value", ENUM_TYPE, enumerated ) );
 	}
 
 
 	protected AnnotationInstance parserPrimaryKeyJoinColumn(XMLPrimaryKeyJoinColumn primaryKeyJoinColumn, AnnotationTarget target) {
 		if ( primaryKeyJoinColumn == null ) {
 			return null;
 		}
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", primaryKeyJoinColumn.getName(), annotationValueList );
 		MockHelper.stringValue(
 				"referencedColumnName", primaryKeyJoinColumn.getReferencedColumnName(), annotationValueList
 		);
 		MockHelper.stringValue(
 				"columnDefinition", primaryKeyJoinColumn.getColumnDefinition(), annotationValueList
 		);
 		return
 				create(
 						PRIMARY_KEY_JOIN_COLUMN, target, annotationValueList
 
 				);
 	}
 
 	protected AnnotationInstance parserPrimaryKeyJoinColumnList(List<XMLPrimaryKeyJoinColumn> primaryKeyJoinColumnList, AnnotationTarget target) {
 		if ( MockHelper.isNotEmpty( primaryKeyJoinColumnList ) ) {
 			if ( primaryKeyJoinColumnList.size() == 1 ) {
 				return parserPrimaryKeyJoinColumn( primaryKeyJoinColumnList.get( 0 ), target );
 			}
 			else {
 				return create(
 						PRIMARY_KEY_JOIN_COLUMNS,
 						target,
 						nestedPrimaryKeyJoinColumnList( "value", primaryKeyJoinColumnList, null )
 				);
 			}
 		}
 
 		return null;
 
 	}
 
 	protected AnnotationValue[] nestedPrimaryKeyJoinColumnList(String name, List<XMLPrimaryKeyJoinColumn> constraints, List<AnnotationValue> annotationValueList) {
 		if ( MockHelper.isNotEmpty( constraints ) ) {
 			AnnotationValue[] values = new AnnotationValue[constraints.size()];
 			for ( int i = 0; i < constraints.size(); i++ ) {
 				AnnotationInstance annotationInstance = parserPrimaryKeyJoinColumn( constraints.get( i ), null );
 				values[i] = MockHelper.nestedAnnotationValue(
 						"", annotationInstance
 				);
 			}
 			MockHelper.addToCollectionIfNotNull(
 					annotationValueList, AnnotationValue.createArrayValue( name, values )
 			);
 			return values;
 		}
 		return MockHelper.EMPTY_ANNOTATION_VALUE_ARRAY;
 
 	}
 
 	protected void getAnnotationInstanceByTarget(DotName annName, AnnotationTarget target, Operation operation) {
 		Map<DotName, List<AnnotationInstance>> annotatedMap = indexBuilder.getIndexedAnnotations( getTargetName() );
 		if ( !annotatedMap.containsKey( annName ) ) {
 			return;
 		}
 		List<AnnotationInstance> annotationInstanceList = annotatedMap.get( annName );
 		if ( MockHelper.isNotEmpty( annotationInstanceList ) ) {
 			for ( AnnotationInstance annotationInstance : annotationInstanceList ) {
 				AnnotationTarget annotationTarget = annotationInstance.target();
 				if ( MockHelper.targetEquals( target, annotationTarget ) ) {
 					if ( operation.process( annotationInstance ) ) {
 						return;
 					}
 				}
 			}
 		}
 	}
 
 
 	protected AnnotationInstance parserAttributeOverrides(List<XMLAttributeOverride> attributeOverrides, AnnotationTarget target) {
 		if ( target == null ) {
 			throw new AssertionFailure( "target can not be null" );
 		}
 		if ( attributeOverrides == null || attributeOverrides.isEmpty() ) {
 			return null;
 		}
 		Set<String> names = new HashSet<String>();
 		for ( XMLAttributeOverride attributeOverride : attributeOverrides ) {
 			names.add( attributeOverride.getName() );
 		}
 		Operation operation = new AttributeOverrideOperation( names, attributeOverrides );
 		getAnnotationInstanceByTarget(
 				ATTRIBUTE_OVERRIDES, target, new ContainerOperation( operation )
 		);
 		getAnnotationInstanceByTarget(
 				ATTRIBUTE_OVERRIDE, target, operation
 		);
 		if ( attributeOverrides.size() == 1 ) {
 			return parserAttributeOverride( attributeOverrides.get( 0 ), target );
 		}
 		else {
 			AnnotationValue[] values = new AnnotationValue[attributeOverrides.size()];
 			for ( int i = 0; i < values.length; i++ ) {
 				values[i] = MockHelper.nestedAnnotationValue(
 						"", parserAttributeOverride( attributeOverrides.get( i ), null )
 				);
 			}
 			return create(
 					ATTRIBUTE_OVERRIDES,
 					target,
 					new AnnotationValue[] { AnnotationValue.createArrayValue( "value", values ) }
 			);
 		}
 	}
 
 	protected AnnotationInstance parserAssociationOverrides(List<XMLAssociationOverride> associationOverrides, AnnotationTarget target) {
 		if ( target == null ) {
 			throw new AssertionFailure( "target can not be null" );
 		}
 		if ( associationOverrides == null || associationOverrides.isEmpty() ) {
 			return null;
 		}
 
 		Set<String> names = new HashSet<String>();
 		for ( XMLAssociationOverride associationOverride : associationOverrides ) {
 			names.add( associationOverride.getName() );
 		}
 		Operation operation = new AssociationOverrideOperation( names, associationOverrides );
 		getAnnotationInstanceByTarget(
 				ASSOCIATION_OVERRIDES, target, new ContainerOperation( operation )
 		);
 		getAnnotationInstanceByTarget(
 				ASSOCIATION_OVERRIDE, target, operation
 		);
 
 
 		if ( associationOverrides.size() == 1 ) {
 			return parserAssociationOverride( associationOverrides.get( 0 ), target );
 		}
 		else {
 			AnnotationValue[] values = new AnnotationValue[associationOverrides.size()];
 			for ( int i = 0; i < values.length; i++ ) {
 				values[i] = MockHelper.nestedAnnotationValue(
 						"", parserAssociationOverride( associationOverrides.get( i ), null )
 				);
 			}
 			return create(
 					ASSOCIATION_OVERRIDES,
 					target,
 					new AnnotationValue[] { AnnotationValue.createArrayValue( "value", values ) }
 			);
 		}
 
 	}
 
 	protected AnnotationInstance parserCollectionTable(XMLCollectionTable collectionTable, AnnotationTarget target) {
 		if ( collectionTable == null ) {
 			return null;
 		}
 		DefaultConfigurationHelper.INSTANCE.applyDefaults(
 				new SchemaAware.CollectionTableSchemaAware( collectionTable ),
 				getDefaults()
 		);
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", collectionTable.getName(), annotationValueList );
 		MockHelper.stringValue( "catalog", collectionTable.getCatalog(), annotationValueList );
 		MockHelper.stringValue( "schema", collectionTable.getSchema(), annotationValueList );
 		nestedJoinColumnList( "joinColumns", collectionTable.getJoinColumn(), annotationValueList );
 		nestedUniqueConstraintList( "uniqueConstraints", collectionTable.getUniqueConstraint(), annotationValueList );
 		return create( COLLECTION_TABLE, target, annotationValueList );
 	}
 
 
 	protected AnnotationInstance parserJoinColumnList(List<XMLJoinColumn> joinColumnList, AnnotationTarget target) {
 		if ( MockHelper.isNotEmpty( joinColumnList ) ) {
 			if ( joinColumnList.size() == 1 ) {
 				return parserJoinColumn( joinColumnList.get( 0 ), target );
 			}
 			else {
 				AnnotationValue[] values = nestedJoinColumnList( "value", joinColumnList, null );
 				return create(
 						JOIN_COLUMNS,
 						target,
 						values
 				);
 			}
 		}
 		return null;
 
 	}
 
 	protected interface Operation {
 		boolean process(AnnotationInstance annotationInstance);
 	}
 
 	class ContainerOperation implements Operation {
 		private Operation child;
 
 		ContainerOperation(Operation child) {
 			this.child = child;
 		}
 
 		@Override
 		public boolean process(AnnotationInstance annotationInstance) {
 			AnnotationValue value = annotationInstance.value();
 			AnnotationInstance[] indexedAttributeOverridesValues = value.asNestedArray();
 			for ( AnnotationInstance ai : indexedAttributeOverridesValues ) {
 				child.process( ai );
 			}
 			return true;
 		}
 	}
 
 	class AttributeOverrideOperation implements Operation {
 		private Set<String> names;
 		private List<XMLAttributeOverride> attributeOverrides;
 
 		AttributeOverrideOperation(Set<String> names, List<XMLAttributeOverride> attributeOverrides) {
 			this.names = names;
 			this.attributeOverrides = attributeOverrides;
 		}
 
 		@Override
 		public boolean process(AnnotationInstance annotationInstance) {
 			String name = annotationInstance.value( "name" ).asString();
 			if ( !names.contains( name ) ) {
 				XMLAttributeOverrideProxy attributeOverride = new XMLAttributeOverrideProxy();
 				attributeOverride.setName( name );
 				attributeOverride.setColumnAnnotationValue( annotationInstance.value( "column" ) );
 				attributeOverrides.add( attributeOverride );
 			}
 			return false;
 		}
 	}
 
 
 	class AssociationOverrideOperation implements Operation {
 		private Set<String> names;
 		private List<XMLAssociationOverride> associationOverrides;
 
 		AssociationOverrideOperation(Set<String> names, List<XMLAssociationOverride> associationOverrides) {
 			this.names = names;
 			this.associationOverrides = associationOverrides;
 		}
 
 		@Override
 		public boolean process(AnnotationInstance annotationInstance) {
 			String name = annotationInstance.value( "name" ).asString();
 			if ( !names.contains( name ) ) {
 				XMLAssociationOverrideProxy associationOverride = new XMLAssociationOverrideProxy();
 				associationOverride.setName( name );
 				associationOverride.setJoinColumnsAnnotationValue( annotationInstance.value( "joinColumns" ) );
 				associationOverride.setJoinTableAnnotationValue( annotationInstance.value( "joinTable" ) );
 				associationOverrides.add( associationOverride );
 			}
 			return false;
 		}
 
 	}
 
 	class XMLAssociationOverrideProxy extends XMLAssociationOverride {
 		private AnnotationValue joinTableAnnotationValue;
 		private AnnotationValue joinColumnsAnnotationValue;
 
 		AnnotationValue getJoinColumnsAnnotationValue() {
 			return joinColumnsAnnotationValue;
 		}
 
 		void setJoinColumnsAnnotationValue(AnnotationValue joinColumnsAnnotationValue) {
 			this.joinColumnsAnnotationValue = joinColumnsAnnotationValue;
 		}
 
 		AnnotationValue getJoinTableAnnotationValue() {
 			return joinTableAnnotationValue;
 		}
 
 		void setJoinTableAnnotationValue(AnnotationValue joinTableAnnotationValue) {
 			this.joinTableAnnotationValue = joinTableAnnotationValue;
 		}
 	}
 
 	class XMLAttributeOverrideProxy extends XMLAttributeOverride {
 		private AnnotationValue columnAnnotationValue;
 
 		AnnotationValue getColumnAnnotationValue() {
 			return columnAnnotationValue;
 		}
 
 		void setColumnAnnotationValue(AnnotationValue columnAnnotationValue) {
 			this.columnAnnotationValue = columnAnnotationValue;
 		}
 	}
 
 	/**
 	 * Create simple AnnotationInstance with empty annotation value.
 	 * AnnotationInstance's target is get from #{getTarget}
 	 *
 	 * @param name annotation name
 	 *
 	 * @return annotationInstance which name is , target is from #{getTarget}, and has no annotation values.
 	 */
 	protected AnnotationInstance create(DotName name) {
 		return create( name, MockHelper.EMPTY_ANNOTATION_VALUE_ARRAY );
 	}
 
 	protected AnnotationInstance create(DotName name, AnnotationValue[] annotationValues) {
 		return create( name, getTarget(), annotationValues );
 
 	}
 
 	protected AnnotationInstance create(DotName name, List<AnnotationValue> annotationValueList) {
 		return create( name, getTarget(), annotationValueList );
 	}
 
 	/**
 	 * @return DotName as the key for the ClassInfo object this mocker created that being push to.
 	 */
 	abstract protected DotName getTargetName();
 
 	/**
 	 * @return Default Annotation Target for #{create} and #{mocker} methods.
 	 */
 	abstract protected AnnotationTarget getTarget();
 
 	protected AnnotationInstance push(AnnotationInstance annotationInstance) {
 		if ( annotationInstance != null && annotationInstance.target() != null ) {
 			indexBuilder.addAnnotationInstance( getTargetName(), annotationInstance );
 		}
 		return annotationInstance;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AttributesBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AttributesBuilder.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AttributesBuilder.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AttributesBuilder.java
index 4f1134324d..fb20f550c2 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AttributesBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/AttributesBuilder.java
@@ -1,109 +1,109 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.List;
 
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLAttributes;
 import org.hibernate.metamodel.source.annotation.xml.XMLBasic;
 import org.hibernate.metamodel.source.annotation.xml.XMLElementCollection;
 import org.hibernate.metamodel.source.annotation.xml.XMLEmbedded;
 import org.hibernate.metamodel.source.annotation.xml.XMLEmbeddedId;
 import org.hibernate.metamodel.source.annotation.xml.XMLId;
 import org.hibernate.metamodel.source.annotation.xml.XMLManyToMany;
 import org.hibernate.metamodel.source.annotation.xml.XMLManyToOne;
 import org.hibernate.metamodel.source.annotation.xml.XMLOneToMany;
 import org.hibernate.metamodel.source.annotation.xml.XMLOneToOne;
 import org.hibernate.metamodel.source.annotation.xml.XMLTransient;
 import org.hibernate.metamodel.source.annotation.xml.XMLVersion;
 
 /**
  * @author Strong Liu
  */
 class AttributesBuilder extends AbstractAttributesBuilder {
 	private XMLAttributes attributes;
 
 	AttributesBuilder(IndexBuilder indexBuilder, ClassInfo classInfo, XMLAccessType accessType, EntityMappingsMocker.Default defaults, XMLAttributes attributes) {
 		super( indexBuilder, classInfo, defaults );
 		this.attributes = attributes;
 	}
 
 	@Override
 	List<XMLBasic> getBasic() {
 		return attributes.getBasic();
 	}
 
 	@Override
 	List<XMLId> getId() {
 		return attributes.getId();
 	}
 
 	@Override
 	List<XMLTransient> getTransient() {
 		return attributes.getTransient();
 	}
 
 	@Override
 	List<XMLVersion> getVersion() {
 		return attributes.getVersion();
 	}
 
 	@Override
 	List<XMLElementCollection> getElementCollection() {
 		return attributes.getElementCollection();
 	}
 
 	@Override
 	List<XMLEmbedded> getEmbedded() {
 		return attributes.getEmbedded();
 	}
 
 	@Override
 	List<XMLManyToMany> getManyToMany() {
 		return attributes.getManyToMany();
 	}
 
 	@Override
 	List<XMLManyToOne> getManyToOne() {
 		return attributes.getManyToOne();
 	}
 
 	@Override
 	List<XMLOneToMany> getOneToMany() {
 		return attributes.getOneToMany();
 	}
 
 	@Override
 	List<XMLOneToOne> getOneToOne() {
 		return attributes.getOneToOne();
 	}
 
 	@Override
 	XMLEmbeddedId getEmbeddedId() {
 		return attributes.getEmbeddedId();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/BasicMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/BasicMocker.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/BasicMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/BasicMocker.java
index 35f4ed7655..0332d9eee8 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/BasicMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/BasicMocker.java
@@ -1,74 +1,74 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLBasic;
 
 /**
  * @author Strong Liu
  */
 class BasicMocker extends PropertyMocker {
 	private XMLBasic basic;
 
 	BasicMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, XMLBasic basic) {
 		super( indexBuilder, classInfo, defaults );
 		this.basic = basic;
 	}
 
 	@Override
 	protected String getFieldName() {
 		return basic.getName();
 	}
 
 	@Override
 	protected void processExtra() {
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.booleanValue( "optional", basic.isOptional(), annotationValueList );
 		MockHelper.enumValue( "fetch", FETCH_TYPE, basic.getFetch(), annotationValueList );
 		create( BASIC, annotationValueList );
 		parserColumn( basic.getColumn(), getTarget() );
 		parserEnumType( basic.getEnumerated(), getTarget() );
 		parserLob( basic.getLob(), getTarget() );
 		parserTemporalType( basic.getTemporal(), getTarget() );
 
 	}
 
 
 	@Override
 	protected XMLAccessType getAccessType() {
 		return basic.getAccess();
 	}
 
 	@Override
 	protected void setAccessType(XMLAccessType accessType) {
 		basic.setAccess( accessType );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/DefaultConfigurationHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/DefaultConfigurationHelper.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/DefaultConfigurationHelper.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/DefaultConfigurationHelper.java
index f055b78136..6f08c05be2 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/DefaultConfigurationHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/DefaultConfigurationHelper.java
@@ -1,389 +1,389 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.DotName;
 import org.jboss.logging.Logger;
 
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
-import org.hibernate.metamodel.binder.source.annotations.xml.filter.IndexedAnnotationFilter;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.annotations.xml.filter.IndexedAnnotationFilter;
 import org.hibernate.metamodel.source.annotation.xml.XMLEmbeddable;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntity;
 import org.hibernate.metamodel.source.annotation.xml.XMLMappedSuperclass;
 import org.hibernate.metamodel.source.annotation.xml.XMLTable;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
 
 /**
  * @author Strong Liu
  */
 class DefaultConfigurationHelper {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			DefaultConfigurationHelper.class.getName()
 	);
 	static final DefaultConfigurationHelper INSTANCE = new DefaultConfigurationHelper();
 	static final DotName[] GLOBAL_ANNOTATIONS = new DotName[] {
 			JPADotNames.SEQUENCE_GENERATOR,
 			JPADotNames.TABLE_GENERATOR,
 			JPADotNames.NAMED_QUERIES,
 			JPADotNames.NAMED_QUERY,
 			JPADotNames.NAMED_NATIVE_QUERIES,
 			JPADotNames.NAMED_NATIVE_QUERY,
 			JPADotNames.SQL_RESULT_SET_MAPPING,
 			JPADotNames.SQL_RESULT_SET_MAPPINGS
 	};
 	static final DotName[] SCHEMA_AWARE_ANNOTATIONS = new DotName[] {
 			JPADotNames.TABLE,
 			JPADotNames.JOIN_TABLE,
 			JPADotNames.COLLECTION_TABLE,
 			JPADotNames.SECONDARY_TABLE,
 			JPADotNames.SECONDARY_TABLES,
 			JPADotNames.TABLE_GENERATOR,
 			JPADotNames.SEQUENCE_GENERATOR
 	};
 	static final DotName[] ASSOCIATION_ANNOTATIONS = new DotName[] {
 			JPADotNames.ONE_TO_MANY, JPADotNames.ONE_TO_ONE, JPADotNames.MANY_TO_ONE, JPADotNames.MANY_TO_MANY
 	};
 
 	private DefaultConfigurationHelper() {
 	}
 
 	void applyDefaults(SchemaAware schemaAware, EntityMappingsMocker.Default defaults) {
 		if ( hasSchemaOrCatalogDefined( defaults ) ) {
 			if ( StringHelper.isEmpty( schemaAware.getSchema() ) ) {
 				schemaAware.setSchema( defaults.getSchema() );
 			}
 			if ( StringHelper.isEmpty( schemaAware.getCatalog() ) ) {
 				schemaAware.setCatalog( defaults.getCatalog() );
 			}
 		}
 	}
 
 	void applyDefaults(Map<DotName, List<AnnotationInstance>> annotationsMap, EntityMappingsMocker.Default defaults) {
 		if ( annotationsMap.isEmpty() || defaults == null ) {
 			return;
 		}
 		if ( hasSchemaOrCatalogDefined( defaults ) ) {
 			applyDefaultSchemaAndCatalog( annotationsMap, defaults );
 		}
 		if ( defaults.isCascadePersist()!=null && defaults.isCascadePersist() ) {
 			applyDefaultCascadePersist( annotationsMap );
 		}
 	}
 
 	void applyDefaults(XMLMappedSuperclass mappedSuperclass, EntityMappingsMocker.Default defaults) {
 		applyDefaultsToEntityObject( new MappedSuperClassEntityObject( mappedSuperclass ), defaults );
 	}
 
 	void applyDefaults(XMLEmbeddable embeddable, EntityMappingsMocker.Default defaults) {
 		applyDefaultsToEntityObject( new EmbeddableEntityObject( embeddable ), defaults );
 	}
 
 	void applyDefaults(XMLEntity entity, EntityMappingsMocker.Default defaults) {
 		mockTableIfNonExist( entity, defaults );
 		applyDefaultsToEntityObject( new EntityEntityObject( entity ), defaults );
 	}
 
 	private void applyDefaultsToEntityObject(EntityObject entityObject, EntityMappingsMocker.Default defaults) {
 		if ( defaults == null ) {
 			return;
 		}
 		String className = MockHelper.buildSafeClassName( entityObject.getClazz(), defaults.getPackageName() );
 		entityObject.setClazz( className );
 		if ( entityObject.isMetadataComplete() == null ) {
 			entityObject.setMetadataComplete( defaults.isMetadataComplete() );
 		}
 		LOG.debugf( "Adding XML overriding information for %s", className );
 	}
 
 	private boolean hasSchemaOrCatalogDefined(EntityMappingsMocker.Default defaults) {
 		return ( defaults != null ) && ( StringHelper.isNotEmpty( defaults.getSchema() ) || StringHelper.isNotEmpty(
 				defaults.getCatalog()
 		) );
 	}
 
 	private void applyDefaultCascadePersist(Map<DotName, List<AnnotationInstance>> annotationsMap) {
 		for ( DotName annName : ASSOCIATION_ANNOTATIONS ) {
 			if ( annotationsMap.containsKey( annName ) ) {
 				addCascadePersistIfNotExist( annName, annotationsMap );
 			}
 		}
 	}
 
 	private void applyDefaultSchemaAndCatalog(Map<DotName, List<AnnotationInstance>> annotationsMap, EntityMappingsMocker.Default defaults) {
 		for ( DotName annName : SCHEMA_AWARE_ANNOTATIONS ) {
 			mockTableIfNonExist( annotationsMap, annName );
 			if ( annotationsMap.containsKey( annName ) ) {
 				overrideSchemaCatalogByDefault( annName, annotationsMap, defaults );
 			}
 		}
 	}
 
 	private void mockTableIfNonExist(Map<DotName, List<AnnotationInstance>> annotationsMap, DotName annName) {
 		if ( annName == JPADotNames.TABLE && !annotationsMap.containsKey( JPADotNames.TABLE ) && annotationsMap
 				.containsKey( JPADotNames.ENTITY ) ) {
 			//if an entity doesn't have a @Table, we create one here
 			AnnotationInstance entity = JandexHelper.getSingleAnnotation( annotationsMap, JPADotNames.ENTITY );
 			AnnotationInstance table = MockHelper.create(
 					JPADotNames.TABLE, entity.target(), MockHelper.EMPTY_ANNOTATION_VALUE_ARRAY
 			);
 			List<AnnotationInstance> annotationInstanceList = new ArrayList<AnnotationInstance>( 1 );
 			annotationInstanceList.add( table );
 			annotationsMap.put( JPADotNames.TABLE, annotationInstanceList );
 		}
 	}
 
 	private void mockTableIfNonExist(XMLEntity entity, EntityMappingsMocker.Default defaults) {
 		if ( hasSchemaOrCatalogDefined( defaults ) ) {
 			XMLTable table = entity.getTable();
 			if ( table == null ) {
 				table = new XMLTable();
 				entity.setTable( table );
 			}
 		}
 	}
 
 	private void addCascadePersistIfNotExist(DotName annName, Map<DotName, List<AnnotationInstance>> indexedAnnotationMap) {
 		List<AnnotationInstance> annotationInstanceList = indexedAnnotationMap.get( annName );
 		if ( annotationInstanceList == null || annotationInstanceList.isEmpty() ) {
 			return;
 		}
 		List<AnnotationInstance> newAnnotationInstanceList = new ArrayList<AnnotationInstance>( annotationInstanceList.size() );
 		for ( AnnotationInstance annotationInstance : annotationInstanceList ) {
 			AnnotationValue cascadeValue = annotationInstance.value( "cascade" );
 			List<AnnotationValue> newAnnotationValueList = new ArrayList<AnnotationValue>();
 			newAnnotationValueList.addAll( annotationInstance.values() );
 			if ( cascadeValue == null ) {
 				AnnotationValue temp = AnnotationValue.createEnumValue( "", JPADotNames.CASCADE_TYPE, "PERSIST" );
 				cascadeValue = AnnotationValue.createArrayValue( "cascade", new AnnotationValue[] { temp } );
 			}
 			else {
 				newAnnotationValueList.remove( cascadeValue );
 				String[] cascadeTypes = cascadeValue.asEnumArray();
 				boolean hasPersistDefined = false;
 				for ( String type : cascadeTypes ) {
 					if ( "PERSIST".equals( type ) ) {
 						hasPersistDefined = true;
 						continue;
 					}
 				}
 				if ( hasPersistDefined ) {
 					newAnnotationInstanceList.add( annotationInstance );
 					continue;
 				}
 				String[] newCascadeTypes = new String[cascadeTypes.length + 1];
 				newCascadeTypes[0] = "PERSIST";
 				System.arraycopy( cascadeTypes, 0, newCascadeTypes, 1, cascadeTypes.length );
 				AnnotationValue[] cascades = new AnnotationValue[newCascadeTypes.length];
 				for ( int i = 0; i < newCascadeTypes.length; i++ ) {
 					cascades[i] = AnnotationValue.createEnumValue( "", JPADotNames.CASCADE_TYPE, newCascadeTypes[i] );
 				}
 				cascadeValue = AnnotationValue.createArrayValue( "cascade", cascades );
 
 			}
 			newAnnotationValueList.add( cascadeValue );
 
 			AnnotationInstance newAnnotationInstance = MockHelper.create(
 					annotationInstance.name(),
 					annotationInstance.target(),
 					MockHelper.toArray( newAnnotationValueList )
 			);
 			newAnnotationInstanceList.add( newAnnotationInstance );
 		}
 		indexedAnnotationMap.put( annName, newAnnotationInstanceList );
 	}
 
 	//@Table, @CollectionTable, @JoinTable, @SecondaryTable
 	private void overrideSchemaCatalogByDefault(DotName annName, Map<DotName, List<AnnotationInstance>> indexedAnnotationMap, EntityMappingsMocker.Default defaults) {
 		List<AnnotationInstance> annotationInstanceList = indexedAnnotationMap.get( annName );
 		if ( annotationInstanceList == null || annotationInstanceList.isEmpty() ) {
 			return;
 		}
 		List<AnnotationInstance> newAnnotationInstanceList = new ArrayList<AnnotationInstance>( annotationInstanceList.size() );
 		for ( AnnotationInstance annotationInstance : annotationInstanceList ) {
 			if ( annName.equals( IndexedAnnotationFilter.SECONDARY_TABLES ) ) {
 				AnnotationInstance[] secondaryTableAnnotationInstanceArray = annotationInstance.value().asNestedArray();
 				AnnotationValue[] newAnnotationValueArray = new AnnotationValue[secondaryTableAnnotationInstanceArray.length];
 				for ( int i = 0; i < secondaryTableAnnotationInstanceArray.length; i++ ) {
 					newAnnotationValueArray[i] = MockHelper.nestedAnnotationValue(
 							"", overrideSchemaCatalogByDefault(
 							secondaryTableAnnotationInstanceArray[i],
 							defaults
 					)
 					);
 				}
 				AnnotationInstance secondaryTablesAnnotationInstance = MockHelper.create(
 						annName,
 						annotationInstance.target(),
 						new AnnotationValue[] {
 								AnnotationValue.createArrayValue( "value", newAnnotationValueArray )
 						}
 				);
 				newAnnotationInstanceList.add( secondaryTablesAnnotationInstance );
 			}
 			else {
 				newAnnotationInstanceList.add( overrideSchemaCatalogByDefault( annotationInstance, defaults ) );
 			}
 		}
 		indexedAnnotationMap.put( annName, newAnnotationInstanceList );
 	}
 
 	private AnnotationInstance overrideSchemaCatalogByDefault(AnnotationInstance annotationInstance, EntityMappingsMocker.Default defaults) {
 		List<AnnotationValue> newAnnotationValueList = new ArrayList<AnnotationValue>();
 		newAnnotationValueList.addAll( annotationInstance.values() );
 		boolean schemaDefined = false;
 		boolean catalogDefined = false;
 		if ( annotationInstance.value( "schema" ) != null ) {
 			schemaDefined = true;
 		}
 		if ( annotationInstance.value( "catalog" ) != null ) {
 			catalogDefined = true;
 		}
 		if ( schemaDefined && catalogDefined ) {
 			return annotationInstance;
 		}
 		if ( !catalogDefined && StringHelper.isNotEmpty( defaults.getCatalog() ) ) {
 			newAnnotationValueList.add(
 					AnnotationValue.createStringValue(
 							"catalog", defaults.getCatalog()
 					)
 			);
 		}
 		if ( !schemaDefined && StringHelper.isNotEmpty( defaults.getSchema() ) ) {
 			newAnnotationValueList.add(
 					AnnotationValue.createStringValue(
 							"schema", defaults.getSchema()
 					)
 			);
 		}
 		return MockHelper.create(
 				annotationInstance.name(),
 				annotationInstance.target(),
 				MockHelper.toArray( newAnnotationValueList )
 		);
 	}
 
 	private static interface EntityObject {
 		String getClazz();
 
 		void setClazz(String className);
 
 		Boolean isMetadataComplete();
 
 		void setMetadataComplete(Boolean isMetadataComplete);
 	}
 
 	private static class EntityEntityObject implements EntityObject {
 		private XMLEntity entity;
 
 		private EntityEntityObject(XMLEntity entity) {
 			this.entity = entity;
 		}
 
 		@Override
 		public String getClazz() {
 			return entity.getClazz();
 		}
 
 		@Override
 		public void setClazz(String className) {
 			entity.setClazz( className );
 		}
 
 		@Override
 		public Boolean isMetadataComplete() {
 			return entity.isMetadataComplete();
 		}
 
 		@Override
 		public void setMetadataComplete(Boolean isMetadataComplete) {
 			entity.setMetadataComplete( isMetadataComplete );
 		}
 	}
 
 	private static class EmbeddableEntityObject implements EntityObject {
 		private XMLEmbeddable entity;
 
 		private EmbeddableEntityObject(XMLEmbeddable entity) {
 			this.entity = entity;
 		}
 
 		@Override
 		public String getClazz() {
 			return entity.getClazz();
 		}
 
 		@Override
 		public void setClazz(String className) {
 			entity.setClazz( className );
 		}
 
 		@Override
 		public Boolean isMetadataComplete() {
 			return entity.isMetadataComplete();
 		}
 
 		@Override
 		public void setMetadataComplete(Boolean isMetadataComplete) {
 			entity.setMetadataComplete( isMetadataComplete );
 		}
 	}
 
 	private static class MappedSuperClassEntityObject implements EntityObject {
 		private XMLMappedSuperclass entity;
 
 		private MappedSuperClassEntityObject(XMLMappedSuperclass entity) {
 			this.entity = entity;
 		}
 
 		@Override
 		public String getClazz() {
 			return entity.getClazz();
 		}
 
 		@Override
 		public void setClazz(String className) {
 			entity.setClazz( className );
 		}
 
 		@Override
 		public Boolean isMetadataComplete() {
 			return entity.isMetadataComplete();
 		}
 
 		@Override
 		public void setMetadataComplete(Boolean isMetadataComplete) {
 			entity.setMetadataComplete( isMetadataComplete );
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ElementCollectionMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ElementCollectionMocker.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ElementCollectionMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ElementCollectionMocker.java
index 35427bb404..95540ba0ee 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ElementCollectionMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ElementCollectionMocker.java
@@ -1,90 +1,90 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLElementCollection;
 
 /**
  * @author Strong Liu
  */
 class ElementCollectionMocker extends PropertyMocker {
 	private XMLElementCollection elementCollection;
 
 	ElementCollectionMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, XMLElementCollection elementCollection) {
 		super( indexBuilder, classInfo, defaults );
 		this.elementCollection = elementCollection;
 	}
 
 	@Override
 	protected void processExtra() {
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.classValue(
 				"targetClass",
 				elementCollection.getTargetClass(),
 				annotationValueList,
 				indexBuilder.getServiceRegistry()
 		);
 		MockHelper.enumValue( "fetch", FETCH_TYPE, elementCollection.getFetch(), annotationValueList );
 		create( ELEMENT_COLLECTION, annotationValueList );
 		parserLob( elementCollection.getLob(), getTarget() );
 		parserEnumType( elementCollection.getEnumerated(), getTarget() );
 		parserColumn( elementCollection.getColumn(), getTarget() );
 		parserTemporalType( elementCollection.getTemporal(), getTarget() );
 		parserCollectionTable( elementCollection.getCollectionTable(), getTarget() );
 		parserAssociationOverrides( elementCollection.getAssociationOverride(), getTarget() );
 		parserAttributeOverrides( elementCollection.getAttributeOverride(), getTarget() );
 		if ( elementCollection.getOrderBy() != null ) {
 			create( ORDER_BY, MockHelper.stringValueArray( "value", elementCollection.getOrderBy() ) );
 		}
 		parserAttributeOverrides( elementCollection.getMapKeyAttributeOverride(), getTarget() );
 		parserMapKeyJoinColumnList( elementCollection.getMapKeyJoinColumn(), getTarget() );
 		parserMapKey( elementCollection.getMapKey(), getTarget() );
 		parserMapKeyColumn( elementCollection.getMapKeyColumn(), getTarget() );
 		parserMapKeyClass( elementCollection.getMapKeyClass(), getTarget() );
 		parserMapKeyEnumerated( elementCollection.getMapKeyEnumerated(), getTarget() );
 		parserMapKeyTemporal( elementCollection.getMapKeyTemporal(), getTarget() );
 	}
 
 	@Override
 	protected String getFieldName() {
 		return elementCollection.getName();
 	}
 
 	@Override
 	protected XMLAccessType getAccessType() {
 		return elementCollection.getAccess();
 	}
 
 	@Override
 	protected void setAccessType(XMLAccessType accessType) {
 		elementCollection.setAccess( accessType );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EmbeddableAttributesBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddableAttributesBuilder.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EmbeddableAttributesBuilder.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddableAttributesBuilder.java
index f0035664aa..7b8274448e 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EmbeddableAttributesBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddableAttributesBuilder.java
@@ -1,110 +1,110 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.Collections;
 import java.util.List;
 
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLBasic;
 import org.hibernate.metamodel.source.annotation.xml.XMLElementCollection;
 import org.hibernate.metamodel.source.annotation.xml.XMLEmbeddableAttributes;
 import org.hibernate.metamodel.source.annotation.xml.XMLEmbedded;
 import org.hibernate.metamodel.source.annotation.xml.XMLEmbeddedId;
 import org.hibernate.metamodel.source.annotation.xml.XMLId;
 import org.hibernate.metamodel.source.annotation.xml.XMLManyToMany;
 import org.hibernate.metamodel.source.annotation.xml.XMLManyToOne;
 import org.hibernate.metamodel.source.annotation.xml.XMLOneToMany;
 import org.hibernate.metamodel.source.annotation.xml.XMLOneToOne;
 import org.hibernate.metamodel.source.annotation.xml.XMLTransient;
 import org.hibernate.metamodel.source.annotation.xml.XMLVersion;
 
 /**
  * @author Strong Liu
  */
 class EmbeddableAttributesBuilder extends AbstractAttributesBuilder {
 	private XMLEmbeddableAttributes attributes;
 
 	EmbeddableAttributesBuilder(IndexBuilder indexBuilder, ClassInfo classInfo, XMLAccessType accessType, EntityMappingsMocker.Default defaults, XMLEmbeddableAttributes embeddableAttributes) {
 		super( indexBuilder, classInfo, defaults );
 		this.attributes = embeddableAttributes;
 	}
 
 	@Override
 	List<XMLBasic> getBasic() {
 		return attributes.getBasic();
 	}
 
 	@Override
 	List<XMLId> getId() {
 		return Collections.emptyList();
 	}
 
 	@Override
 	List<XMLTransient> getTransient() {
 		return attributes.getTransient();
 	}
 
 	@Override
 	List<XMLVersion> getVersion() {
 		return Collections.emptyList();
 	}
 
 	@Override
 	List<XMLElementCollection> getElementCollection() {
 		return attributes.getElementCollection();
 	}
 
 	@Override
 	List<XMLEmbedded> getEmbedded() {
 		return attributes.getEmbedded();
 	}
 
 	@Override
 	List<XMLManyToMany> getManyToMany() {
 		return attributes.getManyToMany();
 	}
 
 	@Override
 	List<XMLManyToOne> getManyToOne() {
 		return attributes.getManyToOne();
 	}
 
 	@Override
 	List<XMLOneToMany> getOneToMany() {
 		return attributes.getOneToMany();
 	}
 
 	@Override
 	List<XMLOneToOne> getOneToOne() {
 		return attributes.getOneToOne();
 	}
 
 	@Override
 	XMLEmbeddedId getEmbeddedId() {
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EmbeddableMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddableMocker.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EmbeddableMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddableMocker.java
index 327eeef3f4..6a243090e8 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EmbeddableMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddableMocker.java
@@ -1,153 +1,153 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLAttributes;
 import org.hibernate.metamodel.source.annotation.xml.XMLEmbeddable;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntityListeners;
 import org.hibernate.metamodel.source.annotation.xml.XMLIdClass;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostLoad;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostPersist;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostRemove;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostUpdate;
 import org.hibernate.metamodel.source.annotation.xml.XMLPrePersist;
 import org.hibernate.metamodel.source.annotation.xml.XMLPreRemove;
 import org.hibernate.metamodel.source.annotation.xml.XMLPreUpdate;
 
 /**
  * Mock <embeddable> to {@link javax.persistence.Embeddable @Embeddable}
  *
  * @author Strong Liu
  */
 class EmbeddableMocker extends AbstractEntityObjectMocker {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			EmbeddableMocker.class.getName()
 	);
 	private XMLEmbeddable embeddable;
 
 	EmbeddableMocker(IndexBuilder indexBuilder, XMLEmbeddable embeddable, EntityMappingsMocker.Default defaults) {
 		super( indexBuilder, defaults );
 		this.embeddable = embeddable;
 	}
 
 	@Override
 	protected AbstractAttributesBuilder getAttributesBuilder() {
 		if ( attributesBuilder == null ) {
 			attributesBuilder = new EmbeddableAttributesBuilder(
 					indexBuilder, classInfo, getAccessType(), getDefaults(), embeddable.getAttributes()
 			);
 		}
 		return attributesBuilder;
 	}
 
 	@Override
 	protected void processExtra() {
 		create( EMBEDDABLE );
 	}
 
 	@Override
 	protected void applyDefaults() {
 		DefaultConfigurationHelper.INSTANCE.applyDefaults( embeddable, getDefaults() );
 	}
 
 	@Override
 	protected boolean isMetadataComplete() {
 		return embeddable.isMetadataComplete() != null && embeddable.isMetadataComplete();
 	}
 
 	@Override
 	protected boolean isExcludeDefaultListeners() {
 		return false;
 	}
 
 	@Override
 	protected boolean isExcludeSuperclassListeners() {
 		return false;
 	}
 
 	@Override
 	protected XMLIdClass getIdClass() {
 		return null;
 	}
 
 	@Override
 	protected XMLEntityListeners getEntityListeners() {
 		return null;
 	}
 
 	@Override
 	protected XMLAccessType getAccessType() {
 		return embeddable.getAccess();
 	}
 
 	@Override
 	protected String getClassName() {
 		return embeddable.getClazz();
 	}
 
 	@Override
 	protected XMLPrePersist getPrePersist() {
 		return null;
 	}
 
 	@Override
 	protected XMLPreRemove getPreRemove() {
 		return null;
 	}
 
 	@Override
 	protected XMLPreUpdate getPreUpdate() {
 		return null;
 	}
 
 	@Override
 	protected XMLPostPersist getPostPersist() {
 		return null;
 	}
 
 	@Override
 	protected XMLPostUpdate getPostUpdate() {
 		return null;
 	}
 
 	@Override
 	protected XMLPostRemove getPostRemove() {
 		return null;
 	}
 
 	@Override
 	protected XMLPostLoad getPostLoad() {
 		return null;
 	}
 
 	@Override
 	protected XMLAttributes getAttributes() {
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EmbeddedIdMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddedIdMocker.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EmbeddedIdMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddedIdMocker.java
index 7b71558ad2..f9a274ce9b 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EmbeddedIdMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddedIdMocker.java
@@ -1,61 +1,61 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLEmbeddedId;
 
 /**
  * @author Strong Liu
  */
 class EmbeddedIdMocker extends PropertyMocker {
 	private XMLEmbeddedId embeddedId;
 
 	EmbeddedIdMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, XMLEmbeddedId embeddedId) {
 		super( indexBuilder, classInfo, defaults );
 		this.embeddedId = embeddedId;
 	}
 
 	@Override
 	protected String getFieldName() {
 		return embeddedId.getName();
 	}
 
 	@Override
 	protected void processExtra() {
 		create( EMBEDDED_ID );
 	}
 
 	@Override
 	protected XMLAccessType getAccessType() {
 		return embeddedId.getAccess();
 	}
 
 	@Override
 	protected void setAccessType(XMLAccessType accessType) {
 		embeddedId.setAccess( accessType );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EmbeddedMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddedMocker.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EmbeddedMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddedMocker.java
index 1c926dbe4d..0b3e061c41 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EmbeddedMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EmbeddedMocker.java
@@ -1,64 +1,64 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLEmbedded;
 
 /**
  * @author Strong Liu
  */
 class EmbeddedMocker extends PropertyMocker {
 	private XMLEmbedded embedded;
 
 	EmbeddedMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, XMLEmbedded embedded) {
 		super( indexBuilder, classInfo, defaults );
 		this.embedded = embedded;
 	}
 
 	@Override
 	protected void processExtra() {
 		create( EMBEDDED );
 		parserAttributeOverrides( embedded.getAttributeOverride(), getTarget() );
 		parserAssociationOverrides( embedded.getAssociationOverride(), getTarget() );
 
 	}
 
 	@Override
 	protected String getFieldName() {
 		return embedded.getName();
 	}
 
 	@Override
 	protected XMLAccessType getAccessType() {
 		return embedded.getAccess();
 	}
 
 	@Override
 	protected void setAccessType(XMLAccessType accessType) {
 		embedded.setAccess( accessType );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EntityMappingsMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityMappingsMocker.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EntityMappingsMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityMappingsMocker.java
index 55efe77f87..60a9159395 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EntityMappingsMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityMappingsMocker.java
@@ -1,243 +1,243 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.jandex.Index;
 import org.jboss.logging.Logger;
 
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLEmbeddable;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntity;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntityMappings;
 import org.hibernate.metamodel.source.annotation.xml.XMLMappedSuperclass;
 import org.hibernate.metamodel.source.annotation.xml.XMLPersistenceUnitDefaults;
 import org.hibernate.metamodel.source.annotation.xml.XMLPersistenceUnitMetadata;
 import org.hibernate.service.ServiceRegistry;
 
 /**
  * Parse all {@link XMLEntityMappings} generated from orm.xml.
  *
  * @author Strong Liu
  */
 public class EntityMappingsMocker {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			EntityMappingsMocker.class.getName()
 	);
 	private final List<XMLEntityMappings> entityMappingsList;
 	/**
 	 * Default configuration defined in Persistence Metadata Unit, one or zero per Persistence Unit.
 	 */
 	private Default globalDefaults;
 	private final IndexBuilder indexBuilder;
 	private final GlobalAnnotations globalAnnotations;
 
 	public EntityMappingsMocker(List<XMLEntityMappings> entityMappingsList, Index index, ServiceRegistry serviceRegistry) {
 		this.entityMappingsList = entityMappingsList;
 		this.indexBuilder = new IndexBuilder( index, serviceRegistry );
 		this.globalAnnotations = new GlobalAnnotations();
 	}
 
 	/**
 	 * Create new {@link Index} with mocking JPA annotations from {@link XMLEntityMappings} and merge them with existing {@link Index}
 	 *
 	 * @return new {@link Index}
 	 */
 	public Index mockNewIndex() {
 		processPersistenceUnitMetadata( entityMappingsList );
 		processEntityMappings( entityMappingsList );
 		processGlobalAnnotations();
 		return indexBuilder.build( globalDefaults );
 	}
 
 	/**
 	 * processing PersistenceUnitMetadata, there should be only one PersistenceUnitMetadata in all mapping xml files.
 	 */
 	private void processPersistenceUnitMetadata(List<XMLEntityMappings> entityMappingsList) {
 		for ( XMLEntityMappings entityMappings : entityMappingsList ) {
 			//we have to iterate entityMappingsList first to find persistence-unit-metadata
 			XMLPersistenceUnitMetadata pum = entityMappings.getPersistenceUnitMetadata();
 			if ( globalDefaults != null ) {
 				LOG.duplicateMetadata();
 				return;
 			}
 			if ( pum == null ) {
 				continue;
 			}
 			globalDefaults = new Default();
 			if ( pum.getXmlMappingMetadataComplete() != null ) {
 				globalDefaults.setMetadataComplete( true );
 				indexBuilder.mappingMetadataComplete();
 			}
 			XMLPersistenceUnitDefaults pud = pum.getPersistenceUnitDefaults();
 			if ( pud == null ) {
 				return;
 			}
 			globalDefaults.setSchema( pud.getSchema() );
 			globalDefaults.setCatalog( pud.getCatalog() );
 			//globalDefaults.setAccess( pud.getAccess() );
 			globalDefaults.setCascadePersist( pud.getCascadePersist() != null );
 			new PersistenceMetadataMocker( indexBuilder, pud ).process();
 		}
 	}
 
 
 	private void processEntityMappings(List<XMLEntityMappings> entityMappingsList) {
 		List<AbstractEntityObjectMocker> mockerList = new ArrayList<AbstractEntityObjectMocker>();
 		for ( XMLEntityMappings entityMappings : entityMappingsList ) {
 			final Default defaults = getEntityMappingsDefaults( entityMappings );
 			globalAnnotations.collectGlobalMappings( entityMappings, defaults );
 			for ( XMLMappedSuperclass mappedSuperclass : entityMappings.getMappedSuperclass() ) {
 				AbstractEntityObjectMocker mocker =
 						new MappedSuperclassMocker( indexBuilder, mappedSuperclass, defaults );
 				mockerList.add( mocker );
 				mocker.preProcess();
 			}
 			for ( XMLEmbeddable embeddable : entityMappings.getEmbeddable() ) {
 				AbstractEntityObjectMocker mocker =
 						new EmbeddableMocker( indexBuilder, embeddable, defaults );
 				mockerList.add( mocker );
 				mocker.preProcess();
 			}
 			for ( XMLEntity entity : entityMappings.getEntity() ) {
 				globalAnnotations.collectGlobalMappings( entity, defaults );
 				AbstractEntityObjectMocker mocker =
 						new EntityMocker( indexBuilder, entity, defaults );
 				mockerList.add( mocker );
 				mocker.preProcess();
 			}
 		}
 		for ( AbstractEntityObjectMocker mocker : mockerList ) {
 			mocker.process();
 		}
 	}
 
 	private void processGlobalAnnotations() {
 		if ( globalAnnotations.hasGlobalConfiguration() ) {
 			indexBuilder.collectGlobalConfigurationFromIndex( globalAnnotations );
 			new GlobalAnnotationMocker(
 					indexBuilder, globalAnnotations
 			).process();
 		}
 	}
 
 	private Default getEntityMappingsDefaults(XMLEntityMappings entityMappings) {
 		Default entityMappingDefault = new Default();
 		entityMappingDefault.setPackageName( entityMappings.getPackage() );
 		entityMappingDefault.setSchema( entityMappings.getSchema() );
 		entityMappingDefault.setCatalog( entityMappings.getCatalog() );
 		entityMappingDefault.setAccess( entityMappings.getAccess() );
 		final Default defaults = new Default();
 		defaults.override( globalDefaults );
 		defaults.override( entityMappingDefault );
 		return defaults;
 	}
 
 
 	public static class Default implements Serializable {
 		private XMLAccessType access;
 		private String packageName;
 		private String schema;
 		private String catalog;
 		private Boolean metadataComplete;
 		private Boolean cascadePersist;
 
 		public XMLAccessType getAccess() {
 			return access;
 		}
 
 		void setAccess(XMLAccessType access) {
 			this.access = access;
 		}
 
 		public String getCatalog() {
 			return catalog;
 		}
 
 		void setCatalog(String catalog) {
 			this.catalog = catalog;
 		}
 
 		public String getPackageName() {
 			return packageName;
 		}
 
 		void setPackageName(String packageName) {
 			this.packageName = packageName;
 		}
 
 		public String getSchema() {
 			return schema;
 		}
 
 		void setSchema(String schema) {
 			this.schema = schema;
 		}
 
 		public Boolean isMetadataComplete() {
 			return metadataComplete;
 		}
 
 		void setMetadataComplete(Boolean metadataComplete) {
 			this.metadataComplete = metadataComplete;
 		}
 
 		public Boolean isCascadePersist() {
 			return cascadePersist;
 		}
 
 		void setCascadePersist(Boolean cascadePersist) {
 			this.cascadePersist = cascadePersist;
 		}
 
 		void override(Default globalDefault) {
 			if ( globalDefault != null ) {
 				if ( globalDefault.getAccess() != null ) {
 					access = globalDefault.getAccess();
 				}
 				if ( globalDefault.getPackageName() != null ) {
 					packageName = globalDefault.getPackageName();
 				}
 				if ( globalDefault.getSchema() != null ) {
 					schema = globalDefault.getSchema();
 				}
 				if ( globalDefault.getCatalog() != null ) {
 					catalog = globalDefault.getCatalog();
 				}
 				if ( globalDefault.isCascadePersist() != null ) {
 					cascadePersist = globalDefault.isCascadePersist();
 				}
 				if ( globalDefault.isMetadataComplete() != null ) {
 					metadataComplete = globalDefault.isMetadataComplete();
 				}
 
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EntityMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityMocker.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EntityMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityMocker.java
index a6ea979bc9..0b6f78e526 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EntityMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityMocker.java
@@ -1,326 +1,326 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import javax.persistence.AccessType;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.logging.Logger;
 
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLAttributes;
 import org.hibernate.metamodel.source.annotation.xml.XMLDiscriminatorColumn;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntity;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntityListeners;
 import org.hibernate.metamodel.source.annotation.xml.XMLIdClass;
 import org.hibernate.metamodel.source.annotation.xml.XMLInheritance;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostLoad;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostPersist;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostRemove;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostUpdate;
 import org.hibernate.metamodel.source.annotation.xml.XMLPrePersist;
 import org.hibernate.metamodel.source.annotation.xml.XMLPreRemove;
 import org.hibernate.metamodel.source.annotation.xml.XMLPreUpdate;
 import org.hibernate.metamodel.source.annotation.xml.XMLSecondaryTable;
 import org.hibernate.metamodel.source.annotation.xml.XMLTable;
 
 /**
  * Mock <entity> to {@link javax.persistence.Entity @Entity}
  *
  * @author Strong Liu
  */
 class EntityMocker extends AbstractEntityObjectMocker {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			EntityMocker.class.getName()
 	);
 	private XMLEntity entity;
 
 	EntityMocker(IndexBuilder indexBuilder, XMLEntity entity, EntityMappingsMocker.Default defaults) {
 		super( indexBuilder, defaults );
 		this.entity = entity;
 	}
 
 	@Override
 	protected String getClassName() {
 		return entity.getClazz();
 	}
 
 	@Override
 	protected void processExtra() {
 		//@Entity
 		create( ENTITY, MockHelper.stringValueArray( "name", entity.getName() ) );
 
 
 		if ( entity.isCacheable() != null ) {
 			//@Cacheable
 			create(
 					CACHEABLE,
 					MockHelper.booleanValueArray( "value", entity.isCacheable() )
 
 			);
 		}
 		if ( StringHelper.isNotEmpty( entity.getDiscriminatorValue() ) ) {
 			//@DiscriminatorValue
 			create(
 					DISCRIMINATOR_VALUE,
 					MockHelper.stringValueArray( "value", entity.getDiscriminatorValue() )
 
 			);
 		}
 		//@Table
 		parserTable( entity.getTable() );
 		parserInheritance( entity.getInheritance() );
 		parserDiscriminatorColumn( entity.getDiscriminatorColumn() );
 		parserAttributeOverrides( entity.getAttributeOverride(), getTarget() );
 		parserAssociationOverrides( entity.getAssociationOverride(), getTarget() );
 		parserPrimaryKeyJoinColumnList( entity.getPrimaryKeyJoinColumn(), getTarget() );
 		parserSecondaryTableList( entity.getSecondaryTable(), getTarget() );
 
 	}
 
 	//@Table  (entity only)
 	private AnnotationInstance parserTable(XMLTable table) {
 		if ( table == null ) {
 			return null;
 		}
 		DefaultConfigurationHelper.INSTANCE.applyDefaults(
 				new SchemaAware.TableSchemaAware( table ),
 				getDefaults()
 		);
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", table.getName(), annotationValueList );
 		MockHelper.stringValue( "catalog", table.getCatalog(), annotationValueList );
 		MockHelper.stringValue( "schema", table.getSchema(), annotationValueList );
 		nestedUniqueConstraintList( "uniqueConstraints", table.getUniqueConstraint(), annotationValueList );
 		return create( TABLE, annotationValueList );
 	}
 
 	protected AccessType getDefaultAccess() {
 		if ( entity.getAccess() != null ) {
 			return AccessType.valueOf( entity.getAccess().value() );
 		}
 
 		return null;
 	}
 
 	protected AccessType getAccessFromIndex(DotName className) {
 		//todo 这里实际上不应该从getIndexedAnnotations获取，而是应该先处理完所有的entity，mapped-superclass，先不处理attributes呢
 		//然后获取这个
 		Map<DotName, List<AnnotationInstance>> indexedAnnotations = indexBuilder.getIndexedAnnotations( className );
 		List<AnnotationInstance> accessAnnotationInstances = indexedAnnotations.get( ACCESS );
 		if ( MockHelper.isNotEmpty( accessAnnotationInstances ) ) {
 			for ( AnnotationInstance annotationInstance : accessAnnotationInstances ) {
 				if ( annotationInstance.target() != null && annotationInstance.target() instanceof ClassInfo ) {
 					ClassInfo ci = (ClassInfo) ( annotationInstance.target() );
 					if ( className.equals( ci.name() ) ) {
 						//todo does ci need to have @Entity or @MappedSuperClass ??
 						return AccessType.valueOf( annotationInstance.value().asEnum() );
 					}
 				}
 			}
 		}
 		return null;
 	}
 
 	@Override
 	protected void applyDefaults() {
 		DefaultConfigurationHelper.INSTANCE.applyDefaults( entity, getDefaults() );
 	}
 
 	@Override
 	protected XMLPrePersist getPrePersist() {
 		return entity.getPrePersist();
 	}
 
 	@Override
 	protected XMLPreRemove getPreRemove() {
 		return entity.getPreRemove();
 	}
 
 	@Override
 	protected XMLPreUpdate getPreUpdate() {
 		return entity.getPreUpdate();
 	}
 
 	@Override
 	protected XMLPostPersist getPostPersist() {
 		return entity.getPostPersist();
 	}
 
 	@Override
 	protected XMLPostUpdate getPostUpdate() {
 		return entity.getPostUpdate();
 	}
 
 	@Override
 	protected XMLPostRemove getPostRemove() {
 		return entity.getPostRemove();
 	}
 
 	@Override
 	protected XMLPostLoad getPostLoad() {
 		return entity.getPostLoad();
 	}
 
 	@Override
 	protected XMLAttributes getAttributes() {
 		return entity.getAttributes();
 	}
 
 	@Override
 	protected boolean isMetadataComplete() {
 		return entity.isMetadataComplete() != null && entity.isMetadataComplete();
 	}
 
 	@Override
 	protected boolean isExcludeDefaultListeners() {
 		return entity.getExcludeDefaultListeners() != null;
 	}
 
 	@Override
 	protected boolean isExcludeSuperclassListeners() {
 		return entity.getExcludeSuperclassListeners() != null;
 	}
 
 	@Override
 	protected XMLIdClass getIdClass() {
 		return entity.getIdClass();
 	}
 
 	@Override
 	protected XMLEntityListeners getEntityListeners() {
 		return entity.getEntityListeners();
 	}
 
 	@Override
 	protected XMLAccessType getAccessType() {
 		return entity.getAccess();
 	}
 
 	//@Inheritance
 	protected AnnotationInstance parserInheritance(XMLInheritance inheritance) {
 		if ( inheritance == null ) {
 			return null;
 		}
 		return
 				create(
 						INHERITANCE,
 						MockHelper.enumValueArray( "strategy", INHERITANCE_TYPE, inheritance.getStrategy() )
 
 				);
 	}
 
 	//@DiscriminatorColumn
 	protected AnnotationInstance parserDiscriminatorColumn(XMLDiscriminatorColumn discriminatorColumn) {
 		if ( discriminatorColumn == null ) {
 			return null;
 		}
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", discriminatorColumn.getName(), annotationValueList );
 		MockHelper.stringValue(
 				"columnDefinition", discriminatorColumn.getColumnDefinition(), annotationValueList
 		);
 		MockHelper.integerValue( "length", discriminatorColumn.getLength(), annotationValueList );
 		MockHelper.enumValue(
 				"discriminatorType", DISCRIMINATOR_TYPE, discriminatorColumn.getDiscriminatorType(), annotationValueList
 		);
 		return
 				create(
 						DISCRIMINATOR_COLUMN, annotationValueList
 
 				);
 
 	}
 
 	//@SecondaryTable
 	protected AnnotationInstance parserSecondaryTable(XMLSecondaryTable secondaryTable, AnnotationTarget target) {
 		if ( secondaryTable == null ) {
 			return null;
 		}
 		DefaultConfigurationHelper.INSTANCE.applyDefaults(
 				new SchemaAware.SecondaryTableSchemaAware( secondaryTable ),
 				getDefaults()
 		);
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", secondaryTable.getName(), annotationValueList );
 		MockHelper.stringValue( "catalog", secondaryTable.getCatalog(), annotationValueList );
 		MockHelper.stringValue( "schema", secondaryTable.getSchema(), annotationValueList );
 		nestedPrimaryKeyJoinColumnList(
 				"pkJoinColumns", secondaryTable.getPrimaryKeyJoinColumn(), annotationValueList
 		);
 		nestedUniqueConstraintList(
 				"uniqueConstraints", secondaryTable.getUniqueConstraint(), annotationValueList
 		);
 		return
 				create(
 						SECONDARY_TABLE, target, annotationValueList
 				);
 	}
 
 
 	protected AnnotationInstance parserSecondaryTableList(List<XMLSecondaryTable> primaryKeyJoinColumnList, AnnotationTarget target) {
 		if ( MockHelper.isNotEmpty( primaryKeyJoinColumnList ) ) {
 			if ( primaryKeyJoinColumnList.size() == 1 ) {
 				return parserSecondaryTable( primaryKeyJoinColumnList.get( 0 ), target );
 			}
 			else {
 				return create(
 						SECONDARY_TABLES,
 						target,
 						nestedSecondaryTableList( "value", primaryKeyJoinColumnList, null )
 				);
 			}
 		}
 		return null;
 
 	}
 
 	protected AnnotationValue[] nestedSecondaryTableList(String name, List<XMLSecondaryTable> secondaryTableList, List<AnnotationValue> annotationValueList) {
 		if ( MockHelper.isNotEmpty( secondaryTableList ) ) {
 			AnnotationValue[] values = new AnnotationValue[secondaryTableList.size()];
 			for ( int i = 0; i < secondaryTableList.size(); i++ ) {
 				AnnotationInstance annotationInstance = parserSecondaryTable( secondaryTableList.get( i ), null );
 				values[i] = MockHelper.nestedAnnotationValue(
 						"", annotationInstance
 				);
 			}
 			MockHelper.addToCollectionIfNotNull(
 					annotationValueList, AnnotationValue.createArrayValue( name, values )
 			);
 			return values;
 		}
 		return MockHelper.EMPTY_ANNOTATION_VALUE_ARRAY;
 
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/GlobalAnnotationMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/GlobalAnnotationMocker.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/GlobalAnnotationMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/GlobalAnnotationMocker.java
index 9fec2da693..1723db0748 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/GlobalAnnotationMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/GlobalAnnotationMocker.java
@@ -1,331 +1,331 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationValue;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLColumnResult;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntityResult;
 import org.hibernate.metamodel.source.annotation.xml.XMLFieldResult;
 import org.hibernate.metamodel.source.annotation.xml.XMLNamedNativeQuery;
 import org.hibernate.metamodel.source.annotation.xml.XMLNamedQuery;
 import org.hibernate.metamodel.source.annotation.xml.XMLQueryHint;
 import org.hibernate.metamodel.source.annotation.xml.XMLSequenceGenerator;
 import org.hibernate.metamodel.source.annotation.xml.XMLSqlResultSetMapping;
 import org.hibernate.metamodel.source.annotation.xml.XMLTableGenerator;
 
 /**
  * @author Strong Liu
  */
 class GlobalAnnotationMocker extends AbstractMocker {
 	private GlobalAnnotations globalAnnotations;
 
 	GlobalAnnotationMocker(IndexBuilder indexBuilder, GlobalAnnotations globalAnnotations) {
 		super( indexBuilder );
 		this.globalAnnotations = globalAnnotations;
 	}
 
 
 	void process() {
 		if ( !globalAnnotations.getTableGeneratorMap().isEmpty() ) {
 			for ( XMLTableGenerator generator : globalAnnotations.getTableGeneratorMap().values() ) {
 				parserTableGenerator( generator );
 			}
 		}
 		if ( !globalAnnotations.getSequenceGeneratorMap().isEmpty() ) {
 			for ( XMLSequenceGenerator generator : globalAnnotations.getSequenceGeneratorMap().values() ) {
 				parserSequenceGenerator( generator );
 			}
 		}
 		if ( !globalAnnotations.getNamedQueryMap().isEmpty() ) {
 			Collection<XMLNamedQuery> namedQueries = globalAnnotations.getNamedQueryMap().values();
 			if ( namedQueries.size() > 1 ) {
 				parserNamedQueries( namedQueries );
 			}
 			else {
 				parserNamedQuery( namedQueries.iterator().next() );
 			}
 		}
 		if ( !globalAnnotations.getNamedNativeQueryMap().isEmpty() ) {
 			Collection<XMLNamedNativeQuery> namedQueries = globalAnnotations.getNamedNativeQueryMap().values();
 			if ( namedQueries.size() > 1 ) {
 				parserNamedNativeQueries( namedQueries );
 			}
 			else {
 				parserNamedNativeQuery( namedQueries.iterator().next() );
 			}
 		}
 		if ( !globalAnnotations.getSqlResultSetMappingMap().isEmpty() ) {
 			parserSqlResultSetMappings( globalAnnotations.getSqlResultSetMappingMap().values() );
 		}
 		indexBuilder.finishGlobalConfigurationMocking( globalAnnotations );
 	}
 
 	private AnnotationInstance parserSqlResultSetMappings(Collection<XMLSqlResultSetMapping> namedQueries) {
 		AnnotationValue[] values = new AnnotationValue[namedQueries.size()];
 		int i = 0;
 		for ( Iterator<XMLSqlResultSetMapping> iterator = namedQueries.iterator(); iterator.hasNext(); ) {
 			AnnotationInstance annotationInstance = parserSqlResultSetMapping( iterator.next() );
 			values[i++] = MockHelper.nestedAnnotationValue(
 					"", annotationInstance
 			);
 		}
 		return create(
 				SQL_RESULT_SET_MAPPINGS, null,
 				new AnnotationValue[] { AnnotationValue.createArrayValue( "values", values ) }
 
 		);
 	}
 
 
 	//@SqlResultSetMapping
 	private AnnotationInstance parserSqlResultSetMapping(XMLSqlResultSetMapping mapping) {
 
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", mapping.getName(), annotationValueList );
 		nestedEntityResultList( "entities", mapping.getEntityResult(), annotationValueList );
 		nestedColumnResultList( "columns", mapping.getColumnResult(), annotationValueList );
 		return
 				create(
 						SQL_RESULT_SET_MAPPING, null, annotationValueList
 
 				);
 	}
 
 
 	//@EntityResult
 	private AnnotationInstance parserEntityResult(XMLEntityResult result) {
 
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue(
 				"discriminatorColumn", result.getDiscriminatorColumn(), annotationValueList
 		);
 		nestedFieldResultList( "fields", result.getFieldResult(), annotationValueList );
 		MockHelper.classValue(
 				"entityClass", result.getEntityClass(), annotationValueList, indexBuilder.getServiceRegistry()
 		);
 		return
 				create(
 						ENTITY_RESULT, null, annotationValueList
 
 				);
 	}
 
 	private void nestedEntityResultList(String name, List<XMLEntityResult> entityResults, List<AnnotationValue> annotationValueList) {
 		if ( MockHelper.isNotEmpty( entityResults ) ) {
 			AnnotationValue[] values = new AnnotationValue[entityResults.size()];
 			for ( int i = 0; i < entityResults.size(); i++ ) {
 				AnnotationInstance annotationInstance = parserEntityResult( entityResults.get( i ) );
 				values[i] = MockHelper.nestedAnnotationValue(
 						"", annotationInstance
 				);
 			}
 			MockHelper.addToCollectionIfNotNull(
 					annotationValueList, AnnotationValue.createArrayValue( name, values )
 			);
 		}
 	}
 
 	//@ColumnResult
 	private AnnotationInstance parserColumnResult(XMLColumnResult result) {
 		return create( COLUMN_RESULT, null, MockHelper.stringValueArray( "name", result.getName() ) );
 	}
 
 	private void nestedColumnResultList(String name, List<XMLColumnResult> columnResults, List<AnnotationValue> annotationValueList) {
 		if ( MockHelper.isNotEmpty( columnResults ) ) {
 			AnnotationValue[] values = new AnnotationValue[columnResults.size()];
 			for ( int i = 0; i < columnResults.size(); i++ ) {
 				AnnotationInstance annotationInstance = parserColumnResult( columnResults.get( i ) );
 				values[i] = MockHelper.nestedAnnotationValue(
 						"", annotationInstance
 				);
 			}
 			MockHelper.addToCollectionIfNotNull(
 					annotationValueList, AnnotationValue.createArrayValue( name, values )
 			);
 		}
 	}
 
 	//@FieldResult
 	private AnnotationInstance parserFieldResult(XMLFieldResult result) {
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", result.getName(), annotationValueList );
 		MockHelper.stringValue( "column", result.getColumn(), annotationValueList );
 		return create( FIELD_RESULT, null, annotationValueList );
 	}
 
 
 	private void nestedFieldResultList(String name, List<XMLFieldResult> fieldResultList, List<AnnotationValue> annotationValueList) {
 		if ( MockHelper.isNotEmpty( fieldResultList ) ) {
 			AnnotationValue[] values = new AnnotationValue[fieldResultList.size()];
 			for ( int i = 0; i < fieldResultList.size(); i++ ) {
 				AnnotationInstance annotationInstance = parserFieldResult( fieldResultList.get( i ) );
 				values[i] = MockHelper.nestedAnnotationValue(
 						"", annotationInstance
 				);
 			}
 			MockHelper.addToCollectionIfNotNull(
 					annotationValueList, AnnotationValue.createArrayValue( name, values )
 			);
 		}
 	}
 
 	private AnnotationInstance parserNamedNativeQueries(Collection<XMLNamedNativeQuery> namedQueries) {
 		AnnotationValue[] values = new AnnotationValue[namedQueries.size()];
 		int i = 0;
 		for ( Iterator<XMLNamedNativeQuery> iterator = namedQueries.iterator(); iterator.hasNext(); ) {
 			AnnotationInstance annotationInstance = parserNamedNativeQuery( iterator.next() );
 			values[i++] = MockHelper.nestedAnnotationValue(
 					"", annotationInstance
 			);
 		}
 		return create(
 				NAMED_NATIVE_QUERIES, null,
 				new AnnotationValue[] { AnnotationValue.createArrayValue( "values", values ) }
 
 		);
 	}
 
 	//@NamedNativeQuery
 	private AnnotationInstance parserNamedNativeQuery(XMLNamedNativeQuery namedNativeQuery) {
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", namedNativeQuery.getName(), annotationValueList );
 		MockHelper.stringValue( "query", namedNativeQuery.getQuery(), annotationValueList );
 		MockHelper.stringValue(
 				"resultSetMapping", namedNativeQuery.getResultSetMapping(), annotationValueList
 		);
 		MockHelper.classValue(
 				"resultClass", namedNativeQuery.getResultClass(), annotationValueList, indexBuilder.getServiceRegistry()
 		);
 		nestedQueryHintList( "hints", namedNativeQuery.getHint(), annotationValueList );
 		return
 				create(
 						NAMED_NATIVE_QUERY, null, annotationValueList
 
 				);
 	}
 
 
 	private AnnotationInstance parserNamedQueries(Collection<XMLNamedQuery> namedQueries) {
 		AnnotationValue[] values = new AnnotationValue[namedQueries.size()];
 		int i = 0;
 		for ( Iterator<XMLNamedQuery> iterator = namedQueries.iterator(); iterator.hasNext(); ) {
 			AnnotationInstance annotationInstance = parserNamedQuery( iterator.next() );
 			values[i++] = MockHelper.nestedAnnotationValue(
 					"", annotationInstance
 			);
 		}
 		return create(
 				NAMED_QUERIES, null,
 				new AnnotationValue[] { AnnotationValue.createArrayValue( "values", values ) }
 
 		);
 	}
 
 
 	//@NamedQuery
 	private AnnotationInstance parserNamedQuery(XMLNamedQuery namedQuery) {
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", namedQuery.getName(), annotationValueList );
 		MockHelper.stringValue( "query", namedQuery.getQuery(), annotationValueList );
 		MockHelper.enumValue( "lockMode", LOCK_MODE_TYPE, namedQuery.getLockMode(), annotationValueList );
 		nestedQueryHintList( "hints", namedQuery.getHint(), annotationValueList );
 		return create( NAMED_QUERY, null, annotationValueList );
 	}
 
 	//@QueryHint
 	private AnnotationInstance parserQueryHint(XMLQueryHint queryHint) {
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", queryHint.getName(), annotationValueList );
 		MockHelper.stringValue( "value", queryHint.getValue(), annotationValueList );
 		return create( QUERY_HINT, null, annotationValueList );
 
 	}
 
 	private void nestedQueryHintList(String name, List<XMLQueryHint> constraints, List<AnnotationValue> annotationValueList) {
 		if ( MockHelper.isNotEmpty( constraints ) ) {
 			AnnotationValue[] values = new AnnotationValue[constraints.size()];
 			for ( int i = 0; i < constraints.size(); i++ ) {
 				AnnotationInstance annotationInstance = parserQueryHint( constraints.get( i ) );
 				values[i] = MockHelper.nestedAnnotationValue(
 						"", annotationInstance
 				);
 			}
 			MockHelper.addToCollectionIfNotNull(
 					annotationValueList, AnnotationValue.createArrayValue( name, values )
 			);
 		}
 	}
 
 
 	//@SequenceGenerator
 	private AnnotationInstance parserSequenceGenerator(XMLSequenceGenerator generator) {
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", generator.getName(), annotationValueList );
 		MockHelper.stringValue( "catalog", generator.getCatalog(), annotationValueList );
 		MockHelper.stringValue( "schema", generator.getSchema(), annotationValueList );
 		MockHelper.stringValue( "sequenceName", generator.getSequenceName(), annotationValueList );
 		MockHelper.integerValue( "initialValue", generator.getInitialValue(), annotationValueList );
 		MockHelper.integerValue( "allocationSize", generator.getAllocationSize(), annotationValueList );
 		return
 				create(
 						SEQUENCE_GENERATOR, null, annotationValueList
 
 				);
 	}
 
 	//@TableGenerator
 	private AnnotationInstance parserTableGenerator(XMLTableGenerator generator) {
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", generator.getName(), annotationValueList );
 		MockHelper.stringValue( "catalog", generator.getCatalog(), annotationValueList );
 		MockHelper.stringValue( "schema", generator.getSchema(), annotationValueList );
 		MockHelper.stringValue( "table", generator.getTable(), annotationValueList );
 		MockHelper.stringValue( "pkColumnName", generator.getPkColumnName(), annotationValueList );
 		MockHelper.stringValue( "valueColumnName", generator.getValueColumnName(), annotationValueList );
 		MockHelper.stringValue( "pkColumnValue", generator.getPkColumnValue(), annotationValueList );
 		MockHelper.integerValue( "initialValue", generator.getInitialValue(), annotationValueList );
 		MockHelper.integerValue( "allocationSize", generator.getAllocationSize(), annotationValueList );
 		nestedUniqueConstraintList( "uniqueConstraints", generator.getUniqueConstraint(), annotationValueList );
 		return
 				create(
 						TABLE_GENERATOR, null, annotationValueList
 
 				);
 	}
 
 	@Override
 	protected AnnotationInstance push(AnnotationInstance annotationInstance) {
 		if ( annotationInstance != null ) {
 			return globalAnnotations.push( annotationInstance.name(), annotationInstance );
 		}
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/GlobalAnnotations.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/GlobalAnnotations.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/GlobalAnnotations.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/GlobalAnnotations.java
index 9c76fe0916..9dd1f2f2c6 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/GlobalAnnotations.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/GlobalAnnotations.java
@@ -1,299 +1,299 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.DotName;
 import org.jboss.logging.Logger;
 
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.binder.MappingException;
+import org.hibernate.metamodel.source.MappingException;
 import org.hibernate.metamodel.source.annotation.xml.XMLAttributes;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntity;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntityMappings;
 import org.hibernate.metamodel.source.annotation.xml.XMLId;
 import org.hibernate.metamodel.source.annotation.xml.XMLNamedNativeQuery;
 import org.hibernate.metamodel.source.annotation.xml.XMLNamedQuery;
 import org.hibernate.metamodel.source.annotation.xml.XMLSequenceGenerator;
 import org.hibernate.metamodel.source.annotation.xml.XMLSqlResultSetMapping;
 import org.hibernate.metamodel.source.annotation.xml.XMLTableGenerator;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
 
 /**
  * @author Strong Liu
  */
 class GlobalAnnotations implements JPADotNames {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			GlobalAnnotations.class.getName()
 	);
 	private Map<String, XMLSequenceGenerator> sequenceGeneratorMap = new HashMap<String, XMLSequenceGenerator>();
 	private Map<String, XMLTableGenerator> tableGeneratorMap = new HashMap<String, XMLTableGenerator>();
 	private Map<String, XMLNamedQuery> namedQueryMap = new HashMap<String, XMLNamedQuery>();
 	private Map<String, XMLNamedNativeQuery> namedNativeQueryMap = new HashMap<String, XMLNamedNativeQuery>();
 	private Map<String, XMLSqlResultSetMapping> sqlResultSetMappingMap = new HashMap<String, XMLSqlResultSetMapping>();
 	private Map<DotName, List<AnnotationInstance>> annotationInstanceMap = new HashMap<DotName, List<AnnotationInstance>>();
 	private List<AnnotationInstance> indexedAnnotationInstanceList = new ArrayList<AnnotationInstance>();
 	//---------------------------
 	private Set<String> defaultNamedNativeQueryNames = new HashSet<String>();
 	private Set<String> defaultNamedQueryNames = new HashSet<String>();
 	private Set<String> defaultNamedGenerators = new HashSet<String>();
 	private Set<String> defaultSqlResultSetMappingNames = new HashSet<String>();
 
 	Map<DotName, List<AnnotationInstance>> getAnnotationInstanceMap() {
 		return annotationInstanceMap;
 	}
 
 	AnnotationInstance push(DotName name, AnnotationInstance annotationInstance) {
 		if ( name == null || annotationInstance == null ) {
 			return null;
 		}
 		List<AnnotationInstance> list = annotationInstanceMap.get( name );
 		if ( list == null ) {
 			list = new ArrayList<AnnotationInstance>();
 			annotationInstanceMap.put( name, list );
 		}
 		list.add( annotationInstance );
 		return annotationInstance;
 	}
 
 
 	void addIndexedAnnotationInstance(List<AnnotationInstance> annotationInstanceList) {
 		if ( MockHelper.isNotEmpty( annotationInstanceList ) ) {
 			indexedAnnotationInstanceList.addAll( annotationInstanceList );
 		}
 	}
 
 	/**
 	 * do the orm xmls define global configurations?
 	 */
 	boolean hasGlobalConfiguration() {
 		return !( namedQueryMap.isEmpty() && namedNativeQueryMap.isEmpty() && sequenceGeneratorMap.isEmpty() && tableGeneratorMap
 				.isEmpty() && sqlResultSetMappingMap.isEmpty() );
 	}
 
 	Map<String, XMLNamedNativeQuery> getNamedNativeQueryMap() {
 		return namedNativeQueryMap;
 	}
 
 	Map<String, XMLNamedQuery> getNamedQueryMap() {
 		return namedQueryMap;
 	}
 
 	Map<String, XMLSequenceGenerator> getSequenceGeneratorMap() {
 		return sequenceGeneratorMap;
 	}
 
 	Map<String, XMLSqlResultSetMapping> getSqlResultSetMappingMap() {
 		return sqlResultSetMappingMap;
 	}
 
 	Map<String, XMLTableGenerator> getTableGeneratorMap() {
 		return tableGeneratorMap;
 	}
 
 
 	public void filterIndexedAnnotations() {
 		for ( AnnotationInstance annotationInstance : indexedAnnotationInstanceList ) {
 			pushIfNotExist( annotationInstance );
 		}
 	}
 
 	private void pushIfNotExist(AnnotationInstance annotationInstance) {
 		DotName annName = annotationInstance.name();
 		boolean isNotExist = false;
 		if ( annName.equals( SQL_RESULT_SET_MAPPINGS ) ) {
 			AnnotationInstance[] annotationInstances = annotationInstance.value().asNestedArray();
 			for ( AnnotationInstance ai : annotationInstances ) {
 				pushIfNotExist( ai );
 			}
 		}
 		else {
 			AnnotationValue value = annotationInstance.value( "name" );
 			String name = value.asString();
 			isNotExist = ( annName.equals( TABLE_GENERATOR ) && !tableGeneratorMap.containsKey( name ) ) ||
 					( annName.equals( SEQUENCE_GENERATOR ) && !sequenceGeneratorMap.containsKey( name ) ) ||
 					( annName.equals( NAMED_QUERY ) && !namedQueryMap.containsKey( name ) ) ||
 					( annName.equals( NAMED_NATIVE_QUERY ) && !namedNativeQueryMap.containsKey( name ) ) ||
 					( annName.equals( SQL_RESULT_SET_MAPPING ) && !sqlResultSetMappingMap.containsKey( name ) );
 		}
 		if ( isNotExist ) {
 			push( annName, annotationInstance );
 		}
 	}
 
 	void collectGlobalMappings(XMLEntityMappings entityMappings, EntityMappingsMocker.Default defaults) {
 		for ( XMLSequenceGenerator generator : entityMappings.getSequenceGenerator() ) {
 			put( generator, defaults );
 			defaultNamedGenerators.add( generator.getName() );
 		}
 		for ( XMLTableGenerator generator : entityMappings.getTableGenerator() ) {
 			put( generator, defaults );
 			defaultNamedGenerators.add( generator.getName() );
 		}
 		for ( XMLNamedQuery namedQuery : entityMappings.getNamedQuery() ) {
 			put( namedQuery );
 			defaultNamedQueryNames.add( namedQuery.getName() );
 		}
 		for ( XMLNamedNativeQuery namedNativeQuery : entityMappings.getNamedNativeQuery() ) {
 			put( namedNativeQuery );
 			defaultNamedNativeQueryNames.add( namedNativeQuery.getName() );
 		}
 		for ( XMLSqlResultSetMapping sqlResultSetMapping : entityMappings.getSqlResultSetMapping() ) {
 			put( sqlResultSetMapping );
 			defaultSqlResultSetMappingNames.add( sqlResultSetMapping.getName() );
 		}
 	}
 
 	void collectGlobalMappings(XMLEntity entity, EntityMappingsMocker.Default defaults) {
 		for ( XMLNamedQuery namedQuery : entity.getNamedQuery() ) {
 			if ( !defaultNamedQueryNames.contains( namedQuery.getName() ) ) {
 				put( namedQuery );
 			}
 			else {
 				LOG.warn( "Named Query [" + namedQuery.getName() + "] duplicated." );
 			}
 		}
 		for ( XMLNamedNativeQuery namedNativeQuery : entity.getNamedNativeQuery() ) {
 			if ( !defaultNamedNativeQueryNames.contains( namedNativeQuery.getName() ) ) {
 				put( namedNativeQuery );
 			}
 			else {
 				LOG.warn( "Named native Query [" + namedNativeQuery.getName() + "] duplicated." );
 			}
 		}
 		for ( XMLSqlResultSetMapping sqlResultSetMapping : entity.getSqlResultSetMapping() ) {
 			if ( !defaultSqlResultSetMappingNames.contains( sqlResultSetMapping.getName() ) ) {
 				put( sqlResultSetMapping );
 			}
 		}
 		XMLSequenceGenerator sequenceGenerator = entity.getSequenceGenerator();
 		if ( sequenceGenerator != null ) {
 			if ( !defaultNamedGenerators.contains( sequenceGenerator.getName() ) ) {
 				put( sequenceGenerator, defaults );
 			}
 		}
 		XMLTableGenerator tableGenerator = entity.getTableGenerator();
 		if ( tableGenerator != null ) {
 			if ( !defaultNamedGenerators.contains( tableGenerator.getName() ) ) {
 				put( tableGenerator, defaults );
 			}
 		}
 		XMLAttributes attributes = entity.getAttributes();
 		if ( attributes != null ) {
 			for ( XMLId id : attributes.getId() ) {
 				sequenceGenerator = id.getSequenceGenerator();
 				if ( sequenceGenerator != null ) {
 					put( sequenceGenerator, defaults );
 				}
 				tableGenerator = id.getTableGenerator();
 				if ( tableGenerator != null ) {
 					put( tableGenerator, defaults );
 				}
 			}
 		}
 	}
 
 	/**
 	 * Override SequenceGenerator using info definded in EntityMappings/Persistence-Metadata-Unit
 	 */
 	private static XMLSequenceGenerator overrideGenerator(XMLSequenceGenerator generator, EntityMappingsMocker.Default defaults) {
 		if ( StringHelper.isEmpty( generator.getSchema() ) && defaults != null ) {
 			generator.setSchema( defaults.getSchema() );
 		}
 		if ( StringHelper.isEmpty( generator.getCatalog() ) && defaults != null ) {
 			generator.setCatalog( defaults.getCatalog() );
 		}
 		return generator;
 	}
 
 	/**
 	 * Override TableGenerator using info definded in EntityMappings/Persistence-Metadata-Unit
 	 */
 	private static XMLTableGenerator overrideGenerator(XMLTableGenerator generator, EntityMappingsMocker.Default defaults) {
 		if ( StringHelper.isEmpty( generator.getSchema() ) && defaults != null ) {
 			generator.setSchema( defaults.getSchema() );
 		}
 		if ( StringHelper.isEmpty( generator.getCatalog() ) && defaults != null ) {
 			generator.setCatalog( defaults.getCatalog() );
 		}
 		return generator;
 	}
 
 	private void put(XMLNamedNativeQuery query) {
 		if ( query != null ) {
 			checkQueryName( query.getName() );
 			namedNativeQueryMap.put( query.getName(), query );
 		}
 	}
 
 	private void checkQueryName(String name) {
 		if ( namedQueryMap.containsKey( name ) || namedNativeQueryMap.containsKey( name ) ) {
 			throw new MappingException( "Duplicated query mapping " + name, null );
 		}
 	}
 
 	private void put(XMLNamedQuery query) {
 		if ( query != null ) {
 			checkQueryName( query.getName() );
 			namedQueryMap.put( query.getName(), query );
 		}
 	}
 
 	private void put(XMLSequenceGenerator generator, EntityMappingsMocker.Default defaults) {
 		if ( generator != null ) {
 			Object old = sequenceGeneratorMap.put( generator.getName(), overrideGenerator( generator, defaults ) );
 			if ( old != null ) {
 				LOG.duplicateGeneratorName( generator.getName() );
 			}
 		}
 	}
 
 	private void put(XMLTableGenerator generator, EntityMappingsMocker.Default defaults) {
 		if ( generator != null ) {
 			Object old = tableGeneratorMap.put( generator.getName(), overrideGenerator( generator, defaults ) );
 			if ( old != null ) {
 				LOG.duplicateGeneratorName( generator.getName() );
 			}
 		}
 	}
 
 	private void put(XMLSqlResultSetMapping mapping) {
 		if ( mapping != null ) {
 			Object old = sqlResultSetMappingMap.put( mapping.getName(), mapping );
 			if ( old != null ) {
 				throw new MappingException( "Duplicated SQL result set mapping " +  mapping.getName(), null );
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/IdMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IdMocker.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/IdMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IdMocker.java
index 8d3bf30503..8e418e76f1 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/IdMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IdMocker.java
@@ -1,84 +1,84 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLGeneratedValue;
 import org.hibernate.metamodel.source.annotation.xml.XMLId;
 
 /**
  * @author Strong Liu
  */
 class IdMocker extends PropertyMocker {
 	private XMLId id;
 
 	IdMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, XMLId id) {
 		super( indexBuilder, classInfo, defaults );
 		this.id = id;
 	}
 
 	@Override
 	protected void processExtra() {
 		create( ID );
 		parserColumn( id.getColumn(), getTarget() );
 		parserGeneratedValue( id.getGeneratedValue(), getTarget() );
 		parserTemporalType( id.getTemporal(), getTarget() );
 	}
 
 	private AnnotationInstance parserGeneratedValue(XMLGeneratedValue generatedValue, AnnotationTarget target) {
 		if ( generatedValue == null ) {
 			return null;
 		}
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "generator", generatedValue.getGenerator(), annotationValueList );
 		MockHelper.enumValue(
 				"strategy", GENERATION_TYPE, generatedValue.getStrategy(), annotationValueList
 		);
 
 		return create( GENERATED_VALUE, target, annotationValueList );
 	}
 
 	@Override
 	protected String getFieldName() {
 		return id.getName();
 	}
 
 	@Override
 	protected XMLAccessType getAccessType() {
 		return id.getAccess();
 	}
 
 	@Override
 	protected void setAccessType(XMLAccessType accessType) {
 		id.setAccess( accessType );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/IndexBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilder.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/IndexBuilder.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilder.java
index af2ac0488a..defdde09ef 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/IndexBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilder.java
@@ -1,305 +1,305 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
-import org.hibernate.metamodel.binder.source.annotations.xml.filter.IndexedAnnotationFilter;
+import org.hibernate.metamodel.source.annotations.xml.filter.IndexedAnnotationFilter;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 
 /**
  * @author Strong Liu
  */
 public class IndexBuilder {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			IndexBuilder.class.getName()
 	);
 	private Map<DotName, List<AnnotationInstance>> annotations;
 	private Map<DotName, List<ClassInfo>> subclasses;
 	private Map<DotName, List<ClassInfo>> implementors;
 	private Map<DotName, ClassInfo> classes;
 	private Index index;
 	private Map<DotName, Map<DotName, List<AnnotationInstance>>> classInfoAnnotationsMap;
 	private Map<DotName, Map<DotName, List<AnnotationInstance>>> indexedClassInfoAnnotationsMap;
 	private ServiceRegistry serviceRegistry;
 
 	IndexBuilder(Index index, ServiceRegistry serviceRegistry) {
 		this.index = index;
 		this.serviceRegistry = serviceRegistry;
 		this.annotations = new HashMap<DotName, List<AnnotationInstance>>();
 		this.subclasses = new HashMap<DotName, List<ClassInfo>>();
 		this.implementors = new HashMap<DotName, List<ClassInfo>>();
 		this.classes = new HashMap<DotName, ClassInfo>();
 		this.classInfoAnnotationsMap = new HashMap<DotName, Map<DotName, List<AnnotationInstance>>>();
 		this.indexedClassInfoAnnotationsMap = new HashMap<DotName, Map<DotName, List<AnnotationInstance>>>();
 	}
 
 	/**
 	 * Build new {@link Index} with mocked annotations from orm.xml.
 	 * This method should be only called once per {@org.hibernate.metamodel.source.annotations.xml.mocker.IndexBuilder IndexBuilder} instance.
 	 *
 	 * @param globalDefaults Global defaults from <persistence-unit-metadata>, or null.
 	 *
 	 * @return Index.
 	 */
 	Index build(EntityMappingsMocker.Default globalDefaults) {
 		//merge annotations that not overrided by xml into the new Index
 		for ( ClassInfo ci : index.getKnownClasses() ) {
 			DotName name = ci.name();
 			if ( indexedClassInfoAnnotationsMap.containsKey( name ) ) {
 				//this class has been overrided by orm.xml
 				continue;
 			}
 			if ( ci.annotations() != null && !ci.annotations().isEmpty() ) {
 				Map<DotName, List<AnnotationInstance>> tmp = new HashMap<DotName, List<AnnotationInstance>>( ci.annotations() );
 				DefaultConfigurationHelper.INSTANCE.applyDefaults( tmp, globalDefaults );
 				mergeAnnotationMap( tmp, annotations );
 				classes.put( name, ci );
 				if ( ci.superName() != null ) {
 					addSubClasses( ci.superName(), ci );
 				}
 				if ( ci.interfaces() != null && ci.interfaces().length > 0 ) {
 					addImplementors( ci.interfaces(), ci );
 				}
 			}
 		}
 		return Index.create(
 				annotations, subclasses, implementors, classes
 		);
 	}
 	Map<DotName, List<AnnotationInstance>> getAnnotations(){
 		return Collections.unmodifiableMap( annotations );
 	}
 	/**
 	 * If {@code xml-mapping-metadata-complete} is defined in PersistenceUnitMetadata, we create a new empty {@link Index} here.
 	 */
 	void mappingMetadataComplete() {
 		LOG.debug(
 				"xml-mapping-metadata-complete is specified in persistence-unit-metadata, ignore JPA annotations."
 		);
 		index = Index.create(
 				new HashMap<DotName, List<AnnotationInstance>>(),
 				new HashMap<DotName, List<ClassInfo>>(),
 				new HashMap<DotName, List<ClassInfo>>(),
 				new HashMap<DotName, ClassInfo>()
 		);
 	}
 
 	/**
 	 * @param name Entity Object dot name which is being process.
 	 */
 	void metadataComplete(DotName name) {
 		LOG.debug(
 				"metadata-complete is specified in " + name + ", ignore JPA annotations."
 		);
 		getIndexedAnnotations( name ).clear();
 	}
 
 	public Map<DotName, List<AnnotationInstance>> getIndexedAnnotations(DotName name) {
 		Map<DotName, List<AnnotationInstance>> map = indexedClassInfoAnnotationsMap.get( name );
 		if ( map == null ) {
 			ClassInfo ci = index.getClassByName( name );
 			if ( ci == null || ci.annotations() == null ) {
 				map = Collections.emptyMap();
 			}
 			else {
 				map = new HashMap<DotName, List<AnnotationInstance>>( ci.annotations() );
 				//here we ignore global annotations
 				for ( DotName globalAnnotationName : DefaultConfigurationHelper.GLOBAL_ANNOTATIONS ) {
 					if ( map.containsKey( globalAnnotationName ) ) {
 						map.put( globalAnnotationName, Collections.<AnnotationInstance>emptyList() );
 					}
 				}
 			}
 			indexedClassInfoAnnotationsMap.put( name, map );
 		}
 		return map;
 	}
 
 	public Map<DotName, List<AnnotationInstance>> getClassInfoAnnotationsMap(DotName name) {
 		return classInfoAnnotationsMap.get( name );
 	}
 
 	public ClassInfo getClassInfo(DotName name) {
 		return classes.get( name );
 	}
 
 	public ClassInfo getIndexedClassInfo(DotName name) {
 		return index.getClassByName( name );
 	}
 
 	void collectGlobalConfigurationFromIndex(GlobalAnnotations globalAnnotations) {
 		for ( DotName annName : DefaultConfigurationHelper.GLOBAL_ANNOTATIONS ) {
 			List<AnnotationInstance> annotationInstanceList = index.getAnnotations( annName );
 			if ( MockHelper.isNotEmpty( annotationInstanceList ) ) {
 				globalAnnotations.addIndexedAnnotationInstance( annotationInstanceList );
 			}
 		}
 		globalAnnotations.filterIndexedAnnotations();
 	}
 
 	void finishGlobalConfigurationMocking(GlobalAnnotations globalAnnotations) {
 		annotations.putAll( globalAnnotations.getAnnotationInstanceMap() );
 	}
 
 	void finishEntityObject(final DotName name, final EntityMappingsMocker.Default defaults) {
 		Map<DotName, List<AnnotationInstance>> map = classInfoAnnotationsMap.get( name );
 		if ( map == null ) {
 			throw new AssertionFailure( "Calling finish entity object " + name + " before create it." );
 		}
 		// annotations classes overrided by xml
 		if ( indexedClassInfoAnnotationsMap.containsKey( name ) ) {
 			Map<DotName, List<AnnotationInstance>> tmp = getIndexedAnnotations( name );
 			mergeAnnotationMap( tmp, map );
 		}
 		DefaultConfigurationHelper.INSTANCE.applyDefaults( map, defaults );
 		
 		mergeAnnotationMap( map, annotations );
 	}
 
 
 	void addAnnotationInstance(DotName targetClassName, AnnotationInstance annotationInstance) {
 		if ( annotationInstance == null ) {
 			return;
 		}
 		for ( IndexedAnnotationFilter indexedAnnotationFilter : IndexedAnnotationFilter.ALL_FILTERS ) {
 			indexedAnnotationFilter.beforePush( this, targetClassName, annotationInstance );
 		}
 		Map<DotName, List<AnnotationInstance>> map = classInfoAnnotationsMap.get( targetClassName );
 		if ( map == null ) {
 			throw new AssertionFailure( "Can't find " + targetClassName + " in internal cache, should call createClassInfo first" );
 		}
 
 		List<AnnotationInstance> annotationInstanceList = map.get( annotationInstance.name() );
 		if ( annotationInstanceList == null ) {
 			annotationInstanceList = new ArrayList<AnnotationInstance>();
 			map.put( annotationInstance.name(), annotationInstanceList );
 		}
 		annotationInstanceList.add( annotationInstance );
 	}
 
 	ServiceRegistry getServiceRegistry() {
 		return serviceRegistry;
 	}
 
 	ClassInfo createClassInfo(String className) {
 		if ( StringHelper.isEmpty( className ) ) {
 			throw new AssertionFailure( "Class Name used to create ClassInfo is empty." );
 		}
 		DotName classDotName = DotName.createSimple( className );
 		if ( classes.containsKey( classDotName ) ) {
 			//classInfoAnnotationsMap.put( classDotName, new HashMap<DotName, List<AnnotationInstance>>(classes.get( classDotName ).annotations()) );
 			return classes.get( classDotName );
 		}
 		Class clazz = serviceRegistry.getService( ClassLoaderService.class ).classForName( className );
 		DotName superName = null;
 		DotName[] interfaces = null;
 		short access_flag;
 		ClassInfo annClassInfo = index.getClassByName( classDotName );
 		if ( annClassInfo != null ) {
 			superName = annClassInfo.superName();
 			interfaces = annClassInfo.interfaces();
 			access_flag = annClassInfo.flags();
 		}
 		else {
 			Class superClass = clazz.getSuperclass();
 			if ( superClass != null ) {
 				superName = DotName.createSimple( superClass.getName() );
 			}
 			Class[] classInterfaces = clazz.getInterfaces();
 			if ( classInterfaces != null && classInterfaces.length > 0 ) {
 				interfaces = new DotName[classInterfaces.length];
 				for ( int i = 0; i < classInterfaces.length; i++ ) {
 					interfaces[i] = DotName.createSimple( classInterfaces[i].getName() );
 				}
 			}
 			access_flag = (short) ( clazz.getModifiers() | 0x20 );//(modifiers | ACC_SUPER)
 		}
 		Map<DotName, List<AnnotationInstance>> map = new HashMap<DotName, List<AnnotationInstance>>();
 		classInfoAnnotationsMap.put( classDotName, map );
 		ClassInfo classInfo = ClassInfo.create(
 				classDotName, superName, access_flag, interfaces, map
 		);
 		classes.put( classDotName, classInfo );
 		addSubClasses( superName, classInfo );
 		addImplementors( interfaces, classInfo );
 		return classInfo;
 	}
 
 	private void addSubClasses(DotName superClassDotName, ClassInfo classInfo) {
 		if ( superClassDotName != null ) {
 			List<ClassInfo> classInfoList = subclasses.get( superClassDotName );
 			if ( classInfoList == null ) {
 				classInfoList = new ArrayList<ClassInfo>();
 				subclasses.put( superClassDotName, classInfoList );
 			}
 			classInfoList.add( classInfo );
 		}
 	}
 
 	private void addImplementors(DotName[] dotNames, ClassInfo classInfo) {
 		if ( dotNames != null && dotNames.length > 0 ) {
 			for ( DotName dotName : dotNames ) {
 				List<ClassInfo> classInfoList = implementors.get( dotName );
 				if ( classInfoList == null ) {
 					classInfoList = new ArrayList<ClassInfo>();
 					implementors.put( dotName, classInfoList );
 				}
 				classInfoList.add( classInfo );
 			}
 		}
 	}
 
 	//merge source into target
 	private void mergeAnnotationMap(Map<DotName, List<AnnotationInstance>> source, Map<DotName, List<AnnotationInstance>> target) {
 		if ( source != null && !source.isEmpty() ) {
 			for ( DotName annotationName : source.keySet() ) {
 				if ( source.get( annotationName ).isEmpty() ) {
 					continue;
 				}
 				List<AnnotationInstance> annotationInstanceList = target.get( annotationName );
 				if ( annotationInstanceList == null ) {
 					annotationInstanceList = new ArrayList<AnnotationInstance>();
 					target.put( annotationName, annotationInstanceList );
 				}
 				annotationInstanceList.addAll( source.get( annotationName ) );
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ListenerMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ListenerMocker.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ListenerMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ListenerMocker.java
index 470ccbe4a7..89123afa5d 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ListenerMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ListenerMocker.java
@@ -1,159 +1,159 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.MappingException;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntityListener;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntityListeners;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostLoad;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostPersist;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostRemove;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostUpdate;
 import org.hibernate.metamodel.source.annotation.xml.XMLPrePersist;
 import org.hibernate.metamodel.source.annotation.xml.XMLPreRemove;
 import org.hibernate.metamodel.source.annotation.xml.XMLPreUpdate;
 
 /**
  * {@link javax.persistence.EntityListeners @EntityListeners} mocker
  *
  * @author Strong Liu
  */
 class ListenerMocker extends AbstractMocker {
 	private final ClassInfo classInfo;
 
 	ListenerMocker(IndexBuilder indexBuilder, ClassInfo classInfo) {
 		super( indexBuilder );
 		this.classInfo = classInfo;
 	}
 
 	AnnotationInstance parser(XMLEntityListeners entityListeners) {
 		if ( entityListeners.getEntityListener().isEmpty() ) {
 			throw new MappingException( "No child element of <entity-listener> found under <entity-listeners>." );
 		}
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>( 1 );
 		List<String> clazzNameList = new ArrayList<String>( entityListeners.getEntityListener().size() );
 		for ( XMLEntityListener listener : entityListeners.getEntityListener() ) {
 			MockHelper.addToCollectionIfNotNull( clazzNameList, listener.getClazz() );
 			parserEntityListener( listener );
 		}
 		MockHelper.classArrayValue( "value", clazzNameList, annotationValueList, indexBuilder.getServiceRegistry() );
 		return create( ENTITY_LISTENERS, classInfo, annotationValueList );
 	}
 
 	private void parserEntityListener(XMLEntityListener listener) {
 		String clazz = listener.getClazz();
 		ClassInfo tempClassInfo = indexBuilder.createClassInfo( clazz );
 		ListenerMocker mocker = createListenerMocker( indexBuilder, tempClassInfo );
 		mocker.parser( listener.getPostLoad() );
 		mocker.parser( listener.getPostPersist() );
 		mocker.parser( listener.getPostRemove() );
 		mocker.parser( listener.getPostUpdate() );
 		mocker.parser( listener.getPrePersist() );
 		mocker.parser( listener.getPreRemove() );
 		mocker.parser( listener.getPreUpdate() );
 		indexBuilder.finishEntityObject( tempClassInfo.name(), null );
 	}
 
 	protected ListenerMocker createListenerMocker(IndexBuilder indexBuilder, ClassInfo classInfo) {
 		return new ListenerMocker( indexBuilder, classInfo );
 	}
 
 	//@PrePersist
 	AnnotationInstance parser(XMLPrePersist callback) {
 		if ( callback == null ) {
 			return null;
 		}
 		return create( PRE_PERSIST, getListenerTarget( callback.getMethodName() ) );
 	}
 
 	//@PreRemove
 	AnnotationInstance parser(XMLPreRemove callback) {
 		if ( callback == null ) {
 			return null;
 		}
 		return create( PRE_REMOVE, getListenerTarget( callback.getMethodName() ) );
 	}
 
 	//@PreUpdate
 	AnnotationInstance parser(XMLPreUpdate callback) {
 		if ( callback == null ) {
 			return null;
 		}
 		return create( PRE_UPDATE, getListenerTarget( callback.getMethodName() ) );
 	}
 
 	//@PostPersist
 	AnnotationInstance parser(XMLPostPersist callback) {
 		if ( callback == null ) {
 			return null;
 		}
 		return create( POST_PERSIST, getListenerTarget( callback.getMethodName() ) );
 	}
 
 	//@PostUpdate
 	AnnotationInstance parser(XMLPostUpdate callback) {
 		if ( callback == null ) {
 			return null;
 		}
 		return create( POST_UPDATE, getListenerTarget( callback.getMethodName() ) );
 	}
 
 	//@PostRemove
 	AnnotationInstance parser(XMLPostRemove callback) {
 		if ( callback == null ) {
 			return null;
 		}
 		return create( POST_REMOVE, getListenerTarget( callback.getMethodName() ) );
 	}
 
 	//@PostLoad
 	AnnotationInstance parser(XMLPostLoad callback) {
 		if ( callback == null ) {
 			return null;
 		}
 		return create( POST_LOAD, getListenerTarget( callback.getMethodName() ) );
 	}
 
 	private AnnotationTarget getListenerTarget(String methodName) {
 		return MockHelper.getTarget(
 				indexBuilder.getServiceRegistry(), classInfo, methodName, MockHelper.TargetType.METHOD
 		);
 	}
 
 	@Override
 	protected AnnotationInstance push(AnnotationInstance annotationInstance) {
 		if ( annotationInstance != null && annotationInstance.target() != null ) {
 			indexBuilder.addAnnotationInstance( classInfo.name(), annotationInstance );
 		}
 		return annotationInstance;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ManyToManyMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ManyToManyMocker.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ManyToManyMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ManyToManyMocker.java
index b540948bc1..3e7b17223c 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ManyToManyMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ManyToManyMocker.java
@@ -1,84 +1,84 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLManyToMany;
 
 /**
  * @author Strong Liu
  */
 class ManyToManyMocker extends PropertyMocker {
 	private XMLManyToMany manyToMany;
 
 	ManyToManyMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, XMLManyToMany manyToMany) {
 		super( indexBuilder, classInfo, defaults );
 		this.manyToMany = manyToMany;
 	}
 
 	@Override
 	protected String getFieldName() {
 		return manyToMany.getName();
 	}
 
 
 	@Override
 	protected void processExtra() {
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.classValue(
 				"targetEntity", manyToMany.getTargetEntity(), annotationValueList, indexBuilder.getServiceRegistry()
 		);
 		MockHelper.enumValue( "fetch", FETCH_TYPE, manyToMany.getFetch(), annotationValueList );
 		MockHelper.stringValue( "mappedBy", manyToMany.getMappedBy(), annotationValueList );
 		MockHelper.cascadeValue( "cascade", manyToMany.getCascade(), isDefaultCascadePersist(), annotationValueList );
 		create( MANY_TO_MANY, annotationValueList );
 		parserMapKeyClass( manyToMany.getMapKeyClass(), getTarget() );
 		parserMapKeyTemporal( manyToMany.getMapKeyTemporal(), getTarget() );
 		parserMapKeyEnumerated( manyToMany.getMapKeyEnumerated(), getTarget() );
 		parserMapKey( manyToMany.getMapKey(), getTarget() );
 		parserAttributeOverrides( manyToMany.getMapKeyAttributeOverride(), getTarget() );
 		parserMapKeyJoinColumnList( manyToMany.getMapKeyJoinColumn(), getTarget() );
 		parserOrderColumn( manyToMany.getOrderColumn(), getTarget() );
 		parserJoinTable( manyToMany.getJoinTable(), getTarget() );
 		if ( manyToMany.getOrderBy() != null ) {
 			create( ORDER_BY, MockHelper.stringValueArray( "value", manyToMany.getOrderBy() ) );
 		}
 	}
 
 	@Override
 	protected XMLAccessType getAccessType() {
 		return manyToMany.getAccess();
 	}
 
 	@Override
 	protected void setAccessType(XMLAccessType accessType) {
 		manyToMany.setAccess( accessType );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ManyToOneMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ManyToOneMocker.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ManyToOneMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ManyToOneMocker.java
index de30f67d42..9e14156efd 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ManyToOneMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/ManyToOneMocker.java
@@ -1,80 +1,80 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLManyToOne;
 
 /**
  * @author Strong Liu
  */
 class ManyToOneMocker extends PropertyMocker {
 	private XMLManyToOne manyToOne;
 
 	ManyToOneMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, XMLManyToOne manyToOne) {
 		super( indexBuilder, classInfo, defaults );
 		this.manyToOne = manyToOne;
 	}
 
 	@Override
 	protected String getFieldName() {
 		return manyToOne.getName();
 	}
 
 	@Override
 	protected void processExtra() {
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.classValue(
 				"targetEntity", manyToOne.getTargetEntity(), annotationValueList, indexBuilder.getServiceRegistry()
 		);
 		MockHelper.enumValue( "fetch", FETCH_TYPE, manyToOne.getFetch(), annotationValueList );
 		MockHelper.booleanValue( "optional", manyToOne.isOptional(), annotationValueList );
 		MockHelper.cascadeValue( "cascade", manyToOne.getCascade(), isDefaultCascadePersist(), annotationValueList );
 		create( MANY_TO_ONE, annotationValueList );
 		parserJoinColumnList( manyToOne.getJoinColumn(), getTarget() );
 		parserJoinTable( manyToOne.getJoinTable(), getTarget() );
 		if ( manyToOne.getMapsId() != null ) {
 			create( MAPS_ID, MockHelper.stringValueArray( "value", manyToOne.getMapsId() ) );
 		}
 		if ( manyToOne.isId() != null && manyToOne.isId() ) {
 			create( ID );
 		}
 	}
 
 	@Override
 	protected XMLAccessType getAccessType() {
 		return manyToOne.getAccess();
 	}
 
 	@Override
 	protected void setAccessType(XMLAccessType accessType) {
 		manyToOne.setAccess( accessType );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/MappedSuperclassMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MappedSuperclassMocker.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/MappedSuperclassMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MappedSuperclassMocker.java
index efe442aac3..f272994ff4 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/MappedSuperclassMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MappedSuperclassMocker.java
@@ -1,142 +1,142 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLAttributes;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntityListeners;
 import org.hibernate.metamodel.source.annotation.xml.XMLIdClass;
 import org.hibernate.metamodel.source.annotation.xml.XMLMappedSuperclass;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostLoad;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostPersist;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostRemove;
 import org.hibernate.metamodel.source.annotation.xml.XMLPostUpdate;
 import org.hibernate.metamodel.source.annotation.xml.XMLPrePersist;
 import org.hibernate.metamodel.source.annotation.xml.XMLPreRemove;
 import org.hibernate.metamodel.source.annotation.xml.XMLPreUpdate;
 
 /**
  * Mock <mapped-superclass> to {@link javax.persistence.MappedSuperclass @MappedSuperClass}
  *
  * @author Strong Liu
  */
 class MappedSuperclassMocker extends AbstractEntityObjectMocker {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			MappedSuperclassMocker.class.getName()
 	);
 	private XMLMappedSuperclass mappedSuperclass;
 
 	MappedSuperclassMocker(IndexBuilder indexBuilder, XMLMappedSuperclass mappedSuperclass, EntityMappingsMocker.Default defaults) {
 		super( indexBuilder, defaults );
 		this.mappedSuperclass = mappedSuperclass;
 	}
 
 	@Override
 	protected void applyDefaults() {
 		DefaultConfigurationHelper.INSTANCE.applyDefaults( mappedSuperclass, getDefaults() );
 	}
 
 	@Override
 	protected void processExtra() {
 		create( MAPPED_SUPERCLASS );
 	}
 
 	@Override
 	protected XMLAttributes getAttributes() {
 		return mappedSuperclass.getAttributes();
 	}
 
 	@Override
 	protected XMLAccessType getAccessType() {
 		return mappedSuperclass.getAccess();
 	}
 
 	@Override
 	protected boolean isMetadataComplete() {
 		return mappedSuperclass.isMetadataComplete() != null && mappedSuperclass.isMetadataComplete();
 	}
 
 	@Override
 	protected boolean isExcludeDefaultListeners() {
 		return mappedSuperclass.getExcludeDefaultListeners() != null;
 	}
 
 	@Override
 	protected boolean isExcludeSuperclassListeners() {
 		return mappedSuperclass.getExcludeSuperclassListeners() != null;
 	}
 
 	@Override
 	protected XMLIdClass getIdClass() {
 		return mappedSuperclass.getIdClass();
 	}
 
 	@Override
 	protected XMLEntityListeners getEntityListeners() {
 		return mappedSuperclass.getEntityListeners();
 	}
 
 	protected String getClassName() {
 		return mappedSuperclass.getClazz();
 	}
 
 	@Override
 	protected XMLPrePersist getPrePersist() {
 		return mappedSuperclass.getPrePersist();
 	}
 
 	@Override
 	protected XMLPreRemove getPreRemove() {
 		return mappedSuperclass.getPreRemove();
 	}
 
 	@Override
 	protected XMLPreUpdate getPreUpdate() {
 		return mappedSuperclass.getPreUpdate();
 	}
 
 	@Override
 	protected XMLPostPersist getPostPersist() {
 		return mappedSuperclass.getPostPersist();
 	}
 
 	@Override
 	protected XMLPostUpdate getPostUpdate() {
 		return mappedSuperclass.getPostUpdate();
 	}
 
 	@Override
 	protected XMLPostRemove getPostRemove() {
 		return mappedSuperclass.getPostRemove();
 	}
 
 	@Override
 	protected XMLPostLoad getPostLoad() {
 		return mappedSuperclass.getPostLoad();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/MockHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MockHelper.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/MockHelper.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MockHelper.java
index 6a0e945a4d..5b6f8ca5a4 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/MockHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MockHelper.java
@@ -1,471 +1,471 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.beans.Introspector;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.FieldInfo;
 import org.jboss.jandex.MethodInfo;
 import org.jboss.jandex.Type;
 
 import org.hibernate.HibernateException;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.metamodel.source.annotation.xml.XMLCascadeType;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 
 /**
  * @author Strong Liu
  */
 public class MockHelper {
 
 	static final AnnotationValue[] EMPTY_ANNOTATION_VALUE_ARRAY = new AnnotationValue[0];
 	static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
 
 	/**
 	 * util method for String Array attribute Annotation
 	 *
 	 * @param name
 	 * @param values
 	 * @param annotationValueList
 	 */
 	static void stringArrayValue(String name, List<String> values, List<AnnotationValue> annotationValueList) {
 		if ( isNotEmpty( values ) ) {
 			AnnotationValue[] annotationValues = new AnnotationValue[values.size()];
 			for ( int j = 0; j < values.size(); j++ ) {
 				annotationValues[j] = stringValue( "", values.get( j ) );
 			}
 			annotationValueList.add(
 					AnnotationValue.createArrayValue(
 							name, annotationValues
 					)
 			);
 		}
 	}
 
 	/**
 	 * util method for single string attribute Annotation only
 	 */
 	static AnnotationValue[] stringValueArray(String name, String value) {
 		return nullSafe( stringValue( name, value ) );
 	}
 
 	private static AnnotationValue stringValue(String name, String value) {
 		if ( StringHelper.isNotEmpty( value ) ) {
 			return AnnotationValue.createStringValue( name, value );
 		}
 		return null;
 	}
 
 	static void stringValue(String name, String value, List<AnnotationValue> annotationValueList) {
 		addToCollectionIfNotNull( annotationValueList, stringValue( name, value ) );
 	}
 
 	private static AnnotationValue integerValue(String name, Integer value) {
 		if ( value == null ) {
 			return null;
 		}
 		return AnnotationValue.createIntegerValue( name, value );
 	}
 
 	static void integerValue(String name, Integer value, List<AnnotationValue> annotationValueList) {
 		addToCollectionIfNotNull( annotationValueList, integerValue( name, value ) );
 	}
 
 	static AnnotationValue[] booleanValueArray(String name, Boolean value) {
 		return nullSafe( booleanValue( name, value ) );
 	}
 
 	static void booleanValue(String name, Boolean value, List<AnnotationValue> annotationValueList) {
 		addToCollectionIfNotNull( annotationValueList, booleanValue( name, value ) );
 	}
 
 	private static AnnotationValue booleanValue(String name, Boolean value) {
 		if ( value == null ) {
 			return null;
 		}
 		return AnnotationValue.createBooleanValue( name, value );
 	}
 
 	private static AnnotationValue classValue(String name, String className, ServiceRegistry serviceRegistry) {
 		if ( StringHelper.isNotEmpty( className ) ) {
 			return AnnotationValue.createClassValue( name, getType( className, serviceRegistry ) );
 		}
 		return null;
 	}
 
 
 	static void classValue(String name, String className, List<AnnotationValue> list, ServiceRegistry serviceRegistry) {
 		addToCollectionIfNotNull( list, classValue( name, className, serviceRegistry ) );
 	}
 
 	static AnnotationValue[] classValueArray(String name, String className, ServiceRegistry serviceRegistry) {
 		return nullSafe( classValue( name, className, serviceRegistry ) );
 	}
 
 	static AnnotationValue nestedAnnotationValue(String name, AnnotationInstance value) {
 		if ( value == null ) {
 			return null;
 		}
 		return AnnotationValue.createNestedAnnotationValue(
 				name, value
 		);
 	}
 
 	static void nestedAnnotationValue(String name, AnnotationInstance value, List<AnnotationValue> list) {
 		addToCollectionIfNotNull( list, nestedAnnotationValue( name, value ) );
 	}
 
 	private static AnnotationValue[] nullSafe(AnnotationValue value) {
 		return value == null ? EMPTY_ANNOTATION_VALUE_ARRAY : new AnnotationValue[] {
 				value
 		};
 	}
 
 	static void classArrayValue(String name, List<String> classNameList, List<AnnotationValue> list, ServiceRegistry serviceRegistry) {
 		if ( isNotEmpty( classNameList ) ) {
 
 			List<AnnotationValue> clazzValueList = new ArrayList<AnnotationValue>( classNameList.size() );
 			for ( String clazz : classNameList ) {
 				addToCollectionIfNotNull( clazzValueList, classValue( "", clazz, serviceRegistry ) );
 			}
 
 			list.add(
 					AnnotationValue.createArrayValue(
 							name, toArray( clazzValueList )
 					)
 			);
 		}
 	}
 
 	public static AnnotationValue[] toArray(List<AnnotationValue> list) {
 		AnnotationValue[] values = EMPTY_ANNOTATION_VALUE_ARRAY;
 		if ( isNotEmpty( list ) ) {
 			values = list.toArray( new AnnotationValue[list.size()] );
 		}
 		return values;
 	}
 
 	private static AnnotationValue enumValue(String name, DotName typeName, Enum value) {
 		if ( value != null && StringHelper.isNotEmpty( value.toString() ) ) {
 			return AnnotationValue.createEnumValue( name, typeName, value.toString() );
 		}
 		return null;
 	}
 
 	static void cascadeValue(String name, XMLCascadeType cascadeType, boolean isCascadePersistDefault, List<AnnotationValue> annotationValueList) {
 		List<Enum> enumList = new ArrayList<Enum>();
 		if ( isCascadePersistDefault ) {
 			enumList.add( javax.persistence.CascadeType.PERSIST );
 		}
 		if ( cascadeType != null ) {
 			if ( cascadeType.getCascadeAll() != null ) {
 				enumList.add( javax.persistence.CascadeType.ALL );
 			}
 			if ( cascadeType.getCascadePersist() != null && !isCascadePersistDefault ) {
 				enumList.add( javax.persistence.CascadeType.PERSIST );
 			}
 			if ( cascadeType.getCascadeMerge() != null ) {
 				enumList.add( javax.persistence.CascadeType.MERGE );
 			}
 			if ( cascadeType.getCascadeRemove() != null ) {
 				enumList.add( javax.persistence.CascadeType.REMOVE );
 			}
 			if ( cascadeType.getCascadeRefresh() != null ) {
 				enumList.add( javax.persistence.CascadeType.REFRESH );
 			}
 			if ( cascadeType.getCascadeDetach() != null ) {
 				enumList.add( javax.persistence.CascadeType.DETACH );
 			}
 		}
 		if ( !enumList.isEmpty() ) {
 			MockHelper.enumArrayValue( name, JPADotNames.CASCADE_TYPE, enumList, annotationValueList );
 		}
 	}
 
 	static void enumArrayValue(String name, DotName typeName, List<Enum> valueList, List<AnnotationValue> list) {
 		if ( isNotEmpty( valueList ) ) {
 
 			List<AnnotationValue> enumValueList = new ArrayList<AnnotationValue>( valueList.size() );
 			for ( Enum e : valueList ) {
 				addToCollectionIfNotNull( enumValueList, enumValue( "", typeName, e ) );
 			}
 			list.add(
 					AnnotationValue.createArrayValue(
 							name, toArray( enumValueList )
 					)
 			);
 		}
 	}
 
 	static void enumValue(String name, DotName typeName, Enum value, List<AnnotationValue> list) {
 		addToCollectionIfNotNull( list, enumValue( name, typeName, value ) );
 	}
 
 	static AnnotationValue[] enumValueArray(String name, DotName typeName, Enum value) {
 		return nullSafe( enumValue( name, typeName, value ) );
 	}
 
 	public static void addToCollectionIfNotNull(Collection collection, Object value) {
 		if ( value != null && collection != null ) {
 			collection.add( value );
 		}
 	}
 
 
 	/**
 	 * @param t1 can't be null
 	 * @param t2 can't be null
 	 */
 	public static boolean targetEquals(AnnotationTarget t1, AnnotationTarget t2) {
 		if ( t1 == t2 ) {
 			return true;
 		}
 		if ( t1 != null && t2 != null ) {
 
 			if ( t1.getClass() == t2.getClass() ) {
 				if ( t1.getClass() == ClassInfo.class ) {
 					return ( (ClassInfo) t1 ).name().equals( ( (ClassInfo) t2 ).name() );
 				}
 				else if ( t1.getClass() == MethodInfo.class ) {
 					return ( (MethodInfo) t1 ).name().equals( ( (MethodInfo) t2 ).name() );
 				}
 				else {
 					return ( (FieldInfo) t1 ).name().equals( ( (FieldInfo) t2 ).name() );
 				}
 			}
 		}
 		return false;
 	}
 
 	public static boolean isNotEmpty(Collection collection) {
 		return collection != null && !collection.isEmpty();
 	}
 
 
 	static AnnotationInstance create(DotName name, AnnotationTarget target, List<AnnotationValue> annotationValueList) {
 		return create(
 				name, target, toArray( annotationValueList )
 		);
 
 	}
 
 	static String buildSafeClassName(String className, String defaultPackageName) {
 		if ( className.indexOf( '.' ) < 0 && StringHelper.isNotEmpty( defaultPackageName ) ) {
 			className = StringHelper.qualify( defaultPackageName, className );
 		}
 		return className;
 	}
 
 	static AnnotationInstance create(DotName name, AnnotationTarget target, AnnotationValue[] values) {
 		if ( values == null || values.length == 0 ) {
 			values = EMPTY_ANNOTATION_VALUE_ARRAY;
 		}
 		return AnnotationInstance.create( name, target, addMockMark( values ) );
 	}
 
 	private static AnnotationValue[] addMockMark(AnnotationValue[] values) {
 		AnnotationValue[] newValues = new AnnotationValue[values.length + 1];
 		System.arraycopy( values, 0, newValues, 0, values.length );
 		newValues[values.length] = booleanValue( "isMocked", true );
 		return newValues;
 	}
 
 
 	private static MethodInfo getMethodInfo(ClassInfo classInfo, Method method) {
 		Class returnTypeClass = method.getReturnType();
 		short access_flags = (short) method.getModifiers();
 		return MethodInfo.create(
 				classInfo,
 				method.getName(),
 				getTypes( method.getParameterTypes() ),
 				getType( returnTypeClass ),
 				access_flags
 		);
 	}
 
 	enum TargetType {METHOD, FIELD, PROPERTY}
 
 	static AnnotationTarget getTarget(ServiceRegistry serviceRegistry, ClassInfo classInfo, String name, TargetType type) {
 		Class clazz = serviceRegistry.getService( ClassLoaderService.class ).classForName( classInfo.toString() );
 		switch ( type ) {
 			case FIELD:
 				Field field = getField( clazz, name );
 				if ( field == null ) {
 					throw new HibernateException(
 							"Unable to load field "
 									+ name
 									+ " of class " + clazz.getName()
 					);
 				}
 
 				return FieldInfo.create(
 						classInfo, name, getType( field.getType() ), (short) ( field.getModifiers() )
 				);
 			case METHOD:
 				Method method = getMethod( clazz, name );
 				if ( method == null ) {
 					throw new HibernateException(
 							"Unable to load method "
 									+ name
 									+ " of class " + clazz.getName()
 					);
 				}
 				return getMethodInfo( classInfo, method );
 			case PROPERTY:
 				method = getterMethod( clazz, name );
 				if ( method == null ) {
 					throw new HibernateException(
 							"Unable to load property "
 									+ name
 									+ " of class " + clazz.getName()
 					);
 				}
 				return getMethodInfo( classInfo, method );
 
 		}
 		throw new HibernateException( "" );
 	}
 
 	//copied from org.hibernate.internal.util.ReflectHelper
 	private static Method getterMethod(Class theClass, String propertyName) {
 		Method[] methods = theClass.getDeclaredMethods();
 		Method.setAccessible( methods, true );
 		for ( Method method : methods ) {
 			// if the method has parameters, skip it
 			if ( method.getParameterTypes().length != 0 ) {
 				continue;
 			}
 			// if the method is a "bridge", skip it
 			if ( method.isBridge() ) {
 				continue;
 			}
 
 			final String methodName = method.getName();
 
 			// try "get"
 			if ( methodName.startsWith( "get" ) || methodName.startsWith( "has" ) ) {
 				String testStdMethod = Introspector.decapitalize( methodName.substring( 3 ) );
 				String testOldMethod = methodName.substring( 3 );
 				if ( testStdMethod.equals( propertyName ) || testOldMethod.equals( propertyName ) ) {
 					return method;
 				}
 			}
 
 			// if not "get", then try "is"
 			if ( methodName.startsWith( "is" ) ) {
 				String testStdMethod = Introspector.decapitalize( methodName.substring( 2 ) );
 				String testOldMethod = methodName.substring( 2 );
 				if ( testStdMethod.equals( propertyName ) || testOldMethod.equals( propertyName ) ) {
 					return method;
 				}
 			}
 		}
 
 		return null;
 	}
 
 
 	private static Method getMethod(Class theClass, String propertyName) {
 		Method[] methods = theClass.getDeclaredMethods();
 		Method.setAccessible( methods, true );
 		for ( Method method : methods ) {
 			// if the method has parameters, skip it
 			if ( method.getParameterTypes().length != 0 ) {
 				continue;
 			}
 			// if the method is a "bridge", skip it
 			if ( method.isBridge() ) {
 				continue;
 			}
 
 			final String methodName = method.getName();
 			if ( methodName.equals( propertyName ) ) {
 				return method;
 			}
 		}
 
 		return null;
 	}
 
 	private static Field getField(Class clazz, String name) {
 		Field[] fields = clazz.getDeclaredFields();
 		Field.setAccessible( fields, true );
 		for ( Field field : fields ) {
 			if ( field.getName().equals( name ) ) {
 				return field;
 			}
 		}
 		return null;
 	}
 
 	private static Type[] getTypes(Class[] classes) {
 		if ( classes == null || classes.length == 0 ) {
 			return EMPTY_TYPE_ARRAY;
 		}
 		Type[] types = new Type[classes.length];
 		for ( int i = 0; i < types.length; i++ ) {
 			types[i] = getType( classes[i] );
 		}
 		return types;
 	}
 
 
 	private static Type getType(String className, ServiceRegistry serviceRegistry) {
 		return getType( serviceRegistry.getService( ClassLoaderService.class ).classForName( className ) );
 	}
 
 	private static Type getType(Class clazz) {
 		return Type.create( DotName.createSimple( clazz.getName() ), getTypeKind( clazz ) );
 	}
 
 	private static Type.Kind getTypeKind(Class clazz) {
 		Type.Kind kind;
 		if ( clazz == Void.TYPE ) {
 			kind = Type.Kind.VOID;
 		}
 		else if ( clazz.isPrimitive() ) {
 			kind = Type.Kind.PRIMITIVE;
 		}
 		else if ( clazz.isArray() ) {
 			kind = Type.Kind.ARRAY;
 		}
 		else {
 			kind = Type.Kind.CLASS;
 		}
 		return kind;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/OneToManyMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/OneToManyMocker.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/OneToManyMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/OneToManyMocker.java
index 9156532217..71db95cd1f 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/OneToManyMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/OneToManyMocker.java
@@ -1,86 +1,86 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLOneToMany;
 
 /**
  * @author Strong Liu
  */
 class OneToManyMocker extends PropertyMocker {
 	private XMLOneToMany oneToMany;
 
 	OneToManyMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, XMLOneToMany oneToMany) {
 		super( indexBuilder, classInfo, defaults );
 		this.oneToMany = oneToMany;
 	}
 
 	@Override
 	protected String getFieldName() {
 		return oneToMany.getName();
 	}
 
 	@Override
 	protected void processExtra() {
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.classValue(
 				"targetEntity", oneToMany.getTargetEntity(), annotationValueList, indexBuilder.getServiceRegistry()
 		);
 		MockHelper.enumValue( "fetch", FETCH_TYPE, oneToMany.getFetch(), annotationValueList );
 		MockHelper.stringValue( "mappedBy", oneToMany.getMappedBy(), annotationValueList );
 		MockHelper.booleanValue( "orphanRemoval", oneToMany.isOrphanRemoval(), annotationValueList );
 		MockHelper.cascadeValue( "cascade", oneToMany.getCascade(), isDefaultCascadePersist(), annotationValueList );
 		create( ONE_TO_MANY, getTarget(), annotationValueList );
 		parserAttributeOverrides( oneToMany.getMapKeyAttributeOverride(), getTarget() );
 		parserMapKeyJoinColumnList( oneToMany.getMapKeyJoinColumn(), getTarget() );
 		parserMapKey( oneToMany.getMapKey(), getTarget() );
 		parserMapKeyColumn( oneToMany.getMapKeyColumn(), getTarget() );
 		parserMapKeyClass( oneToMany.getMapKeyClass(), getTarget() );
 		parserMapKeyTemporal( oneToMany.getMapKeyTemporal(), getTarget() );
 		parserMapKeyEnumerated( oneToMany.getMapKeyEnumerated(), getTarget() );
 		parserJoinColumnList( oneToMany.getJoinColumn(), getTarget() );
 		parserOrderColumn( oneToMany.getOrderColumn(), getTarget() );
 		parserJoinTable( oneToMany.getJoinTable(), getTarget() );
 		if ( oneToMany.getOrderBy() != null ) {
 			create( ORDER_BY, getTarget(), MockHelper.stringValueArray( "value", oneToMany.getOrderBy() ) );
 		}
 	}
 
 	@Override
 	protected XMLAccessType getAccessType() {
 		return oneToMany.getAccess();
 	}
 
 	@Override
 	protected void setAccessType(XMLAccessType accessType) {
 		oneToMany.setAccess( accessType );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/OneToOneMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/OneToOneMocker.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/OneToOneMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/OneToOneMocker.java
index 0ca0419018..076b7dee88 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/OneToOneMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/OneToOneMocker.java
@@ -1,84 +1,84 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLOneToOne;
 
 /**
  * @author Strong Liu
  */
 class OneToOneMocker extends PropertyMocker {
 	private XMLOneToOne oneToOne;
 
 	OneToOneMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, XMLOneToOne oneToOne) {
 		super( indexBuilder, classInfo, defaults );
 		this.oneToOne = oneToOne;
 	}
 
 	@Override
 	protected String getFieldName() {
 		return oneToOne.getName();
 	}
 
 	@Override
 	protected void processExtra() {
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.classValue(
 				"targetEntity", oneToOne.getTargetEntity(), annotationValueList, indexBuilder.getServiceRegistry()
 		);
 		MockHelper.enumValue( "fetch", FETCH_TYPE, oneToOne.getFetch(), annotationValueList );
 		MockHelper.booleanValue( "optional", oneToOne.isOptional(), annotationValueList );
 		MockHelper.booleanValue( "orphanRemoval", oneToOne.isOrphanRemoval(), annotationValueList );
 		MockHelper.stringValue( "mappedBy", oneToOne.getMappedBy(), annotationValueList );
 		MockHelper.cascadeValue( "cascade", oneToOne.getCascade(), isDefaultCascadePersist(), annotationValueList );
 		create( ONE_TO_ONE, annotationValueList );
 
 		parserPrimaryKeyJoinColumnList( oneToOne.getPrimaryKeyJoinColumn(), getTarget() );
 		parserJoinColumnList( oneToOne.getJoinColumn(), getTarget() );
 		parserJoinTable( oneToOne.getJoinTable(), getTarget() );
 		if ( oneToOne.getMapsId() != null ) {
 			create( MAPS_ID, MockHelper.stringValueArray( "value", oneToOne.getMapsId() ) );
 		}
 		if ( oneToOne.isId() != null && oneToOne.isId() ) {
 			create( ID );
 		}
 	}
 
 	@Override
 	protected XMLAccessType getAccessType() {
 		return oneToOne.getAccess();
 	}
 
 	@Override
 	protected void setAccessType(XMLAccessType accessType) {
 		oneToOne.setAccess( accessType );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/PersistenceMetadataMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/PersistenceMetadataMocker.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/PersistenceMetadataMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/PersistenceMetadataMocker.java
index 23f9f62a80..745d60cddd 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/PersistenceMetadataMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/PersistenceMetadataMocker.java
@@ -1,100 +1,100 @@
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.HashMap;
 import java.util.Map;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 
-import org.hibernate.metamodel.binder.source.annotations.xml.PseudoJpaDotNames;
+import org.hibernate.metamodel.source.annotations.xml.PseudoJpaDotNames;
 import org.hibernate.metamodel.source.annotation.xml.XMLPersistenceUnitDefaults;
 
 /**
  * @author Strong Liu
  */
 class PersistenceMetadataMocker extends AbstractMocker {
 	private final XMLPersistenceUnitDefaults persistenceUnitDefaults;
 	private final GlobalAnnotations globalAnnotations = new GlobalAnnotations();
 	/**
 	 * Map JPA Annotations name to Pseudo JPA Annotations name.
 	 */
 	private final static Map<DotName, DotName> nameMapper = new HashMap<DotName, DotName>();
 
 	static {
 		nameMapper.put( ACCESS, PseudoJpaDotNames.DEFAULT_ACCESS );
 		nameMapper.put( ENTITY_LISTENERS, PseudoJpaDotNames.DEFAULT_ENTITY_LISTENERS );
 		nameMapper.put( POST_LOAD, PseudoJpaDotNames.DEFAULT_POST_LOAD );
 		nameMapper.put( POST_REMOVE, PseudoJpaDotNames.DEFAULT_POST_REMOVE );
 		nameMapper.put( POST_UPDATE, PseudoJpaDotNames.DEFAULT_POST_UPDATE );
 		nameMapper.put( POST_PERSIST, PseudoJpaDotNames.DEFAULT_POST_PERSIST );
 		nameMapper.put( PRE_REMOVE, PseudoJpaDotNames.DEFAULT_PRE_REMOVE );
 		nameMapper.put( PRE_UPDATE, PseudoJpaDotNames.DEFAULT_PRE_UPDATE );
 		nameMapper.put( PRE_PERSIST, PseudoJpaDotNames.DEFAULT_PRE_PERSIST );
 		nameMapper.put(
 				PseudoJpaDotNames.DEFAULT_DELIMITED_IDENTIFIERS,
 				PseudoJpaDotNames.DEFAULT_DELIMITED_IDENTIFIERS
 		);
 	}
 
 	PersistenceMetadataMocker(IndexBuilder indexBuilder, XMLPersistenceUnitDefaults persistenceUnitDefaults) {
 		super( indexBuilder );
 		this.persistenceUnitDefaults = persistenceUnitDefaults;
 	}
 
 	/**
 	 * Mock global configurations defined in <persistence-unit-metadata> with pseudo JPA annotation name.
 	 * NOTE: These mocked annotations do not have {@link AnnotationTarget target}.
 	 */
 	final void process() {
 		parserAccessType( persistenceUnitDefaults.getAccess(), null );
 		if ( persistenceUnitDefaults.getDelimitedIdentifiers() != null ) {
 			create( PseudoJpaDotNames.DEFAULT_DELIMITED_IDENTIFIERS, null );
 		}
 		if ( persistenceUnitDefaults.getEntityListeners() != null ) {
 			new DefaultListenerMocker( indexBuilder, null ).parser( persistenceUnitDefaults.getEntityListeners() );
 		}
 		indexBuilder.finishGlobalConfigurationMocking( globalAnnotations );
 	}
 
 	@Override
 	protected AnnotationInstance push(AnnotationInstance annotationInstance) {
 		if ( annotationInstance != null ) {
 			return globalAnnotations.push( annotationInstance.name(), annotationInstance );
 		}
 		return null;
 	}
 
 	@Override
 	protected AnnotationInstance create(DotName name, AnnotationTarget target, AnnotationValue[] annotationValues) {
 		DotName defaultName = nameMapper.get( name );
 		if ( defaultName == null ) {
 			return null;
 		}
 		return super.create( defaultName, target, annotationValues );
 
 	}
 
 	private class DefaultListenerMocker extends ListenerMocker {
 		DefaultListenerMocker(IndexBuilder indexBuilder, ClassInfo classInfo) {
 			super( indexBuilder, classInfo );
 		}
 
 		@Override
 		protected AnnotationInstance push(AnnotationInstance annotationInstance) {
 			return PersistenceMetadataMocker.this.push( annotationInstance );
 		}
 
 		@Override
 		protected AnnotationInstance create(DotName name, AnnotationTarget target, AnnotationValue[] annotationValues) {
 			return PersistenceMetadataMocker.this.create( name, target, annotationValues );
 		}
 
 		@Override
 		protected ListenerMocker createListenerMocker(IndexBuilder indexBuilder, ClassInfo classInfo) {
 			return new DefaultListenerMocker( indexBuilder, classInfo );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/PropertyMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/PropertyMocker.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/PropertyMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/PropertyMocker.java
index e49028d622..7f029e1d2f 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/PropertyMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/PropertyMocker.java
@@ -1,244 +1,244 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 
 import org.hibernate.HibernateException;
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLEnumType;
 import org.hibernate.metamodel.source.annotation.xml.XMLMapKey;
 import org.hibernate.metamodel.source.annotation.xml.XMLMapKeyClass;
 import org.hibernate.metamodel.source.annotation.xml.XMLMapKeyColumn;
 import org.hibernate.metamodel.source.annotation.xml.XMLMapKeyJoinColumn;
 import org.hibernate.metamodel.source.annotation.xml.XMLTemporalType;
 
 /**
  * @author Strong Liu
  */
 abstract class PropertyMocker extends AnnotationMocker {
 	protected ClassInfo classInfo;
 	private AnnotationTarget target;
 
 	PropertyMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults) {
 		super( indexBuilder, defaults );
 		this.classInfo = classInfo;
 	}
 
 	protected abstract void processExtra();
 
 	protected abstract String getFieldName();
 
 	protected abstract XMLAccessType getAccessType();
 
 	protected abstract void setAccessType(XMLAccessType accessType);
 
 	@Override
 	protected DotName getTargetName() {
 		return classInfo.name();
 	}
 
 	protected void resolveTarget() {
 		//attribute in orm.xml has access sub-element
 		XMLAccessType accessType = getAccessType();
 		if ( accessType == null ) {
 			//attribute in the entity class has @Access
 			accessType = AccessHelper.getAccessFromAttributeAnnotation( getTargetName(), getFieldName(), indexBuilder );
 			if ( accessType == null ) {
 				accessType = AccessHelper.getEntityAccess( getTargetName(), indexBuilder );
 			}
 			if ( accessType == null ) {
 				accessType = AccessHelper.getAccessFromIdPosition( getTargetName(), indexBuilder );
 			}
 			if (accessType == null ) {
 				//this should only for determin @Id position
 				accessType = AccessHelper.getAccessFromDefault( indexBuilder );
 			}
 			if ( accessType == null ) {
 				accessType = XMLAccessType.PROPERTY;
 
 			}
 			setAccessType( accessType );
 		}
 
 	}
 
 	@Override
 	protected AnnotationTarget getTarget() {
 		if ( target == null ) {
 			target = getTargetFromAttributeAccessType( getAccessType() );
 		}
 		return target;
 	}
 
 	protected AnnotationTarget getTargetFromAttributeAccessType(XMLAccessType accessType) {
 		if ( accessType == null ) {
 			throw new IllegalArgumentException( "access type can't be null." );
 		}
 		switch ( accessType ) {
 			case FIELD:
 				return MockHelper.getTarget(
 						indexBuilder.getServiceRegistry(),
 						classInfo,
 						getFieldName(),
 						MockHelper.TargetType.FIELD
 				);
 			case PROPERTY:
 				return MockHelper.getTarget(
 						indexBuilder.getServiceRegistry(),
 						classInfo,
 						getFieldName(),
 						MockHelper.TargetType.PROPERTY
 				);
 			default:
 				throw new HibernateException( "can't determin access type [" + accessType + "]" );
 		}
 	}
 
 
 	@Override
 	final void process() {
 		resolveTarget();
 		processExtra();
 	}
 
 	protected AnnotationInstance parserMapKeyColumn(XMLMapKeyColumn mapKeyColumn, AnnotationTarget target) {
 		if ( mapKeyColumn == null ) {
 			return null;
 		}
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", mapKeyColumn.getName(), annotationValueList );
 		MockHelper.stringValue( "columnDefinition", mapKeyColumn.getColumnDefinition(), annotationValueList );
 		MockHelper.stringValue( "table", mapKeyColumn.getTable(), annotationValueList );
 		MockHelper.booleanValue( "nullable", mapKeyColumn.isNullable(), annotationValueList );
 		MockHelper.booleanValue( "insertable", mapKeyColumn.isInsertable(), annotationValueList );
 		MockHelper.booleanValue( "updatable", mapKeyColumn.isUpdatable(), annotationValueList );
 		MockHelper.booleanValue( "unique", mapKeyColumn.isUnique(), annotationValueList );
 		MockHelper.integerValue( "length", mapKeyColumn.getLength(), annotationValueList );
 		MockHelper.integerValue( "precision", mapKeyColumn.getPrecision(), annotationValueList );
 		MockHelper.integerValue( "scale", mapKeyColumn.getScale(), annotationValueList );
 		return create( MAP_KEY_COLUMN, target, annotationValueList );
 	}
 
 	protected AnnotationInstance parserMapKeyClass(XMLMapKeyClass mapKeyClass, AnnotationTarget target) {
 		if ( mapKeyClass == null ) {
 			return null;
 		}
 		return create(
 				MAP_KEY_CLASS, target, MockHelper.classValueArray(
 				"value", mapKeyClass.getClazz(), indexBuilder.getServiceRegistry()
 		)
 		);
 	}
 
 	protected AnnotationInstance parserMapKeyTemporal(XMLTemporalType temporalType, AnnotationTarget target) {
 		if ( temporalType == null ) {
 			return null;
 		}
 		return create(
 				MAP_KEY_TEMPORAL, target,
 				MockHelper.enumValueArray( "value", TEMPORAL_TYPE, temporalType )
 		);
 	}
 
 	protected AnnotationInstance parserMapKeyEnumerated(XMLEnumType enumType, AnnotationTarget target) {
 		if ( enumType == null ) {
 			return null;
 		}
 		return create(
 				MAP_KEY_ENUMERATED, target,
 				MockHelper.enumValueArray( "value", ENUM_TYPE, enumType )
 		);
 	}
 
 	protected AnnotationInstance parserMapKey(XMLMapKey mapKey, AnnotationTarget target) {
 		if ( mapKey == null ) {
 			return null;
 		}
 		return create( MAP_KEY, target, MockHelper.stringValueArray( "name", mapKey.getName() ) );
 	}
 
 	private AnnotationValue[] nestedMapKeyJoinColumnList(String name, List<XMLMapKeyJoinColumn> columns, List<AnnotationValue> annotationValueList) {
 		if ( MockHelper.isNotEmpty( columns ) ) {
 			AnnotationValue[] values = new AnnotationValue[columns.size()];
 			for ( int i = 0; i < columns.size(); i++ ) {
 				AnnotationInstance annotationInstance = parserMapKeyJoinColumn( columns.get( i ), null );
 				values[i] = MockHelper.nestedAnnotationValue(
 						"", annotationInstance
 				);
 			}
 			MockHelper.addToCollectionIfNotNull(
 					annotationValueList, AnnotationValue.createArrayValue( name, values )
 			);
 			return values;
 		}
 		return MockHelper.EMPTY_ANNOTATION_VALUE_ARRAY;
 	}
 
 	protected AnnotationInstance parserMapKeyJoinColumnList(List<XMLMapKeyJoinColumn> joinColumnList, AnnotationTarget target) {
 		if ( MockHelper.isNotEmpty( joinColumnList ) ) {
 			if ( joinColumnList.size() == 1 ) {
 				return parserMapKeyJoinColumn( joinColumnList.get( 0 ), target );
 			}
 			else {
 				AnnotationValue[] values = nestedMapKeyJoinColumnList( "value", joinColumnList, null );
 				return create(
 						MAP_KEY_JOIN_COLUMNS,
 						target,
 						values
 				);
 			}
 		}
 		return null;
 
 	}
 
 	//@MapKeyJoinColumn
 	private AnnotationInstance parserMapKeyJoinColumn(XMLMapKeyJoinColumn column, AnnotationTarget target) {
 		if ( column == null ) {
 			return null;
 		}
 		List<AnnotationValue> annotationValueList = new ArrayList<AnnotationValue>();
 		MockHelper.stringValue( "name", column.getName(), annotationValueList );
 		MockHelper.stringValue( "columnDefinition", column.getColumnDefinition(), annotationValueList );
 		MockHelper.stringValue( "table", column.getTable(), annotationValueList );
 		MockHelper.stringValue(
 				"referencedColumnName", column.getReferencedColumnName(), annotationValueList
 		);
 		MockHelper.booleanValue( "unique", column.isUnique(), annotationValueList );
 		MockHelper.booleanValue( "nullable", column.isNullable(), annotationValueList );
 		MockHelper.booleanValue( "insertable", column.isInsertable(), annotationValueList );
 		MockHelper.booleanValue( "updatable", column.isUpdatable(), annotationValueList );
 		return create( MAP_KEY_JOIN_COLUMN, target, annotationValueList );
 	}
 
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/SchemaAware.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/SchemaAware.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/SchemaAware.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/SchemaAware.java
index 42493634d6..69cfc9e97d 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/SchemaAware.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/SchemaAware.java
@@ -1,154 +1,154 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLCollectionTable;
 import org.hibernate.metamodel.source.annotation.xml.XMLJoinTable;
 import org.hibernate.metamodel.source.annotation.xml.XMLSecondaryTable;
 import org.hibernate.metamodel.source.annotation.xml.XMLTable;
 
 /**
  * @author Strong Liu
  */
 interface SchemaAware {
 	String getSchema();
 
 	void setSchema(String schema);
 
 	String getCatalog();
 
 	void setCatalog(String catalog);
 
 	static class SecondaryTableSchemaAware implements SchemaAware {
 		private XMLSecondaryTable table;
 
 		SecondaryTableSchemaAware(XMLSecondaryTable table) {
 			this.table = table;
 		}
 
 		@Override
 		public String getCatalog() {
 			return table.getCatalog();
 		}
 
 		@Override
 		public String getSchema() {
 			return table.getSchema();
 		}
 
 		@Override
 		public void setSchema(String schema) {
 			table.setSchema( schema );
 		}
 
 		@Override
 		public void setCatalog(String catalog) {
 			table.setCatalog( catalog );
 		}
 	}
 
 	static class TableSchemaAware implements SchemaAware {
 		private XMLTable table;
 
 		public TableSchemaAware(XMLTable table) {
 			this.table = table;
 		}
 
 		@Override
 		public String getCatalog() {
 			return table.getCatalog();
 		}
 
 		@Override
 		public String getSchema() {
 			return table.getSchema();
 		}
 
 		@Override
 		public void setSchema(String schema) {
 			table.setSchema( schema );
 		}
 
 		@Override
 		public void setCatalog(String catalog) {
 			table.setCatalog( catalog );
 		}
 	}
 
 	static class JoinTableSchemaAware implements SchemaAware {
 		private XMLJoinTable table;
 
 		public JoinTableSchemaAware(XMLJoinTable table) {
 			this.table = table;
 		}
 
 		@Override
 		public String getCatalog() {
 			return table.getCatalog();
 		}
 
 		@Override
 		public String getSchema() {
 			return table.getSchema();
 		}
 
 		@Override
 		public void setSchema(String schema) {
 			table.setSchema( schema );
 		}
 
 		@Override
 		public void setCatalog(String catalog) {
 			table.setCatalog( catalog );
 		}
 	}
 
 	static class CollectionTableSchemaAware implements SchemaAware {
 		private XMLCollectionTable table;
 
 		public CollectionTableSchemaAware(XMLCollectionTable table) {
 			this.table = table;
 		}
 
 		@Override
 		public String getCatalog() {
 			return table.getCatalog();
 		}
 
 		@Override
 		public String getSchema() {
 			return table.getSchema();
 		}
 
 		@Override
 		public void setSchema(String schema) {
 			table.setSchema( schema );
 		}
 
 		@Override
 		public void setCatalog(String catalog) {
 			table.setCatalog( catalog );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/TransientMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/TransientMocker.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/TransientMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/TransientMocker.java
index 0c631e4a9c..2f3e1767ff 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/TransientMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/TransientMocker.java
@@ -1,61 +1,61 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLTransient;
 
 /**
  * @author Strong Liu
  */
 class TransientMocker extends PropertyMocker {
 	private XMLTransient transientObj;
 
 	TransientMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, XMLTransient transientObj) {
 		super( indexBuilder, classInfo, defaults );
 		this.transientObj = transientObj;
 	}
 
 	@Override
 	protected void processExtra() {
 		create( TRANSIENT );
 	}
 
 	@Override
 	protected String getFieldName() {
 		return transientObj.getName();
 	}
 
 	@Override
 	protected XMLAccessType getAccessType() {
 		return XMLAccessType.FIELD;
 	}
 
 	@Override
 	protected void setAccessType(XMLAccessType accessType) {
 		//ignore
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/VersionMocker.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/VersionMocker.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/VersionMocker.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/VersionMocker.java
index 6d72a924d3..90d4bc22fd 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/VersionMocker.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/VersionMocker.java
@@ -1,63 +1,63 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import org.jboss.jandex.ClassInfo;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAccessType;
 import org.hibernate.metamodel.source.annotation.xml.XMLVersion;
 
 /**
  * @author Strong Liu
  */
 class VersionMocker extends PropertyMocker {
 	private XMLVersion version;
 
 	VersionMocker(IndexBuilder indexBuilder, ClassInfo classInfo, EntityMappingsMocker.Default defaults, XMLVersion version) {
 		super( indexBuilder, classInfo, defaults );
 		this.version = version;
 	}
 
 	@Override
 	protected String getFieldName() {
 		return version.getName();
 	}
 
 	@Override
 	protected void processExtra() {
 		create( VERSION );
 		parserColumn( version.getColumn(), getTarget() );
 		parserTemporalType( version.getTemporal(), getTarget() );
 	}
 
 	@Override
 	protected XMLAccessType getAccessType() {
 		return version.getAccess();
 	}
 
 	@Override
 	protected void setAccessType(XMLAccessType accessType) {
 		version.setAccess( accessType );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/AbstractSubEntityContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/AbstractSubEntityContainer.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/AbstractSubEntityContainer.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/AbstractSubEntityContainer.java
index e299e72e4a..620122e3ee 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/AbstractSubEntityContainer.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/AbstractSubEntityContainer.java
@@ -1,48 +1,48 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm;
+package org.hibernate.metamodel.source.hbm;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
 /**
  * @author Steve Ebersole
  */
 public class AbstractSubEntityContainer implements SubEntityContainer {
 	private List<EntityHierarchySubEntity> subEntityDescriptors;
 
 	public void addSubEntityDescriptor(EntityHierarchySubEntity subEntityDescriptor) {
 		if ( subEntityDescriptors == null ) {
 			subEntityDescriptors = new ArrayList<EntityHierarchySubEntity>();
 		}
 		subEntityDescriptors.add( subEntityDescriptor );
 	}
 
 	public Iterable<EntityHierarchySubEntity> subEntityDescriptors() {
 		return subEntityDescriptors == null
 				? Collections.<EntityHierarchySubEntity>emptyList()
 				: subEntityDescriptors;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/BindingCreator.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/BindingCreator.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/BindingCreator.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/BindingCreator.java
index b3bfb13913..5bf17a2b6f 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/BindingCreator.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/BindingCreator.java
@@ -1,863 +1,865 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm;
+package org.hibernate.metamodel.source.hbm;
 
 import java.beans.BeanInfo;
 import java.beans.PropertyDescriptor;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Stack;
 
 import org.hibernate.EntityMode;
 import org.hibernate.cache.spi.access.AccessType;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.engine.OptimisticLockStyle;
 import org.hibernate.internal.util.Value;
 import org.hibernate.internal.util.beans.BeanInfoHelper;
 import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.binder.MappingException;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.hbm.xml.mapping.EntityElement;
-import org.hibernate.metamodel.binder.source.hbm.xml.mapping.JoinElementSource;
-import org.hibernate.metamodel.binder.source.hbm.xml.mapping.SubEntityElement;
+import org.hibernate.metamodel.domain.SingularAttribute;
+import org.hibernate.metamodel.source.MappingException;
+import org.hibernate.metamodel.source.MetadataImplementor;
+import org.hibernate.metamodel.source.annotations.attribute.SimpleAttribute;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.EntityElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.JoinElementSource;
 import org.hibernate.metamodel.binding.BagBinding;
 import org.hibernate.metamodel.binding.Caching;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.binding.InheritanceType;
 import org.hibernate.metamodel.binding.SimpleAttributeBinding;
 import org.hibernate.metamodel.binding.TypeDef;
 import org.hibernate.metamodel.domain.AbstractAttributeContainer;
 import org.hibernate.metamodel.domain.Attribute;
 import org.hibernate.metamodel.domain.Entity;
 import org.hibernate.metamodel.relational.Column;
 import org.hibernate.metamodel.relational.Identifier;
 import org.hibernate.metamodel.relational.Schema;
 import org.hibernate.metamodel.relational.SimpleValue;
 import org.hibernate.metamodel.relational.Size;
 import org.hibernate.metamodel.relational.TableSpecification;
 import org.hibernate.metamodel.relational.Tuple;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLAnyElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLBagElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLCacheElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLColumnElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLComponentElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLDynamicComponentElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLIdbagElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLJoinElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLJoinedSubclassElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLListElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLManyToOneElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLMapElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLOneToOneElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLParamElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLPropertiesElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLPropertyElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSetElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSqlDeleteElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSqlInsertElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSqlUpdateElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSubclassElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSynchronizeElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLTuplizerElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLUnionSubclassElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLAnyElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLBagElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLCacheElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLColumnElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLComponentElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLDynamicComponentElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLIdbagElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLJoinElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLJoinedSubclassElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLListElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLManyToOneElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLMapElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLOneToOneElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLParamElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLPropertiesElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLPropertyElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSetElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSqlDeleteElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSqlInsertElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSqlUpdateElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSubclassElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSynchronizeElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLTuplizerElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLUnionSubclassElement;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.tuple.entity.EntityTuplizer;
 
 /**
  * @author Steve Ebersole
  */
 public class BindingCreator {
 	private final MetadataImplementor metadata;
 	private final List<String> processedEntityNames;
 
 	private InheritanceType currentInheritanceType;
 	private HbmBindingContext currentBindingContext;
 
 	public BindingCreator(MetadataImplementor metadata, List<String> processedEntityNames) {
 		this.metadata = metadata;
 		this.processedEntityNames = processedEntityNames;
 	}
 
 	// todo : currently this does not allow inheritance across hbm/annotations.  Do we need to?
 
 	public void processEntityHierarchy(EntityHierarchy entityHierarchy) {
 		currentInheritanceType = entityHierarchy.getHierarchyInheritanceType();
 		EntityBinding rootEntityBinding = createEntityBinding( entityHierarchy.getEntitySourceInformation(), null );
 		if ( currentInheritanceType != InheritanceType.NO_INHERITANCE ) {
 			processHierarchySubEntities( entityHierarchy, rootEntityBinding );
 		}
 	}
 
 	private void processHierarchySubEntities(SubEntityContainer subEntityContainer, EntityBinding superEntityBinding) {
 		for ( EntityHierarchySubEntity subEntity : subEntityContainer.subEntityDescriptors() ) {
 			EntityBinding entityBinding = createEntityBinding( subEntity.getEntitySourceInformation(), superEntityBinding );
 			processHierarchySubEntities( subEntity, entityBinding );
 		}
 	}
 
 	private EntityBinding createEntityBinding(EntitySourceInformation entitySourceInfo, EntityBinding superEntityBinding) {
 		if ( processedEntityNames.contains( entitySourceInfo.getMappedEntityName() ) ) {
 			return metadata.getEntityBinding( entitySourceInfo.getMappedEntityName() );
 		}
 
 		currentBindingContext = entitySourceInfo.getSourceMappingDocument().getMappingLocalBindingContext();
 		try {
 			final EntityBinding entityBinding = doCreateEntityBinding( entitySourceInfo, superEntityBinding );
 
 			metadata.addEntity( entityBinding );
 			processedEntityNames.add( entityBinding.getEntity().getName() );
 			return entityBinding;
 		}
 		finally {
 			currentBindingContext = null;
 		}
 	}
 
 	private EntityBinding doCreateEntityBinding(EntitySourceInformation entitySourceInfo, EntityBinding superEntityBinding) {
 		final EntityBinding entityBinding = createBasicEntityBinding( entitySourceInfo, superEntityBinding );
 
 		bindPrimaryTable( entitySourceInfo, entityBinding );
 		bindAttributes( entitySourceInfo, entityBinding );
 		bindSecondaryTables( entitySourceInfo, entityBinding );
 		bindTableUniqueConstraints( entityBinding );
 
 		return entityBinding;
 	}
 
 	private EntityBinding createBasicEntityBinding(
 			EntitySourceInformation entitySourceInfo,
 			EntityBinding superEntityBinding) {
 		if ( superEntityBinding == null ) {
 			return makeRootEntityBinding( entitySourceInfo );
 		}
 		else {
 			if ( currentInheritanceType == InheritanceType.SINGLE_TABLE ) {
 				return makeDiscriminatedSubclassBinding( entitySourceInfo, superEntityBinding );
 			}
 			else if ( currentInheritanceType == InheritanceType.JOINED ) {
 				return makeJoinedSubclassBinding( entitySourceInfo, superEntityBinding );
 			}
 			else if ( currentInheritanceType == InheritanceType.TABLE_PER_CLASS ) {
 				return makeUnionedSubclassBinding( entitySourceInfo, superEntityBinding );
 			}
 			else {
 				// extreme internal error!
 				throw new RuntimeException( "Internal condition failure" );
 			}
 		}
 	}
 
 	private EntityBinding makeRootEntityBinding(EntitySourceInformation entitySourceInfo) {
 		final EntityBinding entityBinding = new EntityBinding();
 		// todo : this is actually not correct
 		// 		the problem is that we need to know whether we have mapped subclasses which happens later
 		//		one option would be to simply reset the InheritanceType at that time.
 		entityBinding.setInheritanceType( currentInheritanceType );
 		entityBinding.setRoot( true );
 
 		final XMLHibernateMapping.XMLClass xmlClass = (XMLHibernateMapping.XMLClass) entitySourceInfo.getEntityElement();
 		final String entityName = entitySourceInfo.getMappedEntityName();
 		final String verbatimClassName = xmlClass.getName();
 
 		final EntityMode entityMode = verbatimClassName == null ? EntityMode.MAP : EntityMode.POJO;
 		entityBinding.setEntityMode( entityMode );
 
 		final String className;
 		if ( entityMode == EntityMode.POJO ) {
 			className = entitySourceInfo.getSourceMappingDocument()
 					.getMappingLocalBindingContext()
 					.qualifyClassName( verbatimClassName );
 		}
 		else {
 			className = null;
 		}
 
 		Entity entity = new Entity(
 				entityName,
 				className,
 				entitySourceInfo.getSourceMappingDocument().getMappingLocalBindingContext().makeClassReference( className ),
 				null
 		);
 		entityBinding.setEntity( entity );
 
 		performBasicEntityBind( entityBinding, entitySourceInfo );
 
 		entityBinding.setMutable( xmlClass.isMutable() );
 		entityBinding.setExplicitPolymorphism( "explicit".equals( xmlClass.getPolymorphism() ) );
 		entityBinding.setWhereFilter( xmlClass.getWhere() );
 		entityBinding.setRowId( xmlClass.getRowid() );
 		entityBinding.setOptimisticLockStyle( interpretOptimisticLockStyle( entitySourceInfo ) );
 		entityBinding.setCaching( interpretCaching( entitySourceInfo ) );
 
 		return entityBinding;
 	}
 
 	private OptimisticLockStyle interpretOptimisticLockStyle(EntitySourceInformation entitySourceInfo) {
 		final String optimisticLockModeString = Helper.getStringValue(
 				( (XMLHibernateMapping.XMLClass) entitySourceInfo.getEntityElement() ).getOptimisticLock(),
 				"version"
 		);
 		try {
 			return OptimisticLockStyle.valueOf( optimisticLockModeString.toUpperCase() );
 		}
 		catch (Exception e) {
 			throw new MappingException(
 					"Unknown optimistic-lock value : " + optimisticLockModeString,
 					entitySourceInfo.getSourceMappingDocument().getOrigin()
 			);
 		}
 	}
 
 	private static Caching interpretCaching(EntitySourceInformation entitySourceInfo) {
 		final XMLCacheElement cache = ( (XMLHibernateMapping.XMLClass) entitySourceInfo.getEntityElement() ).getCache();
 		if ( cache == null ) {
 			return null;
 		}
 		final String region = cache.getRegion() != null ? cache.getRegion() : entitySourceInfo.getMappedEntityName();
 		final AccessType accessType = Enum.valueOf( AccessType.class, cache.getUsage() );
 		final boolean cacheLazyProps = !"non-lazy".equals( cache.getInclude() );
 		return new Caching( region, accessType, cacheLazyProps );
 	}
 
 	private EntityBinding makeDiscriminatedSubclassBinding(
 			EntitySourceInformation entitySourceInfo,
 			EntityBinding superEntityBinding) {
 		// temporary!!!
 
 		final EntityBinding entityBinding = new EntityBinding();
 		entityBinding.setInheritanceType( InheritanceType.SINGLE_TABLE );
 		bindSuperType( entityBinding, superEntityBinding );
 
 		final String verbatimClassName = entitySourceInfo.getEntityElement().getName();
 
 		final EntityMode entityMode = verbatimClassName == null ? EntityMode.MAP : EntityMode.POJO;
 		entityBinding.setEntityMode( entityMode );
 
 		final String className;
 		if ( entityMode == EntityMode.POJO ) {
 			className = entitySourceInfo.getSourceMappingDocument().getMappingLocalBindingContext().qualifyClassName( verbatimClassName );
 		}
 		else {
 			className = null;
 		}
 
 		final Entity entity = new Entity(
 				entitySourceInfo.getMappedEntityName(),
 				className,
 				entitySourceInfo.getSourceMappingDocument().getMappingLocalBindingContext().makeClassReference( className ),
 				null
 		);
 		entityBinding.setEntity( entity );
 
 
 		performBasicEntityBind( entityBinding, entitySourceInfo );
 
 		return entityBinding;
 	}
 
 	private EntityBinding makeJoinedSubclassBinding(
 			EntitySourceInformation entitySourceInfo,
 			EntityBinding superEntityBinding) {
 		// temporary!!!
 
 		final EntityBinding entityBinding = new EntityBinding();
 		entityBinding.setInheritanceType( InheritanceType.JOINED );
 		bindSuperType( entityBinding, superEntityBinding );
 
 		final XMLJoinedSubclassElement joinedEntityElement = (XMLJoinedSubclassElement) entitySourceInfo.getEntityElement();
 		final HbmBindingContext bindingContext = entitySourceInfo.getSourceMappingDocument().getMappingLocalBindingContext();
 
 		final String entityName = bindingContext.determineEntityName( joinedEntityElement );
 		final String verbatimClassName = joinedEntityElement.getName();
 
 		final EntityMode entityMode = verbatimClassName == null ? EntityMode.MAP : EntityMode.POJO;
 		entityBinding.setEntityMode( entityMode );
 
 		final String className;
 		if ( entityMode == EntityMode.POJO ) {
 			className = bindingContext.qualifyClassName( verbatimClassName );
 		}
 		else {
 			className = null;
 		}
 
 		final Entity entity = new Entity( entityName, className, bindingContext.makeClassReference( className ), null );
 		entityBinding.setEntity( entity );
 
 		performBasicEntityBind( entityBinding, entitySourceInfo );
 
 		return entityBinding;
 	}
 
 	private EntityBinding makeUnionedSubclassBinding(
 			EntitySourceInformation entitySourceInfo,
 			EntityBinding superEntityBinding) {
 		// temporary!!!
 
 		final EntityBinding entityBinding = new EntityBinding();
 		entityBinding.setInheritanceType( InheritanceType.TABLE_PER_CLASS );
 		bindSuperType( entityBinding, superEntityBinding );
 
 		final XMLUnionSubclassElement unionEntityElement = (XMLUnionSubclassElement) entitySourceInfo.getEntityElement();
 		final HbmBindingContext bindingContext = entitySourceInfo.getSourceMappingDocument().getMappingLocalBindingContext();
 
 		final String entityName = bindingContext.determineEntityName( unionEntityElement );
 		final String verbatimClassName = unionEntityElement.getName();
 
 		final EntityMode entityMode = verbatimClassName == null ? EntityMode.MAP : EntityMode.POJO;
 		entityBinding.setEntityMode( entityMode );
 
 		final String className;
 		if ( entityMode == EntityMode.POJO ) {
 			className = bindingContext.qualifyClassName( verbatimClassName );
 		}
 		else {
 			className = null;
 		}
 
 		final Entity entity = new Entity( entityName, className, bindingContext.makeClassReference( className ), null );
 		entityBinding.setEntity( entity );
 
 		performBasicEntityBind( entityBinding, entitySourceInfo );
 
 		return entityBinding;
 	}
 
 	private void bindSuperType(EntityBinding entityBinding, EntityBinding superEntityBinding) {
 //		entityBinding.setSuperEntityBinding( superEntityBinding );
 //		// not sure what to do with the domain model super type...
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	private void performBasicEntityBind(EntityBinding entityBinding, EntitySourceInformation entitySourceInfo) {
 		entityBinding.setJpaEntityName( null );
 
 		final EntityElement entityElement = entitySourceInfo.getEntityElement();
 		final HbmBindingContext bindingContext = entitySourceInfo.getSourceMappingDocument().getMappingLocalBindingContext();
 
 		final String proxy = entityElement.getProxy();
 		final boolean isLazy = entityElement.isLazy() == null
 				? true
 				: entityElement.isLazy();
 		if ( entityBinding.getEntityMode() == EntityMode.POJO ) {
 			if ( proxy != null ) {
 				entityBinding.setProxyInterfaceType(
 						bindingContext.makeClassReference(
 								bindingContext.qualifyClassName( proxy )
 						)
 				);
 				entityBinding.setLazy( true );
 			}
 			else if ( isLazy ) {
 				entityBinding.setProxyInterfaceType( entityBinding.getEntity().getClassReferenceUnresolved() );
 				entityBinding.setLazy( true );
 			}
 		}
 		else {
 			entityBinding.setProxyInterfaceType( new Value( Map.class ) );
 			entityBinding.setLazy( isLazy );
 		}
 
 		final String customTuplizerClassName = extractCustomTuplizerClassName(
 				entityElement,
 				entityBinding.getEntityMode()
 		);
 		if ( customTuplizerClassName != null ) {
 			entityBinding.setCustomEntityTuplizerClass( bindingContext.<EntityTuplizer>locateClassByName( customTuplizerClassName ) );
 		}
 
 		if ( entityElement.getPersister() != null ) {
 			entityBinding.setCustomEntityPersisterClass( bindingContext.<EntityPersister>locateClassByName( entityElement.getPersister() ) );
 		}
 
 		entityBinding.setMetaAttributeContext(
 				Helper.extractMetaAttributeContext(
 						entityElement.getMeta(), true, bindingContext.getMetaAttributeContext()
 				)
 		);
 
 		entityBinding.setDynamicUpdate( entityElement.isDynamicUpdate() );
 		entityBinding.setDynamicInsert( entityElement.isDynamicInsert() );
 		entityBinding.setBatchSize( Helper.getIntValue( entityElement.getBatchSize(), 0 ) );
 		entityBinding.setSelectBeforeUpdate( entityElement.isSelectBeforeUpdate() );
 		entityBinding.setAbstract( entityElement.isAbstract() );
 
 		if ( entityElement.getLoader() != null ) {
 			entityBinding.setCustomLoaderName( entityElement.getLoader().getQueryRef() );
 		}
 
 		final XMLSqlInsertElement sqlInsert = entityElement.getSqlInsert();
 		if ( sqlInsert != null ) {
 			entityBinding.setCustomInsert( Helper.buildCustomSql( sqlInsert ) );
 		}
 
 		final XMLSqlDeleteElement sqlDelete = entityElement.getSqlDelete();
 		if ( sqlDelete != null ) {
 			entityBinding.setCustomDelete( Helper.buildCustomSql( sqlDelete ) );
 		}
 
 		final XMLSqlUpdateElement sqlUpdate = entityElement.getSqlUpdate();
 		if ( sqlUpdate != null ) {
 			entityBinding.setCustomUpdate( Helper.buildCustomSql( sqlUpdate ) );
 		}
 
 		if ( entityElement.getSynchronize() != null ) {
 			for ( XMLSynchronizeElement synchronize : entityElement.getSynchronize() ) {
 				entityBinding.addSynchronizedTable( synchronize.getTable() );
 			}
 		}
 	}
 
 	private String extractCustomTuplizerClassName(EntityElement entityMapping, EntityMode entityMode) {
 		if ( entityMapping.getTuplizer() == null ) {
 			return null;
 		}
 		for ( XMLTuplizerElement tuplizerElement : entityMapping.getTuplizer() ) {
 			if ( entityMode == EntityMode.parse( tuplizerElement.getEntityMode() ) ) {
 				return tuplizerElement.getClazz();
 			}
 		}
 		return null;
 	}
 
 	private void bindPrimaryTable(EntitySourceInformation entitySourceInformation, EntityBinding entityBinding) {
 		final EntityElement entityElement = entitySourceInformation.getEntityElement();
 		final HbmBindingContext bindingContext = entitySourceInformation.getSourceMappingDocument().getMappingLocalBindingContext();
 
 		if ( XMLSubclassElement.class.isInstance( entityElement ) ) {
 			// todo : need to look it up from root entity, or have persister manage it
 		}
 		else {
 			// todo : add mixin interface
 			final String explicitTableName;
 			final String explicitSchemaName;
 			final String explicitCatalogName;
 			if ( XMLHibernateMapping.XMLClass.class.isInstance( entityElement ) ) {
 				explicitTableName = ( (XMLHibernateMapping.XMLClass) entityElement ).getTable();
 				explicitSchemaName = ( (XMLHibernateMapping.XMLClass) entityElement ).getSchema();
 				explicitCatalogName = ( (XMLHibernateMapping.XMLClass) entityElement ).getCatalog();
 			}
 			else if ( XMLJoinedSubclassElement.class.isInstance( entityElement ) ) {
 				explicitTableName = ( (XMLJoinedSubclassElement) entityElement ).getTable();
 				explicitSchemaName = ( (XMLJoinedSubclassElement) entityElement ).getSchema();
 				explicitCatalogName = ( (XMLJoinedSubclassElement) entityElement ).getCatalog();
 			}
 			else if ( XMLUnionSubclassElement.class.isInstance( entityElement ) ) {
 				explicitTableName = ( (XMLUnionSubclassElement) entityElement ).getTable();
 				explicitSchemaName = ( (XMLUnionSubclassElement) entityElement ).getSchema();
 				explicitCatalogName = ( (XMLUnionSubclassElement) entityElement ).getCatalog();
 			}
 			else {
 				// throw up
 				explicitTableName = null;
 				explicitSchemaName = null;
 				explicitCatalogName = null;
 			}
 			final NamingStrategy namingStrategy = bindingContext.getMetadataImplementor()
 					.getOptions()
 					.getNamingStrategy();
 			final String tableName = explicitTableName != null
 					? namingStrategy.tableName( explicitTableName )
 					: namingStrategy.tableName( namingStrategy.classToTableName( entityBinding.getEntity().getName() ) );
 
 			final String schemaName = explicitSchemaName == null
 					? bindingContext.getMappingDefaults().getSchemaName()
 					: explicitSchemaName;
 			final String catalogName = explicitCatalogName == null
 					? bindingContext.getMappingDefaults().getCatalogName()
 					: explicitCatalogName;
 
 			final Schema schema = metadata.getDatabase().getSchema( new Schema.Name( schemaName, catalogName ) );
 			entityBinding.setBaseTable( schema.locateOrCreateTable( Identifier.toIdentifier( tableName ) ) );
 		}
 	}
 
 
 	private Stack<TableSpecification> attributeColumnTableStack = new Stack<TableSpecification>();
 
 	private void bindAttributes(final EntitySourceInformation entitySourceInformation, EntityBinding entityBinding) {
 		// todo : we really need the notion of a Stack here for the table from which the columns come for binding these attributes.
 		// todo : adding the concept (interface) of a source of attribute metadata would allow reuse of this method for entity, component, unique-key, etc
 		// for now, simply assume all columns come from the base table....
 
 		attributeColumnTableStack.push( entityBinding.getBaseTable() );
 		try {
 			bindAttributes(
 					new AttributeMetadataContainer() {
 						@Override
 						public List<Object> getAttributeElements() {
 							return entitySourceInformation.getEntityElement().getPropertyOrManyToOneOrOneToOne();
 						}
 					},
 					entityBinding
 			);
 		}
 		finally {
 			attributeColumnTableStack.pop();
 		}
 
 	}
 
 	private void bindAttributes(AttributeMetadataContainer attributeMetadataContainer, EntityBinding entityBinding) {
 		for ( Object attribute : attributeMetadataContainer.getAttributeElements() ) {
 
 			if ( XMLPropertyElement.class.isInstance( attribute ) ) {
 				XMLPropertyElement property = XMLPropertyElement.class.cast( attribute );
 				bindProperty( property, entityBinding );
 			}
 			else if ( XMLManyToOneElement.class.isInstance( attribute ) ) {
 				XMLManyToOneElement manyToOne = XMLManyToOneElement.class.cast( attribute );
 				makeManyToOneAttributeBinding( manyToOne, entityBinding );
 			}
 			else if ( XMLOneToOneElement.class.isInstance( attribute ) ) {
 // todo : implement
 // value = new OneToOne( mappings, table, persistentClass );
 // bindOneToOne( subElement, (OneToOne) value, propertyName, true, mappings );
 			}
 			else if ( XMLBagElement.class.isInstance( attribute ) ) {
 				XMLBagElement collection = XMLBagElement.class.cast( attribute );
 				BagBinding collectionBinding = makeBagAttributeBinding( collection, entityBinding );
 				metadata.addCollection( collectionBinding );
 			}
 			else if ( XMLIdbagElement.class.isInstance( attribute ) ) {
 				XMLIdbagElement collection = XMLIdbagElement.class.cast( attribute );
 //BagBinding collectionBinding = entityBinding.makeBagAttributeBinding( collection.getName() );
 //bindIdbag( collection, bagBinding, entityBinding, PluralAttributeNature.BAG, collection.getName() );
 // todo: handle identifier
 //attributeBinding = collectionBinding;
 //hibernateMappingBinder.getHibernateXmlBinder().getMetadata().addCollection( attributeBinding );
 			}
 			else if ( XMLSetElement.class.isInstance( attribute ) ) {
 				XMLSetElement collection = XMLSetElement.class.cast( attribute );
 //BagBinding collectionBinding = entityBinding.makeBagAttributeBinding( collection.getName() );
 //bindSet( collection, collectionBinding, entityBinding, PluralAttributeNature.SET, collection.getName() );
 //attributeBinding = collectionBinding;
 //hibernateMappingBinder.getHibernateXmlBinder().getMetadata().addCollection( attributeBinding );
 			}
 			else if ( XMLListElement.class.isInstance( attribute ) ) {
 				XMLListElement collection = XMLListElement.class.cast( attribute );
 //ListBinding collectionBinding = entityBinding.makeBagAttributeBinding( collection.getName() );
 //bindList( collection, bagBinding, entityBinding, PluralAttributeNature.LIST, collection.getName() );
 // todo : handle list index
 //attributeBinding = collectionBinding;
 //hibernateMappingBinder.getHibernateXmlBinder().getMetadata().addCollection( attributeBinding );
 			}
 			else if ( XMLMapElement.class.isInstance( attribute ) ) {
 				XMLMapElement collection = XMLMapElement.class.cast( attribute );
 //BagBinding bagBinding = entityBinding.makeBagAttributeBinding( collection.getName() );
 //bindMap( collection, bagBinding, entityBinding, PluralAttributeNature.MAP, collection.getName() );
 // todo : handle map key
 //hibernateMappingBinder.getHibernateXmlBinder().getMetadata().addCollection( attributeBinding );
 			}
 			else if ( XMLAnyElement.class.isInstance( attribute ) ) {
 // todo : implement
 // value = new Any( mappings, table );
 // bindAny( subElement, (Any) value, nullable, mappings );
 			}
 			else if ( XMLComponentElement.class.isInstance( attribute )
 			|| XMLDynamicComponentElement.class.isInstance( attribute )
 			|| XMLPropertiesElement.class.isInstance( attribute ) ) {
 // todo : implement
 // String subpath = StringHelper.qualify( entityName, propertyName );
 // value = new Component( mappings, persistentClass );
 //
 // bindComponent(
 // subElement,
 // (Component) value,
 // persistentClass.getClassName(),
 // propertyName,
 // subpath,
 // true,
 // "properties".equals( subElementName ),
 // mappings,
 // inheritedMetas,
 // false
 // );
 			}
 		}
 	}
 
 	private void bindProperty(XMLPropertyElement property, EntityBinding entityBinding) {
-		SimpleAttributeBinding attributeBinding = entityBinding.makeSimpleAttributeBinding( property.getName() );
+		SingularAttribute attr = entityBinding.getEntity().locateOrCreateSingularAttribute( property.getName() );
+		SimpleAttributeBinding attributeBinding = entityBinding.makeSimpleAttributeBinding( attr );
 		resolveTypeInformation( property, attributeBinding );
 
 		attributeBinding.setInsertable( Helper.getBooleanValue( property.isInsert(), true ) );
 		attributeBinding.setInsertable( Helper.getBooleanValue( property.isUpdate(), true ) );
 		attributeBinding.setGeneration( PropertyGeneration.parse( property.getGenerated() ) );
 		attributeBinding.setLazy( property.isLazy() );
 		attributeBinding.setIncludedInOptimisticLocking( property.isOptimisticLock() );
 
 		attributeBinding.setPropertyAccessorName(
 				Helper.getPropertyAccessorName(
 						property.getAccess(),
 						false,
 						currentBindingContext.getMappingDefaults().getPropertyAccessorName()
 				)
 		);
 
 		attributeBinding.setMetaAttributeContext(
 				Helper.extractMetaAttributeContext( property.getMeta(), entityBinding.getMetaAttributeContext() )
 		);
 
 // todo : implement.  Is this meant to indicate the natural-id?
 //		attributeBinding.setAlternateUniqueKey( ... );
 
 		attributeBinding.setValue( makeValue( property, attributeBinding ) );
 
 	}
 
 	private void resolveTypeInformation(XMLPropertyElement property, final SimpleAttributeBinding attributeBinding) {
 		final Class<?> attributeJavaType = determineJavaType( attributeBinding.getAttribute() );
 		if ( attributeJavaType != null ) {
 			( (AbstractAttributeContainer.SingularAttributeImpl) attributeBinding.getAttribute() ).resolveType(
 					currentBindingContext.makeJavaType( attributeJavaType.getName() )
 			);
 		}
 
 		// prefer type attribute over nested <type/> element
 		if ( property.getTypeAttribute() != null ) {
 			final String explicitTypeName = property.getTypeAttribute();
 			final TypeDef typeDef = currentBindingContext.getMetadataImplementor().getTypeDefinition( explicitTypeName );
 			if ( typeDef != null ) {
 				attributeBinding.getHibernateTypeDescriptor().setTypeName( typeDef.getTypeClass() );
 				attributeBinding.getHibernateTypeDescriptor().getTypeParameters().putAll( typeDef.getParameters() );
 			}
 			else {
 				attributeBinding.getHibernateTypeDescriptor().setTypeName( explicitTypeName );
 			}
 		}
 		else if ( property.getType() != null ) {
 			// todo : consider changing in-line type definitions to implicitly generate uniquely-named type-defs
 			attributeBinding.getHibernateTypeDescriptor().setTypeName( property.getType().getName() );
 			for ( XMLParamElement xmlParamElement : property.getType().getParam() ) {
 				attributeBinding.getHibernateTypeDescriptor().getTypeParameters().put(
 						xmlParamElement.getName(),
 						xmlParamElement.getValue()
 				);
 			}
 		}
 		else {
 			// see if we can reflect to determine the appropriate type
 			try {
 				final String attributeName = attributeBinding.getAttribute().getName();
 				final Class ownerClass = attributeBinding.getAttribute().getAttributeContainer().getClassReference();
 				BeanInfoHelper.visitBeanInfo(
 					ownerClass,
 					new BeanInfoHelper.BeanInfoDelegate() {
 						@Override
 						public void processBeanInfo(BeanInfo beanInfo) throws Exception {
 							for ( PropertyDescriptor propertyDescriptor : beanInfo.getPropertyDescriptors() ) {
 								if ( propertyDescriptor.getName().equals( attributeName ) ) {
 									attributeBinding.getHibernateTypeDescriptor().setTypeName(
 											propertyDescriptor.getPropertyType().getName()
 									);
 									break;
 								}
 							}
 						}
 					}
 				);
 			}
 			catch ( Exception e ) {
 				// todo : log it?
 			}
 		}
 	}
 
 	private Class<?> determineJavaType(final Attribute attribute) {
 		try {
 			final Class ownerClass = attribute.getAttributeContainer().getClassReference();
 			AttributeJavaTypeDeterminerDelegate delegate = new AttributeJavaTypeDeterminerDelegate( attribute.getName() );
 			BeanInfoHelper.visitBeanInfo( ownerClass, delegate );
 			return delegate.javaType;
 		}
 		catch ( Exception e ) {
 			// todo : log it?
 		}
 		return null;
 	}
 
 	private static class AttributeJavaTypeDeterminerDelegate implements BeanInfoHelper.BeanInfoDelegate {
 		private final String attributeName;
 		private Class<?> javaType = null;
 
 		private AttributeJavaTypeDeterminerDelegate(String attributeName) {
 			this.attributeName = attributeName;
 		}
 
 		@Override
 		public void processBeanInfo(BeanInfo beanInfo) throws Exception {
 			for ( PropertyDescriptor propertyDescriptor : beanInfo.getPropertyDescriptors() ) {
 				if ( propertyDescriptor.getName().equals( attributeName ) ) {
 					javaType = propertyDescriptor.getPropertyType();
 					break;
 				}
 			}
 		}
 	}
 
 	private org.hibernate.metamodel.relational.Value makeValue(
 			XMLPropertyElement property,
 			SimpleAttributeBinding attributeBinding) {
 
 		// todo : to be completely correct, we need to know which table the value belongs to.
 		// 		There is a note about this somewhere else with ideas on the subject.
 		//		For now, just use the entity's base table.
 		final TableSpecification valueSource = attributeBinding.getEntityBinding().getBaseTable();
 
 		if ( property.getColumn() != null && ! property.getColumn().isEmpty() ) {
 			if ( property.getColumnOrFormula() != null && ! property.getColumnOrFormula().isEmpty() ) {
 				throw new MappingException(
 						"column/formula attribute may not be used together with <column>/<formula> subelement",
 						currentBindingContext.getOrigin()
 				);
 			}
 			if ( property.getFormula() != null ) {
 				throw new MappingException(
 						"column and formula attributes may not be used together",
 						currentBindingContext.getOrigin()
 				);
 			}
 			return valueSource.locateOrCreateColumn( property.getColumn() );
 		}
 		else if ( property.getFormula() != null && ! property.getFormula().isEmpty() ) {
 			if ( property.getColumnOrFormula() != null && ! property.getColumnOrFormula().isEmpty() ) {
 				throw new MappingException(
 						"column/formula attribute may not be used together with <column>/<formula> subelement",
 						currentBindingContext.getOrigin()
 				);
 			}
 			return valueSource.locateOrCreateDerivedValue( property.getFormula() );
 		}
 		else if ( property.getColumnOrFormula() != null && ! property.getColumnOrFormula().isEmpty() ) {
 			List<SimpleValue> values = new ArrayList<SimpleValue>();
 			for ( Object columnOrFormula : property.getColumnOrFormula() ) {
 				final SimpleValue value;
 				if ( XMLColumnElement.class.isInstance( columnOrFormula ) ) {
 					final XMLColumnElement columnElement = (XMLColumnElement) columnOrFormula;
 					final Column column = valueSource.locateOrCreateColumn( columnElement.getName() );
 					column.setNullable( ! columnElement.isNotNull() );
 					column.setDefaultValue( columnElement.getDefault() );
 					column.setSqlType( columnElement.getSqlType() );
 					column.setSize(
 							new Size(
 									Helper.getIntValue( columnElement.getPrecision(), -1 ),
 									Helper.getIntValue( columnElement.getScale(), -1 ),
 									Helper.getLongValue( columnElement.getLength(), -1 ),
 									Size.LobMultiplier.NONE
 							)
 					);
 					column.setDatatype( null ); // todo : ???
 					column.setReadFragment( columnElement.getRead() );
 					column.setWriteFragment( columnElement.getWrite() );
 					column.setUnique( columnElement.isUnique() );
 					column.setCheckCondition( columnElement.getCheck() );
 					column.setComment( columnElement.getComment() );
 					value = column;
 				}
 				else {
 					// todo : ??? Seems jaxb is not generating this class ?!?!?!
 //					final XMLFormulaElement formulaElement = (XMLFormulaElement) columnOrFormula;
 					value = null;
 				}
 				if ( value != null ) {
 					values.add( value );
 				}
 			}
 
 			if ( values.size() == 1 ) {
 				return values.get( 0 );
 			}
 
 			final Tuple tuple = valueSource.createTuple(
 					attributeBinding.getEntityBinding().getEntity().getName() + '.'
 							+ attributeBinding.getAttribute().getName()
 			);
 			for ( SimpleValue value : values ) {
 				tuple.addValue( value );
 			}
 			return tuple;
 		}
 		else {
 			// assume a column named based on the NamingStrategy
 			final String name = metadata.getOptions()
 					.getNamingStrategy()
 					.propertyToColumnName( attributeBinding.getAttribute().getName() );
 			return valueSource.locateOrCreateColumn( name );
 		}
 
 //		// TODO: not sure I like this here...
 //		if ( isPrimaryKey() ) {
 //			if ( SimpleValue.class.isInstance( value ) ) {
 //				if ( !Column.class.isInstance( value ) ) {
 //					// this should never ever happen..
 //					throw new org.hibernate.MappingException( "Simple ID is not a column." );
 //				}
 //				entityBinding.getBaseTable().getPrimaryKey().addColumn( Column.class.cast( value ) );
 //			}
 //			else {
 //				for ( SimpleValueRelationalState val : TupleRelationalState.class.cast( state )
 //						.getRelationalStates() ) {
 //					if ( Column.class.isInstance( val ) ) {
 //						entityBinding.getBaseTable().getPrimaryKey().addColumn( Column.class.cast( val ) );
 //					}
 //				}
 //			}
 //		}
 	}
 
 	private void makeManyToOneAttributeBinding(XMLManyToOneElement manyToOne, EntityBinding entityBinding) {
 		//To change body of created methods use File | Settings | File Templates.
 	}
 
 	private BagBinding makeBagAttributeBinding(XMLBagElement collection, EntityBinding entityBinding) {
 		return null;  //To change body of created methods use File | Settings | File Templates.
 	}
 
 	private void bindSecondaryTables(EntitySourceInformation entitySourceInfo, EntityBinding entityBinding) {
 		final EntityElement entityElement = entitySourceInfo.getEntityElement();
 
-		if ( ! ( entityElement instanceof JoinElementSource ) ) {
+		if ( ! ( entityElement instanceof JoinElementSource) ) {
 			return;
 		}
 
 		for ( XMLJoinElement join : ( (JoinElementSource) entityElement ).getJoin() ) {
 			// todo : implement
 			// Join join = new Join();
 			// join.setPersistentClass( persistentClass );
 			// bindJoin( subElement, join, mappings, inheritedMetas );
 			// persistentClass.addJoin( join );
 		}
 	}
 
 	private void bindTableUniqueConstraints(EntityBinding entityBinding) {
 		//To change body of created methods use File | Settings | File Templates.
 	}
 
 	private static interface AttributeMetadataContainer {
 		public List<Object> getAttributeElements();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/EntityHierarchy.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/EntityHierarchy.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/EntityHierarchy.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/EntityHierarchy.java
index f624660b47..933023a839 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/EntityHierarchy.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/EntityHierarchy.java
@@ -1,64 +1,64 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm;
+package org.hibernate.metamodel.source.hbm;
 
 import org.hibernate.metamodel.binding.InheritanceType;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping;
 
 /**
  * Models the source view of an entity hierarchy.
  *
  * @author Steve Ebersole
  */
 public class EntityHierarchy extends AbstractSubEntityContainer {
 	private final EntitySourceInformation entitySourceInformation;
 	private InheritanceType hierarchyInheritanceType = InheritanceType.NO_INHERITANCE;
 
 	public EntityHierarchy(XMLHibernateMapping.XMLClass rootEntity, MappingDocument sourceMappingDocument) {
 		this.entitySourceInformation = new EntitySourceInformation( rootEntity, sourceMappingDocument );
 	}
 
 	public EntitySourceInformation getEntitySourceInformation() {
 		return entitySourceInformation;
 	}
 
 	public InheritanceType getHierarchyInheritanceType() {
 		return hierarchyInheritanceType;
 	}
 
 	@Override
 	public void addSubEntityDescriptor(EntityHierarchySubEntity subEntityDescriptor) {
 		super.addSubEntityDescriptor( subEntityDescriptor );
 
 		// check inheritance type consistency
 		final InheritanceType inheritanceType = Helper.interpretInheritanceType(
 				subEntityDescriptor.getEntitySourceInformation().getEntityElement()
 		);
 		if ( this.hierarchyInheritanceType != InheritanceType.NO_INHERITANCE
 				&& this.hierarchyInheritanceType != inheritanceType ) {
 			// throw exception
 		}
 		this.hierarchyInheritanceType = inheritanceType;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/EntityHierarchySubEntity.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/EntityHierarchySubEntity.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/EntityHierarchySubEntity.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/EntityHierarchySubEntity.java
index 16ab8c846c..ba5dc913e7 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/EntityHierarchySubEntity.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/EntityHierarchySubEntity.java
@@ -1,43 +1,43 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm;
+package org.hibernate.metamodel.source.hbm;
 
-import org.hibernate.metamodel.binder.source.hbm.xml.mapping.EntityElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.EntityElement;
 
 /**
  * A sub entity within an entity hierarchy.
  * 
  * @author Steve Ebersole
  */
 public class EntityHierarchySubEntity extends AbstractSubEntityContainer {
 	private final EntitySourceInformation entitySourceInformation;
 
 	public EntityHierarchySubEntity(EntityElement entityElement, MappingDocument sourceMappingDocument) {
 		this.entitySourceInformation = new EntitySourceInformation( entityElement, sourceMappingDocument );
 	}
 
 	public EntitySourceInformation getEntitySourceInformation() {
 		return entitySourceInformation;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/EntitySourceInformation.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/EntitySourceInformation.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/EntitySourceInformation.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/EntitySourceInformation.java
index b2d2b6aee7..a02553db8e 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/EntitySourceInformation.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/EntitySourceInformation.java
@@ -1,55 +1,55 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm;
+package org.hibernate.metamodel.source.hbm;
 
-import org.hibernate.metamodel.binder.source.hbm.xml.mapping.EntityElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.EntityElement;
 
 /**
  * An aggregation of information about the source of an entity mapping.
  * 
  * @author Steve Ebersole
  */
 public class EntitySourceInformation {
 	private final EntityElement entityElement;
 	private final MappingDocument sourceMappingDocument;
 	private final String mappedEntityName;
 
 	public EntitySourceInformation(EntityElement entityElement, MappingDocument sourceMappingDocument) {
 		this.entityElement = entityElement;
 		this.sourceMappingDocument = sourceMappingDocument;
 		this.mappedEntityName = sourceMappingDocument.getMappingLocalBindingContext().determineEntityName( entityElement );
 	}
 
 	public EntityElement getEntityElement() {
 		return entityElement;
 	}
 
 	public MappingDocument getSourceMappingDocument() {
 		return sourceMappingDocument;
 	}
 
 	public String getMappedEntityName() {
 		return mappedEntityName;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/HbmBindingContext.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HbmBindingContext.java
similarity index 80%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/HbmBindingContext.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HbmBindingContext.java
index c4f2713e24..f8fff0ad7c 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/HbmBindingContext.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HbmBindingContext.java
@@ -1,51 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm;
+package org.hibernate.metamodel.source.hbm;
 
 import java.util.List;
 
-import org.hibernate.metamodel.binder.Origin;
-import org.hibernate.metamodel.binder.source.BindingContext;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
-import org.hibernate.metamodel.binder.source.hbm.xml.mapping.EntityElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLFetchProfileElement;
+import org.hibernate.metamodel.source.Origin;
+import org.hibernate.metamodel.source.BindingContext;
+import org.hibernate.metamodel.source.MetaAttributeContext;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.EntityElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLFetchProfileElement;
 
 /**
  * Defines features specific to the {@code hbm.xml} variety of a {@link BindingContext}
  * 
  * @author Steve Ebersole
  */
 public interface HbmBindingContext extends BindingContext {
 	public boolean isAutoImport();
 
 	public MetaAttributeContext getMetaAttributeContext();
 
 	public Origin getOrigin();
 
 	public String determineEntityName(EntityElement entityElement);
 
 	public String qualifyClassName(String unqualifiedName);
 
 	public void processFetchProfiles(List<XMLFetchProfileElement> fetchProfiles, String containingEntityName);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/HbmSourceProcessorImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HbmSourceProcessorImpl.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/HbmSourceProcessorImpl.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HbmSourceProcessorImpl.java
index 493f4aeaf3..8581a143c8 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/HbmSourceProcessorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HbmSourceProcessorImpl.java
@@ -1,97 +1,97 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm;
+package org.hibernate.metamodel.source.hbm;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.SourceProcessor;
-import org.hibernate.metamodel.binder.source.internal.JaxbRoot;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping;
+import org.hibernate.metamodel.source.MetadataImplementor;
+import org.hibernate.metamodel.source.SourceProcessor;
+import org.hibernate.metamodel.source.internal.JaxbRoot;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping;
 
 /**
  * The {@link SourceProcessor} implementation responsible for processing {@code hbm.xml} sources.
  *
  * @author Steve Ebersole
  */
 public class HbmSourceProcessorImpl implements SourceProcessor {
 	private final MetadataImplementor metadata;
 
 	private List<HibernateMappingProcessor> processors = new ArrayList<HibernateMappingProcessor>();
 	private List<EntityHierarchy> entityHierarchies;
 
 	public HbmSourceProcessorImpl(MetadataImplementor metadata) {
 		this.metadata = metadata;
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public void prepare(MetadataSources sources) {
 		final HierarchyBuilder hierarchyBuilder = new HierarchyBuilder( metadata );
 
 		for ( JaxbRoot jaxbRoot : sources.getJaxbRootList() ) {
 			if ( ! XMLHibernateMapping.class.isInstance( jaxbRoot.getRoot() ) ) {
 				continue;
 			}
 
 			final MappingDocument mappingDocument = new MappingDocument( jaxbRoot, metadata );
 			processors.add( new HibernateMappingProcessor( metadata, mappingDocument ) );
 
 			hierarchyBuilder.processMappingDocument( mappingDocument );
 		}
 
 		this.entityHierarchies = hierarchyBuilder.groupEntityHierarchies();
 	}
 
 	@Override
 	public void processIndependentMetadata(MetadataSources sources) {
 		for ( HibernateMappingProcessor processor : processors ) {
 			processor.processIndependentMetadata();
 		}
 	}
 
 	@Override
 	public void processTypeDependentMetadata(MetadataSources sources) {
 		for ( HibernateMappingProcessor processor : processors ) {
 			processor.processTypeDependentMetadata();
 		}
 	}
 
 	@Override
 	public void processMappingMetadata(MetadataSources sources, List<String> processedEntityNames) {
 		BindingCreator bindingCreator = new BindingCreator( metadata, processedEntityNames );
 		for ( EntityHierarchy entityHierarchy : entityHierarchies ) {
 			bindingCreator.processEntityHierarchy( entityHierarchy );
 		}
 	}
 
 	@Override
 	public void processMappingDependentMetadata(MetadataSources sources) {
 		for ( HibernateMappingProcessor processor : processors ) {
 			processor.processMappingDependentMetadata();
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/Helper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/Helper.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/Helper.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/Helper.java
index 24315d6ccb..ece88bb44b 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/Helper.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/Helper.java
@@ -1,198 +1,198 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm;
+package org.hibernate.metamodel.source.hbm;
 
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
-import org.hibernate.metamodel.binder.source.hbm.xml.mapping.CustomSqlElement;
-import org.hibernate.metamodel.binder.source.hbm.xml.mapping.EntityElement;
+import org.hibernate.metamodel.source.MetaAttributeContext;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.CustomSqlElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.EntityElement;
 import org.hibernate.metamodel.binding.CustomSQL;
 import org.hibernate.metamodel.binding.InheritanceType;
 import org.hibernate.metamodel.binding.MetaAttribute;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLJoinedSubclassElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLMetaElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSubclassElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLUnionSubclassElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLJoinedSubclassElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLMetaElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSubclassElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLUnionSubclassElement;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.service.classloading.spi.ClassLoadingException;
 
 /**
  * @author Steve Ebersole
  * @author Gail Badner
  */
 public class Helper {
 	public static InheritanceType interpretInheritanceType(EntityElement entityElement) {
 		if ( XMLSubclassElement.class.isInstance( entityElement ) ) {
 			return InheritanceType.SINGLE_TABLE;
 		}
 		else if ( XMLJoinedSubclassElement.class.isInstance( entityElement ) ) {
 			return InheritanceType.JOINED;
 		}
 		else if ( XMLUnionSubclassElement.class.isInstance( entityElement ) ) {
 			return InheritanceType.TABLE_PER_CLASS;
 		}
 		else {
 			return InheritanceType.NO_INHERITANCE;
 		}
 	}
 
 	/**
 	 * Given a user-specified description of how to perform custom SQL, build the {@link CustomSQL} representation.
 	 *
 	 * @param customSqlElement User-specified description of how to perform custom SQL
 	 *
 	 * @return The {@link CustomSQL} representation
 	 */
 	public static CustomSQL buildCustomSql(CustomSqlElement customSqlElement) {
 		if ( customSqlElement == null ) {
 			return null;
 		}
 		final ExecuteUpdateResultCheckStyle checkStyle = customSqlElement.getCheck() == null
 				? customSqlElement.isCallable()
 						? ExecuteUpdateResultCheckStyle.NONE
 						: ExecuteUpdateResultCheckStyle.COUNT
 				: ExecuteUpdateResultCheckStyle.fromExternalName( customSqlElement.getCheck().value() );
 		return new CustomSQL( customSqlElement.getValue(), customSqlElement.isCallable(), checkStyle );
 	}
 
 	/**
 	 * Given the user-specified entity mapping, determine the appropriate entity name
 	 *
 	 * @param entityElement The user-specified entity mapping
 	 * @param unqualifiedClassPackage The package to use for unqualified class names
 	 *
 	 * @return The appropriate entity name
 	 */
 	public static String determineEntityName(EntityElement entityElement, String unqualifiedClassPackage) {
 		return entityElement.getEntityName() != null
 				? entityElement.getEntityName()
 				: qualifyIfNeeded( entityElement.getName(), unqualifiedClassPackage );
 	}
 
 	/**
 	 * Qualify a (supposed class) name with the unqualified-class package name if it is not already qualified
 	 *
 	 * @param name The name
 	 * @param unqualifiedClassPackage The unqualified-class package name
 	 *
 	 * @return {@code null} if the incoming name was {@code null}; or the qualified name.
 	 */
 	public static String qualifyIfNeeded(String name, String unqualifiedClassPackage) {
 		if ( name == null ) {
 			return null;
 		}
 		if ( name.indexOf( '.' ) < 0 && unqualifiedClassPackage != null ) {
 			return unqualifiedClassPackage + '.' + name;
 		}
 		return name;
 	}
 
 	public static String getPropertyAccessorName(String access, boolean isEmbedded, String defaultAccess) {
 		return getStringValue( access, isEmbedded ? "embedded" : defaultAccess );
 	}
 
 	public static MetaAttributeContext extractMetaAttributeContext(
 			List<XMLMetaElement> metaElementList,
 			MetaAttributeContext parentContext) {
 		return extractMetaAttributeContext( metaElementList, false, parentContext );
 	}
 
 	public static MetaAttributeContext extractMetaAttributeContext(
 			List<XMLMetaElement> metaElementList,
 			boolean onlyInheritable,
 			MetaAttributeContext parentContext) {
 		final MetaAttributeContext subContext = new MetaAttributeContext( parentContext );
 
 		for ( XMLMetaElement metaElement : metaElementList ) {
 			if ( onlyInheritable & !metaElement.isInherit() ) {
 				continue;
 			}
 
 			final String name = metaElement.getAttribute();
 			final MetaAttribute inheritedMetaAttribute = parentContext.getMetaAttribute( name );
 			MetaAttribute metaAttribute = subContext.getLocalMetaAttribute( name );
 			if ( metaAttribute == null || metaAttribute == inheritedMetaAttribute ) {
 				metaAttribute = new MetaAttribute( name );
 				subContext.add( metaAttribute );
 			}
 			metaAttribute.addValue( metaElement.getValue() );
 		}
 
 		return subContext;
 	}
 
 	public static String getStringValue(String value, String defaultValue) {
 		return value == null ? defaultValue : value;
 	}
 
 	public static int getIntValue(String value, int defaultValue) {
 		return value == null ? defaultValue : Integer.parseInt( value );
 	}
 
 	public static long getLongValue(String value, long defaultValue) {
 		return value == null ? defaultValue : Long.parseLong( value );
 	}
 
 	public static boolean getBooleanValue(String value, boolean defaultValue) {
 		return value == null ? defaultValue : Boolean.valueOf( value );
 	}
 
 	public static boolean getBooleanValue(Boolean value, boolean defaultValue) {
 		return value == null ? defaultValue : value;
 	}
 
 	public static Set<String> getStringValueTokens(String str, String delimiters) {
 		if ( str == null ) {
 			return Collections.emptySet();
 		}
 		else {
 			StringTokenizer tokenizer = new StringTokenizer( str, delimiters );
 			Set<String> tokens = new HashSet<String>();
 			while ( tokenizer.hasMoreTokens() ) {
 				tokens.add( tokenizer.nextToken() );
 			}
 			return tokens;
 		}
 	}
 
 	// todo : remove this once the state objects are cleaned up
 
 	public static Class classForName(String className, ServiceRegistry serviceRegistry) {
 		ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 		try {
 			return classLoaderService.classForName( className );
 		}
 		catch ( ClassLoadingException e ) {
 			throw new MappingException( "Could not find class: " + className );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/HibernateMappingProcessor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HibernateMappingProcessor.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/HibernateMappingProcessor.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HibernateMappingProcessor.java
index effc489369..a9a0e777d7 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/HibernateMappingProcessor.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HibernateMappingProcessor.java
@@ -1,289 +1,289 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm;
+package org.hibernate.metamodel.source.hbm;
 
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.Value;
-import org.hibernate.metamodel.binder.MappingException;
-import org.hibernate.metamodel.binder.Origin;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
+import org.hibernate.metamodel.source.MappingException;
+import org.hibernate.metamodel.source.Origin;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.metamodel.binding.FetchProfile;
 import org.hibernate.metamodel.binding.TypeDef;
 import org.hibernate.metamodel.relational.AuxiliaryDatabaseObject;
 import org.hibernate.metamodel.relational.BasicAuxiliaryDatabaseObjectImpl;
 import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLFetchProfileElement;
 import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping;
 import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLJoinedSubclassElement;
 import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLParamElement;
 import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLQueryElement;
 import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSqlQueryElement;
 import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSubclassElement;
 import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLUnionSubclassElement;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.service.classloading.spi.ClassLoadingException;
 import org.hibernate.type.Type;
 
 /**
  * Responsible for processing a {@code <hibernate-mapping/>} element.  Allows processing to be coordinated across
  * all hbm files in an ordered fashion.  The order is essentially the same as defined in
- * {@link org.hibernate.metamodel.binder.source.SourceProcessor}
+ * {@link org.hibernate.metamodel.source.SourceProcessor}
  *
  * @author Steve Ebersole
  */
 public class HibernateMappingProcessor {
 	private final MetadataImplementor metadata;
 	private final MappingDocument mappingDocument;
 
 	private Value<ClassLoaderService> classLoaderService = new Value<ClassLoaderService>(
 			new Value.DeferredInitializer<ClassLoaderService>() {
 				@Override
 				public ClassLoaderService initialize() {
 					return metadata.getServiceRegistry().getService( ClassLoaderService.class );
 				}
 			}
 	);
 
 	public HibernateMappingProcessor(MetadataImplementor metadata, MappingDocument mappingDocument) {
 		this.metadata = metadata;
 		this.mappingDocument = mappingDocument;
 	}
 
 	private XMLHibernateMapping mappingRoot() {
 		return mappingDocument.getMappingRoot();
 	}
 
 	private Origin origin() {
 		return mappingDocument.getOrigin();
 	}
 
 	private HbmBindingContext bindingContext() {
 		return mappingDocument.getMappingLocalBindingContext();
 	}
 
 	private <T> Class<T> classForName(String name) {
 		return classLoaderService.getValue().classForName( bindingContext().qualifyClassName( name ) );
 	}
 
 	public void processIndependentMetadata() {
 		processDatabaseObjectDefinitions();
 		processTypeDefinitions();
 	}
 
 	private void processDatabaseObjectDefinitions() {
 		if ( mappingRoot().getDatabaseObject() == null ) {
 			return;
 		}
 
 		for ( XMLHibernateMapping.XMLDatabaseObject databaseObjectElement : mappingRoot().getDatabaseObject() ) {
 			final AuxiliaryDatabaseObject auxiliaryDatabaseObject;
 			if ( databaseObjectElement.getDefinition() != null ) {
 				final String className = databaseObjectElement.getDefinition().getClazz();
 				try {
 					auxiliaryDatabaseObject = (AuxiliaryDatabaseObject) classForName( className ).newInstance();
 				}
 				catch (ClassLoadingException e) {
 					throw e;
 				}
 				catch (Exception e) {
 					throw new MappingException(
 							"could not instantiate custom database object class [" + className + "]",
 							origin()
 					);
 				}
 			}
 			else {
 				Set<String> dialectScopes = new HashSet<String>();
 				if ( databaseObjectElement.getDialectScope() != null ) {
 					for ( XMLHibernateMapping.XMLDatabaseObject.XMLDialectScope dialectScope : databaseObjectElement.getDialectScope() ) {
 						dialectScopes.add( dialectScope.getName() );
 					}
 				}
 				auxiliaryDatabaseObject = new BasicAuxiliaryDatabaseObjectImpl(
 						databaseObjectElement.getCreate(),
 						databaseObjectElement.getDrop(),
 						dialectScopes
 				);
 			}
 			metadata.addAuxiliaryDatabaseObject( auxiliaryDatabaseObject );
 		}
 	}
 
 	private void processTypeDefinitions() {
 		if ( mappingRoot().getTypedef() == null ) {
 			return;
 		}
 
 		for ( XMLHibernateMapping.XMLTypedef typedef : mappingRoot().getTypedef() ) {
 			final Map<String, String> parameters = new HashMap<String, String>();
 			for ( XMLParamElement paramElement : typedef.getParam() ) {
 				parameters.put( paramElement.getName(), paramElement.getValue() );
 			}
 			metadata.addTypeDefinition(
 					new TypeDef(
 							typedef.getName(),
 							typedef.getClazz(),
 							parameters
 					)
 			);
 		}
 	}
 
 	public void processTypeDependentMetadata() {
 		processFilterDefinitions();
 		processIdentifierGenerators();
 	}
 
 	private void processFilterDefinitions() {
 		if ( mappingRoot().getFilterDef() == null ) {
 			return;
 		}
 
 		for ( XMLHibernateMapping.XMLFilterDef filterDefinition : mappingRoot().getFilterDef() ) {
 			final String name = filterDefinition.getName();
 			final Map<String,Type> parameters = new HashMap<String, Type>();
 			String condition = null;
 			for ( Object o : filterDefinition.getContent() ) {
 				if ( o instanceof String ) {
 					// represents the condition
 					if ( condition != null ) {
 						// log?
 					}
 					condition = (String) o;
 				}
 				else if ( o instanceof XMLHibernateMapping.XMLFilterDef.XMLFilterParam ) {
 					final XMLHibernateMapping.XMLFilterDef.XMLFilterParam paramElement = (XMLHibernateMapping.XMLFilterDef.XMLFilterParam) o;
 					// todo : should really delay this resolution until later to allow typedef names
 					parameters.put(
 							paramElement.getName(),
 							metadata.getTypeResolver().heuristicType( paramElement.getType() )
 					);
 				}
 				else {
 					throw new MappingException( "Unrecognized nested filter content", origin() );
 				}
 			}
 			if ( condition == null ) {
 				condition = filterDefinition.getCondition();
 			}
 			metadata.addFilterDefinition( new FilterDefinition( name, condition, parameters ) );
 		}
 	}
 
 	private void processIdentifierGenerators() {
 		if ( mappingRoot().getIdentifierGenerator() == null ) {
 			return;
 		}
 
 		for ( XMLHibernateMapping.XMLIdentifierGenerator identifierGeneratorElement : mappingRoot().getIdentifierGenerator() ) {
 			metadata.registerIdentifierGenerator(
 					identifierGeneratorElement.getName(),
 					identifierGeneratorElement.getClazz()
 			);
 		}
 	}
 
 	public void processMappingDependentMetadata() {
 		processFetchProfiles();
 		processImports();
 		processResultSetMappings();
 		processNamedQueries();
 	}
 
 	private void processFetchProfiles(){
 		if ( mappingRoot().getFetchProfile() == null ) {
 			return;
 		}
 
 		processFetchProfiles( mappingRoot().getFetchProfile(), null );
 	}
 
 	public void processFetchProfiles(List<XMLFetchProfileElement> fetchProfiles, String containingEntityName) {
 		for ( XMLFetchProfileElement fetchProfile : fetchProfiles ) {
 			String profileName = fetchProfile.getName();
 			Set<FetchProfile.Fetch> fetches = new HashSet<FetchProfile.Fetch>();
 			for ( XMLFetchProfileElement.XMLFetch fetch : fetchProfile.getFetch() ) {
 				String entityName = fetch.getEntity() == null ? containingEntityName : fetch.getEntity();
 				if ( entityName == null ) {
 					throw new MappingException(
 							"could not determine entity for fetch-profile fetch [" + profileName + "]:[" +
 									fetch.getAssociation() + "]",
 							origin()
 					);
 				}
 				fetches.add( new FetchProfile.Fetch( entityName, fetch.getAssociation(), fetch.getStyle() ) );
 			}
 			metadata.addFetchProfile( new FetchProfile( profileName, fetches ) );
 		}
 	}
 
 	private void processImports() {
 		if ( mappingRoot().getImport() == null ) {
 			return;
 		}
 
 		for ( XMLHibernateMapping.XMLImport importValue : mappingRoot().getImport() ) {
 			String className = mappingDocument.getMappingLocalBindingContext().qualifyClassName( importValue.getClazz() );
 			String rename = importValue.getRename();
 			rename = ( rename == null ) ? StringHelper.unqualify( className ) : rename;
 			metadata.addImport( className, rename );
 		}
 	}
 
 	private void processResultSetMappings() {
 		if ( mappingRoot().getResultset() == null ) {
 			return;
 		}
 
 //			bindResultSetMappingDefinitions( element, null, mappings );
 	}
 
 	private void processNamedQueries() {
 		if ( mappingRoot().getQueryOrSqlQuery() == null ) {
 			return;
 		}
 
 		for ( Object queryOrSqlQuery : mappingRoot().getQueryOrSqlQuery() ) {
 			if ( XMLQueryElement.class.isInstance( queryOrSqlQuery ) ) {
 //					bindNamedQuery( element, null, mappings );
 			}
 			else if ( XMLSqlQueryElement.class.isInstance( queryOrSqlQuery ) ) {
 //				bindNamedSQLQuery( element, null, mappings );
 			}
 			else {
 				throw new MappingException(
 						"unknown type of query: " +
 								queryOrSqlQuery.getClass().getName(), origin()
 				);
 			}
 		}
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/HierarchyBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HierarchyBuilder.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/HierarchyBuilder.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HierarchyBuilder.java
index 662b0859ff..7d24fdec2b 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/HierarchyBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HierarchyBuilder.java
@@ -1,175 +1,175 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm;
+package org.hibernate.metamodel.source.hbm;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.MappingException;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.hbm.xml.mapping.EntityElement;
-import org.hibernate.metamodel.binder.source.hbm.xml.mapping.SubEntityElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLJoinedSubclassElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSubclassElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLUnionSubclassElement;
+import org.hibernate.metamodel.source.MetadataImplementor;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.EntityElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.SubEntityElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLJoinedSubclassElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSubclassElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLUnionSubclassElement;
 
 /**
  * @author Steve Ebersole
  */
 public class HierarchyBuilder {
 	private final MetadataImplementor metadata;
 
 	private final List<EntityHierarchy> entityHierarchies = new ArrayList<EntityHierarchy>();
 
 	// process state
 	private final Map<String,SubEntityContainer> subEntityContainerMap = new HashMap<String, SubEntityContainer>();
 	private final List<ExtendsQueueEntry> extendsQueue = new ArrayList<ExtendsQueueEntry>();
 
 	// mapping file specific state
 	private MappingDocument currentMappingDocument;
 
 	public HierarchyBuilder(MetadataImplementor metadata) {
 		this.metadata = metadata;
 	}
 
 	public void processMappingDocument(MappingDocument mappingDocument) {
 		this.currentMappingDocument = mappingDocument;
 		try {
 			processCurrentMappingDocument();
 		}
 		finally {
 			this.currentMappingDocument = null;
 		}
 	}
 
 	private void processCurrentMappingDocument() {
 		for ( Object entityElementO : currentMappingDocument.getMappingRoot().getClazzOrSubclassOrJoinedSubclass() ) {
 			final EntityElement entityElement = (EntityElement) entityElementO;
 			if ( XMLHibernateMapping.XMLClass.class.isInstance( entityElement ) ) {
 				// we can immediately handle <class/> elements in terms of creating the hierarchy entry
 				final XMLHibernateMapping.XMLClass xmlClass = (XMLHibernateMapping.XMLClass) entityElement;
 				final EntityHierarchy hierarchy = new EntityHierarchy( xmlClass, currentMappingDocument );
 				entityHierarchies.add( hierarchy );
 				subEntityContainerMap.put( hierarchy.getEntitySourceInformation().getMappedEntityName(), hierarchy );
 				processSubElements( entityElement, hierarchy );
 			}
 			else {
 				// we have to see if this things super-type has been found yet, and if not add it to the
 				// extends queue
 				final EntityHierarchySubEntity subEntityDescriptor = new EntityHierarchySubEntity(
 						entityElement,
 						currentMappingDocument
 				);
 				final String entityName = subEntityDescriptor.getEntitySourceInformation().getMappedEntityName();
 				subEntityContainerMap.put( entityName, subEntityDescriptor );
 				final String entityItExtends = currentMappingDocument.getMappingLocalBindingContext().qualifyClassName(
 						((SubEntityElement) entityElement).getExtends()
 				);
 				processSubElements( entityElement, subEntityDescriptor );
 				final SubEntityContainer container = subEntityContainerMap.get( entityItExtends );
 				if ( container != null ) {
 					// we already have this entity's super, attach it and continue
 					container.addSubEntityDescriptor( subEntityDescriptor );
 				}
 				else {
 					// we do not yet have the super and have to wait, so add it fto the extends queue
 					extendsQueue.add( new ExtendsQueueEntry( subEntityDescriptor, entityItExtends ) );
 				}
 			}
 		}
 	}
 
 	public List<EntityHierarchy> groupEntityHierarchies() {
 		while ( ! extendsQueue.isEmpty() ) {
 			// set up a pass over the queue
 			int numberOfMappingsProcessed = 0;
 			Iterator<ExtendsQueueEntry> iterator = extendsQueue.iterator();
 			while ( iterator.hasNext() ) {
 				final ExtendsQueueEntry entry = iterator.next();
 				final SubEntityContainer container = subEntityContainerMap.get( entry.entityItExtends );
 				if ( container != null ) {
 					// we now have this entity's super, attach it and remove entry from extends queue
 					container.addSubEntityDescriptor( entry.subEntityDescriptor );
 					iterator.remove();
 					numberOfMappingsProcessed++;
 				}
 			}
 
 			if ( numberOfMappingsProcessed == 0 ) {
 				// todo : we could log the waiting dependencies...
 				throw new MappingException( "Unable to process extends dependencies in hbm files" );
 			}
 		}
 
 		return entityHierarchies;
 	}
 
 	private void processSubElements(EntityElement entityElement, SubEntityContainer container) {
 		if ( XMLHibernateMapping.XMLClass.class.isInstance( entityElement ) ) {
 			final XMLHibernateMapping.XMLClass xmlClass = (XMLHibernateMapping.XMLClass) entityElement;
 			processElements( xmlClass.getJoinedSubclass(), container );
 			processElements( xmlClass.getSubclass(), container );
 			processElements( xmlClass.getUnionSubclass(), container );
 		}
 		else if ( XMLSubclassElement.class.isInstance( entityElement ) ) {
 			final XMLSubclassElement xmlSubclass = (XMLSubclassElement) entityElement;
 			processElements( xmlSubclass.getSubclass(), container );
 		}
 		else if ( XMLJoinedSubclassElement.class.isInstance( entityElement ) ) {
 			final XMLJoinedSubclassElement xmlJoinedSubclass = (XMLJoinedSubclassElement) entityElement;
 			processElements( xmlJoinedSubclass.getJoinedSubclass(), container );
 		}
 		else if ( XMLUnionSubclassElement.class.isInstance( entityElement ) ) {
 			final XMLUnionSubclassElement xmlUnionSubclass = (XMLUnionSubclassElement) entityElement;
 			processElements( xmlUnionSubclass.getUnionSubclass(), container );
 		}
 	}
 
 	private void processElements(List subElements, SubEntityContainer container) {
 		for ( Object subElementO : subElements ) {
 			final SubEntityElement subElement = (SubEntityElement) subElementO;
 			final EntityHierarchySubEntity subEntityDescriptor = new EntityHierarchySubEntity(
 					subElement,
 					currentMappingDocument
 			);
 			container.addSubEntityDescriptor( subEntityDescriptor );
 			final String subEntityName = subEntityDescriptor.getEntitySourceInformation().getMappedEntityName();
 			subEntityContainerMap.put( subEntityName, subEntityDescriptor );
 		}
 	}
 
 	private static class ExtendsQueueEntry {
 		private final EntityHierarchySubEntity subEntityDescriptor;
 		private final String entityItExtends;
 
 		private ExtendsQueueEntry(EntityHierarchySubEntity subEntityDescriptor, String entityItExtends) {
 			this.subEntityDescriptor = subEntityDescriptor;
 			this.entityItExtends = entityItExtends;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/MappingDocument.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/MappingDocument.java
similarity index 86%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/MappingDocument.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/MappingDocument.java
index feb941cfc6..4e1488964a 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/MappingDocument.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/MappingDocument.java
@@ -1,154 +1,159 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm;
+package org.hibernate.metamodel.source.hbm;
 
 import java.util.List;
 
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.internal.util.Value;
-import org.hibernate.metamodel.binder.Origin;
-import org.hibernate.metamodel.binder.source.MappingDefaults;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.hbm.xml.mapping.EntityElement;
-import org.hibernate.metamodel.binder.source.internal.JaxbRoot;
+import org.hibernate.metamodel.source.Origin;
+import org.hibernate.metamodel.source.MappingDefaults;
+import org.hibernate.metamodel.source.MetaAttributeContext;
+import org.hibernate.metamodel.source.MetadataImplementor;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.EntityElement;
+import org.hibernate.metamodel.source.internal.JaxbRoot;
 import org.hibernate.metamodel.domain.Type;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLFetchProfileElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLFetchProfileElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping;
 import org.hibernate.service.ServiceRegistry;
 
 /**
  * Aggregates together information about a mapping document.
  * 
  * @author Steve Ebersole
  */
 public class MappingDocument {
 	private final JaxbRoot<XMLHibernateMapping> hbmJaxbRoot;
 	private final LocalBindingContextImpl mappingLocalBindingContext;
 
 	public MappingDocument(JaxbRoot<XMLHibernateMapping> hbmJaxbRoot, MetadataImplementor metadata) {
 		this.hbmJaxbRoot = hbmJaxbRoot;
 		this.mappingLocalBindingContext = new LocalBindingContextImpl( metadata );
 	}
 
 	public XMLHibernateMapping getMappingRoot() {
 		return hbmJaxbRoot.getRoot();
 	}
 
 	public Origin getOrigin() {
 		return hbmJaxbRoot.getOrigin();
 	}
 
 	public JaxbRoot<XMLHibernateMapping> getJaxbRoot() {
 		return hbmJaxbRoot;
 	}
 
 	public HbmBindingContext getMappingLocalBindingContext() {
 		return mappingLocalBindingContext;
 	}
 
 	private class LocalBindingContextImpl implements HbmBindingContext {
 		private final MetadataImplementor metadata;
 		private final MetaAttributeContext metaAttributeContext;
 
 		private LocalBindingContextImpl(MetadataImplementor metadata) {
 			this.metadata = metadata;
 			if ( hbmJaxbRoot.getRoot().getMeta() == null || hbmJaxbRoot.getRoot().getMeta().isEmpty() ) {
 				this.metaAttributeContext = new MetaAttributeContext( metadata.getGlobalMetaAttributeContext() );
 			}
 			else {
 				this.metaAttributeContext = Helper.extractMetaAttributeContext(
 						hbmJaxbRoot.getRoot().getMeta(),
 						true,
 						metadata.getGlobalMetaAttributeContext()
 				);
 			}
 		}
 
 		@Override
 		public ServiceRegistry getServiceRegistry() {
 			return metadata.getServiceRegistry();
 		}
 
 		@Override
 		public NamingStrategy getNamingStrategy() {
 			return metadata.getNamingStrategy();
 		}
 
 		@Override
 		public MappingDefaults getMappingDefaults() {
 			return metadata.getMappingDefaults();
 		}
 
 		@Override
 		public MetadataImplementor getMetadataImplementor() {
 			return metadata;
 		}
 
 		@Override
 		public <T> Class<T> locateClassByName(String name) {
 			return metadata.locateClassByName( name );
 		}
 
 		@Override
 		public Type makeJavaType(String className) {
 			return metadata.makeJavaType( className );
 		}
 
 		@Override
 		public Value<Class<?>> makeClassReference(String className) {
 			return metadata.makeClassReference( className );
 		}
 
 		@Override
 		public boolean isAutoImport() {
 			return hbmJaxbRoot.getRoot().isAutoImport();
 		}
 
 		@Override
 		public MetaAttributeContext getMetaAttributeContext() {
 			return metaAttributeContext;
 		}
 
 		@Override
 		public Origin getOrigin() {
 			return hbmJaxbRoot.getOrigin();
 		}
 
 		@Override
 		public String qualifyClassName(String unqualifiedName) {
 			return Helper.qualifyIfNeeded( unqualifiedName, getMappingDefaults().getPackageName() );
 		}
 
 		@Override
 		public String determineEntityName(EntityElement entityElement) {
 			return Helper.determineEntityName( entityElement, getMappingDefaults().getPackageName() );
 		}
 
 		@Override
+		public boolean isGloballyQuotedIdentifiers() {
+			return metadata.getOptions().isGloballyQuotedIdentifiers();
+		}
+
+		@Override
 		public void processFetchProfiles(List<XMLFetchProfileElement> fetchProfiles, String containingEntityName) {
 			// todo : this really needs to not be part of the context
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/SubEntityContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/SubEntityContainer.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/SubEntityContainer.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/SubEntityContainer.java
index 09bb98b4d3..d54cd95c58 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/SubEntityContainer.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/SubEntityContainer.java
@@ -1,35 +1,35 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm;
+package org.hibernate.metamodel.source.hbm;
 
 /**
  * Contract for elements within a {@link EntityHierarchy} which can contain sub elements.  Essentially this
  * abstracts that common aspect away from both root and sub entities.
  *
  * @author Steve Ebersole
  */
 public interface SubEntityContainer {
 	public void addSubEntityDescriptor(EntityHierarchySubEntity subEntityDescriptor);
 	public Iterable<EntityHierarchySubEntity> subEntityDescriptors();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/CustomSqlElement.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/CustomSqlElement.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/CustomSqlElement.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/CustomSqlElement.java
index 63330b6fbf..14d850d044 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/CustomSqlElement.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/CustomSqlElement.java
@@ -1,35 +1,33 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm.xml.mapping;
-
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLCheckAttribute;
+package org.hibernate.metamodel.source.hbm.jaxb.mapping;
 
 /**
  * @author Steve Ebersole
  */
 public interface CustomSqlElement {
 	public String getValue();
 	public boolean isCallable();
 	public XMLCheckAttribute getCheck();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/EntityElement.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/EntityElement.java
similarity index 73%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/EntityElement.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/EntityElement.java
index 5b94d87e70..efe6ec4e75 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/EntityElement.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/EntityElement.java
@@ -1,70 +1,60 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm.xml.mapping;
+package org.hibernate.metamodel.source.hbm.jaxb.mapping;
 
 import java.util.List;
 
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLFetchProfileElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLJoinElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLLoaderElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLResultsetElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSqlDeleteElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSqlInsertElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSqlUpdateElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSynchronizeElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLTuplizerElement;
-
 /**
  * @author Steve Ebersole
  */
 public interface EntityElement extends MetaAttributeContainer {
 	public String getName();
 	public String getEntityName();
 
     public Boolean isAbstract();
     public Boolean isLazy();
     public String getProxy();
     public String getBatchSize();
     public boolean isDynamicInsert();
     public boolean isDynamicUpdate();
     public boolean isSelectBeforeUpdate();
 
 	public List<XMLTuplizerElement> getTuplizer();
     public String getPersister();
 
 	public XMLLoaderElement getLoader();
 	public XMLSqlInsertElement getSqlInsert();
 	public XMLSqlUpdateElement getSqlUpdate();
 	public XMLSqlDeleteElement getSqlDelete();
 
 	public List<XMLSynchronizeElement> getSynchronize();
 
 	public List<XMLFetchProfileElement> getFetchProfile();
 
     public List<XMLResultsetElement> getResultset();
 
     public List<Object> getQueryOrSqlQuery();
 
 	public List<Object> getPropertyOrManyToOneOrOneToOne();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/JoinElementSource.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/JoinElementSource.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/JoinElementSource.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/JoinElementSource.java
index a3cf6122be..f5f5d2cd48 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/JoinElementSource.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/JoinElementSource.java
@@ -1,35 +1,33 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm.xml.mapping;
+package org.hibernate.metamodel.source.hbm.jaxb.mapping;
 
 import java.util.List;
 
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLJoinElement;
-
 /**
  * @author Steve Ebersole
  */
 public interface JoinElementSource {
 	public List<XMLJoinElement> getJoin();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/MetaAttributeContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/MetaAttributeContainer.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/MetaAttributeContainer.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/MetaAttributeContainer.java
index 1c153dbd37..6da5521d4d 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/MetaAttributeContainer.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/MetaAttributeContainer.java
@@ -1,35 +1,33 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm.xml.mapping;
+package org.hibernate.metamodel.source.hbm.jaxb.mapping;
 
 import java.util.List;
 
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLMetaElement;
-
 /**
  * @author Steve Ebersole
  */
 public interface MetaAttributeContainer {
 	public List<XMLMetaElement> getMeta();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/SubEntityElement.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/SubEntityElement.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/SubEntityElement.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/SubEntityElement.java
index eaea4c68c8..5055587a01 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/xml/mapping/SubEntityElement.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/jaxb/mapping/SubEntityElement.java
@@ -1,31 +1,31 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm.xml.mapping;
+package org.hibernate.metamodel.source.hbm.jaxb.mapping;
 
 /**
  * @author Steve Ebersole
  */
 public interface SubEntityElement extends EntityElement {
     public String getExtends();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/AbstractHbmAttributeBindingState.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/AbstractHbmAttributeBindingState.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/AbstractHbmAttributeBindingState.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/AbstractHbmAttributeBindingState.java
index 5c49d38376..39d7052f93 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/AbstractHbmAttributeBindingState.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/AbstractHbmAttributeBindingState.java
@@ -1,158 +1,158 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm.state.binding;
+package org.hibernate.metamodel.source.hbm.state.binding;
 
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.MappingException;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.binder.source.BindingContext;
-import org.hibernate.metamodel.binder.source.MappingDefaults;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
-import org.hibernate.metamodel.binder.source.hbm.Helper;
+import org.hibernate.metamodel.source.BindingContext;
+import org.hibernate.metamodel.source.MappingDefaults;
+import org.hibernate.metamodel.source.MetaAttributeContext;
+import org.hibernate.metamodel.source.hbm.Helper;
 import org.hibernate.metamodel.binding.CascadeType;
 import org.hibernate.metamodel.binding.state.AttributeBindingState;
 
 /**
  * @author Gail Badner
  */
 public abstract class AbstractHbmAttributeBindingState implements AttributeBindingState {
 	private final String ownerClassName;
 	private final String attributeName;
 	private final BindingContext bindingContext;
 	private final String nodeName;
 	private final String accessorName;
 	private final boolean isOptimisticLockable;
 	private final MetaAttributeContext metaAttributeContext;
 
 	public AbstractHbmAttributeBindingState(
 			String ownerClassName,
 			String attributeName,
 			BindingContext bindingContext,
 			String nodeName,
 			MetaAttributeContext metaAttributeContext,
 			String accessorName,
 			boolean isOptimisticLockable) {
 		if ( attributeName == null ) {
 			throw new MappingException(
 					"Attribute name cannot be null."
 			);
 		}
 
 		this.ownerClassName = ownerClassName;
 		this.attributeName = attributeName;
 		this.bindingContext = bindingContext;
 		this.nodeName = nodeName;
 		this.metaAttributeContext = metaAttributeContext;
 		this.accessorName = accessorName;
 		this.isOptimisticLockable = isOptimisticLockable;
 	}
 
 	// TODO: really don't like this here...
 	protected String getOwnerClassName() {
 		return ownerClassName;
 	}
 
 	protected Set<CascadeType> determineCascadeTypes(String cascade) {
 		String commaSeparatedCascades = Helper.getStringValue(
 				cascade,
 				getBindingContext().getMappingDefaults()
 						.getCascadeStyle()
 		);
 		Set<String> cascades = Helper.getStringValueTokens( commaSeparatedCascades, "," );
 		Set<CascadeType> cascadeTypes = new HashSet<CascadeType>( cascades.size() );
 		for ( String s : cascades ) {
 			CascadeType cascadeType = CascadeType.getCascadeType( s );
 			if ( cascadeType == null ) {
 				throw new MappingException( "Invalid cascading option " + s );
 			}
 			cascadeTypes.add( cascadeType );
 		}
 		return cascadeTypes;
 	}
 
 	protected final String getTypeNameByReflection() {
 		Class ownerClass = bindingContext.locateClassByName( ownerClassName );
 		return ReflectHelper.reflectedPropertyClass( ownerClass, attributeName ).getName();
 	}
 
 	public String getAttributeName() {
 		return attributeName;
 	}
 
 	public BindingContext getBindingContext() {
 		return bindingContext;
 	}
 
 	@Deprecated
 	protected final MappingDefaults getDefaults() {
 		return getBindingContext().getMappingDefaults();
 	}
 
 	@Override
 	public final String getPropertyAccessorName() {
 		return accessorName;
 	}
 
 	@Override
 	public final boolean isAlternateUniqueKey() {
 		//TODO: implement
 		return false;
 	}
 
 	@Override
 	public final boolean isOptimisticLockable() {
 		return isOptimisticLockable;
 	}
 
 	@Override
 	public final String getNodeName() {
 		return nodeName == null ? getAttributeName() : nodeName;
 	}
 
 	@Override
 	public MetaAttributeContext getMetaAttributeContext() {
 		return metaAttributeContext;
 	}
 
 	public PropertyGeneration getPropertyGeneration() {
 		return PropertyGeneration.NEVER;
 	}
 
 	public boolean isKeyCascadeDeleteEnabled() {
 		return false;
 	}
 
 	public String getUnsavedValue() {
 		//TODO: implement
 		return null;
 	}
 
 	public Map<String, String> getTypeParameters() {
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/HbmDiscriminatorBindingState.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/HbmDiscriminatorBindingState.java
similarity index 88%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/HbmDiscriminatorBindingState.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/HbmDiscriminatorBindingState.java
index 5ef1a4a63f..f899d8a090 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/HbmDiscriminatorBindingState.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/HbmDiscriminatorBindingState.java
@@ -1,100 +1,100 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm.state.binding;
+package org.hibernate.metamodel.source.hbm.state.binding;
 
 import java.util.Set;
 
-import org.hibernate.metamodel.binder.source.BindingContext;
-import org.hibernate.metamodel.binder.source.hbm.Helper;
+import org.hibernate.metamodel.source.BindingContext;
+import org.hibernate.metamodel.source.hbm.Helper;
 import org.hibernate.metamodel.binding.CascadeType;
 import org.hibernate.metamodel.binding.state.DiscriminatorBindingState;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping.XMLClass.XMLDiscriminator;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping.XMLClass.XMLDiscriminator;
 
 /**
  * @author Gail Badner
  */
 public class HbmDiscriminatorBindingState
 		extends AbstractHbmAttributeBindingState
 		implements DiscriminatorBindingState {
 	private final String discriminatorValue;
 	private final boolean isForced;
 	private final boolean isInserted;
 	private final String typeName;
 
 	public HbmDiscriminatorBindingState(
 			String entityName,
 			String ownerClassName,
 			BindingContext bindingContext,
 			XMLHibernateMapping.XMLClass xmlEntityClazz) {
 		super(
 				ownerClassName,
 				bindingContext.getMappingDefaults().getDiscriminatorColumnName(),
 				bindingContext,
 				null,
 				null,
 				null,
 				true
 		);
 		XMLDiscriminator discriminator = xmlEntityClazz.getDiscriminator();
 		this.discriminatorValue =  Helper.getStringValue(
 				xmlEntityClazz.getDiscriminatorValue(), entityName
 		);
 		this.isForced = xmlEntityClazz.getDiscriminator().isForce();
 		this.isInserted = discriminator.isInsert();
 		this.typeName =  discriminator.getType() == null ? "string" : discriminator.getType();
 	}
 
 	public Set<CascadeType> getCascadeTypes() {
 		return null;
 	}
 
 	protected boolean isEmbedded() {
 		return false;
 	}
 
 	public String getTypeName() {
 		return typeName;
 	}
 
 	@Override
 	public boolean isLazy() {
 		return false;
 	}
 
 	@Override
 	public boolean isInserted() {
 		return isInserted;
 	}
 
 	@Override
 	public String getDiscriminatorValue() {
 		return discriminatorValue;
 	}
 
 	@Override
 	public boolean isForced() {
 		return isForced;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/HbmManyToOneAttributeBindingState.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/HbmManyToOneAttributeBindingState.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/HbmManyToOneAttributeBindingState.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/HbmManyToOneAttributeBindingState.java
index 1d7e038efa..1b15eb1d80 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/HbmManyToOneAttributeBindingState.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/HbmManyToOneAttributeBindingState.java
@@ -1,183 +1,183 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm.state.binding;
+package org.hibernate.metamodel.source.hbm.state.binding;
 
 import java.util.Set;
 
 import org.hibernate.FetchMode;
 import org.hibernate.internal.util.ReflectHelper;
-import org.hibernate.metamodel.binder.source.BindingContext;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
-import org.hibernate.metamodel.binder.source.hbm.Helper;
+import org.hibernate.metamodel.source.BindingContext;
+import org.hibernate.metamodel.source.MetaAttributeContext;
+import org.hibernate.metamodel.source.hbm.Helper;
 import org.hibernate.metamodel.binding.CascadeType;
 import org.hibernate.metamodel.binding.state.ManyToOneAttributeBindingState;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLManyToOneElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLManyToOneElement;
 
 /**
  * @author Gail Badner
  */
 public class HbmManyToOneAttributeBindingState
 		extends AbstractHbmAttributeBindingState
 		implements ManyToOneAttributeBindingState {
 
 	private final FetchMode fetchMode;
 	private final boolean isUnwrapProxy;
 	private final boolean isLazy;
 	private final Set<CascadeType> cascadeTypes;
 	private final boolean isEmbedded;
 	private final String referencedPropertyName;
 	private final String referencedEntityName;
 	private final boolean ignoreNotFound;
 	private final boolean isInsertable;
 	private final boolean isUpdateable;
 
 	public HbmManyToOneAttributeBindingState(
 			String ownerClassName,
 			BindingContext bindingContext,
 			MetaAttributeContext parentMetaAttributeContext,
 			XMLManyToOneElement manyToOne) {
 		super(
 				ownerClassName,
 				manyToOne.getName(),
 				bindingContext,
 				manyToOne.getNode(),
 				Helper.extractMetaAttributeContext( manyToOne.getMeta(), parentMetaAttributeContext ),
 				Helper.getPropertyAccessorName(
 						manyToOne.getAccess(),
 						manyToOne.isEmbedXml(),
 						bindingContext.getMappingDefaults().getPropertyAccessorName()
 				),
 				manyToOne.isOptimisticLock()
 		);
 		fetchMode = getFetchMode( manyToOne );
 		isUnwrapProxy = manyToOne.getLazy() != null && "no-proxy".equals( manyToOne.getLazy().value() );
 		//TODO: better to degrade to lazy="false" if uninstrumented
 		isLazy = manyToOne.getLazy() == null ||
 				isUnwrapProxy ||
 				"proxy".equals( manyToOne.getLazy().value() );
 		cascadeTypes = determineCascadeTypes( manyToOne.getCascade() );
 		isEmbedded = manyToOne.isEmbedXml();
 		referencedEntityName = getReferencedEntityName( ownerClassName, manyToOne, bindingContext );
 		referencedPropertyName = manyToOne.getPropertyRef();
 		ignoreNotFound = "ignore".equals( manyToOne.getNotFound().value() );
 		isInsertable = manyToOne.isInsert();
 		isUpdateable = manyToOne.isUpdate();
 	}
 
 	// TODO: is this needed???
 	protected boolean isEmbedded() {
 		return isEmbedded;
 	}
 
 	private static String getReferencedEntityName(
 			String ownerClassName,
 			XMLManyToOneElement manyToOne,
 			BindingContext bindingContext) {
 		String referencedEntityName;
 		if ( manyToOne.getEntityName() != null ) {
 			referencedEntityName = manyToOne.getEntityName();
 		}
 		else if ( manyToOne.getClazz() != null ) {
 			referencedEntityName = Helper.qualifyIfNeeded(
 					manyToOne.getClazz(), bindingContext.getMappingDefaults().getPackageName()
 			);
 		}
 		else {
 			Class ownerClazz = Helper.classForName( ownerClassName, bindingContext.getServiceRegistry() );
 			referencedEntityName = ReflectHelper.reflectedPropertyClass( ownerClazz, manyToOne.getName() ).getName();
 		}
 		return referencedEntityName;
 	}
 
 	// same as for plural attributes...
 	private static FetchMode getFetchMode(XMLManyToOneElement manyToOne) {
 		FetchMode fetchMode;
 		if ( manyToOne.getFetch() != null ) {
 			fetchMode = "join".equals( manyToOne.getFetch().value() ) ? FetchMode.JOIN : FetchMode.SELECT;
 		}
 		else {
 			String jfNodeValue = ( manyToOne.getOuterJoin() == null ? "auto" : manyToOne.getOuterJoin().value() );
 			if ( "auto".equals( jfNodeValue ) ) {
 				fetchMode = FetchMode.DEFAULT;
 			}
 			else if ( "true".equals( jfNodeValue ) ) {
 				fetchMode = FetchMode.JOIN;
 			}
 			else {
 				fetchMode = FetchMode.SELECT;
 			}
 		}
 		return fetchMode;
 	}
 
 	public String getTypeName() {
 		return referencedEntityName;
 	}
 
 	public FetchMode getFetchMode() {
 		return fetchMode;
 	}
 
 	public boolean isLazy() {
 		return isLazy;
 	}
 
 	public boolean isUnwrapProxy() {
 		return isUnwrapProxy;
 	}
 
 	public String getReferencedAttributeName() {
 		return referencedPropertyName;
 	}
 
 	public String getReferencedEntityName() {
 		return referencedEntityName;
 	}
 
 	public Set<CascadeType> getCascadeTypes() {
 		return cascadeTypes;
 	}
 
 	public boolean ignoreNotFound() {
 		return ignoreNotFound;
 	}
 
 	public boolean isInsertable() {
 		return isInsertable;
 	}
 
 	public boolean isUpdatable() {
 		return isUpdateable;
 	}
 
 	public boolean isKeyCascadeDeleteEnabled() {
 		//TODO: implement
 		return false;
 	}
 
 	public String getUnsavedValue() {
 		//TODO: implement
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/HbmPluralAttributeBindingState.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/HbmPluralAttributeBindingState.java
similarity index 91%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/HbmPluralAttributeBindingState.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/HbmPluralAttributeBindingState.java
index 7d74f1c686..c94f45c12f 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/HbmPluralAttributeBindingState.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/HbmPluralAttributeBindingState.java
@@ -1,283 +1,283 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm.state.binding;
+package org.hibernate.metamodel.source.hbm.state.binding;
 
 import java.util.Comparator;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Set;
 
 import org.hibernate.FetchMode;
-import org.hibernate.metamodel.binder.source.BindingContext;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
-import org.hibernate.metamodel.binder.source.hbm.Helper;
+import org.hibernate.metamodel.source.BindingContext;
+import org.hibernate.metamodel.source.MetaAttributeContext;
+import org.hibernate.metamodel.source.hbm.Helper;
 import org.hibernate.metamodel.binding.CascadeType;
 import org.hibernate.metamodel.binding.CustomSQL;
 import org.hibernate.metamodel.binding.state.PluralAttributeBindingState;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLBagElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSqlDeleteAllElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSqlDeleteElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSqlInsertElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSqlUpdateElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLSynchronizeElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLBagElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSqlDeleteAllElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSqlDeleteElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSqlInsertElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSqlUpdateElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLSynchronizeElement;
 
 /**
  * @author Gail Badner
  */
 public class HbmPluralAttributeBindingState extends AbstractHbmAttributeBindingState
 		implements PluralAttributeBindingState {
 	private final XMLBagElement collection;
 	private final Class collectionPersisterClass;
 	private final String typeName;
 	private final Set<CascadeType> cascadeTypes;
 
 	public HbmPluralAttributeBindingState(
 			String ownerClassName,
 			BindingContext bindingContext,
 			MetaAttributeContext parentMetaAttributeContext,
 			XMLBagElement collection) {
 		super(
 				ownerClassName,
 				collection.getName(),
 				bindingContext,
 				collection.getNode(),
 				Helper.extractMetaAttributeContext( collection.getMeta(), parentMetaAttributeContext ),
 				Helper.getPropertyAccessorName(
 						collection.getAccess(),
 						collection.isEmbedXml(),
 						bindingContext.getMappingDefaults().getPropertyAccessorName()
 				),
 				collection.isOptimisticLock()
 		);
 		this.collection = collection;
 		this.collectionPersisterClass = Helper.classForName(
 				collection.getPersister(), getBindingContext().getServiceRegistry()
 		);
 		this.cascadeTypes = determineCascadeTypes( collection.getCascade() );
 
 		//Attribute typeNode = collectionElement.attribute( "collection-type" );
 		//if ( typeNode != null ) {
 		// TODO: implement when typedef binding is implemented
 		/*
 		   String typeName = typeNode.getValue();
 		   TypeDef typeDef = mappings.getTypeDef( typeName );
 		   if ( typeDef != null ) {
 			   collectionBinding.setTypeName( typeDef.getTypeClass() );
 			   collectionBinding.setTypeParameters( typeDef.getParameters() );
 		   }
 		   else {
 			   collectionBinding.setTypeName( typeName );
 		   }
 		   */
 		//}
 		typeName = collection.getCollectionType();
 	}
 
 	public FetchMode getFetchMode() {
 		FetchMode fetchMode;
 		if ( collection.getFetch() != null ) {
 			fetchMode = "join".equals( collection.getFetch().value() ) ? FetchMode.JOIN : FetchMode.SELECT;
 		}
 		else {
 			String jfNodeValue = ( collection.getOuterJoin().value() == null ? "auto" : collection.getOuterJoin()
 					.value() );
 			if ( "auto".equals( jfNodeValue ) ) {
 				fetchMode = FetchMode.DEFAULT;
 			}
 			else if ( "true".equals( jfNodeValue ) ) {
 				fetchMode = FetchMode.JOIN;
 			}
 			else {
 				fetchMode = FetchMode.SELECT;
 			}
 		}
 		return fetchMode;
 	}
 
 	public boolean isLazy() {
 		return isExtraLazy() ||
 				Helper.getBooleanValue(
 						collection.getLazy().value(), getBindingContext().getMappingDefaults().areAssociationsLazy()
 				);
 	}
 
 	public boolean isExtraLazy() {
 		return ( "extra".equals( collection.getLazy().value() ) );
 	}
 
 	public String getElementTypeName() {
 		return collection.getElement().getTypeAttribute();
 
 	}
 
 	public String getElementNodeName() {
 		return collection.getElement().getNode();
 	}
 
 	public boolean isInverse() {
 		return collection.isInverse();
 	}
 
 	public boolean isMutable() {
 		return collection.isMutable();
 	}
 
 	public boolean isSubselectLoadable() {
 		return "subselect".equals( collection.getFetch().value() );
 	}
 
 	public String getCacheConcurrencyStrategy() {
 		return collection.getCache() == null ?
 				null :
 				collection.getCache().getUsage();
 	}
 
 	public String getCacheRegionName() {
 		return collection.getCache() == null ?
 				null :
 				collection.getCache().getRegion();
 	}
 
 	public String getOrderBy() {
 		return collection.getOrderBy();
 	}
 
 	public String getWhere() {
 		return collection.getWhere();
 	}
 
 	public String getReferencedPropertyName() {
 		return collection.getKey().getPropertyRef();
 	}
 
 	public boolean isSorted() {
 		// SORT
 		// unsorted, natural, comparator.class.name
 		return ( !"unsorted".equals( getSortString() ) );
 	}
 
 	public Comparator getComparator() {
 		return null;
 	}
 
 	public String getComparatorClassName() {
 		String sortString = getSortString();
 		return (
 				isSorted() && !"natural".equals( sortString ) ?
 						sortString :
 						null
 		);
 	}
 
 	private String getSortString() {
 		//TODO: Bag does not define getSort(); update this when there is a Collection subtype
 		// collection.getSort() == null ? "unsorted" : collection.getSort();
 		return "unsorted";
 	}
 
 	public boolean isOrphanDelete() {
 		// ORPHAN DELETE (used for programmer error detection)
 		return true;
 		//return ( getCascade().indexOf( "delete-orphan" ) >= 0 );
 	}
 
 	public int getBatchSize() {
 		return Helper.getIntValue( collection.getBatchSize(), 0 );
 	}
 
 	@Override
 	public boolean isEmbedded() {
 		return collection.isEmbedXml();
 	}
 
 	public boolean isOptimisticLocked() {
 		return collection.isOptimisticLock();
 	}
 
 	public Class getCollectionPersisterClass() {
 		return collectionPersisterClass;
 	}
 
 	public java.util.Map getFilters() {
 		// TODO: IMPLEMENT
 		//Iterator iter = collectionElement.elementIterator( "filter" );
 		//while ( iter.hasNext() ) {
 		//	final Element filter = (Element) iter.next();
 		//	parseFilter( filter, collectionElement, collectionBinding );
 		//}
 		return new HashMap();
 	}
 
 	public java.util.Set getSynchronizedTables() {
 		java.util.Set<String> synchronizedTables = new HashSet<String>();
 		for ( XMLSynchronizeElement sync : collection.getSynchronize() ) {
 			synchronizedTables.add( sync.getTable() );
 		}
 		return synchronizedTables;
 	}
 
 	public CustomSQL getCustomSQLInsert() {
 		XMLSqlInsertElement sqlInsert = collection.getSqlInsert();
 		return Helper.buildCustomSql( sqlInsert );
 	}
 
 	public CustomSQL getCustomSQLUpdate() {
 		XMLSqlUpdateElement sqlUpdate = collection.getSqlUpdate();
 		return Helper.buildCustomSql( sqlUpdate );
 	}
 
 	public CustomSQL getCustomSQLDelete() {
 		XMLSqlDeleteElement sqlDelete = collection.getSqlDelete();
 		return Helper.buildCustomSql( sqlDelete );
 	}
 
 	public CustomSQL getCustomSQLDeleteAll() {
 		XMLSqlDeleteAllElement sqlDeleteAll = collection.getSqlDeleteAll();
 		return Helper.buildCustomSql( sqlDeleteAll );
 	}
 
 	public String getLoaderName() {
 		return collection.getLoader() == null ?
 				null :
 				collection.getLoader().getQueryRef();
 	}
 
 	public Set<CascadeType> getCascadeTypes() {
 		return cascadeTypes;
 	}
 
 	public boolean isKeyCascadeDeleteEnabled() {
 		//TODO: implement
 		return false;
 	}
 
 	public String getUnsavedValue() {
 		//TODO: implement
 		return null;
 	}
 
 	public String getTypeName() {
 		return typeName;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/HbmSimpleAttributeBindingState.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/HbmSimpleAttributeBindingState.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/HbmSimpleAttributeBindingState.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/HbmSimpleAttributeBindingState.java
index db60f625cb..808d4836b9 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/binding/HbmSimpleAttributeBindingState.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/binding/HbmSimpleAttributeBindingState.java
@@ -1,295 +1,295 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm.state.binding;
+package org.hibernate.metamodel.source.hbm.state.binding;
 
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.MappingException;
 import org.hibernate.mapping.PropertyGeneration;
-import org.hibernate.metamodel.binder.source.BindingContext;
-import org.hibernate.metamodel.binder.source.MappingDefaults;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
-import org.hibernate.metamodel.binder.source.hbm.Helper;
+import org.hibernate.metamodel.source.BindingContext;
+import org.hibernate.metamodel.source.MappingDefaults;
+import org.hibernate.metamodel.source.MetaAttributeContext;
+import org.hibernate.metamodel.source.hbm.Helper;
 import org.hibernate.metamodel.binding.CascadeType;
 import org.hibernate.metamodel.binding.state.SimpleAttributeBindingState;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping.XMLClass.XMLId;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping.XMLClass.XMLTimestamp;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping.XMLClass.XMLVersion;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLParamElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLPropertyElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping.XMLClass.XMLId;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping.XMLClass.XMLTimestamp;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping.XMLClass.XMLVersion;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLParamElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLPropertyElement;
 
 /**
  * @author Gail Badner
  */
 public class HbmSimpleAttributeBindingState extends AbstractHbmAttributeBindingState
 		implements SimpleAttributeBindingState {
 	private final String typeName;
 	private final Map<String, String> typeParameters = new HashMap<String, String>();
 
 	private final boolean isLazy;
 	private final PropertyGeneration propertyGeneration;
 	private final boolean isInsertable;
 	private final boolean isUpdatable;
 
 	public HbmSimpleAttributeBindingState(
 			String ownerClassName,
 			BindingContext bindingContext,
 			MetaAttributeContext parentMetaAttributeContext,
 			XMLId id) {
 		super(
 				ownerClassName,
 				id.getName() != null ? id.getName() : bindingContext.getMappingDefaults().getIdColumnName(),
 				bindingContext,
 				id.getNode(),
 				Helper.extractMetaAttributeContext( id.getMeta(), parentMetaAttributeContext ),
 				Helper.getPropertyAccessorName(
 						id.getAccess(),
 						false,
 						bindingContext.getMappingDefaults().getPropertyAccessorName()
 				),
 				true
 		);
 
 		this.isLazy = false;
 		if ( id.getTypeAttribute() != null ) {
 			typeName = maybeConvertToTypeDefName( id.getTypeAttribute(), bindingContext.getMappingDefaults() );
 		}
 		else if ( id.getType() != null ) {
 			typeName = maybeConvertToTypeDefName( id.getType().getName(), bindingContext.getMappingDefaults() );
 		}
 		else {
 			typeName = getTypeNameByReflection();
 		}
 
 		// TODO: how should these be set???
 		this.propertyGeneration = PropertyGeneration.parse( null );
 		this.isInsertable = true;
 
 		this.isUpdatable = false;
 	}
 
 	private static String maybeConvertToTypeDefName(String typeName, MappingDefaults defaults) {
 		String actualTypeName = typeName;
 		if ( typeName != null ) {
 			// TODO: tweak for typedef...
 		}
 		else {
 		}
 		return actualTypeName;
 	}
 
 	public HbmSimpleAttributeBindingState(
 			String ownerClassName,
 			BindingContext bindingContext,
 			MetaAttributeContext parentMetaAttributeContext,
 			XMLVersion version) {
 		super(
 				ownerClassName,
 				version.getName(),
 				bindingContext,
 				version.getNode(),
 				Helper.extractMetaAttributeContext( version.getMeta(), parentMetaAttributeContext ),
 				Helper.getPropertyAccessorName(
 						version.getAccess(),
 						false,
 						bindingContext.getMappingDefaults().getPropertyAccessorName()
 				),
 				true
 		);
 		this.typeName = version.getType() == null ? "integer" : version.getType();
 
 		this.isLazy = false;
 
 		// for version properties marked as being generated, make sure they are "always"
 		// generated; aka, "insert" is invalid; this is dis-allowed by the DTD,
 		// but just to make sure.
 		this.propertyGeneration = PropertyGeneration.parse( version.getGenerated().value() );
 		if ( propertyGeneration == PropertyGeneration.INSERT ) {
 			throw new MappingException( "'generated' attribute cannot be 'insert' for versioning property" );
 		}
 		this.isInsertable = Helper.getBooleanValue( version.isInsert(), true );
 		this.isUpdatable = true;
 	}
 
 	public HbmSimpleAttributeBindingState(
 			String ownerClassName,
 			BindingContext bindingContext,
 			MetaAttributeContext parentMetaAttributeContext,
 			XMLTimestamp timestamp) {
 
 		super(
 				ownerClassName,
 				timestamp.getName(),
 				bindingContext,
 				timestamp.getNode(),
 				Helper.extractMetaAttributeContext( timestamp.getMeta(), parentMetaAttributeContext ),
 				Helper.getPropertyAccessorName(
 						timestamp.getAccess(),
 						false,
 						bindingContext.getMappingDefaults().getPropertyAccessorName()
 				),
 				true
 		);
 
 		// Timestamp.getType() is not defined
 		this.typeName = "db".equals( timestamp.getSource() ) ? "dbtimestamp" : "timestamp";
 		this.isLazy = false;
 
 		// for version properties marked as being generated, make sure they are "always"
 		// generated; aka, "insert" is invalid; this is dis-allowed by the DTD,
 		// but just to make sure.
 		this.propertyGeneration = PropertyGeneration.parse( timestamp.getGenerated().value() );
 		if ( propertyGeneration == PropertyGeneration.INSERT ) {
 			throw new MappingException( "'generated' attribute cannot be 'insert' for versioning property" );
 		}
 		this.isInsertable = true; //TODO: is this right????
 		this.isUpdatable = true;
 	}
 
 	public HbmSimpleAttributeBindingState(
 			String ownerClassName,
 			BindingContext bindingContext,
 			MetaAttributeContext parentMetaAttributeContext,
 			XMLPropertyElement property) {
 		super(
 				ownerClassName,
 				property.getName(),
 				bindingContext,
 				property.getNode(),
 				Helper.extractMetaAttributeContext( property.getMeta(), parentMetaAttributeContext ),
 				Helper.getPropertyAccessorName(
 						property.getAccess(),
 						false,
 						bindingContext.getMappingDefaults().getPropertyAccessorName()
 				),
 				property.isOptimisticLock()
 		);
 		this.isLazy = property.isLazy();
 		this.propertyGeneration = PropertyGeneration.parse( property.getGenerated() );
 
 		if ( propertyGeneration == PropertyGeneration.ALWAYS || propertyGeneration == PropertyGeneration.INSERT ) {
 			// generated properties can *never* be insertable.
 			if ( property.isInsert() != null && property.isInsert() ) {
 				// the user specifically supplied insert="true", which constitutes an illegal combo
 				throw new MappingException(
 						"cannot specify both insert=\"true\" and generated=\"" + propertyGeneration.getName() +
 								"\" for property: " +
 								property.getName()
 				);
 			}
 			isInsertable = false;
 		}
 		else {
 			isInsertable = Helper.getBooleanValue( property.isInsert(), true );
 		}
 		if ( propertyGeneration == PropertyGeneration.ALWAYS ) {
 			if ( property.isUpdate() != null && property.isUpdate() ) {
 				// the user specifically supplied update="true",
 				// which constitutes an illegal combo
 				throw new MappingException(
 						"cannot specify both update=\"true\" and generated=\"" + propertyGeneration.getName() +
 								"\" for property: " +
 								property.getName()
 				);
 			}
 			isUpdatable = false;
 		}
 		else {
 			isUpdatable = Helper.getBooleanValue( property.isUpdate(), true );
 		}
 
 		if ( property.getTypeAttribute() != null ) {
 			typeName = maybeConvertToTypeDefName( property.getTypeAttribute(), bindingContext.getMappingDefaults() );
 		}
 		else if ( property.getType() != null ) {
 			typeName = maybeConvertToTypeDefName( property.getType().getName(), bindingContext.getMappingDefaults() );
 			for ( XMLParamElement typeParameter : property.getType().getParam() ) {
 				//TODO: add parameters from typedef
 				typeParameters.put( typeParameter.getName(), typeParameter.getValue().trim() );
 			}
 		}
 		else {
 			typeName = getTypeNameByReflection();
 		}
 
 
 		// TODO: check for typedef first
 		/*
 		TypeDef typeDef = mappings.getTypeDef( typeName );
 		if ( typeDef != null ) {
 			typeName = typeDef.getTypeClass();
 			// parameters on the property mapping should
 			// override parameters in the typedef
 			Properties allParameters = new Properties();
 			allParameters.putAll( typeDef.getParameters() );
 			allParameters.putAll( parameters );
 			parameters = allParameters;
 		}
         */
 	}
 
 	protected boolean isEmbedded() {
 		return false;
 	}
 
 	public String getTypeName() {
 		return typeName;
 	}
 
 	public Map<String, String> getTypeParameters() {
 		return typeParameters;
 	}
 
 	public boolean isLazy() {
 		return isLazy;
 	}
 
 	public PropertyGeneration getPropertyGeneration() {
 		return propertyGeneration;
 	}
 
 	public boolean isInsertable() {
 		return isInsertable;
 	}
 
 	public boolean isUpdatable() {
 		return isUpdatable;
 	}
 
 	public Set<CascadeType> getCascadeTypes() {
 		return null;
 	}
 
 	public boolean isKeyCascadeDeleteEnabled() {
 		//TODO: implement
 		return false;
 	}
 
 	public String getUnsavedValue() {
 		//TODO: implement
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/relational/HbmColumnRelationalState.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/relational/HbmColumnRelationalState.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/relational/HbmColumnRelationalState.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/relational/HbmColumnRelationalState.java
index e470631ce5..ddffd88f5d 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/relational/HbmColumnRelationalState.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/relational/HbmColumnRelationalState.java
@@ -1,276 +1,276 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm.state.relational;
+package org.hibernate.metamodel.source.hbm.state.relational;
 
 import java.util.Set;
 
 import org.hibernate.MappingException;
 import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.metamodel.binder.source.hbm.Helper;
+import org.hibernate.metamodel.source.hbm.Helper;
 import org.hibernate.metamodel.relational.Size;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLColumnElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping.XMLClass.XMLDiscriminator;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping.XMLClass.XMLId;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping.XMLClass.XMLTimestamp;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping.XMLClass.XMLVersion;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLManyToOneElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLPropertyElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLColumnElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping.XMLClass.XMLDiscriminator;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping.XMLClass.XMLId;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping.XMLClass.XMLTimestamp;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping.XMLClass.XMLVersion;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLManyToOneElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLPropertyElement;
 import org.hibernate.metamodel.relational.state.ColumnRelationalState;
 
 // TODO: remove duplication after Id, Discriminator, Version, Timestamp, and Property extend a common interface.
 
 /**
  * @author Gail Badner
  */
 public class HbmColumnRelationalState implements ColumnRelationalState {
 	private final HbmSimpleValueRelationalStateContainer container;
 	private final String explicitColumnName;
 	private final Size size;
 	private final boolean isNullable;
 	private final boolean isUnique;
 	private final String checkCondition;
 	private final String defaultColumnValue;
 	private final String sqlType;
 	private final String customWrite;
 	private final String customRead;
 	private final String comment;
 	private final Set<String> uniqueKeys;
 	private final Set<String> indexes;
 
 	/* package-protected */
 	HbmColumnRelationalState(XMLColumnElement columnElement,
 							 HbmSimpleValueRelationalStateContainer container) {
 		this.container = container;
 		this.explicitColumnName = columnElement.getName();
 		this.size = createSize( columnElement.getLength(), columnElement.getScale(), columnElement.getPrecision() );
 		this.isNullable = !Helper.getBooleanValue( columnElement.isNotNull(), true );
 		this.isUnique = Helper.getBooleanValue( columnElement.isUnique(), true );
 		this.checkCondition = columnElement.getCheck();
 		this.defaultColumnValue = columnElement.getDefault();
 		this.sqlType = columnElement.getSqlType();
 		this.customWrite = columnElement.getWrite();
 		if ( customWrite != null && !customWrite.matches( "[^?]*\\?[^?]*" ) ) {
 			throw new MappingException( "write expression must contain exactly one value placeholder ('?') character" );
 		}
 		this.customRead = columnElement.getRead();
 		this.comment = columnElement.getComment() == null ? null : columnElement.getComment().trim();
 		this.uniqueKeys = Helper.getStringValueTokens( columnElement.getUniqueKey(), ", " );
 		this.uniqueKeys.addAll( container.getPropertyUniqueKeys() );
 		this.indexes = Helper.getStringValueTokens( columnElement.getIndex(), ", " );
 		this.indexes.addAll( container.getPropertyIndexes() );
 	}
 
 	HbmColumnRelationalState(XMLPropertyElement property,
 							 HbmSimpleValueRelationalStateContainer container) {
 		this.container = container;
 		this.explicitColumnName = property.getName();
 		this.size = createSize( property.getLength(), property.getScale(), property.getPrecision() );
 		this.isUnique = Helper.getBooleanValue( property.isUnique(), true );
 		this.isNullable = !Helper.getBooleanValue( property.isNotNull(), true );
 		this.checkCondition = null;
 		this.defaultColumnValue = null;
 		this.sqlType = null;
 		this.customWrite = null;
 		this.customRead = null;
 		this.comment = null;
 		this.uniqueKeys = Helper.getStringValueTokens( property.getUniqueKey(), ", " );
 		this.uniqueKeys.addAll( container.getPropertyUniqueKeys() );
 		this.indexes = Helper.getStringValueTokens( property.getIndex(), ", " );
 		this.indexes.addAll( container.getPropertyIndexes() );
 	}
 
 	HbmColumnRelationalState(XMLManyToOneElement manyToOne,
 							 HbmSimpleValueRelationalStateContainer container) {
 		this.container = container;
 		this.explicitColumnName = manyToOne.getName();
 		this.size = new Size();
 		this.isNullable = !Helper.getBooleanValue( manyToOne.isNotNull(), false );
 		this.isUnique = manyToOne.isUnique();
 		this.checkCondition = null;
 		this.defaultColumnValue = null;
 		this.sqlType = null;
 		this.customWrite = null;
 		this.customRead = null;
 		this.comment = null;
 		this.uniqueKeys = Helper.getStringValueTokens( manyToOne.getUniqueKey(), ", " );
 		this.uniqueKeys.addAll( container.getPropertyUniqueKeys() );
 		this.indexes = Helper.getStringValueTokens( manyToOne.getIndex(), ", " );
 		this.indexes.addAll( container.getPropertyIndexes() );
 	}
 
 	HbmColumnRelationalState(XMLId id,
 							 HbmSimpleValueRelationalStateContainer container) {
 		if ( id.getColumn() != null && !id.getColumn().isEmpty() ) {
 			throw new IllegalArgumentException( "This method should not be called with non-empty id.getColumnElement()" );
 		}
 		this.container = container;
 		this.explicitColumnName = id.getName();
 		this.size = createSize( id.getLength(), null, null );
 		this.isNullable = false;
 		this.isUnique = true;
 		this.checkCondition = null;
 		this.defaultColumnValue = null;
 		this.sqlType = null;
 		this.customWrite = null;
 		this.customRead = null;
 		this.comment = null;
 		this.uniqueKeys = container.getPropertyUniqueKeys();
 		this.indexes = container.getPropertyIndexes();
 	}
 
 	HbmColumnRelationalState(XMLDiscriminator discriminator,
 							 HbmSimpleValueRelationalStateContainer container) {
 		if ( discriminator.getColumn() != null ) {
 			throw new IllegalArgumentException(
 					"This method should not be called with null discriminator.getColumnElement()"
 			);
 		}
 		this.container = container;
 		this.explicitColumnName = null;
 		this.size = createSize( discriminator.getLength(), null, null );
 		this.isNullable = false;
 		this.isUnique = true;
 		this.checkCondition = null;
 		this.defaultColumnValue = null;
 		this.sqlType = null;
 		this.customWrite = null;
 		this.customRead = null;
 		this.comment = null;
 		this.uniqueKeys = container.getPropertyUniqueKeys();
 		this.indexes = container.getPropertyIndexes();
 	}
 
 	HbmColumnRelationalState(XMLVersion version,
 							 HbmSimpleValueRelationalStateContainer container) {
 		this.container = container;
 		this.explicitColumnName = version.getColumnAttribute();
 		if ( version.getColumn() != null && !version.getColumn().isEmpty() ) {
 			throw new IllegalArgumentException(
 					"This method should not be called with non-empty version.getColumnElement()"
 			);
 		}
 		// TODO: should set default
 		this.size = new Size();
 		this.isNullable = false;
 		this.isUnique = false;
 		this.checkCondition = null;
 		this.defaultColumnValue = null;
 		this.sqlType = null;
 		this.customWrite = null;
 		this.customRead = null;
 		this.comment = null;
 		this.uniqueKeys = container.getPropertyUniqueKeys();
 		this.indexes = container.getPropertyIndexes();
 	}
 
 	HbmColumnRelationalState(XMLTimestamp timestamp,
 							 HbmSimpleValueRelationalStateContainer container) {
 		this.container = container;
 		this.explicitColumnName = timestamp.getColumn();
 		// TODO: should set default
 		this.size = new Size();
 		this.isNullable = false;
 		this.isUnique = true; // well, it should hopefully be unique...
 		this.checkCondition = null;
 		this.defaultColumnValue = null;
 		this.sqlType = null;
 		this.customWrite = null;
 		this.customRead = null;
 		this.comment = null;
 		this.uniqueKeys = container.getPropertyUniqueKeys();
 		this.indexes = container.getPropertyIndexes();
 	}
 
 	public NamingStrategy getNamingStrategy() {
 		return container.getNamingStrategy();
 	}
 
     public boolean isGloballyQuotedIdentifiers(){
         return  container.isGloballyQuotedIdentifiers();
     }
 
 	public String getExplicitColumnName() {
 		return explicitColumnName;
 	}
 
 	public Size getSize() {
 		return size;
 	}
 
 	protected static Size createSize(String length, String scale, String precision) {
 		// TODO: should this set defaults if length, scale, precision is not specified?
 		Size size = new Size();
 		if ( length != null ) {
 			size.setLength( Integer.parseInt( length ) );
 		}
 		if ( scale != null ) {
 			size.setScale( Integer.parseInt( scale ) );
 		}
 		if ( precision != null ) {
 			size.setPrecision( Integer.parseInt( precision ) );
 		}
 		// TODO: is there an attribute for lobMultiplier?
 		return size;
 	}
 
 	public boolean isNullable() {
 		return isNullable;
 	}
 
 	public boolean isUnique() {
 		return isUnique;
 	}
 
 	public String getCheckCondition() {
 		return checkCondition;
 	}
 
 	public String getDefault() {
 		return defaultColumnValue;
 	}
 
 	public String getSqlType() {
 		return sqlType;
 	}
 
 	public String getCustomWriteFragment() {
 		return customWrite;
 	}
 
 	public String getCustomReadFragment() {
 		return customRead;
 	}
 
 	public String getComment() {
 		return comment;
 	}
 
 	public Set<String> getUniqueKeys() {
 		return uniqueKeys;
 	}
 
 	public Set<String> getIndexes() {
 		return indexes;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/relational/HbmDerivedValueRelationalState.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/relational/HbmDerivedValueRelationalState.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/relational/HbmDerivedValueRelationalState.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/relational/HbmDerivedValueRelationalState.java
index 120d77b7de..f160d074ee 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/relational/HbmDerivedValueRelationalState.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/relational/HbmDerivedValueRelationalState.java
@@ -1,41 +1,41 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm.state.relational;
+package org.hibernate.metamodel.source.hbm.state.relational;
 
 import org.hibernate.metamodel.relational.state.DerivedValueRelationalState;
 
 /**
  * @author Gail Badner
  */
 public class HbmDerivedValueRelationalState implements DerivedValueRelationalState {
 	private final String formula;
 
 	public HbmDerivedValueRelationalState(String formula) {
 		this.formula = formula.trim();
 	}
 
 	public String getFormula() {
 		return formula;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/relational/HbmManyToOneRelationalStateContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/relational/HbmManyToOneRelationalStateContainer.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/relational/HbmManyToOneRelationalStateContainer.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/relational/HbmManyToOneRelationalStateContainer.java
index 878b519273..806a06a962 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/relational/HbmManyToOneRelationalStateContainer.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/relational/HbmManyToOneRelationalStateContainer.java
@@ -1,55 +1,55 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm.state.relational;
+package org.hibernate.metamodel.source.hbm.state.relational;
 
-import org.hibernate.metamodel.binder.source.BindingContext;
+import org.hibernate.metamodel.source.BindingContext;
 import org.hibernate.metamodel.relational.state.ManyToOneRelationalState;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLManyToOneElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLManyToOneElement;
 
 /**
  * @author Gail Badner
  */
 public class HbmManyToOneRelationalStateContainer extends HbmSimpleValueRelationalStateContainer
 implements ManyToOneRelationalState {
 
 	private final boolean isLogicalOneToOne;
 	private final String foreignKeyName;
 
 	public HbmManyToOneRelationalStateContainer(
 			BindingContext bindingContext,
 			boolean autoColumnCreation,
 			XMLManyToOneElement manyToOne ) {
 		super( bindingContext, autoColumnCreation, manyToOne );
 		this.isLogicalOneToOne = manyToOne.isUnique();
 		this.foreignKeyName = manyToOne.getForeignKey();
 	}
 
 	public boolean isLogicalOneToOne() {
 		return isLogicalOneToOne;
 	}
 
 	public String getForeignKeyName() {
 		return foreignKeyName;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/relational/HbmSimpleValueRelationalStateContainer.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/relational/HbmSimpleValueRelationalStateContainer.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/relational/HbmSimpleValueRelationalStateContainer.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/relational/HbmSimpleValueRelationalStateContainer.java
index 71e142b492..9092a6e70b 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/hbm/state/relational/HbmSimpleValueRelationalStateContainer.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/state/relational/HbmSimpleValueRelationalStateContainer.java
@@ -1,225 +1,225 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.hbm.state.relational;
+package org.hibernate.metamodel.source.hbm.state.relational;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
 
 import org.hibernate.MappingException;
 import org.hibernate.cfg.NamingStrategy;
-import org.hibernate.metamodel.binder.source.BindingContext;
+import org.hibernate.metamodel.source.BindingContext;
 import org.hibernate.metamodel.binding.HibernateTypeDescriptor;
 import org.hibernate.metamodel.relational.state.SimpleValueRelationalState;
 import org.hibernate.metamodel.relational.state.TupleRelationalState;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLColumnElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping.XMLClass.XMLDiscriminator;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping.XMLClass.XMLId;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping.XMLClass.XMLTimestamp;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping.XMLClass.XMLVersion;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLManyToOneElement;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLPropertyElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLColumnElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping.XMLClass.XMLDiscriminator;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping.XMLClass.XMLId;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping.XMLClass.XMLTimestamp;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping.XMLClass.XMLVersion;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLManyToOneElement;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLPropertyElement;
 
 /**
  * @author Gail Badner
  */
 public class HbmSimpleValueRelationalStateContainer implements TupleRelationalState {
 	private final BindingContext bindingContext;
 	private final Set<String> propertyUniqueKeys;
 	private final Set<String> propertyIndexes;
 	private final List<SimpleValueRelationalState> simpleValueStates;
 	private final HibernateTypeDescriptor hibernateTypeDescriptor = new HibernateTypeDescriptor();
 
 	public BindingContext getBindingContext() {
 		return bindingContext;
 	}
     public boolean isGloballyQuotedIdentifiers(){
         return getBindingContext().isGloballyQuotedIdentifiers();
     }
 	public NamingStrategy getNamingStrategy() {
 		return getBindingContext().getNamingStrategy();
 	}
 
 	// TODO: remove duplication after Id, Discriminator, Version, Timestamp, and Property extend a common interface.
 
 	public HbmSimpleValueRelationalStateContainer(
 			BindingContext bindingContext,
 			boolean autoColumnCreation,
 			XMLId id) {
 		this( bindingContext, id.getColumn() );
 		if ( simpleValueStates.isEmpty() ) {
 			if ( id.getColumn() == null && ! autoColumnCreation ) {
 				throw new MappingException( "No columns to map and auto column creation is disabled." );
 			}
 			simpleValueStates.add( new HbmColumnRelationalState( id, this ) );
 		}
 		else if ( id.getColumn() != null ) {
 			throw new MappingException( "column attribute may not be used together with <column> subelement" );
 		}
 		this.hibernateTypeDescriptor.setTypeName( id.getTypeAttribute() );
 	}
 
 	public HbmSimpleValueRelationalStateContainer(
 			BindingContext bindingContext,
 			boolean autoColumnCreation,
 			XMLDiscriminator discriminator) {
 		this( bindingContext, discriminator.getFormula(), discriminator.getColumn() );
 		if ( simpleValueStates.isEmpty() ) {
 			if ( discriminator.getColumn() == null && discriminator.getFormula() == null &&  ! autoColumnCreation ) {
 				throw new MappingException( "No column or formula to map and auto column creation is disabled." );
 			}
 			simpleValueStates.add( new HbmColumnRelationalState( discriminator, this ) );
 		}
 		else if ( discriminator.getColumn() != null || discriminator.getFormula() != null) {
 			throw new MappingException( "column/formula attribute may not be used together with <column>/<formula> subelement" );
 		}
 		this.hibernateTypeDescriptor.setTypeName( discriminator.getType() == null ? "string" : discriminator.getType() );
 	}
 
 	public HbmSimpleValueRelationalStateContainer(
 			BindingContext bindingContext,
 			boolean autoColumnCreation,
 			XMLVersion version) {
 		this( bindingContext, version.getColumn() );
 		if ( simpleValueStates.isEmpty() ) {
 			if ( version.getColumn() == null && ! autoColumnCreation ) {
 				throw new MappingException( "No column or formula to map and auto column creation is disabled." );
 			}
 			simpleValueStates.add( new HbmColumnRelationalState( version, this ) );
 		}
 		else if ( version.getColumn() != null ) {
 			throw new MappingException( "column attribute may not be used together with <column> subelement" );
 		}
 		this.hibernateTypeDescriptor.setTypeName( version.getType() == null ? "integer" : version.getType() );
 	}
 
 	public HbmSimpleValueRelationalStateContainer(
 			BindingContext bindingContext,
 			boolean autoColumnCreation,
 			XMLTimestamp timestamp) {
 		this( bindingContext, null );
 		if ( simpleValueStates.isEmpty() ) {
 			if ( timestamp.getColumn() == null && ! autoColumnCreation ) {
 				throw new MappingException( "No columns to map and auto column creation is disabled." );
 			}
 			simpleValueStates.add( new HbmColumnRelationalState( timestamp, this ) );
 		}
 		else if ( timestamp.getColumn() != null ) {
 			throw new MappingException( "column attribute may not be used together with <column> subelement" );
 		}
 		this.hibernateTypeDescriptor.setTypeName( "db".equals( timestamp.getSource() ) ? "dbtimestamp" : "timestamp" );
 	}
 
 	public HbmSimpleValueRelationalStateContainer(
 			BindingContext bindingContext,
 			boolean autoColumnCreation,
 			XMLPropertyElement property) {
 		this( bindingContext, property.getColumnOrFormula() );
 		if ( simpleValueStates.isEmpty() ) {
 			if ( property.getColumn() == null && property.getFormula() == null &&  ! autoColumnCreation ) {
 				throw new MappingException( "No column or formula to map and auto column creation is disabled." );
 			}
 			simpleValueStates.add( new HbmColumnRelationalState( property, this ) );
 		}
 		else if ( property.getColumn() != null || property.getFormula() != null) {
 			throw new MappingException( "column/formula attribute may not be used together with <column>/<formula> subelement" );
 		}
 		this.hibernateTypeDescriptor.setTypeName( property.getTypeAttribute() );
 	}
 
 	public HbmSimpleValueRelationalStateContainer(
 			BindingContext bindingContext,
 			boolean autoColumnCreation,
 			XMLManyToOneElement manyToOne) {
 		this( bindingContext, manyToOne.getColumnOrFormula() );
 		if ( simpleValueStates.isEmpty() ) {
 			if ( manyToOne.getColumn() == null && manyToOne.getFormula() == null &&  ! autoColumnCreation ) {
 				throw new MappingException( "No column or formula to map and auto column creation is disabled." );
 			}
 			simpleValueStates.add( new HbmColumnRelationalState( manyToOne, this ) );
 		}
 		else if ( manyToOne.getColumn() != null || manyToOne.getFormula() != null) {
 			throw new MappingException( "column/formula attribute may not be used together with <column>/<formula> subelement" );
 		}
 	}
 
 	private HbmSimpleValueRelationalStateContainer(
 			BindingContext bindingContext,
 			String formulaElement,
 			XMLColumnElement columnElement) {
 		this( bindingContext,
 				formulaElement != null
 						? Collections.singletonList( formulaElement )
 						: columnElement != null
 								? Collections.singletonList( columnElement )
 								: Collections.<Object>emptyList()
 		);
 	}
 
 	private HbmSimpleValueRelationalStateContainer(
 			BindingContext bindingContext,
 			List mappedColumnsOrFormulas) {
 		this.bindingContext = bindingContext;
 		this.propertyUniqueKeys = Collections.emptySet();
 		this.propertyIndexes = Collections.emptySet();
 		simpleValueStates = new ArrayList<SimpleValueRelationalState>(
 							mappedColumnsOrFormulas == null || mappedColumnsOrFormulas.isEmpty()
 									? 1
 									: mappedColumnsOrFormulas.size()
 		);
 		if ( mappedColumnsOrFormulas != null && ! mappedColumnsOrFormulas.isEmpty() ) {
 			for ( Object mappedColumnOrFormula : mappedColumnsOrFormulas ) {
 				simpleValueStates.add( createColumnOrFormulaRelationalState( this, mappedColumnOrFormula ) );
 			}
 		}
 	}
 
 	private static SimpleValueRelationalState createColumnOrFormulaRelationalState(
 			HbmSimpleValueRelationalStateContainer container,
 			Object columnOrFormula) {
 		if ( XMLColumnElement.class.isInstance( columnOrFormula ) ) {
 			return new HbmColumnRelationalState(
 					XMLColumnElement.class.cast( columnOrFormula ),
 					container
 			);
 		}
 		else if ( String.class.isInstance( columnOrFormula ) ) {
 			return new HbmDerivedValueRelationalState( String.class.cast( columnOrFormula ) );
 		}
 		throw new MappingException( "unknown type of column or formula: " + columnOrFormula.getClass().getName() );
 	}
 
 	public List<SimpleValueRelationalState> getRelationalStates() {
 		return simpleValueStates;
 	}
 
 	Set<String> getPropertyUniqueKeys() {
 		return propertyUniqueKeys;
 	}
 
 	Set<String> getPropertyIndexes() {
 		return propertyIndexes;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/AttributeTypeResolver.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/AttributeTypeResolver.java
index 85a8bb112c..b27526c6ca 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/AttributeTypeResolver.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/AttributeTypeResolver.java
@@ -1,139 +1,139 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.internal;
 
 import java.util.Properties;
 
 import org.hibernate.MappingException;
 import org.hibernate.metamodel.binding.AttributeBinding;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.binding.HibernateTypeDescriptor;
 import org.hibernate.metamodel.domain.AbstractAttributeContainer;
 import org.hibernate.metamodel.domain.Attribute;
 import org.hibernate.metamodel.domain.BasicType;
 import org.hibernate.metamodel.domain.JavaType;
 import org.hibernate.metamodel.relational.Datatype;
 import org.hibernate.metamodel.relational.SimpleValue;
 import org.hibernate.metamodel.relational.Value;
-import org.hibernate.metamodel.source.spi.MetadataImplementor;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.type.AbstractStandardBasicType;
 import org.hibernate.type.Type;
 
 /**
  * This is a TEMPORARY way to initialize HibernateTypeDescriptor.explicitType.
  * This class will be removed when types are resolved properly.
  *
  * @author Gail Badner
  */
 class AttributeTypeResolver {
 
 	private final MetadataImplementor metadata;
 
 	AttributeTypeResolver(MetadataImplementor metadata) {
 		this.metadata = metadata;
 	}
 
 	void resolve() {
 		for ( EntityBinding entityBinding : metadata.getEntityBindings() ) {
 			for ( AttributeBinding attributeBinding : entityBinding.getAttributeBindings() ) {
 				Type type = resolveHibernateType( attributeBinding );
 				if ( type != null && ! type.isAssociationType() && ! type.isCollectionType() && ! type.isComponentType() ) {
 					resolveJavaType( attributeBinding.getAttribute(), type );
 					for ( Value value : attributeBinding.getValues() ) {
 						resolveSqlType( value, type );
 					}
 				}
 			}
 		}
 	}
 
 	private Type resolveHibernateType(AttributeBinding attributeBinding) {
 		if ( attributeBinding.getHibernateTypeDescriptor().getExplicitType() != null ) {
 			return attributeBinding.getHibernateTypeDescriptor().getExplicitType(); // already resolved
 		}
 
 		// this only works for "basic" attribute types
 		HibernateTypeDescriptor typeDescriptor = attributeBinding.getHibernateTypeDescriptor();
 		if ( typeDescriptor == null || typeDescriptor.getTypeName() == null) {
 			throw new MappingException( "Hibernate type name has not been defined for attribute: " +
 					getQualifiedAttributeName( attributeBinding )
 			);
 		}
 		Type type = null;
 		if ( typeDescriptor.getTypeName() != null ) {
 			Properties typeParameters = null;
 			if ( typeDescriptor.getTypeParameters() != null ) {
 				typeParameters = new Properties();
 				typeParameters.putAll( typeDescriptor.getTypeParameters() );
 			}
 			type = metadata.getTypeResolver().heuristicType(
 							typeDescriptor.getTypeName(),
 							typeParameters
 					);
 			typeDescriptor.setExplicitType( type );
 		}
 		return type;
 	}
 
 	// this only works for singular basic types
 	private void resolveJavaType(Attribute attribute, Type type) {
-		if ( ! ( type instanceof AbstractStandardBasicType ) || ! attribute.isSingular() ) {
-			return;
-		}
-		// Converting to SingularAttributeImpl is bad, but this resolver is TEMPORARY!
-		AbstractAttributeContainer.SingularAttributeImpl singularAttribute =
-				( AbstractAttributeContainer.SingularAttributeImpl ) attribute;
-		if ( ! singularAttribute.isTypeResolved() ) {
-			singularAttribute.resolveType(
-					new BasicType(
-							new JavaType( ( ( AbstractStandardBasicType) type ).getJavaTypeDescriptor().getJavaTypeClass() )
-					)
-			);
-		}
+//		if ( ! ( type instanceof AbstractStandardBasicType ) || ! attribute.isSingular() ) {
+//			return;
+//		}
+//		// Converting to SingularAttributeImpl is bad, but this resolver is TEMPORARY!
+//		AbstractAttributeContainer.SingularAttributeImpl singularAttribute =
+//				( AbstractAttributeContainer.SingularAttributeImpl ) attribute;
+//		if ( ! singularAttribute.isTypeResolved() ) {
+//			singularAttribute.resolveType(
+//					new BasicType(
+//							new JavaType( ( ( AbstractStandardBasicType) type ).getJavaTypeDescriptor().getJavaTypeClass() )
+//					)
+//			);
+//		}
 	}
 
 	// this only works for singular basic types
 	private void resolveSqlType(Value value, Type type) {
 		if ( value == null || ! ( value instanceof SimpleValue ) || ! ( type instanceof AbstractStandardBasicType )  ) {
 			return;
 		}
 		// Converting to AbstractStandardBasicType is bad, but this resolver is TEMPORARY!
 		AbstractStandardBasicType basicType = ( AbstractStandardBasicType ) type;
 		Datatype dataType = new Datatype(
 								basicType.getSqlTypeDescriptor().getSqlType(),
 								basicType.getName(),
 								basicType.getReturnedClass()
 						);
 		( (SimpleValue) value ).setDatatype( dataType );
 	}
 
 	// TODO: this does not work for components
 	private static String getQualifiedAttributeName(AttributeBinding attributebinding) {
 		return new StringBuilder()
-				.append( attributebinding.getEntityBinding().getEntity().getJavaType().getName() )
+				.append( attributebinding.getEntityBinding().getEntity().getName() )
 				.append( "." )
 				.append( attributebinding.getAttribute().getName() )
 				.toString();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/EntityReferenceResolver.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/EntityReferenceResolver.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/EntityReferenceResolver.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/EntityReferenceResolver.java
index 9e4de6227d..2aa3ace0bb 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/EntityReferenceResolver.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/EntityReferenceResolver.java
@@ -1,75 +1,75 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.internal;
+package org.hibernate.metamodel.source.internal;
 
 import org.hibernate.MappingException;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.metamodel.binding.AttributeBinding;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.binding.EntityReferencingAttributeBinding;
 
 /**
  * @author Gail Badner
  */
 class EntityReferenceResolver {
 
 	private final MetadataImplementor metadata;
 
 	EntityReferenceResolver(MetadataImplementor metadata) {
 		this.metadata = metadata;
 	}
 
 	void resolve() {
 		for ( EntityBinding entityBinding : metadata.getEntityBindings() ) {
 			for ( EntityReferencingAttributeBinding attributeBinding :  entityBinding.getEntityReferencingAttributeBindings() ) {
 				resolve( attributeBinding );
 			}
 		}
 	}
 
 	private void resolve(EntityReferencingAttributeBinding attributeBinding) {
 		if ( attributeBinding.getReferencedEntityName() == null ) {
 			throw new IllegalArgumentException( "attributeBinding has null entityName: " + attributeBinding.getAttribute().getName() );
 		}
 		EntityBinding entityBinding = metadata.getEntityBinding( attributeBinding.getReferencedEntityName() );
 		if ( entityBinding == null ) {
 			throw new org.hibernate.MappingException(
 					"Attribute [" + attributeBinding.getAttribute().getName() +
 					"] refers to unknown entity: [" + attributeBinding.getReferencedEntityName() + "]" );
 		}
 		AttributeBinding referencedAttributeBinding =
 				attributeBinding.isPropertyReference() ?
 						entityBinding.getAttributeBinding( attributeBinding.getReferencedAttributeName() ) :
 						entityBinding.getEntityIdentifier().getValueBinding();
 		if ( referencedAttributeBinding == null ) {
 			// TODO: does attribute name include path w/ entity name?
 			throw new MappingException(
 					"Attribute [" + attributeBinding.getAttribute().getName() +
 					"] refers to unknown attribute: [" + attributeBinding.getReferencedEntityName() + "]"
 			);
 		}
 		attributeBinding.resolveReference( referencedAttributeBinding );
 		referencedAttributeBinding.addEntityReferencingAttributeBinding( attributeBinding );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/JaxbHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/JaxbHelper.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/JaxbHelper.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/JaxbHelper.java
index d0042dac3f..64d4fd28d9 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/JaxbHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/JaxbHelper.java
@@ -1,312 +1,312 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
-package org.hibernate.metamodel.binder.source.internal;
+package org.hibernate.metamodel.source.internal;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import javax.xml.XMLConstants;
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Unmarshaller;
 import javax.xml.bind.ValidationEvent;
 import javax.xml.bind.ValidationEventHandler;
 import javax.xml.bind.ValidationEventLocator;
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLEventReader;
 import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.events.Attribute;
 import javax.xml.stream.events.XMLEvent;
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 
 import org.jboss.logging.Logger;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.xml.sax.SAXException;
 
 import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.binder.MappingException;
-import org.hibernate.metamodel.binder.Origin;
-import org.hibernate.metamodel.binder.XsdException;
+import org.hibernate.metamodel.source.MappingException;
+import org.hibernate.metamodel.source.Origin;
+import org.hibernate.metamodel.source.XsdException;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntityMappings;
-import org.hibernate.metamodel.source.hbm.xml.mapping.XMLHibernateMapping;
+import org.hibernate.metamodel.source.hbm.jaxb.mapping.XMLHibernateMapping;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 
 /**
  * Helper class for unmarshalling xml configuration using StAX and JAXB.
  *
  * @author Steve Ebersole
  * @author Hardy Ferentschik
  */
 public class JaxbHelper {
 	private static final Logger log = Logger.getLogger( JaxbHelper.class );
 
 	public static final String ASSUMED_ORM_XSD_VERSION = "2.0";
 
 	private final MetadataSources metadataSources;
 
 	public JaxbHelper(MetadataSources metadataSources) {
 		this.metadataSources = metadataSources;
 	}
 
 	public JaxbRoot unmarshal(InputStream stream, Origin origin) {
 		try {
 			XMLEventReader staxReader = staxFactory().createXMLEventReader( stream );
 			try {
 				return unmarshal( staxReader, origin );
 			}
 			finally {
 				try {
 					staxReader.close();
 				}
 				catch ( Exception ignore ) {
 				}
 			}
 		}
 		catch ( XMLStreamException e ) {
 			throw new MappingException( "Unable to create stax reader", e, origin );
 		}
 	}
 
 	private XMLInputFactory staxFactory;
 
 	private XMLInputFactory staxFactory() {
 		if ( staxFactory == null ) {
 			staxFactory = buildStaxFactory();
 		}
 		return staxFactory;
 	}
 
 	@SuppressWarnings( { "UnnecessaryLocalVariable" })
 	private XMLInputFactory buildStaxFactory() {
 		XMLInputFactory staxFactory = XMLInputFactory.newInstance();
 		return staxFactory;
 	}
 
 	private static final QName ORM_VERSION_ATTRIBUTE_QNAME = new QName( "version" );
 
 	@SuppressWarnings( { "unchecked" })
 	private JaxbRoot unmarshal(XMLEventReader staxEventReader, final Origin origin) {
 		XMLEvent event;
 		try {
 			event = staxEventReader.peek();
 			while ( event != null && !event.isStartElement() ) {
 				staxEventReader.nextEvent();
 				event = staxEventReader.peek();
 			}
 		}
 		catch ( Exception e ) {
 			throw new MappingException( "Error accessing stax stream", e, origin );
 		}
 
 		if ( event == null ) {
 			throw new MappingException( "Could not locate root element", origin );
 		}
 
 		final Schema validationSchema;
 		final Class jaxbTarget;
 
 		final String elementName = event.asStartElement().getName().getLocalPart();
 
 		if ( "entity-mappings".equals( elementName ) ) {
 			final Attribute attribute = event.asStartElement().getAttributeByName( ORM_VERSION_ATTRIBUTE_QNAME );
 			final String explicitVersion = attribute == null ? null : attribute.getValue();
 			validationSchema = resolveSupportedOrmXsd( explicitVersion );
 			jaxbTarget = XMLEntityMappings.class;
 		}
 		else {
 			validationSchema = hbmSchema();
 			jaxbTarget = XMLHibernateMapping.class;
 		}
 
 		final Object target;
 		final ContextProvidingValidationEventHandler handler = new ContextProvidingValidationEventHandler();
 		try {
 			JAXBContext jaxbContext = JAXBContext.newInstance( jaxbTarget );
 			Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
 			unmarshaller.setSchema( validationSchema );
 			unmarshaller.setEventHandler( handler );
 			target = unmarshaller.unmarshal( staxEventReader );
 		}
 
 		catch ( JAXBException e ) {
 			StringBuilder builder = new StringBuilder();
 			builder.append( "Unable to perform unmarshalling at line number " );
 			builder.append( handler.getLineNumber() );
 			builder.append( " and column " );
 			builder.append( handler.getColumnNumber() );
 			builder.append( ". Message: " );
 			builder.append( handler.getMessage() );
 			throw new MappingException( builder.toString(), e, origin );
 		}
 
 		return new JaxbRoot( target, origin );
 	}
 
 	@SuppressWarnings( { "unchecked" })
 	public JaxbRoot unmarshal(Document document, Origin origin) {
 		Element rootElement = document.getDocumentElement();
 		if ( rootElement == null ) {
 			throw new MappingException( "No root element found", origin );
 		}
 
 		final Schema validationSchema;
 		final Class jaxbTarget;
 
 		if ( "entity-mappings".equals( rootElement.getNodeName() ) ) {
 			final String explicitVersion = rootElement.getAttribute( "version" );
 			validationSchema = resolveSupportedOrmXsd( explicitVersion );
 			jaxbTarget = XMLEntityMappings.class;
 		}
 		else {
 			validationSchema = hbmSchema();
 			jaxbTarget = XMLHibernateMapping.class;
 		}
 
 		final Object target;
 		try {
 			JAXBContext jaxbContext = JAXBContext.newInstance( jaxbTarget );
 			Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
 			unmarshaller.setSchema( validationSchema );
 			target = unmarshaller.unmarshal( new DOMSource( document ) );
 		}
 		catch ( JAXBException e ) {
 			throw new MappingException( "Unable to perform unmarshalling", e, origin );
 		}
 
 		return new JaxbRoot( target, origin );
 	}
 
 	private Schema resolveSupportedOrmXsd(String explicitVersion) {
 		final String xsdVersionString = explicitVersion == null ? ASSUMED_ORM_XSD_VERSION : explicitVersion;
 		if ( "1.0".equals( xsdVersionString ) ) {
 			return orm1Schema();
 		}
 		else if ( "2.0".equals( xsdVersionString ) ) {
 			return orm2Schema();
 		}
 		throw new IllegalArgumentException( "Unsupported orm.xml XSD version encountered [" + xsdVersionString + "]" );
 	}
 
 	public static final String HBM_SCHEMA_NAME = "org/hibernate/hibernate-mapping-4.0.xsd";
 	public static final String ORM_1_SCHEMA_NAME = "org/hibernate/ejb/orm_1_0.xsd";
 	public static final String ORM_2_SCHEMA_NAME = "org/hibernate/ejb/orm_2_0.xsd";
 
 	private Schema hbmSchema;
 
 	private Schema hbmSchema() {
 		if ( hbmSchema == null ) {
 			hbmSchema = resolveLocalSchema( HBM_SCHEMA_NAME );
 		}
 		return hbmSchema;
 	}
 
 	private Schema orm1Schema;
 
 	private Schema orm1Schema() {
 		if ( orm1Schema == null ) {
 			orm1Schema = resolveLocalSchema( ORM_1_SCHEMA_NAME );
 		}
 		return orm1Schema;
 	}
 
 	private Schema orm2Schema;
 
 	private Schema orm2Schema() {
 		if ( orm2Schema == null ) {
 			orm2Schema = resolveLocalSchema( ORM_2_SCHEMA_NAME );
 		}
 		return orm2Schema;
 	}
 
 	private Schema resolveLocalSchema(String schemaName) {
 		return resolveLocalSchema( schemaName, XMLConstants.W3C_XML_SCHEMA_NS_URI );
 	}
 
 	private Schema resolveLocalSchema(String schemaName, String schemaLanguage) {
 		URL url = metadataSources.getServiceRegistry()
 				.getService( ClassLoaderService.class )
 				.locateResource( schemaName );
 		if ( url == null ) {
 			throw new XsdException( "Unable to locate schema [" + schemaName + "] via classpath", schemaName );
 		}
 		try {
 			InputStream schemaStream = url.openStream();
 			try {
 				StreamSource source = new StreamSource( url.openStream() );
 				SchemaFactory schemaFactory = SchemaFactory.newInstance( schemaLanguage );
 				return schemaFactory.newSchema( source );
 			}
 			catch ( SAXException e ) {
 				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
 			}
 			catch ( IOException e ) {
 				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
 			}
 			finally {
 				try {
 					schemaStream.close();
 				}
 				catch ( IOException e ) {
 					log.debugf( "Problem closing schema stream [%s]", e.toString() );
 				}
 			}
 		}
 		catch ( IOException e ) {
 			throw new XsdException( "Stream error handling schema url [" + url.toExternalForm() + "]", schemaName );
 		}
 	}
 
 	static class ContextProvidingValidationEventHandler implements ValidationEventHandler {
 		private int lineNumber;
 		private int columnNumber;
 		private String message;
 
 		@Override
 		public boolean handleEvent(ValidationEvent validationEvent) {
 			ValidationEventLocator locator = validationEvent.getLocator();
 			lineNumber = locator.getLineNumber();
 			columnNumber = locator.getColumnNumber();
 			message = validationEvent.getMessage();
 			return false;
 		}
 
 		public int getLineNumber() {
 			return lineNumber;
 		}
 
 		public int getColumnNumber() {
 			return columnNumber;
 		}
 
 		public String getMessage() {
 			return message;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/JaxbRoot.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/JaxbRoot.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/JaxbRoot.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/JaxbRoot.java
index 4152de5308..888b05aecb 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/JaxbRoot.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/JaxbRoot.java
@@ -1,60 +1,60 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.internal;
+package org.hibernate.metamodel.source.internal;
 
-import org.hibernate.metamodel.binder.Origin;
+import org.hibernate.metamodel.source.Origin;
 
 /**
  * Holds information about a JAXB-unmarshalled XML document.
  *
  * @author Hardy Ferentschik
  * @author Steve Ebersole
  */
 public class JaxbRoot<T> {
 	private final T root;
 	private final Origin origin;
 
 	public JaxbRoot(T root, Origin origin) {
 		this.root = root;
 		this.origin = origin;
 	}
 
 	/**
 	 * Obtain the root JAXB bound object
 	 *
 	 * @return The JAXB root object
 	 */
 	public T getRoot() {
 		return root;
 	}
 
 	/**
 	 * Obtain the metadata about the document's origin
 	 *
 	 * @return The origin
 	 */
 	public Origin getOrigin() {
 		return origin;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/MetadataBuilderImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataBuilderImpl.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/MetadataBuilderImpl.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataBuilderImpl.java
index bc22b1c112..0bb2ea2cce 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/MetadataBuilderImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataBuilderImpl.java
@@ -1,196 +1,196 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.internal;
+package org.hibernate.metamodel.source.internal;
 
 import javax.persistence.SharedCacheMode;
 
 import org.hibernate.cache.spi.access.AccessType;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.EJB3NamingStrategy;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.metamodel.Metadata;
 import org.hibernate.metamodel.MetadataBuilder;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.SourceProcessingOrder;
 import org.hibernate.service.BasicServiceRegistry;
 import org.hibernate.service.config.spi.ConfigurationService;
 
 /**
  * @author Steve Ebersole
  */
 public class MetadataBuilderImpl implements MetadataBuilder {
 	private final MetadataSources sources;
 	private final OptionsImpl options;
 
 	public MetadataBuilderImpl(MetadataSources sources) {
 		this.sources = sources;
 		this.options = new OptionsImpl( sources.getServiceRegistry() );
 	}
 
 	@Override
 	public MetadataBuilder with(NamingStrategy namingStrategy) {
 		this.options.namingStrategy = namingStrategy;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(SourceProcessingOrder sourceProcessingOrder) {
 		this.options.sourceProcessingOrder = sourceProcessingOrder;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(SharedCacheMode sharedCacheMode) {
 		this.options.sharedCacheMode = sharedCacheMode;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(AccessType accessType) {
 		this.options.defaultCacheAccessType = accessType;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder withNewIdentifierGeneratorsEnabled(boolean enabled) {
 		this.options.useNewIdentifierGenerators = enabled;
 		return this;
 	}
 
 	@Override
 	public Metadata buildMetadata() {
 		return new MetadataImpl( sources, options );
 	}
 
 	private static class OptionsImpl implements Metadata.Options {
 		private SourceProcessingOrder sourceProcessingOrder = SourceProcessingOrder.HBM_FIRST;
 		private NamingStrategy namingStrategy = EJB3NamingStrategy.INSTANCE;
 		private SharedCacheMode sharedCacheMode = SharedCacheMode.ENABLE_SELECTIVE;
 		private AccessType defaultCacheAccessType;
         private boolean useNewIdentifierGenerators;
         private boolean globallyQuotedIdentifiers;
 		private String defaultSchemaName;
 		private String defaultCatalogName;
 
 		public OptionsImpl(BasicServiceRegistry serviceRegistry) {
 			ConfigurationService configService = serviceRegistry.getService( ConfigurationService.class );
 
 			// cache access type
 			defaultCacheAccessType = configService.getSetting(
 					AvailableSettings.DEFAULT_CACHE_CONCURRENCY_STRATEGY,
 					new ConfigurationService.Converter<AccessType>() {
 						@Override
 						public AccessType convert(Object value) {
 							return AccessType.fromExternalName( value.toString() );
 						}
 					}
 			);
 
 			useNewIdentifierGenerators = configService.getSetting(
 					AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS,
 					new ConfigurationService.Converter<Boolean>() {
 						@Override
 						public Boolean convert(Object value) {
 							return Boolean.parseBoolean( value.toString() );
 						}
 					},
 					false
 			);
 
 			defaultSchemaName = configService.getSetting(
 					AvailableSettings.DEFAULT_SCHEMA,
 					new ConfigurationService.Converter<String>() {
 						@Override
 						public String convert(Object value) {
 							return value.toString();
 						}
 					},
 					null
 			);
 
 			defaultCatalogName = configService.getSetting(
 					AvailableSettings.DEFAULT_CATALOG,
 					new ConfigurationService.Converter<String>() {
 						@Override
 						public String convert(Object value) {
 							return value.toString();
 						}
 					},
 					null
 			);
 
             globallyQuotedIdentifiers = configService.getSetting(
                     AvailableSettings.GLOBALLY_QUOTED_IDENTIFIERS,
                     new ConfigurationService.Converter<Boolean>() {
                         @Override
                         public Boolean convert(Object value) {
                             return Boolean.parseBoolean( value.toString() );
                         }
                     },
                     false
             );
 		}
 
 
 		@Override
 		public SourceProcessingOrder getSourceProcessingOrder() {
 			return sourceProcessingOrder;
 		}
 
 		@Override
 		public NamingStrategy getNamingStrategy() {
 			return namingStrategy;
 		}
 
 		@Override
 		public AccessType getDefaultAccessType() {
 			return defaultCacheAccessType;
 		}
 
 		@Override
 		public SharedCacheMode getSharedCacheMode() {
 			return sharedCacheMode;
 		}
 
 		@Override
         public boolean useNewIdentifierGenerators() {
             return useNewIdentifierGenerators;
         }
 
         @Override
         public boolean isGloballyQuotedIdentifiers() {
             return globallyQuotedIdentifiers;
         }
 
         @Override
 		public String getDefaultSchemaName() {
 			return defaultSchemaName;
 		}
 
 		@Override
 		public String getDefaultCatalogName() {
 			return defaultCatalogName;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/MetadataImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataImpl.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/MetadataImpl.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataImpl.java
index eb0ee4a5c7..6811d33a44 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/MetadataImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataImpl.java
@@ -1,593 +1,592 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.internal;
+package org.hibernate.metamodel.source.internal;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.DuplicateMappingException;
 import org.hibernate.MappingException;
 import org.hibernate.SessionFactory;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cache.spi.access.AccessType;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.id.factory.DefaultIdentifierGeneratorFactory;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.Value;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.SessionFactoryBuilder;
 import org.hibernate.metamodel.SourceProcessingOrder;
-import org.hibernate.metamodel.binder.source.MappingDefaults;
-import org.hibernate.metamodel.binder.source.MetaAttributeContext;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.SourceProcessor;
-import org.hibernate.metamodel.binder.source.annotations.AnnotationsSourceProcessor;
-import org.hibernate.metamodel.binder.source.hbm.HbmSourceProcessorImpl;
+import org.hibernate.metamodel.source.MappingDefaults;
+import org.hibernate.metamodel.source.MetaAttributeContext;
+import org.hibernate.metamodel.source.MetadataImplementor;
+import org.hibernate.metamodel.source.SourceProcessor;
+import org.hibernate.metamodel.source.hbm.HbmSourceProcessorImpl;
 import org.hibernate.metamodel.binding.AttributeBinding;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.binding.FetchProfile;
 import org.hibernate.metamodel.binding.IdGenerator;
 import org.hibernate.metamodel.binding.PluralAttributeBinding;
 import org.hibernate.metamodel.binding.TypeDef;
 import org.hibernate.metamodel.domain.BasicType;
 import org.hibernate.metamodel.domain.Type;
 import org.hibernate.metamodel.relational.Database;
 import org.hibernate.persister.spi.PersisterClassResolver;
 import org.hibernate.service.BasicServiceRegistry;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.type.TypeResolver;
 
 /**
  * Container for configuration data collected during binding the metamodel.
  *
  * @author Steve Ebersole
  * @author Hardy Ferentschik
  * @author Gail Badner
  */
 public class MetadataImpl implements MetadataImplementor, Serializable {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			MetadataImpl.class.getName()
 	);
 
 	private final BasicServiceRegistry serviceRegistry;
 	private final Options options;
 
 	private final Value<ClassLoaderService> classLoaderService;
 	private final Value<PersisterClassResolver> persisterClassResolverService;
 
 	private TypeResolver typeResolver = new TypeResolver();
 
 	private SessionFactoryBuilder sessionFactoryBuilder = new SessionFactoryBuilderImpl( this );
 
 	private DefaultIdentifierGeneratorFactory identifierGeneratorFactory = new DefaultIdentifierGeneratorFactory();
 
 	private final Database database = new Database();
 
 	private final MappingDefaults mappingDefaults;
 
 	/**
 	 * Maps the fully qualified class name of an entity to its entity binding
 	 */
 	private Map<String, EntityBinding> entityBindingMap = new HashMap<String, EntityBinding>();
 	private Map<String, EntityBinding> rootEntityBindingMap = new HashMap<String, EntityBinding>();
 	private Map<String, PluralAttributeBinding> collectionBindingMap = new HashMap<String, PluralAttributeBinding>();
 	private Map<String, FetchProfile> fetchProfiles = new HashMap<String, FetchProfile>();
 	private Map<String, String> imports = new HashMap<String, String>();
 	private Map<String, TypeDef> typeDefs = new HashMap<String, TypeDef>();
 	private Map<String, IdGenerator> idGenerators = new HashMap<String, IdGenerator>();
 	private Map<String, NamedQueryDefinition> namedQueryDefs = new HashMap<String, NamedQueryDefinition>();
 	private Map<String, NamedSQLQueryDefinition> namedNativeQueryDefs = new HashMap<String, NamedSQLQueryDefinition>();
 	private Map<String, ResultSetMappingDefinition> resultSetMappings = new HashMap<String, ResultSetMappingDefinition>();
 	private Map<String, FilterDefinition> filterDefs = new HashMap<String, FilterDefinition>();
 
     private boolean globallyQuotedIdentifiers = false;
 
 	public MetadataImpl(MetadataSources metadataSources, Options options) {
 		this.serviceRegistry = metadataSources.getServiceRegistry();
 		this.options = options;
 
 		this.mappingDefaults = new MappingDefaultsImpl();
 
 		final SourceProcessor[] sourceProcessors;
 		if ( options.getSourceProcessingOrder() == SourceProcessingOrder.HBM_FIRST ) {
 			sourceProcessors = new SourceProcessor[] {
 					new HbmSourceProcessorImpl( this ),
 					new AnnotationsSourceProcessor( this )
 			};
 		}
 		else {
 			sourceProcessors = new SourceProcessor[] {
 					new AnnotationsSourceProcessor( this ),
 					new HbmSourceProcessorImpl( this )
 			};
 		}
 
 		this.classLoaderService = new org.hibernate.internal.util.Value<ClassLoaderService>(
 				new org.hibernate.internal.util.Value.DeferredInitializer<ClassLoaderService>() {
 					@Override
 					public ClassLoaderService initialize() {
 						return serviceRegistry.getService( ClassLoaderService.class );
 					}
 				}
 		);
 		this.persisterClassResolverService = new org.hibernate.internal.util.Value<PersisterClassResolver>(
 				new org.hibernate.internal.util.Value.DeferredInitializer<PersisterClassResolver>() {
 					@Override
 					public PersisterClassResolver initialize() {
 						return serviceRegistry.getService( PersisterClassResolver.class );
 					}
 				}
 		);
 
 
 		final ArrayList<String> processedEntityNames = new ArrayList<String>();
 
 		prepare( sourceProcessors, metadataSources );
 		bindIndependentMetadata( sourceProcessors, metadataSources );
 		bindTypeDependentMetadata( sourceProcessors, metadataSources );
 		bindMappingMetadata( sourceProcessors, metadataSources, processedEntityNames );
 		bindMappingDependentMetadata( sourceProcessors, metadataSources );
 
 		// todo : remove this by coordinated ordering of entity processing
 		new EntityReferenceResolver( this ).resolve();
 		new AttributeTypeResolver( this ).resolve();
 	}
 
 	private void prepare(SourceProcessor[] sourceProcessors, MetadataSources metadataSources) {
 		for ( SourceProcessor sourceProcessor : sourceProcessors ) {
 			sourceProcessor.prepare( metadataSources );
 		}
 	}
 
 	private void bindIndependentMetadata(SourceProcessor[] sourceProcessors, MetadataSources metadataSources) {
 		for ( SourceProcessor sourceProcessor : sourceProcessors ) {
 			sourceProcessor.processIndependentMetadata( metadataSources );
 		}
 	}
 
 	private void bindTypeDependentMetadata(SourceProcessor[] sourceProcessors, MetadataSources metadataSources) {
 		for ( SourceProcessor sourceProcessor : sourceProcessors ) {
 			sourceProcessor.processTypeDependentMetadata( metadataSources );
 		}
 	}
 
 	private void bindMappingMetadata(SourceProcessor[] sourceProcessors, MetadataSources metadataSources, List<String> processedEntityNames) {
 		for ( SourceProcessor sourceProcessor : sourceProcessors ) {
 			sourceProcessor.processMappingMetadata( metadataSources, processedEntityNames );
 		}
 	}
 
 	private void bindMappingDependentMetadata(SourceProcessor[] sourceProcessors, MetadataSources metadataSources) {
 		for ( SourceProcessor sourceProcessor : sourceProcessors ) {
 			sourceProcessor.processMappingDependentMetadata( metadataSources );
 		}
 	}
 
 	@Override
 	public void addFetchProfile(FetchProfile profile) {
 		if ( profile == null || profile.getName() == null ) {
 			throw new IllegalArgumentException( "Fetch profile object or name is null: " + profile );
 		}
 		fetchProfiles.put( profile.getName(), profile );
 	}
 
 	@Override
 	public void addFilterDefinition(FilterDefinition def) {
 		if ( def == null || def.getFilterName() == null ) {
 			throw new IllegalArgumentException( "Filter definition object or name is null: "  + def );
 		}
 		filterDefs.put( def.getFilterName(), def );
 	}
 
 	public Iterable<FilterDefinition> getFilterDefinitions() {
 		return filterDefs.values();
 	}
 
 	@Override
 	public void addIdGenerator(IdGenerator generator) {
 		if ( generator == null || generator.getName() == null ) {
 			throw new IllegalArgumentException( "ID generator object or name is null." );
 		}
 		idGenerators.put( generator.getName(), generator );
 	}
 
 	@Override
 	public IdGenerator getIdGenerator(String name) {
 		if ( name == null ) {
 			throw new IllegalArgumentException( "null is not a valid generator name" );
 		}
 		return idGenerators.get( name );
 	}
 	@Override
 	public void registerIdentifierGenerator(String name, String generatorClassName) {
 		 identifierGeneratorFactory.register( name, classLoaderService().classForName( generatorClassName ) );
 	}
 
 	@Override
 	public void addNamedNativeQuery(NamedSQLQueryDefinition def) {
 		if ( def == null || def.getName() == null ) {
 			throw new IllegalArgumentException( "Named native query definition object or name is null: " + def.getQueryString() );
 		}
 		namedNativeQueryDefs.put( def.getName(), def );
 	}
 
 	public NamedSQLQueryDefinition getNamedNativeQuery(String name) {
 		if ( name == null ) {
 			throw new IllegalArgumentException( "null is not a valid native query name" );
 		}
 		return namedNativeQueryDefs.get( name );
 	}
 
 	@Override
 	public Iterable<NamedSQLQueryDefinition> getNamedNativeQueryDefinitions() {
 		return namedNativeQueryDefs.values();
 	}
 
 	@Override
 	public void addNamedQuery(NamedQueryDefinition def) {
 		if ( def == null ) {
 			throw new IllegalArgumentException( "Named query definition is null" );
 		}
 		else if ( def.getName() == null ) {
 			throw new IllegalArgumentException( "Named query definition name is null: " + def.getQueryString() );
 		}
 		namedQueryDefs.put( def.getName(), def );
 	}
 
 	public NamedQueryDefinition getNamedQuery(String name) {
 		if ( name == null ) {
 			throw new IllegalArgumentException( "null is not a valid query name" );
 		}
 		return namedQueryDefs.get( name );
 	}
 
 	@Override
 	public Iterable<NamedQueryDefinition> getNamedQueryDefinitions() {
 		return namedQueryDefs.values();
 	}
 
 	@Override
 	public void addResultSetMapping(ResultSetMappingDefinition resultSetMappingDefinition) {
 		if ( resultSetMappingDefinition == null || resultSetMappingDefinition.getName() == null ) {
 			throw new IllegalArgumentException( "Result-set mapping object or name is null: " + resultSetMappingDefinition );
 		}
 		resultSetMappings.put( resultSetMappingDefinition.getName(), resultSetMappingDefinition );
 	}
 
 	@Override
 	public Iterable<ResultSetMappingDefinition> getResultSetMappingDefinitions() {
 		return resultSetMappings.values();
 	}
 
 	@Override
 	public void addTypeDefinition(TypeDef typeDef) {
 		if ( typeDef == null ) {
 			throw new IllegalArgumentException( "Type definition is null" );
 		}
 		else if ( typeDef.getName() == null ) {
 			throw new IllegalArgumentException( "Type definition name is null: " + typeDef.getTypeClass() );
 		}
 		final TypeDef previous = typeDefs.put( typeDef.getName(), typeDef );
 		if ( previous != null ) {
 			LOG.debugf( "Duplicate typedef name [%s] now -> %s", typeDef.getName(), typeDef.getTypeClass() );
 		}
 	}
 
 	@Override
 	public Iterable<TypeDef> getTypeDefinitions() {
 		return typeDefs.values();
 	}
 
 	@Override
 	public TypeDef getTypeDefinition(String name) {
 		return typeDefs.get( name );
 	}
 
 	private ClassLoaderService classLoaderService() {
 		return classLoaderService.getValue();
 	}
 
 	private PersisterClassResolver persisterClassResolverService() {
 		return persisterClassResolverService.getValue();
 	}
 
 	@Override
 	public Options getOptions() {
 		return options;
 	}
 
 	@Override
 	public SessionFactory buildSessionFactory() {
 		return sessionFactoryBuilder.buildSessionFactory();
 	}
 
 	@Override
 	public BasicServiceRegistry getServiceRegistry() {
 		return serviceRegistry;
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> Class<T> locateClassByName(String name) {
 		return classLoaderService().classForName( name );
 	}
 
 	@Override
 	public Type makeJavaType(String className) {
 		// todo : have this perform some analysis of the incoming type name to determine appropriate return
 		return new BasicType( className, makeClassReference( className ) );
 	}
 
 	@Override
 	public Value<Class<?>> makeClassReference(final String className) {
 		return new Value<Class<?>>(
 				new Value.DeferredInitializer<Class<?>>() {
 					@Override
 					public Class<?> initialize() {
 						return classLoaderService.getValue().classForName( className );
 					}
 				}
 		);
 	}
 
 	@Override
 	public Database getDatabase() {
 		return database;
 	}
 
 	public EntityBinding getEntityBinding(String entityName) {
 		return entityBindingMap.get( entityName );
 	}
 
 	@Override
 	public EntityBinding getRootEntityBinding(String entityName) {
 		EntityBinding rootEntityBinding = rootEntityBindingMap.get( entityName );
 		if ( rootEntityBinding == null ) {
 			EntityBinding entityBinding = entityBindingMap.get( entityName );
 			if ( entityBinding == null ) {
 				throw new IllegalStateException( "Unknown entity binding: " + entityName );
 			}
 			if ( entityBinding.isRoot() ) {
 				rootEntityBinding = entityBinding;
 			}
 			else {
 				if ( entityBinding.getEntity().getSuperType() == null ) {
 					throw new IllegalStateException( "Entity binding has no root: " + entityName );
 				}
 				rootEntityBinding = getRootEntityBinding( entityBinding.getEntity().getSuperType().getName() );
 			}
 			rootEntityBindingMap.put( entityName, rootEntityBinding );
 		}
 		return rootEntityBinding;
 	}
 
 	public Iterable<EntityBinding> getEntityBindings() {
 		return entityBindingMap.values();
 	}
 
 	public void addEntity(EntityBinding entityBinding) {
 		final String entityName = entityBinding.getEntity().getName();
 		if ( entityBindingMap.containsKey( entityName ) ) {
 			throw new DuplicateMappingException( DuplicateMappingException.Type.ENTITY, entityName );
 		}
 		entityBindingMap.put( entityName, entityBinding );
 	}
 
 	public PluralAttributeBinding getCollection(String collectionRole) {
 		return collectionBindingMap.get( collectionRole );
 	}
 
 	@Override
 	public Iterable<PluralAttributeBinding> getCollectionBindings() {
 		return collectionBindingMap.values();
 	}
 
 	public void addCollection(PluralAttributeBinding pluralAttributeBinding) {
 		final String owningEntityName = pluralAttributeBinding.getEntityBinding().getEntity().getName();
 		final String attributeName = pluralAttributeBinding.getAttribute().getName();
 		final String collectionRole = owningEntityName + '.' + attributeName;
 		if ( collectionBindingMap.containsKey( collectionRole ) ) {
 			throw new DuplicateMappingException( DuplicateMappingException.Type.ENTITY, collectionRole );
 		}
 		collectionBindingMap.put( collectionRole, pluralAttributeBinding );
 	}
 
 	public void addImport(String importName, String entityName) {
 		if ( importName == null || entityName == null ) {
 			throw new IllegalArgumentException( "Import name or entity name is null" );
 		}
 		LOG.trace( "Import: " + importName + " -> " + entityName );
 		String old = imports.put( importName, entityName );
 		if ( old != null ) {
 			LOG.debug( "import name [" + importName + "] overrode previous [{" + old + "}]" );
 		}
 	}
 
 	public Iterable<Map.Entry<String, String>> getImports() {
 		return imports.entrySet();
 	}
 
 	public Iterable<FetchProfile> getFetchProfiles() {
 		return fetchProfiles.values();
 	}
 
 	public TypeResolver getTypeResolver() {
 		return typeResolver;
 	}
 
 	@Override
 	public SessionFactoryBuilder getSessionFactoryBuilder() {
 		return sessionFactoryBuilder;
 	}
 
 	@Override
 	public NamingStrategy getNamingStrategy() {
 		return options.getNamingStrategy();
 	}
 
     @Override
     public boolean isGloballyQuotedIdentifiers() {
         return globallyQuotedIdentifiers || getOptions().isGloballyQuotedIdentifiers();
     }
 
     public void setGloballyQuotedIdentifiers(boolean globallyQuotedIdentifiers){
        this.globallyQuotedIdentifiers = globallyQuotedIdentifiers;
     }
 
     @Override
 	public MappingDefaults getMappingDefaults() {
 		return mappingDefaults;
 	}
 
 	private final MetaAttributeContext globalMetaAttributeContext = new MetaAttributeContext();
 
 	@Override
 	public MetaAttributeContext getGlobalMetaAttributeContext() {
 		return globalMetaAttributeContext;
 	}
 
 	@Override
 	public MetadataImplementor getMetadataImplementor() {
 		return this;
 	}
 
 	private static final String DEFAULT_IDENTIFIER_COLUMN_NAME = "id";
 	private static final String DEFAULT_DISCRIMINATOR_COLUMN_NAME = "class";
 	private static final String DEFAULT_CASCADE = "none";
 	private static final String DEFAULT_PROPERTY_ACCESS = "property";
 
 	@Override
 	public IdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 		return identifierGeneratorFactory;
 	}
 
 	@Override
 	public org.hibernate.type.Type getIdentifierType(String entityName) throws MappingException {
 		EntityBinding entityBinding = getEntityBinding( entityName );
 		if ( entityBinding == null ) {
 			throw new MappingException( "Entity binding not known: " + entityName );
 		}
 		return entityBinding
 				.getEntityIdentifier()
 				.getValueBinding()
 				.getHibernateTypeDescriptor()
 				.getExplicitType();
 	}
 
 	@Override
 	public String getIdentifierPropertyName(String entityName) throws MappingException {
 		EntityBinding entityBinding = getEntityBinding( entityName );
 		if ( entityBinding == null ) {
 			throw new MappingException( "Entity binding not known: " + entityName );
 		}
 		AttributeBinding idBinding = entityBinding.getEntityIdentifier().getValueBinding();
 		return idBinding == null ? null : idBinding.getAttribute().getName();
 	}
 
 	@Override
 	public org.hibernate.type.Type getReferencedPropertyType(String entityName, String propertyName) throws MappingException {
 		EntityBinding entityBinding = getEntityBinding( entityName );
 		if ( entityBinding == null ) {
 			throw new MappingException( "Entity binding not known: " + entityName );
 		}
 		// TODO: should this call EntityBinding.getReferencedAttributeBindingString), which does not exist yet?
 		AttributeBinding attributeBinding = entityBinding.getAttributeBinding( propertyName );
 		if ( attributeBinding == null ) {
 			throw new MappingException( "unknown property: " + entityName + '.' + propertyName );
 		}
 		return attributeBinding.getHibernateTypeDescriptor().getExplicitType();
 	}
 
 	private class MappingDefaultsImpl implements MappingDefaults {
 
 		@Override
 		public String getPackageName() {
 			return null;
 		}
 
 		@Override
 		public String getSchemaName() {
 			return options.getDefaultSchemaName();
 		}
 
 		@Override
 		public String getCatalogName() {
 			return options.getDefaultCatalogName();
 		}
 
 		@Override
 		public String getIdColumnName() {
 			return DEFAULT_IDENTIFIER_COLUMN_NAME;
 		}
 
 		@Override
 		public String getDiscriminatorColumnName() {
 			return DEFAULT_DISCRIMINATOR_COLUMN_NAME;
 		}
 
 		@Override
 		public String getCascadeStyle() {
 			return DEFAULT_CASCADE;
 		}
 
 		@Override
 		public String getPropertyAccessorName() {
 			return DEFAULT_PROPERTY_ACCESS;
 		}
 
 		@Override
 		public boolean areAssociationsLazy() {
 			return true;
 		}
 
 		private final Value<AccessType> regionFactorySpecifiedDefaultAccessType = new Value<AccessType>(
 				new Value.DeferredInitializer<AccessType>() {
 					@Override
 					public AccessType initialize() {
 						final RegionFactory regionFactory = getServiceRegistry().getService( RegionFactory.class );
 						return regionFactory.getDefaultAccessType();
 					}
 				}
 		);
 
 		@Override
 		public AccessType getCacheAccessType() {
 			return options.getDefaultAccessType() != null
 					? options.getDefaultAccessType()
 					: regionFactorySpecifiedDefaultAccessType.getValue();
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/OverriddenMappingDefaults.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/OverriddenMappingDefaults.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/OverriddenMappingDefaults.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/OverriddenMappingDefaults.java
index c2ea71f529..170361272c 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/OverriddenMappingDefaults.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/OverriddenMappingDefaults.java
@@ -1,114 +1,114 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.internal;
+package org.hibernate.metamodel.source.internal;
 
 import org.hibernate.cache.spi.access.AccessType;
-import org.hibernate.metamodel.binder.source.MappingDefaults;
+import org.hibernate.metamodel.source.MappingDefaults;
 
 /**
  * Represents a "nested level" in the mapping defaults stack.
  *
  * @author Steve Ebersole
  */
 public class OverriddenMappingDefaults implements MappingDefaults {
 	private MappingDefaults overriddenValues;
 
 	private final String packageName;
 	private final String schemaName;
 	private final String catalogName;
 	private final String idColumnName;
 	private final String discriminatorColumnName;
 	private final String cascade;
 	private final String propertyAccess;
 	private final Boolean associationLaziness;
 
 	public OverriddenMappingDefaults(
 			MappingDefaults overriddenValues,
 			String packageName,
 			String schemaName,
 			String catalogName,
 			String idColumnName,
 			String discriminatorColumnName,
 			String cascade,
 			String propertyAccess,
 			Boolean associationLaziness) {
 		if ( overriddenValues == null ) {
 			throw new IllegalArgumentException( "Overridden values cannot be null" );
 		}
 		this.overriddenValues = overriddenValues;
 		this.packageName = packageName;
 		this.schemaName = schemaName;
 		this.catalogName = catalogName;
 		this.idColumnName = idColumnName;
 		this.discriminatorColumnName = discriminatorColumnName;
 		this.cascade = cascade;
 		this.propertyAccess = propertyAccess;
 		this.associationLaziness = associationLaziness;
 	}
 
 	@Override
 	public String getPackageName() {
 		return packageName == null ? overriddenValues.getPackageName() : packageName;
 	}
 
 	@Override
 	public String getSchemaName() {
 		return schemaName == null ? overriddenValues.getSchemaName() : schemaName;
 	}
 
 	@Override
 	public String getCatalogName() {
 		return catalogName == null ? overriddenValues.getCatalogName() : catalogName;
 	}
 
 	@Override
 	public String getIdColumnName() {
 		return idColumnName == null ? overriddenValues.getIdColumnName() : idColumnName;
 	}
 
 	@Override
 	public String getDiscriminatorColumnName() {
 		return discriminatorColumnName == null ? overriddenValues.getDiscriminatorColumnName() : discriminatorColumnName;
 	}
 
 	@Override
 	public String getCascadeStyle() {
 		return cascade == null ? overriddenValues.getCascadeStyle() : cascade;
 	}
 
 	@Override
 	public String getPropertyAccessorName() {
 		return propertyAccess == null ? overriddenValues.getPropertyAccessorName() : propertyAccess;
 	}
 
 	@Override
 	public boolean areAssociationsLazy() {
 		return associationLaziness == null ? overriddenValues.areAssociationsLazy() : associationLaziness;
 	}
 
 	@Override
 	public AccessType getCacheAccessType() {
 		return overriddenValues.getCacheAccessType();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/SessionFactoryBuilderImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImpl.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/SessionFactoryBuilderImpl.java
rename to hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImpl.java
index 3908ac359f..3be406488b 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/binder/source/internal/SessionFactoryBuilderImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImpl.java
@@ -1,88 +1,88 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.internal;
+package org.hibernate.metamodel.source.internal;
 
 import java.io.Serializable;
 
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.Interceptor;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.SessionFactory;
 import org.hibernate.internal.SessionFactoryImpl;
 import org.hibernate.metamodel.SessionFactoryBuilder;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 
 /**
  * @author Gail Badner
  */
 public class SessionFactoryBuilderImpl implements SessionFactoryBuilder {
 	SessionFactoryOptionsImpl options;
 
 	private final MetadataImplementor metadata;
 
 	/* package-protected */
 	SessionFactoryBuilderImpl(MetadataImplementor metadata) {
 		this.metadata = metadata;
 		options = new SessionFactoryOptionsImpl();
 	}
 
 	@Override
 	public SessionFactoryBuilder with(Interceptor interceptor) {
 		this.options.interceptor = interceptor;
 		return this;
 	}
 
 	@Override
 	public SessionFactoryBuilder with(EntityNotFoundDelegate entityNotFoundDelegate) {
 		this.options.entityNotFoundDelegate = entityNotFoundDelegate;
 		return this;
 	}
 
 	@Override
 	public SessionFactory buildSessionFactory() {
 		return new SessionFactoryImpl(metadata, options, null );
 	}
 
 	private static class SessionFactoryOptionsImpl implements SessionFactory.SessionFactoryOptions {
 		private Interceptor interceptor = EmptyInterceptor.INSTANCE;
 
 		// TODO: should there be a DefaultEntityNotFoundDelegate.INSTANCE?
 		private EntityNotFoundDelegate entityNotFoundDelegate = new EntityNotFoundDelegate() {
 				public void handleEntityNotFound(String entityName, Serializable id) {
 					throw new ObjectNotFoundException( id, entityName );
 				}
 		};
 
 		@Override
 		public Interceptor getInterceptor() {
 			return interceptor;
 		}
 
 		@Override
 		public EntityNotFoundDelegate getEntityNotFoundDelegate() {
 			return entityNotFoundDelegate;
 		}
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterFactoryImpl.java b/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterFactoryImpl.java
index aa086af441..0703c5743a 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterFactoryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterFactoryImpl.java
@@ -1,249 +1,249 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.internal;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.cache.spi.access.CollectionRegionAccessStrategy;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.binding.PluralAttributeBinding;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.spi.PersisterClassResolver;
 import org.hibernate.persister.spi.PersisterFactory;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
 
 /**
  * The standard Hibernate {@link PersisterFactory} implementation
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public final class PersisterFactoryImpl implements PersisterFactory, ServiceRegistryAwareService {
 
 	/**
 	 * The constructor signature for {@link EntityPersister} implementations
 	 *
 	 * @todo make EntityPersister *not* depend on {@link SessionFactoryImplementor} if possible.
 	 */
 	public static final Class[] ENTITY_PERSISTER_CONSTRUCTOR_ARGS = new Class[] {
 			PersistentClass.class,
 			EntityRegionAccessStrategy.class,
 			SessionFactoryImplementor.class,
 			Mapping.class
 	};
 
 	/**
 	 * The constructor signature for {@link EntityPersister} implementations using
 	 * an {@link EntityBinding}.
 	 *
 	 * @todo make EntityPersister *not* depend on {@link SessionFactoryImplementor} if possible.
 	 * @todo change ENTITY_PERSISTER_CONSTRUCTOR_ARGS_NEW to ENTITY_PERSISTER_CONSTRUCTOR_ARGS
 	 * when new metamodel is integrated
 	 */
 	public static final Class[] ENTITY_PERSISTER_CONSTRUCTOR_ARGS_NEW = new Class[] {
 			EntityBinding.class,
 			EntityRegionAccessStrategy.class,
 			SessionFactoryImplementor.class,
 			Mapping.class
 	};
 
 	/**
 	 * The constructor signature for {@link CollectionPersister} implementations
 	 *
 	 * @todo still need to make collection persisters EntityMode-aware
 	 * @todo make EntityPersister *not* depend on {@link SessionFactoryImplementor} if possible.
 	 */
 	private static final Class[] COLLECTION_PERSISTER_CONSTRUCTOR_ARGS = new Class[] {
 			Collection.class,
 			CollectionRegionAccessStrategy.class,
 			Configuration.class,
 			SessionFactoryImplementor.class
 	};
 
 	/**
 	 * The constructor signature for {@link CollectionPersister} implementations using
 	 * a {@link PluralAttributeBinding}
 	 *
 	 * @todo still need to make collection persisters EntityMode-aware
 	 * @todo make EntityPersister *not* depend on {@link SessionFactoryImplementor} if possible.
 	 * @todo change COLLECTION_PERSISTER_CONSTRUCTOR_ARGS_NEW to COLLECTION_PERSISTER_CONSTRUCTOR_ARGS
 	 * when new metamodel is integrated
 	 */
 	private static final Class[] COLLECTION_PERSISTER_CONSTRUCTOR_ARGS_NEW = new Class[] {
 			PluralAttributeBinding.class,
 			CollectionRegionAccessStrategy.class,
 			MetadataImplementor.class,
 			SessionFactoryImplementor.class
 	};
 
 	private ServiceRegistryImplementor serviceRegistry;
 
 	@Override
 	public void injectServices(ServiceRegistryImplementor serviceRegistry) {
 		this.serviceRegistry = serviceRegistry;
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public EntityPersister createEntityPersister(
 			PersistentClass metadata,
 			EntityRegionAccessStrategy cacheAccessStrategy,
 			SessionFactoryImplementor factory,
 			Mapping cfg) {
 		Class<? extends EntityPersister> persisterClass = metadata.getEntityPersisterClass();
 		if ( persisterClass == null ) {
 			persisterClass = serviceRegistry.getService( PersisterClassResolver.class ).getEntityPersisterClass( metadata );
 		}
 		return create( persisterClass, ENTITY_PERSISTER_CONSTRUCTOR_ARGS, metadata, cacheAccessStrategy, factory, cfg );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public EntityPersister createEntityPersister(EntityBinding metadata,
 												 EntityRegionAccessStrategy cacheAccessStrategy,
 												 SessionFactoryImplementor factory,
 												 Mapping cfg) {
 		Class<? extends EntityPersister> persisterClass = metadata.getCustomEntityPersisterClass();
 		if ( persisterClass == null ) {
 			persisterClass = serviceRegistry.getService( PersisterClassResolver.class ).getEntityPersisterClass( metadata );
 		}
 		return create( persisterClass, ENTITY_PERSISTER_CONSTRUCTOR_ARGS_NEW, metadata, cacheAccessStrategy, factory, cfg );
 	}
 
 	// TODO: change metadata arg type to EntityBinding when new metadata is integrated
 	private static EntityPersister create(
 			Class<? extends EntityPersister> persisterClass,
 			Class[] persisterConstructorArgs,
 			Object metadata,
 			EntityRegionAccessStrategy cacheAccessStrategy,
 			SessionFactoryImplementor factory,
 			Mapping cfg) throws HibernateException {
 		try {
 			Constructor<? extends EntityPersister> constructor = persisterClass.getConstructor( persisterConstructorArgs );
 			try {
 				return constructor.newInstance( metadata, cacheAccessStrategy, factory, cfg );
 			}
 			catch (MappingException e) {
 				throw e;
 			}
 			catch (InvocationTargetException e) {
 				Throwable target = e.getTargetException();
 				if ( target instanceof HibernateException ) {
 					throw (HibernateException) target;
 				}
 				else {
 					throw new MappingException( "Could not instantiate persister " + persisterClass.getName(), target );
 				}
 			}
 			catch (Exception e) {
 				throw new MappingException( "Could not instantiate persister " + persisterClass.getName(), e );
 			}
 		}
 		catch (MappingException e) {
 			throw e;
 		}
 		catch (Exception e) {
 			throw new MappingException( "Could not get constructor for " + persisterClass.getName(), e );
 		}
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public CollectionPersister createCollectionPersister(
 			Configuration cfg,
 			Collection collectionMetadata,
 			CollectionRegionAccessStrategy cacheAccessStrategy,
 			SessionFactoryImplementor factory) throws HibernateException {
 		Class<? extends CollectionPersister> persisterClass = collectionMetadata.getCollectionPersisterClass();
 		if ( persisterClass == null ) {
 			persisterClass = serviceRegistry.getService( PersisterClassResolver.class ).getCollectionPersisterClass( collectionMetadata );
 		}
 
 		return create( persisterClass, COLLECTION_PERSISTER_CONSTRUCTOR_ARGS, cfg, collectionMetadata, cacheAccessStrategy, factory );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public CollectionPersister createCollectionPersister(MetadataImplementor metadata,
 														 PluralAttributeBinding collectionMetadata,
 														 CollectionRegionAccessStrategy cacheAccessStrategy,
 														 SessionFactoryImplementor factory) throws HibernateException {
 		Class<? extends CollectionPersister> persisterClass = collectionMetadata.getCollectionPersisterClass();
 		if ( persisterClass == null ) {
 			persisterClass = serviceRegistry.getService( PersisterClassResolver.class ).getCollectionPersisterClass( collectionMetadata );
 		}
 
 		return create( persisterClass, COLLECTION_PERSISTER_CONSTRUCTOR_ARGS_NEW, metadata, collectionMetadata, cacheAccessStrategy, factory );
 	}
 
 	// TODO: change collectionMetadata arg type to PluralAttributeBinding when new metadata is integrated
 	// TODO: change metadata arg type to MetadataImplementor when new metadata is integrated
 	private static CollectionPersister create(
 			Class<? extends CollectionPersister> persisterClass,
 			Class[] persisterConstructorArgs,
 			Object cfg,
 			Object collectionMetadata,
 			CollectionRegionAccessStrategy cacheAccessStrategy,
 			SessionFactoryImplementor factory) throws HibernateException {
 		try {
 			Constructor<? extends CollectionPersister> constructor = persisterClass.getConstructor( persisterConstructorArgs );
 			try {
 				return constructor.newInstance( collectionMetadata, cacheAccessStrategy, cfg, factory );
 			}
 			catch (MappingException e) {
 				throw e;
 			}
 			catch (InvocationTargetException e) {
 				Throwable target = e.getTargetException();
 				if ( target instanceof HibernateException ) {
 					throw (HibernateException) target;
 				}
 				else {
 					throw new MappingException( "Could not instantiate collection persister " + persisterClass.getName(), target );
 				}
 			}
 			catch (Exception e) {
 				throw new MappingException( "Could not instantiate collection persister " + persisterClass.getName(), e );
 			}
 		}
 		catch (MappingException e) {
 			throw e;
 		}
 		catch (Exception e) {
 			throw new MappingException( "Could not get constructor for " + persisterClass.getName(), e );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/spi/PersisterFactory.java b/hibernate-core/src/main/java/org/hibernate/persister/spi/PersisterFactory.java
index 01a24332f0..774ce9871a 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/spi/PersisterFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/spi/PersisterFactory.java
@@ -1,129 +1,129 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.spi;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cache.spi.access.CollectionRegionAccessStrategy;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.binding.PluralAttributeBinding;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.service.Service;
 
 /**
  * Contract for creating persister instances (both {@link EntityPersister} and {@link CollectionPersister} varieties).
  *
  * @author Steve Ebersole
  */
 public interface PersisterFactory extends Service {
 
 	// TODO: is it really necessary to provide Configuration to CollectionPersisters ?
 	// Should it not be enough with associated class ? or why does EntityPersister's not get access to configuration ?
 	//
 	// The only reason I could see that Configuration gets passed to collection persisters
 	// is so that they can look up the dom4j node name of the entity element in case
 	// no explicit node name was applied at the collection element level.  Are you kidding me?
 	// Trivial to fix then.  Just store and expose the node name on the entity persister
 	// (which the collection persister looks up anyway via other means...).
 
 	/**
 	 * Create an entity persister instance.
 	 *
 	 * @param model The O/R mapping metamodel definition for the entity
 	 * @param cacheAccessStrategy The caching strategy for this entity
 	 * @param factory The session factory
 	 * @param cfg The overall mapping
 	 *
 	 * @return An appropriate entity persister instance.
 	 *
 	 * @throws HibernateException Indicates a problem building the persister.
 	 */
 	public EntityPersister createEntityPersister(
 			PersistentClass model,
 			EntityRegionAccessStrategy cacheAccessStrategy,
 			SessionFactoryImplementor factory,
 			Mapping cfg) throws HibernateException;
 
 	/**
 	 * Create an entity persister instance.
 	 *
 	 * @param model The O/R mapping metamodel definition for the entity
 	 * @param cacheAccessStrategy The caching strategy for this entity
 	 * @param factory The session factory
 	 * @param cfg The overall mapping
 	 *
 	 * @return An appropriate entity persister instance.
 	 *
 	 * @throws HibernateException Indicates a problem building the persister.
 	 */
 	public EntityPersister createEntityPersister(
 			EntityBinding model,
 			EntityRegionAccessStrategy cacheAccessStrategy,
 			SessionFactoryImplementor factory,
 			Mapping cfg) throws HibernateException;
 
 	/**
 	 * Create a collection persister instance.
 	 *
 	 * @param cfg The configuration
 	 * @param model The O/R mapping metamodel definition for the collection
 	 * @param cacheAccessStrategy The caching strategy for this collection
 	 * @param factory The session factory
 	 *
 	 * @return An appropriate collection persister instance.
 	 *
 	 * @throws HibernateException Indicates a problem building the persister.
 	 */
 	public CollectionPersister createCollectionPersister(
 			Configuration cfg,
 			Collection model,
 			CollectionRegionAccessStrategy cacheAccessStrategy,
 			SessionFactoryImplementor factory) throws HibernateException;
 
 	/**
 	 * Create a collection persister instance.
 	 *
 	 * @param metadata The metadata
 	 * @param model The O/R mapping metamodel definition for the collection
 	 * @param cacheAccessStrategy The caching strategy for this collection
 	 * @param factory The session factory
 	 *
 	 * @return An appropriate collection persister instance.
 	 *
 	 * @throws HibernateException Indicates a problem building the persister.
 	 */
 	public CollectionPersister createCollectionPersister(
 			MetadataImplementor metadata,
 			PluralAttributeBinding model,
 			CollectionRegionAccessStrategy cacheAccessStrategy,
 			SessionFactoryImplementor factory) throws HibernateException;
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryImpl.java b/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryImpl.java
index 8e926af56f..a58edfb79d 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryImpl.java
@@ -1,60 +1,60 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.internal;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.Service;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistryFactory;
 
 /**
  * Acts as a {@link Service} in the {@link BasicServiceRegistryImpl} whose function is as a factory for
  * {@link SessionFactoryServiceRegistryImpl} implementations.
  *
  * @author Steve Ebersole
  */
 public class SessionFactoryServiceRegistryFactoryImpl implements SessionFactoryServiceRegistryFactory {
 	private final ServiceRegistryImplementor theBasicServiceRegistry;
 
 	public SessionFactoryServiceRegistryFactoryImpl(ServiceRegistryImplementor theBasicServiceRegistry) {
 		this.theBasicServiceRegistry = theBasicServiceRegistry;
 	}
 
 	@Override
 	public SessionFactoryServiceRegistryImpl buildServiceRegistry(
 			SessionFactoryImplementor sessionFactory,
 			Configuration configuration) {
 		return new SessionFactoryServiceRegistryImpl( theBasicServiceRegistry, sessionFactory, configuration );
 	}
 
 	@Override
 	public SessionFactoryServiceRegistryImpl buildServiceRegistry(
 			SessionFactoryImplementor sessionFactory,
 			MetadataImplementor metadata) {
 		return new SessionFactoryServiceRegistryImpl( theBasicServiceRegistry, sessionFactory, metadata );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryImpl.java b/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryImpl.java
index 82f5f04647..759b3f2bb8 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryImpl.java
@@ -1,107 +1,107 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.internal;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.Service;
 import org.hibernate.service.StandardSessionFactoryServiceInitiators;
 import org.hibernate.service.spi.ServiceInitiator;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceInitiator;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * @author Steve Ebersole
  */
 public class SessionFactoryServiceRegistryImpl extends AbstractServiceRegistryImpl implements SessionFactoryServiceRegistry  {
 
 	// for now we need to hold on to the Configuration... :(
 	private final Configuration configuration;
 	private final MetadataImplementor metadata;
 	private final SessionFactoryImplementor sessionFactory;
 
 	@SuppressWarnings( {"unchecked"})
 	public SessionFactoryServiceRegistryImpl(
 			ServiceRegistryImplementor parent,
 			SessionFactoryImplementor sessionFactory,
 			Configuration configuration) {
 		super( parent );
 
 		this.sessionFactory = sessionFactory;
 		this.configuration = configuration;
 		this.metadata = null;
 
 		// for now, just use the standard initiator list
 		for ( SessionFactoryServiceInitiator initiator : StandardSessionFactoryServiceInitiators.LIST ) {
 			// create the bindings up front to help identify to which registry services belong
 			createServiceBinding( initiator );
 		}
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	public SessionFactoryServiceRegistryImpl(
 			ServiceRegistryImplementor parent,
 			SessionFactoryImplementor sessionFactory,
 			MetadataImplementor metadata) {
 		super( parent );
 
 		this.sessionFactory = sessionFactory;
 		this.configuration = null;
 		this.metadata = metadata;
 
 		// for now, just use the standard initiator list
 		for ( SessionFactoryServiceInitiator initiator : StandardSessionFactoryServiceInitiators.LIST ) {
 			// create the bindings up front to help identify to which registry services belong
 			createServiceBinding( initiator );
 		}
 	}
 
 	@Override
 	public <R extends Service> R initiateService(ServiceInitiator<R> serviceInitiator) {
 		// todo : add check/error for unexpected initiator types?
 		SessionFactoryServiceInitiator<R> sessionFactoryServiceInitiator =
 				(SessionFactoryServiceInitiator<R>) serviceInitiator;
 		if ( metadata != null ) {
 			return sessionFactoryServiceInitiator.initiateService( sessionFactory, metadata, this );
 		}
 		else if ( configuration != null ) {
 			return sessionFactoryServiceInitiator.initiateService( sessionFactory, configuration, this );
 		}
 		else {
 			throw new IllegalStateException( "Both metadata and configuration are null." );
 		}
 	}
 
 	@Override
 	protected <T extends Service> void configureService(T service) {
 		applyInjections( service );
 
 		if ( ServiceRegistryAwareService.class.isInstance( service ) ) {
 			( (ServiceRegistryAwareService) service ).injectServices( this );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceInitiator.java b/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceInitiator.java
index c646784c85..59448c1cdf 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceInitiator.java
@@ -1,63 +1,63 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.spi;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.Service;
 
 /**
  * @author Steve Ebersole
  */
 public interface SessionFactoryServiceInitiator<R extends Service> extends ServiceInitiator<R>{
 	/**
 	 * Initiates the managed service.
 	 * <p/>
 	 * Note for implementors: signature is guaranteed to change once redesign of SessionFactory building is complete
 	 *
 	 * @param sessionFactory The session factory.  Note the the session factory is still in flux; care needs to be taken
 	 * in regards to what you call.
 	 * @param configuration The configuration.
 	 * @param registry The service registry.  Can be used to locate services needed to fulfill initiation.
 	 *
 	 * @return The initiated service.
 	 */
 	public R initiateService(SessionFactoryImplementor sessionFactory, Configuration configuration, ServiceRegistryImplementor registry);
 
 	/**
 	 * Initiates the managed service.
 	 * <p/>
 	 * Note for implementors: signature is guaranteed to change once redesign of SessionFactory building is complete
 	 *
 	 * @param sessionFactory The session factory.  Note the the session factory is still in flux; care needs to be taken
 	 * in regards to what you call.
 	 * @param metadata The configuration.
 	 * @param registry The service registry.  Can be used to locate services needed to fulfill initiation.
 	 *
 	 * @return The initiated service.
 	 */
 	public R initiateService(SessionFactoryImplementor sessionFactory, MetadataImplementor metadata, ServiceRegistryImplementor registry);
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceRegistryFactory.java b/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceRegistryFactory.java
index f1e7206e2f..33ae849622 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceRegistryFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/spi/SessionFactoryServiceRegistryFactory.java
@@ -1,70 +1,70 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.spi;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.Service;
 import org.hibernate.service.internal.SessionFactoryServiceRegistryImpl;
 
 /**
  * Contract for builder of {@link SessionFactoryServiceRegistry} instances.  Defined as a service to
  * "sit inside" the {@link org.hibernate.service.BasicServiceRegistry}.
  *
  * @author Steve Ebersole
  */
 public interface SessionFactoryServiceRegistryFactory extends Service {
 	/**
 	 * Create the registry.
 	 *
 	 * @todo : fully expect this signature to change!
 	 *
 	 * @param sessionFactory The (in flux) session factory.  Generally this is useful for grabbing a reference for later
 	 * 		use.  However, care should be taken when invoking on the session factory until after it has been fully
 	 * 		initialized.
 	 * @param configuration The configuration object.
 	 *
 	 * @return The registry
 	 */
 	public SessionFactoryServiceRegistryImpl buildServiceRegistry(
 			SessionFactoryImplementor sessionFactory,
 			Configuration configuration);
 
 	/**
 	 * Create the registry.
 	 *
 	 * @todo : fully expect this signature to change!
 	 *
 	 * @param sessionFactory The (in flux) session factory.  Generally this is useful for grabbing a reference for later
 	 * 		use.  However, care should be taken when invoking on the session factory until after it has been fully
 	 * 		initialized.
 	 * @param metadata The configuration object.
 	 *
 	 * @return The registry
 	 */
 	public SessionFactoryServiceRegistryImpl buildServiceRegistry(
 			SessionFactoryImplementor sessionFactory,
 			MetadataImplementor metadata);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/stat/internal/StatisticsInitiator.java b/hibernate-core/src/main/java/org/hibernate/stat/internal/StatisticsInitiator.java
index 212850290f..373f8600fb 100644
--- a/hibernate-core/src/main/java/org/hibernate/stat/internal/StatisticsInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/stat/internal/StatisticsInitiator.java
@@ -1,120 +1,120 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.stat.internal;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.service.config.spi.ConfigurationService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceInitiator;
 import org.hibernate.stat.spi.StatisticsFactory;
 import org.hibernate.stat.spi.StatisticsImplementor;
 
 /**
  * @author Steve Ebersole
  */
 public class StatisticsInitiator implements SessionFactoryServiceInitiator<StatisticsImplementor> {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, StatisticsInitiator.class.getName() );
 
 	public static final StatisticsInitiator INSTANCE = new StatisticsInitiator();
 
 	/**
 	 * Names the {@link StatisticsFactory} to use.  Recognizes both a class name as well as an instance of
 	 * {@link StatisticsFactory}.
 	 */
 	public static final String STATS_BUILDER = "hibernate.stats.factory";
 
 	@Override
 	public Class<StatisticsImplementor> getServiceInitiated() {
 		return StatisticsImplementor.class;
 	}
 
 	@Override
 	public StatisticsImplementor initiateService(
 			SessionFactoryImplementor sessionFactory,
 			Configuration configuration,
 			ServiceRegistryImplementor registry) {
 		final Object configValue = configuration.getProperties().get( STATS_BUILDER );
 		return initiateServiceInternal( sessionFactory, configValue, registry );
 	}
 
 	@Override
 	public StatisticsImplementor initiateService(
 			SessionFactoryImplementor sessionFactory,
 			MetadataImplementor metadata,
 			ServiceRegistryImplementor registry) {
 		ConfigurationService configurationService =  registry.getService( ConfigurationService.class );
 		final Object configValue = configurationService.getSetting( STATS_BUILDER, null );
 		return initiateServiceInternal( sessionFactory, configValue, registry );
 	}
 
 	private StatisticsImplementor initiateServiceInternal(
 			SessionFactoryImplementor sessionFactory,
 			Object configValue,
 			ServiceRegistryImplementor registry) {
 
 		StatisticsFactory statisticsFactory;
 		if ( configValue == null ) {
 			statisticsFactory = DEFAULT_STATS_BUILDER;
 		}
 		else if ( StatisticsFactory.class.isInstance( configValue ) ) {
 			statisticsFactory = (StatisticsFactory) configValue;
 		}
 		else {
 			// assume it names the factory class
 			final ClassLoaderService classLoaderService = registry.getService( ClassLoaderService.class );
 			try {
 				statisticsFactory = (StatisticsFactory) classLoaderService.classForName( configValue.toString() ).newInstance();
 			}
 			catch (HibernateException e) {
 				throw e;
 			}
 			catch (Exception e) {
 				throw new HibernateException(
 						"Unable to instantiate specified StatisticsFactory implementation [" + configValue.toString() + "]",
 						e
 				);
 			}
 		}
 
 		StatisticsImplementor statistics = statisticsFactory.buildStatistics( sessionFactory );
 		final boolean enabled = sessionFactory.getSettings().isStatisticsEnabled();
 		statistics.setStatisticsEnabled( enabled );
 		LOG.debugf( "Statistics initialized [enabled=%s]", enabled );
 		return statistics;
 	}
 
 	private static StatisticsFactory DEFAULT_STATS_BUILDER = new StatisticsFactory() {
 		@Override
 		public StatisticsImplementor buildStatistics(SessionFactoryImplementor sessionFactory) {
 			return new ConcurrentStatisticsImpl( sessionFactory );
 		}
 	};
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/PojoInstantiator.java b/hibernate-core/src/main/java/org/hibernate/tuple/PojoInstantiator.java
index ee23c08945..f18ed95c6e 100755
--- a/hibernate-core/src/main/java/org/hibernate/tuple/PojoInstantiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/PojoInstantiator.java
@@ -1,138 +1,138 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.tuple;
 
 import java.io.IOException;
 import java.io.Serializable;
 import java.lang.reflect.Constructor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.InstantiationException;
 import org.hibernate.PropertyNotFoundException;
 import org.hibernate.bytecode.spi.ReflectionOptimizer;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.mapping.Component;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.metamodel.binding.EntityBinding;
 
 import org.jboss.logging.Logger;
 
 /**
  * Defines a POJO-based instantiator for use from the tuplizers.
  */
 public class PojoInstantiator implements Instantiator, Serializable {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, PojoInstantiator.class.getName());
 
 	private transient Constructor constructor;
 
 	private final Class mappedClass;
 	private final transient ReflectionOptimizer.InstantiationOptimizer optimizer;
 	private final boolean embeddedIdentifier;
 	private final Class proxyInterface;
 
 	public PojoInstantiator(Component component, ReflectionOptimizer.InstantiationOptimizer optimizer) {
 		this.mappedClass = component.getComponentClass();
 		this.optimizer = optimizer;
 
 		this.proxyInterface = null;
 		this.embeddedIdentifier = false;
 
 		try {
 			constructor = ReflectHelper.getDefaultConstructor(mappedClass);
 		}
 		catch ( PropertyNotFoundException pnfe ) {
             LOG.noDefaultConstructor(mappedClass.getName());
 			constructor = null;
 		}
 	}
 
 	public PojoInstantiator(PersistentClass persistentClass, ReflectionOptimizer.InstantiationOptimizer optimizer) {
 		this.mappedClass = persistentClass.getMappedClass();
 		this.proxyInterface = persistentClass.getProxyInterface();
 		this.embeddedIdentifier = persistentClass.hasEmbeddedIdentifier();
 		this.optimizer = optimizer;
 
 		try {
 			constructor = ReflectHelper.getDefaultConstructor( mappedClass );
 		}
 		catch ( PropertyNotFoundException pnfe ) {
             LOG.noDefaultConstructor(mappedClass.getName());
 			constructor = null;
 		}
 	}
 
 	public PojoInstantiator(EntityBinding entityBinding, ReflectionOptimizer.InstantiationOptimizer optimizer) {
-		this.mappedClass = entityBinding.getEntity().getJavaType().getClassReference();
-		this.proxyInterface = entityBinding.getProxyInterfaceType().getClassReference();
+		this.mappedClass = entityBinding.getEntity().getClassReference();
+		this.proxyInterface = entityBinding.getProxyInterfaceType().getValue();
 		this.embeddedIdentifier = entityBinding.getEntityIdentifier().isEmbedded();
 		this.optimizer = optimizer;
 
 		try {
 			constructor = ReflectHelper.getDefaultConstructor( mappedClass );
 		}
 		catch ( PropertyNotFoundException pnfe ) {
 			LOG.noDefaultConstructor(mappedClass.getName());
 			constructor = null;
 		}
 	}
 
 	private void readObject(java.io.ObjectInputStream stream)
 	throws ClassNotFoundException, IOException {
 		stream.defaultReadObject();
 		constructor = ReflectHelper.getDefaultConstructor( mappedClass );
 	}
 
 	public Object instantiate() {
 		if ( ReflectHelper.isAbstractClass(mappedClass) ) {
 			throw new InstantiationException( "Cannot instantiate abstract class or interface: ", mappedClass );
 		}
 		else if ( optimizer != null ) {
 			return optimizer.newInstance();
 		}
 		else if ( constructor == null ) {
 			throw new InstantiationException( "No default constructor for entity: ", mappedClass );
 		}
 		else {
 			try {
 				return constructor.newInstance( (Object[]) null );
 			}
 			catch ( Exception e ) {
 				throw new InstantiationException( "Could not instantiate entity: ", mappedClass, e );
 			}
 		}
 	}
 
 	public Object instantiate(Serializable id) {
 		final boolean useEmbeddedIdentifierInstanceAsEntity = embeddedIdentifier &&
 				id != null &&
 				id.getClass().equals(mappedClass);
 		return useEmbeddedIdentifierInstanceAsEntity ? id : instantiate();
 	}
 
 	public boolean isInstance(Object object) {
 		return mappedClass.isInstance(object) ||
 				( proxyInterface!=null && proxyInterface.isInstance(object) ); //this one needed only for guessEntityMode()
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/PropertyFactory.java b/hibernate-core/src/main/java/org/hibernate/tuple/PropertyFactory.java
index 2f23d04551..6ff5e12423 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/PropertyFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/PropertyFactory.java
@@ -1,382 +1,382 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.tuple;
 import java.lang.reflect.Constructor;
 import org.hibernate.EntityMode;
 import org.hibernate.FetchMode;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.IdentifierValue;
 import org.hibernate.engine.internal.UnsavedValueFactory;
 import org.hibernate.engine.spi.VersionValue;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.mapping.KeyValue;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.PropertyGeneration;
 import org.hibernate.metamodel.binding.AttributeBinding;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.binding.EntityIdentifier;
 import org.hibernate.metamodel.binding.PluralAttributeBinding;
 import org.hibernate.metamodel.binding.SimpleAttributeBinding;
 import org.hibernate.property.Getter;
 import org.hibernate.property.PropertyAccessor;
 import org.hibernate.property.PropertyAccessorFactory;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.Type;
 import org.hibernate.type.VersionType;
 import org.hibernate.internal.util.ReflectHelper;
 
 /**
  * Responsible for generation of runtime metamodel {@link Property} representations.
  * Makes distinction between identifier, version, and other (standard) properties.
  *
  * @author Steve Ebersole
  */
 public class PropertyFactory {
 
 	/**
 	 * Generates an IdentifierProperty representation of the for a given entity mapping.
 	 *
 	 * @param mappedEntity The mapping definition of the entity.
 	 * @param generator The identifier value generator to use for this identifier.
 	 * @return The appropriate IdentifierProperty definition.
 	 */
 	public static IdentifierProperty buildIdentifierProperty(PersistentClass mappedEntity, IdentifierGenerator generator) {
 
 		String mappedUnsavedValue = mappedEntity.getIdentifier().getNullValue();
 		Type type = mappedEntity.getIdentifier().getType();
 		Property property = mappedEntity.getIdentifierProperty();
 		
 		IdentifierValue unsavedValue = UnsavedValueFactory.getUnsavedIdentifierValue(
 				mappedUnsavedValue,
 				getGetter( property ),
 				type,
 				getConstructor(mappedEntity)
 			);
 
 		if ( property == null ) {
 			// this is a virtual id property...
 			return new IdentifierProperty(
 			        type,
 					mappedEntity.hasEmbeddedIdentifier(),
 					mappedEntity.hasIdentifierMapper(),
 					unsavedValue,
 					generator
 				);
 		}
 		else {
 			return new IdentifierProperty(
 					property.getName(),
 					property.getNodeName(),
 					type,
 					mappedEntity.hasEmbeddedIdentifier(),
 					unsavedValue,
 					generator
 				);
 		}
 	}
 
 	/**
 	 * Generates an IdentifierProperty representation of the for a given entity mapping.
 	 *
 	 * @param mappedEntity The mapping definition of the entity.
 	 * @param generator The identifier value generator to use for this identifier.
 	 * @return The appropriate IdentifierProperty definition.
 	 */
 	public static IdentifierProperty buildIdentifierProperty(EntityBinding mappedEntity, IdentifierGenerator generator) {
 
 		final SimpleAttributeBinding property = mappedEntity.getEntityIdentifier().getValueBinding();
 
 		// TODO: the following will cause an NPE with "virtual" IDs; how should they be set?
 		final String mappedUnsavedValue = property.getUnsavedValue();
 		final Type type = property.getHibernateTypeDescriptor().getExplicitType();
 
 		IdentifierValue unsavedValue = UnsavedValueFactory.getUnsavedIdentifierValue(
 				mappedUnsavedValue,
 				getGetter( property ),
 				type,
 				getConstructor( mappedEntity )
 			);
 
 		if ( property == null ) {
 			// this is a virtual id property...
 			return new IdentifierProperty(
 			        type,
 					mappedEntity.getEntityIdentifier().isEmbedded(),
 					mappedEntity.getEntityIdentifier().isIdentifierMapper(),
 					unsavedValue,
 					generator
 				);
 		}
 		else {
 			return new IdentifierProperty(
 					property.getAttribute().getName(),
-					property.getNodeName(),
+					null,
 					type,
 					mappedEntity.getEntityIdentifier().isEmbedded(),
 					unsavedValue,
 					generator
 				);
 		}
 	}
 
 	/**
 	 * Generates a VersionProperty representation for an entity mapping given its
 	 * version mapping Property.
 	 *
 	 * @param property The version mapping Property.
 	 * @param lazyAvailable Is property lazy loading currently available.
 	 * @return The appropriate VersionProperty definition.
 	 */
 	public static VersionProperty buildVersionProperty(Property property, boolean lazyAvailable) {
 		String mappedUnsavedValue = ( (KeyValue) property.getValue() ).getNullValue();
 		
 		VersionValue unsavedValue = UnsavedValueFactory.getUnsavedVersionValue(
 				mappedUnsavedValue,
 				getGetter( property ),
 				(VersionType) property.getType(),
 				getConstructor( property.getPersistentClass() )
 			);
 
 		boolean lazy = lazyAvailable && property.isLazy();
 
 		return new VersionProperty(
 		        property.getName(),
 		        property.getNodeName(),
 		        property.getValue().getType(),
 		        lazy,
 				property.isInsertable(),
 				property.isUpdateable(),
 		        property.getGeneration() == PropertyGeneration.INSERT || property.getGeneration() == PropertyGeneration.ALWAYS,
 				property.getGeneration() == PropertyGeneration.ALWAYS,
 				property.isOptional(),
 				property.isUpdateable() && !lazy,
 				property.isOptimisticLocked(),
 		        property.getCascadeStyle(),
 		        unsavedValue
 			);
 	}
 
 	/**
 	 * Generates a VersionProperty representation for an entity mapping given its
 	 * version mapping Property.
 	 *
 	 * @param property The version mapping Property.
 	 * @param lazyAvailable Is property lazy loading currently available.
 	 * @return The appropriate VersionProperty definition.
 	 */
 	public static VersionProperty buildVersionProperty(SimpleAttributeBinding property, boolean lazyAvailable) {
 		String mappedUnsavedValue = ( (KeyValue) property.getValue() ).getNullValue();
 
 		VersionValue unsavedValue = UnsavedValueFactory.getUnsavedVersionValue(
 				mappedUnsavedValue,
 				getGetter( property ),
 				( VersionType ) property.getHibernateTypeDescriptor().getExplicitType(),
 				getConstructor( property.getEntityBinding() )
 		);
 
 		boolean lazy = lazyAvailable && property.isLazy();
 
 		return new VersionProperty(
 		        property.getAttribute().getName(),
-		        property.getNodeName(),
+		        null,
 		        property.getHibernateTypeDescriptor().getExplicitType(),
 		        lazy,
 				property.isInsertable(),
 				property.isUpdatable(),
 		        property.getGeneration() == PropertyGeneration.INSERT || property.getGeneration() == PropertyGeneration.ALWAYS,
 				property.getGeneration() == PropertyGeneration.ALWAYS,
 				property.isNullable(),
 				property.isUpdatable() && !lazy,
 				property.isOptimisticLockable(),
 				// TODO: get cascadeStyle from property when HHH-6355 is fixed; for now, assume NONE
 				//property.getCascadeStyle(),
 				CascadeStyle.NONE,
 		        unsavedValue
 			);
 	}
 
 	/**
 	 * Generate a "standard" (i.e., non-identifier and non-version) based on the given
 	 * mapped property.
 	 *
 	 * @param property The mapped property.
 	 * @param lazyAvailable Is property lazy loading currently available.
 	 * @return The appropriate StandardProperty definition.
 	 */
 	public static StandardProperty buildStandardProperty(Property property, boolean lazyAvailable) {
 		
 		final Type type = property.getValue().getType();
 		
 		// we need to dirty check collections, since they can cause an owner
 		// version number increment
 		
 		// we need to dirty check many-to-ones with not-found="ignore" in order 
 		// to update the cache (not the database), since in this case a null
 		// entity reference can lose information
 		
 		boolean alwaysDirtyCheck = type.isAssociationType() && 
 				( (AssociationType) type ).isAlwaysDirtyChecked(); 
 
 		return new StandardProperty(
 				property.getName(),
 				property.getNodeName(),
 				type,
 				lazyAvailable && property.isLazy(),
 				property.isInsertable(),
 				property.isUpdateable(),
 		        property.getGeneration() == PropertyGeneration.INSERT || property.getGeneration() == PropertyGeneration.ALWAYS,
 				property.getGeneration() == PropertyGeneration.ALWAYS,
 				property.isOptional(),
 				alwaysDirtyCheck || property.isUpdateable(),
 				property.isOptimisticLocked(),
 				property.getCascadeStyle(),
 		        property.getValue().getFetchMode()
 			);
 	}
 
 	/**
 	 * Generate a "standard" (i.e., non-identifier and non-version) based on the given
 	 * mapped property.
 	 *
 	 * @param property The mapped property.
 	 * @param lazyAvailable Is property lazy loading currently available.
 	 * @return The appropriate StandardProperty definition.
 	 */
 	public static StandardProperty buildStandardProperty(AttributeBinding property, boolean lazyAvailable) {
 
 		final Type type = property.getHibernateTypeDescriptor().getExplicitType();
 
 		// we need to dirty check collections, since they can cause an owner
 		// version number increment
 
 		// we need to dirty check many-to-ones with not-found="ignore" in order
 		// to update the cache (not the database), since in this case a null
 		// entity reference can lose information
 
 		boolean alwaysDirtyCheck = type.isAssociationType() &&
 				( (AssociationType) type ).isAlwaysDirtyChecked();
 
 		if ( property.isSimpleValue() ) {
 			SimpleAttributeBinding simpleProperty = ( SimpleAttributeBinding ) property;
 			return new StandardProperty(
 					simpleProperty.getAttribute().getName(),
-					simpleProperty.getNodeName(),
+					null,
 					type,
 					lazyAvailable && simpleProperty.isLazy(),
 					simpleProperty.isInsertable(),
 					simpleProperty.isUpdatable(),
 					simpleProperty.getGeneration() == PropertyGeneration.INSERT || simpleProperty.getGeneration() == PropertyGeneration.ALWAYS,
 					simpleProperty.getGeneration() == PropertyGeneration.ALWAYS,
 					simpleProperty.isNullable(),
 					alwaysDirtyCheck || simpleProperty.isUpdatable(),
 					simpleProperty.isOptimisticLockable(),
 					// TODO: get cascadeStyle from simpleProperty when HHH-6355 is fixed; for now, assume NONE
 					//simpleProperty.getCascadeStyle(),
 					CascadeStyle.NONE,
 					// TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT
 					//simpleProperty.getFetchMode()
 					FetchMode.DEFAULT
 				);
 		}
 		else {
 			PluralAttributeBinding pluralProperty = ( PluralAttributeBinding ) property;
 
 			return new StandardProperty(
 					pluralProperty.getAttribute().getName(),
-					pluralProperty.getNodeName(),
+					null,
 					type,
 					lazyAvailable && pluralProperty.isLazy(),
 					// TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable
 					// pluralProperty.isInsertable(),
 					//pluralProperty.isUpdatable(),
 					true,
 					true,
 					false,
 					false,
 					pluralProperty.isNullable(),
 					// TODO: fix this when HHH-6356 is fixed; for now assume PluralAttributeBinding is updatable and insertable
 					//alwaysDirtyCheck || pluralProperty.isUpdatable(),
 					true,
 					pluralProperty.isOptimisticLocked(),
 					// TODO: get cascadeStyle from property when HHH-6355 is fixed; for now, assume NONE
 					//pluralProperty.getCascadeStyle(),
 					CascadeStyle.NONE,
 					// TODO: get fetchMode() from simpleProperty when HHH-6357 is fixed; for now, assume FetchMode.DEFAULT
 					//pluralProperty.getFetchMode()
 					FetchMode.DEFAULT
 				);
 		}
 	}
 
 	private static Constructor getConstructor(PersistentClass persistentClass) {
 		if ( persistentClass == null || !persistentClass.hasPojoRepresentation() ) {
 			return null;
 		}
 
 		try {
 			return ReflectHelper.getDefaultConstructor( persistentClass.getMappedClass() );
 		}
 		catch( Throwable t ) {
 			return null;
 		}
 	}
 
 	private static Constructor getConstructor(EntityBinding entityBinding) {
-		if ( entityBinding == null || entityBinding.getEntity().getJavaType() == null ) {
+		if ( entityBinding == null || entityBinding.getEntity() == null ) {
 			return null;
 		}
 
 		try {
-			return ReflectHelper.getDefaultConstructor( entityBinding.getEntity().getJavaType().getClassReference() );
+			return ReflectHelper.getDefaultConstructor( entityBinding.getEntity().getClassReference() );
 		}
 		catch( Throwable t ) {
 			return null;
 		}
 	}
 
 	private static Getter getGetter(Property mappingProperty) {
 		if ( mappingProperty == null || !mappingProperty.getPersistentClass().hasPojoRepresentation() ) {
 			return null;
 		}
 
 		PropertyAccessor pa = PropertyAccessorFactory.getPropertyAccessor( mappingProperty, EntityMode.POJO );
 		return pa.getGetter( mappingProperty.getPersistentClass().getMappedClass(), mappingProperty.getName() );
 	}
 
 	private static Getter getGetter(AttributeBinding mappingProperty) {
-		if ( mappingProperty == null || mappingProperty.getEntityBinding().getEntity().getJavaType() == null ) {
+		if ( mappingProperty == null || mappingProperty.getEntityBinding().getEntity() == null ) {
 			return null;
 		}
 
 		PropertyAccessor pa = PropertyAccessorFactory.getPropertyAccessor( mappingProperty, EntityMode.POJO );
 		return pa.getGetter(
-				mappingProperty.getEntityBinding().getEntity().getJavaType().getClassReference(),
+				mappingProperty.getEntityBinding().getEntity().getClassReference(),
 				mappingProperty.getAttribute().getName()
 		);
 	}
 
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java b/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java
index 626b9ac2ce..73ccd8c088 100644
--- a/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java
+++ b/hibernate-core/src/main/java/org/hibernate/tuple/entity/PojoEntityTuplizer.java
@@ -1,554 +1,554 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tuple.entity;
 
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.EntityMode;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.HibernateException;
 import org.hibernate.PropertyNotFoundException;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.MappingException;
 import org.hibernate.bytecode.instrumentation.internal.FieldInterceptionHelper;
 import org.hibernate.bytecode.instrumentation.spi.FieldInterceptor;
 import org.hibernate.bytecode.spi.ReflectionOptimizer;
 import org.hibernate.cfg.Environment;
 import org.hibernate.classic.Lifecycle;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.Subclass;
 import org.hibernate.metamodel.binding.AttributeBinding;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.property.Getter;
 import org.hibernate.property.PropertyAccessor;
 import org.hibernate.property.PropertyAccessorFactory;
 import org.hibernate.property.Setter;
 import org.hibernate.proxy.HibernateProxy;
 import org.hibernate.proxy.ProxyFactory;
 import org.hibernate.tuple.Instantiator;
 import org.hibernate.tuple.PojoInstantiator;
 import org.hibernate.type.CompositeType;
 
 /**
  * An {@link EntityTuplizer} specific to the pojo entity mode.
  *
  * @author Steve Ebersole
  * @author Gavin King
  */
 public class PojoEntityTuplizer extends AbstractEntityTuplizer {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, PojoEntityTuplizer.class.getName());
 
 	private final Class mappedClass;
 	private final Class proxyInterface;
 	private final boolean lifecycleImplementor;
 	private final Set lazyPropertyNames = new HashSet();
 	private final ReflectionOptimizer optimizer;
 
 	public PojoEntityTuplizer(EntityMetamodel entityMetamodel, PersistentClass mappedEntity) {
 		super( entityMetamodel, mappedEntity );
 		this.mappedClass = mappedEntity.getMappedClass();
 		this.proxyInterface = mappedEntity.getProxyInterface();
 		this.lifecycleImplementor = Lifecycle.class.isAssignableFrom( mappedClass );
 
 		Iterator iter = mappedEntity.getPropertyClosureIterator();
 		while ( iter.hasNext() ) {
 			Property property = (Property) iter.next();
 			if ( property.isLazy() ) {
 				lazyPropertyNames.add( property.getName() );
 			}
 		}
 
 		String[] getterNames = new String[propertySpan];
 		String[] setterNames = new String[propertySpan];
 		Class[] propTypes = new Class[propertySpan];
 		for ( int i = 0; i < propertySpan; i++ ) {
 			getterNames[i] = getters[i].getMethodName();
 			setterNames[i] = setters[i].getMethodName();
 			propTypes[i] = getters[i].getReturnType();
 		}
 
 		if ( hasCustomAccessors || !Environment.useReflectionOptimizer() ) {
 			optimizer = null;
 		}
 		else {
 			// todo : YUCK!!!
 			optimizer = Environment.getBytecodeProvider().getReflectionOptimizer( mappedClass, getterNames, setterNames, propTypes );
 //			optimizer = getFactory().getSettings().getBytecodeProvider().getReflectionOptimizer(
 //					mappedClass, getterNames, setterNames, propTypes
 //			);
 		}
 
 	}
 
 	public PojoEntityTuplizer(EntityMetamodel entityMetamodel, EntityBinding mappedEntity) {
 		super( entityMetamodel, mappedEntity );
-		this.mappedClass = mappedEntity.getEntity().getJavaType().getClassReference();
-		this.proxyInterface = mappedEntity.getProxyInterfaceType().getClassReference();
+		this.mappedClass = mappedEntity.getEntity().getClassReference();
+		this.proxyInterface = mappedEntity.getProxyInterfaceType().getValue();
 		this.lifecycleImplementor = Lifecycle.class.isAssignableFrom( mappedClass );
 
 		for ( AttributeBinding property : mappedEntity.getAttributeBindingClosure() ) {
 			if ( property.isLazy() ) {
 				lazyPropertyNames.add( property.getAttribute().getName() );
 			}
 		}
 
 		String[] getterNames = new String[propertySpan];
 		String[] setterNames = new String[propertySpan];
 		Class[] propTypes = new Class[propertySpan];
 		for ( int i = 0; i < propertySpan; i++ ) {
 			getterNames[i] = getters[ i ].getMethodName();
 			setterNames[i] = setters[ i ].getMethodName();
 			propTypes[i] = getters[ i ].getReturnType();
 		}
 
 		if ( hasCustomAccessors || ! Environment.useReflectionOptimizer() ) {
 			optimizer = null;
 		}
 		else {
 			// todo : YUCK!!!
 			optimizer = Environment.getBytecodeProvider().getReflectionOptimizer(
 					mappedClass, getterNames, setterNames, propTypes
 			);
 //			optimizer = getFactory().getSettings().getBytecodeProvider().getReflectionOptimizer(
 //					mappedClass, getterNames, setterNames, propTypes
 //			);
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     protected ProxyFactory buildProxyFactory(PersistentClass persistentClass, Getter idGetter, Setter idSetter) {
 		// determine the id getter and setter methods from the proxy interface (if any)
         // determine all interfaces needed by the resulting proxy
 		HashSet<Class> proxyInterfaces = new HashSet<Class>();
 		proxyInterfaces.add( HibernateProxy.class );
 
 		Class mappedClass = persistentClass.getMappedClass();
 		Class proxyInterface = persistentClass.getProxyInterface();
 
 		if ( proxyInterface!=null && !mappedClass.equals( proxyInterface ) ) {
 			if ( !proxyInterface.isInterface() ) {
 				throw new MappingException(
 						"proxy must be either an interface, or the class itself: " + getEntityName()
 				);
 			}
 			proxyInterfaces.add( proxyInterface );
 		}
 
 		if ( mappedClass.isInterface() ) {
 			proxyInterfaces.add( mappedClass );
 		}
 
 		Iterator subclasses = persistentClass.getSubclassIterator();
 		while ( subclasses.hasNext() ) {
 			final Subclass subclass = ( Subclass ) subclasses.next();
 			final Class subclassProxy = subclass.getProxyInterface();
 			final Class subclassClass = subclass.getMappedClass();
 			if ( subclassProxy!=null && !subclassClass.equals( subclassProxy ) ) {
 				if ( !subclassProxy.isInterface() ) {
 					throw new MappingException(
 							"proxy must be either an interface, or the class itself: " + subclass.getEntityName()
 					);
 				}
 				proxyInterfaces.add( subclassProxy );
 			}
 		}
 
 		Iterator properties = persistentClass.getPropertyIterator();
 		Class clazz = persistentClass.getMappedClass();
 		while ( properties.hasNext() ) {
 			Property property = (Property) properties.next();
 			Method method = property.getGetter(clazz).getMethod();
 			if ( method != null && Modifier.isFinal( method.getModifiers() ) ) {
                 LOG.gettersOfLazyClassesCannotBeFinal(persistentClass.getEntityName(), property.getName());
 			}
 			method = property.getSetter(clazz).getMethod();
             if ( method != null && Modifier.isFinal( method.getModifiers() ) ) {
                 LOG.settersOfLazyClassesCannotBeFinal(persistentClass.getEntityName(), property.getName());
 			}
 		}
 
 		Method idGetterMethod = idGetter==null ? null : idGetter.getMethod();
 		Method idSetterMethod = idSetter==null ? null : idSetter.getMethod();
 
 		Method proxyGetIdentifierMethod = idGetterMethod==null || proxyInterface==null ?
 				null :
 		        ReflectHelper.getMethod(proxyInterface, idGetterMethod);
 		Method proxySetIdentifierMethod = idSetterMethod==null || proxyInterface==null  ?
 				null :
 		        ReflectHelper.getMethod(proxyInterface, idSetterMethod);
 
 		ProxyFactory pf = buildProxyFactoryInternal( persistentClass, idGetter, idSetter );
 		try {
 			pf.postInstantiate(
 					getEntityName(),
 					mappedClass,
 					proxyInterfaces,
 					proxyGetIdentifierMethod,
 					proxySetIdentifierMethod,
 					persistentClass.hasEmbeddedIdentifier() ?
 			                (CompositeType) persistentClass.getIdentifier().getType() :
 			                null
 			);
 		}
 		catch ( HibernateException he ) {
             LOG.unableToCreateProxyFactory(getEntityName(), he);
 			pf = null;
 		}
 		return pf;
 	}
 
 	protected ProxyFactory buildProxyFactoryInternal(PersistentClass persistentClass, Getter idGetter, Setter idSetter) {
 		// TODO : YUCK!!!  fix after HHH-1907 is complete
 		return Environment.getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();
 //		return getFactory().getSettings().getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     protected Instantiator buildInstantiator(PersistentClass persistentClass) {
 		if ( optimizer == null ) {
 			return new PojoInstantiator( persistentClass, null );
 		}
 		else {
 			return new PojoInstantiator( persistentClass, optimizer.getInstantiationOptimizer() );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
 	protected ProxyFactory buildProxyFactory(EntityBinding entityBinding, Getter idGetter, Setter idSetter) {
 		// determine the id getter and setter methods from the proxy interface (if any)
 		// determine all interfaces needed by the resulting proxy
 		HashSet<Class> proxyInterfaces = new HashSet<Class>();
 		proxyInterfaces.add( HibernateProxy.class );
 
-		Class mappedClass = entityBinding.getEntity().getJavaType().getClassReference();
-		Class proxyInterface = entityBinding.getProxyInterfaceType().getClassReference();
+		Class mappedClass = entityBinding.getEntity().getClassReference();
+		Class proxyInterface = entityBinding.getProxyInterfaceType().getValue();
 
 		if ( proxyInterface!=null && !mappedClass.equals( proxyInterface ) ) {
 			if ( ! proxyInterface.isInterface() ) {
 				throw new MappingException(
 						"proxy must be either an interface, or the class itself: " + getEntityName()
 				);
 			}
 			proxyInterfaces.add( proxyInterface );
 		}
 
 		if ( mappedClass.isInterface() ) {
 			proxyInterfaces.add( mappedClass );
 		}
 
 		// TODO: fix when it's possible to get subclasses from an EntityBinding
 		//Iterator subclasses = entityBinding.getSubclassIterator();
 		//while ( subclasses.hasNext() ) {
 		//	final Subclass subclass = ( Subclass ) subclasses.next();
 		//	final Class subclassProxy = subclass.getProxyInterface();
 		//	final Class subclassClass = subclass.getMappedClass();
 		//	if ( subclassProxy!=null && !subclassClass.equals( subclassProxy ) ) {
 		//		if ( !subclassProxy.isInterface() ) {
 		//			throw new MappingException(
 		//					"proxy must be either an interface, or the class itself: " + subclass.getEntityName()
 		//			);
 		//		}
 		//		proxyInterfaces.add( subclassProxy );
 		//	}
 		//}
 
 		for ( AttributeBinding property : entityBinding.getAttributeBindings() ) {
 			Method method = getGetter( property ).getMethod();
 			if ( method != null && Modifier.isFinal( method.getModifiers() ) ) {
 				LOG.gettersOfLazyClassesCannotBeFinal(entityBinding.getEntity().getName(), property.getAttribute().getName());
 			}
 			method = getSetter( property ).getMethod();
 			if ( method != null && Modifier.isFinal( method.getModifiers() ) ) {
 				LOG.settersOfLazyClassesCannotBeFinal(entityBinding.getEntity().getName(), property.getAttribute().getName());
 			}
 		}
 
 		Method idGetterMethod = idGetter==null ? null : idGetter.getMethod();
 		Method idSetterMethod = idSetter==null ? null : idSetter.getMethod();
 
 		Method proxyGetIdentifierMethod = idGetterMethod==null || proxyInterface==null ?
 				null :
 		        ReflectHelper.getMethod(proxyInterface, idGetterMethod);
 		Method proxySetIdentifierMethod = idSetterMethod==null || proxyInterface==null  ?
 				null :
 		        ReflectHelper.getMethod(proxyInterface, idSetterMethod);
 
 		ProxyFactory pf = buildProxyFactoryInternal( entityBinding, idGetter, idSetter );
 		try {
 			pf.postInstantiate(
 					getEntityName(),
 					mappedClass,
 					proxyInterfaces,
 					proxyGetIdentifierMethod,
 					proxySetIdentifierMethod,
 					entityBinding.getEntityIdentifier().isEmbedded() ?
 			                ( CompositeType ) entityBinding
 									.getEntityIdentifier()
 									.getValueBinding()
 									.getHibernateTypeDescriptor()
 									.getExplicitType() :
 			                null
 			);
 		}
 		catch ( HibernateException he ) {
 			LOG.unableToCreateProxyFactory(getEntityName(), he);
 			pf = null;
 		}
 		return pf;
 	}
 
 	protected ProxyFactory buildProxyFactoryInternal(EntityBinding entityBinding, Getter idGetter, Setter idSetter) {
 		// TODO : YUCK!!!  fix after HHH-1907 is complete
 		return Environment.getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();
 //		return getFactory().getSettings().getBytecodeProvider().getProxyFactoryFactory().buildProxyFactory();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
 	protected Instantiator buildInstantiator(EntityBinding entityBinding) {
 		if ( optimizer == null ) {
 			return new PojoInstantiator( entityBinding, null );
 		}
 		else {
 			return new PojoInstantiator( entityBinding, optimizer.getInstantiationOptimizer() );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public void setPropertyValues(Object entity, Object[] values) throws HibernateException {
 		if ( !getEntityMetamodel().hasLazyProperties() && optimizer != null && optimizer.getAccessOptimizer() != null ) {
 			setPropertyValuesWithOptimizer( entity, values );
 		}
 		else {
 			super.setPropertyValues( entity, values );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public Object[] getPropertyValues(Object entity) throws HibernateException {
 		if ( shouldGetAllProperties( entity ) && optimizer != null && optimizer.getAccessOptimizer() != null ) {
 			return getPropertyValuesWithOptimizer( entity );
 		}
 		else {
 			return super.getPropertyValues( entity );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public Object[] getPropertyValuesToInsert(Object entity, Map mergeMap, SessionImplementor session) throws HibernateException {
 		if ( shouldGetAllProperties( entity ) && optimizer != null && optimizer.getAccessOptimizer() != null ) {
 			return getPropertyValuesWithOptimizer( entity );
 		}
 		else {
 			return super.getPropertyValuesToInsert( entity, mergeMap, session );
 		}
 	}
 
 	protected void setPropertyValuesWithOptimizer(Object object, Object[] values) {
 		optimizer.getAccessOptimizer().setPropertyValues( object, values );
 	}
 
 	protected Object[] getPropertyValuesWithOptimizer(Object object) {
 		return optimizer.getAccessOptimizer().getPropertyValues( object );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public EntityMode getEntityMode() {
 		return EntityMode.POJO;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Class getMappedClass() {
 		return mappedClass;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public boolean isLifecycleImplementor() {
 		return lifecycleImplementor;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     protected Getter buildPropertyGetter(Property mappedProperty, PersistentClass mappedEntity) {
 		return mappedProperty.getGetter( mappedEntity.getMappedClass() );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     protected Setter buildPropertySetter(Property mappedProperty, PersistentClass mappedEntity) {
 		return mappedProperty.getSetter( mappedEntity.getMappedClass() );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
 	protected Getter buildPropertyGetter(AttributeBinding mappedProperty) {
 		return getGetter( mappedProperty );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
 	protected Setter buildPropertySetter(AttributeBinding mappedProperty) {
 		return getSetter( mappedProperty );
 	}
 
 	private Getter getGetter(AttributeBinding mappedProperty)  throws PropertyNotFoundException, MappingException {
 		return getPropertyAccessor( mappedProperty ).getGetter(
-				mappedProperty.getEntityBinding().getEntity().getJavaType().getClassReference(),
+				mappedProperty.getEntityBinding().getEntity().getClassReference(),
 				mappedProperty.getAttribute().getName()
 		);
 	}
 
 	private Setter getSetter(AttributeBinding mappedProperty) throws PropertyNotFoundException, MappingException {
 		return getPropertyAccessor( mappedProperty ).getSetter(
-				mappedProperty.getEntityBinding().getEntity().getJavaType().getClassReference(),
+				mappedProperty.getEntityBinding().getEntity().getClassReference(),
 				mappedProperty.getAttribute().getName()
 		);
 	}
 
 	private PropertyAccessor getPropertyAccessor(AttributeBinding mappedProperty) throws MappingException {
 		// TODO: Fix this then backrefs are working in new metamodel
 		return PropertyAccessorFactory.getPropertyAccessor(
-				mappedProperty.getEntityBinding().getEntity().getJavaType().getClassReference(),
+				mappedProperty.getEntityBinding().getEntity().getClassReference(),
 				mappedProperty.getPropertyAccessorName()
 		);
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Class getConcreteProxyClass() {
 		return proxyInterface;
 	}
 
     //TODO: need to make the majority of this functionality into a top-level support class for custom impl support
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public void afterInitialize(Object entity, boolean lazyPropertiesAreUnfetched, SessionImplementor session) {
 		if ( isInstrumented() ) {
 			Set lazyProps = lazyPropertiesAreUnfetched && getEntityMetamodel().hasLazyProperties() ?
 					lazyPropertyNames : null;
 			//TODO: if we support multiple fetch groups, we would need
 			//      to clone the set of lazy properties!
 			FieldInterceptionHelper.injectFieldInterceptor( entity, getEntityName(), lazyProps, session );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	@Override
     public boolean hasUninitializedLazyProperties(Object entity) {
 		if ( getEntityMetamodel().hasLazyProperties() ) {
 			FieldInterceptor callback = FieldInterceptionHelper.extractFieldInterceptor( entity );
 			return callback != null && !callback.isInitialized();
 		}
 		else {
 			return false;
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public boolean isInstrumented() {
 		return FieldInterceptionHelper.isInstrumented( getMappedClass() );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public String determineConcreteSubclassEntityName(Object entityInstance, SessionFactoryImplementor factory) {
 		final Class concreteEntityClass = entityInstance.getClass();
 		if ( concreteEntityClass == getMappedClass() ) {
 			return getEntityName();
 		}
 		else {
 			String entityName = getEntityMetamodel().findEntityNameByEntityClass( concreteEntityClass );
 			if ( entityName == null ) {
 				throw new HibernateException(
 						"Unable to resolve entity name from Class [" + concreteEntityClass.getName() + "]"
 								+ " expected instance/subclass of [" + getEntityName() + "]"
 				);
 			}
 			return entityName;
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public EntityNameResolver[] getEntityNameResolvers() {
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/xjb/hbm-mapping-bindings.xjb b/hibernate-core/src/main/xjb/hbm-mapping-bindings.xjb
index 34668f34c7..74dcd601f6 100644
--- a/hibernate-core/src/main/xjb/hbm-mapping-bindings.xjb
+++ b/hibernate-core/src/main/xjb/hbm-mapping-bindings.xjb
@@ -1,134 +1,134 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
 <jaxb:bindings xmlns:jaxb="http://java.sun.com/xml/ns/jaxb"
         xmlns:xsd="http://www.w3.org/2001/XMLSchema"
         xmlns:inheritance="http://jaxb2-commons.dev.java.net/basic/inheritance"
         jaxb:extensionBindingPrefixes="inheritance"
         jaxb:version="2.1">
 
     <jaxb:bindings schemaLocation="../resources/org/hibernate/hibernate-mapping-4.0.xsd" node="/xsd:schema">
 
         <jaxb:schemaBindings>
             <jaxb:nameXmlTransform>
                 <jaxb:typeName prefix="XML"/>
                 <jaxb:elementName prefix="XML"/>
                 <jaxb:modelGroupName prefix="XML"/>
                 <jaxb:anonymousTypeName prefix="XML"/>
             </jaxb:nameXmlTransform>
         </jaxb:schemaBindings>
 
         <!-- Inheritance -->
         <jaxb:bindings node="//xsd:element[@name='class']/xsd:complexType">
-            <inheritance:implements>org.hibernate.metamodel.binder.source.hbm.xml.mapping.EntityElement</inheritance:implements>
-            <inheritance:implements>org.hibernate.metamodel.binder.source.hbm.xml.mapping.JoinElementSource</inheritance:implements>
+            <inheritance:implements>org.hibernate.metamodel.source.hbm.jaxb.mapping.EntityElement</inheritance:implements>
+            <inheritance:implements>org.hibernate.metamodel.source.hbm.jaxb.mapping.JoinElementSource</inheritance:implements>
         </jaxb:bindings>
         <jaxb:bindings node="//xsd:complexType[@name='subclass-element']">
-            <inheritance:implements>org.hibernate.metamodel.binder.source.hbm.xml.mapping.SubEntityElement</inheritance:implements>
-            <inheritance:implements>org.hibernate.metamodel.binder.source.hbm.xml.mapping.JoinElementSource</inheritance:implements>
+            <inheritance:implements>org.hibernate.metamodel.source.hbm.jaxb.mapping.SubEntityElement</inheritance:implements>
+            <inheritance:implements>org.hibernate.metamodel.source.hbm.jaxb.mapping.JoinElementSource</inheritance:implements>
         </jaxb:bindings>
         <jaxb:bindings node="//xsd:complexType[@name='joined-subclass-element']">
-            <inheritance:implements>org.hibernate.metamodel.binder.source.hbm.xml.mapping.SubEntityElement</inheritance:implements>
+            <inheritance:implements>org.hibernate.metamodel.source.hbm.jaxb.mapping.SubEntityElement</inheritance:implements>
         </jaxb:bindings>
         <jaxb:bindings node="//xsd:complexType[@name='union-subclass-element']">
-            <inheritance:implements>org.hibernate.metamodel.binder.source.hbm.xml.mapping.SubEntityElement</inheritance:implements>
+            <inheritance:implements>org.hibernate.metamodel.source.hbm.jaxb.mapping.SubEntityElement</inheritance:implements>
         </jaxb:bindings>
         <jaxb:bindings node="//xsd:complexType[@name='sql-insert-element']">
-            <inheritance:implements>org.hibernate.metamodel.binder.source.hbm.xml.mapping.CustomSqlElement</inheritance:implements>
+            <inheritance:implements>org.hibernate.metamodel.source.hbm.jaxb.mapping.CustomSqlElement</inheritance:implements>
         </jaxb:bindings>
         <jaxb:bindings node="//xsd:complexType[@name='sql-update-element']">
-            <inheritance:implements>org.hibernate.metamodel.binder.source.hbm.xml.mapping.CustomSqlElement</inheritance:implements>
+            <inheritance:implements>org.hibernate.metamodel.source.hbm.jaxb.mapping.CustomSqlElement</inheritance:implements>
         </jaxb:bindings>
         <jaxb:bindings node="//xsd:complexType[@name='sql-delete-element']">
-            <inheritance:implements>org.hibernate.metamodel.binder.source.hbm.xml.mapping.CustomSqlElement</inheritance:implements>
+            <inheritance:implements>org.hibernate.metamodel.source.hbm.jaxb.mapping.CustomSqlElement</inheritance:implements>
         </jaxb:bindings>
         <jaxb:bindings node="//xsd:complexType[@name='sql-delete-all-element']">
-            <inheritance:implements>org.hibernate.metamodel.binder.source.hbm.xml.mapping.CustomSqlElement</inheritance:implements>
+            <inheritance:implements>org.hibernate.metamodel.source.hbm.jaxb.mapping.CustomSqlElement</inheritance:implements>
         </jaxb:bindings>
 
         <jaxb:bindings node="//xsd:element[@name='class']//xsd:attribute[@name='subselect']">
             <jaxb:property name="subselectAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:element[@name='discriminator']//xsd:attribute[@name='column']">
             <jaxb:property name="columnAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:element[@name='discriminator']//xsd:attribute[@name='formula']">
             <jaxb:property name="formulaAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:element[@name='id']//xsd:attribute[@name='column']">
             <jaxb:property name="columnAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:element[@name='id']//xsd:attribute[@name='type']">
             <jaxb:property name="typeAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:element[@name='version']//xsd:attribute[@name='column']">
             <jaxb:property name="columnAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='array-element']//xsd:attribute[@name='subselect']">
             <jaxb:property name="subselectAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='bag-element']//xsd:attribute[@name='subselect']">
             <jaxb:property name="subselectAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='element-element']//xsd:attribute[@name='type']">
             <jaxb:property name="typeAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='idbag-element']//xsd:attribute[@name='subselect']">
             <jaxb:property name="subselectAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='idbag-element']//xsd:element[@name='collection-id']//xsd:attribute[@name='column']">
             <jaxb:property name="columnAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='index-element']//xsd:attribute[@name='column']">
             <jaxb:property name="columnAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='join-element']//xsd:attribute[@name='subselect']">
             <jaxb:property name="subselectAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='joined-subclass-element']//xsd:attribute[@name='subselect']">
             <jaxb:property name="subselectAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='key-element']//xsd:attribute[@name='column']">
             <jaxb:property name="columnAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='key-many-to-one-element']//xsd:attribute[@name='column']">
             <jaxb:property name="columnAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='key-property-element']//xsd:attribute[@name='column']">
             <jaxb:property name="columnAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='key-property-element']//xsd:attribute[@name='type']">
             <jaxb:property name="typeAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='list-element']//xsd:attribute[@name='subselect']">
             <jaxb:property name="subselectAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='list-index-element']//xsd:attribute[@name='column']">
             <jaxb:property name="columnAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='map-element']//xsd:attribute[@name='subselect']">
             <jaxb:property name="subselectAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='map-element']//xsd:element[@name='map-key']//xsd:attribute[@name='type']">
             <jaxb:property name="typeAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='map-element']//xsd:element[@name='index-many-to-many']//xsd:attribute[@name='column']">
             <jaxb:property name="columnAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='one-to-one-element']//xsd:attribute[@name='formula']">
             <jaxb:property name="formulaAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='primitive-array-element']//xsd:attribute[@name='subselect']">
             <jaxb:property name="subselectAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='property-element']//xsd:attribute[@name='type']">
             <jaxb:property name="typeAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='set-element']//xsd:attribute[@name='subselect']">
             <jaxb:property name="subselectAttribute"/>
         </jaxb:bindings> 
         <jaxb:bindings node="//xsd:complexType[@name='union-subclass-element']//xsd:attribute[@name='subselect']">
             <jaxb:property name="subselectAttribute"/>
         </jaxb:bindings> 
     </jaxb:bindings>
 
 </jaxb:bindings>
\ No newline at end of file
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/AbstractBasicBindingTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/AbstractBasicBindingTests.java
index 80cd39066f..ca7f01602f 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/AbstractBasicBindingTests.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/AbstractBasicBindingTests.java
@@ -1,187 +1,184 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.binding;
 
 import java.sql.Types;
 import java.util.Iterator;
 import java.util.Set;
 
-import junit.framework.Assert;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.internal.MetadataImpl;
+import org.hibernate.metamodel.source.MetadataImplementor;
+import org.hibernate.metamodel.source.internal.MetadataImpl;
 import org.hibernate.metamodel.domain.BasicType;
 import org.hibernate.metamodel.domain.SingularAttribute;
 import org.hibernate.metamodel.domain.TypeNature;
 import org.hibernate.metamodel.relational.Column;
 import org.hibernate.metamodel.relational.Datatype;
 import org.hibernate.metamodel.relational.SimpleValue;
 import org.hibernate.service.BasicServiceRegistry;
 import org.hibernate.service.ServiceRegistryBuilder;
 import org.hibernate.service.internal.BasicServiceRegistryImpl;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 import org.hibernate.type.LongType;
 import org.hibernate.type.StringType;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Basic tests of {@code hbm.xml} and annotation binding code
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractBasicBindingTests extends BaseUnitTestCase {
 
 	private BasicServiceRegistryImpl serviceRegistry;
 	private MetadataSources sources;
 
 	@Before
 	public void setUp() {
 		serviceRegistry = (BasicServiceRegistryImpl) new ServiceRegistryBuilder().buildServiceRegistry();
 		sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
 	}
 
 	@After
 	public void tearDown() {
 		serviceRegistry.destroy();
 	}
 
 	protected BasicServiceRegistry basicServiceRegistry() {
 		return serviceRegistry;
 	}
 
 	@Test
 	public void testSimpleEntityMapping() {
 		MetadataImpl metadata = addSourcesForSimpleEntityBinding( sources );
 		EntityBinding entityBinding = metadata.getEntityBinding( SimpleEntity.class.getName() );
 		assertRoot( metadata, entityBinding );
 		assertIdAndSimpleProperty( entityBinding );
 
 		assertNull( entityBinding.getVersioningValueBinding() );
 	}
 
 	@Test
 	public void testSimpleVersionedEntityMapping() {
 		MetadataImpl metadata = addSourcesForSimpleVersionedEntityBinding( sources );
 		EntityBinding entityBinding = metadata.getEntityBinding( SimpleVersionedEntity.class.getName() );
 		assertIdAndSimpleProperty( entityBinding );
 
 		assertNotNull( entityBinding.getVersioningValueBinding() );
 		assertNotNull( entityBinding.getVersioningValueBinding().getAttribute() );
 	}
 
 	@Test
 	public void testEntityWithManyToOneMapping() {
 		MetadataImpl metadata = addSourcesForManyToOne( sources );
 
 		EntityBinding simpleEntityBinding = metadata.getEntityBinding( SimpleEntity.class.getName() );
 		assertIdAndSimpleProperty( simpleEntityBinding );
 
 		Set<EntityReferencingAttributeBinding> referenceBindings = simpleEntityBinding.getAttributeBinding( "id" )
 				.getEntityReferencingAttributeBindings();
 		assertEquals( "There should be only one reference binding", 1, referenceBindings.size() );
 
 		EntityReferencingAttributeBinding referenceBinding = referenceBindings.iterator().next();
 		EntityBinding referencedEntityBinding = referenceBinding.getReferencedEntityBinding();
 		// TODO - Is this assertion correct (HF)?
 		assertEquals( "Should be the same entity binding", referencedEntityBinding, simpleEntityBinding );
 
 		EntityBinding entityWithManyToOneBinding = metadata.getEntityBinding( ManyToOneEntity.class.getName() );
 		Iterator<EntityReferencingAttributeBinding> it = entityWithManyToOneBinding.getEntityReferencingAttributeBindings()
 				.iterator();
 		assertTrue( it.hasNext() );
 		assertSame( entityWithManyToOneBinding.getAttributeBinding( "simpleEntity" ), it.next() );
 		assertFalse( it.hasNext() );
 	}
 
 	public abstract MetadataImpl addSourcesForSimpleVersionedEntityBinding(MetadataSources sources);
 
 	public abstract MetadataImpl addSourcesForSimpleEntityBinding(MetadataSources sources);
 
 	public abstract MetadataImpl addSourcesForManyToOne(MetadataSources sources);
 
 	protected void assertIdAndSimpleProperty(EntityBinding entityBinding) {
 		assertNotNull( entityBinding );
 		assertNotNull( entityBinding.getEntityIdentifier() );
 		assertNotNull( entityBinding.getEntityIdentifier().getValueBinding() );
 
 		AttributeBinding idAttributeBinding = entityBinding.getAttributeBinding( "id" );
 		assertNotNull( idAttributeBinding );
 		assertSame( idAttributeBinding, entityBinding.getEntityIdentifier().getValueBinding() );
 		assertSame( LongType.INSTANCE, idAttributeBinding.getHibernateTypeDescriptor().getExplicitType() );
 
 		assertTrue( idAttributeBinding.getAttribute().isSingular() );
 		assertNotNull( idAttributeBinding.getAttribute() );
 		SingularAttribute singularIdAttribute =  ( SingularAttribute ) idAttributeBinding.getAttribute();
-		assertSame( TypeNature.BASIC, singularIdAttribute.getSingularAttributeType().getNature() );
 		BasicType basicIdAttributeType = ( BasicType ) singularIdAttribute.getSingularAttributeType();
-		assertSame( Long.class, basicIdAttributeType.getJavaType().getClassReference() );
+		assertSame( Long.class, basicIdAttributeType.getClassReference() );
 
 		assertNotNull( idAttributeBinding.getValue() );
 		assertTrue( idAttributeBinding.getValue() instanceof Column );
 		Datatype idDataType = ( (Column) idAttributeBinding.getValue() ).getDatatype();
 		assertSame( Long.class, idDataType.getJavaType() );
 		assertSame( Types.BIGINT, idDataType.getTypeCode() );
 		assertSame( LongType.INSTANCE.getName(), idDataType.getTypeName() );
 
 		AttributeBinding nameBinding = entityBinding.getAttributeBinding( "name" );
 		assertNotNull( nameBinding );
 		assertSame( StringType.INSTANCE, nameBinding.getHibernateTypeDescriptor().getExplicitType() );
 		assertNotNull( nameBinding.getAttribute() );
 		assertNotNull( nameBinding.getValue() );
 
 		assertTrue( nameBinding.getAttribute().isSingular() );
 		assertNotNull( nameBinding.getAttribute() );
 		SingularAttribute singularNameAttribute =  ( SingularAttribute ) nameBinding.getAttribute();
-		assertSame( TypeNature.BASIC, singularNameAttribute.getSingularAttributeType().getNature() );
 		BasicType basicNameAttributeType = ( BasicType ) singularNameAttribute.getSingularAttributeType();
-		assertSame( String.class, basicNameAttributeType.getJavaType().getClassReference() );
+		assertSame( String.class, basicNameAttributeType.getClassReference() );
 
 		assertNotNull( nameBinding.getValue() );
 		// until HHH-6380 is fixed, need to call getValues()
 		assertEquals( 1, nameBinding.getValuesSpan() );
 		Iterator<SimpleValue> it = nameBinding.getValues().iterator();
 		assertTrue( it.hasNext() );
 		SimpleValue nameValue = it.next();
 		assertTrue( nameValue instanceof Column );
 		Datatype nameDataType = nameValue.getDatatype();
 		assertSame( String.class, nameDataType.getJavaType() );
 		assertSame( Types.VARCHAR, nameDataType.getTypeCode() );
 		assertSame( StringType.INSTANCE.getName(), nameDataType.getTypeName() );
 	}
 
 	protected void assertRoot(MetadataImplementor metadata, EntityBinding entityBinding) {
 		assertTrue( entityBinding.isRoot() );
 		assertSame( entityBinding, metadata.getRootEntityBinding( entityBinding.getEntity().getName() ) );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicAnnotationBindingTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicAnnotationBindingTests.java
index e6aedf4e9e..2d907b2993 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicAnnotationBindingTests.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicAnnotationBindingTests.java
@@ -1,50 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.binding;
 
 import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.binder.source.internal.MetadataImpl;
+import org.hibernate.metamodel.source.internal.MetadataImpl;
 
 /**
  * Basic tests of annotation based binding code
  *
  * @author Hardy Ferentschik
  */
 public class BasicAnnotationBindingTests extends AbstractBasicBindingTests {
 	public MetadataImpl addSourcesForSimpleEntityBinding(MetadataSources sources) {
 		sources.addAnnotatedClass( SimpleEntity.class );
 		return (MetadataImpl) sources.buildMetadata();
 	}
 
 	public MetadataImpl addSourcesForSimpleVersionedEntityBinding(MetadataSources sources) {
 		sources.addAnnotatedClass( SimpleVersionedEntity.class );
 		return (MetadataImpl) sources.buildMetadata();
 	}
 
 	public MetadataImpl addSourcesForManyToOne(MetadataSources sources) {
 		sources.addAnnotatedClass( ManyToOneEntity.class );
 		sources.addAnnotatedClass( SimpleEntity.class );
 		return (MetadataImpl) sources.buildMetadata();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicHbmBindingTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicHbmBindingTests.java
index 34fcbbe37a..927354b15e 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicHbmBindingTests.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicHbmBindingTests.java
@@ -1,50 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.binding;
 
 import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.binder.source.internal.MetadataImpl;
+import org.hibernate.metamodel.source.internal.MetadataImpl;
 
 /**
  * Basic tests of {@code hbm.xml} binding code
  *
  * @author Steve Ebersole
  */
 public class BasicHbmBindingTests extends AbstractBasicBindingTests {
 	public MetadataImpl addSourcesForSimpleEntityBinding(MetadataSources sources) {
 		sources.addResource( "org/hibernate/metamodel/binding/SimpleEntity.hbm.xml" );
 		return (MetadataImpl) sources.buildMetadata();
 	}
 
 	public MetadataImpl addSourcesForSimpleVersionedEntityBinding(MetadataSources sources) {
 		sources.addResource( "org/hibernate/metamodel/binding/SimpleVersionedEntity.hbm.xml" );
 		return (MetadataImpl) sources.buildMetadata();
 	}
 
 	public MetadataImpl addSourcesForManyToOne(MetadataSources sources) {
 		sources.addResource( "org/hibernate/metamodel/binding/ManyToOneEntity.hbm.xml" );
 		sources.addResource( "org/hibernate/metamodel/binding/SimpleEntity.hbm.xml" );
 		return (MetadataImpl) sources.buildMetadata();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/MiscAnnotationBindingTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/MiscAnnotationBindingTest.java
index c99f767194..71ba4f96f6 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/MiscAnnotationBindingTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/MiscAnnotationBindingTest.java
@@ -1,40 +1,40 @@
 package org.hibernate.metamodel.binding;
 
 import javax.persistence.Entity;
 import javax.persistence.Id;
 
 import org.junit.Test;
 
 import org.hibernate.annotations.Where;
 import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.binder.source.internal.MetadataImpl;
+import org.hibernate.metamodel.source.internal.MetadataImpl;
 import org.hibernate.service.ServiceRegistryBuilder;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static junit.framework.Assert.assertEquals;
 
 /**
  * @author Hardy Ferentschik
  */
 public class MiscAnnotationBindingTest extends BaseUnitTestCase {
 	@Test
 	public void testWhereFilter() {
 
 
 		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addAnnotatedClass( Foo.class );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 
 		EntityBinding binding = metadata.getEntityBinding( MiscAnnotationBindingTest.class.getName() + "$" + Foo.class.getSimpleName() );
 		assertEquals( "Wrong where filter", "1=1", binding.getWhereFilter() );
 	}
 
 	@Entity
 	@Where(clause = "1=1")
 	class Foo {
 		@Id
 		private long id;
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/TestAnnotationsBindingContextImpl.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/TestAnnotationsBindingContextImpl.java
index 5864344a7c..dcc2ba7946 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/TestAnnotationsBindingContextImpl.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/TestAnnotationsBindingContextImpl.java
@@ -1,141 +1,140 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations;
 
 import java.util.HashMap;
 import java.util.Map;
 
 import com.fasterxml.classmate.MemberResolver;
 import com.fasterxml.classmate.ResolvedType;
 import com.fasterxml.classmate.ResolvedTypeWithMembers;
 import com.fasterxml.classmate.TypeResolver;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 
 import org.hibernate.cfg.EJB3NamingStrategy;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.cfg.NotYetImplementedException;
 import org.hibernate.internal.util.Value;
-import org.hibernate.metamodel.binder.source.MappingDefaults;
-import org.hibernate.metamodel.binder.source.MetadataImplementor;
-import org.hibernate.metamodel.binder.source.annotations.AnnotationsBindingContext;
+import org.hibernate.metamodel.source.MappingDefaults;
+import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.metamodel.domain.Type;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 
 /**
  * @author Steve Ebersole
  */
 public class TestAnnotationsBindingContextImpl implements AnnotationsBindingContext {
 	private Index index;
 	private ServiceRegistry serviceRegistry;
 
 	private NamingStrategy namingStrategy = EJB3NamingStrategy.INSTANCE;
 
 	private final TypeResolver typeResolver = new TypeResolver();
 	private final Map<Class<?>, ResolvedType> resolvedTypeCache = new HashMap<Class<?>, ResolvedType>();
 
 	public TestAnnotationsBindingContextImpl(Index index, ServiceRegistry serviceRegistry) {
 		this.index = index;
 		this.serviceRegistry = serviceRegistry;
 	}
 
 	@Override
 	public Index getIndex() {
 		return index;
 	}
 
 	@Override
 	public ServiceRegistry getServiceRegistry() {
 		return serviceRegistry;
 	}
 
 	@Override
 	public NamingStrategy getNamingStrategy() {
 		return namingStrategy;
 	}
 
 	@Override
 	public MappingDefaults getMappingDefaults() {
 		throw new NotYetImplementedException();
 	}
 
 	@Override
 	public MetadataImplementor getMetadataImplementor() {
 		throw new NotYetImplementedException();
 	}
 
 	@Override
 	public <T> Class<T> locateClassByName(String name) {
 		return serviceRegistry.getService( ClassLoaderService.class ).classForName( name );
 	}
 
 	@Override
 	public Type makeJavaType(String className) {
 		throw new NotYetImplementedException();
 	}
 
 	@Override
 	public Value<Class<?>> makeClassReference(String className) {
 		throw new NotYetImplementedException();
 	}
 	@Override
 	public ClassInfo getClassInfo(String name) {
 		DotName dotName = DotName.createSimple( name );
 		return index.getClassByName( dotName );
 	}
 
 	@Override
 	public void resolveAllTypes(String className) {
 		// the resolved type for the top level class in the hierarchy
 		Class<?> clazz = locateClassByName( className );
 		ResolvedType resolvedType = typeResolver.resolve( clazz );
 		while ( resolvedType != null ) {
 			// todo - check whether there is already something in the map
 			resolvedTypeCache.put( clazz, resolvedType );
 			resolvedType = resolvedType.getParentClass();
 			if ( resolvedType != null ) {
 				clazz = resolvedType.getErasedType();
 			}
 		}
 	}
 
 	@Override
 	public ResolvedType getResolvedType(Class<?> clazz) {
 		return resolvedTypeCache.get( clazz );
 	}
 
 	@Override
 	public ResolvedTypeWithMembers resolveMemberTypes(ResolvedType type) {
 		// todo : is there a reason we create this resolver every time?
 		MemberResolver memberResolver = new MemberResolver( typeResolver );
 		return memberResolver.resolve( type, null, null );
 	}
 
 	@Override
 	public boolean isGloballyQuotedIdentifiers() {
 		return false;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/BaseAnnotationBindingTestCase.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/BaseAnnotationBindingTestCase.java
index c13ebf165f..82f16f8daf 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/BaseAnnotationBindingTestCase.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/BaseAnnotationBindingTestCase.java
@@ -1,76 +1,76 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.entity;
 
 import org.junit.After;
 
 import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.binder.source.internal.MetadataImpl;
+import org.hibernate.metamodel.source.internal.MetadataImpl;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.service.ServiceRegistryBuilder;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 /**
  * @author Hardy Ferentschik
  */
 public abstract class BaseAnnotationBindingTestCase extends BaseUnitTestCase {
 	protected MetadataSources sources;
 	protected MetadataImpl meta;
 
 	@After
 	public void tearDown() {
 		sources = null;
 		meta = null;
 	}
 
 	public void buildMetadataSources(String ormPath, Class<?>... classes) {
 		sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
 		if ( ormPath != null ) {
 			sources.addResource( ormPath );
 		}
 		for ( Class clazz : classes ) {
 			sources.addAnnotatedClass( clazz );
 		}
 	}
 
 	public void buildMetadataSources(Class<?>... classes) {
 		buildMetadataSources( null, classes );
 	}
 
 	public EntityBinding getEntityBinding(Class<?> clazz) {
 		if ( meta == null ) {
 			meta = (MetadataImpl) sources.buildMetadata();
 		}
 		return meta.getEntityBinding( clazz.getName() );
 	}
 
 	public EntityBinding getRootEntityBinding(Class<?> clazz) {
 		if ( meta == null ) {
 			meta = (MetadataImpl) sources.buildMetadata();
 		}
 		return meta.getRootEntityBinding( clazz.getName() );
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/TableNameTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/TableNameTest.java
index 875518f42a..b485639be7 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/TableNameTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/TableNameTest.java
@@ -1,218 +1,216 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.entity;
 
 import java.util.Iterator;
 import java.util.Set;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.Inheritance;
 import javax.persistence.Table;
 
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
-import org.hibernate.metamodel.binder.source.annotations.AnnotationsBindingContext;
-import org.hibernate.metamodel.binder.source.annotations.ConfiguredClassHierarchyBuilder;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClassHierarchy;
+import org.hibernate.metamodel.source.annotations.ConfiguredClassHierarchyBuilder;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
 import org.hibernate.metamodel.binding.InheritanceType;
 import org.hibernate.metamodel.source.annotations.TestAnnotationsBindingContextImpl;
 import org.hibernate.service.ServiceRegistryBuilder;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.service.internal.BasicServiceRegistryImpl;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertTrue;
 import static org.junit.Assert.assertFalse;
 
 /**
  * @author Hardy Ferentschik
  */
 public class TableNameTest extends BaseUnitTestCase {
 
 	private BasicServiceRegistryImpl serviceRegistry;
 	private ClassLoaderService service;
 
 	@Before
 	public void setUp() {
 		serviceRegistry = (BasicServiceRegistryImpl) new ServiceRegistryBuilder().buildServiceRegistry();
 		service = serviceRegistry.getService( ClassLoaderService.class );
 	}
 
 	@After
 	public void tearDown() {
 		serviceRegistry.destroy();
 	}
 
 	@Test
 	public void testSingleInheritanceDefaultTableName() {
 		@Entity
 		class A {
 			@Id
 			@GeneratedValue
 			private int id;
 		}
 
 		@Entity
 		class B extends A {
 		}
 
 		Index index = JandexHelper.indexForClass( service, A.class, B.class );
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = ConfiguredClassHierarchyBuilder.createEntityHierarchies(
 				new TestAnnotationsBindingContextImpl( index, serviceRegistry )
 		);
 		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
 
 		Iterator<EntityClass> iter = hierarchies.iterator().next().iterator();
 		EntityClass entityClass = iter.next();
 		ClassInfo info = entityClass.getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( A.class.getName() ), info.name() );
 		assertTrue( entityClass.hasOwnTable() );
 		Assert.assertEquals(
 				"wrong inheritance type", InheritanceType.SINGLE_TABLE, entityClass.getInheritanceType()
 		);
 		Assert.assertEquals(
 				"wrong table name", "A", entityClass.getClassNameForTable()
 		);
 
 		assertTrue( iter.hasNext() );
 		entityClass = iter.next();
 		info = entityClass.getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( B.class.getName() ), info.name() );
 		assertFalse( entityClass.hasOwnTable() );
 		Assert.assertEquals(
 				"wrong inheritance type", InheritanceType.SINGLE_TABLE, entityClass.getInheritanceType()
 		);
 		Assert.assertEquals(
 				"wrong table name", "A", entityClass.getClassNameForTable()
 		);
 
 		assertFalse( iter.hasNext() );
 	}
 
 	@Test
 	public void testTablePerClassDefaultTableName() {
 		@Entity
 		@Inheritance(strategy = javax.persistence.InheritanceType.TABLE_PER_CLASS)
 		class A {
 			@Id
 			@GeneratedValue
 			private int id;
 		}
 
 		@Entity
 		class B extends A {
 		}
 
 		Index index = JandexHelper.indexForClass( service, A.class, B.class );
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = ConfiguredClassHierarchyBuilder.createEntityHierarchies(
 				new TestAnnotationsBindingContextImpl( index, serviceRegistry )
 		);
 		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
 
 		Iterator<EntityClass> iter = hierarchies.iterator().next().iterator();
 		EntityClass entityClass = iter.next();
 		ClassInfo info = entityClass.getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( A.class.getName() ), info.name() );
 		assertTrue( entityClass.hasOwnTable() );
 		Assert.assertEquals(
 				"wrong inheritance type", InheritanceType.TABLE_PER_CLASS, entityClass.getInheritanceType()
 		);
 		Assert.assertEquals(
 				"wrong table name", "A", entityClass.getClassNameForTable()
 		);
 
 		assertTrue( iter.hasNext() );
 		entityClass = iter.next();
 		info = entityClass.getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( B.class.getName() ), info.name() );
 		assertTrue( entityClass.hasOwnTable() );
 		Assert.assertEquals(
 				"wrong inheritance type", InheritanceType.TABLE_PER_CLASS, entityClass.getInheritanceType()
 		);
 		Assert.assertEquals(
 				"wrong table name", "B", entityClass.getClassNameForTable()
 		);
 
 		assertFalse( iter.hasNext() );
 	}
 
 	@Test
 	public void testJoinedSubclassDefaultTableName() {
 		@Entity
 		@Inheritance(strategy = javax.persistence.InheritanceType.JOINED)
 		@Table(name = "FOO")
 		class A {
 			@Id
 			@GeneratedValue
 			private int id;
 		}
 
 		@Entity
 		class B extends A {
 		}
 
 		Index index = JandexHelper.indexForClass( service, B.class, A.class );
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = ConfiguredClassHierarchyBuilder.createEntityHierarchies(
 				new TestAnnotationsBindingContextImpl( index, serviceRegistry )
 		);
 		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
 
 		Iterator<EntityClass> iter = hierarchies.iterator().next().iterator();
 		EntityClass entityClass = iter.next();
 		ClassInfo info = entityClass.getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( A.class.getName() ), info.name() );
 		assertTrue( entityClass.hasOwnTable() );
 		Assert.assertEquals(
 				"wrong inheritance type", InheritanceType.JOINED, entityClass.getInheritanceType()
 		);
 		Assert.assertEquals(
 				"wrong table name", "A", entityClass.getClassNameForTable()
 		);
 
 		assertTrue( iter.hasNext() );
 		entityClass = iter.next();
 		info = entityClass.getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( B.class.getName() ), info.name() );
 		assertTrue( entityClass.hasOwnTable() );
 		Assert.assertEquals(
 				"wrong inheritance type", InheritanceType.JOINED, entityClass.getInheritanceType()
 		);
 		Assert.assertEquals(
 				"wrong table name", "B", entityClass.getClassNameForTable()
 		);
 
 		assertFalse( iter.hasNext() );
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinderTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinderTest.java
index f739fea717..ea1ed2fbc1 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinderTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinderTest.java
@@ -1,148 +1,147 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.global;
 
 import java.util.Iterator;
 
 import org.jboss.jandex.Index;
 
 import org.hibernate.MappingException;
 import org.hibernate.annotations.FetchMode;
 import org.hibernate.annotations.FetchProfile;
 import org.hibernate.annotations.FetchProfiles;
 import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
-import org.hibernate.metamodel.binder.source.annotations.global.FetchProfileBinder;
-import org.hibernate.metamodel.binder.source.internal.MetadataImpl;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.internal.MetadataImpl;
 import org.hibernate.service.ServiceRegistryBuilder;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.service.internal.BasicServiceRegistryImpl;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Hardy Ferentschik
  */
 public class FetchProfileBinderTest extends BaseUnitTestCase {
 
 	private BasicServiceRegistryImpl serviceRegistry;
 	private ClassLoaderService service;
 	private MetadataImpl meta;
 
 	@Before
 	public void setUp() {
 		serviceRegistry = (BasicServiceRegistryImpl) new ServiceRegistryBuilder().buildServiceRegistry();
 		service = serviceRegistry.getService( ClassLoaderService.class );
 		meta = (MetadataImpl) new MetadataSources( serviceRegistry ).buildMetadata();
 	}
 
 	@After
 	public void tearDown() {
 		serviceRegistry.destroy();
 	}
 
 	@Test
 	public void testSingleFetchProfile() {
 		@FetchProfile(name = "foo", fetchOverrides = {
 				@FetchProfile.FetchOverride(entity = Foo.class, association = "bar", mode = FetchMode.JOIN)
 		})
 		class Foo {
 		}
 		Index index = JandexHelper.indexForClass( service, Foo.class );
 
 		FetchProfileBinder.bind( meta, index );
 
 		Iterator<org.hibernate.metamodel.binding.FetchProfile> mappedFetchProfiles = meta.getFetchProfiles().iterator();
 		assertTrue( mappedFetchProfiles.hasNext() );
 		org.hibernate.metamodel.binding.FetchProfile profile = mappedFetchProfiles.next();
 		assertEquals( "Wrong fetch profile name", "foo", profile.getName() );
 		org.hibernate.metamodel.binding.FetchProfile.Fetch fetch = profile.getFetches().iterator().next();
 		assertEquals( "Wrong association name", "bar", fetch.getAssociation() );
 		assertEquals( "Wrong association type", Foo.class.getName(), fetch.getEntity() );
 	}
 
 	@Test
 	public void testFetchProfiles() {
 		Index index = JandexHelper.indexForClass( service, FooBar.class );
 		FetchProfileBinder.bind( meta, index );
 
 		Iterator<org.hibernate.metamodel.binding.FetchProfile> mappedFetchProfiles = meta.getFetchProfiles().iterator();
 		assertTrue( mappedFetchProfiles.hasNext() );
 		org.hibernate.metamodel.binding.FetchProfile profile = mappedFetchProfiles.next();
 		assertProfiles( profile );
 
 		assertTrue( mappedFetchProfiles.hasNext() );
 		profile = mappedFetchProfiles.next();
 		assertProfiles( profile );
 	}
 
 	private void assertProfiles(org.hibernate.metamodel.binding.FetchProfile profile) {
 		if ( profile.getName().equals( "foobar" ) ) {
 			org.hibernate.metamodel.binding.FetchProfile.Fetch fetch = profile.getFetches().iterator().next();
 			assertEquals( "Wrong association name", "foobar", fetch.getAssociation() );
 			assertEquals( "Wrong association type", FooBar.class.getName(), fetch.getEntity() );
 		}
 		else if ( profile.getName().equals( "fubar" ) ) {
 			org.hibernate.metamodel.binding.FetchProfile.Fetch fetch = profile.getFetches().iterator().next();
 			assertEquals( "Wrong association name", "fubar", fetch.getAssociation() );
 			assertEquals( "Wrong association type", FooBar.class.getName(), fetch.getEntity() );
 		}
 		else {
 			fail( "Wrong fetch name:" + profile.getName() );
 		}
 	}
 
 	@Test(expected = MappingException.class)
 	public void testNonJoinFetchThrowsException() {
 		@FetchProfile(name = "foo", fetchOverrides = {
 				@FetchProfile.FetchOverride(entity = Foo.class, association = "bar", mode = FetchMode.SELECT)
 		})
 		class Foo {
 		}
 		Index index = JandexHelper.indexForClass( service, Foo.class );
 
 		FetchProfileBinder.bind( meta, index );
 	}
 
 	@FetchProfiles( {
 			@FetchProfile(name = "foobar", fetchOverrides = {
 					@FetchProfile.FetchOverride(entity = FooBar.class, association = "foobar", mode = FetchMode.JOIN)
 			}),
 			@FetchProfile(name = "fubar", fetchOverrides = {
 					@FetchProfile.FetchOverride(entity = FooBar.class, association = "fubar", mode = FetchMode.JOIN)
 			})
 	})
 	class FooBar {
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/QueryBinderTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/QueryBinderTest.java
index 9256059831..c1cac6f3df 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/QueryBinderTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/QueryBinderTest.java
@@ -1,97 +1,97 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.global;
 
 import javax.persistence.NamedNativeQuery;
 
 import org.jboss.jandex.Index;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.cfg.NotYetImplementedException;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryReturn;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryRootReturn;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.source.annotations.util.JandexHelper;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
 import org.hibernate.metamodel.source.internal.MetadataImpl;
 import org.hibernate.service.ServiceRegistryBuilder;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.service.internal.BasicServiceRegistryImpl;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertTrue;
 
 /**
  * @author Hardy Ferentschik
  */
 public class QueryBinderTest extends BaseUnitTestCase {
 
 	private BasicServiceRegistryImpl serviceRegistry;
 	private ClassLoaderService service;
 	private MetadataImpl meta;
 
 	@Before
 	public void setUp() {
 		serviceRegistry = (BasicServiceRegistryImpl) new ServiceRegistryBuilder().buildServiceRegistry();
 		service = serviceRegistry.getService( ClassLoaderService.class );
 		meta = (MetadataImpl) new MetadataSources( serviceRegistry ).buildMetadata();
 	}
 
 	@After
 	public void tearDown() {
 		serviceRegistry.destroy();
 	}
 
 	@Test(expected = NotYetImplementedException.class)
 	public void testNoResultClass() {
 		@NamedNativeQuery(name = "fubar", query = "SELECT * FROM FOO")
 		class Foo {
 		}
 		Index index = JandexHelper.indexForClass( service, Foo.class );
 		QueryBinder.bind( meta, index );
 	}
 
 	@Test
 	public void testResultClass() {
 		@NamedNativeQuery(name = "fubar", query = "SELECT * FROM FOO", resultClass = Foo.class)
 		class Foo {
 		}
 		Index index = JandexHelper.indexForClass( service, Foo.class );
 		QueryBinder.bind( meta, index );
 
 		NamedSQLQueryDefinition namedQuery = meta.getNamedNativeQuery( "fubar" );
 		assertNotNull( namedQuery );
 		NativeSQLQueryReturn queryReturns[] = namedQuery.getQueryReturns();
 		assertTrue( "Wrong number of returns", queryReturns.length == 1 );
 		assertTrue( "Wrong query return type", queryReturns[0] instanceof NativeSQLQueryRootReturn );
 		NativeSQLQueryRootReturn rootReturn = (NativeSQLQueryRootReturn) queryReturns[0];
 		assertEquals( "Wrong result class", Foo.class.getName(), rootReturn.getReturnEntityName() );
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/BaseAnnotationIndexTestCase.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/BaseAnnotationIndexTestCase.java
index 4b11db1ff4..f48b097597 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/BaseAnnotationIndexTestCase.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/BaseAnnotationIndexTestCase.java
@@ -1,77 +1,77 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.util;
 
 import java.util.Set;
 
 import javax.persistence.AccessType;
 
 import org.jboss.jandex.Index;
 import org.junit.After;
 import org.junit.Before;
 
-import org.hibernate.metamodel.binder.source.annotations.ConfiguredClassHierarchyBuilder;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClassHierarchy;
+import org.hibernate.metamodel.source.annotations.ConfiguredClassHierarchyBuilder;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.annotations.entity.ConfiguredClassHierarchy;
 import org.hibernate.metamodel.source.annotations.TestAnnotationsBindingContextImpl;
 import org.hibernate.metamodel.source.annotations.entity.EmbeddableClass;
 import org.hibernate.metamodel.source.annotations.entity.EntityClass;
 import org.hibernate.service.ServiceRegistryBuilder;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.service.internal.BasicServiceRegistryImpl;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 /**
  * @author Hardy Ferentschik
  */
 public abstract class BaseAnnotationIndexTestCase extends BaseUnitTestCase {
 	private BasicServiceRegistryImpl serviceRegistry;
 
 	@Before
 	public void setUp() {
 		serviceRegistry = (BasicServiceRegistryImpl) new ServiceRegistryBuilder().buildServiceRegistry();
 	}
 
 	@After
 	public void tearDown() {
 		serviceRegistry.destroy();
 	}
 
 	public Set<ConfiguredClassHierarchy<EntityClass>> createEntityHierarchies(Class<?>... clazz) {
 		Index index = JandexHelper.indexForClass( serviceRegistry.getService( ClassLoaderService.class ), clazz );
 		TestAnnotationsBindingContextImpl context = new TestAnnotationsBindingContextImpl( index, serviceRegistry );
 		return ConfiguredClassHierarchyBuilder.createEntityHierarchies( context );
 	}
 
 	public ConfiguredClassHierarchy<EmbeddableClass> createEmbeddableHierarchy(AccessType accessType, Class<?>... configuredClasses) {
 		Index index = JandexHelper.indexForClass(
 				serviceRegistry.getService( ClassLoaderService.class ),
 				configuredClasses
 		);
 		TestAnnotationsBindingContextImpl context = new TestAnnotationsBindingContextImpl( index, serviceRegistry );
 		return ConfiguredClassHierarchyBuilder.createEmbeddableHierarchy( configuredClasses[0], accessType, context );
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/EntityHierarchyTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/EntityHierarchyTest.java
index 25b2229eb7..da208e172f 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/EntityHierarchyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/EntityHierarchyTest.java
@@ -1,327 +1,327 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.util;
 
 import java.util.Iterator;
 import java.util.Set;
 import javax.persistence.AccessType;
 import javax.persistence.Embeddable;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.Inheritance;
 import javax.persistence.MappedSuperclass;
 
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.junit.Test;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.AssertionFailure;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClassHierarchy;
+import org.hibernate.metamodel.source.annotations.entity.ConfiguredClassHierarchy;
 import org.hibernate.metamodel.binding.InheritanceType;
 import org.hibernate.metamodel.source.annotations.entity.EmbeddableClass;
 import org.hibernate.metamodel.source.annotations.entity.EntityClass;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertTrue;
 import static org.junit.Assert.assertFalse;
 
 /**
  * @author Hardy Ferentschik
  */
 public class EntityHierarchyTest extends BaseAnnotationIndexTestCase {
 
 	@Test
 	public void testSingleEntity() {
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies( Foo.class );
 		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
 
 		Iterator<EntityClass> iter = hierarchies.iterator().next().iterator();
 		ClassInfo info = iter.next().getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( Foo.class.getName() ), info.name() );
 		assertFalse( iter.hasNext() );
 	}
 
 	@Test
 	public void testSimpleInheritance() {
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies( B.class, A.class );
 		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
 
 		Iterator<EntityClass> iter = hierarchies.iterator().next().iterator();
 		ClassInfo info = iter.next().getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( A.class.getName() ), info.name() );
 		info = iter.next().getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( B.class.getName() ), info.name() );
 		assertFalse( iter.hasNext() );
 	}
 
 	@Test
 	public void testMultipleHierarchies() {
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies( B.class, Foo.class, A.class );
 		assertEquals( "There should be only one hierarchy", 2, hierarchies.size() );
 	}
 
 	@Test
 	public void testMappedSuperClass() {
 		@MappedSuperclass
 		class MappedSuperClass {
 			@Id
 			@GeneratedValue
 			private int id;
 		}
 
 		class UnmappedSubClass extends MappedSuperClass {
 			private String unmappedProperty;
 		}
 
 		@Entity
 		class MappedSubClass extends UnmappedSubClass {
 			private String mappedProperty;
 		}
 
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies(
 				MappedSubClass.class,
 				MappedSuperClass.class,
 				UnmappedSubClass.class
 		);
 		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
 
 		Iterator<EntityClass> iter = hierarchies.iterator().next().iterator();
 		ClassInfo info = iter.next().getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( MappedSuperClass.class.getName() ), info.name() );
 		info = iter.next().getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( UnmappedSubClass.class.getName() ), info.name() );
 		info = iter.next().getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( MappedSubClass.class.getName() ), info.name() );
 		assertFalse( iter.hasNext() );
 	}
 
 	@Test(expected = AnnotationException.class)
 	public void testEntityAndMappedSuperClassAnnotations() {
 		@Entity
 		@MappedSuperclass
 		class EntityAndMappedSuperClass {
 		}
 
 		createEntityHierarchies( EntityAndMappedSuperClass.class );
 	}
 
 	@Test(expected = AnnotationException.class)
 	public void testEntityAndEmbeddableAnnotations() {
 		@Entity
 		@Embeddable
 		class EntityAndEmbeddable {
 		}
 
 		createEntityHierarchies( EntityAndEmbeddable.class );
 	}
 
 	@Test(expected = AnnotationException.class)
 	public void testNoIdAnnotation() {
 
 		@Entity
 		class A {
 			String id;
 		}
 
 		@Entity
 		class B extends A {
 		}
 
 		createEntityHierarchies( B.class, A.class );
 	}
 
 	@Test
 	public void testDefaultFieldAccess() {
 		@Entity
 		class A {
 			@Id
 			String id;
 		}
 
 		@Entity
 		class B extends A {
 		}
 
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies( B.class, A.class );
 		assertTrue( hierarchies.size() == 1 );
 		ConfiguredClassHierarchy hierarchy = hierarchies.iterator().next();
 		assertEquals( "Wrong default access type", AccessType.FIELD, hierarchy.getDefaultAccessType() );
 	}
 
 	@Test
 	public void testDefaultPropertyAccess() {
 		@Entity
 		class A {
 			String id;
 
 			@Id
 			public String getId() {
 				return id;
 			}
 
 			public void setId(String id) {
 				this.id = id;
 			}
 		}
 
 		@Entity
 		class B extends A {
 		}
 
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies( B.class, A.class );
 		assertTrue( hierarchies.size() == 1 );
 		ConfiguredClassHierarchy hierarchy = hierarchies.iterator().next();
 		assertEquals( "Wrong default access type", AccessType.PROPERTY, hierarchy.getDefaultAccessType() );
 	}
 
 	@Test
 	public void testDefaultInheritanceStrategy() {
 		@Entity
 		class A {
 			@Id
 			String id;
 		}
 
 		@Entity
 		class B extends A {
 		}
 
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies( B.class, A.class );
 		assertTrue( hierarchies.size() == 1 );
 		ConfiguredClassHierarchy hierarchy = hierarchies.iterator().next();
 		assertEquals( "Wrong inheritance type", InheritanceType.SINGLE_TABLE, hierarchy.getInheritanceType() );
 	}
 
 
 	@Test
 	public void testExplicitInheritanceStrategy() {
 		@MappedSuperclass
 		class MappedSuperClass {
 
 		}
 
 		@Entity
 		@Inheritance(strategy = javax.persistence.InheritanceType.JOINED)
 		class A extends MappedSuperClass {
 			@Id
 			String id;
 		}
 
 		@Entity
 		class B extends A {
 		}
 
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies(
 				B.class,
 				MappedSuperClass.class,
 				A.class
 		);
 		assertTrue( hierarchies.size() == 1 );
 		ConfiguredClassHierarchy hierarchy = hierarchies.iterator().next();
 		assertEquals(
 				"Wrong inheritance type", InheritanceType.JOINED, hierarchy.getInheritanceType()
 		);
 	}
 
 	@Test(expected = AnnotationException.class)
 	public void testMultipleConflictingInheritanceDefinitions() {
 
 		@Entity
 		@Inheritance(strategy = javax.persistence.InheritanceType.JOINED)
 		class A {
 			String id;
 		}
 
 		@Entity
 		@Inheritance(strategy = javax.persistence.InheritanceType.TABLE_PER_CLASS)
 		class B extends A {
 		}
 
 		createEntityHierarchies( B.class, A.class );
 	}
 
 	@Test
 	public void testEmbeddableHierarchy() {
 		@Embeddable
 		class A {
 			String foo;
 		}
 
 		class B extends A {
 		}
 
 		@Embeddable
 		class C extends B {
 			String bar;
 		}
 
 		ConfiguredClassHierarchy<EmbeddableClass> hierarchy = createEmbeddableHierarchy(
 				AccessType.FIELD,
 				C.class,
 				A.class,
 				B.class
 		);
 		Iterator<EmbeddableClass> iter = hierarchy.iterator();
 		ClassInfo info = iter.next().getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( A.class.getName() ), info.name() );
 		info = iter.next().getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( B.class.getName() ), info.name() );
 		info = iter.next().getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( C.class.getName() ), info.name() );
 		assertFalse( iter.hasNext() );
 		assertNotNull( hierarchy );
 	}
 
 	@Test(expected = AssertionFailure.class)
 	public void testEmbeddableHierarchyWithNotAnnotatedEntity() {
 		class NonAnnotatedEmbeddable {
 		}
 
 		createEmbeddableHierarchy( AccessType.FIELD, NonAnnotatedEmbeddable.class );
 	}
 
 	@Entity
 	public class Foo {
 		@Id
 		@GeneratedValue
 		private int id;
 	}
 
 	@Entity
 	public class A {
 		@Id
 		@GeneratedValue
 		private int id;
 	}
 
 	@Entity
 	public class B extends A {
 		private String name;
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/GenericTypeDiscoveryTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/GenericTypeDiscoveryTest.java
index 49581b4bc3..ae59a5ea2c 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/GenericTypeDiscoveryTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/GenericTypeDiscoveryTest.java
@@ -1,266 +1,266 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.util;
 
 import java.util.Iterator;
 import java.util.Set;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.ManyToOne;
 import javax.persistence.MappedSuperclass;
 
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.junit.Test;
 
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClass;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClassHierarchy;
+import org.hibernate.metamodel.source.annotations.entity.ConfiguredClass;
+import org.hibernate.metamodel.source.annotations.entity.ConfiguredClassHierarchy;
 import org.hibernate.metamodel.source.annotations.attribute.MappedAttribute;
 import org.hibernate.metamodel.source.annotations.entity.EntityClass;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertTrue;
 
 /**
  * @author Hardy Ferentschik
  */
 public class GenericTypeDiscoveryTest extends BaseAnnotationIndexTestCase {
 
 	@Test
 	public void testGenericClassHierarchy() {
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies(
 				Paper.class,
 				Stuff.class,
 				Item.class,
 				PricedStuff.class
 		);
 		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
 
 		Iterator<EntityClass> iter = hierarchies.iterator().next().iterator();
 		ConfiguredClass configuredClass = iter.next();
 		ClassInfo info = configuredClass.getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( Stuff.class.getName() ), info.name() );
 		MappedAttribute property = configuredClass.getMappedAttribute( "value" );
 		assertEquals( Price.class.getName(), property.getType() );
 
 		assertTrue( iter.hasNext() );
 		configuredClass = iter.next();
 		info = configuredClass.getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( PricedStuff.class.getName() ), info.name() );
 		assertFalse(
 				"PricedStuff should not mapped properties", configuredClass.getSimpleAttributes().iterator().hasNext()
 		);
 
 		assertTrue( iter.hasNext() );
 		configuredClass = iter.next();
 		info = configuredClass.getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( Item.class.getName() ), info.name() );
 		// properties are alphabetically ordered!
 		property = configuredClass.getMappedAttribute( "owner" );
 		assertEquals( SomeGuy.class.getName(), property.getType() );
 		property = configuredClass.getMappedAttribute( "type" );
 		assertEquals( PaperType.class.getName(), property.getType() );
 
 		assertTrue( iter.hasNext() );
 		configuredClass = iter.next();
 		info = configuredClass.getClassInfo();
 		assertEquals( "wrong class", DotName.createSimple( Paper.class.getName() ), info.name() );
 		assertFalse( "Paper should not mapped properties", configuredClass.getSimpleAttributes().iterator().hasNext() );
 
 		assertFalse( iter.hasNext() );
 	}
 
 	@Test
 	public void testUnresolvedType() {
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies( UnresolvedType.class );
 		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
 	}
 
 	@MappedSuperclass
 	public class Stuff<Value> {
 		private Value value;
 
 		@ManyToOne
 		public Value getValue() {
 			return value;
 		}
 
 		public void setValue(Value value) {
 			this.value = value;
 		}
 	}
 
 	@MappedSuperclass
 	public class PricedStuff extends Stuff<Price> {
 	}
 
 	@MappedSuperclass
 	public class Item<Type, Owner> extends PricedStuff {
 		private Integer id;
 		private String name;
 		private Type type;
 		private Owner owner;
 
 		@Id
 		@GeneratedValue
 		public Integer getId() {
 			return id;
 		}
 
 		public void setId(Integer id) {
 			this.id = id;
 		}
 
 		public String getName() {
 			return name;
 		}
 
 		public void setName(String name) {
 			this.name = name;
 		}
 
 		@ManyToOne
 		public Type getType() {
 			return type;
 		}
 
 		public void setType(Type type) {
 			this.type = type;
 		}
 
 		@ManyToOne
 		public Owner getOwner() {
 			return owner;
 		}
 
 		public void setOwner(Owner owner) {
 			this.owner = owner;
 		}
 	}
 
 	@Entity
 	public class Paper extends Item<PaperType, SomeGuy> {
 	}
 
 	@Entity
 	public class PaperType {
 		private Integer id;
 		private String name;
 
 		@Id
 		@GeneratedValue
 		public Integer getId() {
 			return id;
 		}
 
 		public void setId(Integer id) {
 			this.id = id;
 		}
 
 		public String getName() {
 			return name;
 		}
 
 		public void setName(String name) {
 			this.name = name;
 		}
 
 	}
 
 	@Entity
 	public class Price {
 		private Integer id;
 		private Double amount;
 		private String currency;
 
 		@Id
 		@GeneratedValue
 		public Integer getId() {
 			return id;
 		}
 
 		public void setId(Integer id) {
 			this.id = id;
 		}
 
 		public Double getAmount() {
 			return amount;
 		}
 
 		public void setAmount(Double amount) {
 			this.amount = amount;
 		}
 
 		public String getCurrency() {
 			return currency;
 		}
 
 		public void setCurrency(String currency) {
 			this.currency = currency;
 		}
 	}
 
 	@Entity
 	public class SomeGuy {
 		private Integer id;
 
 		@Id
 		@GeneratedValue
 		public Integer getId() {
 			return id;
 		}
 
 		public void setId(Integer id) {
 			this.id = id;
 		}
 	}
 
 	@Entity
 	public class UnresolvedType<T> {
 
 		private Integer id;
 		private T state;
 
 		@Id
 		@GeneratedValue
 		public Integer getId() {
 			return id;
 		}
 
 		public void setId(Integer id) {
 			this.id = id;
 		}
 
 		//@Type(type = "org.hibernate.test.annotations.generics.StateType")
 		public T getState() {
 			return state;
 		}
 
 		public void setState(T state) {
 			this.state = state;
 		}
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/JandexHelperTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/JandexHelperTest.java
index 24dede1a19..5486b9dc90 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/JandexHelperTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/JandexHelperTest.java
@@ -1,224 +1,224 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.util;
 
 import java.util.List;
 import java.util.Map;
 import javax.persistence.AttributeOverride;
 import javax.persistence.Basic;
 import javax.persistence.Column;
 import javax.persistence.LockModeType;
 import javax.persistence.NamedQuery;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.annotations.NamedNativeQuery;
-import org.hibernate.metamodel.binder.source.annotations.HibernateDotNames;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
-import org.hibernate.metamodel.binder.source.annotations.JandexHelper;
+import org.hibernate.metamodel.source.annotations.HibernateDotNames;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JandexHelper;
 import org.hibernate.service.ServiceRegistryBuilder;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.service.internal.BasicServiceRegistryImpl;
 
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static junit.framework.Assert.assertTrue;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 
 /**
  * Tests for the helper class {@link JandexHelper}.
  *
  * @author Hardy Ferentschik
  */
 public class JandexHelperTest extends BaseUnitTestCase {
 	private BasicServiceRegistryImpl serviceRegistry;
 	private ClassLoaderService classLoaderService;
 
 	@Before
 	public void setUp() {
 		serviceRegistry = (BasicServiceRegistryImpl) new ServiceRegistryBuilder().buildServiceRegistry();
 		classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 	}
 
 	@After
 	public void tearDown() {
 		serviceRegistry.destroy();
 	}
 
 	@Test
 	public void testGetMemberAnnotations() {
 		class Foo {
 			@Column
 			@Basic
 			private String bar;
 			private String fubar;
 		}
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 
 		ClassInfo classInfo = index.getClassByName( DotName.createSimple( Foo.class.getName() ) );
 		Map<DotName, List<AnnotationInstance>> memberAnnotations = JandexHelper.getMemberAnnotations(
 				classInfo, "bar"
 		);
 		assertTrue(
 				"property bar should defines @Column annotation",
 				memberAnnotations.containsKey( DotName.createSimple( Column.class.getName() ) )
 		);
 		assertTrue(
 				"property bar should defines @Basic annotation",
 				memberAnnotations.containsKey( DotName.createSimple( Basic.class.getName() ) )
 		);
 
 		memberAnnotations = JandexHelper.getMemberAnnotations( classInfo, "fubar" );
 		assertTrue( "there should be no annotations in fubar", memberAnnotations.isEmpty() );
 	}
 
 	@Test
 	public void testGettingNestedAnnotation() {
 		@AttributeOverride(name = "foo", column = @Column(name = "FOO"))
 		class Foo {
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.ATTRIBUTE_OVERRIDE );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		// try to retrieve the name
 		String name = JandexHelper.getValue( annotationInstance, "name", String.class );
 		assertEquals( "Wrong nested annotation", "foo", name );
 
 		// try to retrieve the nested column annotation instance
 		AnnotationInstance columnAnnotationInstance = JandexHelper.getValue(
 				annotationInstance,
 				"column",
 				AnnotationInstance.class
 		);
 		assertNotNull( columnAnnotationInstance );
 		assertEquals(
 				"Wrong nested annotation",
 				"javax.persistence.Column",
 				columnAnnotationInstance.name().toString()
 		);
 	}
 
 	@Test(expected = AssertionFailure.class)
 	public void testTryingToRetrieveWrongType() {
 		@AttributeOverride(name = "foo", column = @Column(name = "FOO"))
 		class Foo {
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.ATTRIBUTE_OVERRIDE );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		JandexHelper.getValue( annotationInstance, "name", Float.class );
 	}
 
 	@Test
 	public void testRetrieveDefaultEnumElement() {
 		@NamedQuery(name = "foo", query = "fubar")
 		class Foo {
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.NAMED_QUERY );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		LockModeType lockMode = JandexHelper.getValueAsEnum( annotationInstance, "lockMode", LockModeType.class );
 		assertEquals( "Wrong lock mode", LockModeType.NONE, lockMode );
 	}
 
 	@Test
 	public void testRetrieveExplicitEnumElement() {
 		@NamedQuery(name = "foo", query = "bar", lockMode = LockModeType.OPTIMISTIC)
 		class Foo {
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.NAMED_QUERY );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		LockModeType lockMode = JandexHelper.getValueAsEnum( annotationInstance, "lockMode", LockModeType.class );
 		assertEquals( "Wrong lock mode", LockModeType.OPTIMISTIC, lockMode );
 	}
 
 	@Test
 	public void testRetrieveStringArray() {
 		class Foo {
 			@org.hibernate.annotations.Index(name = "index", columnNames = { "a", "b", "c" })
 			private String foo;
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( HibernateDotNames.INDEX );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		String[] columnNames = JandexHelper.getValue( annotationInstance, "columnNames", String[].class );
 		Assert.assertTrue( columnNames.length == 3 );
 	}
 
 	@Test(expected = AssertionFailure.class)
 	public void testRetrieveClassParameterAsClass() {
 		@NamedNativeQuery(name = "foo", query = "bar", resultClass = Foo.class)
 		class Foo {
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( HibernateDotNames.NAMED_NATIVE_QUERY );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		JandexHelper.getValue( annotationInstance, "resultClass", Class.class );
 	}
 
 	@Test
 	public void testRetrieveClassParameterAsString() {
 		@NamedNativeQuery(name = "foo", query = "bar", resultClass = Foo.class)
 		class Foo {
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( HibernateDotNames.NAMED_NATIVE_QUERY );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		String fqcn = JandexHelper.getValue( annotationInstance, "resultClass", String.class );
 		assertEquals( "Wrong class names", Foo.class.getName(), fqcn );
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/TypeDiscoveryTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/TypeDiscoveryTest.java
index 995d5a2ab7..34cfafc58f 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/TypeDiscoveryTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/TypeDiscoveryTest.java
@@ -1,76 +1,76 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.util;
 
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Set;
 import javax.persistence.Id;
 
 import org.junit.Test;
 
 import org.hibernate.annotations.Parameter;
 import org.hibernate.annotations.Type;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClass;
-import org.hibernate.metamodel.binder.source.annotations.entity.ConfiguredClassHierarchy;
+import org.hibernate.metamodel.source.annotations.entity.ConfiguredClass;
+import org.hibernate.metamodel.source.annotations.entity.ConfiguredClassHierarchy;
 import org.hibernate.metamodel.source.annotations.attribute.MappedAttribute;
 import org.hibernate.metamodel.source.annotations.entity.EntityClass;
 
 import static junit.framework.Assert.assertEquals;
 
 /**
  * @author Hardy Ferentschik
  */
 public class TypeDiscoveryTest extends BaseAnnotationIndexTestCase {
 
 	@Test
 	public void testImplicitAndExplicitType() {
 		Set<ConfiguredClassHierarchy<EntityClass>> hierarchies = createEntityHierarchies( Entity.class );
 		assertEquals( "There should be only one hierarchy", 1, hierarchies.size() );
 
 		Iterator<EntityClass> iter = hierarchies.iterator().next().iterator();
 		ConfiguredClass configuredClass = iter.next();
 
 		MappedAttribute property = configuredClass.getMappedAttribute( "id" );
 		assertEquals( "Unexpected property type", "int", property.getType() );
 
 		property = configuredClass.getMappedAttribute( "string" );
 		assertEquals( "Unexpected property type", String.class.getName(), property.getType() );
 
 		property = configuredClass.getMappedAttribute( "customString" );
 		assertEquals( "Unexpected property type", "my.custom.Type", property.getType() );
 
 		Map<String, String> typeParameters = property.getTypeParameters();
 		assertEquals( "There should be a type parameter", "bar", typeParameters.get( "foo" ) );
 	}
 
 	@javax.persistence.Entity
 	class Entity {
 		@Id
 		private int id;
 		private String string;
 		@Type(type = "my.custom.Type", parameters = { @Parameter(name = "foo", value = "bar") })
 		private String customString;
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/OrmXmlParserTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/OrmXmlParserTests.java
index aef0e32a01..3ec69c3e47 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/OrmXmlParserTests.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/OrmXmlParserTests.java
@@ -1,69 +1,69 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.xml;
 
 import org.junit.Test;
 
 import org.hibernate.metamodel.MetadataSources;
-import org.hibernate.metamodel.binder.MappingException;
-import org.hibernate.metamodel.binder.source.internal.MetadataImpl;
+import org.hibernate.metamodel.source.MappingException;
+import org.hibernate.metamodel.source.internal.MetadataImpl;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.service.ServiceRegistryBuilder;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static junit.framework.Assert.assertNotNull;
 
 /**
  * @author Hardy Ferentschik
  */
 public class OrmXmlParserTests extends BaseUnitTestCase {
 	@Test
 	public void testSimpleOrmVersion2() {
 		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addResource( "org/hibernate/metamodel/source/annotations/xml/orm-father.xml" );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 
 		EntityBinding binding = metadata.getEntityBinding( Father.class.getName() );
 		assertNotNull( binding );
 	}
 
 	@Test
 	public void testSimpleOrmVersion1() {
 		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addResource( "org/hibernate/metamodel/source/annotations/xml/orm-star.xml" );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 
 		EntityBinding binding = metadata.getEntityBinding( Star.class.getName() );
 		assertNotNull( binding );
 	}
 
 	@Test(expected = MappingException.class)
 	public void testInvalidOrmXmlThrowsException() {
 		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addResource( "org/hibernate/metamodel/source/annotations/xml/orm-invalid.xml" );
 		sources.buildMetadata();
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AbstractMockerTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMockerTest.java
similarity index 99%
rename from hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AbstractMockerTest.java
rename to hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMockerTest.java
index 528f9f9a45..745a50a705 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/AbstractMockerTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMockerTest.java
@@ -1,206 +1,206 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.List;
 import javax.xml.bind.JAXBException;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.jboss.jandex.Indexer;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.HibernateException;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntityMappings;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 import org.hibernate.testing.ServiceRegistryBuilder;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 /**
  * @author Strong Liu
  */
 public abstract class AbstractMockerTest {
 	private static final String ORM1_MAPPING_XSD = "org/hibernate/ejb/orm_1_0.xsd";
 	private static final String ORM2_MAPPING_XSD = "org/hibernate/ejb/orm_2_0.xsd";
 	private IndexBuilder indexBuilder;
 	private Index index;
 	private ServiceRegistry serviceRegistry;
 	protected String packagePrefix = getClass().getPackage().getName().replace( '.', '/' ) + '/';
 
 	protected IndexBuilder getIndexBuilder() {
 		if ( indexBuilder == null ) {
 			indexBuilder = new IndexBuilder( getIndex(), getServiceRegistry() );
 		}
 		return indexBuilder;
 
 	}
 
 	protected EntityMappingsMocker getEntityMappingsMocker(String... mappingFiles) {
 		ClassLoaderService classLoaderService = getServiceRegistry().getService( ClassLoaderService.class );
 		List<XMLEntityMappings> xmlEntityMappingsList = new ArrayList<XMLEntityMappings>();
 		for ( String fileName : mappingFiles ) {
 			XMLEntityMappings entityMappings;
 			try {
 				entityMappings = XmlHelper.unmarshallXml(
 						packagePrefix + fileName, ORM2_MAPPING_XSD, XMLEntityMappings.class, classLoaderService
 				).getRoot();
 			}
 			catch ( JAXBException orm2Exception ) {
 				// if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility
 				try {
 					entityMappings = XmlHelper.unmarshallXml(
 							packagePrefix + fileName, ORM1_MAPPING_XSD, XMLEntityMappings.class, classLoaderService
 					).getRoot();
 				}
 				catch ( JAXBException orm1Exception ) {
 					throw new AnnotationException( "Unable to parse xml configuration.", orm1Exception );
 				}
 			}
 			xmlEntityMappingsList.add( entityMappings );
 		}
 		return new EntityMappingsMocker( xmlEntityMappingsList, getIndex(), getServiceRegistry() );
 	}
 
 	protected Index getIndex() {
 		if ( index == null ) {
 			Indexer indexer = new Indexer();
 			for ( Class<?> clazz : getAnnotatedClasses() ) {
 				indexClass( indexer, clazz.getName().replace( '.', '/' ) + ".class" );
 			}
 
 			// add package-info from the configured packages
 			for ( String packageName : getAnnotatedPackages() ) {
 				indexClass( indexer, packageName.replace( '.', '/' ) + "/package-info.class" );
 			}
 			index = indexer.complete();
 		}
 		return index;
 
 	}
 
 	protected Index getMockedIndex(String ormFileName) {
 		EntityMappingsMocker mocker = getEntityMappingsMocker( ormFileName );
 		return mocker.mockNewIndex();
 	}
 
 	private void indexClass(Indexer indexer, String className) {
 		ClassLoaderService classLoaderService = getServiceRegistry().getService( ClassLoaderService.class );
 		InputStream stream = classLoaderService.locateResourceStream( className );
 		try {
 			indexer.index( stream );
 		}
 		catch ( IOException e ) {
 			throw new HibernateException( "Unable to open input stream for class " + className, e );
 		}
 	}
 
 	protected Class[] getAnnotatedClasses() {
 		return new Class[0];
 	}
 
 	protected String[] getAnnotatedPackages() {
 		return new String[0];
 	}
 
 	protected ServiceRegistry getServiceRegistry() {
 		if ( serviceRegistry == null ) {
 			serviceRegistry = ServiceRegistryBuilder.buildServiceRegistry();
 		}
 		return serviceRegistry;
 	}
 
 	protected void assertHasNoAnnotation(Index index, DotName className, DotName annName) {
 		List<AnnotationInstance> annotationInstanceList = getAnnotationInstances( index, className, annName );
 		if ( annotationInstanceList != null ) {
 			if ( !annotationInstanceList.isEmpty() ) {
 				fail( className + " has Annotation " + annName );
 			}
 		}
 	}
 	protected void assertHasAnnotation(Index index,  DotName annName) {
 		assertHasAnnotation( index, null, annName, 1 );
 	}
 	protected void assertHasAnnotation(Index index, DotName className, DotName annName) {
 		assertHasAnnotation( index, className, annName, 1 );
 	}
 
 	protected void assertHasAnnotation(Index index, DotName className, DotName annName, int size) {
 		List<AnnotationInstance> annotationInstanceList = getAnnotationInstances( index, className, annName );
 		if ( annotationInstanceList == null || annotationInstanceList.isEmpty() ) {
 			fail( "Expected annotation " + annName + " size is " + size + ", but no one can be found in Index" );
 		}
 		assertEquals(
 				"Expected annotation " + annName + " size is " + size + ", but it actually is " + annotationInstanceList
 						.size(), size, annotationInstanceList.size()
 		);
 	}
 
 	protected void assertStringAnnotationValue(String expected, AnnotationValue annotationValue) {
 		if ( annotationValue == null ) {
 			fail( "Annotation Value is null." );
 		}
 		assertEquals( expected, annotationValue.asString() );
 	}
 
 	protected void assertAnnotationValue(Index index, DotName className, DotName annName, AnnotationValueChecker checker) {
 		assertAnnotationValue( index, className, annName, 1, checker );
 	}
 
 	protected void assertAnnotationValue(Index index, DotName className, DotName annName, int size, AnnotationValueChecker checker) {
 		assertHasAnnotation( index, className, annName, size );
 		List<AnnotationInstance> annotationInstanceList = getAnnotationInstances( index,className,annName );
 		for ( AnnotationInstance annotationInstance : annotationInstanceList ) {
 			checker.check( annotationInstance );
 		}
 	}
 
 	private List<AnnotationInstance> getAnnotationInstances(Index index, DotName className, DotName annName) {
 		if ( className != null ) {
 			ClassInfo classInfo = index.getClassByName( className );
 			if ( classInfo == null ) {
 				fail( "Can't find " + className + " from Index" );
 			}
 			if ( classInfo.annotations() == null ) {
 				fail( classInfo + " doesn't have any annotations defined" );
 			}
 			return classInfo.annotations().get( annName );
 		}
 		else {
 			return index.getAnnotations( annName );
 		}
 	}
 
 	static interface AnnotationValueChecker {
 		void check(AnnotationInstance annotationInstance);
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/Author.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Author.java
similarity index 96%
rename from hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/Author.java
rename to hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Author.java
index 1237a50416..0a2868d18d 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/Author.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Author.java
@@ -1,73 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.List;
 import javax.persistence.CascadeType;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.OneToMany;
 import javax.persistence.SequenceGenerator;
 
 /**
  * @author Strong Liu
  */
 @Entity
 public class Author {
 	private Long id;
 	private String name;
 	private List<Book> books = new ArrayList<Book>();
 
 	@Id
 	@GeneratedValue(generator = "SEQ_GEN")
 	@SequenceGenerator(name = "SEQ_GEN", initialValue = 123)
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public void setName(String name) {
 		this.name = name;
 	}
 
 	@OneToMany(mappedBy = "author",cascade = CascadeType.MERGE)
 	public List<Book> getBooks() {
 		return books;
 	}
 
 	public void setBooks(List<Book> books) {
 		this.books = books;
 	}
 
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/BasicMockerTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/BasicMockerTest.java
similarity index 96%
rename from hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/BasicMockerTest.java
rename to hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/BasicMockerTest.java
index 84b89b0de2..dfeea93066 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/BasicMockerTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/BasicMockerTest.java
@@ -1,108 +1,108 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.junit.Test;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLAttributes;
 import org.hibernate.metamodel.source.annotation.xml.XMLEntity;
 import org.hibernate.metamodel.source.annotation.xml.XMLGeneratedValue;
 import org.hibernate.metamodel.source.annotation.xml.XMLId;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Strong Liu
  */
 public class BasicMockerTest extends AbstractMockerTest {
 	@Test
 	public void testEntity() {
 		XMLEntity entity = createEntity();
 		IndexBuilder indexBuilder = getIndexBuilder();
 		EntityMocker entityMocker = new EntityMocker( indexBuilder, entity, new EntityMappingsMocker.Default() );
 		entityMocker.preProcess();
 		entityMocker.process();
 
 		Index index = indexBuilder.build( new EntityMappingsMocker.Default() );
 		assertEquals( 1, index.getKnownClasses().size() );
 		DotName itemName = DotName.createSimple( Item.class.getName() );
 		assertHasAnnotation( index, itemName, JPADotNames.ENTITY );
 		assertHasAnnotation( index, itemName, JPADotNames.ID );
 		assertHasAnnotation( index, itemName, JPADotNames.GENERATED_VALUE );
 	}
 
 	@Test
 	public void testEntityWithEntityMappingsConfiguration() {
 		XMLEntity entity = new XMLEntity();
 		entity.setName( "Item" );
 		entity.setClazz( "Item" );
 		IndexBuilder indexBuilder = getIndexBuilder();
 		EntityMappingsMocker.Default defaults = new EntityMappingsMocker.Default();
 		defaults.setPackageName( getClass().getPackage().getName() );
 		defaults.setSchema( "HIBERNATE_SCHEMA" );
 		defaults.setCatalog( "HIBERNATE_CATALOG" );
 		EntityMocker entityMocker = new EntityMocker( indexBuilder, entity, defaults );
 		entityMocker.preProcess();
 		entityMocker.process();
 
 		Index index = indexBuilder.build( new EntityMappingsMocker.Default() );
 		assertEquals( 1, index.getKnownClasses().size() );
 		DotName itemName = DotName.createSimple( Item.class.getName() );
 		assertHasAnnotation( index, itemName, JPADotNames.ENTITY );
 		assertHasAnnotation( index, itemName, JPADotNames.TABLE );
 		assertAnnotationValue(
 				index, itemName, JPADotNames.TABLE, new AnnotationValueChecker() {
 					@Override
 					public void check(AnnotationInstance annotationInstance) {
 						AnnotationValue schemaValue = annotationInstance.value( "schema" );
 						AnnotationValue catalogValue = annotationInstance.value( "catalog" );
 						assertStringAnnotationValue( "HIBERNATE_SCHEMA", schemaValue );
 						assertStringAnnotationValue( "HIBERNATE_CATALOG", catalogValue );
 					}
 				}
 		);
 
 	}
 
 
 	private XMLEntity createEntity() {
 		XMLEntity entity = new XMLEntity();
 		entity.setName( "Item" );
 		entity.setClazz( Item.class.getName() );
 		XMLAttributes attributes = new XMLAttributes();
 		XMLId id = new XMLId();
 		id.setName( "id" );
 		id.setGeneratedValue( new XMLGeneratedValue() );
 		attributes.getId().add( id );
 		entity.setAttributes( attributes );
 		return entity;
 	}
 
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/Book.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Book.java
similarity index 97%
rename from hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/Book.java
rename to hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Book.java
index ecb6024f80..ccfebfa64e 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/Book.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Book.java
@@ -1,101 +1,101 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
 import javax.persistence.AttributeOverride;
 import javax.persistence.CascadeType;
 import javax.persistence.Column;
 import javax.persistence.ElementCollection;
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.Id;
 import javax.persistence.ManyToOne;
 import javax.persistence.TableGenerator;
 import javax.persistence.Temporal;
 import javax.persistence.TemporalType;
 import javax.persistence.Version;
 
 /**
  * @author Strong Liu
  */
 @Entity
 @TableGenerator(name = "TABLE_GEN", catalog = "ANNOTATION_CATALOG", schema = "ANNOTATION_SCHEMA")
 public class Book {
 	@Id
 	@GeneratedValue(generator = "TABLE_GEN")
 	private Long id;
 	@Temporal(TemporalType.TIMESTAMP)
 	private Date publishDate;
 	@ManyToOne(cascade = CascadeType.DETACH)
 	private Author author;
 	@ElementCollection
 	@AttributeOverride(name = "title", column = @Column(name = "TOC_TITLE"))
 	private List<Topic> topics = new ArrayList<Topic>();
 
 	public List<Topic> getTopics() {
 		return topics;
 	}
 
 	public void setTopics(List<Topic> topics) {
 		this.topics = topics;
 	}
 
 	@Version
 	private Long version;
 
 	public Author getAuthor() {
 		return author;
 	}
 
 	public void setAuthor(Author author) {
 		this.author = author;
 	}
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 
 	public Date getPublishDate() {
 		return publishDate;
 	}
 
 	public void setPublishDate(Date publishDate) {
 		this.publishDate = publishDate;
 	}
 
 	public Long getVersion() {
 		return version;
 	}
 
 	public void setVersion(Long version) {
 		this.version = version;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/DefaultConfigurationHelperTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/DefaultConfigurationHelperTest.java
similarity index 98%
rename from hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/DefaultConfigurationHelperTest.java
rename to hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/DefaultConfigurationHelperTest.java
index f936857cf5..223d545089 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/DefaultConfigurationHelperTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/DefaultConfigurationHelperTest.java
@@ -1,200 +1,200 @@
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import javax.persistence.CascadeType;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.ManyToOne;
 import javax.persistence.OneToMany;
 import javax.persistence.SecondaryTable;
 import javax.persistence.SecondaryTables;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.junit.Test;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLEntity;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Strong Liu
  */
 public class DefaultConfigurationHelperTest extends AbstractMockerTest {
 	@Test
 	public void applyNullDefaultToEntity() {
 		XMLEntity entity = new XMLEntity();
 		entity.setClazz( "Entity" );
 		DefaultConfigurationHelper.INSTANCE.applyDefaults( entity, null );
 		assertNull( entity.getTable() );
 		assertEquals( "Entity", entity.getClazz() );
 	}
 
 	@Test
 	public void applyDefaultToEntity() {
 		EntityMappingsMocker.Default defaults = new EntityMappingsMocker.Default();
 		defaults.setPackageName( "org.test" );
 		defaults.setSchema( "schema" );
 		defaults.setMetadataComplete( true );
 		XMLEntity entity = new XMLEntity();
 		entity.setClazz( "Entity" );
 		DefaultConfigurationHelper.INSTANCE.applyDefaults( entity, defaults );
 		assertNotNull( entity.getTable() );
 		assertNull( entity.getTable().getSchema() );
 		assertNull( entity.getTable().getCatalog() );
 		assertTrue( entity.isMetadataComplete() );
 		assertEquals( "org.test.Entity", entity.getClazz() );
 		DefaultConfigurationHelper.INSTANCE
 				.applyDefaults( new SchemaAware.TableSchemaAware( entity.getTable() ), defaults );
 		assertEquals( "schema", entity.getTable().getSchema() );
 		assertNull( entity.getTable().getCatalog() );
 	}
 
 	@Test
 	public void testDefaultCascadePersist() {
 		EntityMappingsMocker.Default defaults = new EntityMappingsMocker.Default();
 		defaults.setCascadePersist( true );
 		Index index = getIndex();
 		Map<DotName, List<AnnotationInstance>> annotations = new HashMap<DotName, List<AnnotationInstance>>();
 		annotations.putAll( index.getClassByName( DotName.createSimple( Parent.class.getName() ) ).annotations() );
 		assertEquals( 4, annotations.size() );
 		assertEquals( 1, annotations.get( JPADotNames.ENTITY ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.ID ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.ONE_TO_MANY ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.MANY_TO_ONE ).size() );
 
 		DefaultConfigurationHelper.INSTANCE.applyDefaults( annotations, defaults );
 
 		assertEquals( 4, annotations.size() );
 		assertEquals( 1, annotations.get( JPADotNames.ENTITY ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.ID ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.ONE_TO_MANY ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.MANY_TO_ONE ).size() );
 		AnnotationInstance oneToMany = annotations.get( JPADotNames.ONE_TO_MANY ).get( 0 );
 		String[] cascadeTypes = oneToMany.value( "cascade" ).asEnumArray();
 		assertArrayEquals( new String[] { "ALL", "DETACH", "PERSIST" }, cascadeTypes );
 		AnnotationInstance manyToOne = annotations.get( JPADotNames.MANY_TO_ONE ).get( 0 );
 		cascadeTypes = manyToOne.value( "cascade" ).asEnumArray();
 		assertArrayEquals( new String[] { "PERSIST" }, cascadeTypes );
 
 		annotations.clear();
 		annotations.putAll( index.getClassByName( DotName.createSimple( Child.class.getName() ) ).annotations() );
 		assertEquals( 3, annotations.size() );
 		assertEquals( 1, annotations.get( JPADotNames.ENTITY ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.ID ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.MANY_TO_ONE ).size() );
 
 		DefaultConfigurationHelper.INSTANCE.applyDefaults( annotations, defaults );
 
 		assertEquals( 3, annotations.size() );
 		assertEquals( 1, annotations.get( JPADotNames.ENTITY ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.ID ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.MANY_TO_ONE ).size() );
 
 		manyToOne = annotations.get( JPADotNames.MANY_TO_ONE ).get( 0 );
 		cascadeTypes = manyToOne.value( "cascade" ).asEnumArray();
 		assertArrayEquals( new String[] { "PERSIST", "ALL", "DETACH" }, cascadeTypes );
 	}
 
 	@Test
 	public void testDefaultSchemaToAnnotationInstance() {
 		EntityMappingsMocker.Default defaults = new EntityMappingsMocker.Default();
 		defaults.setSchema( "hib_schema" );
 		defaults.setCatalog( "hib_catalog" );
 		Index index = getIndex();
 		Map<DotName, List<AnnotationInstance>> annotations = new HashMap<DotName, List<AnnotationInstance>>();
 		annotations.putAll( index.getClassByName( DotName.createSimple( Parent.class.getName() ) ).annotations() );
 		assertEquals( 4, annotations.size() );
 		assertEquals( 1, annotations.get( JPADotNames.ENTITY ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.ID ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.ONE_TO_MANY ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.MANY_TO_ONE ).size() );
 		DefaultConfigurationHelper.INSTANCE.applyDefaults( annotations, defaults );
 		assertEquals( 5, annotations.size() );
 		assertEquals( 1, annotations.get( JPADotNames.ENTITY ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.ID ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.ONE_TO_MANY ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.MANY_TO_ONE ).size() );
 		assertEquals( 1, annotations.get( JPADotNames.TABLE ).size() );
 		AnnotationInstance table = annotations.get( JPADotNames.TABLE ).get( 0 );
 		assertEquals( "hib_schema", table.value( "schema" ).asString() );
 		assertEquals( "hib_catalog", table.value( "catalog" ).asString() );
 
 		annotations.clear();
 		annotations.putAll( index.getClassByName( DotName.createSimple( Name.class.getName() ) ).annotations() );
 		DefaultConfigurationHelper.INSTANCE.applyDefaults( annotations, defaults );
 		assertEquals( 1, annotations.size() );
 		assertEquals( 1, annotations.get( JPADotNames.SECONDARY_TABLES ).size() );
 		AnnotationInstance[] secondaryTables = annotations.get( JPADotNames.SECONDARY_TABLES )
 				.get( 0 )
 				.value()
 				.asNestedArray();
 		assertEquals( 2, secondaryTables.length );
 		AnnotationInstance secondaryTable = secondaryTables[0];
 		String name = secondaryTable.value( "name" ).asString();
 		if ( name.equals( "sec1" ) ) {
 			assertSt1( secondaryTable );
 			assertSt2( secondaryTables[1] );
 		}
 		else {
 			assertSt1( secondaryTables[1] );
 			assertSt2( secondaryTable );
 		}
 
 
 	}
 
 	private void assertSt1(AnnotationInstance secondaryTable) {
 		assertEquals( "hib_schema", secondaryTable.value( "schema" ).asString() );
 		assertEquals( "sec1_catalog", secondaryTable.value( "catalog" ).asString() );
 	}
 
 	private void assertSt2(AnnotationInstance secondaryTable) {
 		assertEquals( "sec2_schema", secondaryTable.value( "schema" ).asString() );
 		assertEquals( "hib_catalog", secondaryTable.value( "catalog" ).asString() );
 	}
 
 	@Override
 	protected Class[] getAnnotatedClasses() {
 		return new Class[] { Parent.class, Child.class, Name.class };
 	}
 
 	@SecondaryTables( {
 			@SecondaryTable(name = "sec1", catalog = "sec1_catalog"),
 			@SecondaryTable(name = "sec2", schema = "sec2_schema")
 	})
 	class Name {
 	}
 
 	@Entity
 	class Parent {
 		@Id
 		long id;
 		@OneToMany(cascade = { CascadeType.ALL, CascadeType.DETACH, CascadeType.PERSIST })
 		Set<Child> children = new HashSet<Child>();
 		@ManyToOne
 		Parent parent;
 
 
 	}
 
 	@Entity
 	class Child {
 		@Id
 		long id;
 		@ManyToOne(cascade = { CascadeType.ALL, CascadeType.DETACH })
 		Parent parent;
 
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EntityListenerTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityListenerTest.java
similarity index 91%
rename from hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EntityListenerTest.java
rename to hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityListenerTest.java
index 6f1ee777b0..392e5430ff 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/EntityListenerTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/EntityListenerTest.java
@@ -1,62 +1,62 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.junit.Test;
 
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
-import org.hibernate.metamodel.binder.source.annotations.xml.PseudoJpaDotNames;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.xml.PseudoJpaDotNames;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Strong Liu
  */
 public class EntityListenerTest extends AbstractMockerTest {
 	@Test
 	public void basicEntityListenerMockTest() {
 		Index index = getMockedIndex( "listener.xml" );
 		DotName itemName = DotName.createSimple( Item.class.getName() );
 		DotName itemListenerName = DotName.createSimple( ItemListener.class.getName() );
 		ClassInfo itemClassInfo = index.getClassByName( itemName );
 		assertEquals( 2, itemClassInfo.annotations().size() );
 		//entity
 		assertHasAnnotation( index, itemName, JPADotNames.ENTITY );
 		assertHasAnnotation( index, itemName, JPADotNames.ENTITY_LISTENERS );
 		//listener
 		assertHasAnnotation( index, itemListenerName, JPADotNames.PRE_PERSIST );
 		assertHasAnnotation( index, itemListenerName, JPADotNames.POST_PERSIST );
 		//assert global configurations
 		assertHasAnnotation( index, PseudoJpaDotNames.DEFAULT_DELIMITED_IDENTIFIERS );
 		assertHasAnnotation( index, PseudoJpaDotNames.DEFAULT_ACCESS );
 		assertHasAnnotation( index, PseudoJpaDotNames.DEFAULT_ENTITY_LISTENERS );
 		assertHasAnnotation( index, PseudoJpaDotNames.DEFAULT_PRE_PERSIST );
 		assertHasAnnotation( index, PseudoJpaDotNames.DEFAULT_POST_PERSIST );
 
 
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/IndexBuilderTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilderTest.java
similarity index 73%
rename from hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/IndexBuilderTest.java
rename to hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilderTest.java
index e539d3222d..52d1189241 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/IndexBuilderTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilderTest.java
@@ -1,13 +1,13 @@
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import org.junit.Test;
 
 /**
  * @author Strong Liu
  */
 public class IndexBuilderTest extends AbstractMockerTest {
 	@Test
 	public void test() {
 		IndexBuilder builder = getIndexBuilder();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/Item.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Item.java
similarity index 94%
rename from hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/Item.java
rename to hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Item.java
index cd4a40a19c..fa5be30fc4 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/Item.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Item.java
@@ -1,39 +1,39 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 /**
  * @author Strong Liu
  */
 public class Item {
 	private Long id;
 
 	public Long getId() {
 		return id;
 	}
 
 	public void setId(Long id) {
 		this.id = id;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ItemListener.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/ItemListener.java
similarity index 94%
rename from hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ItemListener.java
rename to hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/ItemListener.java
index 93ea7eead8..dc1852b0b6 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/ItemListener.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/ItemListener.java
@@ -1,32 +1,32 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 /**
  * @author Strong Liu
  */
 public class ItemListener {
 	public void prePersist(){}
 	public void postPersist(){}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/OverrideTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/OverrideTest.java
similarity index 98%
rename from hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/OverrideTest.java
rename to hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/OverrideTest.java
index f718ff6229..b1729dffb7 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/OverrideTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/OverrideTest.java
@@ -1,252 +1,252 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.List;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.junit.Test;
 
 import org.hibernate.metamodel.source.annotation.xml.XMLEntity;
-import org.hibernate.metamodel.binder.source.annotations.JPADotNames;
+import org.hibernate.metamodel.source.annotations.JPADotNames;
 
 import static org.junit.Assert.assertArrayEquals;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
 /**
  * @author Strong Liu
  */
 public class OverrideTest extends AbstractMockerTest {
 	@Override
 	protected Class[] getAnnotatedClasses() {
 		return new Class[] {
 				Author.class,
 				Book.class,
 				Topic.class
 		};
 	}
 
 	@Test
 	public void testPersistenceUnitMetadataMetadataComplete() {
 		XMLEntity author = new XMLEntity();
 		author.setClazz( Author.class.getName() );
 		IndexBuilder indexBuilder = getIndexBuilder();
 		EntityMappingsMocker.Default defaults = new EntityMappingsMocker.Default();
 		defaults.setMetadataComplete( true );
 		EntityMocker entityMocker = new EntityMocker( indexBuilder, author, defaults );
 		entityMocker.preProcess();
 		entityMocker.process();
 		Index index = indexBuilder.build( new EntityMappingsMocker.Default() );
 		DotName className = DotName.createSimple( Author.class.getName() );
 		ClassInfo classInfo = index.getClassByName( className );
 		assertEquals( 1, classInfo.annotations().size() );
 		assertHasAnnotation( index, className, JPADotNames.ENTITY );
 	}
 
 	@Test
 	public void testEntityMetadataComplete() {
 		Index index = getMockedIndex( "entity-metadata-complete.xml" );
 		DotName authorName = DotName.createSimple( Author.class.getName() );
 		ClassInfo authorClassInfo = index.getClassByName( authorName );
 		assertHasAnnotation( index, authorName, JPADotNames.ENTITY );
 		assertHasAnnotation( index, authorName, JPADotNames.ID_CLASS );
 		assertEquals( 2, authorClassInfo.annotations().size() );
 		DotName bookName = DotName.createSimple( Book.class.getName() );
 		assertHasAnnotation( index, bookName, JPADotNames.ENTITY );
 	}
 
 	@Test
 	public void testOverrideToMappedSuperClass() {
 		Index index = getMockedIndex( "override-to-mappedsuperclass.xml" );
 		index.printAnnotations();
 		DotName authorName = DotName.createSimple( Author.class.getName() );
 		assertHasAnnotation( index, authorName, JPADotNames.ENTITY );
 		assertHasNoAnnotation( index, authorName, JPADotNames.TABLE );
 		DotName bookName = DotName.createSimple( Book.class.getName() );
 		assertHasAnnotation( index, bookName, JPADotNames.MAPPED_SUPERCLASS );
 		assertHasNoAnnotation( index, bookName, JPADotNames.TABLE );
 
 	}
 
 	@Test
 	public void testPersistenceUnitDefaultsCascadePersistInAnnotation() {
 		XMLEntity author = new XMLEntity();
 		author.setClazz( Author.class.getName() );
 		IndexBuilder indexBuilder = getIndexBuilder();
 		EntityMappingsMocker.Default defaults = new EntityMappingsMocker.Default();
 		defaults.setCascadePersist( true );
 		EntityMocker entityMocker = new EntityMocker( indexBuilder, author, defaults );
 		entityMocker.preProcess();
 		entityMocker.process();
 		Index index = indexBuilder.build( new EntityMappingsMocker.Default() );
 		DotName className = DotName.createSimple( Author.class.getName() );
 		assertAnnotationValue(
 				index, className, JPADotNames.ONE_TO_MANY, new CascadeAnnotationValueChecker( "PERSIST", "MERGE" )
 		);
 	}
 
 
 	@Test
 	public void testPersistenceUnitDefaultsCascadePersistInXML() {
 		Index index = getMockedIndex( "AttributeOverride.xml" );
 		DotName className = DotName.createSimple( Author.class.getName() );
 		assertAnnotationValue(
 				index,
 				className,
 				JPADotNames.ONE_TO_MANY,
 				new CascadeAnnotationValueChecker( new String[] { "PERSIST", "ALL" } )
 		);
 	}
 
 	protected class CascadeAnnotationValueChecker implements AnnotationValueChecker {
 		private String[] expected = new String[0];
 
 		public CascadeAnnotationValueChecker(String... expected) {
 			this.expected = expected;
 		}
 
 		@Override
 		public void check(AnnotationInstance annotationInstance) {
 			AnnotationValue cascadeValue = annotationInstance.value( "cascade" );
 			assertNotNull(
 					"Cascade is null in @OneToMany, but should be added a Cascade persist", cascadeValue
 			);
 			String[] enumArray = cascadeValue.asEnumArray();
 			assertEquals( expected.length, enumArray.length );
 			assertArrayEquals( expected, enumArray );
 		}
 	}
 
 	/**
 	 * Entity has a @AttributeOverride on property topic
 	 * and this property also has a <attribute-override> in orm.xml but with different name
 	 * by jpa override rules, this two attribute-override should be merged into one @AttributeOverrides
 	 */
 	@Test
 	public void testAttributeOverride() {
 		Index index = getMockedIndex( "AttributeOverride.xml" );
 		DotName className = DotName.createSimple( Book.class.getName() );
 		index.printAnnotations();
 		assertHasNoAnnotation(
 				index,
 				className,
 				JPADotNames.ATTRIBUTE_OVERRIDE
 		);
 		assertAnnotationValue(
 				index,
 				className,
 				JPADotNames.ATTRIBUTE_OVERRIDES, new AnnotationValueChecker() {
 					@Override
 					public void check(AnnotationInstance annotationInstance) {
 						AnnotationValue value = annotationInstance.value();
 						assertNotNull( value );
 						AnnotationInstance[] annotationInstances = value.asNestedArray();
 						assertEquals( 2, annotationInstances.length );
 						AnnotationInstance ai = annotationInstances[0];
 						String name = ai.value( "name" ).asString();
 						AnnotationValue columnValue = ai.value( "column" ).asNested().value( "name" );
 						if ( name.equals( "title" ) ) {
 							assertEquals( "TOC_TITLE", columnValue.asString() );
 
 						}
 						else if ( name.equals( "summary" ) ) {
 							assertEquals( "TOPIC_SUMMARY", columnValue.asString() );
 						}
 						else {
 							fail( "AttributeOverride's name is " + name + ", should be either 'title' or 'summary'" );
 						}
 					}
 				}
 		);
 	}
 
 	@Test
 	public void testSchemaInPersistenceMetadata() {
 		Index index = getMockedIndex( "default-schema.xml" );
 		index.printAnnotations();
 		//Global Configuration should be accessed like this, not from ClassInfo
 		List<AnnotationInstance> annotationInstanceList = index.getAnnotations( JPADotNames.TABLE_GENERATOR );
 		assertNotNull( annotationInstanceList );
 		assertEquals( 1, annotationInstanceList.size() );
 		AnnotationInstance generator = annotationInstanceList.get( 0 );
 		assertEquals( "TABLE_GEN", generator.value( "name" ).asString() );
 		assertEquals( "ANNOTATION_CATALOG", generator.value( "catalog" ).asString() );
 		assertEquals( "ANNOTATION_SCHEMA", generator.value( "schema" ).asString() );
 
 		annotationInstanceList = index.getAnnotations( JPADotNames.SEQUENCE_GENERATOR );
 		assertNotNull( annotationInstanceList );
 		assertEquals( 1, annotationInstanceList.size() );
 		generator = annotationInstanceList.get( 0 );
 		assertEquals( "SEQ_GEN", generator.value( "name" ).asString() );
 		assertEquals( "XML_CATALOG", generator.value( "catalog" ).asString() );
 		assertEquals( "XML_SCHEMA", generator.value( "schema" ).asString() );
 		assertEquals( 123, generator.value( "initialValue" ).asInt() );
 		//Book and Author and Topic are all not defined @Table
 		//but orm xml defines default schema and catalog in persistence-unit-metadata
 		//so, we have to mock @Table for entities, Book and Author but not Topic which is a Embeddable
 		annotationInstanceList = index.getAnnotations( JPADotNames.TABLE );
 		assertNotNull( annotationInstanceList );
 		assertEquals( 2, annotationInstanceList.size() );
 		for ( AnnotationInstance table : annotationInstanceList ) {
 			assertEquals( "XML_CATALOG", table.value( "catalog" ).asString() );
 			assertEquals( "XML_SCHEMA", table.value( "schema" ).asString() );
 		}
 
 	}
 
 	@Test
 	public void testSchemaInEntityMapping() {
 		Index index = getMockedIndex( "default-schema2.xml" );
 		index.printAnnotations();
 		//Global Configuration should be accessed like this, not from ClassInfo
 		List<AnnotationInstance> annotationInstanceList = index.getAnnotations( JPADotNames.TABLE_GENERATOR );
 		assertNotNull( annotationInstanceList );
 		assertEquals( 1, annotationInstanceList.size() );
 		AnnotationInstance generator = annotationInstanceList.get( 0 );
 		assertEquals( "TABLE_GEN", generator.value( "name" ).asString() );
 		assertEquals( "ANNOTATION_CATALOG", generator.value( "catalog" ).asString() );
 		assertEquals( "ANNOTATION_SCHEMA", generator.value( "schema" ).asString() );
 
 		annotationInstanceList = index.getAnnotations( JPADotNames.SEQUENCE_GENERATOR );
 		assertNotNull( annotationInstanceList );
 		assertEquals( 1, annotationInstanceList.size() );
 		generator = annotationInstanceList.get( 0 );
 		assertEquals( "SEQ_GEN", generator.value( "name" ).asString() );
 		assertNull( generator.value( "catalog" ) );
 		assertNull( generator.value( "schema" ) );
 		assertEquals( 123, generator.value( "initialValue" ).asInt() );
 
 		annotationInstanceList = index.getAnnotations( JPADotNames.TABLE );
 		assertNotNull( annotationInstanceList );
 		assertEquals( 0, annotationInstanceList.size() );
 
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/PersistenceMetadataMockerTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/PersistenceMetadataMockerTest.java
similarity index 92%
rename from hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/PersistenceMetadataMockerTest.java
rename to hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/PersistenceMetadataMockerTest.java
index b93cfbdd2a..26b966f801 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/PersistenceMetadataMockerTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/PersistenceMetadataMockerTest.java
@@ -1,50 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import javax.persistence.AccessType;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.Index;
 import org.junit.Test;
 import static org.junit.Assert.*;
 
-import org.hibernate.metamodel.binder.source.annotations.xml.PseudoJpaDotNames;
+import org.hibernate.metamodel.source.annotations.xml.PseudoJpaDotNames;
 
 /**
  * @author Strong Liu
  */
 public class PersistenceMetadataMockerTest extends AbstractMockerTest {
 	@Test
 	public void testPersistenceMetadata() {
 		Index index = getMockedIndex( "persistence-metadata.xml" );
 		assertHasAnnotation( index, null, PseudoJpaDotNames.DEFAULT_ACCESS, 1 );
 		assertAnnotationValue(index,null, PseudoJpaDotNames.DEFAULT_ACCESS,new AnnotationValueChecker(){
 			@Override
 			public void check(AnnotationInstance annotationInstance) {
 			assertEquals( AccessType.FIELD.toString(), annotationInstance.value().asEnum());
 			}
 		});
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/Topic.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Topic.java
similarity index 95%
rename from hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/Topic.java
rename to hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Topic.java
index 94daf79c1b..cf74904525 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/Topic.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/Topic.java
@@ -1,60 +1,60 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import javax.persistence.Embeddable;
 
 /**
  * @author Strong Liu
  */
 @Embeddable
 public class Topic {
 	private String title;
 	private String summary;
 	private int position;
 
 	public int getPosition() {
 		return position;
 	}
 
 	public void setPosition(int position) {
 		this.position = position;
 	}
 
 	public String getSummary() {
 		return summary;
 	}
 
 	public void setSummary(String summary) {
 		this.summary = summary;
 	}
 
 	public String getTitle() {
 		return title;
 	}
 
 	public void setTitle(String title) {
 		this.title = title;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/XmlHelper.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/XmlHelper.java
similarity index 94%
rename from hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/XmlHelper.java
rename to hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/XmlHelper.java
index 753a9e6436..a6f0115d8a 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binder/source/annotations/xml/mocker/XmlHelper.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/XmlHelper.java
@@ -1,79 +1,79 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.metamodel.binder.source.annotations.xml.mocker;
+package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.io.InputStream;
 import java.net.URL;
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBElement;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Unmarshaller;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 
 import org.hibernate.internal.CoreMessageLogger;
 import org.jboss.logging.Logger;
 import org.xml.sax.SAXException;
 
-import org.hibernate.metamodel.binder.Origin;
-import org.hibernate.metamodel.binder.source.internal.JaxbRoot;
+import org.hibernate.metamodel.source.Origin;
+import org.hibernate.metamodel.source.internal.JaxbRoot;
 import org.hibernate.service.classloading.spi.ClassLoaderService;
 
 /**
  * @author Hardy Ferentschik
  */
 public class XmlHelper {
     private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, XmlHelper.class.getName() );
 
     private XmlHelper() {
     }
 
     public static <T> JaxbRoot<T> unmarshallXml(String fileName, String schemaName, Class<T> clazz, ClassLoaderService classLoaderService)
             throws JAXBException {
         Schema schema = getMappingSchema( schemaName, classLoaderService );
         InputStream in = classLoaderService.locateResourceStream( fileName );
         JAXBContext jc = JAXBContext.newInstance( clazz );
         Unmarshaller unmarshaller = jc.createUnmarshaller();
         unmarshaller.setSchema( schema );
         StreamSource stream = new StreamSource( in );
         JAXBElement<T> elem = unmarshaller.unmarshal( stream, clazz );
         Origin origin = new Origin( null, fileName );
         return new JaxbRoot<T>( elem.getValue(), origin );
     }
 
     private static Schema getMappingSchema(String schemaVersion, ClassLoaderService classLoaderService) {
         URL schemaUrl = classLoaderService.locateResource( schemaVersion );
         SchemaFactory sf = SchemaFactory.newInstance( javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI );
         Schema schema = null;
         try {
             schema = sf.newSchema( schemaUrl );
         }
         catch ( SAXException e ) {
             LOG.debugf( "Unable to create schema for %s: %s", schemaVersion, e.getMessage() );
         }
         return schema;
     }
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/MetadataImplTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/MetadataImplTest.java
index 0ff4808c7c..79326d60c9 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/MetadataImplTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/MetadataImplTest.java
@@ -1,113 +1,111 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.internal;
 
 import java.util.Iterator;
 
 import org.junit.Test;
 
 import org.hibernate.HibernateException;
 import org.hibernate.SessionFactory;
 import org.hibernate.metamodel.Metadata;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.SessionFactoryBuilder;
-import org.hibernate.metamodel.binder.source.internal.MetadataImpl;
-import org.hibernate.metamodel.binder.source.internal.SessionFactoryBuilderImpl;
 import org.hibernate.metamodel.binding.FetchProfile;
 import org.hibernate.service.ServiceRegistryBuilder;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertSame;
 import static junit.framework.Assert.assertTrue;
 
 /**
  * @author Hardy Ferentschik
  */
 public class MetadataImplTest extends BaseUnitTestCase {
 
 	@Test(expected = IllegalArgumentException.class)
 	public void testAddingNullClass() {
 		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addClass( null );
 		sources.buildMetadata();
 	}
 
 	@Test(expected = IllegalArgumentException.class)
 	public void testAddingNullPackageName() {
 		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addPackage( null );
 		sources.buildMetadata();
 	}
 
 	@Test(expected = HibernateException.class)
 	public void testAddingNonExistingPackageName() {
 		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addPackage( "not.a.package" );
 		sources.buildMetadata();
 	}
 
 	@Test
 	public void testAddingPackageName() {
 		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addPackage( "org.hibernate.metamodel.source.internal" );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 
 		assertFetchProfile( metadata );
 	}
 
 	@Test
 	public void testAddingPackageNameWithTrailingDot() {
 		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addPackage( "org.hibernate.metamodel.source.internal." );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 
 		assertFetchProfile( metadata );
 	}
 
 	@Test
 	public void testGettingSessionFactoryBuilder() {
 		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
 		Metadata metadata = sources.buildMetadata();
 
 		SessionFactoryBuilder sessionFactoryBuilder = metadata.getSessionFactoryBuilder();
 		assertNotNull( sessionFactoryBuilder );
 		assertTrue( SessionFactoryBuilderImpl.class.isInstance( sessionFactoryBuilder ) );
 
 		SessionFactory sessionFactory = metadata.buildSessionFactory();
 		assertNotNull( sessionFactory );
 	}
 
 	private void assertFetchProfile(MetadataImpl metadata) {
 		Iterator<FetchProfile> profiles = metadata.getFetchProfiles().iterator();
 		assertTrue( profiles.hasNext() );
 		FetchProfile profile = profiles.next();
 		assertEquals( "wrong profile name", "package-configured-profile", profile.getName() );
 		assertFalse( profiles.hasNext() );
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImplTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImplTest.java
index 18a156e36b..75c5ec0ef1 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImplTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImplTest.java
@@ -1,197 +1,195 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.internal;
 
 import java.io.Serializable;
 import java.util.Iterator;
 
 import org.junit.Test;
 
 import org.hibernate.CallbackException;
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.EntityMode;
 import org.hibernate.Interceptor;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.SessionFactory;
 import org.hibernate.Transaction;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.SessionFactoryBuilder;
-import org.hibernate.metamodel.binder.source.internal.MetadataImpl;
-import org.hibernate.metamodel.binder.source.internal.SessionFactoryBuilderImpl;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.service.ServiceRegistryBuilder;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 import org.hibernate.type.Type;
 
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertSame;
 import static junit.framework.Assert.assertTrue;
 
 /**
  * @author Gail Badner
  */
 public class SessionFactoryBuilderImplTest extends BaseUnitTestCase {
 
 	@Test
 	public void testGettingSessionFactoryBuilder() {
 		SessionFactoryBuilder sessionFactoryBuilder = getSessionFactoryBuilder();
 		assertNotNull( sessionFactoryBuilder );
 		assertTrue( SessionFactoryBuilderImpl.class.isInstance( sessionFactoryBuilder ) );
 	}
 
 	@Test
 	public void testBuildSessionFactoryWithDefaultOptions() {
 		SessionFactoryBuilder sessionFactoryBuilder = getSessionFactoryBuilder();
 		SessionFactory sessionFactory = sessionFactoryBuilder.buildSessionFactory();
 		assertSame( EmptyInterceptor.INSTANCE, sessionFactory.getSessionFactoryOptions().getInterceptor() );
 		assertTrue( EntityNotFoundDelegate.class.isInstance(
 				sessionFactory.getSessionFactoryOptions().getEntityNotFoundDelegate()
 		) );
 	}
 
 	@Test
 	public void testBuildSessionFactoryWithUpdatedOptions() {
 		SessionFactoryBuilder sessionFactoryBuilder = getSessionFactoryBuilder();
 		Interceptor interceptor = new AnInterceptor();
 		EntityNotFoundDelegate entityNotFoundDelegate = new EntityNotFoundDelegate() {
 			@Override
 			public void handleEntityNotFound(String entityName, Serializable id) {
 				throw new ObjectNotFoundException( id, entityName );
 			}
 		};
 		sessionFactoryBuilder.with( interceptor );
 		sessionFactoryBuilder.with( entityNotFoundDelegate );
 		SessionFactory sessionFactory = sessionFactoryBuilder.buildSessionFactory();
 		assertSame( interceptor, sessionFactory.getSessionFactoryOptions().getInterceptor() );
 		assertSame( entityNotFoundDelegate, sessionFactory.getSessionFactoryOptions().getEntityNotFoundDelegate() );
 	}
 
 	private SessionFactoryBuilder getSessionFactoryBuilder() {
 		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addAnnotatedClass( SimpleEntity.class );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 		return  metadata.getSessionFactoryBuilder();
 	}
 
 	private static class AnInterceptor implements Interceptor {
 		private static final Interceptor INSTANCE = EmptyInterceptor.INSTANCE;
 
 		@Override
 		public boolean onLoad(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)
 				throws CallbackException {
 			return INSTANCE.onLoad( entity, id, state, propertyNames, types );
 		}
 
 		@Override
 		public boolean onFlushDirty(Object entity, Serializable id, Object[] currentState, Object[] previousState, String[] propertyNames, Type[] types)
 				throws CallbackException {
 			return INSTANCE.onFlushDirty( entity, id, currentState, previousState, propertyNames, types );
 		}
 
 		@Override
 		public boolean onSave(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)
 				throws CallbackException {
 			return INSTANCE.onSave( entity, id, state, propertyNames, types );
 		}
 
 		@Override
 		public void onDelete(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)
 				throws CallbackException {
 			INSTANCE.onDelete( entity, id, state, propertyNames, types );
 		}
 
 		@Override
 		public void onCollectionRecreate(Object collection, Serializable key) throws CallbackException {
 			INSTANCE.onCollectionRecreate( collection, key );
 		}
 
 		@Override
 		public void onCollectionRemove(Object collection, Serializable key) throws CallbackException {
 			INSTANCE.onCollectionRemove( collection, key );
 		}
 
 		@Override
 		public void onCollectionUpdate(Object collection, Serializable key) throws CallbackException {
 			INSTANCE.onCollectionUpdate( collection, key );
 		}
 
 		@Override
 		public void preFlush(Iterator entities) throws CallbackException {
 			INSTANCE.preFlush( entities );
 		}
 
 		@Override
 		public void postFlush(Iterator entities) throws CallbackException {
 			INSTANCE.postFlush( entities );
 		}
 
 		@Override
 		public Boolean isTransient(Object entity) {
 			return INSTANCE.isTransient( entity );
 		}
 
 		@Override
 		public int[] findDirty(Object entity, Serializable id, Object[] currentState, Object[] previousState, String[] propertyNames, Type[] types) {
 			return INSTANCE.findDirty( entity, id, currentState, previousState, propertyNames, types );
 		}
 
 		@Override
 		public Object instantiate(String entityName, EntityMode entityMode, Serializable id)
 				throws CallbackException {
 			return INSTANCE.instantiate( entityName, entityMode, id );
 		}
 
 		@Override
 		public String getEntityName(Object object) throws CallbackException {
 			return INSTANCE.getEntityName( object );
 		}
 
 		@Override
 		public Object getEntity(String entityName, Serializable id) throws CallbackException {
 			return INSTANCE.getEntity( entityName, id );
 		}
 
 		@Override
 		public void afterTransactionBegin(Transaction tx) {
 			INSTANCE.afterTransactionBegin( tx );
 		}
 
 		@Override
 		public void beforeTransactionCompletion(Transaction tx) {
 			INSTANCE.beforeTransactionCompletion( tx );
 		}
 
 		@Override
 		public void afterTransactionCompletion(Transaction tx) {
 			INSTANCE.afterTransactionCompletion( tx );
 		}
 
 		@Override
 		public String onPrepareStatement(String sql) {
 			return INSTANCE.onPrepareStatement( sql );
 		}
 	}
 }
 
 
diff --git a/hibernate-core/src/test/resources/org/hibernate/metamodel/binder/source/annotations/xml/mocker/listener.xml b/hibernate-core/src/test/resources/org/hibernate/metamodel/binder/source/annotations/xml/mocker/listener.xml
index 97c4a81d11..8095ad48ca 100644
--- a/hibernate-core/src/test/resources/org/hibernate/metamodel/binder/source/annotations/xml/mocker/listener.xml
+++ b/hibernate-core/src/test/resources/org/hibernate/metamodel/binder/source/annotations/xml/mocker/listener.xml
@@ -1,27 +1,27 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
 <entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm"
 				 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 				 version="2.0">
 	<persistence-unit-metadata>
 		<persistence-unit-defaults>
 			<delimited-identifiers/>
 			<access>FIELD</access>
 			<entity-listeners>
-				<entity-listener class="org.hibernate.metamodel.binder.source.annotations.xml.mocker.ItemListener">
+				<entity-listener class="org.hibernate.metamodel.source.annotations.xml.mocker.ItemListener">
 					<pre-persist method-name="prePersist"/>
 					<post-persist method-name="postPersist"/>
 				</entity-listener>
 			</entity-listeners>
 		</persistence-unit-defaults>
 	</persistence-unit-metadata>
 	<package>org.hibernate.metamodel.binder.source.annotations.xml.mocker</package>
 	<entity class="Item">
 		<entity-listeners>
-			<entity-listener class="org.hibernate.metamodel.binder.source.annotations.xml.mocker.ItemListener">
+			<entity-listener class="org.hibernate.metamodel.source.annotations.xml.mocker.ItemListener">
 				<pre-persist method-name="prePersist"/>
 				<post-persist method-name="postPersist"/>
 			</entity-listener>
 		</entity-listeners>
 	</entity>
 </entity-mappings>
diff --git a/hibernate-core/src/test/resources/org/hibernate/metamodel/binder/source/annotations/xml/mocker/persistence-metadata.xml b/hibernate-core/src/test/resources/org/hibernate/metamodel/binder/source/annotations/xml/mocker/persistence-metadata.xml
index 6611bce577..6148c06247 100644
--- a/hibernate-core/src/test/resources/org/hibernate/metamodel/binder/source/annotations/xml/mocker/persistence-metadata.xml
+++ b/hibernate-core/src/test/resources/org/hibernate/metamodel/binder/source/annotations/xml/mocker/persistence-metadata.xml
@@ -1,18 +1,18 @@
 <?xml version="1.0" encoding="UTF-8"?>
 
 <entity-mappings xmlns="http://java.sun.com/xml/ns/persistence/orm"
 				 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 				 version="2.0">
 	<persistence-unit-metadata>
 		<persistence-unit-defaults>
 			<delimited-identifiers/>
 			<access>FIELD</access>
 			<entity-listeners>
-				<entity-listener class="org.hibernate.metamodel.binder.source.annotations.xml.mocker.ItemListener">
+				<entity-listener class="org.hibernate.metamodel.source.annotations.xml.mocker.ItemListener">
 					<pre-persist method-name="prePersist"/>
 					<post-persist method-name="postPersist"/>
 				</entity-listener>
 			</entity-listeners>
 		</persistence-unit-defaults>
 	</persistence-unit-metadata>
 </entity-mappings>
diff --git a/hibernate-testing/src/main/java/org/hibernate/testing/Skip.java b/hibernate-testing/src/main/java/org/hibernate/testing/Skip.java
new file mode 100644
index 0000000000..b71877f27d
--- /dev/null
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/Skip.java
@@ -0,0 +1,71 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.testing;
+
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+/**
+ * An annotation, used in combination with {@link Matcher}, to determine when/if tests should be skipped.
+ *
+ * @author Steve Ebersole
+ */
+@Retention( RetentionPolicy.RUNTIME )
+@Target({ ElementType.METHOD, ElementType.TYPE })
+public @interface Skip {
+	/**
+	 * The condition which causes a skip
+	 *
+	 * @return The condition
+	 */
+	Class<? extends Matcher> condition();
+
+	/**
+	 * A message describing the reason for the skip
+	 *
+	 * @return Descriptive message
+	 */
+	String message();
+
+	/**
+	 * Simple boolean assertion
+	 */
+	public static interface Matcher {
+		/**
+		 * Do we have a match to the underlying condition?
+		 *
+		 * @return True/false ;)
+		 */
+		public boolean isMatch();
+	}
+
+	public static class AlwaysSkip implements Matcher {
+		@Override
+		public boolean isMatch() {
+			return true;
+		}
+	}
+}
diff --git a/hibernate-testing/src/main/java/org/hibernate/testing/SkipLog.java b/hibernate-testing/src/main/java/org/hibernate/testing/SkipLog.java
index a16abc9455..8c44e40de5 100644
--- a/hibernate-testing/src/main/java/org/hibernate/testing/SkipLog.java
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/SkipLog.java
@@ -1,49 +1,43 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.testing;
 
 import org.jboss.logging.Logger;
 
-import org.hibernate.testing.junit4.SkipMarker;
-
 /**
  * Well-known-location lookup for the test-skip log...
  *
  * @author Steve Ebersole
  */
 public class SkipLog {
 	private static final Logger log = Logger.getLogger( SkipLog.class );
 
-	public static void reportSkip(SkipMarker skipMarker) {
-		log.info( "*** skipping test [" + skipMarker.getTestName() + "] - " + skipMarker.getReason(), new Exception() );
-	}
-
 	public static void reportSkip(String message) {
 		log.info( "*** skipping test - " + message, new Exception() );
 	}
 
 	public static void reportSkip(String reason, String testDescription) {
 		reportSkip( testDescription + " : " + reason  );
 	}
 }
