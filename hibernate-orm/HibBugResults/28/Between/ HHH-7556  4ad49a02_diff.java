diff --git a/changelog.txt b/changelog.txt
index b9ba33f3c0..28b36e1de5 100644
--- a/changelog.txt
+++ b/changelog.txt
@@ -1,1259 +1,1259 @@
 Hibernate Changelog
 ===================
 Note: Newer entries are automatically generated and the description might not
 match the actual issue resolution (i.e. a bug might not be a bug). Please
 refer to the particular case on JIRA using the issue tracking number to learn
 more about each case.
 
 Changes in version 4.1.5.SP1 (2012.07.12)
 ------------------------------------------------------------------------------------------------------------------------
 
 ** Bug
     * [HHH-7447] - ValueHolder used in NaturalIdCacheKey is not Serializable
 ** Improvement
     * [HHH-2394] - Support filter tag in subclass
 
 Changes in version 4.1.5.Final (2012.07.12)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/12150
 
 ** Bug
     * [HHH-5411] - Missing value in not updatable column in Envers audit table
     * [HHH-5565] - Memory leak is possible if changes for audited entities are outside of transaction
     * [HHH-5929] - PooledLoOptimizer in conjunction with SequenceStyleGenerator is not thread-safe
     * [HHH-6304] - Error "Cannot create TypedQuery for query with more than one return" with named queries
     * [HHH-6707] - One-to-One mapping with foreign key in target table and foreign key being the primary key fails with Oracle
     * [HHH-6896] - Metamodel.managedType(...) implemented incorrectly
     * [HHH-7310] - Resolution of types registered in type registry does not work properly for Properties of @Embeddable types
     * [HHH-7311] - NullPointerException if TenantConnectionProvider class does not exist
     * [HHH-7368] - SQLServer2005Dialect: pagination query fails if terminating with a semicolon
     * [HHH-7369] - SQLServer2005Dialect: scalar query fails with pagination
     * [HHH-7374] - Support KEY, ENTRY and VALUE qualifiers in WHERE clause
     * [HHH-7380] - bug when initialize MULTI_TENANT_IDENTIFIER_RESOLVER and CUSTOM_ENTITY_DIRTINESS_STRATEGY
     * [HHH-7426] - Setting cacheable="true" in orm.xml does not enable caching of entity in 2lc
 ** Improvement
     * [HHH-4394] - @OrderBy usage on a joined classes (when using join table) produces incorred SQL syntax.
     * [HHH-7370] - SQLServer2005Dialect: sql-transformation to common_table_expression not needed when offset = 0
     * [HHH-7381] - Refact: split CacheImpl from SessionFactoryImpl into a session factory scope service
     * [HHH-7382] - refact: unify the configuration implementation loading strategy
     * [HHH-7431] - Reduce NaturalIdCacheKey Memory Footprint
 ** Task
     * [HHH-7440] - Redesign dialect-specific LIMIT clause appliance
     * [HHH-7442] - rename org.hibernate.internal.util.Value
 
 Changes in version 4.1.4.Final (2012.05.30)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11960
 
 ** Bug
     * [HHH-2214] - SQLStateConverter chooses wrong JDBCException: Locks and MySQL
     * [HHH-5396] - JPQL KEY(), ENTRY() and VALUE() does not recognize alias refs
     * [HHH-6256] - persistence.xml-specified javax.persistence.lock.timeout is ignored
     * [HHH-6310] - SQLServer2005Dialect produced select statement with a distinct keyword within an aggregate function does not work
     * [HHH-6329] - Apparently inaccurate 'java.lang.UnsupportedOperationException: Illegal attempt to edit read only item' when using SQLQuery.executeUpdate
     * [HHH-6728] - SQLServer2005Dialect - Paging doesn't work with UPPERCASE colums in a case sensitive database
     * [HHH-6950] - Bogus string replacement in SQLServer2005Dialect.insertRowNumberFunction()
     * [HHH-6960] - NullPointerException in PreCollectionRemove Listener
     * [HHH-7019] - SQLServer2005Dialect, SQLServer2008Dialect issues with subqueries
     * [HHH-7074] - the replacement annotations of @Entity are not working
     * [HHH-7107] - org.hibernate.test.locking.LockModeTest hangs on Sybase 15.5 and DB2-97
     * [HHH-7112] - session.clear does not clear StatefulPersistenceContext.naturalIdResolutionCacheMap
     * [HHH-7198] - SQLServer2005Dialect.getLimitString turns tablenames to lowercase ->  SQLGrammarException: when mapping tables with capital letters
     * [HHH-7285] - Using distinct in Criteria, using first- and maxResults, fails with SQLGrammarException when a colum in the distinct clause starts with 'from'
     * [HHH-7294] - Envers manytomany Test BasicSametable fails on DB2 as DB2 does not support tinyint
     * [HHH-7295] - ParentAuditing Test in Envers Testsuite fails across different databases with different error messages because Hibernate does not set LockMode correctly
     * [HHH-7316] - Collection removal actions added by DefaultAutoFlushEventListener.onAutoFlush() are not removed when flush is not needed
     * [HHH-7317] - Boolean values bound to parameters in SQL predicate cause failures using DB2 with deferPrepares = true
     * [HHH-7323] - SQLServerDialectTest.testMaxResultsSqlServerWithCaseSensitiveCollation fails on mssql2008R1 and mssql2008R2 due to Lock request TimeOut period exceeded
     * [HHH-7346] - Tests fail on Postgresql due to failure in typecasts
     * [HHH-7347] - fail test if it runs longer than 30 minutes to prevent hangs
     * [HHH-7348] - AbstractMultiTenantConnectionProvider not closing connections
     * [HHH-7350] - read-only entities can not be deleted from 2LC
 
 ** Improvement
     * [HHH-3961] - SQLServerDialect, support nowait in LockMode.UPGRADE_NOWAIT
     * [HHH-5881] - Add getter for "namedParameters" to QueryKey
     * [HHH-6846] - Support for Query.setHint(javax.persistence.lock.timeout)
     * [HHH-7356] - javax.persistence.lock.timeout hint is ignored by @NamedQuery
 
 ** New Feature
     * [HHH-7306] - Allow use of CurrentTenantIdentifierResolver in normal session opening
 
 
 Changes in version 4.1.3.Final (2012.05.02)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11959
 
 ** Bug
     * [HHH-1512] - Problem to lock a row in a DB2 database with LockMode UPGRADE
     * [HHH-2697] - Can't use := for variable assignment within a SQL-Statement
     * [HHH-7068] - "Cursor state not valid" error from AS400
     * [HHH-7101] - NPE when trying to create EntityManagerFactory
     * [HHH-7195] - Table does not handle quoted catalog
     * [HHH-7225] - NullPointerException after persisting null entity value as natural-Id
     * [HHH-7237] - Inline natural-id synchronization doesn't consider reattached objects
     * [HHH-7238] - Remove the need for QueryResultsRegionImpl to have @Listener
     * [HHH-7239] - have session remove itself from list of transaction observers on close
     * [HHH-7245] - Inline natural-id synchronization doesn't consider objects loaded from shared cache
     * [HHH-7246] - Envers creates revision for changing from empty string to null and from null to string
     * [HHH-7250] - Bug in SharedCache handling of Natural-id
     * [HHH-7251] - PostgreSQL Dialect not properly mapping SQL error codes for pessimistic lock exceptions.
     * [HHH-7252] - EntityManager not retaining LockOptions context when mapping exceptions.
     * [HHH-7253] - NPE thrown by NaturalIdResolutionCache
     * [HHH-7265] - ConcurrentModificationException in SynchronizationRegistryImpl.notifySynchronizationsAfterTransactionCompletion due to SynchronizationRegistryImpl.clearSynchronizations clearing SynchronizationRegistryImpl.synchronizations
     * [HHH-7266] - Move away from use of Enhydra developed DataSource for JTA testing
     * [HHH-7274] - Developer Guide reverses discussion of CMTTransactionFactory and JTATransactionFactory
     * [HHH-7276] - Regression allows entity to be looked up by previous natural id
     * [HHH-7278] - Natural-id shared cache afterTransactionCompletionProcess does not distinguish between success and failure
     * [HHH-7281] - Tests fail on Postgresql due to failure in typecasting
     * [HHH-7296] - NPE in JtaTransaction#markRollbackOnly
 
 ** Improvement
     * [HHH-6848] - Performance Optimization of in memory merge algorithm (Wim Ockerman)
     * [HHH-7235] - Support null NaturalId values in loadEntityIdByNaturalId query
     * [HHH-7256] - Infinispan second level cache should react to minimal puts in putFromLoad impl
     * [HHH-7272] - Have ClassLoaderServiceImpl use Class.forName rather than ClassLoader.loadClass
     * [HHH-7279] - Prevent identical re-cachings in natural-id shared cache
     * [HHH-7280] - Upgrade to Infinispan 5.1.4.FINAL
     * [HHH-7282] - Move org.hibernate.cache.internal.Timestamper to hibernate-testing module
     * [HHH-7283] - hibernate is not compilable on JDK7
 
 ** New Feature
     * [HHH-6790] - Add option to SequenceStyleGenerator to prefer a "sequence per entity"
 
 ** Patch
     * [HHH-5043] - Incorrect handling of hibernate.default_schema in SchemaUpdate
     * [HHH-6405] - setFetchMode ignored in certain cases when using criteria queries
 
 
 Changes in version 4.1.2.Final (2012.04.04)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11951
 
 ** Bug
     * [HHH-1657] - hql update generate wrong sql with joined subclass hierarcy
     * [HHH-6271] - deploying with a 1.0 orm.xml, gets unexpected error HHH00196
     * [HHH-6915] - Restrictions.ilike(String propertyValue, Object value) does not correctly initialize LikeExpresison
     * [HHH-7017] - Envers does not work in case of resource-local transactions and manual session flush mode
     * [HHH-7020] - Connection leak with nested sessions
     * [HHH-7090] - Temporary session closing affects original session
     * [HHH-7133] - NaturalIdLoadAccess not correctly working on mutable NaturalId's
     * [HHH-7158] - Regression: null values on NaturalId's at persist-time are causing subsequent NPE's and wrong behaviour
     * [HHH-7159] - Database keywords causes failure of some tests in org.hibernate.test.collection.custom
     * [HHH-7160] - NaturalIdXrefDelegate#cache() needs to remove obsolete entries in shared cache when NaturalId values changed
     * [HHH-7165] - count() query on classes using EmbeddedId should not use id column tuple on Dialects which dont support non-distinct tuple counts
     * [HHH-7166] - Infinispan Hibernate RegionFactory doesn't allow user to have their own custom CommandFactory
     * [HHH-7167] - The new natural id code introduced in 4.1.1 depends on the order the entity persisters are loaded which leads to fatal errors
     * [HHH-7174] - org.hibernate.test.tm.CMTTest.testConcurrentCachedQueries fails due to test cases interdependent
     * [HHH-7184] - Missing StaticModels for envers revision entity
     * [HHH-7191] - NaturalIdCache improperly declared
     * [HHH-7192] - NullPointerException in QueryTranslatorImpl on erroneously typed delete query
     * [HHH-7193] - Transaction Rollback not clearing statement batch on Prepared Statement causes issues with statement caching
     * [HHH-7194] - NullPointerExeption with nested subqueries using Criteria API
     * [HHH-7200] - SessionFactoryObservers should be notified of the close event in reverse order of the create event
     * [HHH-7204] - improve tracking of regions created in the Infinispan region factory
     * [HHH-7210] - Natural-id cache put stats not being correctly updated on insert for "asynch" cache providers
 
 
 Changes in version 4.1.1.Final (2012.03.07)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11859
 
 ** Bug
     * [HHH-6883] - Informix dialect incorrectly reports that temp tables are not supported
     * [HHH-7046] - Polymorphic query by natural ID broken
     * [HHH-7073] - Audited entities with Many-to-Many relationships fail with NullPointerException
     * [HHH-7085] - Entities marked as @Immutable that have a @NaturalId fail to be inserted with NPE
     * [HHH-7089] - NPE during SessionFactoryImpl init when 2L caching is enabled and @NaturalIdCache is used with EHcache
     * [HHH-7094] - Session is not flushed before NaturalIdLoadAccess is executed
     * [HHH-7095] - Handle RegionFactory.buildNaturalIdRegion throwing UnsupportedOperationException
     * [HHH-7096] - Settings not available in SingletonEhCacheRegionFactory
     * [HHH-7097] - Entity load event doesn't result in naturalId->pk caching
     * [HHH-7102] - Misleading error message is shown when no RegionFactory is manually set
     * [HHH-7106] - Documentation doesnt explain how to create audited tables
     * [HHH-7117] - MultipleLinesSqlCommandExtractor does not accept trailing white spaces after last statement
     * [HHH-7127] - Query region evictAll not working on local mode
     * [HHH-7129] - Throw exception when metadata attempts to spread @NaturalId across an entity hierarchy
     * [HHH-7138] - Hibernate implements JPA @OneToMany collection versioning incorrectly
     * [HHH-7147] - ServiceRegistry is starting services twice
 
 ** Deprecation
     * [HHH-7023] - Deprecate HQL-specific (JDBC-style) positional parameters
 
 ** Improvement
     * [HHH-5927] - Performance risk: Suboptimal synchronization in org.hibernate.engine.query.QueryPlanCache.getHQLQueryPlan
     * [HHH-6589] - Skip non-JPA features populating JPA "static metamodel"
     * [HHH-6946] - Add support for the AS400 (iSeries) system to StandardDialectResolver
     * [HHH-6983] - remove common-collections dependency
     * [HHH-7066] - Improve memory allocation on String extraction out of Clob fields
     * [HHH-7128] - Upgrade to Infinispan 5.1.2.CR1
 
 ** Patch
     * [HHH-4417] - Add annotation support for UserCollectionType
     * [HHH-6100] - Bug fix related to CriteriaQuery (JPA) when using XML mappings
 
 ** Task
     * [HHH-7062] - upgrade to jboss-logging 3.1.0.GA
     * [HHH-7067] - Update build to work with Gradle m8
     * [HHH-7153] - Update to newest jDocBook tool chain versions
 
 
 Changes in version 4.1.0.Final (2012.02.08)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11223
 
 ** Bug
     * [HHH-3218] - ManyToOne Persisting Cascade in Embeddable as part of ElementCollection
     * [HHH-3544] - Nullability.checkNullability() throws PropertyValueException (not-null property references a null property) for a property that ForeignKeys.Nullifier.nullifyTransientReferences() just nulled
     * [HHH-3853] - one-to-one mapping doesn support Primary Key Association
     * [HHH-4962] - @ManyToOne with @JoinTable fails
     * [HHH-5024] - MetadataContext#registerAttribute does not recognize inherited fields
     * [HHH-5299] - Multi-Level cascading of unsaved instances with bidirectional associations fails with TransientObjectException (Carl-Eric Menzel)
     * [HHH-5755] - javax.persistence.criteria.Expression.as() is broken
     * [HHH-6580] - Discriminator value used as ID when inserting entity to PosgtreSQL
     * [HHH-6689] - DefaultMergeEventListener changes CheckNullability flag - not thread save
     * [HHH-6738] - Hardcoded alias causing problems
     * [HHH-6744] - TransientObjectException thrown on dirty check during flush with CHECK_NULLABILITY set to false
     * [HHH-6825] - AuditException with @OneToOne-mappedBy and @PrimaryKeyJoinColumn
     * [HHH-6964] - EnversIntegrator is always detected by default while initializing Serviceregistry using Native Hibernate API causing a MappingException even when Envers is not used
     * [HHH-6967] - Reapply HHH-6906
     * [HHH-6969] - Reference manual discusses removed SessionFactory.openSession(Interceptor) method
     * [HHH-6984] - some statistics are incremented even when stats are disabled
     * [HHH-7003] - Scale = 0 doesn't supported
     * [HHH-7006] - keyword "top" causes test fail on ms sql server
     * [HHH-7007] - Replacing the region factory in the global cache command factory could affect other apps
     * [HHH-7016] - NullPointerException in CacheAdapterImpl when evictAll
     * [HHH-7021] - PostgreSQL 8.1 and earlier does not support if exists before drop (Eric Dalquist)
     * [HHH-7022] - AbstractMultiTenantConnectionProvider never closes connections causing resource exhaustion
     * [HHH-7030] - EventListenerRegistry interface generic declaration is not extensible to subclasses
     * [HHH-7034] - java.sql.SQLTimeoutException should be mapped to org.hibernate.QueryTimeoutException
     * [HHH-7041] - SQLServer2005Dialect handles DISTINCT clauses incorrectly
     * [HHH-7044] - SQLServer2005Dialect parses GROUP BY clause incorrectly
 
 ** Deprecation
     * [HHH-7014] - Deprecate PostgreSQLDialect
     * [HHH-7032] - Deprecate Dialect.buildSQLExceptionConverter()
 
 ** Improvement
     * [HHH-2879] - add an actual api for loading an entity by natural candidate key (mapped natural-id)
     * [HHH-3910] - custom dirty flag tracking
     * [HHH-4358] - Having to use @ForceDiscriminator kind of breaks JPA compatibility
     * [HHH-5472] - Delay saving an entity if it does not cascade the save to non-nullable transient entities
     * [HHH-6923] - Remove org.hibernate.service.instrumentation.spi.InstrumentationService
     * [HHH-6944] - Update Dialects to return SQLExceptionConversionDelegate
     * [HHH-6957] - Throw TransientPropertyValueException if there are unresolved entity insert actions after persist/save/merge listeners execute
     * [HHH-6968] - Update overview.html for aggregated JavaDocs
     * [HHH-6974] - Add caching to new "load access" api for natural id loading
     * [HHH-6980] - Upgrade to Infinispan 5.1.0.CR4
     * [HHH-6994] - Have EntityEntry fire notification to PersistenceContext on loadedState being updated
     * [HHH-6998] - Expand CustomEntityDirtinessStrategy to define findDirty
     * [HHH-7009] - Create PostgreSQL81Dialect and PostgreSQL82Dialect (Eric Dalquist)
     * [HHH-7026] - upgrade to infinispan 5.1.1.FINAL
 
 ** New Feature
     * [HHH-6605] - Storing information about changes of properties
 
 ** Task
     * [HHH-6082] - Incorporate EntityManager documentation into main dev guide
     * [HHH-6336] - Add TenantIdentifierResolver
-    * [HHH-6656] - Document org.hibernate.service.classloading.spi.ClassLoaderService
+    * [HHH-6656] - Document org.hibernate.boot.registry.classloading.spi.ClassLoaderService
     * [HHH-6966] - Re apply HHH-6782
     * [HHH-6985] - Change up tests for PostgreSQL LockMode issues
     * [HHH-7011] - Document multi-tenancy
     * [HHH-7018] - change EntityManagerFactory serialization to just serialize the name and lookup the previously created EntityManagerFactory during deserialization
 
 
 Changes in version 4.0.1.Final (2012.01.11)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11754
 
 ** Sub-task
     * [HHH-2763] - Allow initialization during flush
     * [HHH-6952] - Allow extensions of InfinispanRegionFactory to override classloader logic
 
 ** Bug
     * [HHH-4439] - In general it is impossible to override properties defined in @MappedSuperclass to change how they will be handled during auditing.
     * [HHH-5275] - Criteria.setLockMode does not work correctly
     * [HHH-5891] - AuditReaderImpl.getRevisions result is not ordered as specified in Javadoc
     * [HHH-6854] - testSubsequentPooledLoOptimizerUsage doesn't actually test the PooledLo optimizer
     * [HHH-6855] - SequenceStyleGenerator should force use of TableStructure when the optimizer is PooledLo
     * [HHH-6902] - Create typed query in EntityManager throws NullPointerException when filters are present
     * [HHH-6906] - Clean up javadoc warnings
     * [HHH-6909] - "Getting Started Guide" example code cannot be run successfully
     * [HHH-6916] - Improper handling of primitive arrays in AbstractQueryImpl.registerParameterBinding
     * [HHH-6920] - HQL insert queries and identifier handling
     * [HHH-6921] - jandex and classmate dependencies should not be exported to published pom
     * [HHH-6933] - Developer's guide has strange markup in Chapter 1
     * [HHH-6936] - EntityManagerImpl.close() and EntityManagerImpl.isOpen() should check if the session factory is closed
 
 ** Improvement
     * [HHH-6822] - Split notions of (1) "naming" a SessionFactory and (2) specifying a JNDI name to which to bind it
     * [HHH-6840] - Add to_char function to HSQLDialect
     * [HHH-6887] - Improve SQLStateConverter to take sql state type from the database metadata into account
     * [HHH-6955] - Upgrade to Infinispan 5.1.0.CR3
 
 ** New Feature
     * [HHH-6931] - Provide local database hook
     * [HHH-6940] - Ability (easier) to run bits of code in a timeout protected way
 
 ** Patch
     * [HHH-5124] - Removing an entity and persisting it again fails
 
 ** Task
     * [HHH-6657] - Document org.hibernate.integrator.spi.IntegratorService
     * [HHH-6782] - define javadoc groups based on api/spi/internal
     * [HHH-6897] - serialization of the EntityManager should be possible
     * [HHH-6900] - upgrade to org.javassist:javassist:3.15.0-GA
     * [HHH-6903] - add building of hem and manual docs
     * [HHH-6937] - Process database profiles just once per build
 
 
 Changes in version 4.0.0.Final (2011.12.14)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11656
 
 ** Bug
     * [HHH-6836] - some test failures on Oracle
     * [HHH-6866] - UUID wrongly mapped as 'char(255) for bit data' on DB2
     * [HHH-6867] - test data overflow causes org.hibernate.test.cut.CompositeUserTypeTest.testCustomColumnReadAndWrite fails on DB2
     * [HHH-6870] - sysdate function in oracle dialect is a non argu and no parentheses function
 
 ** Improvement
     * [HHH-6729] - Upgrade to Infinispan 5.1 and update default second level cache config file
 
 ** Task
     * [HHH-6423] - Add JoinedIterable<T>
 
 
 Changes in version 4.0.0.CR7 (2011.11.30)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11653
 
 ** Bug
     * [HHH-5222] - upgrade from READ to OPTIMISTIC_FORCE_INCREMENT fails
     * [HHH-5945] - Race condition in building query cache
     * [HHH-5992] - A query fails to return correct results silently
     * [HHH-6068] - JPA-specified default schema ignored for Hibernate sequences
     * [HHH-6425] - On Sybase ASE, insert a empty string '' to db, it stores it as single space ' '
     * [HHH-6773] - test fails on sybase
     * [HHH-6780] - Wrong Query timeout calculation
     * [HHH-6806] - Auto scan for JPA entities does not work in exploded packages in JBoss AS < 7
     * [HHH-6807] - org.hibernate.test.lob.LobMergeTest fail on Sybase ASE
     * [HHH-6817] - Logging of strings containing the percent character broken
     * [HHH-6819] - org.hibernate.test.importfile.CommandExtractorServiceTest/MultiLineImportFileTest fail
     * [HHH-6820] - Skip test org.hibernate.ejb.test.lock.LockTest.testContendedPessimisticLock for Sybase ASE15.5
     * [HHH-6827] - org.hibernate.test.tm.CMTTest#testConcurrentCachedDirtyQueries is falling
     * [HHH-6828] - BasicOperationsTest does not take into account that databases can treat identifers differently when it come to lower or upper case
     * [HHH-6830] - QueryAndSQLTest.testNativeQueryWithFormulaAttribute fails due to hard coded function names
     * [HHH-6834] - skip test BasicOperationsTest on oracle due to a oracle jdbc driver issue
     * [HHH-6842] - Skip org.hibernate.test.annotations.manytoonewithformula.ManyToOneWithFormulaTest#testManyToOneFromNonPkToNonPk for DB2
     * [HHH-6843] - LockTest#testContendedPessimisticLock is too agressive in its assumptions
     * [HHH-6849] - SQLServer2005Dialect changes the order of selected columns when using pagination
     * [HHH-6850] - no Types.BINARY mapping in DB2 dialect
     * [HHH-6851] - DB2 doesn't support NotNullUnique causes org.hibernate.test.annotations.uniqueconstraint.UniqueConstraintTest.testUniquenessConstraintWithSuperclassProperty fail
     * [HHH-6852] - DB2 doesn't support exists in select
     * [HHH-6856] - RowValueConstructorSyntax with In syntax is not working
     * [HHH-6863] - serviceBindingList in AbstractServiceRegistryImpl needs synchronization
     * [HHH-6865] - PessimisticLockException should be thrown when pessimistic read and write locking strategies fail
     * [HHH-6867] - test data overflow causes org.hibernate.test.cut.CompositeUserTypeTest.testCustomColumnReadAndWrite fails on DB2
 
 ** Improvement
     * [HHH-4055] - make UpdateTimestampsCache pluggable, like QueryCache
     * [HHH-6833] - Eable SQL logging for tests
     * [HHH-6845] - Avoid repeated invocations of ReflectHelper.overridesEquals in proxy initializers
     * [HHH-6858] - Minor performance improvements after hotspots analysis
     * [HHH-6862] - Reuse cached entryArray of IdentityMap in StatefulPersistenceContext as much as possible
     * [HHH-6868] - Lazily initialize HashMap in LockOptions
 
 ** Patch
     * [HHH-6286] - UpdateTimestampsCache should try to avoid acquiring lock if possible
 
 ** Task
     * [HHH-6818] - update dependencies management
     * [HHH-6821] - Upgrade to jboss-logging-tools 1.0.0.CR5
     * [HHH-6853] - upgrade to jboss-logging 3.1.0.CR2
     * [HHH-6860] - Upgrade to Hibernate Commons Annotations 4.0.1 when released
 
 Changes in version 4.0.0.CR6 (2011.11.10)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11652
 
 ** Bug
     * [HHH-3716] - Sybase - null values for columns mapped as "boolean" are persisted as 0 (zero) instead of NULL
     * [HHH-5413] - null values for columns mapped as "boolean" cause exception when saving entity with Sybase jdbc4
     * [HHH-6714] - Parentheses dissapear in HQL query where they should stay
     * [HHH-6753] - Envers WorkUnits: Problems with merge
     * [HHH-6779] - ByteType mapped to tinyint, but on sybase/ms sql server, tinyint is unsigned int
     * [HHH-6784] - The REVINFO table is always added to Hibernate's configuration, even if there are no audit tables
     * [HHH-6786] - DB2 v97 doesn't support define a boolean type column
     * [HHH-6789] - StringIndexOutOfBoundsException at TemplatedViolatedConstraintNameExtracter.extractUsingTemplate
     * [HHH-6792] - connection leaks due to service registry is not destroyed
     * [HHH-6793] - SessionCacheCleaner doesn't accomodate for closed sessions
     * [HHH-6795] - unsupported Boolean type null value on Sybase causes hangs forever when doing bind parameter
     * [HHH-6796] - Services retrieved after SessionFactoryServiceRegistry has started are not configured (Configurable)
     * [HHH-6799] - Hibernate EntityManager bootstrap does not ensure that ServiceRegistries are closed
     * [HHH-6815] - ByteTest fails on SQL Server due to driver dropping negative sign due to TINYINT data type
 
 ** Patch
     * [HHH-5146] - org.hibernate.util.IdentitySet.iterator() return Map.Entry instances instead of actual elements
 
 ** Task
     * [HHH-6787] - upgrade to JBoss Logging tools 1.0.0.CR3
     * [HHH-6791] - tiny improvement, in favor of java auto-box instead of create new instance
     * [HHH-6798] - Upgrade to Hibernate Commons Annotations GA once it's released
     * [HHH-6816] - Upgrade to jboss-logging 3.1.0.CR1
 
 
 Changes in version 4.0.0.CR5 (2011.10.27)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11550
 
 ** Bug
     * [HHH-2304] - Wrong type detection for sql type char(x) columns
     * [HHH-3434] - hql insert doesn't work when inserting into a table with composite-id
     * [HHH-3843] - @Audited and @ManyToMany relation problem - after modyfing an Entity: org.hibernate.NonUniqueObjectException with message: "a different object with the same identifier value was already associated with the session ...
     * [HHH-4838] - 2L-Querycache ImmutableNaturalKeyLookup not properly recognized as hasImmutableNaturalId() is called on wrong EntityMetamodel
     * [HHH-4881] - restrict polymorphic query results
     * [HHH-4982] - JPA OneToOne(optional=true) not supported with @PrimaryKeyJoinColumn
     * [HHH-5419] - COUNT operator with composite primary key and JPA 2.0 Criteria API produces bad sql
     * [HHH-6121] - Hibernate statistics should log at DEBUG level instead of INFO
     * [HHH-6188] - java.util.UUID cannot be used for Ids on Oracle
     * [HHH-6636] - Properties listed inside "<properties>" tag are not audited
     * [HHH-6703] - id element has 'column' attribute, then the pk column is nullable in ddl created by schema export
     * [HHH-6715] - Integrator classes not being located correctly
     * [HHH-6717] - oracle does not have a boolean type
     * [HHH-6722] - o.h.test.schemaupdate.SchemaExportTest fails if dialect does not support drop table if exist
     * [HHH-6724] - AnnotationBinder and HbmBinder improperly set EntityPersisterClass upon class hierarchy
     * [HHH-6737] - column names in Constraint is not quoted even column name is quoted in mapping
     * [HHH-6739] - JtaIsolationDelegate.doTheWorkInNewTransaction fails to propagate or otherwise report caught exceptions
     * [HHH-6748] - Test failures due to inconsistent return type of numeric from native query
     * [HHH-6749] - FooBarTest.testLimit() fails on MS SQL Server due to dialect interpretation of max row
     * [HHH-6750] - ASTParserLoadingTest.testAggregation() fails on MS SQL Server performing avg, presumably due to forcing result to match column type
     * [HHH-6751] - Test failure due to inconsistent scale returned for BigDecimal properties
     * [HHH-6755] - SQL Server/Sybase dialects don't have type mapping for binary datatype
     * [HHH-6756] - Test failures due to Oracle LONG limitatations
     * [HHH-6757] - QueryCacheTest.testCaseInsensitiveComparison() fails for case-insensitive DBs
     * [HHH-6758] - Test failure due to Oracle restrictions on Blob comparison and missing equals() and hashcode()
     * [HHH-6759] - Null properties mapped as boolean cause exception on Oracle
     * [HHH-6760] - Test failures on Oracle due to identity IDs
     * [HHH-6762] - ManyToOneWithFormulaTest.testManyToOneFromNonPkToNonPk() fails due to unsupported keyword
     * [HHH-6764] - QueryAndSQLTest.testNativeQueryWithFormulaAttribute() fails on SQL Server due to unsupported function
     * [HHH-6765] - AuctionTest2.testLazy() fails on SQL Server due to unsupported function in select clause
     * [HHH-6767] - CriteriaQueryTest.testSubselect() fails on SQL Server since it doesn't support ORDER BY in a subquery
     * [HHH-6770] - Oracle test failures due to reserved words used as column names
     * [HHH-6771] - Test failure on Oracle due to ORDER BY in subquery
     * [HHH-6772] - org.hibernate.ejb.test.BaseEntityManagerFunctionalTestCase overrides system properties
     * [HHH-6775] - TargetTest.testTargetOnMapKey() fails on SQL Server due to nullable column in primary key
 
 ** Improvement
     * [HHH-4854] - Make constraint violation name extraction language neutral
     * [HHH-6691] - Improve JavaDoc of Wrapped wrt exception thrown upon unexpected type
     * [HHH-6716] - envers should set the TCCL to the envers classloader before constructing a dom4j instance. This will allow applications to use their own version of dom4j
     * [HHH-6720] - Refactor QuerySplitter
     * [HHH-6723] - Remove extra join from eager @OneToOne
     * [HHH-6732] - Some logging trace statements are missing guards against unneeded string creation
     * [HHH-6733] - Avoid frequent usage of ReflectHelper in PojoInstantiator
     * [HHH-6735] - Performance hostpot in FieldInterceptionHelper.JavassistDelegate.isInstrumented(Class)
     * [HHH-6745] - Sybase ASE dialect improvement
     * [HHH-6766] - Support Multicolumn Subqueries in Criteria API
 
 ** New Feature
     * [HHH-6696] - Allow specifying revision listener apart from @RevisionEntity annotation
 
 ** Patch
     * [HHH-4596] - Bulk insertion with assigned identifiers
 
 ** Task
     * [HHH-6740] - run envers tests on db matrix
     * [HHH-6742] - move unit tests back to src/test
 
 
 Changes in version 4.0.0.CR4 (2011.09.28)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11357
 
 ** Bug
     * [HHH-5801] - ColumnNameCache.columnNameToIndexCache map should be synchronized
     * [HHH-5832] - JPA Query and IdClass Causing NullPointerException
     * [HHH-6625] - EntityPrinter.toString() fails for non-POJO entities (happens when logging)
     * [HHH-6642] - NullPointerException in method AbstractReadWriteEhcacheAccessStrategy.handleLockExpiry
     * [HHH-6668] - JaxbProcessor can't resolve hibernate-configuration-4.0.xsd
     * [HHH-6669] - Manual SchemaExport broken due to temp code comments
     * [HHH-6677] - skip @BeforeClassOnce / @AfterClassOnce if test is ignored
 
 ** Improvement
     * [HHH-5326] - UpdateTimestampsCache should maintain the statistics for its region
     * [HHH-6674] - upgrade infinispan to 5.0.1.Final
 
 ** Task
     * [HHH-6659] - upgrade maven wagon plugin to 1.0
     * [HHH-6660] - Edit Transactions.xml in devguide
     * [HHH-6663] - Proof/edit Services.xml in devguide
     * [HHH-6675] - upgrade dependencies
     * [HHH-6676] - change the Intellij metadata generated by gradle idea task configuration (max heap size to 512M by default)
     * [HHH-6683] - Consolidate (consistency) building of service registries
 
 
 Changes in version 4.0.0.CR3 (2011.09.14)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11363
 
 ** Bug
     * [HHH-6533] - ByteTypeDescriptor is not working properly
     * [HHH-6581] - JPA 2.0 Spec. Violation with Access and MappedSuperclass
     * [HHH-6614] - Bad performance: audited entity updates (lots of them) with no EntityManager clear
     * [HHH-6635] - C3P0: hibernate.c3p0.* configuration properties not properly parsed
     * [HHH-6645] - Fix entity information
     * [HHH-6647] - ValidityAuditStrategy breaks in case of concurrent updates to the same entity
 
 ** Improvement
     * [HHH-6640] - Add ability for Integrator to prepare ServiceRegistryBuilder as part of lifecycle
     * [HHH-6653] - Clean up JAXB generated classes
 
 ** New Feature
     * [HHH-6091] - Let people customize identifier generator strategy mappings programmatically in Hibernate 4
 
 ** Task
     * [HHH-6439] - Add Dialect.getAddUniqueConstraintString()
     * [HHH-6626] - Improve PutFromLoadValidatorUnitTestCase to be less timesensitive
     * [HHH-6634] - upgrade to jandex 1.0.3.Final
     * [HHH-6641] - Document services
     * [HHH-6650] - upgrade jacc dependency
     * [HHH-6654] - upgrade ant to 1.8.2
     * [HHH-6658] - upgrade jboss-logging-tools to 1.0.0.Beta7
 
 
 Changes in version 4.0.0.CR2 (2011.08.31)
 ------------------------------------------------------------------------------------------------------------------------
 http://hibernate.onjira.com/browse/HHH/fixforversion/11352
 
 ** Bug
     * [HHH-5789] - Hibernate 3.5.4 doesn't build with OpenJDK 6b18-1.8.2 or greater
     * [HHH-5848] - Columns's table name not processed by naming strategy
     * [HHH-6020] - Move to JBossTS caused some test failures in hibernate-envers
     * [HHH-6384] - hibernate.hbm2ddl.auto=create does not drop tables
     * [HHH-6412] - hibernate version is not injected by the injection plugin
     * [HHH-6586] - Document metamodel package as experimental and unsupported
     * [HHH-6594] - Interceptor.onPrepareStatement no longer being called
     * [HHH-6599] - Hibernate mark as rollback even for no transaction requests
 
 ** Improvement
     * [HHH-6588] - rollback to use "org.hibernate.SQL" category to log sql
 
 ** New Feature
     * [HHH-6618] - running hibernate functional test cases on DB matrix
 
 ** Patch
     * [HHH-6577] - CUBRID Database Dialect
 
 ** Task
     * [HHH-5930] - Remove hibernate-tools dependency from runtime scope if it's not needed
     * [HHH-6619] - Move org.hibernate.pretty.Printer to org.hibernate.internal.util.EntityPrinter
     * [HHH-6621] - Migrate to Hibernate Commons Annotations 4.0.0.CR2
     * [HHH-6622] - Upgrade JBoss Logging to 3.0.0.GA
 
 
 Changes in version 4.0.0.CR1 (2011.08.17)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11350
 
 ** Bug
     * [HHH-6543] - JBoss AS7 transaction manager jndi lookup is wrong
     * [HHH-6547] - Basic properties cannot be made nullable in HBM XML
     * [HHH-6560] - Discriminator match value is not initialized in root EntityBinding
     * [HHH-6563] - NullPointerException using annotations source if a unique constraint is not mapped with a constraint name
     * [HHH-6564] - JBoss AS6 and earlier transaction manager jndi lookup is wrong
     * [HHH-6565] - Unique constraint columns that already exist in the table are not found
 
 ** Improvement
     * [HHH-6573] - change to use ClassLoaderService to locate service initiator
 
 ** Patch
     * [HHH-6370] - HSQLDB dialect - fixes reported issues and adds minor enhancement (Fred Toussi)
 
 ** Task
     * [HHH-6268] - Plumb MetadataImplementor into integrators
     * [HHH-6337] - Add EntityBinding methods to support single-table inheritance
     * [HHH-6410] - Update EntityBinding.getAttributeBindingClosureSpan() and getAttributeBindingClosure() to work for subclass EntityBindings
     * [HHH-6498] - Update entity persisters and tuplizers to use EntityBinding superclass and subclass information
 
 
 Changes in version 4.0.0.Beta5 (2011.08.03)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11251
 
 ** Sub-task
     * [HHH-6202] - Bind inheritance type
     * [HHH-6212] - Handle secondary tables
     * [HHH-6393] - Implement attribute overrides for embeddables
     * [HHH-6430] - MappedAttribute should make use of HibernateTypeDescriptor
     * [HHH-6476] - Implement AttributeSource.getPropertyAccessorName
     * [HHH-6485] - Add support for @DiscriminatorFormula
     * [HHH-6488] - Implement SimpleIdentifierSource#getIdentifierGeneratorDescriptor
     * [HHH-6489] - Support @javax.persistence.Temporal
     * [HHH-6490] - Support @javax.persistence.Lob
     * [HHH-6501] - Support @org.hibernate.annotations.Parent
     * [HHH-6520] - if no @GeneratedValue on an simple @Id property, then the generator strategy should be assigned
     * [HHH-6521] - Column name is not quoted even the global quote identifier property is enabled
     * [HHH-6535] - Support @org.hibernate.annotations.Target
 
 ** Bug
     * [HHH-1780] - negation of EXISTS in hql query does not work
     * [HHH-4648] - Mapping exception when one class maps to multiple tables.
     * [HHH-6469] - build error when using open jdk
     * [HHH-6471] - Redesign how EntityBinding models hierarchy-shared information
     * [HHH-6478] - Code cleanup in metamodel package
     * [HHH-6479] - Split notions of locating and creating an attribute
     * [HHH-6480] - Develop component binding for new metamodel
     * [HHH-6495] - Components not handled correctly from annotations
     * [HHH-6499] - NPE can be thrown by some implementations of Helper.ValueSourcesAdapter.isIncludedInInsertByDefault() and isIncludedInUpdateByDefault()
     * [HHH-6500] - EntityBinding.getEntity().getSuperType() is null for subclass EntityBinding
     * [HHH-6506] - Descriminator type is not resolved
     * [HHH-6529] - Type is not resolved for plural attributes
 
 ** Improvement
     * [HHH-6472] - Implementing EntityDiscriminator and discriminator match value
     * [HHH-6482] - ddl from schema export is not correctly formatted
 
 
 Changes in version 4.0.0.Beta4 (2011.07.20)
 ------------------------------------------------------------------------------------------------------------------------
 https://hibernate.onjira.com/browse/HHH/fixforversion/11242
 
 ** Sub-task
     * [HHH-6392] - Implement attribute overrides for mapped super classes
 
 ** Bug
     * [HHH-2614] - Blob Length Set to 255 By Default With Derby DB
     * [HHH-6380] - Annotations source maps SingleColumnType values to Tuple
     * [HHH-6381] - using @SecondaryTable with optional=true not handled for joined subclasses (@Inheritance(strategy = InheritanceType.JOINED)
     * [HHH-6401] - Create @OptimisticLocking annotation
     * [HHH-6418] - org.hibernate.metamodel.relational.AuxiliaryDatabaseObject extends org.hibernate.mapping.RelationalModel
     * [HHH-6419] - Thread Local bound session proxy does not let SessionImplementor#getFactory() go through on inactive transactions
     * [HHH-6442] - JarVisitorFactory is reconstructing URLs without the URLStreamHandler association
     * [HHH-6451] - adapt hibernate-ehcache to the new api
     * [HHH-6456] - Test failure in CachedPropertyRefCollectionTest behind a proxy
     * [HHH-6460] - AbstractEntityPersister is missing simple property information
     * [HHH-6467] - Non-association attributes are not dirty-checked
 
 ** Deprecation
     * [HHH-6395] - Deprecate org.hibernate.annotations.Entity
 
 ** Improvement
     * [HHH-6417] - Make EventType more debugger friendly by implementing toString
     * [HHH-6421] - Reduce log level of LazyInitializationException from ERROR to TRACE
     * [HHH-6437] - Improve Database to track default Schema object
     * [HHH-6447] - Develop shared binding creation approach
 
 ** New Feature
     * [HHH-6397] - Create @DynamicInsert annotation
     * [HHH-6398] - Create @DynamicUpdate annotation
     * [HHH-6399] - Create @SelectBeforeUpdate annotation
     * [HHH-6400] - Create @Polymorphism annotation
 
 ** Patch
     * [HHH-4630] - Criteria join on composite identifier generates wrong alias, SQL error
 
 ** Remove Feature
     * [HHH-6402] - Remove previously deprecated annotations
 
 ** Task
     * [HHH-6257] - Add IdentifierGenerator to EntityIdentifier binding
     * [HHH-6355] - Have attribute bindings return single, aggregated CascadeStyle
     * [HHH-6357] - Add AttributeBinding.getFetchMode()
     * [HHH-6371] - Develop metamodel binding creation using a push approach
     * [HHH-6416] - Move AuxiliaryDatabaseObject into Database
     * [HHH-6420] - SQL Server dialect is broken (Tomaz Cerar)
     * [HHH-6444] - Integrate new metamodel into SchemaExport
     * [HHH-6449] - Change Exportable.sqlCreateStrings/sqlDropStrings(MetadataImplementor) to take Dialect argument instead
     * [HHH-6450] - Change length argument of Dialect.getTypeName() and TypeNames size/capacity to long
     * [HHH-6453] - Enable new metamodel in BaseCoreFunctionalTestCase
     * [HHH-6462] - Build fetch profiles, caches, current session context and transaction environment from new metadata
 
 
 Changes in version 4.0.0.Beta3 (2011.07.07)
 ------------------------------------------------------------------------------------------------------------------------
 http://opensource.atlassian.com/projects/hibernate/browse/HHH/fixforversion/11241
 
 ** Sub-task
     * [HHH-6173] - Implement embedded entities (component) mapping
     * [HHH-6201] - Handle mapped super classes
     * [HHH-6352] - Add EntityBinding.getAttributeBindingClosureSpan() and getAttributeBindingClosure()
     * [HHH-6358] - Integrate new metamodel into EntityMetamodel
     * [HHH-6359] - Integrate new metamodel into entity tuplizers
     * [HHH-6360] - Build basic properties from an AttributeBinding
     * [HHH-6364] - Add AttributeBinding,getValuesSpan() and Tuple.valuesSpan()
     * [HHH-6365] - Use Identifier.toIdentifier() to create column names
     * [HHH-6366] - Add integer value to uniquely identify Table and InLineView objects for column aliases
     * [HHH-6387] - Add EntityBinding.getFilterDefinitions() and addFilterDefinition()
     * [HHH-6389] - Add TableSpecification.getQualifiedName(Dialect) and implement in subclasses
     * [HHH-6411] - Integrate new metamodel into SingleTableEntityPersister
 ** Bug
     * [HHH-5917] - Envers doesnt track all columns anymore
     * [HHH-6289] - Review log level for o.h.m.s.AnnotationBinder and related binder classes
     * [HHH-6386] - sybase improvement
     * [HHH-6394] - org.hibernate.metamodel.source.annotations.global.QueryBinder handles resultClass paramter of @NamedNativeQuery wrong
     * [HHH-6408] - An empty (ie not null) hibernate.connection.isolation raises a java.lang.NumberFormatException
 Improvement
     * [HHH-6406] - Move JBoss Transaction dependency from 4.14 to 4.15.1 (no more dependency hell)
 ** Task
     * [HHH-6278] - quote all db identifiers
     * [HHH-6350] - Integrate new metamodel for a root entity with simple attributes and no joins
     * [HHH-6368] - remove deprecated hibernate annotations
     * [HHH-6372] - Provide a temporary way to initialize basic types in metamodel
     * [HHH-6404] - Move Hibernate Search integrator from Hibernate Core to Hibernate Search
     * [HHH-6407] - Add SimpleValue.getAlias(Dialect) and implement in subclasses
 
 
 Changes in version 4.0.0.Beta2 (2011.06.22)
 ------------------------------------------------------------------------------------------------------------------------
 http://opensource.atlassian.com/projects/hibernate/browse/HHH/fixforversion/11231
 
 ** Sub-task
     * [HHH-5671] - Apply entity-mode information to the logical model
     * [HHH-6319] - Add getter for attribute node name
     * [HHH-6320] - Add boolean values and getters to EntityIdentifier indicating if an ID is embedded or "identifier mapper"
     * [HHH-6321] - Add org.hibernate.metamodel.binding.CascadeType.toCascadeStyle()
     * [HHH-6341] - Add AttributeBinding.isBasicPropertyAccessor()
     * [HHH-6342] - Add EntityModeEntitySpecifics.getTuplizerClass()
     * [HHH-6346] - Add EntityBinding.entityTuplizerClass(); change getEntityPersisterClass() to return Class<EntityPersister>
 
 ** Bug
     * [HHH-6177] - Envers - problem with mapping relation when using mixed inheritance strategy
     * [HHH-6327] - NPE when using JDBC connection pool C3pO
     * [HHH-6348] - POST_COMMIT_DELETE listener does not get executed
 
 ** Remove Feature
     * [HHH-6330] - Remove entity mode switching capability
 
 ** Task
     * [HHH-6297] - remove legacy cache api
     * [HHH-6300] - Create EntityBindingState implementation for annotations
     * [HHH-6301] - Metamodel changes in preparation for integrating metamodel into persisters
     * [HHH-6307] - Upgrade to slf4j 1.6.1
     * [HHH-6308] - Upgrade to Hibernate Validator 4.2.0.Final
     * [HHH-6318] - Change EntityIdentifier.attributeBinding to be type SimpleAttributeBinding
     * [HHH-6322] - upgrade to hibernate-jpa-2.0-api-1.0.1.Final
     * [HHH-6333] - Create DeferredInitializationValue
     * [HHH-6334] - Create JavaType for the metamodel
     * [HHH-6335] - Change PojoEntitySpecifics to use JavaType for entity and proxy classes
     * [HHH-6340] - Revisit EntityBindingState
     * [HHH-6343] - Remove JavaClassNameResolver because it is not used
 
 
 Changes in version 4.0.0.Beta1 (2011.06.08)
 ------------------------------------------------------------------------------------------------------------------------
 http://opensource.atlassian.com/projects/hibernate/browse/HHH/fixforversion/11222
 
 ** Sub-task
     * [HHH-6113] - Write orm.xml parser
     * [HHH-6132] - Process and bind global configuration annotations
     * [HHH-6133] - Enhance annotation based Jandex index with configuration extracted from orm.xml
     * [HHH-6171] - Implement SimpleAttributeBinding relational and domain state using annotations
     * [HHH-6174] - Create table binding
     * [HHH-6207] - Bind o.h.a.Cache and j.p.Cachable
     * [HHH-6246] - ConfiguredClass should honor default access from persistence-metadata-unit
     * [HHH-6261] - Bind @GeneratedValue
     * [HHH-6263] - Bind o.h.a.Proxy
     * [HHH-6264] - Bind typedef information
     * [HHH-6265] - Bind fetch profiles
     * [HHH-6266] - Bind filter definitions
     * [HHH-6273] - Bind identifier-generator definitions
     * [HHH-6279] - Bind database object definitions
     * [HHH-6281] - Basic HbmBinder cleanup
 
 ** Bug
     * [HHH-2176] - DB2 setMaxResults problem in Hibernate 3.1.3
     * [HHH-2225] - NPE when eager fetching joined component with native SQL query
     * [HHH-4760] - NotAuditedException occurs when auditReader.getRevisions() is called for javassist proxies
     * [HHH-4943] - ilike support is incomplete
     * [HHH-5572] - clean up Sybase job failures
     * [HHH-5808] - ObjectNotFoundException for an audited optional association. Envers is creating a proxy even when the association is null.
     * [HHH-5967] - Envers Fetching Indexed Collection - Duplicate Row Exception
     * [HHH-6119] - NullPointerException in AbstractPathImpl without source path
     * [HHH-6176] - Envers ignores custom comparators for SortedSets
     * [HHH-6206] - Explicitly add antlr jar to transitive dependencies
     * [HHH-6211] - Fix bad pull request merge
     * [HHH-6217] - Create EntityBindingState for initializing entity-specific binding data
     * [HHH-6219] - Memory leak with Infinispan cache
     * [HHH-6242] - no Types.BINARY type mapping in PostgresqlDialect
     * [HHH-6243] - JBPAPP-3312 org.hibernate.test.legacy.CustomSQLTest fails
     * [HHH-6250] - Some classes still using SLF4J
     * [HHH-6272] - More logging fix ups
     * [HHH-6274] - Logging format error causes many test failures
     * [HHH-6276] - org.hibernate.test.cache.ehcache.EhCacheRegionFactoryImpl fails due to no slf4j in test configuration
 
 ** Improvement
     * [HHH-4489] - need method "refresh(String entityName, Object obj)"
     * [HHH-5025] - Support caching audit queries using ehcache's DiskStore.
     * [HHH-5598] - sybase integration improvement
     * [HHH-5649] - improve eclipse support with migration to gradle
     * [HHH-6062] - Infinispan as JTA synchronization participant
     * [HHH-6237] - Remove Service proxy code
     * [HHH-6247] - Log (warn) inability for EM to join transaction only when user explicitly asked for join
     * [HHH-6248] - Ominous-sounding WARN message from SessionFactoryObjectFactory
     * [HHH-6258] - Performance improvement work
     * [HHH-6291] - Basic MetadataImpl redesign
     * [HHH-6292] - avoid Boolean instance creation
     * [HHH-6294] - use enum instead of constant
 
 ** New Feature
     * [HHH-5580] - tracking entity names in a revision
     * [HHH-6078] - Conditional auditing support
     * [HHH-6293] - avoid create unnesserary Integer object
 
 ** Patch
     * [HHH-5434] - org.hibernate.test.filter.DynamicFilterTest testSqlSyntaxOfFiltersWithUnions fails with Ingres dialect
     * [HHH-6228] - Build is platform dependent
 
 ** Task
     * [HHH-6110] - Initial work to integrate new metamodel into persisters
     * [HHH-6156] - Deprecate Configuration
     * [HHH-6186] - Upgrade Hibernate 4 to Infinispan 5.0.0.CRx
     * [HHH-6213] - Move domain and relational state interfaces into org.hibernate.metamodel.state
     * [HHH-6214] - Make RegionFactory a service
     * [HHH-6229] - Clean up MappingDefaults
     * [HHH-6230] - Rework attribute binding using state objects
     * [HHH-6232] - Add discriminator value to DiscriminatorBindingState
     * [HHH-6239] - Add service for access to configuration options/settings map
     * [HHH-6240] - Add access to configuration options targetting metamodel building
     * [HHH-6251] - Create CollectionElement subclasses for element, composite-element, one-to-many, many-to-many, many-to-any
     * [HHH-6267] - Plumb MetadataImplementor into service initiators registered in SessionFactoryServiceRegistry
     * [HHH-6282] - clean out-of-date config files in etc dir
     * [HHH-6290] - Add EntityBinder.isRoot() to indicate if the EntityBinding is for a "root" entity
 
 
 Changes in version 4.0.0.Alpha3 (2011.05.04)
 ------------------------------------------------------------------------------------------------------------------------
 http://opensource.atlassian.com/projects/hibernate/browse/HHH/fixforversion/11163
 
 ** Sub-task
     * [HHH-6114] - Preprocess annotation configuration
     * [HHH-6148] - Resolve generic type parameters
     * [HHH-6161] - Integrate annotation based configuration processing into MetadataSource
 
 ** Bug
     * [HHH-468] - MysqlDialect incorrectly maps java.lang.Boolean to SQL BIT
     * [HHH-2049] - LEFT OUTER JOIN subcriteria filters children
     * [HHH-4073] - discriminator formula creates problem in hibernate envers
     * [HHH-4787] - AuditProperty.isNull() doesn't generate "tab.col is null" SQL clause as expected
     * [HHH-5276] - Table REVINFO created in the default schema even if the property is otherwise set
     * [HHH-5887] - Document typo hibernate.hbm2ddl.import_files
     * [HHH-6069] - Escape entity fields name when required
     * [HHH-6093] - Account for tenant identifier on QueryKey
     * [HHH-6094] - Test failures in hibernate-infinispan dealing with query caching
     * [HHH-6095] - Improve the way AbstractEntityManagerImpl.flush checks for an active transaction, should apply to other AbstractEntityManagerImpl methods that also check for an active tx
     * [HHH-6163] - Need to fix location of envers integrator service file
     * [HHH-6164] - Prefer regsitering JTA syncs via TransactionManager
 
 ** Deprecation
     * [HHH-6158] - Deprecate SessionFactoryStub
     * [HHH-6181] - Deprecate EJB3Configuration
     * [HHH-6183] - Deprecate Configuration
 
 ** Improvement
     * [HHH-2578] - redesign SessionFactory building
     * [HHH-2579] - scope bytecode provider selection to session factory
     * [HHH-5914] - Remove deprecated Hibernate type constants from org.hibernate.Hibernate and manuals
     * [HHH-6064] - Skip regsitration of envers listeners if AuditConfiguration says no auditing annotations were found
     * [HHH-6080] - Migrate from DTD to XSD for hbm.xml files
     * [HHH-6096] - H2Dialect should use CACHED option for temporary table creation
     * [HHH-6097] - Review log levels, especially related to i18n messages
     * [HHH-6102] - ISE should be thrown when EM is colsed and joinTransaction is called, even with RESOURCE-LOCAL TX
     * [HHH-6106] - Fix up IntelliJ project generation
     * [HHH-6117] - Figure out best way to handle SessionFactoryObjectFactory dealing with JNDI
     * [HHH-6118] - Make Metadata more user-friendly API
     * [HHH-6128] - Create simplier LobCreator access from Session
     * [HHH-6129] - org.hibernate.LobHelper#createNClob can now return NClob
     * [HHH-6144] - Introduce ServiceRegistryBuilder
     * [HHH-6154] - Add a README for describing build
 
 ** New Feature
     * [HHH-6140] - Allow disabling of JAXP validation
 
 ** Patch
     * [HHH-6169] - Prevent unnecessary calls to JDBC metadata methods.
 
 ** Task
     * [HHH-5652] - Create "Take It Further" tasks for the JPA chapter of the GSG
     * [HHH-6014] - Migrate hibernate-envers tests to JUnit4
     * [HHH-6023] - Create "Take It Further" tasks for the Envers chapter of the GSG
     * [HHH-6092] - Create domain and relational state APIs for SimpleAttributeBinding and implement for XML mappings
     * [HHH-6098] - Slight naming changes in regards to new logging classes
     * [HHH-6101] - Clean up checks for java 1.3 versus 1.4
     * [HHH-6107] - Metamodel dependence on ServiceRegistry
     * [HHH-6111] - Switch to use JAX for xml parsing
     * [HHH-6115] - jaxb generation should follow directory pattern
     * [HHH-6131] - JAXB generated classes should have a prefix to distinguish then easier from model classes
     * [HHH-6134] - Migrate processing hbm.xml files to use Jaxb-generated classes
     * [HHH-6138] - Implement addition of annotated classes and packages in MetadataSources
     * [HHH-6141] - Develop scheme for ordered processing of MetadataSources sources
     * [HHH-6142] - Integrate JAXB-based binding code and MetadataSources
     * [HHH-6146] - remove SF.setTenantIdentifier, add to withOptions selections
     * [HHH-6147] - Add support for multi-tenancy to StatelessSession building
     * [HHH-6155] - Migrate o.h.impl package to o.h.internal
     * [HHH-6168] - Create an attribute binding for many-to-one and implement DomainState and RelationalState for HBM XML
     * [HHH-6191] - repackage org.hibernate.cache per api/spi/internal split
     * [HHH-6192] - Split org.hibernate.collection package up into api/sip/internal
     * [HHH-6193] - Split org.hibernate.context package into api/spi/internal
     * [HHH-6194] - Better jaxb task to leverage Gradle up-to-date checking
     * [HHH-6196] - Split org.hibernate.engine package into api/spi/internal
     * [HHH-6198] - Split org.hibernate.event package into api/spi/internal
     * [HHH-6199] - Split org.hibernate.exception package into api/spi/internal
     * [HHH-6200] - Split org.hibernate.hql package into api/spi/internal
 
 
 
 Changes in version 4.0.0.Alpha2 (2011.04.06)
 ------------------------------------------------------------------------------------------------------------------------
 http://opensource.atlassian.com/projects/hibernate/browse/HHH/fixforversion/11162
 
 ** Bug
     * [HHH-4999] - createSQLQuery(query).list() result screw up when when columns in different tables have same name
     * [HHH-5803] - Better handling of implicit literal numeric expression typing
     * [HHH-5940] - @MapKeyJoinColumns always throws an exception
     * [HHH-5989] - Add tests of JPA-style transaction joining
     * [HHH-5996] - Wire in JdbcServices into SchemaUpdateTask, SchemaExportTask,  SchemaValidatorTask, HibernateService.dropSchema(), HibernateService.createSchema()
     * [HHH-6001] - Add a top-level directory inside the release bundle archives
     * [HHH-6002] - Use today's year when building copyright footer for aggregated javadocs
     * [HHH-6028] - Remove o.h.classic stuff
     * [HHH-6057] - hibernate.cfg.xml references wrong hbm.xml files and doesn't include reference to DTD file
     * [HHH-6058] - Error in mapping file in Event.hbm.xml file for documentation in download
     * [HHH-6061] - ValidatoryFactory type checking
     * [HHH-6076] - query with setFirstResult throws Exception on derby
 
 ** Improvement
     * [HHH-2680] - Blobs not updated on Session.merge() for detached instances
     * [HHH-2860] - Consolidate Session creation options/parameters
     * [HHH-4362] - @RowId
     * [HHH-5244] - Flesh out H2Dialect temp table support
     * [HHH-5284] - Allow Type to dictate the default length/scale/precision
     * [HHH-5562] - Introduce a locator pattern for integrators to be able to leverage to more easily integrate with Hibernate
     * [HHH-5947] - Improve error message, documentation and tests on @UniqueConstraint
     * [HHH-5993] - Expose SessionFactoryObserver to Hibernate EntityManager configuration
     * [HHH-6053] - Create an interface for centralizing the contract that is shared between Session and StatelessSession
 
 ** New Feature
     * [HHH-5697] - Support for multi-tenancy
 
 ** Patch
     * [HHH-3646] - implement Criteria API querying of collection-of-component (David Mansfield)
     * [HHH-5348] - support for TypedQuery jpaql/hql "scalar" queries
 
 ** Task
     * [HHH-5650] - Pull documentation building into 'release' module
     * [HHH-5682] - Modify service infrastructure to leverage CDI annotations
     * [HHH-5683] - Create Weld-specific ServiceRegistry
     * [HHH-5913] - Implement set of event listeners as a service
     * [HHH-5942] - Migrate to JUnit 4
     * [HHH-5966] - Finish up loose ends for overriding a SqlTypeDescriptor
     * [HHH-6010] - Remove duplication in code involving Work and ReturningWork
     * [HHH-6013] - Consolidate on single JTA impl for testing
     * [HHH-6015] - Investigate hibernate-infinispan test failures since migration to JUnit4
     * [HHH-6016] - Migrate version injection plugin to Gradle
     * [HHH-6025] - Remove cglib dependencies
     * [HHH-6026] - Migrate bytecode provider integrations to api/spi/internal split
     * [HHH-6027] - Migrate o.h.action pakcage to api/spi/internal split
     * [HHH-6033] - Migrate stats to api/spi/internal split
     * [HHH-6036] - integration documentation generation
     * [HHH-6038] - Migrate to use newly separated gradle-upload-auth-plugin
     * [HHH-6047] - allow nesting of ServiceRegistry
     * [HHH-6050] - Remove direct compile-time dependencies to slf4j from build
     * [HHH-6051] - Create a SessionFactory scoped ServiceRegistry
     * [HHH-6052] - Make statistics a service
     * [HHH-6073] - Dialects cannot use the Thread Context ClassLoader with AS7, please change to use the
     * [HHH-6081] - Finish up Integrator
     * [HHH-6088] - Move to slf4j-log4j12 for test logging
 
 
 Changes in version 4.0.0.Alpha1 (2011.03.09)
 ------------------------------------------------------------------------------------------------------------------------
 http://opensource.atlassian.com/projects/hibernate/browse/HHH/fixforversion/11161
 
 ** Sub-task
     * [HHH-5662] - Import the initial work
     * [HHH-5765] - Wire in JdbcServices
     * [HHH-5949] - Migrate, complete and integrate TransactionFactory as a service
 
 ** Bug
     * [HHH-3873] - DB2Dialect.getLimitString raise DB2 error message when called with limit=0
     * [HHH-4646] - Inconsistent behavior with Audited and MappedSuperclass annotations
     * [HHH-5126] - JPA Query with InExpression and Collection_valued_input_parameter Complains About Bad Syntax
     * [HHH-5136] - map-key-column is broken
     * [HHH-5163] - ClassCastException when Hibernate tries to cache results using ResultTransformer
     * [HHH-5168] - DB2Dialect generates CROSS JOINs which aren't supported
     * [HHH-5177] - auditing a child of a mapped superclass forces auditing on siblings
     * [HHH-5280] - Exception on unidirectional collection whose elements are owned by several collection: "java.lang.IllegalArgumentException: object is not an instance of declaring class"
     * [HHH-5306] - Dialect resolution: Cannot set a custom dialect resolver programatically or using hibernate.cfg.xml
     * [HHH-5359] - Derived entity usecase fails when the association is bidirectional
     * [HHH-5590] - Don't log and rethrow exceptions in AbstractFlushingEventListener
     * [HHH-5599] - NPE occurs when using Infinispan as L2 Cache
     * [HHH-5669] - Fix gradle build issues with Infinispan 2LC
     * [HHH-5686] - Collections should be loaded by default using "lazy collection fetch" instead of "extra lazy collection" fetch
     * [HHH-5693] - Re-enable entitymanager tests
     * [HHH-5704] - New getSubString() handling in ClobProxy is incompatible with MySQL JDBC PS.setClob(int, Clob) for empty CLOB
     * [HHH-5706] - Incorrect accounting for 1-based LOB offsets
     * [HHH-5709] - JPA Metamodel: EntityType.getName != @Entity.name
     * [HHH-5710] - incorrect test logic of org.hibernate.test.readonly.ReadOnlyCriteriaQueryTest
     * [HHH-5717] - LockOptions not being set correctly
     * [HHH-5725] - SqlServerDialect should support SQL 2000 which does not support the row_number function
     * [HHH-5727] - Collection member declaration not handling optional AS in HQL.
     * [HHH-5729] - Only one check constraint is generated when @Min and @Max annotation is used on a single field
     * [HHH-5736] - Problem with "not" function of CriteriaBuilder
     * [HHH-5750] - Envers unset session on proxy
     * [HHH-5756] - Envers creates new revisions when only collection changed for entity
     * [HHH-5766] - New services are not wired into standalone SchemaExport, SchemaUpdate, and SchemaValidator
     * [HHH-5782] - Remove HibernateException and SQLException from ConnectionManager method signatures
     * [HHH-5783] - Transaction timeout should be applied by ConnectionManager, not LogicalConnection
     * [HHH-5791] - NullPointerException merging a transient entity with non-nullable properties that are null if insert is delayed and check_nullability is false
     * [HHH-5793] - Query and timestamp caches to use cluster cache loader to avoid behaving like sync repl caches
     * [HHH-5800] - Implement missing element-collection related xml in JPAOverridenAnnotationReader
     * [HHH-5807] - Weird characters in license headers lead to compilation errors with UTF-8 character set
     * [HHH-5817] - Passing char[] or byte[] to equal function of CriteriaBuilder throws java.lang.ClassCastException (Vyacheslav Dimitrov)
     * [HHH-5821] - JPA EntityType's (or ManagedType's) getSingularAttributes() returns the version attribute with isVersion set to false.
     * [HHH-5826] - org.hibernate.util.SerializationHelper#resolveClass never tries loader3
     * [HHH-5838] - Proxool connection pool should only close pools it opened
     * [HHH-5839] - non-utf8 characters in AuditReaderImpl
     * [HHH-5842] - Types.Binary column type should be registered as "binary($l) for HSQLDialect (Fred Toussi)
     * [HHH-5853] - Problem loading cachable collections defined with a property-ref key with a versioned owner
     * [HHH-5883] - @Lob annotated field throws MappingException
     * [HHH-5888] - CLONE: Problem using BLOB and CLOB fields in Oracle
     * [HHH-5889] - CLONE: Using materialized blobs with PostgreSQL causes error
     * [HHH-5890] - Parent POM: License comment in points to 404
     * [HHH-5893] - Tests fail for dialects that return null for empty LOBs
     * [HHH-5900] - Revert change to add upload repositiory authentication handling in build script
     * [HHH-5907] - derby does not support materialize a LOB locator outside the transaction in  which it was created
     * [HHH-5922] - Type overrides do not affect functions registered with the dialect
     * [HHH-5961] - Contextual LOB creator is used when the JDBC driver does not support JDBC4 Connection.createBlob()
     * [HHH-5982] - Flush checker logic bugs
     * [HHH-5983] - Entiy actions contain non-transient references to session and entity  causing inconsistencies after serialization
     * [HHH-5987] - Remove org.hibernate.ejb.CurrentEntityManagerImpl
     * [HHH-5994] - Inserts may be delayed because TransactionCoordinatorImpl.isTransactionInProgress() returns false for non-JTA transactions
     * [HHH-5995] - Compile error because Statement is undefined in SqlExceptionHelper
 
 ** Remove Feature
     * [HHH-5981] - Clarify Session.disconnect() and Session.reconnect() behavior
 
 ** Improvement
     * [HHH-3965] - Expose the ability to use varchar(max) or nvarchar(max)
     * [HHH-4539] - Make UPPER and LOWER work on MS SQL Server text and ntext columns
     * [HHH-5325] - Minor issues in test suite and suggestions for improvements (fixes HSQDB 2.0 failures)
     * [HHH-5588] - Improve support for entityNames - determine the entityName for a retrieved object va envers
     * [HHH-5655] - In Gradle build, better account for non-standard local maven repo cache locations
     * [HHH-5658] - Better .gitignore
     * [HHH-5701] - Add .metadata/* to .gitignore
     * [HHH-5724] - Improve the error message on Bean Validation exception by showing the constraint violation data
     * [HHH-5726] - SqlServer2005Dialect should support variable limit
     * [HHH-5761] - Update source repository links in Envers documentation
     * [HHH-5794] - Add support for additional orm.xml elements for Map handling and element collections
     * [HHH-5823] - Poor multithread performance in UpdateTimestampsCache class
     * [HHH-5824] - Poor multithread performance in SessionFactoryImpl.getQueryCache method
     * [HHH-5843] - Avoid useless branches during HQL parsing when trace logging is disabled
     * [HHH-5859] - Upgrade to Infinispan 4.2.1.CR1
     * [HHH-5904] - Deploy just testing artifacts from hibernate-core, not all tests
     * [HHH-5906] - Expose AbstractEntityPersister.getPropertyUniqueness() as public for OGM to use
     * [HHH-5943] - Make ServiceRegistry mutable
     * [HHH-5977] - Add tests for @JoinColumn using secondary table
     * [HHH-5986] - Refactor org.hibernate.util package for spi/internal split
     * [HHH-5993] - Expose SessionFactoryObserver to Hibernate EntityManager configuration
 
 ** New Feature
     * [HHH-2655] - SQLServer2005Dialect (ROW_NUMBER for Paging)
     * [HHH-5371] - Add support for REVEND_TSTMP which will enable SQL table partitioning by time
     * [HHH-5611] - Add management capability via JMX
     * [HHH-5687] - Extract SQL keywords from DatabaseMetaData
     * [HHH-5879] - Expose state from AbstractEntityPersister / Type / SessionFactoryImplementor  for OGM usage
     * [HHH-5898] - Improve authentication for Gradle uploads
     * [HHH-5916] - Add support for a programmatic way to define a default EntityPersister and CollectionPersister class implementation
     * [HHH-5957] - Provide a way for dialects to override a SqlTypeDescriptor
 
 ** Task
     * [HHH-5615] - Switch to JBoss logging
     * [HHH-5616] - Switch to Gradle for builds
     * [HHH-5617] - Migrate to Git for source control
     * [HHH-5618] - Support legacy ConnectionProvider names
     * [HHH-5619] - Support legacy TransactionFactory names
     * [HHH-5623] - Baseline on JDK 1.6
     * [HHH-5632] - Import initial services work
     * [HHH-5634] - Clean up stuff no longer needed
     * [HHH-5638] - Import JDBC batching service
     * [HHH-5639] - Import ConnectionProvider service
     * [HHH-5640] - Import DialectFactory and DialectResolver services
     * [HHH-5641] - Import JtaPlatform services
     * [HHH-5647] - Develop release process using Gradle
     * [HHH-5651] - Wire in new services in org.hibernate.service
     * [HHH-5656] - Import ServicesRegistry bootstrap code and service tests
     * [HHH-5714] - Upgrade metamodel generator dependency in entitymanager to 1.1.0.Final
     * [HHH-5768] - upgrade H2 version to 1.2.145 (was 1.2.140)
     * [HHH-5778] - Wire in new batch code
     * [HHH-5781] - Refactor code in org.hibernate.jdbc to spi/internal and remove obsolete code
     * [HHH-5788] - Move settings required by JdbcServices into JdbcSupport
     * [HHH-5880] - Gradle has to deploy testing artifacts
     * [HHH-5897] - Upgrade to Gradle 0.9.2
     * [HHH-5903] - Rename ServicesRegistry to ServiceRegistry
     * [HHH-5928] - Clean up compilation warnings
     * [HHH-5941] - Remove deprecated set(), nullSafeSet(), get(), nullSafeGet() methods and add SessionImplementer argument to UserType.nullSafeGet()/nullSafeSet()
     * [HHH-5985] - Remove TransactionHelper in preference of IsolationDelegate
     * [HHH-5990] - Remove non-maintained second level cache integrations
     * [HHH-5991] - Revist passing of ServiceRegistry to Configuration to build a SessionFactory
     * [HHH-6000] - split annotation processor execution out into separate tasks
 
 
 Changes in version 3.6.0.CR2 (2010.09.29)
 -------------------------------------------
 http://opensource.atlassian.com/projects/hibernate/browse/HHH/fixforversion/11131
 
 ** Bug
     * [HHH-892] - HQL parser does not resolve alias in ORDER BY clause
     * [HHH-2917] - Using subselects as operands for arithmetic operations causes NullPointerException
     * [HHH-4510] - Add column-level read/write support (HHH-4440) to annotations
     * [HHH-5490] - dirty data be inserted into 2L cache
     * [HHH-5552] - Infinispan listener implementations need to load entities and keys using application classloader.
     * [HHH-5563] - JndiInfinispanRegionFactory creates region with a stopped cache, if region previously existed
     * [HHH-5568] - correct wrong format in document
     * [HHH-5573] - Change TestCase to rebuildSessionFactory() whenever sessions var is accessed
     * [HHH-5590] - Don't log and rethrow exceptions in AbstractFlushingEventListener
     * [HHH-5591] - ConcurrentStatisticsImpl#queryExecuted() does not update queryExecutionMaxTimeQueryString
     * [HHH-5592] - org.hibernate.test.hql.ASTParserLoadingOrderByTest hangs on postgresql
     * [HHH-5593] - org.hibernate.test.legacy.FooBarTest.testCollectionWhere fails on hsqldb
     * [HHH-5594] - org.hibernate.test.jpa.lock.JPALockTest fails on hsqldb
     * [HHH-5595] - postgresql jdbc driver does not implement the setQueryTimeout method
     * [HHH-5596] - org.hibernate.test.annotations.onetoone.OneToOneTest.testPkOneToOneSelectStatementDoesNotGenerateExtraJoin() fails on postgresql
     * [HHH-5597] - org.hibernate.test.criteria.LikeTest.testLike fails on postgresql because of the default escape charactor
 
 ** Improvement
     * [HHH-5560] - Envers ValidAuditTimeStrategy needs a better name
     * [HHH-5589] - mysql does not support column check
 
 ** New Feature
     * [HHH-5190] - Provide annotation support for <discriminator>'s force and insert
     * [HHH-5205] - Add support for source="db" for timestamp versions
 
 ** Patch
     * [HHH-5581] - Improve InformixDialect sequence support
 
 
 Changes in version 3.6.0.CR1 (2010.09.15)
 -------------------------------------------
 http://opensource.atlassian.com/projects/hibernate/browse/HHH/fixforversion/11141
 
 ** Sub-task
     * [HHH-3766] - Modify the queries executed to use the "end-revision" column, when available
     * [HHH-5446] - Write an envers tutorial guide
     * [HHH-5499] - Extend AuditReader interface with findRevisions() method
 
 ** Bug
     * [HHH-5310] - orm_2_0.xsd compliant mapping files break in JEE use cases
     * [HHH-5356] - Sybase 15 does not support cross join
     * [HHH-5484] - org.hibernate.type.UUIDCharType incorrectly mapped to char and causes test fail due to the padding space
     * [HHH-5542] - Infinispan region factory uses same cache instance for all timestamp regions
     * [HHH-5545] - Resolve query cache results not up to date testsuite failures
 
 ** Improvement
     * [HHH-3709] - Add StartRevision/EndRevison fileds to audit tables
     * [HHH-5372] - Improve envers query performance by using new REVEND column
     * [HHH-5441] - Create "Getting Started Guide"
     * [HHH-5543] - JEE bootstrapping should only parse and validate mapping files once
     * [HHH-5557] - Sybase supports alias length upto 30 characters
     * [HHH-5564] - Upgrade to Infinispan 4.2.x
 
 ** Task
     * [HHH-5524] - Move tagRelease.sh into svn
 
 
 Changes in version 3.6.0.Beta4 (2010.09.01)
 -------------------------------------------
 http://opensource.atlassian.com/projects/hibernate/browse/HHH/fixforversion/11140
 
 ** Sub-task
     * [HHH-5442] - Write native tutorial chapter
     * [HHH-5444] - Write annotations tutorial chapter
     * [HHH-5445] - Write a jpa/entitymanager tutorial guide
     * [HHH-5462] - Write preface
     * [HHH-5463] - Write a community chapter
 
 ** Bug
     * [HHH-817] - Projection aliases should not be applied to where-clause (Milosz Tylenda)
     * [HHH-1189] - interfaces for Proxies are not regonized as interfaces
     * [HHH-3334] - Cascade-save breaks if parent ID is assigned (delays insert) and child has identity ID (early insert) (Wallace Wadge)
     * [HHH-5142] - Exception when initializing lazy @ManyToMany indexed collection containing not audited entities
     * [HHH-5225] - Cannot parse order-by fragment if it contains a registered function without parentheses
     * [HHH-5440] - Joined collection expressions not properly "rendered" in JPA Criteria queries
     * [HHH-5511] - Infinispan Region.destroy() impl should call cache.stop()
     * [HHH-5512] - JndiInfinispanRegionFactory shouldn't try to stop CacheManager
     * [HHH-5517] - Switch uuid generation in SessionFactory to org.hibernate.id.UUIDGenerator instead
     * [HHH-5519] - VersionedItem should not extend Item, otherwise query cache results are confusing
     * [HHH-5520] - Per org.hibernate.cache.spi.RegionFactory javadocs, implementors should be allowed to use no-arg constructor
 
 ** Deprecation
     * [HHH-5489] - Deprecate jbosscache as a second level cache provider, in favor of infinispan
 
 ** Improvement
     * [HHH-5427] - derby 10.6.1.0 native sequence support broken
     * [HHH-5507] - Add @MapKeyType annotation
     * [HHH-5509] - Leverage StandardBasicTypes internaly
     * [HHH-5515] - Upgrade to Infinispan 4.1.0.CR3
 
 ** Patch
     * [HHH-5197] - Envers documentation doesn't include the correct configuration when using Hibernate directly
     * [HHH-5453] - ByteCodeHelper.readByteCode won't load classes bigger than a constant size
 
 ** Task
     * [HHH-5502] - Upgrade to maven-jdocbook-plugin 2.3.2
     * [HHH-5505] - enable Sybase 15.5 in the test db profile
     * [HHH-5506] - rollback maven-jdocbook-plugin to 2.3.0
     * [HHH-5510] - Upgrade to maven-jdocbook-plugin 2.3.3
 
 
 Changes in version 3.6.0.Beta3 (2010.08.18)
 -------------------------------------------
 http://opensource.atlassian.com/projects/hibernate/browse/HHH/fixforversion/11133
 
 ** Sub-task
     * [HHH-5464] - Write a chapter about obtaining Hibernate
 
 ** Bug
     * [HHH-1643] - Sub-query as function parameter - either sub-query is missed from SQL or NullPointerException raised
     * [HHH-5180] - StandardQueryCache.get() does not handle EntityNotFoundException for natural key lookups
     * [HHH-5426] - HQL update/delete does not invalidate the query cache
     * [HHH-5449] - Versioned HQL update might issue incorrect SQL
     * [HHH-5469] - HHH-3659 is only half done, due to HHH-4989 (i.e. no HQL performance log when running Java 5)
     * [HHH-5473] - Default for CHECK_NULLABILITY does not allow merge retries
 
 ** Improvement
     * [HHH-5438] - Skip deployment of "irrelevant" modules
     * [HHH-5439] - Deployment of site.xml
     * [HHH-5474] - Clean up usages of now deprecated ExtendedMappings
     * [HHH-5477] - Introduce StandardBasicTypes for standard basic type constants
 
 ** Patch
     * [HHH-5300] - Configurable QueryPlanCache reference counts (Manuel Dominguez Sarmiento)
 
 ** Task
     * [HHH-5451] - deprecate cglib as bytecode provider
     * [HHH-5479] - Upgrade jDocBook plugin to 2.3.0
     * [HHH-5485] - Move hiberante dtd files from http://hibernate.sourceforge.net to http://www.hibernate.org/dtd
 
 
 Changes in version 3.6.0.Beta2 (2010.08.04)
 -------------------------------------------
 http://opensource.atlassian.com/projects/hibernate/browse/HHH/fixforversion/11132
 
 ** Bug
     * [HHH-2350] - 2nd level cache broken for non-inverse bidirectional one-to-many relation
     * [HHH-4011] - ChainedPropertyAccessor is not serializable, which breaks caching to disk and replicated caches.
     * [HHH-5097] - Bug in ParameterizedFunctionExpression with two or more parameters: IllegalArgumentException
     * [HHH-5296] - AbstractFromImpl::getJoin() shall return empty set, not null
     * [HHH-5355] - org.hibernate.test.id.uuid.sqlrep.sqlchar.UUIDCharTest errors with IngresDialect
     * [HHH-5400] - Binding BLOB values via byte[] (MaterializedBlobType) fails in 3.6 on MySQL
     * [HHH-5408] - Revise JPA compliance wording used in documentation according to Oracle policies
     * [HHH-5415] - org.hibernate.type.descriptor.java.DataHelper dumping "NClob not found" exception to stderr
     * [HHH-5425] - PropertyAccessException when caching results from a Query with a ResultTransformer that as 1 value per row
     * [HHH-5431] - Infinispan's CacheAdapterImpl.putAllowingTimeout not using silent flag
 
 ** Improvement
     * [HHH-2510] - override equals() and fix hashCode() in AliasToBeanResultTransformer
     * [HHH-5212] - Alter SQLFunction contract to be more flexible
     * [HHH-5283] - Add BasicType handling of java.net.URL
     * [HHH-5295] - Rendered JPAQL query shall be the same all the times, aliases shall not have random indexes
     * [HHH-5331] - Remove reflection calls on SessionFactory for JDK 1.5 detection in relation to Statistics
diff --git a/documentation/src/main/docbook/devguide/en-US/Database_Access.xml b/documentation/src/main/docbook/devguide/en-US/Database_Access.xml
index 5b42be5358..26862e3ddb 100644
--- a/documentation/src/main/docbook/devguide/en-US/Database_Access.xml
+++ b/documentation/src/main/docbook/devguide/en-US/Database_Access.xml
@@ -1,656 +1,656 @@
 <?xml version='1.0' encoding='utf-8' ?>
 
 <chapter xmlns="http://docbook.org/ns/docbook"
          xmlns:xlink="http://www.w3.org/1999/xlink"
          xmlns:xi="http://www.w3.org/2001/XInclude">
 
     <title>Database access</title>
 
     <section>
         <title>Connecting</title>
         <para>
             Hibernate connects to databases on behalf of your application. It can connect through a variety of mechanisms,
             including:
         </para>
         <itemizedlist>
             <listitem><para>Stand-alone built-in connection pool</para></listitem>
             <listitem><para><classname>javax.sql.DataSource</classname></para></listitem>
             <listitem><para>Connection pools, including support for two different third-party opensource JDBC connection pools:</para>
                 <itemizedlist>
                     <listitem><para>c3p0</para></listitem>
                     <listitem><para>proxool</para></listitem>
                 </itemizedlist>
             </listitem>
             <listitem>
                 <para>Application-supplied JDBC connections.  This is not a recommended approach and exists for legacy reasons</para>
             </listitem>
         </itemizedlist>
 
         <note>
             <para>The built-in connection pool is not intended for production environments.</para>
         </note>
 
         <para>
             Hibernate obtains JDBC connections as needed though the
-            <interfacename>org.hibernate.service.jdbc.connections.spi.ConnectionProvider</interfacename> interface
+            <interfacename>ConnectionProvider</interfacename> interface
             which is a service contract.  Applications may also supply their own
-            <interfacename>org.hibernate.service.jdbc.connections.spi.ConnectionProvider</interfacename> implementation
+            <interfacename>ConnectionProvider</interfacename> implementation
             to define a custom approach for supplying connections to Hibernate (from a different connection pool
             implementation, for example).
         </para>
 
         <!-- todo : discuss servies -->
 
         <section>
             <title>Configuration</title>
             <para>
                 You can configure database connections using a properties file, an XML deployment descriptor or
                 programmatically.
               </para>
                 <example>
                     <title><filename>hibernate.properties</filename> for a c3p0 connection pool</title>
                     <programlisting><xi:include href="extras/hibernate.properties" parse="text" /></programlisting>
                 </example>
                 <example>
                     <title><filename>hibernate.cfg.xml</filename> for a connection to the bundled HSQL database</title>
                     <programlisting language="XML" role="XML"><xi:include href="extras/hibernate.cfg.xml" parse="text" /></programlisting>
                 </example>
 
       <section>
         <title>Programatic configuration</title>
         <para>
           An instance of object <classname>org.hibernate.cfg.Configuration</classname> represents an entire set of
           mappings of an application's Java types to an SQL database. The
           <classname>org.hibernate.cfg.Configuration</classname> builds an immutable
           <classname>org.hibernate.SessionFactory</classname>, and compiles the mappings from various XML mapping
           files. You can specify the mapping files directly, or Hibernate can find them for you.
         </para>
         <example>
           <title>Specifying the mapping files directly</title>
           <para>
             You can obtain a <classname>org.hibernate.cfg.Configuration</classname> instance by instantiating it
             directly and specifying XML mapping documents. If the mapping files are in the classpath, use method
             <methodname>addResource()</methodname>.
           </para>
           <programlisting language="Java" role="JAVA"><xi:include href="extras/specify_mapping_files_directly.java" parse="text" /></programlisting>
         </example>
         <example>
           <title>Letting Hibernate find the mapping files for you</title>
           <para>
             The <methodname>addClass()</methodname> method directs Hibernate to search the CLASSPATH for the mapping
             files, eliminating hard-coded file names. In the following example, it searches for
             <filename>org/hibernate/auction/Item.hbm.xml</filename> and
             <filename>org/hibernate/auction/Bid.hbm.xml</filename>.
           </para>
           <programlisting language="Java" role="JAVA"><xi:include href="extras/letting_hibernate_find_mapping_files.java" parse="text" /></programlisting>
         </example>
         <example>
           <title>Specifying configuration properties</title>
           <programlisting language="Java" role="JAVA"><xi:include href="extras/specifying_configuration_properties_programmatically.java" parse="text" /></programlisting>
         </example>
         <itemizedlist>
           <title>Other ways to configure Hibernate programmatically</title>
           <listitem>
             <para>
               Pass an instance of <classname>java.util.Properties</classname> to
               <classname>Configuration.setProperties()</classname>.
             </para>
           </listitem>
           <listitem>
             <para>
               Set System properties using <command>java
               -D<replaceable>property</replaceable>=<replaceable>value</replaceable></command>
             </para>
           </listitem>
         </itemizedlist>
       </section>
     </section>
     
     <section>
         <title>Obtaining a JDBC connection</title>
         <para>
             After you configure the <xref linkend="hibernate-jdbc-properties" />, you can use method
             <methodname>openSession</methodname> of class <classname>org.hibernate.SessionFactory</classname> to open
             sessions.  Sessions will obtain JDBC connections as needed based on the provided configuration.
         </para>
         <example>
             <title>Specifying configuration properties</title>
             <programlisting language="Java" role="JAVA"><xi:include href="extras/opening_a_session.java" parse="text" /></programlisting>
         </example>
         <itemizedlist id="hibernate-jdbc-properties">
             <title>Most important Hibernate JDBC properties</title>
             <listitem><para>hibernate.connection.driver_class</para></listitem>
             <listitem><para>hibernate.connection.url</para></listitem>
             <listitem><para>hibernate.connection.username</para></listitem>
             <listitem><para>hibernate.connection.password</para></listitem>
             <listitem><para>hibernate.connection.pool_size</para></listitem>
         </itemizedlist>
         <para>
             All available Hibernate settings are defined as constants and discussed on the
             <interfacename>org.hibernate.cfg.AvailableSettings</interfacename> interface.  See its source code or
             JavaDoc for details.
         </para>
     </section>
   </section>
   
   <section>
     <title>Connection pooling</title>
     <para>
       Hibernate's internal connection pooling algorithm is rudimentary, and is provided for development and testing
       purposes. Use a third-party pool for best performance and stability. To use a third-party pool, replace the
       <property>hibernate.connection.pool_size property</property> with settings specific to your connection pool of
       choice. This disables Hibernate's internal connection pool.
     </para>
     
     <section>
       <title>c3p0 connection pool</title>
       <para>
         C3P0 is an open source JDBC connection pool distributed along with Hibernate in the <filename>lib/</filename>
         directory. Hibernate uses its <classname>org.hibernate.service.jdbc.connections.internal.C3P0ConnectionProvider</classname> for
         connection pooling if you set the <property>hibernate.c3p0.*</property> properties.  properties.
       </para>
       <itemizedlist>
         <title>Important configuration properties for the c3p0 connection pool</title>
         <listitem><para>hibernate.c3p0.min_size</para></listitem>
         <listitem><para>hibernate.c3p0.max_size</para></listitem>
         <listitem><para>hibernate.c3p0.timeout</para></listitem>
         <listitem><para>hibernate.c3p0.max_statements</para></listitem>
       </itemizedlist>
     </section>
     
     <section>
       <title>Proxool connection pool</title>
       <para>
         Proxool is another open source JDBC connection pool distributed along with Hibernate in the
         <filename>lib/</filename> directory. Hibernate uses its
         <classname>org.hibernate.service.jdbc.connections.internal.ProxoolConnectionProvider</classname> for connection pooling if you set the
         <property>hibernate.proxool.*</property> properties. Unlike c3p0, proxool requires some additional configuration
         parameters, as described by the Proxool documentation available at <link xlink:href="http://proxool.sourceforge.net/configure.html" />.
       </para>
       <table>
         <title>Important configuration properties for the Proxool connection pool</title>
         <tgroup cols="2">
           <colspec colwidth="120px" />
           <colspec colwidth="320px" />
           <thead>
             <row>
               <entry>Property</entry>
               <entry>Description</entry>
             </row>
           </thead>
           <tbody>
             <row>
               <entry>hibernate.proxool.xml</entry>
               <entry>Configure Proxool provider using an XML file (.xml is appended automatically)</entry>
             </row>
             <row>
               <entry>hibernate.proxool.properties</entry>
               <entry>Configure the Proxool provider using a properties file (.properties is appended
               automatically)</entry>
             </row>
             <row>
               <entry>hibernate.proxool.existing_pool</entry>
               <entry>Whether to configure the Proxool provider from an existing pool</entry>
             </row>
             <row>
               <entry>hibernate.proxool.pool_alias</entry>
               <entry>Proxool pool alias to use. Required.</entry>
             </row>
           </tbody>
         </tgroup>
       </table>
     </section>
 
     
     <section>
       <title>Obtaining connections from an application server, using JNDI</title>
       <para>
         To use Hibernate inside an application server, configure Hibernate to obtain connections from an application
         server <classname>javax.sql.Datasource</classname> registered in JNDI, by setting at least one of the following
         properties:
       </para>
       <itemizedlist>
         <title>Important Hibernate properties for JNDI datasources</title>
         <listitem><para>hibernate.connection.datasource (required)</para></listitem>
         <listitem><para>hibernate.jndi.url</para></listitem>
         <listitem><para>hibernate.jndi.class</para></listitem>
         <listitem><para>hibernate.connection.username</para></listitem>
         <listitem><para>hibernate.connection.password</para></listitem>
       </itemizedlist>
       <para>
         JDBC connections obtained from a JNDI datasource automatically participate in the container-managed transactions
         of the application server.
       </para>
     </section>
     
     <section>
       <title>Other connection-specific configuration</title>
       <para>
         You can pass arbitrary connection properties by prepending <literal>hibernate.connection</literal> to the
         connection property name. For example, specify a charSet connection property as
         <property>hibernate.connection.charSet</property>.
       </para>
       <para>
         You can define your own plugin strategy for obtaining JDBC connections by implementing the interface
-        <interfacename>org.hibernate.service.jdbc.connections.spi.ConnectionProvider</interfacename> and specifying your custom
+        <interfacename>ConnectionProvider</interfacename> and specifying your custom
         implementation with the <property>hibernate.connection.provider_class</property> property.
       </para>
     </section>
     
     <section>
       <title>Optional configuration properties</title>
       <para>
         In addition to the properties mentioned in the previous sections, Hibernate includes many other optional
         properties. See <xref linkend="appendix-Configuration_Properties" /> for a more complete list.
       </para>
     </section>
   </section>
   
   <section id="configuring-dialects">
     <title>Dialects</title>
     <para>
         Although SQL is relatively standardized, each database vendor uses a subset of supported syntax. This is referred
         to as a <firstterm>dialect</firstterm>.  Hibernate handles variations across these dialects through its
         <classname>org.hibernate.dialect.Dialect</classname> class and the various subclasses for each vendor dialect.
     </para>
 
     <table>
       <title>Supported database dialects</title>
       <tgroup cols="2">
         <colspec colwidth="120px" />
         <colspec colwidth="320px" />
         <thead>
           <row>
             <entry>Database</entry>
             <entry>Dialect</entry>
           </row>
         </thead>
         <tbody>
           <row>
             <entry>DB2</entry>
             <entry>org.hibernate.dialect.DB2Dialect</entry>
           </row>
           <row>
             <entry>DB2 AS/400</entry>
             <entry>org.hibernate.dialect.DB2400Dialect</entry>
           </row>
           <row>
             <entry>DB2 OS390</entry>
             <entry>org.hibernate.dialect.DB2390Dialect</entry>
           </row>
           <row>
             <entry>Firebird</entry>
             <entry>org.hibernate.dialect.FirebirdDialect</entry>
           </row>
           <row>
             <entry>FrontBase</entry>
             <entry>org.hibernate.dialect.FrontbaseDialect</entry>
           </row>
           <row>
             <entry>HypersonicSQL</entry>
             <entry>org.hibernate.dialect.HSQLDialect</entry>
           </row>
           <row>
             <entry>Informix</entry>
             <entry>org.hibernate.dialect.InformixDialect</entry>
           </row>
           <row>
             <entry>Interbase</entry>
             <entry>org.hibernate.dialect.InterbaseDialect</entry>
           </row>
           <row>
             <entry>Ingres</entry>
             <entry>org.hibernate.dialect.IngresDialect</entry>
           </row>
           <row>
             <entry>Microsoft SQL Server 2005</entry>
             <entry>org.hibernate.dialect.SQLServer2005Dialect</entry>
           </row>
           <row>
             <entry>Microsoft SQL Server 2008</entry>
             <entry>org.hibernate.dialect.SQLServer2008Dialect</entry>
           </row>
           <row>
             <entry>Mckoi SQL</entry>
             <entry>org.hibernate.dialect.MckoiDialect</entry>
           </row>
           <row>
             <entry>MySQL</entry>
             <entry>org.hibernate.dialect.MySQLDialect</entry>
           </row>
           <row>
             <entry>MySQL with InnoDB</entry>
             <entry>org.hibernate.dialect.MySQL5InnoDBDialect</entry>
           </row>
           <row>
             <entry>MySQL with MyISAM</entry>
             <entry>org.hibernate.dialect.MySQLMyISAMDialect</entry>
           </row>
           <row>
             <entry>Oracle 8i</entry>
             <entry>org.hibernate.dialect.Oracle8iDialect</entry>
           </row>
           <row>
             <entry>Oracle 9i</entry>
             <entry>org.hibernate.dialect.Oracle9iDialect</entry>
           </row>
           <row>
             <entry>Oracle 10g</entry>
             <entry>org.hibernate.dialect.Oracle10gDialect</entry>
           </row>
           <row>
             <entry>Pointbase</entry>
             <entry>org.hibernate.dialect.PointbaseDialect</entry>
           </row>
           <row>
             <entry>PostgreSQL 8.1</entry>
             <entry>org.hibernate.dialect.PostgreSQL81Dialect</entry>
           </row>
             <row>
                 <entry>PostgreSQL 8.2 and later</entry>
                 <entry>org.hibernate.dialect.PostgreSQL82Dialect</entry>
             </row>
           <row>
             <entry>Progress</entry>
             <entry>org.hibernate.dialect.ProgressDialect</entry>
           </row>
           <row>
             <entry>SAP DB</entry>
             <entry>org.hibernate.dialect.SAPDBDialect</entry>
           </row>
           <row>
             <entry>Sybase ASE 15.5</entry>
             <entry>org.hibernate.dialect.SybaseASE15Dialect</entry>
           </row>
           <row>
             <entry>Sybase ASE 15.7</entry>
             <entry>org.hibernate.dialect.SybaseASE157Dialect</entry>
           </row>
           <row>
             <entry>Sybase Anywhere</entry>
             <entry>org.hibernate.dialect.SybaseAnywhereDialect</entry>
           </row>
         </tbody>
       </tgroup>
     </table>
 
       <section>
           <title>Specifying the Dialect to use</title>
           <para>
               The developer may manually specify the Dialect to use by setting the
               <property>hibernate.dialect</property> configuration property to the name of a specific
               <classname>org.hibernate.dialect.Dialect</classname> class to use.
           </para>
       </section>
 
       <section>
           <title>Dialect resolution</title>
           <para>
-              Assuming a <interfacename>org.hibernate.service.jdbc.connections.spi.ConnectionProvider</interfacename> has been
+              Assuming a <interfacename>ConnectionProvider</interfacename> has been
               set up, Hibernate will attempt to automatically determine the Dialect to use based on the
               <interfacename>java.sql.DatabaseMetaData</interfacename> reported by a
               <interfacename>java.sql.Connection</interfacename> obtained from that
-              <interfacename>org.hibernate.service.jdbc.connections.spi.ConnectionProvider</interfacename>.
+              <interfacename>ConnectionProvider</interfacename>.
           </para>
           <para>
                 This functionality is provided by a series of
-                <interfacename>org.hibernate.service.jdbc.dialect.spi.DialectResolver</interfacename> instances registered
+                <interfacename>org.hibernate.engine.jdbc.dialect.spi.DialectResolver</interfacename> instances registered
                 with Hibernate internally.  Hibernate comes with a standard set of recognitions.  If your application
                 requires extra Dialect resolution capabilities, it would simply register a custom implementation
-                of <interfacename>org.hibernate.service.jdbc.dialect.spi.DialectResolver</interfacename> as follows:
+                of <interfacename>org.hibernate.engine.jdbc.dialect.spi.DialectResolver</interfacename> as follows:
           </para>
           <!-- document an example using the service registry -->
             <para>
-                Registered <interfacename>org.hibernate.service.jdbc.dialect.spi.DialectResolver</interfacename> are
+                Registered <interfacename>org.hibernate.engine.jdbc.dialect.spi.DialectResolver</interfacename> are
                 <emphasis>prepended</emphasis> to an internal list of resolvers, so they take precedence
                 before any already registered resolvers including the standard one.
             </para>
       </section>
   </section>
 
   <section>
     <title>Automatic schema generation with SchemaExport</title>
     <para>
       SchemaExport is a Hibernate utility which generates DDL from your mapping files. The generated schema includes
       referential integrity constraints, primary and foreign keys, for entity and collection tables. It also creates
       tables and sequences for mapped identifier generators.
     </para>
     <note>
       <para>
         You must specify a SQL Dialect via the <property>hibernate.dialect</property> property when using this tool,
         because DDL is highly vendor-specific. See <xref linkend="configuring-dialects" /> for information.
       </para>
     </note>
     <para>
       Before Hibernate can generate your schema, you must customize your mapping files.
     </para>
     
     <section>
       <title>Customizing the mapping files</title>
       <para>
         Hibernate provides several elements and attributes to customize your mapping files. They are listed in <xref
         linkend="tab-customizing-schema" />, and a logical order of customization is presented in <xref
         linkend="proc-customizing-schema" />.
       </para>
       <table id="tab-customizing-schema">
         <title>Elements and attributes provided for customizing mapping files</title>
         <tgroup cols="3">
           <colspec colwidth="80px" />
           <colspec colwidth="80px" />
           <colspec colwidth="280px" />
           <thead>
             <row>
               <entry>Name</entry>
               <entry>Type of value</entry>
               <entry>Description</entry>
             </row>
           </thead>
           <tbody>
             <row>
               <entry>length</entry>
               <entry>number</entry>
               <entry>Column length</entry>
             </row>
             <row>
               <entry>precision</entry>
               <entry>number</entry>
               <entry>Decimal precision of column</entry>
             </row>
             <row>
               <entry>scale</entry>
               <entry>number</entry>
               <entry>Decimal scale of column</entry>
             </row>
             <row>
               <entry>not-null</entry>
               <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
               <entry>Whether a column is allowed to hold null values</entry>
             </row>
             <row>
               <entry>unique</entry>
               <entry><para><literal>true</literal> or <literal>false</literal></para></entry>
               <entry>Whether values in the column must be unique</entry>
             </row>
             <row>
               <entry>index</entry>
               <entry>string</entry>
               <entry>The name of a multi-column index</entry>
             </row>
             <row>
               <entry>unique-key</entry>
               <entry>string</entry>
               <entry>The name of a multi-column unique constraint</entry>
             </row>
             <row>
               <entry>foreign-key</entry>
               <entry>string</entry>
               <entry>The name of the foreign key constraint generated for an association. This applies to
               &lt;one-to-one&gt;, &lt;many-to-one&gt;, &lt;key&gt;, and &lt;many-to-many&gt; mapping
               elements. <literal>inverse="true"</literal> sides are skipped by SchemaExport.</entry>
             </row>
             <row>
               <entry>sql-type</entry>
               <entry>string</entry>
               <entry>Overrides the default column type. This applies to the &lt;column&gt; element only.</entry>
             </row>
             <row>
               <entry>default</entry>
               <entry>string</entry>
               <entry>Default value for the column</entry>
             </row>
             <row>
               <entry>check</entry>
               <entry>string</entry>
               <entry>An SQL check constraint on either a column or atable</entry>
             </row>
           </tbody>
         </tgroup>
       </table>
       <procedure id="proc-customizing-schema">
         <title>Customizing the schema</title>
         <step>
           <title>Set the length, precision, and scale of mapping elements.</title>
           <para>
             Many Hibernate mapping elements define optional attributes named <option>length</option>,
             <option>precision</option>, and <option>scale</option>.
           </para>
           <programlisting language="XML" role="XML"><xi:include href="extras/length-precision-scale.xml" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
         </step>
         <step>
           <title>Set the <option>not-null</option>, <option>UNIQUE</option>, <option>unique-key</option> attributes.</title>
           <para>
             The <option>not-null</option> and <option>UNIQUE</option> attributes generate constraints on table columns.
           </para>
           <para>
             The unique-key attribute groups columns in a single, unique key constraint. Currently, the specified value
             of the unique-key attribute does not name the constraint in the generated DDL. It only groups the columns in
             the mapping file.
           </para>
           <programlisting language="XML" role="XML"><xi:include href="extras/notnull-unique.xml" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
         </step>
         <step>
           <title>Set the <option>index</option> and <option>foreign-key</option> attributes.</title>
           <para>
             The <option>index</option> attribute specifies the name of an index for Hibernate to create using the mapped
             column or columns. You can group multiple columns into the same index by assigning them the same index name.
           </para>
           <para>
             A foreign-key attribute overrides the name of any generated foreign key constraint.
           </para>
           <programlisting language="XML" role="XML"><xi:include href="extras/foreign-key.xml" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
         </step>
         <step>
           <title>Set child <option>&lt;column&gt;</option> elements.</title>
           <para>
             Many mapping elements accept one or more child &lt;column&gt; elements. This is particularly useful for
             mapping types involving multiple columns.
           </para>
           <programlisting language="XML" role="XML"><xi:include href="extras/child-column-elements.xml" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
         </step>
         <step>
           <title>Set the <option>default</option> attribute.</title>
           <para>
             The <option>default</option> attribute represents a default value for a column. Assign the same value to the
             mapped property before saving a new instance of the mapped class.
           </para>
           <programlisting language="XML" role="XML"><xi:include href="extras/default-attribute.xml" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
         </step>
         <step>
           <title>Set the <option>sql-type</option> attribure.</title>
           <para>
             Use the <option>sql-type</option> attribute to override the default mapping of a Hibernate type to SQL
             datatype.
           </para>
           <programlisting language="XML" role="XML"><xi:include href="extras/sql-type.xml"
           xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
         </step>
         <step>
           <title>Set the <option>check</option> attribute.</title>
           <para>
             use the <option>check</option> attribute to specify a <wordasword>check</wordasword> constraint.
           </para>
           <programlisting language="XML" role="XML"><xi:include href="extras/check.xml" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
         </step>
         <step>
           <title>Add &lt;comment&gt; elements to your schema.</title>
           <para>
             Use the &lt;comment&gt; element to specify comments for the generated schema.
           </para>
           <programlisting language="XML" role="XML"><xi:include href="extras/comments.xml" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
         </step>
       </procedure>
     </section>
 
     <section>
       <title>Running the SchemaExport tool</title>
       <para>
         The SchemaExport tool writes a DDL script to standard output, executes the DDL statements, or both.
       </para>
       <example>
         <title>SchemaExport syntax</title>
         <screen>
           java -cp hibernate_classpaths org.hibernate.tool.hbm2ddl.SchemaExport <replaceable>options</replaceable> <replaceable>mapping_files</replaceable> 
         </screen>
       </example>
       <table>
         <title>SchemaExport Options</title>
         <tgroup cols="2">
           <colspec colwidth="120px" />
           <colspec colwidth="320px" />
           <thead>
             <row>
               <entry>Option</entry>
               <entry>Description</entry>
             </row>
           </thead>
           <tbody>
             <row>
               <entry>--quiet</entry>
               <entry>do not output the script to standard output</entry>
             </row>
             <row>
               <entry>--drop</entry>
               <entry>only drop the tables</entry>
             </row>
             <row>
               <entry>--create</entry>
               <entry>only create the tables</entry>
             </row>
             <row>
               <entry>--text</entry>
               <entry>do not export to the database</entry>
             </row>
             <row>
               <entry><para>--output=<replaceable>my_schema.ddl</replaceable></para></entry>
               <entry>output the ddl script to a file</entry>
             </row>
             <row>
               <entry><para>--naming=<replaceable>eg.MyNamingStrategy</replaceable></para></entry>
               <entry>select a NamingStrategy</entry>
             </row>
             <row>
               <entry><para>--config=<replaceable>hibernate.cfg.xml</replaceable></para></entry>
               <entry>read Hibernate configuration from an XML file</entry>
             </row>
             <row>
               <entry><para>--properties=<replaceable>hibernate.properties</replaceable></para></entry>
               <entry>read database properties from a file</entry>
             </row>
             <row>
               <entry>--format</entry>
               <entry>format the generated SQL nicely in the script</entry>
             </row>
             <row>
               <entry><para>--delimiter=<replaceable>;</replaceable></para></entry>
               <entry>set an end-of-line delimiter for the script</entry>
             </row>
           </tbody>
         </tgroup>
       </table>
       <example>
         <title>Embedding SchemaExport into your application</title>
         <programlisting language="Java" role="JAVA"><xi:include href="extras/embedding_SchemaExport.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text" /></programlisting>
       </example>
     </section>
   </section>
 </chapter>
diff --git a/documentation/src/main/docbook/devguide/en-US/chapters/multitenancy/Multi_Tenancy.xml b/documentation/src/main/docbook/devguide/en-US/chapters/multitenancy/Multi_Tenancy.xml
index a5a2d0a805..b2432b96f2 100644
--- a/documentation/src/main/docbook/devguide/en-US/chapters/multitenancy/Multi_Tenancy.xml
+++ b/documentation/src/main/docbook/devguide/en-US/chapters/multitenancy/Multi_Tenancy.xml
@@ -1,307 +1,307 @@
 <?xml version='1.0' encoding='utf-8' ?>
 
 <chapter xmlns="http://docbook.org/ns/docbook"
          xmlns:xl="http://www.w3.org/1999/xlink"
          xmlns:xi="http://www.w3.org/2001/XInclude">
 
     <title>Multi-tenancy</title>
 
     <section>
         <title>What is multi-tenancy?</title>
         <para>
             The term multi-tenancy in general is applied to software development to indicate an architecture in which
             a single running instance of an application simultaneously serves multiple clients (tenants).  This is
             highly common in SaaS solutions.  Isolating information (data, customizations, etc) pertaining to the
             various tenants is a particular challenge in these systems.  This includes the data owned by each tenant
             stored in the database.  It is this last piece, sometimes called multi-tenant data, on which we will focus.
         </para>
     </section>
 
     <section>
         <title>Multi-tenant data approaches</title>
         <para>
             There are 3 main approaches to isolating information in these multi-tenant systems which goes hand-in-hand
             with different database schema definitions and JDBC setups.
         </para>
 
         <note>
             <para>
                 Each approach has pros and cons as well as specific techniques and considerations.  Such
                 topics are beyond the scope of this documentation.  Many resources exist which delve into these
                 other topics.  One example is <link xl:href="http://msdn.microsoft.com/en-us/library/aa479086.aspx"/>
                 which does a great job of covering these topics.
             </para>
         </note>
 
         <section>
             <title>Separate database</title>
 
             <mediaobject>
                 <imageobject role="html">
                     <imagedata fileref="images/multitenacy_database.png" format="PNG" align="center" />
                 </imageobject>
                 <imageobject role="fo">
                     <imagedata fileref="images/multitenacy_database.svg" format="SVG" align="center" width="17cm" />
                 </imageobject>
             </mediaobject>
 
             <para>
                 Each tenant's data is kept in a physically separate database instance.  JDBC Connections would point
                 specifically to each database, so any pooling would be per-tenant.  A general application approach
                 here would be to define a JDBC Connection pool per-tenant and to select the pool to use based on the
                 <quote>tenant identifier</quote> associated with the currently logged in user.
             </para>
         </section>
 
         <section>
             <title>Separate schema</title>
 
             <mediaobject>
                 <imageobject role="html">
                     <imagedata fileref="images/multitenacy_schema.png" format="PNG" align="center" />
                 </imageobject>
                 <imageobject role="fo">
                     <imagedata fileref="images/multitenacy_schema.svg" format="SVG" align="center" width="17cm" />
                 </imageobject>
             </mediaobject>
 
             <para>
                 Each tenant's data is kept in a distinct database schema on a single database instance.  There are 2
                 different ways to define JDBC Connections here:
                 <itemizedlist>
                     <listitem>
                         <para>
                             Connections could point specifically to each schema, as we saw with the
                             <literal>Separate database</literal> approach.  This is an option provided that
                             the driver supports naming the default schema in the connection URL or if the
                             pooling mechanism supports naming a schema to use for its Connections.  Using this
                             approach, we would have a distinct JDBC Connection pool per-tenant where the pool to use
                             would be selected based on the <quote>tenant identifier</quote> associated with the
                             currently logged in user.
                         </para>
                     </listitem>
                     <listitem>
                         <para>
                             Connections could point to the database itself (using some default schema) but
                             the Connections would be altered using the SQL <literal>SET SCHEMA</literal> (or similar)
                             command.  Using this approach, we would have a single JDBC Connection pool for use to
                             service all tenants, but before using the Connection it would be altered to reference
                             the schema named by the <quote>tenant identifier</quote> associated with the currently
                             logged in user.
                         </para>
                     </listitem>
                 </itemizedlist>
             </para>
         </section>
 
         <section>
             <title>Partitioned (discriminator) data</title>
 
             <mediaobject>
                 <imageobject role="html">
                     <imagedata fileref="images/multitenacy_discriminator.png" format="PNG" align="center" />
                 </imageobject>
                 <imageobject role="fo">
                     <imagedata fileref="images/multitenacy_discriminator.svg" format="SVG" align="center" width="17cm" />
                 </imageobject>
             </mediaobject>
 
             <para>
                 All data is kept in a single database schema.  The data for each tenant is partitioned by the use of
                 partition value or discriminator.  The complexity of this discriminator might range from a simple
                 column value to a complex SQL formula.  Again, this approach would use a single Connection pool
                 to service all tenants.  However, in this approach the application needs to alter each and every
                 SQL statement sent to the database to reference the <quote>tenant identifier</quote> discriminator.
             </para>
         </section>
     </section>
 
     <section>
         <title>Multi-tenancy in Hibernate</title>
         <para>
             Using Hibernate with multi-tenant data comes down to both an API and then integration piece(s).  As
             usual Hibernate strives to keep the API simple and isolated from any underlying integration complexities.
             The API is really just defined by passing the tenant identifier as part of opening any session.
         </para>
         <example id="specifying-tenant-ex">
             <title>Specifying tenant identifier from <interfacename>SessionFactory</interfacename></title>
             <programlisting role="JAVA"><xi:include href="extras/tenant-identifier-from-SessionFactory.java" parse="text"/></programlisting>
         </example>
         <para>
             Additionally, when specifying configuration, a <classname>org.hibernate.MultiTenancyStrategy</classname>
             should be named using the <property>hibernate.multiTenancy</property> setting.  Hibernate will perform
             validations based on the type of strategy you specify.  The strategy here correlates to the isolation
             approach discussed above.
         </para>
         <variablelist>
             <varlistentry>
                 <term>NONE</term>
                 <listitem>
                     <para>
                         (the default) No multi-tenancy is expected.  In fact, it is considered an error if a tenant
                         identifier is specified when opening a session using this strategy.
                     </para>
                 </listitem>
             </varlistentry>
             <varlistentry>
                 <term>SCHEMA</term>
                 <listitem>
                     <para>
                         Correlates to the separate schema approach.  It is an error to attempt to open a session without
                         a tenant identifier using this strategy.  Additionally, a
-                        <interfacename>org.hibernate.service.jdbc.connections.spi.MultiTenantConnectionProvider</interfacename>
+                        <interfacename>MultiTenantConnectionProvider</interfacename>
                         must be specified.
                     </para>
                 </listitem>
             </varlistentry>
             <varlistentry>
                 <term>DATABASE</term>
                 <listitem>
                     <para>
                         Correlates to the separate database approach.  It is an error to attempt to open a session without
                         a tenant identifier using this strategy.  Additionally, a
-                        <interfacename>org.hibernate.service.jdbc.connections.spi.MultiTenantConnectionProvider</interfacename>
+                        <interfacename>MultiTenantConnectionProvider</interfacename>
                         must be specified.
                     </para>
                 </listitem>
             </varlistentry>
             <varlistentry>
                 <term>DISCRIMINATOR</term>
                 <listitem>
                     <para>
                         Correlates to the partitioned (discriminator) approach.  It is an error to attempt to open a
                         session without a tenant identifier using this strategy.  This strategy is not yet implemented
                         in Hibernate as of 4.0 and 4.1.  Its support is planned for 5.0.
                     </para>
                 </listitem>
             </varlistentry>
         </variablelist>
 
         <section>
             <title><interfacename>MultiTenantConnectionProvider</interfacename></title>
             <para>
                 When using either the DATABASE or SCHEMA approach, Hibernate needs to be able to obtain Connections
                 in a tenant specific manner.  That is the role of the
-                <interfacename>org.hibernate.service.jdbc.connections.spi.MultiTenantConnectionProvider</interfacename>
+                <interfacename>MultiTenantConnectionProvider</interfacename>
                 contract.  Application developers will need to provide an implementation of this
                 contract.  Most of its methods are extremely self-explanatory.  The only ones which might not be are
                 <methodname>getAnyConnection</methodname> and <methodname>releaseAnyConnection</methodname>.  It is
                 important to note also that these methods do not accept the tenant identifier.  Hibernate uses these
                 methods during startup to perform various configuration, mainly via the
                 <classname>java.sql.DatabaseMetaData</classname> object.
             </para>
             <para>
                 The <interfacename>MultiTenantConnectionProvider</interfacename> to use can be specified in a number of
                 ways:
             </para>
             <itemizedlist>
                 <listitem>
                     <para>
                         Use the <property>hibernate.multi_tenant_connection_provider</property> setting.  It could
                         name a <interfacename>MultiTenantConnectionProvider</interfacename> instance, a
                         <interfacename>MultiTenantConnectionProvider</interfacename> implementation class reference or
                         a <interfacename>MultiTenantConnectionProvider</interfacename> implementation class name.
                     </para>
                 </listitem>
                 <listitem>
                     <para>
-                        Passed directly to the <classname>org.hibernate.service.ServiceRegistryBuilder</classname>.
+                        Passed directly to the <classname>org.hibernate.boot.registry.StandardServiceRegistryBuilder</classname>.
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         If none of the above options match, but the settings do specify a
                         <property>hibernate.connection.datasource</property> value, Hibernate will assume it should
                         use the specific
-                        <classname>org.hibernate.service.jdbc.connections.spi.DataSourceBasedMultiTenantConnectionProviderImpl</classname>
+                        <classname>DataSourceBasedMultiTenantConnectionProviderImpl</classname>
                         implementation which works on a number of pretty reasonable assumptions when running inside of
                         an app server and using one <interfacename>javax.sql.DataSource</interfacename> per tenant.
                         See its javadocs for more details.
                     </para>
                 </listitem>
             </itemizedlist>
         </section>
 
         <section>
             <title><interfacename>CurrentTenantIdentifierResolver</interfacename></title>
             <para>
                 <interfacename>org.hibernate.context.spi.CurrentTenantIdentifierResolver</interfacename> is a contract
                 for Hibernate to be able to resolve what the application considers the current tenant identifier.
                 The implementation to use is either passed directly to <classname>Configuration</classname> via its
                 <methodname>setCurrentTenantIdentifierResolver</methodname> method.  It can also be specified via
                 the <property>hibernate.tenant_identifier_resolver</property> setting.
             </para>
             <para>
                 There are 2 situations where <interfacename>CurrentTenantIdentifierResolver</interfacename> is used:
             </para>
             <itemizedlist>
                 <listitem>
                     <para>
                         The first situation is when the application is using the
                         <interfacename>org.hibernate.context.spi.CurrentSessionContext</interfacename> feature in
                         conjunction with multi-tenancy.  In the case of the current-session feature,  Hibernate will
                         need to open a session if it cannot find an existing one in scope.  However, when a session
                         is opened in a multi-tenant environment the tenant identifier has to be specified.  This is
                         where the <interfacename>CurrentTenantIdentifierResolver</interfacename> comes into play;
                         Hibernate will consult the implementation you provide to determine the tenant identifier to use
                         when opening the session.  In this case, it is required that a
                         <interfacename>CurrentTenantIdentifierResolver</interfacename> be supplied.
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         The other situation is when you do not want to have to explicitly specify the tenant
                         identifier all the time as we saw in <xref linkend="specifying-tenant-ex"/>.  If a
                         <interfacename>CurrentTenantIdentifierResolver</interfacename> has been specified, Hibernate
                         will use it to determine the default tenant identifier to use when opening the session.
                     </para>
                 </listitem>
             </itemizedlist>
             <para>
                 Additionally, if the <interfacename>CurrentTenantIdentifierResolver</interfacename> implementation
                 returns <literal>true</literal> for its <methodname>validateExistingCurrentSessions</methodname>
                 method, Hibernate will make sure any existing sessions that are found in scope have a matching
                 tenant identifier.  This capability is only pertinent when the
                 <interfacename>CurrentTenantIdentifierResolver</interfacename> is used in current-session settings.
             </para>
         </section>
 
         <section>
             <title>Caching</title>
             <para>
                 Multi-tenancy support in Hibernate works seamlessly with the Hibernate second level cache.  The key
                 used to cache data encodes the tenant identifier.
             </para>
         </section>
 
         <section>
             <title>Odds and ends</title>
             <para>
                 Currently schema export will not really work with multi-tenancy.  That may not change.
             </para>
             <para>
                 The JPA expert group is in the process of defining multi-tenancy support for the upcoming 2.1
                 version of the specification.
             </para>
         </section>
     </section>
 
     <section>
         <title>Strategies for <interfacename>MultiTenantConnectionProvider</interfacename> implementors</title>
         <example>
             <title>Implementing MultiTenantConnectionProvider using different connection pools</title>
             <programlisting role="JAVA"><xi:include href="extras/MultiTenantConnectionProviderImpl-multi-cp.java" parse="text"/></programlisting>
         </example>
         <para>
             The approach above is valid for the DATABASE approach.  It is also valid for the SCHEMA approach
             provided the underlying database allows naming the schema to which to connect in the connection URL.
         </para>
         <example>
             <title>Implementing MultiTenantConnectionProvider using single connection pool</title>
             <programlisting role="JAVA"><xi:include href="extras/MultiTenantConnectionProviderImpl-single-cp.java" parse="text"/></programlisting>
         </example>
         <para>
             This approach is only relevant to the SCHEMA approach.
         </para>
     </section>
 </chapter>
\ No newline at end of file
diff --git a/documentation/src/main/docbook/devguide/en-US/chapters/services/Services.xml b/documentation/src/main/docbook/devguide/en-US/chapters/services/Services.xml
index a27e79f6d7..cb40a52da8 100644
--- a/documentation/src/main/docbook/devguide/en-US/chapters/services/Services.xml
+++ b/documentation/src/main/docbook/devguide/en-US/chapters/services/Services.xml
@@ -1,1100 +1,1100 @@
 <?xml version='1.0' encoding='utf-8' ?>
 
 <chapter xmlns="http://docbook.org/ns/docbook"
          xmlns:xi="http://www.w3.org/2001/XInclude">
 
     <title>Services</title>
 
     <section>
         <title>What are services?</title>
         <para>
             Services are classes that provide Hibernate with pluggable implementations of various types of
             functionality.  Specifically they are implementations of certain service contract interfaces.  The interface
             is known as the service role; the implementation class is know as the service implementation.  Generally
             speaking, users can plug in alternate implementations of all standard service roles (overriding); they can
             also define additional services beyond the base set of service roles (extending).
         </para>
     </section>
 
     <section>
         <title>Service contracts</title>
         <para>
             The basic requirement for a service is to implement the marker interface
             <interfacename>org.hibernate.service.Service</interfacename>.  Hibernate uses this internally for some
             basic type safety.
         </para>
         <para>
             Optionally, the service can also implement the
             <interfacename>org.hibernate.service.spi.Startable</interfacename> and
             <interfacename>org.hibernate.service.spi.Stoppable</interfacename> interfaces to receive notifications
             of being started and stopped.  Another optional service contract is
             <interfacename>org.hibernate.service.spi.Manageable</interfacename> which marks the service as manageable
             in JMX provided the JMX integration is enabled.
         </para>
     </section>
 
     <section>
         <title>Service dependencies</title>
         <para>
             Services are allowed to declare dependencies on other services using either of 2 approaches.
         </para>
         <section>
             <title>@<interfacename>org.hibernate.service.spi.InjectService</interfacename></title>
             <para>
                 Any method on the service implementation class accepting a single parameter and annotated with
                 @<interfacename>InjectService</interfacename> is considered requesting injection of another service.
             </para>
             <para>
                 By default the type of the method parameter is expected to be the service role to be injected.  If the
                 parameter type is different than the service role, the <methodname>serviceRole</methodname> attribute
                 of the <interfacename>InjectService</interfacename> should be used to explicitly name the role.
             </para>
             <para>
                 By default injected services are considered required, that is the start up will fail if a named
                 dependent service is missing.  If the service to be injected is optional, the
                 <methodname>required</methodname> attribute of the <interfacename>InjectService</interfacename>
                 should be declared as <literal>false</literal> (default is <literal>true</literal>).
             </para>
         </section>
         <section>
             <title><interfacename>org.hibernate.service.spi.ServiceRegistryAwareService</interfacename></title>
             <para>
                 The second approach is a pull approach where the service implements the optional service interface
                 <interfacename>org.hibernate.service.spi.ServiceRegistryAwareService</interfacename> which declares
                 a single <methodname>injectServices</methodname> method.  During startup, Hibernate will inject the
                 <interfacename>org.hibernate.service.ServiceRegistry</interfacename> itself into services which
                 implement this interface.  The service can then use the <interfacename>ServiceRegistry</interfacename>
                 reference to locate any additional services it needs.
             </para>
         </section>
     </section>
 
     <section xml:id="services-registry">
         <title>ServiceRegistry</title>
         <para>
             The central service API, aside from the services themselves, is the
             <interfacename>org.hibernate.service.ServiceRegistry</interfacename> interface. The main purpose of
             a service registry is to hold, manage and provide access to services.
         </para>
         <para>
             Service registries are hierarchical.  Services in one registry can depend on and utilize services in that
             same registry as well as any parent registries.
         </para>
         <para>
-            Use <classname>org.hibernate.service.ServiceRegistryBuilder</classname> to build a
+            Use <classname>org.hibernate.boot.registry.StandardServiceRegistryBuilder</classname> to build a
             <interfacename>org.hibernate.service.ServiceRegistry</interfacename> instance.
         </para>
     </section>
 
 
     <section>
         <title>Standard services</title>
 
         <section xml:id="services-BatchBuilder">
             <title><interfacename>org.hibernate.engine.jdbc.batch.spi.BatchBuilder</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Defines strategy for how Hibernate manages JDBC statement batching
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.engine.jdbc.batch.internal.BatchBuilderInitiator</classname>
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl</classname>
                         </para>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-ConfigurationService">
-            <title><interfacename>org.hibernate.service.config.spi.ConfigurationService</interfacename></title>
+            <title><interfacename>org.hibernate.engine.config.spi.ConfigurationService</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Provides access to the configuration settings, combining those explicitly provided as well
                             as those contributed by any registered
                             <interfacename>org.hibernate.integrator.spi.Integrator</interfacename> implementations
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
-                            <classname>org.hibernate.service.config.internal.ConfigurationServiceInitiator</classname>
+                            <classname>org.hibernate.engine.config.internal.ConfigurationServiceInitiator</classname>
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <para>
-                            <classname>org.hibernate.service.config.internal.ConfigurationServiceImpl</classname>
+                            <classname>org.hibernate.engine.config.internal.ConfigurationServiceImpl</classname>
                         </para>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-ConnectionProvider">
-            <title><interfacename>org.hibernate.service.jdbc.connections.spi.ConnectionProvider</interfacename></title>
+            <title><interfacename>ConnectionProvider</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Defines the means in which Hibernate can obtain and release
                             <interfacename>java.sql.Connection</interfacename> instances for its use.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
-                            <classname>org.hibernate.service.jdbc.connections.internal.ConnectionProviderInitiator</classname>
+                            <classname>ConnectionProviderInitiator</classname>
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <itemizedlist>
                             <listitem>
                                 <para>
                                     <classname>org.hibernate.service.jdbc.connections.internal.C3P0ConnectionProvider</classname> -
                                     provides connection pooling based on integration with the C3P0 connection pooling library
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jdbc.connections.internal.DatasourceConnectionProviderImpl</classname> -
+                                    <classname>DatasourceConnectionProviderImpl</classname> -
                                     provides connection managed delegated to a
                                     <interfacename>javax.sql.DataSource</interfacename>
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jdbc.connections.internal.DriverManagerConnectionProviderImpl</classname> -
+                                    <classname>DriverManagerConnectionProviderImpl</classname> -
                                     provides rudimentary connection pooling based on simple custom pool.  Note intended
                                     production use!
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
                                     <classname>org.hibernate.service.jdbc.connections.internal.ProxoolConnectionProvider</classname> -
                                     provides connection pooling based on integration with the proxool connection pooling library
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jdbc.connections.internal.UserSuppliedConnectionProviderImpl</classname> -
+                                    <classname>UserSuppliedConnectionProviderImpl</classname> -
                                     Provides no connection support.  Indicates the user will supply connections to Hibernate directly.
                                     Not recommended for use.
                                 </para>
                             </listitem>
                         </itemizedlist>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-DialectFactory">
-            <title><interfacename>org.hibernate.service.jdbc.dialect.spi.DialectFactory</interfacename></title>
+            <title><interfacename>org.hibernate.engine.jdbc.dialect.spi.DialectFactory</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Contract for Hibernate to obtain <classname>org.hibernate.dialect.Dialect</classname>
                             instance to use.  This is either explicitly defined by the
                             <property>hibernate.dialect</property> property or determined by the
                             <xref linkend="services-DialectResolver"/> service which is a delegate to this service.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
-                            <classname>org.hibernate.service.jdbc.dialect.internal.DialectFactoryInitiator</classname>
+                            <classname>org.hibernate.engine.jdbc.dialect.internal.DialectFactoryInitiator</classname>
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <para>
-                            <classname>org.hibernate.service.jdbc.dialect.internal.DialectFactoryImpl</classname>
+                            <classname>org.hibernate.engine.jdbc.dialect.internal.DialectFactoryImpl</classname>
                         </para>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-DialectResolver">
-            <title><interfacename>org.hibernate.service.jdbc.dialect.spi.DialectResolver</interfacename></title>
+            <title><interfacename>org.hibernate.engine.jdbc.dialect.spi.DialectResolver</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Provides resolution of <classname>org.hibernate.dialect.Dialect</classname> to use based on
                             information extracted from JDBC metadata.
                         </para>
                         <para>
                             The standard resolver implementation acts as a chain, delegating to a series of individual
                             resolvers.  The standard Hibernate resolution behavior is contained in
-                            <classname>org.hibernate.service.jdbc.dialect.internal.StandardDialectResolver</classname>.
-                            <classname>org.hibernate.service.jdbc.dialect.internal.DialectResolverInitiator</classname>
+                            <classname>org.hibernate.engine.jdbc.dialect.internal.StandardDialectResolver</classname>.
+                            <classname>org.hibernate.engine.jdbc.dialect.internal.DialectResolverInitiator</classname>
                             also consults with the <property>hibernate.dialect_resolvers</property> setting for any
                             custom resolvers.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
-                            <classname>org.hibernate.service.jdbc.dialect.internal.DialectResolverInitiator</classname>
+                            <classname>org.hibernate.engine.jdbc.dialect.internal.DialectResolverInitiator</classname>
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <para>
-                            <classname>org.hibernate.service.jdbc.dialect.internal.DialectResolverSet</classname>
+                            <classname>org.hibernate.engine.jdbc.dialect.internal.DialectResolverSet</classname>
                         </para>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-JdbcServices">
             <title><interfacename>org.hibernate.engine.jdbc.spi.JdbcServices</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Special type of service that aggregates together a number of other services and provides
                             a higher-level set of functionality.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.engine.jdbc.internal.JdbcServicesInitiator</classname>
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.engine.jdbc.internal.JdbcServicesImpl</classname>
                         </para>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-JmxService">
-            <title><interfacename>org.hibernate.service.jmx.spi.JmxService</interfacename></title>
+            <title><interfacename>org.hibernate.jmx.spi.JmxService</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Provides simplified access to JMX related features needed by Hibernate.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
-                            <classname>org.hibernate.service.jmx.internal.JmxServiceInitiator</classname>
+                            <classname>org.hibernate.jmx.internal.JmxServiceInitiator</classname>
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <itemizedlist>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jmx.internal.DisabledJmxServiceImpl</classname> -
+                                    <classname>org.hibernate.jmx.internal.DisabledJmxServiceImpl</classname> -
                                     A no-op implementation when JMX functionality is disabled.
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jmx.internal.JmxServiceImpl</classname> -
+                                    <classname>org.hibernate.jmx.internal.JmxServiceImpl</classname> -
                                     Standard implementation of JMX handling
                                 </para>
                             </listitem>
                         </itemizedlist>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-JndiService">
-            <title><interfacename>org.hibernate.service.jndi.spi.JndiService</interfacename></title>
+            <title><interfacename>org.hibernate.engine.jndi.spi.JndiService</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Provides simplified access to JNDI related features needed by Hibernate.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
-                            <classname>org.hibernate.service.jndi.internal.JndiServiceInitiator</classname>
+                            <classname>org.hibernate.engine.jndi.internal.JndiServiceInitiator</classname>
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <para>
-                            <classname>org.hibernate.service.jndi.internal.JndiServiceImpl</classname>
+                            <classname>org.hibernate.engine.jndi.internal.JndiServiceImpl</classname>
                         </para>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-JtaPlatform">
-            <title><interfacename>org.hibernate.service.jta.platform.spi.JtaPlatform</interfacename></title>
+            <title><interfacename>org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Provides an abstraction from the underlying JTA platform when JTA features are used.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
-                            <classname>org.hibernate.service.jta.platform.internal.JtaPlatformInitiator</classname>
+                            <classname>org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformInitiator</classname>
                         </para>
                         <important>
                             <para>
                                 <classname>JtaPlatformInitiator</classname> provides mapping against the legacy,
                                 now-deprecated <interfacename>org.hibernate.transaction.TransactionManagerLookup</interfacename>
                                 names internally for the Hibernate-provided
                                 <interfacename>org.hibernate.transaction.TransactionManagerLookup</interfacename>
                                 implementations.
                             </para>
                         </important>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <itemizedlist>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.BitronixJtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.BitronixJtaPlatform</classname> -
                                     Integration with the Bitronix stand-alone transaction manager.
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.BorlandEnterpriseServerJtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.BorlandEnterpriseServerJtaPlatform</classname> -
                                     Integration with the transaction manager as deployed within a Borland Enterprise Server
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.JBossAppServerJtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.JBossAppServerJtaPlatform</classname> -
                                     Integration with the transaction manager as deployed within a JBoss Application Server
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.JBossStandAloneJtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.JBossStandAloneJtaPlatform</classname> -
                                     Integration with the JBoss Transactions stand-alone transaction manager
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.JOTMJtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.JOTMJtaPlatform</classname> -
                                     Integration with the JOTM stand-alone transaction manager
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.JOnASJtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.JOnASJtaPlatform</classname> -
                                     Integration with the JOnAS transaction manager.
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.JRun4JtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.JRun4JtaPlatform</classname> -
                                     Integration with the transaction manager as deployed in a JRun 4 application server.
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.NoJtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform</classname> -
                                     No-op version when no JTA set up is configured
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.OC4JJtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.OC4JJtaPlatform</classname> -
                                     Integration with transaction manager as deployed in an OC4J (Oracle) application
                                     server.
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.OrionJtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.OrionJtaPlatform</classname> -
                                     Integration with transaction manager as deployed in an Orion application server.
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.ResinJtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.ResinJtaPlatform</classname> -
                                     Integration with transaction manager as deployed in a Resin application server.
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.SunOneJtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.SunOneJtaPlatform</classname> -
                                     Integration with transaction manager as deployed in a Sun ONE (7 and above)
                                     application server.
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.TransactionManagerLookupBridge</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.TransactionManagerLookupBridge</classname> -
                                     Provides a bridge to legacy (and deprecated)
                                     <interfacename>org.hibernate.transaction.TransactionManagerLookup</interfacename>
                                     implementations
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.WebSphereExtendedJtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.WebSphereExtendedJtaPlatform</classname> -
                                     Integration with transaction manager as deployed in a WebSphere Application Server
                                     (6 and above).
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.WebSphereJtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.WebSphereJtaPlatform</classname> -
                                     Integration with transaction manager as deployed in a WebSphere Application Server
                                     (4, 5.0 and 5.1).
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
-                                    <classname>org.hibernate.service.jta.platform.internal.WeblogicJtaPlatform</classname> -
+                                    <classname>org.hibernate.engine.transaction.jta.platform.internal.WeblogicJtaPlatform</classname> -
                                     Integration with transaction manager as deployed in a Weblogic application server.
                                 </para>
                             </listitem>
                         </itemizedlist>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-MultiTenantConnectionProvider">
-            <title><interfacename>org.hibernate.service.jdbc.connections.spi.MultiTenantConnectionProvider</interfacename></title>
+            <title><interfacename>MultiTenantConnectionProvider</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             A variation of <xref linkend="services-ConnectionProvider"/> providing access to JDBC
                             connections in multi-tenant environments.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
                             N/A
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <para>
                             Intended that users provide appropriate implementation if needed.
                         </para>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-PersisterClassResolver">
             <title><interfacename>org.hibernate.persister.spi.PersisterClassResolver</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Contract for determining the appropriate
                             <interfacename>org.hibernate.persister.entity.EntityPersister</interfacename>
                             or <interfacename>org.hibernate.persister.collection.CollectionPersister</interfacename>
                             implementation class to use given an entity or collection mapping.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.persister.internal.PersisterClassResolverInitiator</classname>
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.persister.internal.StandardPersisterClassResolver</classname>
                         </para>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-PersisterFactory">
             <title><interfacename>org.hibernate.persister.spi.PersisterFactory</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Factory for creating
                             <interfacename>org.hibernate.persister.entity.EntityPersister</interfacename>
                             and <interfacename>org.hibernate.persister.collection.CollectionPersister</interfacename>
                             instances.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.persister.internal.PersisterFactoryInitiator</classname>
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.persister.internal.PersisterFactoryImpl</classname>
                         </para>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-RegionFactory">
             <title><interfacename>org.hibernate.cache.spi.RegionFactory</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Integration point for Hibernate's second level cache support.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.cache.internal.RegionFactoryInitiator</classname>
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <itemizedlist>
                             <listitem>
                                 <para>
                                     <classname>org.hibernate.cache.ehcache.EhCacheRegionFactory</classname>
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
                                     <classname>org.hibernate.cache.infinispan.InfinispanRegionFactory</classname>
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
                                     <classname>org.hibernate.cache.infinispan.JndiInfinispanRegionFactory</classname>
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
                                     <classname>org.hibernate.cache.internal.NoCachingRegionFactory</classname>
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
                                     <classname>org.hibernate.cache.ehcache.SingletonEhCacheRegionFactory</classname>
                                 </para>
                             </listitem>
                         </itemizedlist>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-SessionFactoryServiceRegistryFactory">
             <title><interfacename>org.hibernate.service.spi.SessionFactoryServiceRegistryFactory</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Factory for creating
                             <interfacename>org.hibernate.service.spi.SessionFactoryServiceRegistry</interfacename>
                             instances which acts as a specialized
                             <interfacename>org.hibernate.service.ServiceRegistry</interfacename> for
                             <interfacename>org.hibernate.SessionFactory</interfacename> scoped services.  See
                             <xref linkend="services-registry-sessionfactory"/> for more details.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.service.internal.SessionFactoryServiceRegistryFactoryInitiator</classname>
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.service.internal.SessionFactoryServiceRegistryFactoryImpl</classname>
                         </para>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-Statistics">
             <title><interfacename>org.hibernate.stat.Statistics</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Contract for exposing collected statistics.  The statistics are collected through the
                             <interfacename>org.hibernate.stat.spi.StatisticsImplementor</interfacename> contract.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.stat.internal.StatisticsInitiator</classname>
                         </para>
                         <para>
                             Defines a <property>hibernate.stats.factory</property> setting to allow
                             configuring the
                             <interfacename>org.hibernate.stat.spi.StatisticsFactory</interfacename> to use internally
                             when building the actual
                             <interfacename>org.hibernate.stat.Statistics</interfacename> instance.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.stat.internal.ConcurrentStatisticsImpl</classname>
                         </para>
                         <para>
                             The default <interfacename>org.hibernate.stat.spi.StatisticsFactory</interfacename>
                             implementation builds a
                             <classname>org.hibernate.stat.internal.ConcurrentStatisticsImpl</classname> instance.
                         </para>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-TransactionFactory">
             <title><interfacename>org.hibernate.engine.transaction.spi.TransactionFactory</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Strategy defining how Hibernate's <interfacename>org.hibernate.Transaction</interfacename>
                             API maps to the underlying transaction approach.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.engine.transaction.internal.TransactionFactoryInitiator</classname>
                         </para>
                         <para>
                             Defines a <property>hibernate.transaction.factory_class</property> setting to allow
                             configuring which <interfacename>TransactionFactory</interfacename> to use.
                             <property>hibernate.transaction.factory_class</property> follows the rules set forth
                             under <xref linkend="config-strategy"/>.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <itemizedlist>
                             <listitem>
                                 <para>
                                     <classname>org.hibernate.engine.transaction.internal.jdbc.JdbcTransactionFactory</classname> -
                                     A non-JTA strategy in which the transactions are managed using the JDBC
                                     <interfacename>java.sql.Connection</interfacename>.  This implementation's short
                                     name is <property>jdbc</property>.
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
                                     <classname>org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory</classname> -
                                     A JTA-based strategy in which Hibernate is not controlling the transactions.  An
                                     important distinction here is that interaction with the underlying JTA implementation
                                     is done through the
                                     <interfacename>javax.transaction.TransactionManager</interfacename>.  This
                                     implementation's short name is <property>cmt</property>.
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
                                     <classname>org.hibernate.engine.transaction.internal.jta.JtaTransactionFactory</classname> -
                                     A JTA-based strategy in which Hibernate *may* be controlling the transactions.  An
                                     important distinction here is that interaction with the underlying JTA
                                     implementation is done through the
                                     <interfacename>javax.transaction.UserTransaction</interfacename>.  This
                                     implementation's short name is <property>jta</property>.
                                 </para>
                             </listitem>
                         </itemizedlist>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
         <section xml:id="services-ImportSqlCommandExtractor">
             <title><interfacename>org.hibernate.tool.hbm2ddl.ImportSqlCommandExtractor</interfacename></title>
             <variablelist>
                 <varlistentry>
                     <term>Notes</term>
                     <listitem>
                         <para>
                             Contract for extracting statements from <literal>import.sql</literal> scripts.
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Initiator</term>
                     <listitem>
                         <para>
                             <classname>org.hibernate.tool.hbm2ddl.ImportSqlCommandExtractorInitiator</classname>
                         </para>
                     </listitem>
                 </varlistentry>
                 <varlistentry>
                     <term>Implementations</term>
                     <listitem>
                         <itemizedlist>
                             <listitem>
                                 <para>
                                     <classname>org.hibernate.tool.hbm2ddl.SingleLineSqlCommandExtractor</classname>
                                     treats each line as a complete SQL statement. Comment lines shall start with
                                     <literal>--</literal>, <literal>//</literal> or <literal>/*</literal> character
                                     sequence.
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
                                     <classname>org.hibernate.tool.hbm2ddl.MultipleLinesSqlCommandExtractor</classname>
                                     supports instructions/comments and quoted strings spread over multiple lines. Each
                                     statement must end with semicolon.
                                 </para>
                             </listitem>
                         </itemizedlist>
                     </listitem>
                 </varlistentry>
             </variablelist>
         </section>
 
     </section>
 
 
     <section>
         <title>Custom services</title>
         <para>
             Once a <interfacename>org.hibernate.service.ServiceRegistry</interfacename> is built it is considered
             immutable; the services themselves might accept re-configuration, but immutability here means
             adding/replacing services.  So another role provided by the
-            <classname>org.hibernate.service.ServiceRegistryBuilder</classname> is to allow tweaking of the services
+            <classname>org.hibernate.boot.registry.StandardServiceRegistryBuilder</classname> is to allow tweaking of the services
             that will be contained in the <interfacename>org.hibernate.service.ServiceRegistry</interfacename>
             generated from it.
         </para>
         <para>
-            There are 2 means to tell a <classname>org.hibernate.service.ServiceRegistryBuilder</classname> about
+            There are 2 means to tell a <classname>org.hibernate.boot.registry.StandardServiceRegistryBuilder</classname> about
             custom services.
         </para>
         <itemizedlist>
             <listitem>
                 <para>
-                    Implement a <interfacename>org.hibernate.service.spi.BasicServiceInitiator</interfacename> class
+                    Implement a <interfacename>org.hibernate.boot.registry.StandardServiceInitiator</interfacename> class
                     to control on-demand construction of the service class and add it to the
-                    <classname>org.hibernate.service.ServiceRegistryBuilder</classname> via its
+                    <classname>org.hibernate.boot.registry.StandardServiceRegistryBuilder</classname> via its
                     <methodname>addInitiator</methodname> method.
                 </para>
             </listitem>
             <listitem>
                 <para>
                     Just instantiate the service class and add it to the
-                    <classname>org.hibernate.service.ServiceRegistryBuilder</classname> via its
+                    <classname>org.hibernate.boot.registry.StandardServiceRegistryBuilder</classname> via its
                     <methodname>addService</methodname> method.
                 </para>
             </listitem>
         </itemizedlist>
         <para>
             Either approach the adding a service approach or the adding an initiator approach are valid for extending a
             registry (adding new service roles) and overriding services (replacing service implementations).
         </para>
     </section>
 
 
     <section>
         <title>Special service registries</title>
 
         <section xml:id="services-registry-bootstrap">
             <title>Boot-strap registry</title>
             <para>
                 The boot-strap registry holds services that absolutely have to be available for most things to work.
                 The main service here is the <xref linkend="services-ClassLoaderService"/> which is a perfect example.
                 Even resolving configuration files needs access to class loading services (resource look ups).  This
                 is the root registry (no parent) in normal use.
             </para>
 
             <para>
                 Instances of boot-strap registries are built using the
-                <classname>org.hibernate.service.BootstrapServiceRegistryBuilder</classname> class.
+                <classname>org.hibernate.boot.registry.BootstrapServiceRegistryBuilder</classname> class.
             </para>
 
             <example xml:id="BootstrapServiceRegistryBuilder-example">
                 <title>Using BootstrapServiceRegistryBuilder</title>
                 <programlisting role="JAVA"><xi:include href="extras/BootstrapServiceRegistryBuilder-example.java" parse="text"/></programlisting>
             </example>
 
             <section id="services-registry-bootstrap-services">
                 <title>Bootstrap registry services</title>
                 <section id="services-ClassLoaderService">
-                    <title><interfacename>org.hibernate.service.classloading.spi.ClassLoaderService</interfacename></title>
+                    <title><interfacename>org.hibernate.boot.registry.classloading.spi.ClassLoaderService</interfacename></title>
                     <para>
                         Hibernate needs to interact with ClassLoaders.  However, the manner in which Hibernate
                         (or any library) should interact with ClassLoaders varies based on the runtime environment
                         which is hosting the application.  Application servers, OSGi containers, and other modular
                         class loading systems impose very specific class-loading requirements.  This service is provides
                         Hibernate an abstraction from this environmental complexity.  And just as importantly, it does
                         so in a single-swappable-component manner.
                     </para>
                     <para>
                         In terms of interacting with a ClassLoader, Hibernate needs the following capabilities:
                         <itemizedlist>
                             <listitem>
                                 <para>
                                     the ability to locate application classes
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
                                     the ability to locate integration classes
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
                                     the ability to locate resources (properties files, xml files, etc)
                                 </para>
                             </listitem>
                             <listitem>
                                 <para>
                                     the ability to load <classname>java.util.ServiceLoader</classname>
                                 </para>
                             </listitem>
                         </itemizedlist>
                     </para>
                     <note>
                         <para>
                             Currently, the ability to load application classes and the ability to load integration
                             classes are combined into a single "load class" capability on the service.  That may
                             change in a later release.
                         </para>
                     </note>
                 </section>
 
                 <section xml:id="services-IntegratorService">
                     <title><interfacename>org.hibernate.integrator.spi.IntegratorService</interfacename></title>
                     <para>
                         Applications, add-ons and others all need to integrate with Hibernate which used to require
                         something, usually the application, to coordinate registering the pieces of each integration
                         needed on behalf of each integrator.  The intent of this service is to allow those integrators
                         to be discovered and to have them integrate themselves with Hibernate.
                     </para>
                     <para>
                         This service focuses on the discovery aspect.  It leverages the standard Java
                         <classname>java.util.ServiceLoader</classname> capability provided by the
-                        <interfacename>org.hibernate.service.classloading.spi.ClassLoaderService</interfacename>
+                        <interfacename>org.hibernate.boot.registry.classloading.spi.ClassLoaderService</interfacename>
                         in order to discover implementations of the
                         <interfacename>org.hibernate.integrator.spi.Integrator</interfacename> contract.
                         Integrators would simply define a file named
                         <filename>/META-INF/services/org.hibernate.integrator.spi.Integrator</filename> and make it
                         available on the classpath.  <classname>java.util.ServiceLoader</classname> covers the
                         format of this file in detail, but essentially it list classes by FQN that implement the
                         <interfacename>org.hibernate.integrator.spi.Integrator</interfacename> one per line.
                     </para>
                     <para>
                         See <xref linkend="integrators"/>
                     </para>
                 </section>
             </section>
         </section>
 
         <section xml:id="services-registry-sessionfactory">
             <title>SessionFactory registry</title>
             <para>
                 While it is best practice to treat instances of all the registry types as targeting a given
                 <interfacename>org.hibernate.SessionFactory</interfacename>, the instances of services in this group
                 explicitly belong to a single <interfacename>org.hibernate.SessionFactory</interfacename>.  The
                 difference is a matter of timing in when they need to be initiated.  Generally they need access to the
                 <interfacename>org.hibernate.SessionFactory</interfacename> to be initiated.  This special registry is
                 <interfacename>org.hibernate.service.spi.SessionFactoryServiceRegistry</interfacename>
             </para>
 
             <section xml:id="services-EventListenerRegistry">
                 <title><interfacename>org.hibernate.event.service.spi.EventListenerRegistry</interfacename></title>
                 <variablelist>
                     <varlistentry>
                         <term>Notes</term>
                         <listitem>
                             <para>
                                 Service for managing event listeners.
                             </para>
                         </listitem>
                     </varlistentry>
                     <varlistentry>
                         <term>Initiator</term>
                         <listitem>
                             <para>
                                 <classname>org.hibernate.event.service.internal.EventListenerServiceInitiator</classname>
                             </para>
                         </listitem>
                     </varlistentry>
                     <varlistentry>
                         <term>Implementations</term>
                         <listitem>
                             <para>
                                 <classname>org.hibernate.event.service.internal.EventListenerRegistryImpl</classname>
                             </para>
                         </listitem>
                     </varlistentry>
                 </variablelist>
             </section>
         </section>
 
     </section>
 
 
     <section xml:id="services-use">
         <title>Using services and registries</title>
         <para>
             Coming soon...
         </para>
     </section>
 
     <section xml:id="integrators">
         <title>Integrators</title>
         <para>
             The <interfacename>org.hibernate.integrator.spi.Integrator</interfacename> is intended to provide a simple
             means for allowing developers to hook into the process of building a functioning SessionFactory.  The
             The <interfacename>org.hibernate.integrator.spi.Integrator</interfacename> interface defines 2 methods of
             interest: <methodname>integrate</methodname> allows us to hook into the building process;
             <methodname>disintegrate</methodname> allows us to hook into a SessionFactory shutting down.
         </para>
         <note>
             <para>
                 There is a 3rd method defined on <interfacename>org.hibernate.integrator.spi.Integrator</interfacename>,
                 an overloaded form of <methodname>integrate</methodname> accepting a
                 <interfacename>org.hibernate.metamodel.source.MetadataImplementor</interfacename> instead of
                 <classname>org.hibernate.cfg.Configuration</classname>.  This form is intended for use with the new
                 metamodel code scheduled for completion in 5.0
             </para>
         </note>
         <para>
             See <xref linkend="services-IntegratorService"/>
         </para>
         <para>
             In addition to the discovery approach provided by the IntegratorService, applications can manually
             register Integrator implementations when building the BootstrapServiceRegistry.
             See <xref linkend="BootstrapServiceRegistryBuilder-example"/>
         </para>
 
         <section xml:id="integrators-uses">
             <title>Integrator use-cases</title>
             <para>
                 The main use cases for an <interfacename>org.hibernate.integrator.spi.Integrator</interfacename> right
                 now are registering event listeners and providing services (see
                 <interfacename>org.hibernate.integrator.spi.ServiceContributingIntegrator</interfacename>).  With 5.0
                 we plan on expanding that to allow altering the metamodel describing the mapping between object and
                 relational models.
             </para>
 
             <example xml:id="registering-listeners-example">
                 <title>Registering event listeners</title>
                 <programlisting role="JAVA"><xi:include href="extras/register-event-listeners-example.java" xmlns:xi="http://www.w3.org/2001/XInclude" parse="text"/></programlisting>
             </example>
         </section>
     </section>
 </chapter>
\ No newline at end of file
diff --git a/documentation/src/main/docbook/devguide/en-US/chapters/transactions/Transactions.xml b/documentation/src/main/docbook/devguide/en-US/chapters/transactions/Transactions.xml
index 2aa3e844d1..9b282aa80b 100644
--- a/documentation/src/main/docbook/devguide/en-US/chapters/transactions/Transactions.xml
+++ b/documentation/src/main/docbook/devguide/en-US/chapters/transactions/Transactions.xml
@@ -1,534 +1,534 @@
 <?xml version='1.0' encoding='utf-8' ?>
 
 <chapter xmlns="http://docbook.org/ns/docbook"
          xmlns:xi="http://www.w3.org/2001/XInclude">
 
     <title>Transactions and concurrency control</title>
 
     <section>
         <title>Defining Transaction</title>
         <para>
             It is important to understand that the term transaction has many different yet related meanings in regards
             to persistence and Object/Relational Mapping.  In most use-cases these definitions align, but that is not
             always the case.
         </para>
         <itemizedlist>
             <listitem>
                 <para>
                     Might refer to the physical transaction with the database.
                 </para>
             </listitem>
             <listitem>
                 <para>
                     Might refer to the logical notion of a transaction as related to a persistence context.
                 </para>
             </listitem>
             <listitem>
                 <para>
                     Might refer to the application notion of a Unit-of-Work, as defined by the archetypal pattern.
                 </para>
             </listitem>
         </itemizedlist>
         <note>
             <para>
                 This documentation largely treats the physical and logic notions of transaction as one-in-the-same.
             </para>
         </note>
     </section>
 
     <section>
         <title>Physical Transactions</title>
         <para>
             Hibernate uses the JDBC API for persistence.  In the world of Java there are 2 well defined mechanism
             for dealing with transactions in JDBC: JDBC itself and JTA.  Hibernate supports both mechanisms for
             integrating with transactions and allowing applications to manage physical transactions.
         </para>
         <para>
             The first concept in understanding Hibernate transaction support is the
             <interfacename>org.hibernate.engine.transaction.spi.TransactionFactory</interfacename> interface which
             serves 2 main functions:
         </para>
         <itemizedlist>
             <listitem>
                 <para>
                     It allows Hibernate to understand the transaction semantics of the environment.  Are we operating
                     in a JTA environment?  Is a physical transaction already currently active?  etc.
                 </para>
             </listitem>
             <listitem>
                 <para>
                     It acts as a factory for <interfacename>org.hibernate.Transaction</interfacename> instances which
                     are used to allow applications to manage and check the state of transactions.
                     <interfacename>org.hibernate.Transaction</interfacename> is Hibernate's notion of a logical
                     transaction.  JPA has a similar notion in the
                     <interfacename>javax.persistence.EntityTransaction</interfacename> interface.
                 </para>
             </listitem>
         </itemizedlist>
 
         <note>
             <para>
                 <interfacename>javax.persistence.EntityTransaction</interfacename> is only available when using
                 resource-local transactions.  Hibernate allows access to
                 <interfacename>org.hibernate.Transaction</interfacename> regardless of environment.
             </para>
         </note>
 
         <para>
             <interfacename>org.hibernate.engine.transaction.spi.TransactionFactory</interfacename> is a standard
             Hibernate service.  See <xref linkend="services-TransactionFactory"/> for details.
         </para>
 
         <section>
             <title>Physical Transactions - JDBC</title>
             <para>
                 JDBC-based transaction management leverages the JDBC defined methods
                 <methodname>java.sql.Connection.commit()</methodname> and
                 <methodname>java.sql.Connection.rollback()</methodname> (JDBC does not define an explicit
                 method of beginning a transaction).  In Hibernate, this approach is represented by the
                 <classname>org.hibernate.engine.transaction.internal.jdbc.JdbcTransactionFactory</classname> class.
             </para>
         </section>
 
         <section>
             <title>Physical Transactions - JTA</title>
             <para>
                 JTA-based transaction approach which leverages the
                 <interfacename>javax.transaction.UserTransaction</interfacename> interface as obtained from
-                <interfacename>org.hibernate.service.jta.platform.spi.JtaPlatform</interfacename> API.  This approach
+                <interfacename>org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform</interfacename> API.  This approach
                 is represented by the
                 <classname>org.hibernate.engine.transaction.internal.jta.JtaTransactionFactory</classname> class.
             </para>
             <para>
                 See <xref linkend="services-JtaPlatform"/> for information on integration with the underlying JTA
                 system.
             </para>
         </section>
 
 
         <section>
             <title>Physical Transactions - CMT</title>
             <para>
                 Another JTA-based transaction approach which leverages the JTA
                 <interfacename>javax.transaction.TransactionManager</interfacename> interface as obtained from
-                <interfacename>org.hibernate.service.jta.platform.spi.JtaPlatform</interfacename> API.  This approach
+                <interfacename>org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform</interfacename> API.  This approach
                 is represented by the
                 <classname>org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory</classname> class.  In
                 an actual JEE CMT environment, access to the
                 <interfacename>javax.transaction.UserTransaction</interfacename> is restricted.
             </para>
             <note>
                 <para>
                     The term CMT is potentially misleading here.  The important point simply being that the physical JTA
                     transactions are being managed by something other than the Hibernate transaction API.
                 </para>
             </note>
             <para>
                 See <xref linkend="services-JtaPlatform"/> for information on integration with the underlying JTA
                 system.
             </para>
         </section>
 
         <section>
             <title>Physical Transactions - Custom</title>
             <para>
                 Its is also possible to plug in a custom transaction approach by implementing the
                 <interfacename>org.hibernate.engine.transaction.spi.TransactionFactory</interfacename> contract.
                 The default service initiator has built-in support for understanding custom transaction approaches
                 via the <literal>hibernate.transaction.factory_class</literal> which can name either:
             </para>
             <itemizedlist>
                 <listitem>
                     <para>
                         The instance of <interfacename>org.hibernate.engine.transaction.spi.TransactionFactory</interfacename>
                         to use.
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         The name of a class implementing
                         <interfacename>org.hibernate.engine.transaction.spi.TransactionFactory</interfacename>
                         to use.  The expectation is that the implementation class have a no-argument constructor.
                     </para>
                 </listitem>
             </itemizedlist>
         </section>
 
         <section>
             <title>Physical Transactions - Legacy</title>
             <para>
                 During development of 4.0, most of these classes named here were moved to new packages.  To help
                 facilitate upgrading, Hibernate will also recognize the legacy names here for a short period of time.
             </para>
             <itemizedlist>
                 <listitem>
                     <para>
                         <literal>org.hibernate.transaction.JDBCTransactionFactory</literal> is mapped to
                         <classname>org.hibernate.engine.transaction.internal.jdbc.JdbcTransactionFactory</classname>
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         <literal>org.hibernate.transaction.JTATransactionFactory</literal> is mapped to
                         <classname>org.hibernate.engine.transaction.internal.jta.JtaTransactionFactory</classname>
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         <literal>org.hibernate.transaction.CMTTransactionFactory</literal> is mapped to
                         <classname>org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory</classname>
                     </para>
                 </listitem>
             </itemizedlist>
         </section>
 
     </section>
 
 
     <section>
         <title>Hibernate Transaction Usage</title>
         <para>
             Hibernate uses JDBC connections and JTA resources directly, without adding any additional locking behavior.
             It is important for you to become familiar with the JDBC, ANSI SQL, and transaction isolation specifics
             of your database management system.
         </para>
         <para>
             Hibernate does not lock objects in memory.  The behavior defined by the isolation level of your database
             transactions does not change when you use Hibernate.  The Hibernate
             <interfacename>org.hibernate.Session</interfacename> acts as a transaction-scoped cache providing
             repeatable reads for lookup by identifier and queries that result in loading entities.
         </para>
 
         <important>
             <para>
                 To reduce lock contention in the database, the physical database transaction needs to be as short as
                 possible.  Long database transactions prevent your application from scaling to a highly-concurrent load.
                 Do not hold a database transaction open during end-user-level work, but open it after the end-user-level
                 work is finished.  This is concept is referred to as <literal>transactional write-behind</literal>.
             </para>
         </important>
     </section>
 
     <section>
         <title>Transactional patterns (and anti-patterns)</title>
 
         <section xml:id="session-per-operation">
             <title>Session-per-operation anti-pattern</title>
             <para>
                 This is an anti-pattern of opening and closing a <classname>Session</classname> for each database call
                 in a single thread.  It is also an anti-pattern in terms of database transactions. Group your database
                 calls into a planned sequence.  In the same way, do not auto-commit after every SQL statement in your
                 application.  Hibernate disables, or expects the application server to disable, auto-commit mode
                 immediately.  Database transactions are never optional.  All communication with a database must
                 be encapsulated by a transaction.  Avoid auto-commit behavior for reading data, because many small
                 transactions are unlikely to perform better than one clearly-defined unit of work, and are more
                 difficult to maintain and extend.
             </para>
             <note>
                 <para>
                     Using auto-commit does not circumvent database transactions.  Instead, when in auto-commit mode,
                     JDBC drivers simply perform each call in an implicit transaction call.  It is as if your application
                     called commit after each and every JDBC call.
                 </para>
             </note>
         </section>
 
         <section xml:id="session-per-request">
             <title>Session-per-request pattern</title>
             <para>
                 This is the most common transaction pattern.  The term request here relates to the concept of a system
                 that reacts to a series of requests from a client/user.  Web applications are a prime example of this
                 type of system, though certainly not the only one.  At the beginning of handling such a request, the
                 application opens a Hibernate <interfacename>Session</interfacename>, starts a transaction, performs
                 all data related work, ends the transaction and closes the <interfacename>Session</interfacename>.
                 The crux of the pattern is the one-to-one relationship between the transaction and the
                 <interfacename>Session</interfacename>.
             </para>
 
             <para>
                 Within this pattern there is a common technique of defining a <firstterm>current session</firstterm> to
                 simplify the need of passing this <interfacename>Session</interfacename> around to all the application
                 components that may need access to it.  Hibernate provides support for this technique through the
                 <methodname>getCurrentSession</methodname> method of the <interfacename>SessionFactory</interfacename>.
                 The concept of a "current" session has to have a scope that defines the bounds in which the notion
                 of "current" is valid.   This is purpose of the
                 <interfacename>org.hibernate.context.spi.CurrentSessionContext</interfacename> contract.  There are 2
                 reliable defining scopes:
             </para>
             <itemizedlist>
                 <listitem>
                     <para>
                         First is a JTA transaction because it allows a callback hook to know when it is ending which
                         gives Hibernate a chance to close the <interfacename>Session</interfacename> and clean up.
                         This is represented by the
                         <classname>org.hibernate.context.internal.JTASessionContext</classname> implementation of
                         the <interfacename>org.hibernate.context.spi.CurrentSessionContext</interfacename> contract.
                         Using this implementation, a <interfacename>Session</interfacename> will be opened the first
                         time <methodname>getCurrentSession</methodname> is called within that transaction.
                     </para>
                 </listitem>
                 <listitem>
                     <para>
                         Secondly is this application request cycle itself.  This is best represented with the
                         <classname>org.hibernate.context.internal.ManagedSessionContext</classname> implementation of
                         the <interfacename>org.hibernate.context.spi.CurrentSessionContext</interfacename> contract.
                         Here an external component is responsible for managing the lifecycle and scoping of a "current"
                         session.  At the start of such a scope, <classname>ManagedSessionContext</classname>'s
                         <methodname>bind</methodname> method is called passing in the
                         <interfacename>Session</interfacename>.  At the end, its <methodname>unbind</methodname>
                         method is called.
                     </para>
                     <para>
                         Some common examples of such "external components" include:
                     </para>
                     <itemizedlist>
                         <listitem>
                             <para>
                                 <interfacename>javax.servlet.Filter</interfacename> implementation
                             </para>
                         </listitem>
                         <listitem>
                             <para>
                                 AOP interceptor with a pointcut on the service methods
                             </para>
                         </listitem>
                         <listitem>
                             <para>
                                 A proxy/interception container
                             </para>
                         </listitem>
                     </itemizedlist>
                 </listitem>
             </itemizedlist>
             <important>
                 <para>
                     The <methodname>getCurrentSession()</methodname> method has one downside in a JTA environment.  If
                     you use it, after_statement connection release mode is also used by default.  Due to a limitation of
                     the JTA specification, Hibernate cannot automatically clean up any unclosed
                     <interfacename>ScrollableResults</interfacename> or <interfacename>Iterator</interfacename>
                     instances returned by <methodname>scroll()</methodname> or <methodname>iterate()</methodname>.
                     Release the underlying database cursor by calling <methodname>ScrollableResults.close()</methodname>
                     or <methodname>Hibernate.close(Iterator)</methodname> explicitly from a
                     <systemitem>finally</systemitem> block.
                 </para>
             </important>
         </section>
 
         <section xml:id="long-conversations">
             <title>Conversations</title>
             <para>
                 The <phrase>session-per-request</phrase> pattern is not the only valid way of designing units of work.
                 Many business processes require a whole series of interactions with the user that are interleaved with
                 database accesses. In web and enterprise applications, it is not acceptable for a database transaction
                 to span a user interaction. Consider the following example:
             </para>
             <procedure>
                 <title>An example of a long-running conversation</title>
                 <step>
                     <para>
                         The first screen of a dialog opens. The data seen by the user is loaded in a particular
                         <classname>Session</classname> and database transaction.  The user is free to modify the objects.
                     </para>
                 </step>
                 <step>
                     <para>
                         The user uses a UI element to save their work after five minutes of editing. The modifications
                         are made persistent.  The user also expects to have exclusive access to the data during the edit
                         session.
                     </para>
                 </step>
             </procedure>
 
             <para>
                 Even though we have multiple databases access here, from the point of view of the user, this series of
                 steps represents a single unit of work.  There are many ways to implement this in your application.
             </para>
 
             <para>
                 A first naive implementation might keep the <classname>Session</classname> and database transaction open
                 while the user is editing, using database-level locks to prevent other users from modifying the same
                 data and to guarantee isolation and atomicity.  This is an anti-pattern, because lock contention is a
                 bottleneck which will prevent scalability in the future.
             </para>
             <para>
                 Several database transactions are used to implement the conversation.  In this case, maintaining
                 isolation of business processes becomes the partial responsibility of the application tier.  A single
                 conversation usually spans several database transactions.  These multiple database accesses can only
                 be atomic as a whole if only one of these database transactions (typically the last one) stores the
                 updated data.  All others only read data.  A common way to receive this data is through a wizard-style
                 dialog spanning several request/response cycles.  Hibernate includes some features which make this easy
                 to implement.
             </para>
 
             <informaltable>
                 <tgroup cols="2">
                     <tbody>
                         <row>
                             <entry>
                                 <para>
                                     Automatic Versioning
                                 </para>
                             </entry>
                             <entry>
                                 <para>
                                     Hibernate can perform automatic optimistic concurrency control for you.  It can
                                     automatically detect if a concurrent modification occurred during user think time.
                                     Check for this at the end of the conversation.
                                 </para>
                             </entry>
                         </row>
                         <row>
                             <entry>
                                 <para>
                                     Detached Objects
                                 </para>
                             </entry>
                             <entry>
                                 <para>
                                     If you decide to use the session-per-request pattern, all loaded instances will be
                                     in the detached state during user think time.  Hibernate allows you to reattach the
                                     objects and persist the modifications.  The pattern is called
                                     session-per-request-with-detached-objects.  Automatic versioning is used to isolate
                                     concurrent modifications.
                                 </para>
                             </entry>
                         </row>
                         <row>
                             <entry>
                                 <para>
                                     Extended Session
                                 </para>
                             </entry>
                             <entry>
                                 <para>
                                     The Hibernate <interfacename>Session</interfacename> can be disconnected from the
                                     underlying JDBC connection after the database transaction has been committed and
                                     reconnected when a new client request occurs. This pattern is known as
                                     session-per-conversation and makes even reattachment unnecessary. Automatic
                                     versioning is used to isolate concurrent modifications and the
                                     <interfacename>Session</interfacename> will not be allowed to flush automatically,
                                     only explicitly.
                                 </para>
                             </entry>
                         </row>
                     </tbody>
                 </tgroup>
             </informaltable>
 
             <para>
                 <phrase>Session-per-request-with-detached-objects</phrase> and <phrase>session-per-conversation</phrase>
                 each have advantages and disadvantages.
             </para>
         </section>
 
         <section>
             <title>Session-per-application</title>
             <para>
                 Discussion coming soon..
             </para>
         </section>
     </section>
 
     <section>
         <title>Object identity</title>
         <para>
             An application can concurrently access the same persistent state (database row) in two different Sessions.
             However, an instance of a persistent class is never shared between two
             <interfacename>Session</interfacename> instances.  Two different notions of identity exist and come into
             play here: Database identity and JVM identity.
         </para>
         <example>
             <title>Database identity</title>
             <programlisting language="Java" role="JAVA"><xi:include href="extras/database-identity.java" parse="text" /></programlisting>
         </example>
         <example>
             <title>JVM identity</title>
             <programlisting language="Java" role="JAVA"><xi:include href="extras/jvm-identity.java" parse="text" /></programlisting>
         </example>
         <para>
             For objects attached to a particular <interfacename>Session</interfacename>, the two notions are
             equivalent, and JVM identity for database identity is guaranteed by Hibernate.  The application might
             concurrently access a business object with the same identity in two different sessions, the two
             instances are actually different, in terms of JVM identity.  Conflicts are resolved using an optimistic
             approach and automatic versioning at flush/commit time.
         </para>
         <para>
             This approach places responsibility for concurrency on Hibernate and the database. It also provides the
             best scalability, since expensive locking is not needed to guarantee identity in single-threaded units
             of work.  The application does not need to synchronize on any business object, as long as it maintains
             a single thread per anti-patterns.  While not recommended, within a
             <interfacename>Session</interfacename> the application could safely use the <literal>==</literal>
             operator to compare objects.
         </para>
         <para>
 
             However, an application that uses the <literal>==</literal> operator outside of a
             <interfacename>Session</interfacename>
     may introduce problems.. If you put two detached instances into the same <classname>Set</classname>, they might
     use the same database identity, which means they represent the same row in the database. They would not be
     guaranteed to have the same JVM identity if they are in a detached state. Override the
     <methodname>equals</methodname> and <methodname>hashCode</methodname> methods in persistent classes, so that
     they have their own notion of object equality. Never use the database identifier to implement equality. Instead,
     use a business key that is a combination of unique, typically immutable, attributes. The database identifier
     changes if a transient object is made persistent. If the transient instance, together with detached instances,
     is held in a <classname>Set</classname>, changing the hash-code breaks the contract of the
     <classname>Set</classname>. Attributes for business keys can be less stable than database primary keys. You only
     need to guarantee stability as long as the objects are in the same <classname>Set</classname>.This is not a
     Hibernate issue, but relates to Java's implementation of object identity and equality.
   </para>
 
 </section>
 
 
     <section xml:id="transactions-basics-issues">
         <title>Common issues</title>
 
          <para>
              Both the <emphasis>session-per-user-session</emphasis> and <emphasis>session-per-application</emphasis>
              anti-patterns are susceptible to the following issues.  Some of the issues might also arise within the
              recommended patterns, so ensure that you understand the implications before making a design decision:
          </para>
 
         <itemizedlist>
             <listitem>
                 <para>
                     A <interfacename>Session</interfacename> is not thread-safe. Things that work concurrently, like
                     HTTP requests, session beans, or Swing workers, will cause race conditions if a
                     <interfacename>Session</interfacename> instance is shared. If you keep your Hibernate
                     <interfacename>Session</interfacename> in your
                     <interfacename>javax.servlet.http.HttpSession</interfacename> (this is discussed later in the
                     chapter), you should consider synchronizing access to your
                     <interfacename>HttpSession</interfacename>; otherwise, a user that clicks reload fast enough can use
                     the same <interfacename>Session</interfacename> in two concurrently running threads.
                 </para>
             </listitem>
             <listitem>
                 <para>
                     An exception thrown by Hibernate means you have to rollback your database transaction
                     and close the <interfacename>Session</interfacename> immediately (this is discussed in more detail
                     later in the chapter).  If your <interfacename>Session</interfacename> is bound to the application,
                     you have to stop the application.  Rolling back the database transaction does not put your business
                     objects back into the state they were at the start of the transaction.  This means that the
                     database state and the business objects will be out of sync. Usually this is not a
                     problem, because exceptions are not recoverable and you will have to start over after
                     rollback anyway.
                 </para>
             </listitem>
             <listitem>
                 <para>
                     The <interfacename>Session</interfacename> caches every object that is in a persistent state
                     (watched and checked for changes by Hibernate).  If you keep it open for a long time or simply load
                     too much data, it will grow endlessly until you get an OutOfMemoryException.  One solution is to
                     call <methodname>clear()</methodname> and <methodname>evict()</methodname> to manage the
                     <interfacename>Session</interfacename> cache, but you should consider an alternate means of dealing
                     with large amounts of data such as a Stored Procedure.  Java is simply not the right tool for these
                     kind of operations.  Some solutions are shown in <xref linkend="batch"/>.  Keeping a
                     <interfacename>Session</interfacename> open for the duration of a user session also means a higher
                     probability of stale data.
                 </para>
             </listitem>
         </itemizedlist>
 
     </section>
 
 </chapter>
diff --git a/hibernate-c3p0/src/main/java/org/hibernate/service/jdbc/connections/internal/C3P0ConnectionProvider.java b/hibernate-c3p0/src/main/java/org/hibernate/service/jdbc/connections/internal/C3P0ConnectionProvider.java
index e9feac5f44..61238d83f5 100644
--- a/hibernate-c3p0/src/main/java/org/hibernate/service/jdbc/connections/internal/C3P0ConnectionProvider.java
+++ b/hibernate-c3p0/src/main/java/org/hibernate/service/jdbc/connections/internal/C3P0ConnectionProvider.java
@@ -1,260 +1,261 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.jdbc.connections.internal;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Properties;
 import javax.sql.DataSource;
 
 import com.mchange.v2.c3p0.DataSources;
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.Environment;
+import org.hibernate.engine.jdbc.connections.internal.ConnectionProviderInitiator;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.UnknownUnwrapTypeException;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.classloading.spi.ClassLoadingException;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.spi.Configurable;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.Stoppable;
 
 /**
  * A connection provider that uses a C3P0 connection pool. Hibernate will use this by
  * default if the <tt>hibernate.c3p0.*</tt> properties are set.
  *
  * @author various people
  * @see ConnectionProvider
  */
 public class C3P0ConnectionProvider 
 		implements ConnectionProvider, Configurable, Stoppable, ServiceRegistryAwareService {
 
     private static final C3P0MessageLogger LOG = Logger.getMessageLogger(C3P0MessageLogger.class, C3P0ConnectionProvider.class.getName());
 
 	//swaldman 2006-08-28: define c3p0-style configuration parameters for properties with
 	//                     hibernate-specific overrides to detect and warn about conflicting
 	//                     declarations
 	private final static String C3P0_STYLE_MIN_POOL_SIZE = "c3p0.minPoolSize";
 	private final static String C3P0_STYLE_MAX_POOL_SIZE = "c3p0.maxPoolSize";
 	private final static String C3P0_STYLE_MAX_IDLE_TIME = "c3p0.maxIdleTime";
 	private final static String C3P0_STYLE_MAX_STATEMENTS = "c3p0.maxStatements";
 	private final static String C3P0_STYLE_ACQUIRE_INCREMENT = "c3p0.acquireIncrement";
 	private final static String C3P0_STYLE_IDLE_CONNECTION_TEST_PERIOD = "c3p0.idleConnectionTestPeriod";
 
 	//swaldman 2006-08-28: define c3p0-style configuration parameters for initialPoolSize, which
 	//                     hibernate sensibly lets default to minPoolSize, but we'll let users
 	//                     override it with the c3p0-style property if they want.
 	private final static String C3P0_STYLE_INITIAL_POOL_SIZE = "c3p0.initialPoolSize";
 
 	private DataSource ds;
 	private Integer isolation;
 	private boolean autocommit;
 
 	private ServiceRegistryImplementor serviceRegistry;
 
 	@Override
 	@SuppressWarnings("UnnecessaryUnboxing")
 	public Connection getConnection() throws SQLException {
 		final Connection c = ds.getConnection();
 		if ( isolation != null ) {
 			c.setTransactionIsolation( isolation.intValue() );
 		}
 		if ( c.getAutoCommit() != autocommit ) {
 			c.setAutoCommit( autocommit );
 		}
 		return c;
 	}
 
 	@Override
 	public void closeConnection(Connection conn) throws SQLException {
 		conn.close();
 	}
 
 	@Override
 	public boolean isUnwrappableAs(Class unwrapType) {
 		return ConnectionProvider.class.equals( unwrapType ) ||
 				C3P0ConnectionProvider.class.isAssignableFrom( unwrapType ) ||
 				DataSource.class.isAssignableFrom( unwrapType );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> T unwrap(Class<T> unwrapType) {
 		if ( ConnectionProvider.class.equals( unwrapType ) ||
 				C3P0ConnectionProvider.class.isAssignableFrom( unwrapType ) ) {
 			return (T) this;
 		}
 		else if ( DataSource.class.isAssignableFrom( unwrapType ) ) {
 			return (T) ds;
 		}
 		else {
 			throw new UnknownUnwrapTypeException( unwrapType );
 		}
 	}
 
 	@Override
     @SuppressWarnings( {"unchecked"})
 	public void configure(Map props) {
 		String jdbcDriverClass = (String) props.get( Environment.DRIVER );
 		String jdbcUrl = (String) props.get( Environment.URL );
 		Properties connectionProps = ConnectionProviderInitiator.getConnectionProperties( props );
 
         LOG.c3p0UsingDriver(jdbcDriverClass, jdbcUrl);
         LOG.connectionProperties(ConfigurationHelper.maskOut(connectionProps, "password"));
 
 		autocommit = ConfigurationHelper.getBoolean( Environment.AUTOCOMMIT, props );
         LOG.autoCommitMode( autocommit );
 
         if (jdbcDriverClass == null) {
 			LOG.jdbcDriverNotSpecified(Environment.DRIVER);
 		}
 		else {
 			try {
 				serviceRegistry.getService( ClassLoaderService.class ).classForName( jdbcDriverClass );
 			}
 			catch ( ClassLoadingException e ) {
 				throw new ClassLoadingException( LOG.jdbcDriverNotFound(jdbcDriverClass), e );
 			}
 		}
 
 		try {
 
 			//swaldman 2004-02-07: modify to allow null values to signify fall through to c3p0 PoolConfig defaults
 			Integer minPoolSize = ConfigurationHelper.getInteger( Environment.C3P0_MIN_SIZE, props );
 			Integer maxPoolSize = ConfigurationHelper.getInteger( Environment.C3P0_MAX_SIZE, props );
 			Integer maxIdleTime = ConfigurationHelper.getInteger( Environment.C3P0_TIMEOUT, props );
 			Integer maxStatements = ConfigurationHelper.getInteger( Environment.C3P0_MAX_STATEMENTS, props );
 			Integer acquireIncrement = ConfigurationHelper.getInteger( Environment.C3P0_ACQUIRE_INCREMENT, props );
 			Integer idleTestPeriod = ConfigurationHelper.getInteger( Environment.C3P0_IDLE_TEST_PERIOD, props );
 
 			Properties c3props = new Properties();
 
 			// turn hibernate.c3p0.* into c3p0.*, so c3p0
 			// gets a chance to see all hibernate.c3p0.*
 			for ( Object o : props.keySet() ) {
 				if ( ! String.class.isInstance( o ) ) {
 					continue;
 				}
 				final String key = (String) o;
 				if ( key.startsWith( "hibernate.c3p0." ) ) {
 					String newKey = key.substring( 15 );
 					if ( props.containsKey( newKey ) ) {
 						warnPropertyConflict( key, newKey );
 					}
 					c3props.put( newKey, props.get( key ) );
 				}
 			}
 
 			setOverwriteProperty( Environment.C3P0_MIN_SIZE, C3P0_STYLE_MIN_POOL_SIZE, props, c3props, minPoolSize );
 			setOverwriteProperty( Environment.C3P0_MAX_SIZE, C3P0_STYLE_MAX_POOL_SIZE, props, c3props, maxPoolSize );
 			setOverwriteProperty( Environment.C3P0_TIMEOUT, C3P0_STYLE_MAX_IDLE_TIME, props, c3props, maxIdleTime );
 			setOverwriteProperty(
 					Environment.C3P0_MAX_STATEMENTS, C3P0_STYLE_MAX_STATEMENTS, props, c3props, maxStatements
 			);
 			setOverwriteProperty(
 					Environment.C3P0_ACQUIRE_INCREMENT, C3P0_STYLE_ACQUIRE_INCREMENT, props, c3props, acquireIncrement
 			);
 			setOverwriteProperty(
 					Environment.C3P0_IDLE_TEST_PERIOD, C3P0_STYLE_IDLE_CONNECTION_TEST_PERIOD, props, c3props, idleTestPeriod
 			);
 
 			// revert to traditional hibernate behavior of setting initialPoolSize to minPoolSize
 			// unless otherwise specified with a c3p0.*-style parameter.
 			Integer initialPoolSize = ConfigurationHelper.getInteger( C3P0_STYLE_INITIAL_POOL_SIZE, props );
 			if ( initialPoolSize == null && minPoolSize != null ) {
 				c3props.put( C3P0_STYLE_INITIAL_POOL_SIZE, String.valueOf( minPoolSize ).trim() );
 			}
 
 			/*DataSource unpooled = DataSources.unpooledDataSource(
 				jdbcUrl, props.getProperty(Environment.USER), props.getProperty(Environment.PASS)
 			);*/
 			DataSource unpooled = DataSources.unpooledDataSource( jdbcUrl, connectionProps );
 
 			Map allProps = new HashMap();
 			allProps.putAll( props );
 			allProps.putAll( c3props );
 
 			ds = DataSources.pooledDataSource( unpooled, allProps );
 		}
 		catch ( Exception e ) {
             LOG.error(LOG.unableToInstantiateC3p0ConnectionPool(), e);
             throw new HibernateException(LOG.unableToInstantiateC3p0ConnectionPool(), e);
 		}
 
 		String i = (String) props.get( Environment.ISOLATION );
         if (i == null) isolation = null;
 		else {
 			isolation = Integer.valueOf( i );
             LOG.jdbcIsolationLevel(Environment.isolationLevelToString(isolation));
 		}
 
 	}
 
 	public void close() {
 		try {
 			DataSources.destroy( ds );
 		}
 		catch ( SQLException sqle ) {
             LOG.unableToDestroyC3p0ConnectionPool(sqle);
 		}
 	}
 
 	@Override
 	public boolean supportsAggressiveRelease() {
 		return false;
 	}
 
 	private void setOverwriteProperty(String hibernateStyleKey, String c3p0StyleKey, Map hibp, Properties c3p, Integer value) {
 		if ( value != null ) {
             String peeledC3p0Key = c3p0StyleKey.substring(5);
 			c3p.put( peeledC3p0Key, String.valueOf( value ).trim() );
 			if ( hibp.containsKey( c3p0StyleKey )  ) {
 				warnPropertyConflict( hibernateStyleKey, c3p0StyleKey );
 			}
 			String longC3p0StyleKey = "hibernate." + c3p0StyleKey;
 			if ( hibp.containsKey( longC3p0StyleKey ) ) {
 				warnPropertyConflict( hibernateStyleKey, longC3p0StyleKey );
 			}
 		}
 	}
 
 	private void warnPropertyConflict(String hibernateStyle, String c3p0Style) {
         LOG.bothHibernateAndC3p0StylesSet(hibernateStyle, c3p0Style, hibernateStyle, c3p0Style);
 	}
 
 	@Override
 	public void stop() {
 		close();
 	}
 
 	@Override
 	public void injectServices(ServiceRegistryImplementor serviceRegistry) {
 		this.serviceRegistry = serviceRegistry;
 	}
 }
diff --git a/hibernate-c3p0/src/test/java/org/hibernate/test/c3p0/C3P0ConnectionProviderTest.java b/hibernate-c3p0/src/test/java/org/hibernate/test/c3p0/C3P0ConnectionProviderTest.java
index af61d3b84d..2175f15193 100644
--- a/hibernate-c3p0/src/test/java/org/hibernate/test/c3p0/C3P0ConnectionProviderTest.java
+++ b/hibernate-c3p0/src/test/java/org/hibernate/test/c3p0/C3P0ConnectionProviderTest.java
@@ -1,88 +1,88 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.c3p0;
 
 import java.lang.management.ManagementFactory;
 import java.util.Set;
 import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
 import org.junit.Test;
 
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.service.jdbc.connections.internal.C3P0ConnectionProvider;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Strong Liu
  */
 public class C3P0ConnectionProviderTest extends BaseCoreFunctionalTestCase {
 
     @Test
     public void testC3P0isDefaultWhenThereIsC3P0Properties() {
         JdbcServices jdbcServices = serviceRegistry().getService( JdbcServices.class );
         ConnectionProvider provider = jdbcServices.getConnectionProvider();
         assertTrue( provider instanceof C3P0ConnectionProvider );
 
     }
 
     @Test
     public void testHHH6635() throws Exception {
         MBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();
         Set<ObjectName> set = mBeanServer.queryNames( null, null );
         boolean mbeanfound = false;
         for ( ObjectName obj : set ) {
             if ( obj.getKeyPropertyListString().indexOf( "PooledDataSource" ) > 0 ) {
                 mbeanfound = true;
 
                 // see according c3p0 settings in META-INF/persistence.xml
 
                 int actual_minPoolSize = (Integer) mBeanServer.getAttribute( obj, "minPoolSize" );
                 assertEquals( 50, actual_minPoolSize );
 
                 int actual_maxPoolSize = (Integer) mBeanServer.getAttribute( obj, "maxPoolSize" );
                 assertEquals( 800, actual_maxPoolSize );
 
                 int actual_maxStatements = (Integer) mBeanServer.getAttribute( obj, "maxStatements" );
                 assertEquals( 50, actual_maxStatements );
 
                 int actual_maxIdleTime = (Integer) mBeanServer.getAttribute( obj, "maxIdleTime" );
                 assertEquals( 300, actual_maxIdleTime );
 
                 int actual_idleConnectionTestPeriod = (Integer) mBeanServer.getAttribute(
                         obj,
                         "idleConnectionTestPeriod"
                 );
                 assertEquals( 3000, actual_idleConnectionTestPeriod );
                 break;
             }
         }
 
         assertTrue( "PooledDataSource BMean not found, please verify version of c3p0", mbeanfound );
     }
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/SessionFactory.java b/hibernate-core/src/main/java/org/hibernate/SessionFactory.java
index 827b5a77ee..a4020d905f 100644
--- a/hibernate-core/src/main/java/org/hibernate/SessionFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/SessionFactory.java
@@ -1,377 +1,377 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate;
 
 import java.io.Serializable;
 import java.sql.Connection;
 import java.util.Map;
 import java.util.Set;
 import javax.naming.Referenceable;
 
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.metadata.CollectionMetadata;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.stat.Statistics;
 
 /**
  * The main contract here is the creation of {@link Session} instances.  Usually
  * an application has a single {@link SessionFactory} instance and threads
  * servicing client requests obtain {@link Session} instances from this factory.
  * <p/>
  * The internal state of a {@link SessionFactory} is immutable.  Once it is created
  * this internal state is set.  This internal state includes all of the metadata
  * about Object/Relational Mapping.
  * <p/>
  * Implementors <strong>must</strong> be threadsafe.
  *
  * @see org.hibernate.cfg.Configuration
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public interface SessionFactory extends Referenceable, Serializable {
 
 	public interface SessionFactoryOptions {
 		Interceptor getInterceptor();
 		EntityNotFoundDelegate getEntityNotFoundDelegate();
 	}
 
 	public SessionFactoryOptions getSessionFactoryOptions();
 
 	/**
 	 * Obtain a {@link Session} builder.
 	 *
 	 * @return The session builder
 	 */
 	public SessionBuilder withOptions();
 
 	/**
 	 * Open a {@link Session}.
 	 * <p/>
 	 * JDBC {@link Connection connection(s} will be obtained from the
-	 * configured {@link org.hibernate.service.jdbc.connections.spi.ConnectionProvider} as needed
+	 * configured {@link org.hibernate.engine.jdbc.connections.spi.ConnectionProvider} as needed
 	 * to perform requested work.
 	 *
 	 * @return The created session.
 	 *
 	 * @throws HibernateException Indicates a problem opening the session; pretty rare here.
 	 */
 	public Session openSession() throws HibernateException;
 
 	/**
 	 * Obtains the current session.  The definition of what exactly "current"
 	 * means controlled by the {@link org.hibernate.context.spi.CurrentSessionContext} impl configured
 	 * for use.
 	 * <p/>
 	 * Note that for backwards compatibility, if a {@link org.hibernate.context.spi.CurrentSessionContext}
 	 * is not configured but JTA is configured this will default to the {@link org.hibernate.context.internal.JTASessionContext}
 	 * impl.
 	 *
 	 * @return The current session.
 	 *
 	 * @throws HibernateException Indicates an issue locating a suitable current session.
 	 */
 	public Session getCurrentSession() throws HibernateException;
 
 	/**
 	 * Obtain a {@link StatelessSession} builder.
 	 *
 	 * @return The stateless session builder
 	 */
 	public StatelessSessionBuilder withStatelessOptions();
 
 	/**
 	 * Open a new stateless session.
 	 *
 	 * @return The created stateless session.
 	 */
 	public StatelessSession openStatelessSession();
 
 	/**
 	 * Open a new stateless session, utilizing the specified JDBC
 	 * {@link Connection}.
 	 *
 	 * @param connection Connection provided by the application.
 	 *
 	 * @return The created stateless session.
 	 */
 	public StatelessSession openStatelessSession(Connection connection);
 
 	/**
 	 * Retrieve the {@link ClassMetadata} associated with the given entity class.
 	 *
 	 * @param entityClass The entity class
 	 *
 	 * @return The metadata associated with the given entity; may be null if no such
 	 * entity was mapped.
 	 *
 	 * @throws HibernateException Generally null is returned instead of throwing.
 	 */
 	public ClassMetadata getClassMetadata(Class entityClass);
 
 	/**
 	 * Retrieve the {@link ClassMetadata} associated with the given entity class.
 	 *
 	 * @param entityName The entity class
 	 *
 	 * @return The metadata associated with the given entity; may be null if no such
 	 * entity was mapped.
 	 *
 	 * @throws HibernateException Generally null is returned instead of throwing.
 	 * @since 3.0
 	 */
 	public ClassMetadata getClassMetadata(String entityName);
 
 	/**
 	 * Get the {@link CollectionMetadata} associated with the named collection role.
 	 *
 	 * @param roleName The collection role (in form [owning-entity-name].[collection-property-name]).
 	 *
 	 * @return The metadata associated with the given collection; may be null if no such
 	 * collection was mapped.
 	 *
 	 * @throws HibernateException Generally null is returned instead of throwing.
 	 */
 	public CollectionMetadata getCollectionMetadata(String roleName);
 
 	/**
 	 * Retrieve the {@link ClassMetadata} for all mapped entities.
 	 *
 	 * @return A map containing all {@link ClassMetadata} keyed by the
 	 * corresponding {@link String} entity-name.
 	 *
 	 * @throws HibernateException Generally empty map is returned instead of throwing.
 	 *
 	 * @since 3.0 changed key from {@link Class} to {@link String}.
 	 */
 	public Map<String,ClassMetadata> getAllClassMetadata();
 
 	/**
 	 * Get the {@link CollectionMetadata} for all mapped collections
 	 *
 	 * @return a map from <tt>String</tt> to <tt>CollectionMetadata</tt>
 	 *
 	 * @throws HibernateException Generally empty map is returned instead of throwing.
 	 */
 	public Map getAllCollectionMetadata();
 
 	/**
 	 * Retrieve the statistics fopr this factory.
 	 *
 	 * @return The statistics.
 	 */
 	public Statistics getStatistics();
 
 	/**
 	 * Destroy this <tt>SessionFactory</tt> and release all resources (caches,
 	 * connection pools, etc).
 	 * <p/>
 	 * It is the responsibility of the application to ensure that there are no
 	 * open {@link Session sessions} before calling this method as the impact
 	 * on those {@link Session sessions} is indeterminate.
 	 * <p/>
 	 * No-ops if already {@link #isClosed closed}.
 	 *
 	 * @throws HibernateException Indicates an issue closing the factory.
 	 */
 	public void close() throws HibernateException;
 
 	/**
 	 * Is this factory already closed?
 	 *
 	 * @return True if this factory is already closed; false otherwise.
 	 */
 	public boolean isClosed();
 
 	/**
 	 * Obtain direct access to the underlying cache regions.
 	 *
 	 * @return The direct cache access API.
 	 */
 	public Cache getCache();
 
 	/**
 	 * Evict all entries from the second-level cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param persistentClass The entity class for which to evict data.
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'persisttentClass' did not name a mapped entity or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictEntityRegion(Class)} accessed through
 	 * {@link #getCache()} instead.
 	 */
     @Deprecated
 	public void evict(Class persistentClass) throws HibernateException;
 
 	/**
 	 * Evict an entry from the second-level  cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param persistentClass The entity class for which to evict data.
 	 * @param id The entity id
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'persisttentClass' did not name a mapped entity or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#containsEntity(Class, Serializable)} accessed through
 	 * {@link #getCache()} instead.
 	 */
     @Deprecated
 	public void evict(Class persistentClass, Serializable id) throws HibernateException;
 
 	/**
 	 * Evict all entries from the second-level cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param entityName The entity name for which to evict data.
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'persisttentClass' did not name a mapped entity or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictEntityRegion(String)} accessed through
 	 * {@link #getCache()} instead.
 	 */
     @Deprecated
 	public void evictEntity(String entityName) throws HibernateException;
 
 	/**
 	 * Evict an entry from the second-level  cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param entityName The entity name for which to evict data.
 	 * @param id The entity id
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'persisttentClass' did not name a mapped entity or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictEntity(String,Serializable)} accessed through
 	 * {@link #getCache()} instead.
 	 */
     @Deprecated
 	public void evictEntity(String entityName, Serializable id) throws HibernateException;
 
 	/**
 	 * Evict all entries from the second-level cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param roleName The name of the collection role whose regions should be evicted
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'roleName' did not name a mapped collection or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictCollectionRegion(String)} accessed through
 	 * {@link #getCache()} instead.
 	 */
     @Deprecated
 	public void evictCollection(String roleName) throws HibernateException;
 
 	/**
 	 * Evict an entry from the second-level cache. This method occurs outside
 	 * of any transaction; it performs an immediate "hard" remove, so does not respect
 	 * any transaction isolation semantics of the usage strategy. Use with care.
 	 *
 	 * @param roleName The name of the collection role
 	 * @param id The id of the collection owner
 	 *
 	 * @throws HibernateException Generally will mean that either that
 	 * 'roleName' did not name a mapped collection or a problem
 	 * communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictCollection(String,Serializable)} accessed through
 	 * {@link #getCache()} instead.
 	 */
     @Deprecated
 	public void evictCollection(String roleName, Serializable id) throws HibernateException;
 
 	/**
 	 * Evict any query result sets cached in the named query cache region.
 	 *
 	 * @param cacheRegion The named query cache region from which to evict.
 	 *
 	 * @throws HibernateException Since a not-found 'cacheRegion' simply no-ops,
 	 * this should indicate a problem communicating with underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictQueryRegion(String)} accessed through
 	 * {@link #getCache()} instead.
 	 */
     @Deprecated
 	public void evictQueries(String cacheRegion) throws HibernateException;
 
 	/**
 	 * Evict any query result sets cached in the default query cache region.
 	 *
 	 * @throws HibernateException Indicate a problem communicating with
 	 * underlying cache impl.
 	 *
 	 * @deprecated Use {@link Cache#evictQueryRegions} accessed through
 	 * {@link #getCache()} instead.
 	 */
     @Deprecated
 	public void evictQueries() throws HibernateException;
 
 	/**
 	 * Obtain a set of the names of all filters defined on this SessionFactory.
 	 *
 	 * @return The set of filter names.
 	 */
 	public Set getDefinedFilterNames();
 
 	/**
 	 * Obtain the definition of a filter by name.
 	 *
 	 * @param filterName The name of the filter for which to obtain the definition.
 	 * @return The filter definition.
 	 * @throws HibernateException If no filter defined with the given name.
 	 */
 	public FilterDefinition getFilterDefinition(String filterName) throws HibernateException;
 
 	/**
 	 * Determine if this session factory contains a fetch profile definition
 	 * registered under the given name.
 	 *
 	 * @param name The name to check
 	 * @return True if there is such a fetch profile; false otherwise.
 	 */
 	public boolean containsFetchProfileDefinition(String name);
 
 	/**
 	 * Retrieve this factory's {@link TypeHelper}
 	 *
 	 * @return The factory's {@link TypeHelper}
 	 */
 	public TypeHelper getTypeHelper();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/registry/BootstrapServiceRegistry.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/BootstrapServiceRegistry.java
new file mode 100644
index 0000000000..d7d9387225
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/BootstrapServiceRegistry.java
@@ -0,0 +1,35 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.boot.registry;
+
+import org.hibernate.service.ServiceRegistry;
+
+/**
+ * Specialization of the {@link org.hibernate.service.ServiceRegistry} contract mainly to make the
+ * {@link StandardServiceRegistryBuilder#StandardServiceRegistryBuilder(BootstrapServiceRegistry)} signature type-safe
+ *
+ * @author Steve Ebersole
+ */
+public interface BootstrapServiceRegistry extends ServiceRegistry {
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/registry/BootstrapServiceRegistryBuilder.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/BootstrapServiceRegistryBuilder.java
new file mode 100644
index 0000000000..db33fef5eb
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/BootstrapServiceRegistryBuilder.java
@@ -0,0 +1,152 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.boot.registry;
+
+import java.util.LinkedHashSet;
+
+import org.hibernate.boot.registry.internal.BootstrapServiceRegistryImpl;
+import org.hibernate.integrator.internal.IntegratorServiceImpl;
+import org.hibernate.integrator.spi.Integrator;
+import org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl;
+import org.hibernate.boot.registry.selector.internal.StrategySelectorBuilder;
+
+/**
+ * Builder for bootstrap {@link org.hibernate.service.ServiceRegistry} instances.
+ *
+ * @author Steve Ebersole
+ *
+ * @see BootstrapServiceRegistryImpl
+ * @see StandardServiceRegistryBuilder#StandardServiceRegistryBuilder(org.hibernate.boot.registry.BootstrapServiceRegistry)
+ */
+public class BootstrapServiceRegistryBuilder {
+	private final LinkedHashSet<Integrator> providedIntegrators = new LinkedHashSet<Integrator>();
+	private ClassLoader applicationClassLoader;
+	private ClassLoader resourcesClassLoader;
+	private ClassLoader hibernateClassLoader;
+	private ClassLoader environmentClassLoader;
+
+	private StrategySelectorBuilder strategySelectorBuilder = new StrategySelectorBuilder();
+
+	/**
+	 * Add an {@link Integrator} to be applied to the bootstrap registry.
+	 *
+	 * @param integrator The integrator to add.
+	 * @return {@code this}, for method chaining
+	 */
+	public BootstrapServiceRegistryBuilder with(Integrator integrator) {
+		providedIntegrators.add( integrator );
+		return this;
+	}
+
+	/**
+	 * Applies the specified {@link ClassLoader} as the application class loader for the bootstrap registry
+	 *
+	 * @param classLoader The class loader to use
+	 * @return {@code this}, for method chaining
+	 */
+	@SuppressWarnings( {"UnusedDeclaration"})
+	public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader) {
+		this.applicationClassLoader = classLoader;
+		return this;
+	}
+
+	/**
+	 * Applies the specified {@link ClassLoader} as the resource class loader for the bootstrap registry
+	 *
+	 * @param classLoader The class loader to use
+	 * @return {@code this}, for method chaining
+	 */
+	@SuppressWarnings( {"UnusedDeclaration"})
+	public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader) {
+		this.resourcesClassLoader = classLoader;
+		return this;
+	}
+
+	/**
+	 * Applies the specified {@link ClassLoader} as the Hibernate class loader for the bootstrap registry
+	 *
+	 * @param classLoader The class loader to use
+	 * @return {@code this}, for method chaining
+	 */
+	@SuppressWarnings( {"UnusedDeclaration"})
+	public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader) {
+		this.hibernateClassLoader = classLoader;
+		return this;
+	}
+
+	/**
+	 * Applies the specified {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry
+	 *
+	 * @param classLoader The class loader to use
+	 * @return {@code this}, for method chaining
+	 */
+	@SuppressWarnings( {"UnusedDeclaration"})
+	public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader) {
+		this.environmentClassLoader = classLoader;
+		return this;
+	}
+
+	/**
+	 * Applies a named strategy implementation to the bootstrap registry
+	 *
+	 * @param strategy The strategy
+	 * @param name The registered name
+	 * @param implementation The strategy implementation Class
+	 *
+	 * @return {@code this}, for method chaining
+	 *
+	 * @see org.hibernate.boot.registry.selector.spi.StrategySelector#registerStrategyImplementor(Class, String, Class)
+	 */
+	@SuppressWarnings( {"UnusedDeclaration"})
+	public <T> BootstrapServiceRegistryBuilder withStrategySelector(Class<T> strategy, String name, Class<? extends T> implementation) {
+		this.strategySelectorBuilder.addCustomRegistration( strategy, name, implementation );
+		return this;
+	}
+
+	/**
+	 * Build the bootstrap registry.
+	 *
+	 * @return The built bootstrap registry
+	 */
+	public BootstrapServiceRegistry build() {
+		final ClassLoaderServiceImpl classLoaderService = new ClassLoaderServiceImpl(
+				applicationClassLoader,
+				resourcesClassLoader,
+				hibernateClassLoader,
+				environmentClassLoader
+		);
+
+		final IntegratorServiceImpl integratorService = new IntegratorServiceImpl(
+				providedIntegrators,
+				classLoaderService
+		);
+
+
+		return new BootstrapServiceRegistryImpl(
+				classLoaderService,
+				strategySelectorBuilder.buildSelector( classLoaderService ),
+				integratorService
+		);
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/spi/BasicServiceInitiator.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/StandardServiceInitiator.java
similarity index 86%
rename from hibernate-core/src/main/java/org/hibernate/service/spi/BasicServiceInitiator.java
rename to hibernate-core/src/main/java/org/hibernate/boot/registry/StandardServiceInitiator.java
index 1235549ff6..ceeb6cb1e6 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/spi/BasicServiceInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/StandardServiceInitiator.java
@@ -1,45 +1,47 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.spi;
+package org.hibernate.boot.registry;
 
 import java.util.Map;
 
 import org.hibernate.service.Service;
+import org.hibernate.service.spi.ServiceInitiator;
+import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * Contract for an initiator of services that target the standard {@link org.hibernate.service.ServiceRegistry}
  *
  * @author Steve Ebersole
  */
-public interface BasicServiceInitiator<R extends Service> extends ServiceInitiator<R> {
+public interface StandardServiceInitiator<R extends Service> extends ServiceInitiator<R> {
 	/**
 	 * Initiates the managed service.
 	 *
 	 * @param configurationValues The configuration values in effect
 	 * @param registry The service registry.  Can be used to locate services needed to fulfill initiation.
 	 *
 	 * @return The initiated service.
 	 */
 	public R initiateService(Map configurationValues, ServiceRegistryImplementor registry);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/registry/StandardServiceRegistryBuilder.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/StandardServiceRegistryBuilder.java
new file mode 100644
index 0000000000..0e2d7e3877
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/StandardServiceRegistryBuilder.java
@@ -0,0 +1,224 @@
+/*
+ * Hibernate, Relational Persistence for Idiomatic Java
+ *
+ * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
+ * indicated by the @author tags or express copyright attribution
+ * statements applied by the authors.  All third-party contributions are
+ * distributed under license by Red Hat Inc.
+ *
+ * This copyrighted material is made available to anyone wishing to use, modify,
+ * copy, or redistribute it subject to the terms and conditions of the GNU
+ * Lesser General Public License, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+ * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
+ * for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this distribution; if not, write to:
+ * Free Software Foundation, Inc.
+ * 51 Franklin Street, Fifth Floor
+ * Boston, MA  02110-1301  USA
+ */
+package org.hibernate.boot.registry;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+
+import org.hibernate.cfg.Environment;
+import org.hibernate.integrator.spi.Integrator;
+import org.hibernate.integrator.spi.IntegratorService;
+import org.hibernate.integrator.spi.ServiceContributingIntegrator;
+import org.hibernate.internal.jaxb.cfg.JaxbHibernateConfiguration;
+import org.hibernate.internal.util.config.ConfigurationHelper;
+import org.hibernate.boot.registry.internal.BootstrapServiceRegistryImpl;
+import org.hibernate.service.ConfigLoader;
+import org.hibernate.service.Service;
+import org.hibernate.service.ServiceRegistry;
+import org.hibernate.service.StandardServiceInitiators;
+import org.hibernate.service.internal.ProvidedService;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
+
+/**
+ * Builder for standard {@link org.hibernate.service.ServiceRegistry} instances.
+ *
+ * @author Steve Ebersole
+ * 
+ * @see StandardServiceRegistryImpl
+ * @see org.hibernate.boot.registry.BootstrapServiceRegistryBuilder
+ */
+public class StandardServiceRegistryBuilder {
+	public static final String DEFAULT_CFG_RESOURCE_NAME = "hibernate.cfg.xml";
+
+	private final Map settings;
+	private final List<StandardServiceInitiator> initiators = standardInitiatorList();
+	private final List<ProvidedService> providedServices = new ArrayList<ProvidedService>();
+
+	private final BootstrapServiceRegistry bootstrapServiceRegistry;
+	private final ConfigLoader configLoader;
+
+	/**
+	 * Create a default builder
+	 */
+	public StandardServiceRegistryBuilder() {
+		this( new BootstrapServiceRegistryImpl() );
+	}
+
+	/**
+	 * Create a builder with the specified bootstrap services.
+	 *
+	 * @param bootstrapServiceRegistry Provided bootstrap registry to use.
+	 */
+	public StandardServiceRegistryBuilder(BootstrapServiceRegistry bootstrapServiceRegistry) {
+		this.settings = Environment.getProperties();
+		this.bootstrapServiceRegistry = bootstrapServiceRegistry;
+		this.configLoader = new ConfigLoader( bootstrapServiceRegistry );
+	}
+
+	/**
+	 * Used from the {@link #initiators} variable initializer
+	 *
+	 * @return List of standard initiators
+	 */
+	private static List<StandardServiceInitiator> standardInitiatorList() {
+		final List<StandardServiceInitiator> initiators = new ArrayList<StandardServiceInitiator>();
+		initiators.addAll( StandardServiceInitiators.LIST );
+		return initiators;
+	}
+
+	/**
+	 * Read settings from a {@link Properties} file.  Differs from {@link #configure()} and {@link #configure(String)}
+	 * in that here we read a {@link Properties} file while for {@link #configure} we read the XML variant.
+	 *
+	 * @param resourceName The name by which to perform a resource look up for the properties file.
+	 *
+	 * @return this, for method chaining
+	 *
+	 * @see #configure()
+	 * @see #configure(String)
+	 */
+	@SuppressWarnings( {"unchecked"})
+	public StandardServiceRegistryBuilder loadProperties(String resourceName) {
+		settings.putAll( configLoader.loadProperties( resourceName ) );
+		return this;
+	}
+
+	/**
+	 * Read setting information from an XML file using the standard resource location
+	 *
+	 * @return this, for method chaining
+	 *
+	 * @see #DEFAULT_CFG_RESOURCE_NAME
+	 * @see #configure(String)
+	 * @see #loadProperties(String)
+	 */
+	public StandardServiceRegistryBuilder configure() {
+		return configure( DEFAULT_CFG_RESOURCE_NAME );
+	}
+
+	/**
+	 * Read setting information from an XML file using the named resource location
+	 *
+	 * @param resourceName The named resource
+	 *
+	 * @return this, for method chaining
+	 *
+	 * @see #loadProperties(String)
+	 */
+	@SuppressWarnings( {"unchecked"})
+	public StandardServiceRegistryBuilder configure(String resourceName) {
+		JaxbHibernateConfiguration configurationElement = configLoader.loadConfigXmlResource( resourceName );
+		for ( JaxbHibernateConfiguration.JaxbSessionFactory.JaxbProperty xmlProperty : configurationElement.getSessionFactory().getProperty() ) {
+			settings.put( xmlProperty.getName(), xmlProperty.getValue() );
+		}
+
+		return this;
+	}
+
+	/**
+	 * Apply a setting value
+	 *
+	 * @param settingName The name of the setting
+	 * @param value The value to use.
+	 *
+	 * @return this, for method chaining
+	 */
+	@SuppressWarnings( {"unchecked", "UnusedDeclaration"})
+	public StandardServiceRegistryBuilder applySetting(String settingName, Object value) {
+		settings.put( settingName, value );
+		return this;
+	}
+
+	/**
+	 * Apply a groups of setting values
+	 *
+	 * @param settings The incoming settings to apply
+	 *
+	 * @return this, for method chaining
+	 */
+	@SuppressWarnings( {"unchecked", "UnusedDeclaration"})
+	public StandardServiceRegistryBuilder applySettings(Map settings) {
+		this.settings.putAll( settings );
+		return this;
+	}
+
+	/**
+	 * Adds a service initiator.
+	 *
+	 * @param initiator The initiator to be added
+	 *
+	 * @return this, for method chaining
+	 */
+	@SuppressWarnings( {"UnusedDeclaration"})
+	public StandardServiceRegistryBuilder addInitiator(StandardServiceInitiator initiator) {
+		initiators.add( initiator );
+		return this;
+	}
+
+	/**
+	 * Adds a user-provided service
+	 *
+	 * @param serviceRole The role of the service being added
+	 * @param service The service implementation
+	 *
+	 * @return this, for method chaining
+	 */
+	@SuppressWarnings( {"unchecked"})
+	public StandardServiceRegistryBuilder addService(final Class serviceRole, final Service service) {
+		providedServices.add( new ProvidedService( serviceRole, service ) );
+		return this;
+	}
+
+	/**
+	 * Build the service registry accounting for all settings and service initiators and services.
+	 *
+	 * @return The built service registry
+	 */
+	public ServiceRegistry buildServiceRegistry() {
+		Map<?,?> settingsCopy = new HashMap();
+		settingsCopy.putAll( settings );
+		Environment.verifyProperties( settingsCopy );
+		ConfigurationHelper.resolvePlaceHolders( settingsCopy );
+
+		for ( Integrator integrator : bootstrapServiceRegistry.getService( IntegratorService.class ).getIntegrators() ) {
+			if ( ServiceContributingIntegrator.class.isInstance( integrator ) ) {
+				ServiceContributingIntegrator.class.cast( integrator ).prepareServices( this );
+			}
+		}
+
+		return new StandardServiceRegistryImpl( bootstrapServiceRegistry, initiators, providedServices, settingsCopy );
+	}
+
+	/**
+	 * Destroy a service registry.  Applications should only destroy registries they have explicitly created.
+	 *
+	 * @param serviceRegistry The registry to be closed.
+	 */
+	public static void destroy(ServiceRegistry serviceRegistry) {
+		( (StandardServiceRegistryImpl) serviceRegistry ).destroy();
+	}
+}
diff --git a/hibernate-core/src/main/java/org/hibernate/service/classloading/internal/ClassLoaderServiceImpl.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/internal/ClassLoaderServiceImpl.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/service/classloading/internal/ClassLoaderServiceImpl.java
rename to hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/internal/ClassLoaderServiceImpl.java
index f069ddfc86..bf2b37a391 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/classloading/internal/ClassLoaderServiceImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/internal/ClassLoaderServiceImpl.java
@@ -1,335 +1,335 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.classloading.internal;
+package org.hibernate.boot.registry.classloading.internal;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.ServiceLoader;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.cfg.AvailableSettings;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 
 /**
  * Standard implementation of the service for interacting with class loaders
  *
  * @author Steve Ebersole
  */
 public class ClassLoaderServiceImpl implements ClassLoaderService {
 	private static final Logger log = Logger.getLogger( ClassLoaderServiceImpl.class );
 
 	private final ClassLoader classClassLoader;
 	private final ClassLoader resourcesClassLoader;
 	private final ClassLoader serviceLoaderClassLoader;
 
 	public ClassLoaderServiceImpl() {
 		this( ClassLoaderServiceImpl.class.getClassLoader() );
 	}
 
 	public ClassLoaderServiceImpl(ClassLoader classLoader) {
 		this( classLoader, classLoader, classLoader, classLoader );
 	}
 
 	public ClassLoaderServiceImpl(
 			ClassLoader applicationClassLoader,
 			ClassLoader resourcesClassLoader,
 			ClassLoader hibernateClassLoader,
 			ClassLoader environmentClassLoader) {
 		// Normalize missing loaders
 		if ( hibernateClassLoader == null ) {
 			hibernateClassLoader = ClassLoaderServiceImpl.class.getClassLoader();
 		}
 
 		if ( environmentClassLoader == null || applicationClassLoader == null ) {
 			ClassLoader sysClassLoader = locateSystemClassLoader();
 			ClassLoader tccl = locateTCCL();
 			if ( environmentClassLoader == null ) {
 				environmentClassLoader = sysClassLoader != null ? sysClassLoader : hibernateClassLoader;
 			}
 			if ( applicationClassLoader == null ) {
 				applicationClassLoader = tccl != null ? tccl : hibernateClassLoader;
 			}
 		}
 
 		if ( resourcesClassLoader == null ) {
 			resourcesClassLoader = applicationClassLoader;
 		}
 
 		final LinkedHashSet<ClassLoader> classLoadingClassLoaders = new LinkedHashSet<ClassLoader>();
 		classLoadingClassLoaders.add( applicationClassLoader );
 		classLoadingClassLoaders.add( hibernateClassLoader );
 		classLoadingClassLoaders.add( environmentClassLoader );
 
 		this.classClassLoader = new ClassLoader(null) {
 			@Override
 			protected Class<?> findClass(String name) throws ClassNotFoundException {
 				for ( ClassLoader loader : classLoadingClassLoaders ) {
 					try {
 						return loader.loadClass( name );
 					}
 					catch (Exception ignore) {
 					}
 				}
 				throw new ClassNotFoundException( "Could not load requested class : " + name );
 			}
 		};
 
 		this.resourcesClassLoader = resourcesClassLoader;
 
 		this.serviceLoaderClassLoader = buildServiceLoaderClassLoader();
 	}
 
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public static ClassLoaderServiceImpl fromConfigSettings(Map configVales) {
 		return new ClassLoaderServiceImpl(
 				(ClassLoader) configVales.get( AvailableSettings.APP_CLASSLOADER ),
 				(ClassLoader) configVales.get( AvailableSettings.RESOURCES_CLASSLOADER ),
 				(ClassLoader) configVales.get( AvailableSettings.HIBERNATE_CLASSLOADER ),
 				(ClassLoader) configVales.get( AvailableSettings.ENVIRONMENT_CLASSLOADER )
 		);
 	}
 
 	private static ClassLoader locateSystemClassLoader() {
 		try {
 			return ClassLoader.getSystemClassLoader();
 		}
 		catch ( Exception e ) {
 			return null;
 		}
 	}
 
 	private static ClassLoader locateTCCL() {
 		try {
 			return Thread.currentThread().getContextClassLoader();
 		}
 		catch ( Exception e ) {
 			return null;
 		}
 	}
 
 	private ClassLoader buildServiceLoaderClassLoader() {
 		return new ClassLoader(null) {
 			final ClassLoader[] classLoaderArray = new ClassLoader[] {
 					// first look on the hibernate class loader
 					getClass().getClassLoader(),
 					// next look on the resource class loader
 					resourcesClassLoader,
 					// finally look on the combined class class loader
 					classClassLoader
 			};
 
 			@Override
 			public Enumeration<URL> getResources(String name) throws IOException {
 				final HashSet<URL> resourceUrls = new HashSet<URL>();
 
 				for ( ClassLoader classLoader : classLoaderArray ) {
 					final Enumeration<URL> urls = classLoader.getResources( name );
 					while ( urls.hasMoreElements() ) {
 						resourceUrls.add( urls.nextElement() );
 					}
 				}
 
 				return new Enumeration<URL>() {
 					final Iterator<URL> resourceUrlIterator = resourceUrls.iterator();
 					@Override
 					public boolean hasMoreElements() {
 						return resourceUrlIterator.hasNext();
 					}
 
 					@Override
 					public URL nextElement() {
 						return resourceUrlIterator.next();
 					}
 				};
 			}
 
 			@Override
 			protected URL findResource(String name) {
 				for ( ClassLoader classLoader : classLoaderArray ) {
 					final URL resource = classLoader.getResource( name );
 					if ( resource != null ) {
 						return resource;
 					}
 				}
 				return super.findResource( name );
 			}
 
 			@Override
 			protected Class<?> findClass(String name) throws ClassNotFoundException {
 				for ( ClassLoader classLoader : classLoaderArray ) {
 					try {
 						return classLoader.loadClass( name );
 					}
 					catch (Exception ignore) {
 					}
 				}
 
 				throw new ClassNotFoundException( "Could not load requested class : " + name );
 			}
 		};
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> Class<T> classForName(String className) {
 		try {
 			return (Class<T>) Class.forName( className, true, classClassLoader );
 		}
 		catch (Exception e) {
 			throw new ClassLoadingException( "Unable to load class [" + className + "]", e );
 		}
 	}
 
 	@Override
 	public URL locateResource(String name) {
 		// first we try name as a URL
 		try {
 			return new URL( name );
 		}
 		catch ( Exception ignore ) {
 		}
 
 		try {
 			return resourcesClassLoader.getResource( name );
 		}
 		catch ( Exception ignore ) {
 		}
 
 		return null;
 	}
 
 	@Override
 	public InputStream locateResourceStream(String name) {
 		// first we try name as a URL
 		try {
 			log.tracef( "trying via [new URL(\"%s\")]", name );
 			return new URL( name ).openStream();
 		}
 		catch ( Exception ignore ) {
 		}
 
 		try {
 			log.tracef( "trying via [ClassLoader.getResourceAsStream(\"%s\")]", name );
 			InputStream stream =  resourcesClassLoader.getResourceAsStream( name );
 			if ( stream != null ) {
 				return stream;
 			}
 		}
 		catch ( Exception ignore ) {
 		}
 
 		final String stripped = name.startsWith( "/" ) ? name.substring(1) : null;
 
 		if ( stripped != null ) {
 			try {
 				log.tracef( "trying via [new URL(\"%s\")]", stripped );
 				return new URL( stripped ).openStream();
 			}
 			catch ( Exception ignore ) {
 			}
 
 			try {
 				log.tracef( "trying via [ClassLoader.getResourceAsStream(\"%s\")]", stripped );
 				InputStream stream = resourcesClassLoader.getResourceAsStream( stripped );
 				if ( stream != null ) {
 					return stream;
 				}
 			}
 			catch ( Exception ignore ) {
 			}
 		}
 
 		return null;
 	}
 
 	@Override
 	public List<URL> locateResources(String name) {
 		ArrayList<URL> urls = new ArrayList<URL>();
 		try {
 			Enumeration<URL> urlEnumeration = resourcesClassLoader.getResources( name );
 			if ( urlEnumeration != null && urlEnumeration.hasMoreElements() ) {
 				while ( urlEnumeration.hasMoreElements() ) {
 					urls.add( urlEnumeration.nextElement() );
 				}
 			}
 		}
 		catch ( Exception ignore ) {
 		}
 
 		return urls;
 	}
 
 	@Override
 	public <S> LinkedHashSet<S> loadJavaServices(Class<S> serviceContract) {
 		final ServiceLoader<S> loader = ServiceLoader.load( serviceContract, serviceLoaderClassLoader );
 		final LinkedHashSet<S> services = new LinkedHashSet<S>();
 		for ( S service : loader ) {
 			services.add( service );
 		}
 
 		return services;
 	}
 
 	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 	// completely temporary !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 	// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
 	public static interface Work<T> {
 		public T perform();
 	}
 
 	public <T> T withTccl(Work<T> work) {
 		final ClassLoader tccl = Thread.currentThread().getContextClassLoader();
 
 		boolean set = false;
 
 		try {
 			Thread.currentThread().setContextClassLoader( serviceLoaderClassLoader);
 			set = true;
 		}
 		catch (Exception ignore) {
 		}
 
 		try {
 			return work.perform();
 		}
 		finally {
 			if ( set ) {
 				Thread.currentThread().setContextClassLoader( tccl );
 			}
 		}
 
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/classloading/spi/ClassLoaderService.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/spi/ClassLoaderService.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/service/classloading/spi/ClassLoaderService.java
rename to hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/spi/ClassLoaderService.java
index 5bbd2a0555..cc4cbe4d02 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/classloading/spi/ClassLoaderService.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/spi/ClassLoaderService.java
@@ -1,89 +1,89 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.classloading.spi;
+package org.hibernate.boot.registry.classloading.spi;
 
 import java.io.InputStream;
 import java.net.URL;
 import java.util.LinkedHashSet;
 import java.util.List;
 
 import org.hibernate.service.Service;
 
 /**
  * A service for interacting with class loaders
  *
  * @author Steve Ebersole
  */
 public interface ClassLoaderService extends Service {
 	/**
 	 * Locate a class by name
 	 *
 	 * @param className The name of the class to locate
 	 *
 	 * @return The class reference
 	 *
 	 * @throws ClassLoadingException Indicates the class could not be found
 	 */
 	public <T> Class<T> classForName(String className);
 
 	/**
 	 * Locate a resource by name (classpath lookup)
 	 *
 	 * @param name The resource name.
 	 *
 	 * @return The located URL; may return {@code null} to indicate the resource was not found
 	 */
 	public URL locateResource(String name);
 
 	/**
 	 * Locate a resource by name (classpath lookup) and gets its stream
 	 *
 	 * @param name The resource name.
 	 *
 	 * @return The stream of the located resource; may return {@code null} to indicate the resource was not found
 	 */
 	public InputStream locateResourceStream(String name);
 
 	/**
 	 * Locate a series of resource by name (classpath lookup)
 	 *
 	 * @param name The resource name.
 	 *
 	 * @return The list of URL matching; may return {@code null} to indicate the resource was not found
 	 */
 	public List<URL> locateResources(String name);
 
 	/**
 	 * Discovers and instantiates implementations of the named service contract.
 	 * <p/>
 	 * NOTE : the terms service here is used differently than {@link Service}.  Instead here we are talking about
 	 * services as defined by {@link java.util.ServiceLoader}.
 	 *
 	 * @param serviceContract The java type defining the service contract
 	 * @param <S> The type of the service contract
 	 *     
 	 * @return The ordered set of discovered services.
 	 */
 	public <S> LinkedHashSet<S> loadJavaServices(Class<S> serviceContract);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/classloading/spi/ClassLoadingException.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/spi/ClassLoadingException.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/service/classloading/spi/ClassLoadingException.java
rename to hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/spi/ClassLoadingException.java
index b7219ae444..ce02f02f99 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/classloading/spi/ClassLoadingException.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/classloading/spi/ClassLoadingException.java
@@ -1,40 +1,40 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.classloading.spi;
+package org.hibernate.boot.registry.classloading.spi;
 import org.hibernate.HibernateException;
 
 /**
  * Indicates a problem performing class loading
  *
  * @author Steve Ebersole
  */
 public class ClassLoadingException extends HibernateException {
 	public ClassLoadingException(String string, Throwable root) {
 		super( string, root );
 	}
 
 	public ClassLoadingException(String s) {
 		super( s );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/internal/BootstrapServiceRegistryImpl.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/internal/BootstrapServiceRegistryImpl.java
similarity index 86%
rename from hibernate-core/src/main/java/org/hibernate/service/internal/BootstrapServiceRegistryImpl.java
rename to hibernate-core/src/main/java/org/hibernate/boot/registry/internal/BootstrapServiceRegistryImpl.java
index 3659ce8b71..2780846ea3 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/internal/BootstrapServiceRegistryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/internal/BootstrapServiceRegistryImpl.java
@@ -1,167 +1,172 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.internal;
+package org.hibernate.boot.registry.internal;
 
 import java.util.LinkedHashSet;
 
 import org.hibernate.integrator.internal.IntegratorServiceImpl;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.integrator.spi.IntegratorService;
-import org.hibernate.service.BootstrapServiceRegistry;
+import org.hibernate.boot.registry.BootstrapServiceRegistry;
 import org.hibernate.service.Service;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.classloading.internal.ClassLoaderServiceImpl;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.selector.internal.StrategySelectorImpl;
-import org.hibernate.service.selector.spi.StrategySelector;
+import org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.selector.internal.StrategySelectorImpl;
+import org.hibernate.boot.registry.selector.spi.StrategySelector;
 import org.hibernate.service.spi.ServiceBinding;
 import org.hibernate.service.spi.ServiceException;
 import org.hibernate.service.spi.ServiceInitiator;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * {@link ServiceRegistry} implementation containing specialized "bootstrap" services, specifically:<ul>
  * <li>{@link ClassLoaderService}</li>
  * <li>{@link IntegratorService}</li>
  * </ul>
  *
+ * IMPL NOTE : Currently implements the deprecated {@link org.hibernate.service.BootstrapServiceRegistry} contract
+ * so that the registry returned from the builder works on the deprecated sense.  Once
+ * {@link org.hibernate.service.BootstrapServiceRegistry} goes away, this should be updated to instead implement
+ * {@link org.hibernate.boot.registry.BootstrapServiceRegistry}.
+ *
  * @author Steve Ebersole
  */
 public class BootstrapServiceRegistryImpl
 		implements ServiceRegistryImplementor, BootstrapServiceRegistry, ServiceBinding.ServiceLifecycleOwner {
 	private static final LinkedHashSet<Integrator> NO_INTEGRATORS = new LinkedHashSet<Integrator>();
 
 	private final ServiceBinding<ClassLoaderService> classLoaderServiceBinding;
 	private final ServiceBinding<StrategySelector> strategySelectorBinding;
 	private final ServiceBinding<IntegratorService> integratorServiceBinding;
 
 	public BootstrapServiceRegistryImpl() {
 		this( new ClassLoaderServiceImpl(), NO_INTEGRATORS );
 	}
 
 	public BootstrapServiceRegistryImpl(
 			ClassLoaderService classLoaderService,
 			LinkedHashSet<Integrator> providedIntegrators) {
 		this.classLoaderServiceBinding = new ServiceBinding<ClassLoaderService>(
 				this,
 				ClassLoaderService.class,
 				classLoaderService
 		);
 
 		final StrategySelectorImpl strategySelector = new StrategySelectorImpl( classLoaderService );
 		this.strategySelectorBinding = new ServiceBinding<StrategySelector>(
 				this,
 				StrategySelector.class,
 				strategySelector
 		);
 
 		this.integratorServiceBinding = new ServiceBinding<IntegratorService>(
 				this,
 				IntegratorService.class,
 				new IntegratorServiceImpl( providedIntegrators, classLoaderService )
 		);
 	}
 
 	public BootstrapServiceRegistryImpl(
 			ClassLoaderService classLoaderService,
 			StrategySelector strategySelector,
 			IntegratorService integratorService) {
 		this.classLoaderServiceBinding = new ServiceBinding<ClassLoaderService>(
 				this,
 				ClassLoaderService.class,
 				classLoaderService
 		);
 
 		this.strategySelectorBinding = new ServiceBinding<StrategySelector>(
 				this,
 				StrategySelector.class,
 				strategySelector
 		);
 
 		this.integratorServiceBinding = new ServiceBinding<IntegratorService>(
 				this,
 				IntegratorService.class,
 				integratorService
 		);
 	}
 
 
 
 	@Override
 	public <R extends Service> R getService(Class<R> serviceRole) {
 		final ServiceBinding<R> binding = locateServiceBinding( serviceRole );
 		return binding == null ? null : binding.getService();
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <R extends Service> ServiceBinding<R> locateServiceBinding(Class<R> serviceRole) {
 		if ( ClassLoaderService.class.equals( serviceRole ) ) {
 			return (ServiceBinding<R>) classLoaderServiceBinding;
 		}
 		else if ( StrategySelector.class.equals( serviceRole) ) {
 			return (ServiceBinding<R>) strategySelectorBinding;
 		}
 		else if ( IntegratorService.class.equals( serviceRole ) ) {
 			return (ServiceBinding<R>) integratorServiceBinding;
 		}
 
 		return null;
 	}
 
 	@Override
 	public void destroy() {
 	}
 
 	@Override
 	public ServiceRegistry getParentServiceRegistry() {
 		return null;
 	}
 
 	@Override
 	public <R extends Service> R initiateService(ServiceInitiator<R> serviceInitiator) {
 		throw new ServiceException( "Boot-strap registry should only contain provided services" );
 	}
 
 	@Override
 	public <R extends Service> void configureService(ServiceBinding<R> binding) {
 		throw new ServiceException( "Boot-strap registry should only contain provided services" );
 	}
 
 	@Override
 	public <R extends Service> void injectDependencies(ServiceBinding<R> binding) {
 		throw new ServiceException( "Boot-strap registry should only contain provided services" );
 	}
 
 	@Override
 	public <R extends Service> void startService(ServiceBinding<R> binding) {
 		throw new ServiceException( "Boot-strap registry should only contain provided services" );
 	}
 
 	@Override
 	public <R extends Service> void stopService(ServiceBinding<R> binding) {
 		throw new ServiceException( "Boot-strap registry should only contain provided services" );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/internal/StandardServiceRegistryImpl.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/internal/StandardServiceRegistryImpl.java
similarity index 85%
rename from hibernate-core/src/main/java/org/hibernate/service/internal/StandardServiceRegistryImpl.java
rename to hibernate-core/src/main/java/org/hibernate/boot/registry/internal/StandardServiceRegistryImpl.java
index f55423e977..23717955bc 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/internal/StandardServiceRegistryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/internal/StandardServiceRegistryImpl.java
@@ -1,79 +1,81 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.internal;
+package org.hibernate.boot.registry.internal;
 
 import java.util.List;
 import java.util.Map;
 
-import org.hibernate.service.BootstrapServiceRegistry;
+import org.hibernate.boot.registry.StandardServiceInitiator;
+import org.hibernate.boot.registry.BootstrapServiceRegistry;
 import org.hibernate.service.Service;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.service.internal.AbstractServiceRegistryImpl;
+import org.hibernate.service.internal.ProvidedService;
 import org.hibernate.service.spi.Configurable;
 import org.hibernate.service.spi.ServiceBinding;
 import org.hibernate.service.spi.ServiceInitiator;
 
 /**
  * Hibernate implementation of the standard service registry.
  *
  * @author Steve Ebersole
  */
 public class StandardServiceRegistryImpl extends AbstractServiceRegistryImpl implements ServiceRegistry {
 	private final Map configurationValues;
 
 	@SuppressWarnings( {"unchecked"})
 	public StandardServiceRegistryImpl(
 			BootstrapServiceRegistry bootstrapServiceRegistry,
-			List<BasicServiceInitiator> serviceInitiators,
+			List<StandardServiceInitiator> serviceInitiators,
 			List<ProvidedService> providedServices,
 			Map<?, ?> configurationValues) {
 		super( bootstrapServiceRegistry );
 
 		this.configurationValues = configurationValues;
 
 		// process initiators
 		for ( ServiceInitiator initiator : serviceInitiators ) {
 			createServiceBinding( initiator );
 		}
 
 		// then, explicitly provided service instances
 		for ( ProvidedService providedService : providedServices ) {
 			createServiceBinding( providedService );
 		}
 	}
 
 	@Override
 	public <R extends Service> R initiateService(ServiceInitiator<R> serviceInitiator) {
 		// todo : add check/error for unexpected initiator types?
-		return ( (BasicServiceInitiator<R>) serviceInitiator ).initiateService( configurationValues, this );
+		return ( (StandardServiceInitiator<R>) serviceInitiator ).initiateService( configurationValues, this );
 	}
 
 	@Override
 	public <R extends Service> void configureService(ServiceBinding<R> serviceBinding) {
 		if ( Configurable.class.isInstance( serviceBinding.getService() ) ) {
 			( (Configurable) serviceBinding.getService() ).configure( configurationValues );
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/selector/internal/StrategySelectorBuilder.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/selector/internal/StrategySelectorBuilder.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/service/selector/internal/StrategySelectorBuilder.java
rename to hibernate-core/src/main/java/org/hibernate/boot/registry/selector/internal/StrategySelectorBuilder.java
index 54002abb84..1cce52e67b 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/selector/internal/StrategySelectorBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/selector/internal/StrategySelectorBuilder.java
@@ -1,105 +1,105 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.selector.internal;
+package org.hibernate.boot.registry.selector.internal;
 
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.engine.transaction.internal.jdbc.JdbcTransactionFactory;
 import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
 import org.hibernate.engine.transaction.internal.jta.JtaTransactionFactory;
 import org.hibernate.engine.transaction.spi.TransactionFactory;
-import org.hibernate.service.classloading.internal.ClassLoaderServiceImpl;
-import org.hibernate.service.selector.spi.StrategySelectionException;
-import org.hibernate.service.selector.spi.StrategySelector;
+import org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl;
+import org.hibernate.boot.registry.selector.spi.StrategySelectionException;
+import org.hibernate.boot.registry.selector.spi.StrategySelector;
 
 /**
  * @author Steve Ebersole
  */
 public class StrategySelectorBuilder {
 	private static final Logger log = Logger.getLogger( StrategySelectorBuilder.class );
 
 	private static class CustomRegistration<T> {
 		private final Class<T> strategy;
 		private final String name;
 		private final Class<? extends T> implementation;
 
 		private CustomRegistration(Class<T> strategy, String name, Class<? extends T> implementation) {
 			this.strategy = strategy;
 			this.name = name;
 			this.implementation = implementation;
 		}
 
 		public void registerWith(StrategySelectorImpl strategySelector) {
 			strategySelector.registerStrategyImplementor( strategy, name, implementation );
 		}
 	}
 
 	private final List<CustomRegistration> customRegistrations = new ArrayList<CustomRegistration>();
 
 	@SuppressWarnings("unchecked")
 	public <T> void addCustomRegistration(Class<T> strategy, String name, Class<? extends T> implementation) {
 		if ( !strategy.isInterface() ) {
 			// not good form...
 			log.debug( "Registering non-interface strategy implementation : " + strategy.getName()  );
 		}
 
 		if ( ! strategy.isAssignableFrom( implementation ) ) {
 			throw new StrategySelectionException(
 					"Implementation class [" + implementation.getName() + "] does not implement strategy interface ["
 							+ strategy.getName() + "]"
 			);
 		}
 		customRegistrations.add( new CustomRegistration( strategy, name, implementation ) );
 	}
 
 	public StrategySelector buildSelector(ClassLoaderServiceImpl classLoaderService) {
 		StrategySelectorImpl strategySelector = new StrategySelectorImpl( classLoaderService );
 
 		// build the baseline...
 		addTransactionFactories( strategySelector );
 
 		// todo : apply auto-discovered registrations
 
 		// apply customizations
 		for ( CustomRegistration customRegistration : customRegistrations ) {
 			customRegistration.registerWith( strategySelector );
 		}
 
 		return strategySelector;
 	}
 
 	private void addTransactionFactories(StrategySelectorImpl strategySelector) {
 		strategySelector.registerStrategyImplementor( TransactionFactory.class, JdbcTransactionFactory.SHORT_NAME, JdbcTransactionFactory.class );
 		strategySelector.registerStrategyImplementor( TransactionFactory.class, "org.hibernate.transaction.JDBCTransactionFactory", JdbcTransactionFactory.class );
 
 		strategySelector.registerStrategyImplementor( TransactionFactory.class, JtaTransactionFactory.SHORT_NAME, JtaTransactionFactory.class );
 		strategySelector.registerStrategyImplementor( TransactionFactory.class, "org.hibernate.transaction.JTATransactionFactory", JtaTransactionFactory.class );
 
 		strategySelector.registerStrategyImplementor( TransactionFactory.class, CMTTransactionFactory.SHORT_NAME, CMTTransactionFactory.class );
 		strategySelector.registerStrategyImplementor( TransactionFactory.class, "org.hibernate.transaction.CMTTransactionFactory", CMTTransactionFactory.class );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/selector/internal/StrategySelectorImpl.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/selector/internal/StrategySelectorImpl.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/service/selector/internal/StrategySelectorImpl.java
rename to hibernate-core/src/main/java/org/hibernate/boot/registry/selector/internal/StrategySelectorImpl.java
index 42e2d45e01..9d7c6b98e4 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/selector/internal/StrategySelectorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/selector/internal/StrategySelectorImpl.java
@@ -1,161 +1,161 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.selector.internal;
+package org.hibernate.boot.registry.selector.internal;
 
 import java.util.Iterator;
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.jboss.logging.Logger;
 
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.classloading.spi.ClassLoadingException;
-import org.hibernate.service.selector.spi.StrategySelectionException;
-import org.hibernate.service.selector.spi.StrategySelector;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.registry.selector.spi.StrategySelectionException;
+import org.hibernate.boot.registry.selector.spi.StrategySelector;
 
 /**
  * @author Steve Ebersole
  */
 public class StrategySelectorImpl implements StrategySelector {
 	private static final Logger log = Logger.getLogger( StrategySelectorImpl.class );
 
 	private final Map<Class,Map<String,Class>> namedStrategyImplementorByStrategyMap
 			= new ConcurrentHashMap<Class, Map<String, Class>>();
 
 	private final ClassLoaderService classLoaderService;
 
 	public StrategySelectorImpl(ClassLoaderService classLoaderService) {
 		this.classLoaderService = classLoaderService;
 	}
 
 	@Override
 	public <T> void registerStrategyImplementor(Class<T> strategy, String name, Class<? extends T> implementation) {
 		Map<String,Class> namedStrategyImplementorMap = namedStrategyImplementorByStrategyMap.get( strategy );
 		if ( namedStrategyImplementorMap == null ) {
 			namedStrategyImplementorMap = new ConcurrentHashMap<String, Class>();
 			namedStrategyImplementorByStrategyMap.put( strategy, namedStrategyImplementorMap );
 		}
 
 		Class old = namedStrategyImplementorMap.put( name, implementation );
 		if ( old == null ) {
 			log.trace(
 					String.format(
 							"Registering named strategy selector [%s] : [%s] -> [%s]",
 							strategy.getName(),
 							name,
 							implementation.getName()
 					)
 			);
 		}
 		else {
 			log.debug(
 					String.format(
 							"Registering named strategy selector [%s] : [%s] -> [%s] (replacing [%s])",
 							strategy.getName(),
 							name,
 							implementation.getName(),
 							old.getName()
 					)
 			);
 		}
 	}
 
 	@Override
 	public <T> void unRegisterStrategyImplementor(Class<T> strategy, Class<? extends T> implementation) {
 		Map<String,Class> namedStrategyImplementorMap = namedStrategyImplementorByStrategyMap.get( strategy );
 		if ( namedStrategyImplementorMap == null ) {
 			log.debug( "Named strategy map did not exist on call to un-register" );
 			return;
 		}
 
 		final Iterator itr = namedStrategyImplementorMap.values().iterator();
 		while ( itr.hasNext() ) {
 			final Class registered = (Class) itr.next();
 			if ( registered.equals( implementation ) ) {
 				itr.remove();
 			}
 		}
 
 		// try tp clean up after ourselves...
 		if ( namedStrategyImplementorMap.isEmpty() ) {
 			namedStrategyImplementorByStrategyMap.remove( strategy );
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public <T> Class<? extends T> selectStrategyImplementor(Class<T> strategy, String name) {
 		Map<String,Class> namedStrategyImplementorMap = namedStrategyImplementorByStrategyMap.get( strategy );
 		if ( namedStrategyImplementorMap != null ) {
 			final Class registered = namedStrategyImplementorMap.get( name );
 			if ( registered != null ) {
 				return (Class<T>) registered;
 			}
 		}
 
 		try {
 			return classLoaderService.classForName( name );
 		}
 		catch (ClassLoadingException e) {
 			throw new StrategySelectionException(
 					"Unable to resolve name [" + name + "] as strategy [" + strategy.getName() + "]"
 			);
 		}
 	}
 
 	@Override
 	public <T> T resolveStrategy(Class<T> strategy, Object strategyReference) {
 		return resolveDefaultableStrategy( strategy, strategyReference, null );
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public <T> T resolveDefaultableStrategy(Class<T> strategy, Object strategyReference, T defaultValue) {
 		if ( strategyReference == null ) {
 			return defaultValue;
 		}
 
 		if ( strategy.isInstance( strategyReference ) ) {
 			return strategy.cast( strategyReference );
 		}
 
 		final Class<? extends T> implementationClass;
 		if ( Class.class.isInstance( strategyReference ) ) {
 			implementationClass = (Class<T>) strategyReference;
 		}
 		else {
 			implementationClass = selectStrategyImplementor( strategy, strategyReference.toString() );
 		}
 
 		try {
 			return implementationClass.newInstance();
 		}
 		catch (Exception e) {
 			throw new StrategySelectionException(
 					String.format( "Could not instantiate named strategy class [%s]", implementationClass.getName() ),
 					e
 			);
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/boot/registry/selector/package-info.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/selector/package-info.java
new file mode 100644
index 0000000000..095e5ca34b
--- /dev/null
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/selector/package-info.java
@@ -0,0 +1 @@
+package org.hibernate.boot.registry.selector;
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/service/selector/spi/StrategySelectionException.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/selector/spi/StrategySelectionException.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/service/selector/spi/StrategySelectionException.java
rename to hibernate-core/src/main/java/org/hibernate/boot/registry/selector/spi/StrategySelectionException.java
index 5caf1e2804..01b63580be 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/selector/spi/StrategySelectionException.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/selector/spi/StrategySelectionException.java
@@ -1,39 +1,39 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.selector.spi;
+package org.hibernate.boot.registry.selector.spi;
 
 import org.hibernate.HibernateException;
 
 /**
  * @author Steve Ebersole
  */
 public class StrategySelectionException extends HibernateException {
 	public StrategySelectionException(String message) {
 		super( message );
 	}
 
 	public StrategySelectionException(String message, Throwable root) {
 		super( message, root );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/selector/spi/StrategySelector.java b/hibernate-core/src/main/java/org/hibernate/boot/registry/selector/spi/StrategySelector.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/service/selector/spi/StrategySelector.java
rename to hibernate-core/src/main/java/org/hibernate/boot/registry/selector/spi/StrategySelector.java
index 222c4dc047..21012a25fb 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/selector/spi/StrategySelector.java
+++ b/hibernate-core/src/main/java/org/hibernate/boot/registry/selector/spi/StrategySelector.java
@@ -1,98 +1,98 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.selector.spi;
+package org.hibernate.boot.registry.selector.spi;
 
 import org.hibernate.service.Service;
 
 /**
  * Service which acts as a registry for named strategy implementations.
  *
  * @author Steve Ebersole
  */
 public interface StrategySelector extends Service {
 	/**
 	 * Registers a named implementor of a particular strategy contract.
 	 *
 	 * @param strategy The strategy contract.
 	 * @param name The registration name
 	 * @param implementation The implementation Class
 	 */
 	public <T> void registerStrategyImplementor(Class<T> strategy, String name, Class<? extends T> implementation);
 
 	/**
 	 * Un-registers a named implementor of a particular strategy contract.  Un-registers all named registrations
 	 * for the given strategy contract naming the given class.
 	 *
 	 * @param strategy The strategy contract.
 	 * @param implementation The implementation Class
 	 */
 	public <T> void unRegisterStrategyImplementor(Class<T> strategy, Class<? extends T> implementation);
 
 	/**
 	 * Locate the named strategy implementation.
 	 *
 	 * @param strategy The type of strategy to be resolved.
 	 * @param name The name of the strategy to locate; might be either a registered name or the implementation FQN.
 	 *
 	 * @return The named strategy implementation class.
 	 */
 	public <T> Class<? extends T> selectStrategyImplementor(Class<T> strategy, String name);
 
 	/**
 	 * Resolve strategy instances. See discussion on {@link #resolveDefaultableStrategy}.
 	 * Only difference is that here, the implied default value is {@code null}.
 	 *
 	 * @param strategy The type (interface) of the strategy to be resolved.
 	 * @param strategyReference The reference to the strategy for which we need to resolve an instance.
 	 *
 	 * @return The strategy instance
 	 */
 	public <T> T resolveStrategy(Class<T> strategy, Object strategyReference);
 
 	/**
 	 * Resolve strategy instances. The incoming reference might be:<ul>
 	 *     <li>
 	 *         {@code null} - in which case defaultValue is returned.
 	 *     </li>
 	 *     <li>
 	 *         An actual instance of the strategy type - it is returned, as is
 	 *     </li>
 	 *     <li>
 	 *         A reference to the implementation {@link Class} - an instance is created by calling
 	 *         {@link Class#newInstance()} (aka, the class's no-arg ctor).
 	 *     </li>
 	 *     <li>
 	 *         The name of the implementation class - First the implementation's {@link Class} reference
 	 *         is resolved, and then an instance is created by calling {@link Class#newInstance()}
 	 *     </li>
 	 * </ul>
 	 *
 	 * @param strategy The type (interface) of the strategy to be resolved.
 	 * @param strategyReference The reference to the strategy for which we need to resolve an instance.
 	 * @param defaultValue THe default value to use if strategyReference is null
 	 *
 	 * @return The strategy instance
 	 */
 	public <T> T resolveDefaultableStrategy(Class<T> strategy, Object strategyReference, T defaultValue);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cache/internal/RegionFactoryInitiator.java b/hibernate-core/src/main/java/org/hibernate/cache/internal/RegionFactoryInitiator.java
index 4089bd846f..6a2002f591 100644
--- a/hibernate-core/src/main/java/org/hibernate/cache/internal/RegionFactoryInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/cache/internal/RegionFactoryInitiator.java
@@ -1,96 +1,96 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cache.internal;
 
 import java.util.Map;
 
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.cache.spi.RegionFactory;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.service.spi.ServiceException;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * Initiator for the {@link RegionFactory} service.
  *
  * @author Hardy Ferentschik
  */
-public class RegionFactoryInitiator implements BasicServiceInitiator<RegionFactory> {
+public class RegionFactoryInitiator implements StandardServiceInitiator<RegionFactory> {
 	public static final RegionFactoryInitiator INSTANCE = new RegionFactoryInitiator();
 
 	/**
 	 * Property name to use to configure the full qualified class name for the {@code RegionFactory}
 	 */
 	public static final String IMPL_NAME = "hibernate.cache.region.factory_class";
 
 	@Override
 	public Class<RegionFactory> getServiceInitiated() {
 		return RegionFactory.class;
 	}
 
 	@Override
 	@SuppressWarnings( { "unchecked" })
 	public RegionFactory initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		final Object impl = configurationValues.get( IMPL_NAME );
 		if ( impl == null ) {
 			return new NoCachingRegionFactory();
 		}
 
 		if ( getServiceInitiated().isInstance( impl ) ) {
 			return (RegionFactory) impl;
 		}
 
 		Class<? extends RegionFactory> customImplClass = null;
 		if ( Class.class.isInstance( impl ) ) {
 			customImplClass = (Class<? extends RegionFactory>) impl;
 		}
 		else {
 			customImplClass = registry.getService( ClassLoaderService.class )
 					.classForName( mapLegacyNames( impl.toString() ) );
 		}
 
 		try {
 			return customImplClass.newInstance();
 		}
 		catch ( Exception e ) {
 			throw new ServiceException(
 					"Could not initialize custom RegionFactory impl [" + customImplClass.getName() + "]", e
 			);
 		}
 	}
 
 	// todo this shouldn't be public (nor really static):
 	// hack for org.hibernate.cfg.SettingsFactory.createRegionFactory()
 	public static String mapLegacyNames(final String name) {
 		if ( "org.hibernate.cache.EhCacheRegionFactory".equals( name ) ) {
 			return "org.hibernate.cache.ehcache.EhCacheRegionFactory";
 		}
 
 		if ( "org.hibernate.cache.SingletonEhCacheRegionFactory".equals( name ) ) {
 			return "org.hibernate.cache.ehcache.SingletonEhCacheRegionFactory";
 		}
 
 		return name;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/AvailableSettings.java b/hibernate-core/src/main/java/org/hibernate/cfg/AvailableSettings.java
index 4a55bb0c36..351d2600e3 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/AvailableSettings.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/AvailableSettings.java
@@ -1,597 +1,597 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 /**
  * @author Steve Ebersole
  */
 public interface AvailableSettings {
 	/**
 	 * Defines a name for the {@link org.hibernate.SessionFactory}.  Useful both to<ul>
 	 *     <li>allow serialization and deserialization to work across different jvms</li>
 	 *     <li>optionally allow the SessionFactory to be bound into JNDI</li>
 	 * </ul>
 	 *
 	 * @see #SESSION_FACTORY_NAME_IS_JNDI
 	 */
 	public static final String SESSION_FACTORY_NAME = "hibernate.session_factory_name";
 
 	/**
 	 * Does the value defined by {@link #SESSION_FACTORY_NAME} represent a {@literal JNDI} namespace into which
 	 * the {@link org.hibernate.SessionFactory} should be bound?
 	 */
 	public static final String SESSION_FACTORY_NAME_IS_JNDI = "hibernate.session_factory_name_is_jndi";
 
 	/**
-	 * Names the {@link org.hibernate.service.jdbc.connections.spi.ConnectionProvider} to use for obtaining
+	 * Names the {@link org.hibernate.engine.jdbc.connections.spi.ConnectionProvider} to use for obtaining
 	 * JDBC connections.  Can either reference an instance of
-	 * {@link org.hibernate.service.jdbc.connections.spi.ConnectionProvider} or a {@link Class} or {@link String}
-	 * reference to the {@link org.hibernate.service.jdbc.connections.spi.ConnectionProvider} implementation
+	 * {@link org.hibernate.engine.jdbc.connections.spi.ConnectionProvider} or a {@link Class} or {@link String}
+	 * reference to the {@link org.hibernate.engine.jdbc.connections.spi.ConnectionProvider} implementation
 	 * class.
 	 */
 	public static final String CONNECTION_PROVIDER ="hibernate.connection.provider_class";
 
 	/**
 	 * Names the {@literal JDBC} driver class
 	 */
 	public static final String DRIVER ="hibernate.connection.driver_class";
 
 	/**
 	 * Names the {@literal JDBC} connection url.
 	 */
 	public static final String URL ="hibernate.connection.url";
 
 	/**
 	 * Names the connection user.  This might mean one of 2 things in out-of-the-box Hibernate
-	 * {@link org.hibernate.service.jdbc.connections.spi.ConnectionProvider}: <ul>
+	 * {@link org.hibernate.engine.jdbc.connections.spi.ConnectionProvider}: <ul>
 	 *     <li>The username used to pass along to creating the JDBC connection</li>
 	 *     <li>The username used to obtain a JDBC connection from a data source</li>
 	 * </ul>
 	 */
 	public static final String USER ="hibernate.connection.username";
 
 	/**
 	 * Names the connection password.  See usage discussion on {@link #USER}
 	 */
 	public static final String PASS ="hibernate.connection.password";
 
 	/**
 	 * Names the {@literal JDBC} transaction isolation level
 	 */
 	public static final String ISOLATION ="hibernate.connection.isolation";
 
 	/**
 	 * Names the {@literal JDBC} autocommit mode
 	 */
 	public static final String AUTOCOMMIT ="hibernate.connection.autocommit";
 
 	/**
 	 * Maximum number of inactive connections for the built-in Hibernate connection pool.
 	 */
 	public static final String POOL_SIZE ="hibernate.connection.pool_size";
 
 	/**
 	 * Names a {@link javax.sql.DataSource}.  Can either reference a {@link javax.sql.DataSource} instance or
 	 * a {@literal JNDI} name under which to locate the {@link javax.sql.DataSource}.
 	 */
 	public static final String DATASOURCE ="hibernate.connection.datasource";
 
 	/**
 	 * Names a prefix used to define arbitrary JDBC connection properties.  These properties are passed along to
 	 * the {@literal JDBC} provider when creating a connection.
 	 */
 	public static final String CONNECTION_PREFIX = "hibernate.connection";
 
 	/**
 	 * Names the {@literal JNDI} {@link javax.naming.InitialContext} class.
 	 *
 	 * @see javax.naming.Context#INITIAL_CONTEXT_FACTORY
 	 */
 	public static final String JNDI_CLASS ="hibernate.jndi.class";
 
 	/**
 	 * Names the {@literal JNDI} provider/connection url
 	 *
 	 * @see javax.naming.Context#PROVIDER_URL
 	 */
 	public static final String JNDI_URL ="hibernate.jndi.url";
 
 	/**
 	 * Names a prefix used to define arbitrary {@literal JNDI} {@link javax.naming.InitialContext} properties.  These
 	 * properties are passed along to {@link javax.naming.InitialContext#InitialContext(java.util.Hashtable)}
 	 */
 	public static final String JNDI_PREFIX = "hibernate.jndi";
 
 	/**
 	 * Names the Hibernate {@literal SQL} {@link org.hibernate.dialect.Dialect} class
 	 */
 	public static final String DIALECT ="hibernate.dialect";
 
 	/**
-	 * Names any additional {@link org.hibernate.service.jdbc.dialect.spi.DialectResolver} implementations to
-	 * register with the standard {@link org.hibernate.service.jdbc.dialect.spi.DialectFactory}.
+	 * Names any additional {@link org.hibernate.engine.jdbc.dialect.spi.DialectResolver} implementations to
+	 * register with the standard {@link org.hibernate.engine.jdbc.dialect.spi.DialectFactory}.
 	 */
 	public static final String DIALECT_RESOLVERS = "hibernate.dialect_resolvers";
 
 
 	/**
 	 * A default database schema (owner) name to use for unqualified tablenames
 	 */
 	public static final String DEFAULT_SCHEMA = "hibernate.default_schema";
 	/**
 	 * A default database catalog name to use for unqualified tablenames
 	 */
 	public static final String DEFAULT_CATALOG = "hibernate.default_catalog";
 
 	/**
 	 * Enable logging of generated SQL to the console
 	 */
 	public static final String SHOW_SQL ="hibernate.show_sql";
 	/**
 	 * Enable formatting of SQL logged to the console
 	 */
 	public static final String FORMAT_SQL ="hibernate.format_sql";
 	/**
 	 * Add comments to the generated SQL
 	 */
 	public static final String USE_SQL_COMMENTS ="hibernate.use_sql_comments";
 	/**
 	 * Maximum depth of outer join fetching
 	 */
 	public static final String MAX_FETCH_DEPTH = "hibernate.max_fetch_depth";
 	/**
 	 * The default batch size for batch fetching
 	 */
 	public static final String DEFAULT_BATCH_FETCH_SIZE = "hibernate.default_batch_fetch_size";
 	/**
 	 * Use <tt>java.io</tt> streams to read / write binary data from / to JDBC
 	 */
 	public static final String USE_STREAMS_FOR_BINARY = "hibernate.jdbc.use_streams_for_binary";
 	/**
 	 * Use JDBC scrollable <tt>ResultSet</tt>s. This property is only necessary when there is
 	 * no <tt>ConnectionProvider</tt>, ie. the user is supplying JDBC connections.
 	 */
 	public static final String USE_SCROLLABLE_RESULTSET = "hibernate.jdbc.use_scrollable_resultset";
 	/**
 	 * Tells the JDBC driver to attempt to retrieve row Id with the JDBC 3.0 PreparedStatement.getGeneratedKeys()
 	 * method. In general, performance will be better if this property is set to true and the underlying
 	 * JDBC driver supports getGeneratedKeys().
 	 */
 	public static final String USE_GET_GENERATED_KEYS = "hibernate.jdbc.use_get_generated_keys";
 	/**
 	 * Gives the JDBC driver a hint as to the number of rows that should be fetched from the database
 	 * when more rows are needed. If <tt>0</tt>, JDBC driver default settings will be used.
 	 */
 	public static final String STATEMENT_FETCH_SIZE = "hibernate.jdbc.fetch_size";
 	/**
 	 * Maximum JDBC batch size. A nonzero value enables batch updates.
 	 */
 	public static final String STATEMENT_BATCH_SIZE = "hibernate.jdbc.batch_size";
 	/**
 	 * Select a custom batcher.
 	 */
 	public static final String BATCH_STRATEGY = "hibernate.jdbc.factory_class";
 	/**
 	 * Should versioned data be included in batching?
 	 */
 	public static final String BATCH_VERSIONED_DATA = "hibernate.jdbc.batch_versioned_data";
 	/**
 	 * An XSLT resource used to generate "custom" XML
 	 */
 	public static final String OUTPUT_STYLESHEET ="hibernate.xml.output_stylesheet";
 
 	/**
 	 * Maximum size of C3P0 connection pool
 	 */
 	public static final String C3P0_MAX_SIZE = "hibernate.c3p0.max_size";
 	/**
 	 * Minimum size of C3P0 connection pool
 	 */
 	public static final String C3P0_MIN_SIZE = "hibernate.c3p0.min_size";
 
 	/**
 	 * Maximum idle time for C3P0 connection pool
 	 */
 	public static final String C3P0_TIMEOUT = "hibernate.c3p0.timeout";
 	/**
 	 * Maximum size of C3P0 statement cache
 	 */
 	public static final String C3P0_MAX_STATEMENTS = "hibernate.c3p0.max_statements";
 	/**
 	 * Number of connections acquired when pool is exhausted
 	 */
 	public static final String C3P0_ACQUIRE_INCREMENT = "hibernate.c3p0.acquire_increment";
 	/**
 	 * Idle time before a C3P0 pooled connection is validated
 	 */
 	public static final String C3P0_IDLE_TEST_PERIOD = "hibernate.c3p0.idle_test_period";
 
 	/**
 	 * Proxool/Hibernate property prefix
 	 * @deprecated Use {@link #PROXOOL_CONFIG_PREFIX} instead
 	 */
 	public static final String PROXOOL_PREFIX = "hibernate.proxool";
 	/**
 	 * Proxool property to configure the Proxool Provider using an XML (<tt>/path/to/file.xml</tt>)
 	 */
 	public static final String PROXOOL_XML = "hibernate.proxool.xml";
 	/**
 	 * Proxool property to configure the Proxool Provider  using a properties file (<tt>/path/to/proxool.properties</tt>)
 	 */
 	public static final String PROXOOL_PROPERTIES = "hibernate.proxool.properties";
 	/**
 	 * Proxool property to configure the Proxool Provider from an already existing pool (<tt>true</tt> / <tt>false</tt>)
 	 */
 	public static final String PROXOOL_EXISTING_POOL = "hibernate.proxool.existing_pool";
 	/**
 	 * Proxool property with the Proxool pool alias to use
 	 * (Required for <tt>PROXOOL_EXISTING_POOL</tt>, <tt>PROXOOL_PROPERTIES</tt>, or
 	 * <tt>PROXOOL_XML</tt>)
 	 */
 	public static final String PROXOOL_POOL_ALIAS = "hibernate.proxool.pool_alias";
 
 	/**
 	 * Enable automatic session close at end of transaction
 	 */
 	public static final String AUTO_CLOSE_SESSION = "hibernate.transaction.auto_close_session";
 	/**
 	 * Enable automatic flush during the JTA <tt>beforeCompletion()</tt> callback
 	 */
 	public static final String FLUSH_BEFORE_COMPLETION = "hibernate.transaction.flush_before_completion";
 	/**
 	 * Specifies how Hibernate should release JDBC connections.
 	 */
 	public static final String RELEASE_CONNECTIONS = "hibernate.connection.release_mode";
 	/**
 	 * Context scoping impl for {@link org.hibernate.SessionFactory#getCurrentSession()} processing.
 	 */
 	public static final String CURRENT_SESSION_CONTEXT_CLASS = "hibernate.current_session_context_class";
 
 	/**
 	 * Names the implementation of {@link org.hibernate.engine.transaction.spi.TransactionContext} to use for
 	 * creating {@link org.hibernate.Transaction} instances
 	 */
 	public static final String TRANSACTION_STRATEGY = "hibernate.transaction.factory_class";
 
 	/**
-	 * Names the {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation to use for integrating
-	 * with {@literal JTA} systems.  Can reference either a {@link org.hibernate.service.jta.platform.spi.JtaPlatform}
-	 * instance or the name of the {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation class
+	 * Names the {@link org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform} implementation to use for integrating
+	 * with {@literal JTA} systems.  Can reference either a {@link org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform}
+	 * instance or the name of the {@link org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform} implementation class
 	 * @since 4.0
 	 */
 	public static final String JTA_PLATFORM = "hibernate.transaction.jta.platform";
 
 	/**
 	 * Names the {@link org.hibernate.transaction.TransactionManagerLookup} implementation to use for obtaining
 	 * reference to the {@literal JTA} {@link javax.transaction.TransactionManager}
 	 *
 	 * @deprecated See {@link #JTA_PLATFORM}
 	 */
 	@Deprecated
 	public static final String TRANSACTION_MANAGER_STRATEGY = "hibernate.transaction.manager_lookup_class";
 
 	/**
 	 * JNDI name of JTA <tt>UserTransaction</tt> object
 	 *
 	 * @deprecated See {@link #JTA_PLATFORM}
 	 */
 	@Deprecated
 	public static final String USER_TRANSACTION = "jta.UserTransaction";
 
 	/**
 	 * The {@link org.hibernate.cache.spi.RegionFactory} implementation class
 	 */
 	public static final String CACHE_REGION_FACTORY = "hibernate.cache.region.factory_class";
 
 	/**
 	 * The <tt>CacheProvider</tt> implementation class
 	 */
 	public static final String CACHE_PROVIDER_CONFIG = "hibernate.cache.provider_configuration_file_resource_path";
 	/**
 	 * The <tt>CacheProvider</tt> JNDI namespace, if pre-bound to JNDI.
 	 */
 	public static final String CACHE_NAMESPACE = "hibernate.cache.jndi";
 	/**
 	 * Enable the query cache (disabled by default)
 	 */
 	public static final String USE_QUERY_CACHE = "hibernate.cache.use_query_cache";
 	/**
 	 * The <tt>QueryCacheFactory</tt> implementation class.
 	 */
 	public static final String QUERY_CACHE_FACTORY = "hibernate.cache.query_cache_factory";
 	/**
 	 * Enable the second-level cache (enabled by default)
 	 */
 	public static final String USE_SECOND_LEVEL_CACHE = "hibernate.cache.use_second_level_cache";
 	/**
 	 * Optimize the cache for minimal puts instead of minimal gets
 	 */
 	public static final String USE_MINIMAL_PUTS = "hibernate.cache.use_minimal_puts";
 	/**
 	 * The <tt>CacheProvider</tt> region name prefix
 	 */
 	public static final String CACHE_REGION_PREFIX = "hibernate.cache.region_prefix";
 	/**
 	 * Enable use of structured second-level cache entries
 	 */
 	public static final String USE_STRUCTURED_CACHE = "hibernate.cache.use_structured_entries";
 
 	/**
 	 * Enable statistics collection
 	 */
 	public static final String GENERATE_STATISTICS = "hibernate.generate_statistics";
 
 	public static final String USE_IDENTIFIER_ROLLBACK = "hibernate.use_identifier_rollback";
 
 	/**
 	 * Use bytecode libraries optimized property access
 	 */
 	public static final String USE_REFLECTION_OPTIMIZER = "hibernate.bytecode.use_reflection_optimizer";
 
 	/**
 	 * The classname of the HQL query parser factory
 	 */
 	public static final String QUERY_TRANSLATOR = "hibernate.query.factory_class";
 
 	/**
 	 * A comma-separated list of token substitutions to use when translating a Hibernate
 	 * query to SQL
 	 */
 	public static final String QUERY_SUBSTITUTIONS = "hibernate.query.substitutions";
 
 	/**
 	 * Should named queries be checked during startup (the default is enabled).
 	 * <p/>
 	 * Mainly intended for test environments.
 	 */
 	public static final String QUERY_STARTUP_CHECKING = "hibernate.query.startup_check";
 
 	/**
 	 * Auto export/update schema using hbm2ddl tool. Valid values are <tt>update</tt>,
 	 * <tt>create</tt>, <tt>create-drop</tt> and <tt>validate</tt>.
 	 */
 	public static final String HBM2DDL_AUTO = "hibernate.hbm2ddl.auto";
 
 	/**
 	 * Comma-separated names of the optional files containing SQL DML statements executed
 	 * during the SessionFactory creation.
 	 * File order matters, the statements of a give file are executed before the statements of the
 	 * following files.
 	 *
 	 * These statements are only executed if the schema is created ie if <tt>hibernate.hbm2ddl.auto</tt>
 	 * is set to <tt>create</tt> or <tt>create-drop</tt>.
 	 *
 	 * The default value is <tt>/import.sql</tt>
 	 */
 	public static final String HBM2DDL_IMPORT_FILES = "hibernate.hbm2ddl.import_files";
 
 	/**
 	 * {@link String} reference to {@link org.hibernate.tool.hbm2ddl.ImportSqlCommandExtractor} implementation class.
 	 * Referenced implementation is required to provide non-argument constructor.
 	 *
 	 * The default value is <tt>org.hibernate.tool.hbm2ddl.SingleLineSqlCommandExtractor</tt>.
 	 */
 	public static final String HBM2DDL_IMPORT_FILES_SQL_EXTRACTOR = "hibernate.hbm2ddl.import_files_sql_extractor";
 
 	/**
 	 * The {@link org.hibernate.exception.spi.SQLExceptionConverter} to use for converting SQLExceptions
 	 * to Hibernate's JDBCException hierarchy.  The default is to use the configured
 	 * {@link org.hibernate.dialect.Dialect}'s preferred SQLExceptionConverter.
 	 */
 	public static final String SQL_EXCEPTION_CONVERTER = "hibernate.jdbc.sql_exception_converter";
 
 	/**
 	 * Enable wrapping of JDBC result sets in order to speed up column name lookups for
 	 * broken JDBC drivers
 	 */
 	public static final String WRAP_RESULT_SETS = "hibernate.jdbc.wrap_result_sets";
 
 	/**
 	 * Enable ordering of update statements by primary key value
 	 */
 	public static final String ORDER_UPDATES = "hibernate.order_updates";
 
 	/**
 	 * Enable ordering of insert statements for the purpose of more efficient JDBC batching.
 	 */
 	public static final String ORDER_INSERTS = "hibernate.order_inserts";
 
 	/**
 	 * The EntityMode in which set the Session opened from the SessionFactory.
 	 */
     public static final String DEFAULT_ENTITY_MODE = "hibernate.default_entity_mode";
 
     /**
      * The jacc context id of the deployment
      */
     public static final String JACC_CONTEXTID = "hibernate.jacc_context_id";
 
 	/**
 	 * Should all database identifiers be quoted.
 	 */
 	public static final String GLOBALLY_QUOTED_IDENTIFIERS = "hibernate.globally_quoted_identifiers";
 
 	/**
 	 * Enable nullability checking.
 	 * Raises an exception if a property marked as not-null is null.
 	 * Default to false if Bean Validation is present in the classpath and Hibernate Annotations is used,
 	 * true otherwise.
 	 */
 	public static final String CHECK_NULLABILITY = "hibernate.check_nullability";
 
 
 	public static final String BYTECODE_PROVIDER = "hibernate.bytecode.provider";
 
 	public static final String JPAQL_STRICT_COMPLIANCE= "hibernate.query.jpaql_strict_compliance";
 
 	/**
 	 * When using pooled {@link org.hibernate.id.enhanced.Optimizer optimizers}, prefer interpreting the
 	 * database value as the lower (lo) boundary.  The default is to interpret it as the high boundary.
 	 */
 	public static final String PREFER_POOLED_VALUES_LO = "hibernate.id.optimizer.pooled.prefer_lo";
 
 	/**
 	 * The maximum number of strong references maintained by {@link org.hibernate.engine.query.spi.QueryPlanCache}. Default is 128.
 	 * @deprecated in favor of {@link #QUERY_PLAN_CACHE_PARAMETER_METADATA_MAX_SIZE}
 	 */
 	@Deprecated
 	public static final String QUERY_PLAN_CACHE_MAX_STRONG_REFERENCES = "hibernate.query.plan_cache_max_strong_references";
 
 	/**
 	 * The maximum number of soft references maintained by {@link org.hibernate.engine.query.spi.QueryPlanCache}. Default is 2048.
 	 * @deprecated in favor of {@link #QUERY_PLAN_CACHE_MAX_SIZE}
 	 */
 	@Deprecated
 	public static final String QUERY_PLAN_CACHE_MAX_SOFT_REFERENCES = "hibernate.query.plan_cache_max_soft_references";
 
 	/**
 	 * The maximum number of entries including:
 	 * <ul>
 	 *     <li>{@link org.hibernate.engine.query.spi.HQLQueryPlan}</li>
 	 *     <li>{@link org.hibernate.engine.query.spi.FilterQueryPlan}</li>
 	 *     <li>{@link org.hibernate.engine.query.spi.NativeSQLQueryPlan}</li>
 	 * </ul>
 	 * 
 	 * maintained by {@link org.hibernate.engine.query.spi.QueryPlanCache}. Default is 2048.
 	 */
 	public static final String QUERY_PLAN_CACHE_MAX_SIZE = "hibernate.query.plan_cache_max_size";
 
 	/**
 	 * The maximum number of {@link org.hibernate.engine.query.spi.ParameterMetadata} maintained 
 	 * by {@link org.hibernate.engine.query.spi.QueryPlanCache}. Default is 128.
 	 */
 	public static final String QUERY_PLAN_CACHE_PARAMETER_METADATA_MAX_SIZE = "hibernate.query.plan_parameter_metadata_max_size";
 
 	/**
 	 * Should we not use contextual LOB creation (aka based on {@link java.sql.Connection#createBlob()} et al).
 	 */
 	public static final String NON_CONTEXTUAL_LOB_CREATION = "hibernate.jdbc.lob.non_contextual_creation";
 
 	/**
 	 * Names the {@link ClassLoader} used to load user application classes.
 	 * @since 4.0
 	 */
 	public static final String APP_CLASSLOADER = "hibernate.classLoader.application";
 
 	/**
 	 * Names the {@link ClassLoader} Hibernate should use to perform resource loading.
 	 * @since 4.0
 	 */
 	public static final String RESOURCES_CLASSLOADER = "hibernate.classLoader.resources";
 
 	/**
 	 * Names the {@link ClassLoader} responsible for loading Hibernate classes.  By default this is
 	 * the {@link ClassLoader} that loaded this class.
 	 * @since 4.0
 	 */
 	public static final String HIBERNATE_CLASSLOADER = "hibernate.classLoader.hibernate";
 
 	/**
 	 * Names the {@link ClassLoader} used when Hibernate is unable to locates classes on the
 	 * {@link #APP_CLASSLOADER} or {@link #HIBERNATE_CLASSLOADER}.
 	 * @since 4.0
 	 */
 	public static final String ENVIRONMENT_CLASSLOADER = "hibernate.classLoader.environment";
 
 
 	public static final String C3P0_CONFIG_PREFIX = "hibernate.c3p0";
 
 	public static final String PROXOOL_CONFIG_PREFIX = "hibernate.proxool";
 
 
 	public static final String JMX_ENABLED = "hibernate.jmx.enabled";
 	public static final String JMX_PLATFORM_SERVER = "hibernate.jmx.usePlatformServer";
 	public static final String JMX_AGENT_ID = "hibernate.jmx.agentId";
 	public static final String JMX_DOMAIN_NAME = "hibernate.jmx.defaultDomain";
 	public static final String JMX_SF_NAME = "hibernate.jmx.sessionFactoryName";
 	public static final String JMX_DEFAULT_OBJ_NAME_DOMAIN = "org.hibernate.core";
 
 	/**
 	 * A configuration value key used to indicate that it is safe to cache
 	 * {@link javax.transaction.TransactionManager} references.
 	 * @since 4.0
 	 */
 	public static final String JTA_CACHE_TM = "hibernate.jta.cacheTransactionManager";
 
 	/**
 	 * A configuration value key used to indicate that it is safe to cache
 	 * {@link javax.transaction.UserTransaction} references.
 	 * @since 4.0
 	 */
 	public static final String JTA_CACHE_UT = "hibernate.jta.cacheUserTransaction";
 
 	/**
 	 * Setting used to give the name of the default {@link org.hibernate.annotations.CacheConcurrencyStrategy}
 	 * to use when either {@link javax.persistence.Cacheable @Cacheable} or
 	 * {@link org.hibernate.annotations.Cache @Cache} is used.  {@link org.hibernate.annotations.Cache @Cache(strategy="..")} is used to override.
 	 */
 	public static final String DEFAULT_CACHE_CONCURRENCY_STRATEGY = "hibernate.cache.default_cache_concurrency_strategy";
 
 	/**
 	 * Setting which indicates whether or not the new {@link org.hibernate.id.IdentifierGenerator} are used
 	 * for AUTO, TABLE and SEQUENCE.
 	 * Default to false to keep backward compatibility.
 	 */
 	public static final String USE_NEW_ID_GENERATOR_MAPPINGS = "hibernate.id.new_generator_mappings";
 
 	/**
 	 * Setting to identify a {@link org.hibernate.CustomEntityDirtinessStrategy} to use.  May point to
 	 * either a class name or instance.
 	 */
 	public static final String CUSTOM_ENTITY_DIRTINESS_STRATEGY = "hibernate.entity_dirtiness_strategy";
 
 	/**
 	 * Strategy for multi-tenancy.
 
 	 * @see org.hibernate.MultiTenancyStrategy
 	 * @since 4.0
 	 */
 	public static final String MULTI_TENANT = "hibernate.multiTenancy";
 
 	/**
-	 * Names a {@link org.hibernate.service.jdbc.connections.spi.MultiTenantConnectionProvider} implementation to
+	 * Names a {@link org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider} implementation to
 	 * use.  As MultiTenantConnectionProvider is also a service, can be configured directly through the
-	 * {@link org.hibernate.service.ServiceRegistryBuilder}
+	 * {@link org.hibernate.boot.registry.StandardServiceRegistryBuilder}
 	 *
 	 * @since 4.1
 	 */
 	public static final String MULTI_TENANT_CONNECTION_PROVIDER = "hibernate.multi_tenant_connection_provider";
 
 	/**
 	 * Names a {@link org.hibernate.context.spi.CurrentTenantIdentifierResolver} implementation to use.
 	 * <p/>
 	 * Can be<ul>
 	 *     <li>CurrentTenantIdentifierResolver instance</li>
 	 *     <li>CurrentTenantIdentifierResolver implementation {@link Class} reference</li>
 	 *     <li>CurrentTenantIdentifierResolver implementation class name</li>
 	 * </ul>
 	 *
 	 * @since 4.1
 	 */
 	public static final String MULTI_TENANT_IDENTIFIER_RESOLVER = "hibernate.tenant_identifier_resolver";
 
 	public static final String FORCE_DISCRIMINATOR_IN_SELECTS_BY_DEFAULT = "hibernate.discriminator.force_in_select";
 
     public static final String ENABLE_LAZY_LOAD_NO_TRANS = "hibernate.enable_lazy_load_no_trans";
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java b/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
index 53d7415a51..306b9917b3 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/Configuration.java
@@ -1,2773 +1,2773 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
 import java.io.StringReader;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.StringTokenizer;
 import java.util.TreeMap;
 import java.util.concurrent.ConcurrentHashMap;
 import java.util.jar.JarFile;
 import java.util.zip.ZipEntry;
 import javax.persistence.AttributeConverter;
 import javax.persistence.Embeddable;
 import javax.persistence.Entity;
 import javax.persistence.MapsId;
 
 import org.dom4j.Attribute;
 import org.dom4j.Document;
 import org.dom4j.DocumentException;
 import org.dom4j.Element;
 import org.jboss.logging.Logger;
 import org.xml.sax.EntityResolver;
 import org.xml.sax.InputSource;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.AssertionFailure;
 import org.hibernate.DuplicateMappingException;
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.InvalidMappingException;
 import org.hibernate.MappingException;
 import org.hibernate.MappingNotFoundException;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.annotations.AnyMetaDef;
 import org.hibernate.annotations.common.reflection.MetadataProvider;
 import org.hibernate.annotations.common.reflection.MetadataProviderInjector;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.annotations.common.reflection.XClass;
 import org.hibernate.annotations.common.reflection.java.JavaReflectionManager;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.annotations.reflection.JPAMetadataProvider;
 import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.IdentifierGeneratorAggregator;
 import org.hibernate.id.PersistentIdentifierGenerator;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
 import org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory;
 import org.hibernate.id.factory.spi.MutableIdentifierGeneratorFactory;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.SessionFactoryImpl;
 import org.hibernate.internal.util.ConfigHelper;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.SerializationHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.collections.ArrayHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.internal.util.collections.JoinedIterator;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.internal.util.xml.ErrorLogger;
 import org.hibernate.internal.util.xml.MappingReader;
 import org.hibernate.internal.util.xml.Origin;
 import org.hibernate.internal.util.xml.OriginImpl;
 import org.hibernate.internal.util.xml.XMLHelper;
 import org.hibernate.internal.util.xml.XmlDocument;
 import org.hibernate.internal.util.xml.XmlDocumentImpl;
 import org.hibernate.mapping.AuxiliaryDatabaseObject;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.Column;
 import org.hibernate.mapping.DenormalizedTable;
 import org.hibernate.mapping.FetchProfile;
 import org.hibernate.mapping.ForeignKey;
 import org.hibernate.mapping.IdGenerator;
 import org.hibernate.mapping.IdentifierCollection;
 import org.hibernate.mapping.Index;
 import org.hibernate.mapping.Join;
 import org.hibernate.mapping.MappedSuperclass;
 import org.hibernate.mapping.MetadataSource;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.mapping.Table;
 import org.hibernate.mapping.TypeDef;
 import org.hibernate.mapping.UniqueKey;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.secure.internal.JACCConfiguration;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.tool.hbm2ddl.DatabaseMetadata;
 import org.hibernate.tool.hbm2ddl.IndexMetadata;
 import org.hibernate.tool.hbm2ddl.TableMetadata;
 import org.hibernate.tuple.entity.EntityTuplizerFactory;
 import org.hibernate.type.BasicType;
 import org.hibernate.type.SerializationException;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeResolver;
 import org.hibernate.usertype.CompositeUserType;
 import org.hibernate.usertype.UserType;
 
 /**
  * An instance of <tt>Configuration</tt> allows the application
  * to specify properties and mapping documents to be used when
  * creating a <tt>SessionFactory</tt>. Usually an application will create
  * a single <tt>Configuration</tt>, build a single instance of
  * <tt>SessionFactory</tt> and then instantiate <tt>Session</tt>s in
  * threads servicing client requests. The <tt>Configuration</tt> is meant
  * only as an initialization-time object. <tt>SessionFactory</tt>s are
  * immutable and do not retain any association back to the
  * <tt>Configuration</tt>.<br>
  * <br>
  * A new <tt>Configuration</tt> will use the properties specified in
  * <tt>hibernate.properties</tt> by default.
  * <p/>
- * NOTE : This will be replaced by use of {@link ServiceRegistryBuilder} and
+ * NOTE : This will be replaced by use of {@link org.hibernate.boot.registry.StandardServiceRegistryBuilder} and
  * {@link org.hibernate.metamodel.MetadataSources} instead after the 4.0 release at which point this class will become
  * deprecated and scheduled for removal in 5.0.  See
  * <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-6183">HHH-6183</a>,
  * <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-2578">HHH-2578</a> and
  * <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-6586">HHH-6586</a> for details
  *
  * @author Gavin King
  * @see org.hibernate.SessionFactory
  */
 @SuppressWarnings( {"UnusedDeclaration"})
 public class Configuration implements Serializable {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, Configuration.class.getName());
 
 	public static final String DEFAULT_CACHE_CONCURRENCY_STRATEGY = AvailableSettings.DEFAULT_CACHE_CONCURRENCY_STRATEGY;
 
 	public static final String USE_NEW_ID_GENERATOR_MAPPINGS = AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS;
 
 	public static final String ARTEFACT_PROCESSING_ORDER = "hibernate.mapping.precedence";
 
 	/**
 	 * Class name of the class needed to enable Search.
 	 */
 	private static final String SEARCH_STARTUP_CLASS = "org.hibernate.search.event.EventListenerRegister";
 
 	/**
 	 * Method to call to enable Search.
 	 */
 	private static final String SEARCH_STARTUP_METHOD = "enableHibernateSearch";
 
 	protected MetadataSourceQueue metadataSourceQueue;
 	private transient ReflectionManager reflectionManager;
 
 	protected Map<String, PersistentClass> classes;
 	protected Map<String, String> imports;
 	protected Map<String, Collection> collections;
 	protected Map<String, Table> tables;
 	protected List<AuxiliaryDatabaseObject> auxiliaryDatabaseObjects;
 
 	protected Map<String, NamedQueryDefinition> namedQueries;
 	protected Map<String, NamedSQLQueryDefinition> namedSqlQueries;
 	protected Map<String, ResultSetMappingDefinition> sqlResultSetMappings;
 
 	protected Map<String, TypeDef> typeDefs;
 	protected Map<String, FilterDefinition> filterDefinitions;
 	protected Map<String, FetchProfile> fetchProfiles;
 
 	protected Map tableNameBinding;
 	protected Map columnNameBindingPerTable;
 
 	protected List<SecondPass> secondPasses;
 	protected List<Mappings.PropertyReference> propertyReferences;
 	protected Map<ExtendsQueueEntry, ?> extendsQueue;
 
 	protected Map<String, SQLFunction> sqlFunctions;
 	private TypeResolver typeResolver = new TypeResolver();
 
 	private EntityTuplizerFactory entityTuplizerFactory;
 //	private ComponentTuplizerFactory componentTuplizerFactory; todo : HHH-3517 and HHH-1907
 
 	private Interceptor interceptor;
 	private Properties properties;
 	private EntityResolver entityResolver;
 	private EntityNotFoundDelegate entityNotFoundDelegate;
 
 	protected transient XMLHelper xmlHelper;
 	protected NamingStrategy namingStrategy;
 	private SessionFactoryObserver sessionFactoryObserver;
 
 	protected final SettingsFactory settingsFactory;
 
 	private transient Mapping mapping = buildMapping();
 
 	private MutableIdentifierGeneratorFactory identifierGeneratorFactory;
 
 	private Map<Class<?>, org.hibernate.mapping.MappedSuperclass> mappedSuperClasses;
 
 	private Map<String, IdGenerator> namedGenerators;
 	private Map<String, Map<String, Join>> joins;
 	private Map<String, AnnotatedClassType> classTypes;
 	private Set<String> defaultNamedQueryNames;
 	private Set<String> defaultNamedNativeQueryNames;
 	private Set<String> defaultSqlResultSetMappingNames;
 	private Set<String> defaultNamedGenerators;
 	private Map<String, Properties> generatorTables;
 	private Map<Table, List<UniqueConstraintHolder>> uniqueConstraintHoldersByTable;
 	private Map<String, String> mappedByResolver;
 	private Map<String, String> propertyRefResolver;
 	private Map<String, AnyMetaDef> anyMetaDefs;
 	private List<CacheHolder> caches;
 	private boolean inSecondPass = false;
 	private boolean isDefaultProcessed = false;
 	private boolean isValidatorNotPresentLogged;
 	private Map<XClass, Map<String, PropertyData>> propertiesAnnotatedWithMapsId;
 	private Map<XClass, Map<String, PropertyData>> propertiesAnnotatedWithIdAndToOne;
 	private CurrentTenantIdentifierResolver currentTenantIdentifierResolver;
 	private boolean specjProprietarySyntaxEnabled;
 
 	private ConcurrentHashMap<Class,AttributeConverterDefinition> attributeConverterDefinitionsByClass;
 
 	protected Configuration(SettingsFactory settingsFactory) {
 		this.settingsFactory = settingsFactory;
 		reset();
 	}
 
 	public Configuration() {
 		this( new SettingsFactory() );
 	}
 
 	protected void reset() {
 		metadataSourceQueue = new MetadataSourceQueue();
 		createReflectionManager();
 
 		classes = new HashMap<String,PersistentClass>();
 		imports = new HashMap<String,String>();
 		collections = new HashMap<String,Collection>();
 		tables = new TreeMap<String,Table>();
 
 		namedQueries = new HashMap<String,NamedQueryDefinition>();
 		namedSqlQueries = new HashMap<String,NamedSQLQueryDefinition>();
 		sqlResultSetMappings = new HashMap<String, ResultSetMappingDefinition>();
 
 		typeDefs = new HashMap<String,TypeDef>();
 		filterDefinitions = new HashMap<String, FilterDefinition>();
 		fetchProfiles = new HashMap<String, FetchProfile>();
 		auxiliaryDatabaseObjects = new ArrayList<AuxiliaryDatabaseObject>();
 
 		tableNameBinding = new HashMap();
 		columnNameBindingPerTable = new HashMap();
 
 		secondPasses = new ArrayList<SecondPass>();
 		propertyReferences = new ArrayList<Mappings.PropertyReference>();
 		extendsQueue = new HashMap<ExtendsQueueEntry, String>();
 
 		xmlHelper = new XMLHelper();
 		interceptor = EmptyInterceptor.INSTANCE;
 		properties = Environment.getProperties();
 		entityResolver = XMLHelper.DEFAULT_DTD_RESOLVER;
 
 		sqlFunctions = new HashMap<String, SQLFunction>();
 
 		entityTuplizerFactory = new EntityTuplizerFactory();
 //		componentTuplizerFactory = new ComponentTuplizerFactory();
 
 		identifierGeneratorFactory = new DefaultIdentifierGeneratorFactory();
 
 		mappedSuperClasses = new HashMap<Class<?>, MappedSuperclass>();
 
 		metadataSourcePrecedence = Collections.emptyList();
 
 		namedGenerators = new HashMap<String, IdGenerator>();
 		joins = new HashMap<String, Map<String, Join>>();
 		classTypes = new HashMap<String, AnnotatedClassType>();
 		generatorTables = new HashMap<String, Properties>();
 		defaultNamedQueryNames = new HashSet<String>();
 		defaultNamedNativeQueryNames = new HashSet<String>();
 		defaultSqlResultSetMappingNames = new HashSet<String>();
 		defaultNamedGenerators = new HashSet<String>();
 		uniqueConstraintHoldersByTable = new HashMap<Table, List<UniqueConstraintHolder>>();
 		mappedByResolver = new HashMap<String, String>();
 		propertyRefResolver = new HashMap<String, String>();
 		caches = new ArrayList<CacheHolder>();
 		namingStrategy = EJB3NamingStrategy.INSTANCE;
 		setEntityResolver( new EJB3DTDEntityResolver() );
 		anyMetaDefs = new HashMap<String, AnyMetaDef>();
 		propertiesAnnotatedWithMapsId = new HashMap<XClass, Map<String, PropertyData>>();
 		propertiesAnnotatedWithIdAndToOne = new HashMap<XClass, Map<String, PropertyData>>();
 		specjProprietarySyntaxEnabled = System.getProperty( "hibernate.enable_specj_proprietary_syntax" ) != null;
 	}
 
 	public EntityTuplizerFactory getEntityTuplizerFactory() {
 		return entityTuplizerFactory;
 	}
 
 	public ReflectionManager getReflectionManager() {
 		return reflectionManager;
 	}
 
 //	public ComponentTuplizerFactory getComponentTuplizerFactory() {
 //		return componentTuplizerFactory;
 //	}
 
 	/**
 	 * Iterate the entity mappings
 	 *
 	 * @return Iterator of the entity mappings currently contained in the configuration.
 	 */
 	public Iterator<PersistentClass> getClassMappings() {
 		return classes.values().iterator();
 	}
 
 	/**
 	 * Iterate the collection mappings
 	 *
 	 * @return Iterator of the collection mappings currently contained in the configuration.
 	 */
 	public Iterator getCollectionMappings() {
 		return collections.values().iterator();
 	}
 
 	/**
 	 * Iterate the table mappings
 	 *
 	 * @return Iterator of the table mappings currently contained in the configuration.
 	 */
 	public Iterator<Table> getTableMappings() {
 		return tables.values().iterator();
 	}
 
 	/**
 	 * Iterate the mapped super class mappings
 	 * EXPERIMENTAL Consider this API as PRIVATE
 	 *
 	 * @return iterator over the MappedSuperclass mapping currently contained in the configuration.
 	 */
 	public Iterator<MappedSuperclass> getMappedSuperclassMappings() {
 		return mappedSuperClasses.values().iterator();
 	}
 
 	/**
 	 * Get the mapping for a particular entity
 	 *
 	 * @param entityName An entity name.
 	 * @return the entity mapping information
 	 */
 	public PersistentClass getClassMapping(String entityName) {
 		return classes.get( entityName );
 	}
 
 	/**
 	 * Get the mapping for a particular collection role
 	 *
 	 * @param role a collection role
 	 * @return The collection mapping information
 	 */
 	public Collection getCollectionMapping(String role) {
 		return collections.get( role );
 	}
 
 	/**
 	 * Set a custom entity resolver. This entity resolver must be
 	 * set before addXXX(misc) call.
 	 * Default value is {@link org.hibernate.internal.util.xml.DTDEntityResolver}
 	 *
 	 * @param entityResolver entity resolver to use
 	 */
 	public void setEntityResolver(EntityResolver entityResolver) {
 		this.entityResolver = entityResolver;
 	}
 
 	public EntityResolver getEntityResolver() {
 		return entityResolver;
 	}
 
 	/**
 	 * Retrieve the user-supplied delegate to handle non-existent entity
 	 * scenarios.  May be null.
 	 *
 	 * @return The user-supplied delegate
 	 */
 	public EntityNotFoundDelegate getEntityNotFoundDelegate() {
 		return entityNotFoundDelegate;
 	}
 
 	/**
 	 * Specify a user-supplied delegate to be used to handle scenarios where an entity could not be
 	 * located by specified id.  This is mainly intended for EJB3 implementations to be able to
 	 * control how proxy initialization errors should be handled...
 	 *
 	 * @param entityNotFoundDelegate The delegate to use
 	 */
 	public void setEntityNotFoundDelegate(EntityNotFoundDelegate entityNotFoundDelegate) {
 		this.entityNotFoundDelegate = entityNotFoundDelegate;
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param xmlFile a path to a file
 	 * @return this (for method chaining purposes)
 	 * @throws org.hibernate.MappingException Indicates inability to locate or parse
 	 * the specified mapping file.
 	 * @see #addFile(java.io.File)
 	 */
 	public Configuration addFile(String xmlFile) throws MappingException {
 		return addFile( new File( xmlFile ) );
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param xmlFile a path to a file
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates inability to locate the specified mapping file.  Historically this could
 	 * have indicated a problem parsing the XML document, but that is now delayed until after {@link #buildMappings}
 	 */
 	public Configuration addFile(final File xmlFile) throws MappingException {
 		LOG.readingMappingsFromFile( xmlFile.getPath() );
 		final String name =  xmlFile.getAbsolutePath();
 		final InputSource inputSource;
 		try {
 			inputSource = new InputSource( new FileInputStream( xmlFile ) );
 		}
 		catch ( FileNotFoundException e ) {
 			throw new MappingNotFoundException( "file", xmlFile.toString() );
 		}
 		add( inputSource, "file", name );
 		return this;
 	}
 
 	private XmlDocument add(InputSource inputSource, String originType, String originName) {
 		return add( inputSource, new OriginImpl( originType, originName ) );
 	}
 
 	private XmlDocument add(InputSource inputSource, Origin origin) {
 		XmlDocument metadataXml = MappingReader.INSTANCE.readMappingDocument( entityResolver, inputSource, origin );
 		add( metadataXml );
 		return metadataXml;
 	}
 
 	public void add(XmlDocument metadataXml) {
 		if ( inSecondPass || !isOrmXml( metadataXml ) ) {
 			metadataSourceQueue.add( metadataXml );
 		}
 		else {
 			final MetadataProvider metadataProvider = ( (MetadataProviderInjector) reflectionManager ).getMetadataProvider();
 			JPAMetadataProvider jpaMetadataProvider = ( JPAMetadataProvider ) metadataProvider;
 			List<String> classNames = jpaMetadataProvider.getXMLContext().addDocument( metadataXml.getDocumentTree() );
 			for ( String className : classNames ) {
 				try {
 					metadataSourceQueue.add( reflectionManager.classForName( className, this.getClass() ) );
 				}
 				catch ( ClassNotFoundException e ) {
 					throw new AnnotationException( "Unable to load class defined in XML: " + className, e );
 				}
 			}
 		}
 	}
 
 	private static boolean isOrmXml(XmlDocument xmlDocument) {
 		return "entity-mappings".equals( xmlDocument.getDocumentTree().getRootElement().getName() );
 	}
 
 	/**
 	 * Add a cached mapping file.  A cached file is a serialized representation
 	 * of the DOM structure of a particular mapping.  It is saved from a previous
 	 * call as a file with the name <tt>xmlFile + ".bin"</tt> where xmlFile is
 	 * the name of the original mapping file.
 	 * </p>
 	 * If a cached <tt>xmlFile + ".bin"</tt> exists and is newer than
 	 * <tt>xmlFile</tt> the <tt>".bin"</tt> file will be read directly. Otherwise
 	 * xmlFile is read and then serialized to <tt>xmlFile + ".bin"</tt> for use
 	 * the next time.
 	 *
 	 * @param xmlFile The cacheable mapping file to be added.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the cached file or processing
 	 * the non-cached file.
 	 */
 	public Configuration addCacheableFile(File xmlFile) throws MappingException {
 		File cachedFile = determineCachedDomFile( xmlFile );
 
 		try {
 			return addCacheableFileStrictly( xmlFile );
 		}
 		catch ( SerializationException e ) {
 			LOG.unableToDeserializeCache( cachedFile.getPath(), e );
 		}
 		catch ( FileNotFoundException e ) {
 			LOG.cachedFileNotFound( cachedFile.getPath(), e );
 		}
 
 		final String name = xmlFile.getAbsolutePath();
 		final InputSource inputSource;
 		try {
 			inputSource = new InputSource( new FileInputStream( xmlFile ) );
 		}
 		catch ( FileNotFoundException e ) {
 			throw new MappingNotFoundException( "file", xmlFile.toString() );
 		}
 
 		LOG.readingMappingsFromFile( xmlFile.getPath() );
 		XmlDocument metadataXml = add( inputSource, "file", name );
 
 		try {
 			LOG.debugf( "Writing cache file for: %s to: %s", xmlFile, cachedFile );
 			SerializationHelper.serialize( ( Serializable ) metadataXml.getDocumentTree(), new FileOutputStream( cachedFile ) );
 		}
 		catch ( Exception e ) {
 			LOG.unableToWriteCachedFile( cachedFile.getPath(), e.getMessage() );
 		}
 
 		return this;
 	}
 
 	private File determineCachedDomFile(File xmlFile) {
 		return new File( xmlFile.getAbsolutePath() + ".bin" );
 	}
 
 	/**
 	 * <b>INTENDED FOR TESTSUITE USE ONLY!</b>
 	 * <p/>
 	 * Much like {@link #addCacheableFile(File)} except that here we will fail immediately if
 	 * the cache version cannot be found or used for whatever reason
 	 *
 	 * @param xmlFile The xml file, not the bin!
 	 *
 	 * @return The dom "deserialized" from the cached file.
 	 *
 	 * @throws SerializationException Indicates a problem deserializing the cached dom tree
 	 * @throws FileNotFoundException Indicates that the cached file was not found or was not usable.
 	 */
 	public Configuration addCacheableFileStrictly(File xmlFile) throws SerializationException, FileNotFoundException {
 		final File cachedFile = determineCachedDomFile( xmlFile );
 
 		final boolean useCachedFile = xmlFile.exists()
 				&& cachedFile.exists()
 				&& xmlFile.lastModified() < cachedFile.lastModified();
 
 		if ( ! useCachedFile ) {
 			throw new FileNotFoundException( "Cached file could not be found or could not be used" );
 		}
 
 		LOG.readingCachedMappings( cachedFile );
 		Document document = ( Document ) SerializationHelper.deserialize( new FileInputStream( cachedFile ) );
 		add( new XmlDocumentImpl( document, "file", xmlFile.getAbsolutePath() ) );
 		return this;
 	}
 
 	/**
 	 * Add a cacheable mapping file.
 	 *
 	 * @param xmlFile The name of the file to be added.  This must be in a form
 	 * useable to simply construct a {@link java.io.File} instance.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the cached file or processing
 	 * the non-cached file.
 	 * @see #addCacheableFile(java.io.File)
 	 */
 	public Configuration addCacheableFile(String xmlFile) throws MappingException {
 		return addCacheableFile( new File( xmlFile ) );
 	}
 
 
 	/**
 	 * Read mappings from a <tt>String</tt>
 	 *
 	 * @param xml an XML string
 	 * @return this (for method chaining purposes)
 	 * @throws org.hibernate.MappingException Indicates problems parsing the
 	 * given XML string
 	 */
 	public Configuration addXML(String xml) throws MappingException {
 		LOG.debugf( "Mapping XML:\n%s", xml );
 		final InputSource inputSource = new InputSource( new StringReader( xml ) );
 		add( inputSource, "string", "XML String" );
 		return this;
 	}
 
 	/**
 	 * Read mappings from a <tt>URL</tt>
 	 *
 	 * @param url The url for the mapping document to be read.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the URL or processing
 	 * the mapping document.
 	 */
 	public Configuration addURL(URL url) throws MappingException {
 		final String urlExternalForm = url.toExternalForm();
 
 		LOG.debugf( "Reading mapping document from URL : %s", urlExternalForm );
 
 		try {
 			add( url.openStream(), "URL", urlExternalForm );
 		}
 		catch ( IOException e ) {
 			throw new InvalidMappingException( "Unable to open url stream [" + urlExternalForm + "]", "URL", urlExternalForm, e );
 		}
 		return this;
 	}
 
 	private XmlDocument add(InputStream inputStream, final String type, final String name) {
 		final InputSource inputSource = new InputSource( inputStream );
 		try {
 			return add( inputSource, type, name );
 		}
 		finally {
 			try {
 				inputStream.close();
 			}
 			catch ( IOException ignore ) {
 				LOG.trace( "Was unable to close input stream");
 			}
 		}
 	}
 
 	/**
 	 * Read mappings from a DOM <tt>Document</tt>
 	 *
 	 * @param doc The DOM document
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the DOM or processing
 	 * the mapping document.
 	 */
 	public Configuration addDocument(org.w3c.dom.Document doc) throws MappingException {
 		LOG.debugf( "Mapping Document:\n%s", doc );
 
 		final Document document = xmlHelper.createDOMReader().read( doc );
 		add( new XmlDocumentImpl( document, "unknown", null ) );
 
 		return this;
 	}
 
 	/**
 	 * Read mappings from an {@link java.io.InputStream}.
 	 *
 	 * @param xmlInputStream The input stream containing a DOM.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the stream, or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addInputStream(InputStream xmlInputStream) throws MappingException {
 		add( xmlInputStream, "input stream", null );
 		return this;
 	}
 
 	/**
 	 * Read mappings as a application resource (i.e. classpath lookup).
 	 *
 	 * @param resourceName The resource name
 	 * @param classLoader The class loader to use.
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems locating the resource or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addResource(String resourceName, ClassLoader classLoader) throws MappingException {
 		LOG.readingMappingsFromResource( resourceName );
 		InputStream resourceInputStream = classLoader.getResourceAsStream( resourceName );
 		if ( resourceInputStream == null ) {
 			throw new MappingNotFoundException( "resource", resourceName );
 		}
 		add( resourceInputStream, "resource", resourceName );
 		return this;
 	}
 
 	/**
 	 * Read mappings as a application resourceName (i.e. classpath lookup)
 	 * trying different class loaders.
 	 *
 	 * @param resourceName The resource name
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems locating the resource or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addResource(String resourceName) throws MappingException {
 		LOG.readingMappingsFromResource( resourceName );
 		ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
 		InputStream resourceInputStream = null;
 		if ( contextClassLoader != null ) {
 			resourceInputStream = contextClassLoader.getResourceAsStream( resourceName );
 		}
 		if ( resourceInputStream == null ) {
 			resourceInputStream = Environment.class.getClassLoader().getResourceAsStream( resourceName );
 		}
 		if ( resourceInputStream == null ) {
 			throw new MappingNotFoundException( "resource", resourceName );
 		}
 		add( resourceInputStream, "resource", resourceName );
 		return this;
 	}
 
 	/**
 	 * Read a mapping as an application resource using the convention that a class
 	 * named <tt>foo.bar.Foo</tt> is mapped by a file <tt>foo/bar/Foo.hbm.xml</tt>
 	 * which can be resolved as a classpath resource.
 	 *
 	 * @param persistentClass The mapped class
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems locating the resource or
 	 * processing the contained mapping document.
 	 */
 	public Configuration addClass(Class persistentClass) throws MappingException {
 		String mappingResourceName = persistentClass.getName().replace( '.', '/' ) + ".hbm.xml";
 		LOG.readingMappingsFromResource( mappingResourceName );
 		return addResource( mappingResourceName, persistentClass.getClassLoader() );
 	}
 
 	/**
 	 * Read metadata from the annotations associated with this class.
 	 *
 	 * @param annotatedClass The class containing annotations
 	 *
 	 * @return this (for method chaining)
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public Configuration addAnnotatedClass(Class annotatedClass) {
 		XClass xClass = reflectionManager.toXClass( annotatedClass );
 		metadataSourceQueue.add( xClass );
 		return this;
 	}
 
 	/**
 	 * Read package-level metadata.
 	 *
 	 * @param packageName java package name
 	 *
 	 * @return this (for method chaining)
 	 *
 	 * @throws MappingException in case there is an error in the mapping data
 	 */
 	public Configuration addPackage(String packageName) throws MappingException {
 		LOG.debugf( "Mapping Package %s", packageName );
 		try {
 			AnnotationBinder.bindPackage( packageName, createMappings() );
 			return this;
 		}
 		catch ( MappingException me ) {
 			LOG.unableToParseMetadata( packageName );
 			throw me;
 		}
 	}
 
 	/**
 	 * Read all mappings from a jar file
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param jar a jar file
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the jar file or
 	 * processing the contained mapping documents.
 	 */
 	public Configuration addJar(File jar) throws MappingException {
 		LOG.searchingForMappingDocuments( jar.getName() );
 		JarFile jarFile = null;
 		try {
 			try {
 				jarFile = new JarFile( jar );
 			}
 			catch (IOException ioe) {
 				throw new InvalidMappingException(
 						"Could not read mapping documents from jar: " + jar.getName(), "jar", jar.getName(),
 						ioe
 				);
 			}
 			Enumeration jarEntries = jarFile.entries();
 			while ( jarEntries.hasMoreElements() ) {
 				ZipEntry ze = (ZipEntry) jarEntries.nextElement();
 				if ( ze.getName().endsWith( ".hbm.xml" ) ) {
 					LOG.foundMappingDocument( ze.getName() );
 					try {
 						addInputStream( jarFile.getInputStream( ze ) );
 					}
 					catch (Exception e) {
 						throw new InvalidMappingException(
 								"Could not read mapping documents from jar: " + jar.getName(),
 								"jar",
 								jar.getName(),
 								e
 						);
 					}
 				}
 			}
 		}
 		finally {
 			try {
 				if ( jarFile != null ) {
 					jarFile.close();
 				}
 			}
 			catch (IOException ioe) {
 				LOG.unableToCloseJar( ioe.getMessage() );
 			}
 		}
 
 		return this;
 	}
 
 	/**
 	 * Read all mapping documents from a directory tree.
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param dir The directory
 	 * @return this (for method chaining purposes)
 	 * @throws MappingException Indicates problems reading the jar file or
 	 * processing the contained mapping documents.
 	 */
 	public Configuration addDirectory(File dir) throws MappingException {
 		File[] files = dir.listFiles();
 		for ( File file : files ) {
 			if ( file.isDirectory() ) {
 				addDirectory( file );
 			}
 			else if ( file.getName().endsWith( ".hbm.xml" ) ) {
 				addFile( file );
 			}
 		}
 		return this;
 	}
 
 	/**
 	 * Create a new <tt>Mappings</tt> to add class and collection mappings to.
 	 *
 	 * @return The created mappings
 	 */
 	public Mappings createMappings() {
 		return new MappingsImpl();
 	}
 
 
 	@SuppressWarnings({ "unchecked" })
 	private Iterator<IdentifierGenerator> iterateGenerators(Dialect dialect) throws MappingException {
 
 		TreeMap generators = new TreeMap();
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		for ( PersistentClass pc : classes.values() ) {
 			if ( !pc.isInherited() ) {
 				IdentifierGenerator ig = pc.getIdentifier().createIdentifierGenerator(
 						getIdentifierGeneratorFactory(),
 						dialect,
 						defaultCatalog,
 						defaultSchema,
 						(RootClass) pc
 				);
 
 				if ( ig instanceof PersistentIdentifierGenerator ) {
 					generators.put( ( (PersistentIdentifierGenerator) ig ).generatorKey(), ig );
 				}
 				else if ( ig instanceof IdentifierGeneratorAggregator ) {
 					( (IdentifierGeneratorAggregator) ig ).registerPersistentGenerators( generators );
 				}
 			}
 		}
 
 		for ( Collection collection : collections.values() ) {
 			if ( collection.isIdentified() ) {
 				IdentifierGenerator ig = ( ( IdentifierCollection ) collection ).getIdentifier().createIdentifierGenerator(
 						getIdentifierGeneratorFactory(),
 						dialect,
 						defaultCatalog,
 						defaultSchema,
 						null
 				);
 
 				if ( ig instanceof PersistentIdentifierGenerator ) {
 					generators.put( ( (PersistentIdentifierGenerator) ig ).generatorKey(), ig );
 				}
 			}
 		}
 
 		return generators.values().iterator();
 	}
 
 	/**
 	 * Generate DDL for dropping tables
 	 *
 	 * @param dialect The dialect for which to generate the drop script
 
 	 * @return The sequence of DDL commands to drop the schema objects
 
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	public String[] generateDropSchemaScript(Dialect dialect) throws HibernateException {
 		secondPassCompile();
 
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		ArrayList<String> script = new ArrayList<String>( 50 );
 
 		// drop them in reverse order in case db needs it done that way...
 		{
 			ListIterator itr = auxiliaryDatabaseObjects.listIterator( auxiliaryDatabaseObjects.size() );
 			while ( itr.hasPrevious() ) {
 				AuxiliaryDatabaseObject object = (AuxiliaryDatabaseObject) itr.previous();
 				if ( object.appliesToDialect( dialect ) ) {
 					script.add( object.sqlDropString( dialect, defaultCatalog, defaultSchema ) );
 				}
 			}
 		}
 
 		if ( dialect.dropConstraints() ) {
 			Iterator itr = getTableMappings();
 			while ( itr.hasNext() ) {
 				Table table = (Table) itr.next();
 				if ( table.isPhysicalTable() ) {
 					Iterator subItr = table.getForeignKeyIterator();
 					while ( subItr.hasNext() ) {
 						ForeignKey fk = (ForeignKey) subItr.next();
 						if ( fk.isPhysicalConstraint() ) {
 							script.add(
 									fk.sqlDropString(
 											dialect,
 											defaultCatalog,
 											defaultSchema
 										)
 								);
 						}
 					}
 				}
 			}
 		}
 
 
 		Iterator itr = getTableMappings();
 		while ( itr.hasNext() ) {
 
 			Table table = (Table) itr.next();
 			if ( table.isPhysicalTable() ) {
 
 				/*Iterator subIter = table.getIndexIterator();
 				while ( subIter.hasNext() ) {
 					Index index = (Index) subIter.next();
 					if ( !index.isForeignKey() || !dialect.hasImplicitIndexForForeignKey() ) {
 						script.add( index.sqlDropString(dialect) );
 					}
 				}*/
 
 				script.add(
 						table.sqlDropString(
 								dialect,
 								defaultCatalog,
 								defaultSchema
 							)
 					);
 
 			}
 
 		}
 
 		itr = iterateGenerators( dialect );
 		while ( itr.hasNext() ) {
 			String[] lines = ( (PersistentIdentifierGenerator) itr.next() ).sqlDropStrings( dialect );
 			script.addAll( Arrays.asList( lines ) );
 		}
 
 		return ArrayHelper.toStringArray( script );
 	}
 
 	/**
 	 * @param dialect The dialect for which to generate the creation script
 	 *
 	 * @return The sequence of DDL commands to create the schema objects
 	 *
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 	 *
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public String[] generateSchemaCreationScript(Dialect dialect) throws HibernateException {
 		secondPassCompile();
 
 		ArrayList<String> script = new ArrayList<String>( 50 );
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		Iterator iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 				script.add(
 						table.sqlCreateString(
 								dialect,
 								mapping,
 								defaultCatalog,
 								defaultSchema
 							)
 					);
 				Iterator<String> comments = table.sqlCommentStrings( dialect, defaultCatalog, defaultSchema );
 				while ( comments.hasNext() ) {
 					script.add( comments.next() );
 				}
 			}
 		}
 
 		iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 
 				if ( !dialect.supportsUniqueConstraintInCreateAlterTable() ) {
 					Iterator subIter = table.getUniqueKeyIterator();
 					while ( subIter.hasNext() ) {
 						UniqueKey uk = (UniqueKey) subIter.next();
 						String constraintString = uk.sqlCreateString( dialect, mapping, defaultCatalog, defaultSchema );
 						if (constraintString != null) script.add( constraintString );
 					}
 				}
 
 
 				Iterator subIter = table.getIndexIterator();
 				while ( subIter.hasNext() ) {
 					Index index = (Index) subIter.next();
 					script.add(
 							index.sqlCreateString(
 									dialect,
 									mapping,
 									defaultCatalog,
 									defaultSchema
 								)
 						);
 				}
 
 				if ( dialect.hasAlterTable() ) {
 					subIter = table.getForeignKeyIterator();
 					while ( subIter.hasNext() ) {
 						ForeignKey fk = (ForeignKey) subIter.next();
 						if ( fk.isPhysicalConstraint() ) {
 							script.add(
 									fk.sqlCreateString(
 											dialect, mapping,
 											defaultCatalog,
 											defaultSchema
 										)
 								);
 						}
 					}
 				}
 
 			}
 		}
 
 		iter = iterateGenerators( dialect );
 		while ( iter.hasNext() ) {
 			String[] lines = ( (PersistentIdentifierGenerator) iter.next() ).sqlCreateStrings( dialect );
 			script.addAll( Arrays.asList( lines ) );
 		}
 
 		for ( AuxiliaryDatabaseObject auxiliaryDatabaseObject : auxiliaryDatabaseObjects ) {
 			if ( auxiliaryDatabaseObject.appliesToDialect( dialect ) ) {
 				script.add( auxiliaryDatabaseObject.sqlCreateString( dialect, mapping, defaultCatalog, defaultSchema ) );
 			}
 		}
 
 		return ArrayHelper.toStringArray( script );
 	}
 
 	/**
 	 * @param dialect The dialect for which to generate the creation script
 	 * @param databaseMetadata The database catalog information for the database to be updated; needed to work out what
 	 * should be created/altered
 	 *
 	 * @return The sequence of DDL commands to apply the schema objects
 	 *
 	 * @throws HibernateException Generally indicates a problem calling {@link #buildMappings()}
 	 *
 	 * @see org.hibernate.tool.hbm2ddl.SchemaExport
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public String[] generateSchemaUpdateScript(Dialect dialect, DatabaseMetadata databaseMetadata)
 			throws HibernateException {
 		secondPassCompile();
 
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		ArrayList<String> script = new ArrayList<String>( 50 );
 
 		Iterator iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			String tableSchema = ( table.getSchema() == null ) ? defaultSchema : table.getSchema() ;
 			String tableCatalog = ( table.getCatalog() == null ) ? defaultCatalog : table.getCatalog();
 			if ( table.isPhysicalTable() ) {
 
 				TableMetadata tableInfo = databaseMetadata.getTableMetadata(
 						table.getName(),
 						tableSchema,
 						tableCatalog,
 						table.isQuoted()
 				);
 				if ( tableInfo == null ) {
 					script.add(
 							table.sqlCreateString(
 									dialect,
 									mapping,
 									tableCatalog,
 									tableSchema
 								)
 						);
 				}
 				else {
 					Iterator<String> subiter = table.sqlAlterStrings(
 							dialect,
 							mapping,
 							tableInfo,
 							tableCatalog,
 							tableSchema
 						);
 					while ( subiter.hasNext() ) {
 						script.add( subiter.next() );
 					}
 				}
 
 				Iterator<String> comments = table.sqlCommentStrings( dialect, defaultCatalog, defaultSchema );
 				while ( comments.hasNext() ) {
 					script.add( comments.next() );
 				}
 
 			}
 		}
 
 		iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			String tableSchema = ( table.getSchema() == null ) ? defaultSchema : table.getSchema() ;
 			String tableCatalog = ( table.getCatalog() == null ) ? defaultCatalog : table.getCatalog();
 			if ( table.isPhysicalTable() ) {
 
 				TableMetadata tableInfo = databaseMetadata.getTableMetadata(
 						table.getName(),
 						tableSchema,
 						tableCatalog,
 						table.isQuoted()
 					);
 
 				if ( dialect.hasAlterTable() ) {
 					Iterator subIter = table.getForeignKeyIterator();
 					while ( subIter.hasNext() ) {
 						ForeignKey fk = (ForeignKey) subIter.next();
 						if ( fk.isPhysicalConstraint() ) {
 							boolean create = tableInfo == null || (
 									tableInfo.getForeignKeyMetadata( fk ) == null && (
 											//Icky workaround for MySQL bug:
 											!( dialect instanceof MySQLDialect ) ||
 													tableInfo.getIndexMetadata( fk.getName() ) == null
 										)
 								);
 							if ( create ) {
 								script.add(
 										fk.sqlCreateString(
 												dialect,
 												mapping,
 												tableCatalog,
 												tableSchema
 											)
 									);
 							}
 						}
 					}
 				}
 
 				Iterator subIter = table.getIndexIterator();
 				while ( subIter.hasNext() ) {
 					final Index index = (Index) subIter.next();
 					// Skip if index already exists
 					if ( tableInfo != null && StringHelper.isNotEmpty( index.getName() ) ) {
 						final IndexMetadata meta = tableInfo.getIndexMetadata( index.getName() );
 						if ( meta != null ) {
 							continue;
 						}
 					}
 					script.add(
 							index.sqlCreateString(
 									dialect,
 									mapping,
 									tableCatalog,
 									tableSchema
 							)
 					);
 				}
 
 //broken, 'cos we don't generate these with names in SchemaExport
 //				subIter = table.getUniqueKeyIterator();
 //				while ( subIter.hasNext() ) {
 //					UniqueKey uk = (UniqueKey) subIter.next();
 //					if ( tableInfo==null || tableInfo.getIndexMetadata( uk.getFilterName() ) == null ) {
 //						script.add( uk.sqlCreateString(dialect, mapping) );
 //					}
 //				}
 			}
 		}
 
 		iter = iterateGenerators( dialect );
 		while ( iter.hasNext() ) {
 			PersistentIdentifierGenerator generator = (PersistentIdentifierGenerator) iter.next();
 			Object key = generator.generatorKey();
 			if ( !databaseMetadata.isSequence( key ) && !databaseMetadata.isTable( key ) ) {
 				String[] lines = generator.sqlCreateStrings( dialect );
 				script.addAll( Arrays.asList( lines ) );
 			}
 		}
 
 		return ArrayHelper.toStringArray( script );
 	}
 
 	public void validateSchema(Dialect dialect, DatabaseMetadata databaseMetadata)throws HibernateException {
 		secondPassCompile();
 
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 
 		Iterator iter = getTableMappings();
 		while ( iter.hasNext() ) {
 			Table table = (Table) iter.next();
 			if ( table.isPhysicalTable() ) {
 
 
 				TableMetadata tableInfo = databaseMetadata.getTableMetadata(
 						table.getName(),
 						( table.getSchema() == null ) ? defaultSchema : table.getSchema(),
 						( table.getCatalog() == null ) ? defaultCatalog : table.getCatalog(),
 								table.isQuoted());
 				if ( tableInfo == null ) {
 					throw new HibernateException( "Missing table: " + table.getName() );
 				}
 				else {
 					table.validateColumns( dialect, mapping, tableInfo );
 				}
 
 			}
 		}
 
 		iter = iterateGenerators( dialect );
 		while ( iter.hasNext() ) {
 			PersistentIdentifierGenerator generator = (PersistentIdentifierGenerator) iter.next();
 			Object key = generator.generatorKey();
 			if ( !databaseMetadata.isSequence( key ) && !databaseMetadata.isTable( key ) ) {
 				throw new HibernateException( "Missing sequence or table: " + key );
 			}
 		}
 	}
 
 	private void validate() throws MappingException {
 		Iterator iter = classes.values().iterator();
 		while ( iter.hasNext() ) {
 			( (PersistentClass) iter.next() ).validate( mapping );
 		}
 		iter = collections.values().iterator();
 		while ( iter.hasNext() ) {
 			( (Collection) iter.next() ).validate( mapping );
 		}
 	}
 
 	/**
 	 * Call this to ensure the mappings are fully compiled/built. Usefull to ensure getting
 	 * access to all information in the metamodel when calling e.g. getClassMappings().
 	 */
 	public void buildMappings() {
 		secondPassCompile();
 	}
 
 	protected void secondPassCompile() throws MappingException {
 		LOG.trace( "Starting secondPassCompile() processing" );
 
 		//process default values first
 		{
 			if ( !isDefaultProcessed ) {
 				//use global delimiters if orm.xml declare it
 				Map defaults = reflectionManager.getDefaults();
 				final Object isDelimited = defaults.get( "delimited-identifier" );
 				if ( isDelimited != null && isDelimited == Boolean.TRUE ) {
 					getProperties().put( Environment.GLOBALLY_QUOTED_IDENTIFIERS, "true" );
 				}
 				// Set default schema name if orm.xml declares it.
 				final String schema = (String) defaults.get( "schema" );
 				if ( StringHelper.isNotEmpty( schema ) ) {
 					getProperties().put( Environment.DEFAULT_SCHEMA, schema );
 				}
 				// Set default catalog name if orm.xml declares it.
 				final String catalog = (String) defaults.get( "catalog" );
 				if ( StringHelper.isNotEmpty( catalog ) ) {
 					getProperties().put( Environment.DEFAULT_CATALOG, catalog );
 				}
 
 				AnnotationBinder.bindDefaults( createMappings() );
 				isDefaultProcessed = true;
 			}
 		}
 
 		// process metadata queue
 		{
 			metadataSourceQueue.syncAnnotatedClasses();
 			metadataSourceQueue.processMetadata( determineMetadataSourcePrecedence() );
 		}
 
 
 
 		try {
 			inSecondPass = true;
 			processSecondPassesOfType( PkDrivenByDefaultMapsIdSecondPass.class );
 			processSecondPassesOfType( SetSimpleValueTypeSecondPass.class );
 			processSecondPassesOfType( CopyIdentifierComponentSecondPass.class );
 			processFkSecondPassInOrder();
 			processSecondPassesOfType( CreateKeySecondPass.class );
 			processSecondPassesOfType( SecondaryTableSecondPass.class );
 
 			originalSecondPassCompile();
 
 			inSecondPass = false;
 		}
 		catch ( RecoverableException e ) {
 			//the exception was not recoverable after all
 			throw ( RuntimeException ) e.getCause();
 		}
 
 		// process cache queue
 		{
 			for ( CacheHolder holder : caches ) {
 				if ( holder.isClass ) {
 					applyCacheConcurrencyStrategy( holder );
 				}
 				else {
 					applyCollectionCacheConcurrencyStrategy( holder );
 				}
 			}
 			caches.clear();
 		}
 
 		for ( Map.Entry<Table, List<UniqueConstraintHolder>> tableListEntry : uniqueConstraintHoldersByTable.entrySet() ) {
 			final Table table = tableListEntry.getKey();
 			final List<UniqueConstraintHolder> uniqueConstraints = tableListEntry.getValue();
 			int uniqueIndexPerTable = 0;
 			for ( UniqueConstraintHolder holder : uniqueConstraints ) {
 				uniqueIndexPerTable++;
 				final String keyName = StringHelper.isEmpty( holder.getName() )
 						? "key" + uniqueIndexPerTable
 						: holder.getName();
 				buildUniqueKeyFromColumnNames( table, keyName, holder.getColumns() );
 			}
 		}
 	}
 
 	private void processSecondPassesOfType(Class<? extends SecondPass> type) {
 		Iterator iter = secondPasses.iterator();
 		while ( iter.hasNext() ) {
 			SecondPass sp = ( SecondPass ) iter.next();
 			//do the second pass of simple value types first and remove them
 			if ( type.isInstance( sp ) ) {
 				sp.doSecondPass( classes );
 				iter.remove();
 			}
 		}
 	}
 
 	/**
 	 * Processes FKSecondPass instances trying to resolve any
 	 * graph circularity (ie PK made of a many to one linking to
 	 * an entity having a PK made of a ManyToOne ...).
 	 */
 	private void processFkSecondPassInOrder() {
 		LOG.debug("Processing fk mappings (*ToOne and JoinedSubclass)");
 		List<FkSecondPass> fkSecondPasses = getFKSecondPassesOnly();
 
 		if ( fkSecondPasses.size() == 0 ) {
 			return; // nothing to do here
 		}
 
 		// split FkSecondPass instances into primary key and non primary key FKs.
 		// While doing so build a map of class names to FkSecondPass instances depending on this class.
 		Map<String, Set<FkSecondPass>> isADependencyOf = new HashMap<String, Set<FkSecondPass>>();
 		List<FkSecondPass> endOfQueueFkSecondPasses = new ArrayList<FkSecondPass>( fkSecondPasses.size() );
 		for ( FkSecondPass sp : fkSecondPasses ) {
 			if ( sp.isInPrimaryKey() ) {
 				String referenceEntityName = sp.getReferencedEntityName();
 				PersistentClass classMapping = getClassMapping( referenceEntityName );
 				String dependentTable = classMapping.getTable().getQuotedName();
 				if ( !isADependencyOf.containsKey( dependentTable ) ) {
 					isADependencyOf.put( dependentTable, new HashSet<FkSecondPass>() );
 				}
 				isADependencyOf.get( dependentTable ).add( sp );
 			}
 			else {
 				endOfQueueFkSecondPasses.add( sp );
 			}
 		}
 
 		// using the isADependencyOf map we order the FkSecondPass recursively instances into the right order for processing
 		List<FkSecondPass> orderedFkSecondPasses = new ArrayList<FkSecondPass>( fkSecondPasses.size() );
 		for ( String tableName : isADependencyOf.keySet() ) {
 			buildRecursiveOrderedFkSecondPasses( orderedFkSecondPasses, isADependencyOf, tableName, tableName );
 		}
 
 		// process the ordered FkSecondPasses
 		for ( FkSecondPass sp : orderedFkSecondPasses ) {
 			sp.doSecondPass( classes );
 		}
 
 		processEndOfQueue( endOfQueueFkSecondPasses );
 	}
 
 	/**
 	 * @return Returns a list of all <code>secondPasses</code> instances which are a instance of
 	 *         <code>FkSecondPass</code>.
 	 */
 	private List<FkSecondPass> getFKSecondPassesOnly() {
 		Iterator iter = secondPasses.iterator();
 		List<FkSecondPass> fkSecondPasses = new ArrayList<FkSecondPass>( secondPasses.size() );
 		while ( iter.hasNext() ) {
 			SecondPass sp = ( SecondPass ) iter.next();
 			//do the second pass of fk before the others and remove them
 			if ( sp instanceof FkSecondPass ) {
 				fkSecondPasses.add( ( FkSecondPass ) sp );
 				iter.remove();
 			}
 		}
 		return fkSecondPasses;
 	}
 
 	/**
 	 * Recursively builds a list of FkSecondPass instances ready to be processed in this order.
 	 * Checking all dependencies recursively seems quite expensive, but the original code just relied
 	 * on some sort of table name sorting which failed in certain circumstances.
 	 * <p/>
 	 * See <tt>ANN-722</tt> and <tt>ANN-730</tt>
 	 *
 	 * @param orderedFkSecondPasses The list containing the <code>FkSecondPass<code> instances ready
 	 * for processing.
 	 * @param isADependencyOf Our lookup data structure to determine dependencies between tables
 	 * @param startTable Table name to start recursive algorithm.
 	 * @param currentTable The current table name used to check for 'new' dependencies.
 	 */
 	private void buildRecursiveOrderedFkSecondPasses(
 			List<FkSecondPass> orderedFkSecondPasses,
 			Map<String, Set<FkSecondPass>> isADependencyOf,
 			String startTable,
 			String currentTable) {
 
 		Set<FkSecondPass> dependencies = isADependencyOf.get( currentTable );
 
 		// bottom out
 		if ( dependencies == null || dependencies.size() == 0 ) {
 			return;
 		}
 
 		for ( FkSecondPass sp : dependencies ) {
 			String dependentTable = sp.getValue().getTable().getQuotedName();
 			if ( dependentTable.compareTo( startTable ) == 0 ) {
 				StringBuilder sb = new StringBuilder(
 						"Foreign key circularity dependency involving the following tables: "
 				);
 				throw new AnnotationException( sb.toString() );
 			}
 			buildRecursiveOrderedFkSecondPasses( orderedFkSecondPasses, isADependencyOf, startTable, dependentTable );
 			if ( !orderedFkSecondPasses.contains( sp ) ) {
 				orderedFkSecondPasses.add( 0, sp );
 			}
 		}
 	}
 
 	private void processEndOfQueue(List<FkSecondPass> endOfQueueFkSecondPasses) {
 		/*
 		 * If a second pass raises a recoverableException, queue it for next round
 		 * stop of no pass has to be processed or if the number of pass to processes
 		 * does not diminish between two rounds.
 		 * If some failing pass remain, raise the original exception
 		 */
 		boolean stopProcess = false;
 		RuntimeException originalException = null;
 		while ( !stopProcess ) {
 			List<FkSecondPass> failingSecondPasses = new ArrayList<FkSecondPass>();
 			for ( FkSecondPass pass : endOfQueueFkSecondPasses ) {
 				try {
 					pass.doSecondPass( classes );
 				}
 				catch (RecoverableException e) {
 					failingSecondPasses.add( pass );
 					if ( originalException == null ) {
 						originalException = (RuntimeException) e.getCause();
 					}
 				}
 			}
 			stopProcess = failingSecondPasses.size() == 0 || failingSecondPasses.size() == endOfQueueFkSecondPasses.size();
 			endOfQueueFkSecondPasses = failingSecondPasses;
 		}
 		if ( endOfQueueFkSecondPasses.size() > 0 ) {
 			throw originalException;
 		}
 	}
 
 	private void buildUniqueKeyFromColumnNames(Table table, String keyName, String[] columnNames) {
 		keyName = normalizer.normalizeIdentifierQuoting( keyName );
 
 		UniqueKey uc;
 		int size = columnNames.length;
 		Column[] columns = new Column[size];
 		Set<Column> unbound = new HashSet<Column>();
 		Set<Column> unboundNoLogical = new HashSet<Column>();
 		for ( int index = 0; index < size; index++ ) {
 			final String logicalColumnName = normalizer.normalizeIdentifierQuoting( columnNames[index] );
 			try {
 				final String columnName = createMappings().getPhysicalColumnName( logicalColumnName, table );
 				columns[index] = new Column( columnName );
 				unbound.add( columns[index] );
 				//column equals and hashcode is based on column name
 			}
 			catch ( MappingException e ) {
 				unboundNoLogical.add( new Column( logicalColumnName ) );
 			}
 		}
 		for ( Column column : columns ) {
 			if ( table.containsColumn( column ) ) {
 				uc = table.getOrCreateUniqueKey( keyName );
 				uc.addColumn( table.getColumn( column ) );
 				unbound.remove( column );
 			}
 		}
 		if ( unbound.size() > 0 || unboundNoLogical.size() > 0 ) {
 			StringBuilder sb = new StringBuilder( "Unable to create unique key constraint (" );
 			for ( String columnName : columnNames ) {
 				sb.append( columnName ).append( ", " );
 			}
 			sb.setLength( sb.length() - 2 );
 			sb.append( ") on table " ).append( table.getName() ).append( ": database column " );
 			for ( Column column : unbound ) {
 				sb.append( column.getName() ).append( ", " );
 			}
 			for ( Column column : unboundNoLogical ) {
 				sb.append( column.getName() ).append( ", " );
 			}
 			sb.setLength( sb.length() - 2 );
 			sb.append( " not found. Make sure that you use the correct column name which depends on the naming strategy in use (it may not be the same as the property name in the entity, especially for relational types)" );
 			throw new AnnotationException( sb.toString() );
 		}
 	}
 
 	private void originalSecondPassCompile() throws MappingException {
 		LOG.debug( "Processing extends queue" );
 		processExtendsQueue();
 
 		LOG.debug( "Processing collection mappings" );
 		Iterator itr = secondPasses.iterator();
 		while ( itr.hasNext() ) {
 			SecondPass sp = (SecondPass) itr.next();
 			if ( ! (sp instanceof QuerySecondPass) ) {
 				sp.doSecondPass( classes );
 				itr.remove();
 			}
 		}
 
 		LOG.debug( "Processing native query and ResultSetMapping mappings" );
 		itr = secondPasses.iterator();
 		while ( itr.hasNext() ) {
 			SecondPass sp = (SecondPass) itr.next();
 			sp.doSecondPass( classes );
 			itr.remove();
 		}
 
 		LOG.debug( "Processing association property references" );
 
 		itr = propertyReferences.iterator();
 		while ( itr.hasNext() ) {
 			Mappings.PropertyReference upr = (Mappings.PropertyReference) itr.next();
 
 			PersistentClass clazz = getClassMapping( upr.referencedClass );
 			if ( clazz == null ) {
 				throw new MappingException(
 						"property-ref to unmapped class: " +
 						upr.referencedClass
 					);
 			}
 
 			Property prop = clazz.getReferencedProperty( upr.propertyName );
 			if ( upr.unique ) {
 				( (SimpleValue) prop.getValue() ).setAlternateUniqueKey( true );
 			}
 		}
 
 		//TODO: Somehow add the newly created foreign keys to the internal collection
 
 		LOG.debug( "Processing foreign key constraints" );
 
 		itr = getTableMappings();
 		Set<ForeignKey> done = new HashSet<ForeignKey>();
 		while ( itr.hasNext() ) {
 			secondPassCompileForeignKeys( (Table) itr.next(), done );
 		}
 
 	}
 
 	private int processExtendsQueue() {
 		LOG.debug( "Processing extends queue" );
 		int added = 0;
 		ExtendsQueueEntry extendsQueueEntry = findPossibleExtends();
 		while ( extendsQueueEntry != null ) {
 			metadataSourceQueue.processHbmXml( extendsQueueEntry.getMetadataXml(), extendsQueueEntry.getEntityNames() );
 			extendsQueueEntry = findPossibleExtends();
 		}
 
 		if ( extendsQueue.size() > 0 ) {
 			Iterator iterator = extendsQueue.keySet().iterator();
 			StringBuilder buf = new StringBuilder( "Following super classes referenced in extends not found: " );
 			while ( iterator.hasNext() ) {
 				final ExtendsQueueEntry entry = ( ExtendsQueueEntry ) iterator.next();
 				buf.append( entry.getExplicitName() );
 				if ( entry.getMappingPackage() != null ) {
 					buf.append( "[" ).append( entry.getMappingPackage() ).append( "]" );
 				}
 				if ( iterator.hasNext() ) {
 					buf.append( "," );
 				}
 			}
 			throw new MappingException( buf.toString() );
 		}
 
 		return added;
 	}
 
 	protected ExtendsQueueEntry findPossibleExtends() {
 		Iterator<ExtendsQueueEntry> itr = extendsQueue.keySet().iterator();
 		while ( itr.hasNext() ) {
 			final ExtendsQueueEntry entry = itr.next();
 			boolean found = getClassMapping( entry.getExplicitName() ) != null
 					|| getClassMapping( HbmBinder.getClassName( entry.getExplicitName(), entry.getMappingPackage() ) ) != null;
 			if ( found ) {
 				itr.remove();
 				return entry;
 			}
 		}
 		return null;
 	}
 
 	protected void secondPassCompileForeignKeys(Table table, Set<ForeignKey> done) throws MappingException {
 		table.createForeignKeys();
 		Iterator iter = table.getForeignKeyIterator();
 		while ( iter.hasNext() ) {
 
 			ForeignKey fk = (ForeignKey) iter.next();
 			if ( !done.contains( fk ) ) {
 				done.add( fk );
 				final String referencedEntityName = fk.getReferencedEntityName();
 				if ( referencedEntityName == null ) {
 					throw new MappingException(
 							"An association from the table " +
 							fk.getTable().getName() +
 							" does not specify the referenced entity"
 						);
 				}
 				LOG.debugf( "Resolving reference to class: %s", referencedEntityName );
 				PersistentClass referencedClass = classes.get( referencedEntityName );
 				if ( referencedClass == null ) {
 					throw new MappingException(
 							"An association from the table " +
 							fk.getTable().getName() +
 							" refers to an unmapped class: " +
 							referencedEntityName
 						);
 				}
 				if ( referencedClass.isJoinedSubclass() ) {
 					secondPassCompileForeignKeys( referencedClass.getSuperclass().getTable(), done );
 				}
 				fk.setReferencedTable( referencedClass.getTable() );
 				fk.alignColumns();
 			}
 		}
 	}
 
 	public Map<String, NamedQueryDefinition> getNamedQueries() {
 		return namedQueries;
 	}
 
 	/**
 	 * Create a {@link SessionFactory} using the properties and mappings in this configuration. The
 	 * {@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} after
 	 * building the {@link SessionFactory} will not affect it.
 	 *
 	 * @param serviceRegistry The registry of services to be used in creating this session factory.
 	 *
 	 * @return The built {@link SessionFactory}
 	 *
 	 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 	 */
 	public SessionFactory buildSessionFactory(ServiceRegistry serviceRegistry) throws HibernateException {
 		LOG.debugf( "Preparing to build session factory with filters : %s", filterDefinitions );
 
 		secondPassCompile();
 		if ( !metadataSourceQueue.isEmpty() ) {
 			LOG.incompleteMappingMetadataCacheProcessing();
 		}
 
 		validate();
 
 		Environment.verifyProperties( properties );
 		Properties copy = new Properties();
 		copy.putAll( properties );
 		ConfigurationHelper.resolvePlaceHolders( copy );
 		Settings settings = buildSettings( copy, serviceRegistry );
 
 		return new SessionFactoryImpl(
 				this,
 				mapping,
 				serviceRegistry,
 				settings,
 				sessionFactoryObserver
 			);
 	}
 
 	/**
 	 * Create a {@link SessionFactory} using the properties and mappings in this configuration. The
 	 * {@link SessionFactory} will be immutable, so changes made to {@code this} {@link Configuration} after
 	 * building the {@link SessionFactory} will not affect it.
 	 *
 	 * @return The build {@link SessionFactory}
 	 *
 	 * @throws HibernateException usually indicates an invalid configuration or invalid mapping information
 	 *
 	 * @deprecated Use {@link #buildSessionFactory(ServiceRegistry)} instead
 	 */
 	public SessionFactory buildSessionFactory() throws HibernateException {
 		Environment.verifyProperties( properties );
 		ConfigurationHelper.resolvePlaceHolders( properties );
-		final ServiceRegistry serviceRegistry =  new ServiceRegistryBuilder()
+		final ServiceRegistry serviceRegistry =  new StandardServiceRegistryBuilder()
 				.applySettings( properties )
 				.buildServiceRegistry();
 		setSessionFactoryObserver(
 				new SessionFactoryObserver() {
 					@Override
 					public void sessionFactoryCreated(SessionFactory factory) {
 					}
 
 					@Override
 					public void sessionFactoryClosed(SessionFactory factory) {
 						( (StandardServiceRegistryImpl) serviceRegistry ).destroy();
 					}
 				}
 		);
 		return buildSessionFactory( serviceRegistry );
 	}
 
 	/**
 	 * Retrieve the configured {@link Interceptor}.
 	 *
 	 * @return The current {@link Interceptor}
 	 */
 	public Interceptor getInterceptor() {
 		return interceptor;
 	}
 
 	/**
 	 * Set the current {@link Interceptor}
 	 *
 	 * @param interceptor The {@link Interceptor} to use for the {@link #buildSessionFactory built}
 	 * {@link SessionFactory}.
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setInterceptor(Interceptor interceptor) {
 		this.interceptor = interceptor;
 		return this;
 	}
 
 	/**
 	 * Get all properties
 	 *
 	 * @return all properties
 	 */
 	public Properties getProperties() {
 		return properties;
 	}
 
 	/**
 	 * Get a property value by name
 	 *
 	 * @param propertyName The name of the property
 	 *
 	 * @return The value currently associated with that property name; may be null.
 	 */
 	public String getProperty(String propertyName) {
 		return properties.getProperty( propertyName );
 	}
 
 	/**
 	 * Specify a completely new set of properties
 	 *
 	 * @param properties The new set of properties
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setProperties(Properties properties) {
 		this.properties = properties;
 		return this;
 	}
 
 	/**
 	 * Add the given properties to ours.
 	 *
 	 * @param extraProperties The properties to add.
 	 *
 	 * @return this for method chaining
 	 *
 	 */
 	public Configuration addProperties(Properties extraProperties) {
 		this.properties.putAll( extraProperties );
 		return this;
 	}
 
 	/**
 	 * Adds the incoming properties to the internal properties structure, as long as the internal structure does not
 	 * already contain an entry for the given key.
 	 *
 	 * @param properties The properties to merge
 	 *
 	 * @return this for ethod chaining
 	 */
 	public Configuration mergeProperties(Properties properties) {
 		for ( Map.Entry entry : properties.entrySet() ) {
 			if ( this.properties.containsKey( entry.getKey() ) ) {
 				continue;
 			}
 			this.properties.setProperty( (String) entry.getKey(), (String) entry.getValue() );
 		}
 		return this;
 	}
 
 	/**
 	 * Set a property value by name
 	 *
 	 * @param propertyName The name of the property to set
 	 * @param value The new property value
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setProperty(String propertyName, String value) {
 		properties.setProperty( propertyName, value );
 		return this;
 	}
 
 	private void addProperties(Element parent) {
 		Iterator itr = parent.elementIterator( "property" );
 		while ( itr.hasNext() ) {
 			Element node = (Element) itr.next();
 			String name = node.attributeValue( "name" );
 			String value = node.getText().trim();
 			LOG.debugf( "%s=%s", name, value );
 			properties.setProperty( name, value );
 			if ( !name.startsWith( "hibernate" ) ) {
 				properties.setProperty( "hibernate." + name, value );
 			}
 		}
 		Environment.verifyProperties( properties );
 	}
 
 	/**
 	 * Use the mappings and properties specified in an application resource named <tt>hibernate.cfg.xml</tt>.
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates we cannot find <tt>hibernate.cfg.xml</tt>
 	 *
 	 * @see #configure(String)
 	 */
 	public Configuration configure() throws HibernateException {
 		configure( "/hibernate.cfg.xml" );
 		return this;
 	}
 
 	/**
 	 * Use the mappings and properties specified in the given application resource. The format of the resource is
 	 * defined in <tt>hibernate-configuration-3.0.dtd</tt>.
 	 * <p/>
 	 * The resource is found via {@link #getConfigurationInputStream}
 	 *
 	 * @param resource The resource to use
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates we cannot find the named resource
 	 *
 	 * @see #doConfigure(java.io.InputStream, String)
 	 */
 	public Configuration configure(String resource) throws HibernateException {
 		LOG.configuringFromResource( resource );
 		InputStream stream = getConfigurationInputStream( resource );
 		return doConfigure( stream, resource );
 	}
 
 	/**
 	 * Get the configuration file as an <tt>InputStream</tt>. Might be overridden
 	 * by subclasses to allow the configuration to be located by some arbitrary
 	 * mechanism.
 	 * <p/>
 	 * By default here we use classpath resource resolution
 	 *
 	 * @param resource The resource to locate
 	 *
 	 * @return The stream
 	 *
 	 * @throws HibernateException Generally indicates we cannot find the named resource
 	 */
 	protected InputStream getConfigurationInputStream(String resource) throws HibernateException {
 		LOG.configurationResource( resource );
 		return ConfigHelper.getResourceAsStream( resource );
 	}
 
 	/**
 	 * Use the mappings and properties specified in the given document. The format of the document is defined in
 	 * <tt>hibernate-configuration-3.0.dtd</tt>.
 	 *
 	 * @param url URL from which you wish to load the configuration
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates a problem access the url
 	 *
 	 * @see #doConfigure(java.io.InputStream, String)
 	 */
 	public Configuration configure(URL url) throws HibernateException {
 		LOG.configuringFromUrl( url );
 		try {
 			return doConfigure( url.openStream(), url.toString() );
 		}
 		catch (IOException ioe) {
 			throw new HibernateException( "could not configure from URL: " + url, ioe );
 		}
 	}
 
 	/**
 	 * Use the mappings and properties specified in the given application file. The format of the file is defined in
 	 * <tt>hibernate-configuration-3.0.dtd</tt>.
 	 *
 	 * @param configFile File from which you wish to load the configuration
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Generally indicates a problem access the file
 	 *
 	 * @see #doConfigure(java.io.InputStream, String)
 	 */
 	public Configuration configure(File configFile) throws HibernateException {
 		LOG.configuringFromFile( configFile.getName() );
 		try {
 			return doConfigure( new FileInputStream( configFile ), configFile.toString() );
 		}
 		catch (FileNotFoundException fnfe) {
 			throw new HibernateException( "could not find file: " + configFile, fnfe );
 		}
 	}
 
 	/**
 	 * Configure this configuration's state from the contents of the given input stream.  The expectation is that
 	 * the stream contents represent an XML document conforming to the Hibernate Configuration DTD.  See
 	 * {@link #doConfigure(Document)} for further details.
 	 *
 	 * @param stream The input stream from which to read
 	 * @param resourceName The name to use in warning/error messages
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Indicates a problem reading the stream contents.
 	 */
 	protected Configuration doConfigure(InputStream stream, String resourceName) throws HibernateException {
 		try {
 			ErrorLogger errorLogger = new ErrorLogger( resourceName );
 			Document document = xmlHelper.createSAXReader( errorLogger,  entityResolver )
 					.read( new InputSource( stream ) );
 			if ( errorLogger.hasErrors() ) {
 				throw new MappingException( "invalid configuration", errorLogger.getErrors().get( 0 ) );
 			}
 			doConfigure( document );
 		}
 		catch (DocumentException e) {
 			throw new HibernateException( "Could not parse configuration: " + resourceName, e );
 		}
 		finally {
 			try {
 				stream.close();
 			}
 			catch (IOException ioe) {
 				LOG.unableToCloseInputStreamForResource( resourceName, ioe );
 			}
 		}
 		return this;
 	}
 
 	/**
 	 * Use the mappings and properties specified in the given XML document.
 	 * The format of the file is defined in
 	 * <tt>hibernate-configuration-3.0.dtd</tt>.
 	 *
 	 * @param document an XML document from which you wish to load the configuration
 	 * @return A configuration configured via the <tt>Document</tt>
 	 * @throws HibernateException if there is problem in accessing the file.
 	 */
 	public Configuration configure(org.w3c.dom.Document document) throws HibernateException {
 		LOG.configuringFromXmlDocument();
 		return doConfigure( xmlHelper.createDOMReader().read( document ) );
 	}
 
 	/**
 	 * Parse a dom4j document conforming to the Hibernate Configuration DTD (<tt>hibernate-configuration-3.0.dtd</tt>)
 	 * and use its information to configure this {@link Configuration}'s state
 	 *
 	 * @param doc The dom4j document
 	 *
 	 * @return this for method chaining
 	 *
 	 * @throws HibernateException Indicates a problem performing the configuration task
 	 */
 	protected Configuration doConfigure(Document doc) throws HibernateException {
 		Element sfNode = doc.getRootElement().element( "session-factory" );
 		String name = sfNode.attributeValue( "name" );
 		if ( name != null ) {
 			properties.setProperty( Environment.SESSION_FACTORY_NAME, name );
 		}
 		addProperties( sfNode );
 		parseSessionFactory( sfNode, name );
 
 		Element secNode = doc.getRootElement().element( "security" );
 		if ( secNode != null ) {
 			parseSecurity( secNode );
 		}
 
 		LOG.configuredSessionFactory( name );
 		LOG.debugf( "Properties: %s", properties );
 
 		return this;
 	}
 
 
 	private void parseSessionFactory(Element sfNode, String name) {
 		Iterator elements = sfNode.elementIterator();
 		while ( elements.hasNext() ) {
 			Element subelement = (Element) elements.next();
 			String subelementName = subelement.getName();
 			if ( "mapping".equals( subelementName ) ) {
 				parseMappingElement( subelement, name );
 			}
 			else if ( "class-cache".equals( subelementName ) ) {
 				String className = subelement.attributeValue( "class" );
 				Attribute regionNode = subelement.attribute( "region" );
 				final String region = ( regionNode == null ) ? className : regionNode.getValue();
 				boolean includeLazy = !"non-lazy".equals( subelement.attributeValue( "include" ) );
 				setCacheConcurrencyStrategy( className, subelement.attributeValue( "usage" ), region, includeLazy );
 			}
 			else if ( "collection-cache".equals( subelementName ) ) {
 				String role = subelement.attributeValue( "collection" );
 				Attribute regionNode = subelement.attribute( "region" );
 				final String region = ( regionNode == null ) ? role : regionNode.getValue();
 				setCollectionCacheConcurrencyStrategy( role, subelement.attributeValue( "usage" ), region );
 			}
 		}
 	}
 
 	private void parseMappingElement(Element mappingElement, String name) {
 		final Attribute resourceAttribute = mappingElement.attribute( "resource" );
 		final Attribute fileAttribute = mappingElement.attribute( "file" );
 		final Attribute jarAttribute = mappingElement.attribute( "jar" );
 		final Attribute packageAttribute = mappingElement.attribute( "package" );
 		final Attribute classAttribute = mappingElement.attribute( "class" );
 
 		if ( resourceAttribute != null ) {
 			final String resourceName = resourceAttribute.getValue();
 			LOG.debugf( "Session-factory config [%s] named resource [%s] for mapping", name, resourceName );
 			addResource( resourceName );
 		}
 		else if ( fileAttribute != null ) {
 			final String fileName = fileAttribute.getValue();
 			LOG.debugf( "Session-factory config [%s] named file [%s] for mapping", name, fileName );
 			addFile( fileName );
 		}
 		else if ( jarAttribute != null ) {
 			final String jarFileName = jarAttribute.getValue();
 			LOG.debugf( "Session-factory config [%s] named jar file [%s] for mapping", name, jarFileName );
 			addJar( new File( jarFileName ) );
 		}
 		else if ( packageAttribute != null ) {
 			final String packageName = packageAttribute.getValue();
 			LOG.debugf( "Session-factory config [%s] named package [%s] for mapping", name, packageName );
 			addPackage( packageName );
 		}
 		else if ( classAttribute != null ) {
 			final String className = classAttribute.getValue();
 			LOG.debugf( "Session-factory config [%s] named class [%s] for mapping", name, className );
 			try {
 				addAnnotatedClass( ReflectHelper.classForName( className ) );
 			}
 			catch ( Exception e ) {
 				throw new MappingException(
 						"Unable to load class [ " + className + "] declared in Hibernate configuration <mapping/> entry",
 						e
 				);
 			}
 		}
 		else {
 			throw new MappingException( "<mapping> element in configuration specifies no known attributes" );
 		}
 	}
 
 	private void parseSecurity(Element secNode) {
 		String contextId = secNode.attributeValue( "context" );
 		setProperty( Environment.JACC_CONTEXTID, contextId );
 		LOG.jaccContextId( contextId );
 		JACCConfiguration jcfg = new JACCConfiguration( contextId );
 		Iterator grantElements = secNode.elementIterator();
 		while ( grantElements.hasNext() ) {
 			Element grantElement = (Element) grantElements.next();
 			String elementName = grantElement.getName();
 			if ( "grant".equals( elementName ) ) {
 				jcfg.addPermission(
 						grantElement.attributeValue( "role" ),
 						grantElement.attributeValue( "entity-name" ),
 						grantElement.attributeValue( "actions" )
 					);
 			}
 		}
 	}
 
 	RootClass getRootClassMapping(String clazz) throws MappingException {
 		try {
 			return (RootClass) getClassMapping( clazz );
 		}
 		catch (ClassCastException cce) {
 			throw new MappingException( "You may only specify a cache for root <class> mappings" );
 		}
 	}
 
 	/**
 	 * Set up a cache for an entity class
 	 *
 	 * @param entityName The name of the entity to which we shoudl associate these cache settings
 	 * @param concurrencyStrategy The cache strategy to use
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy) {
 		setCacheConcurrencyStrategy( entityName, concurrencyStrategy, entityName );
 		return this;
 	}
 
 	/**
 	 * Set up a cache for an entity class, giving an explicit region name
 	 *
 	 * @param entityName The name of the entity to which we should associate these cache settings
 	 * @param concurrencyStrategy The cache strategy to use
 	 * @param region The name of the cache region to use
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setCacheConcurrencyStrategy(String entityName, String concurrencyStrategy, String region) {
 		setCacheConcurrencyStrategy( entityName, concurrencyStrategy, region, true );
 		return this;
 	}
 
 	public void setCacheConcurrencyStrategy(
 			String entityName,
 			String concurrencyStrategy,
 			String region,
 			boolean cacheLazyProperty) throws MappingException {
 		caches.add( new CacheHolder( entityName, concurrencyStrategy, region, true, cacheLazyProperty ) );
 	}
 
 	private void applyCacheConcurrencyStrategy(CacheHolder holder) {
 		RootClass rootClass = getRootClassMapping( holder.role );
 		if ( rootClass == null ) {
 			throw new MappingException( "Cannot cache an unknown entity: " + holder.role );
 		}
 		rootClass.setCacheConcurrencyStrategy( holder.usage );
 		rootClass.setCacheRegionName( holder.region );
 		rootClass.setLazyPropertiesCacheable( holder.cacheLazy );
 	}
 
 	/**
 	 * Set up a cache for a collection role
 	 *
 	 * @param collectionRole The name of the collection to which we should associate these cache settings
 	 * @param concurrencyStrategy The cache strategy to use
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setCollectionCacheConcurrencyStrategy(String collectionRole, String concurrencyStrategy) {
 		setCollectionCacheConcurrencyStrategy( collectionRole, concurrencyStrategy, collectionRole );
 		return this;
 	}
 
 	/**
 	 * Set up a cache for a collection role, giving an explicit region name
 	 *
 	 * @param collectionRole The name of the collection to which we should associate these cache settings
 	 * @param concurrencyStrategy The cache strategy to use
 	 * @param region The name of the cache region to use
 	 */
 	public void setCollectionCacheConcurrencyStrategy(String collectionRole, String concurrencyStrategy, String region) {
 		caches.add( new CacheHolder( collectionRole, concurrencyStrategy, region, false, false ) );
 	}
 
 	private void applyCollectionCacheConcurrencyStrategy(CacheHolder holder) {
 		Collection collection = getCollectionMapping( holder.role );
 		if ( collection == null ) {
 			throw new MappingException( "Cannot cache an unknown collection: " + holder.role );
 		}
 		collection.setCacheConcurrencyStrategy( holder.usage );
 		collection.setCacheRegionName( holder.region );
 	}
 
 	/**
 	 * Get the query language imports
 	 *
 	 * @return a mapping from "import" names to fully qualified class names
 	 */
 	public Map<String,String> getImports() {
 		return imports;
 	}
 
 	/**
 	 * Create an object-oriented view of the configuration properties
 	 *
 	 * @param serviceRegistry The registry of services to be used in building these settings.
 	 *
 	 * @return The build settings
 	 */
 	public Settings buildSettings(ServiceRegistry serviceRegistry) {
 		Properties clone = ( Properties ) properties.clone();
 		ConfigurationHelper.resolvePlaceHolders( clone );
 		return buildSettingsInternal( clone, serviceRegistry );
 	}
 
 	public Settings buildSettings(Properties props, ServiceRegistry serviceRegistry) throws HibernateException {
 		return buildSettingsInternal( props, serviceRegistry );
 	}
 
 	private Settings buildSettingsInternal(Properties props, ServiceRegistry serviceRegistry) {
 		final Settings settings = settingsFactory.buildSettings( props, serviceRegistry );
 		settings.setEntityTuplizerFactory( this.getEntityTuplizerFactory() );
 //		settings.setComponentTuplizerFactory( this.getComponentTuplizerFactory() );
 		return settings;
 	}
 
 	public Map getNamedSQLQueries() {
 		return namedSqlQueries;
 	}
 
 	public Map getSqlResultSetMappings() {
 		return sqlResultSetMappings;
 	}
 
 	public NamingStrategy getNamingStrategy() {
 		return namingStrategy;
 	}
 
 	/**
 	 * Set a custom naming strategy
 	 *
 	 * @param namingStrategy the NamingStrategy to set
 	 *
 	 * @return this for method chaining
 	 */
 	public Configuration setNamingStrategy(NamingStrategy namingStrategy) {
 		this.namingStrategy = namingStrategy;
 		return this;
 	}
 
 	/**
 	 * Retrieve the IdentifierGeneratorFactory in effect for this configuration.
 	 *
 	 * @return This configuration's IdentifierGeneratorFactory.
 	 */
 	public MutableIdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 		return identifierGeneratorFactory;
 	}
 
 	public Mapping buildMapping() {
 		return new Mapping() {
 			public IdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 				return identifierGeneratorFactory;
 			}
 
 			/**
 			 * Returns the identifier type of a mapped class
 			 */
 			public Type getIdentifierType(String entityName) throws MappingException {
 				PersistentClass pc = classes.get( entityName );
 				if ( pc == null ) {
 					throw new MappingException( "persistent class not known: " + entityName );
 				}
 				return pc.getIdentifier().getType();
 			}
 
 			public String getIdentifierPropertyName(String entityName) throws MappingException {
 				final PersistentClass pc = classes.get( entityName );
 				if ( pc == null ) {
 					throw new MappingException( "persistent class not known: " + entityName );
 				}
 				if ( !pc.hasIdentifierProperty() ) {
 					return null;
 				}
 				return pc.getIdentifierProperty().getName();
 			}
 
 			public Type getReferencedPropertyType(String entityName, String propertyName) throws MappingException {
 				final PersistentClass pc = classes.get( entityName );
 				if ( pc == null ) {
 					throw new MappingException( "persistent class not known: " + entityName );
 				}
 				Property prop = pc.getReferencedProperty( propertyName );
 				if ( prop == null ) {
 					throw new MappingException(
 							"property not known: " +
 							entityName + '.' + propertyName
 						);
 				}
 				return prop.getType();
 			}
 		};
 	}
 
 	private void readObject(ObjectInputStream ois) throws IOException, ClassNotFoundException {
 		//we need  reflectionManager before reading the other components (MetadataSourceQueue in particular)
 		final MetadataProvider metadataProvider = (MetadataProvider) ois.readObject();
 		this.mapping = buildMapping();
 		xmlHelper = new XMLHelper();
 		createReflectionManager(metadataProvider);
 		ois.defaultReadObject();
 	}
 
 	private void writeObject(java.io.ObjectOutputStream out) throws IOException {
 		//We write MetadataProvider first as we need  reflectionManager before reading the other components
 		final MetadataProvider metadataProvider = ( ( MetadataProviderInjector ) reflectionManager ).getMetadataProvider();
 		out.writeObject( metadataProvider );
 		out.defaultWriteObject();
 	}
 
 	private void createReflectionManager() {
 		createReflectionManager( new JPAMetadataProvider() );
 	}
 
 	private void createReflectionManager(MetadataProvider metadataProvider) {
 		reflectionManager = new JavaReflectionManager();
 		( ( MetadataProviderInjector ) reflectionManager ).setMetadataProvider( metadataProvider );
 	}
 
 	public Map getFilterDefinitions() {
 		return filterDefinitions;
 	}
 
 	public void addFilterDefinition(FilterDefinition definition) {
 		filterDefinitions.put( definition.getFilterName(), definition );
 	}
 
 	public Iterator iterateFetchProfiles() {
 		return fetchProfiles.values().iterator();
 	}
 
 	public void addFetchProfile(FetchProfile fetchProfile) {
 		fetchProfiles.put( fetchProfile.getName(), fetchProfile );
 	}
 
 	public void addAuxiliaryDatabaseObject(AuxiliaryDatabaseObject object) {
 		auxiliaryDatabaseObjects.add( object );
 	}
 
 	public Map getSqlFunctions() {
 		return sqlFunctions;
 	}
 
 	public void addSqlFunction(String functionName, SQLFunction function) {
 		sqlFunctions.put( functionName, function );
 	}
 
 	public TypeResolver getTypeResolver() {
 		return typeResolver;
 	}
 
 	/**
 	 * Allows registration of a type into the type registry.  The phrase 'override' in the method name simply
 	 * reminds that registration *potentially* replaces a previously registered type .
 	 *
 	 * @param type The type to register.
 	 */
 	public void registerTypeOverride(BasicType type) {
 		getTypeResolver().registerTypeOverride( type );
 	}
 
 
 	public void registerTypeOverride(UserType type, String[] keys) {
 		getTypeResolver().registerTypeOverride( type, keys );
 	}
 
 	public void registerTypeOverride(CompositeUserType type, String[] keys) {
 		getTypeResolver().registerTypeOverride( type, keys );
 	}
 
 	public SessionFactoryObserver getSessionFactoryObserver() {
 		return sessionFactoryObserver;
 	}
 
 	public void setSessionFactoryObserver(SessionFactoryObserver sessionFactoryObserver) {
 		this.sessionFactoryObserver = sessionFactoryObserver;
 	}
 
 	public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver() {
 		return currentTenantIdentifierResolver;
 	}
 
 	public void setCurrentTenantIdentifierResolver(CurrentTenantIdentifierResolver currentTenantIdentifierResolver) {
 		this.currentTenantIdentifierResolver = currentTenantIdentifierResolver;
 	}
 
 	/**
 	 * Adds the AttributeConverter Class to this Configuration.
 	 *
 	 * @param attributeConverterClass The AttributeConverter class.
 	 * @param autoApply Should the AttributeConverter be auto applied to property types as specified
 	 * by its "entity attribute" parameterized type?
 	 */
 	public void addAttributeConverter(Class<? extends AttributeConverter> attributeConverterClass, boolean autoApply) {
 		final AttributeConverter attributeConverter;
 		try {
 			attributeConverter = attributeConverterClass.newInstance();
 		}
 		catch (Exception e) {
 			throw new AnnotationException(
 					"Unable to instantiate AttributeConverter [" + attributeConverterClass.getName() + "]"
 			);
 		}
 		addAttributeConverter( attributeConverter, autoApply );
 	}
 
 	/**
 	 * Adds the AttributeConverter instance to this Configuration.  This form is mainly intended for developers
 	 * to programatically add their own AttributeConverter instance.  HEM, instead, uses the
 	 * {@link #addAttributeConverter(Class, boolean)} form
 	 *
 	 * @param attributeConverter The AttributeConverter instance.
 	 * @param autoApply Should the AttributeConverter be auto applied to property types as specified
 	 * by its "entity attribute" parameterized type?
 	 */
 	public void addAttributeConverter(AttributeConverter attributeConverter, boolean autoApply) {
 		if ( attributeConverterDefinitionsByClass == null ) {
 			attributeConverterDefinitionsByClass = new ConcurrentHashMap<Class, AttributeConverterDefinition>();
 		}
 
 		final Object old = attributeConverterDefinitionsByClass.put(
 				attributeConverter.getClass(),
 				new AttributeConverterDefinition( attributeConverter, autoApply )
 		);
 
 		if ( old != null ) {
 			throw new AssertionFailure(
 					"AttributeConverter class [" + attributeConverter.getClass() + "] registered multiple times"
 			);
 		}
 	}
 
 
 	// Mappings impl ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	/**
 	 * Internal implementation of the Mappings interface giving access to the Configuration's internal
 	 * <tt>metadata repository</tt> state ({@link Configuration#classes}, {@link Configuration#tables}, etc).
 	 */
 	@SuppressWarnings( {"deprecation", "unchecked"})
 	protected class MappingsImpl implements ExtendedMappings, Serializable {
 
 		private String schemaName;
 
 		public String getSchemaName() {
 			return schemaName;
 		}
 
 		public void setSchemaName(String schemaName) {
 			this.schemaName = schemaName;
 		}
 
 
 		private String catalogName;
 
 		public String getCatalogName() {
 			return catalogName;
 		}
 
 		public void setCatalogName(String catalogName) {
 			this.catalogName = catalogName;
 		}
 
 
 		private String defaultPackage;
 
 		public String getDefaultPackage() {
 			return defaultPackage;
 		}
 
 		public void setDefaultPackage(String defaultPackage) {
 			this.defaultPackage = defaultPackage;
 		}
 
 
 		private boolean autoImport;
 
 		public boolean isAutoImport() {
 			return autoImport;
 		}
 
 		public void setAutoImport(boolean autoImport) {
 			this.autoImport = autoImport;
 		}
 
 
 		private boolean defaultLazy;
 
 		public boolean isDefaultLazy() {
 			return defaultLazy;
 		}
 
 		public void setDefaultLazy(boolean defaultLazy) {
 			this.defaultLazy = defaultLazy;
 		}
 
 
 		private String defaultCascade;
 
 		public String getDefaultCascade() {
 			return defaultCascade;
 		}
 
 		public void setDefaultCascade(String defaultCascade) {
 			this.defaultCascade = defaultCascade;
 		}
 
 
 		private String defaultAccess;
 
 		public String getDefaultAccess() {
 			return defaultAccess;
 		}
 
 		public void setDefaultAccess(String defaultAccess) {
 			this.defaultAccess = defaultAccess;
 		}
 
 
 		public NamingStrategy getNamingStrategy() {
 			return namingStrategy;
 		}
 
 		public void setNamingStrategy(NamingStrategy namingStrategy) {
 			Configuration.this.namingStrategy = namingStrategy;
 		}
 
 		public TypeResolver getTypeResolver() {
 			return typeResolver;
 		}
 
 		public Iterator<PersistentClass> iterateClasses() {
 			return classes.values().iterator();
 		}
 
 		public PersistentClass getClass(String entityName) {
 			return classes.get( entityName );
 		}
 
 		public PersistentClass locatePersistentClassByEntityName(String entityName) {
 			PersistentClass persistentClass = classes.get( entityName );
 			if ( persistentClass == null ) {
 				String actualEntityName = imports.get( entityName );
 				if ( StringHelper.isNotEmpty( actualEntityName ) ) {
 					persistentClass = classes.get( actualEntityName );
 				}
 			}
 			return persistentClass;
 		}
 
 		public void addClass(PersistentClass persistentClass) throws DuplicateMappingException {
 			Object old = classes.put( persistentClass.getEntityName(), persistentClass );
 			if ( old != null ) {
 				throw new DuplicateMappingException( "class/entity", persistentClass.getEntityName() );
 			}
 		}
 
 		public void addImport(String entityName, String rename) throws DuplicateMappingException {
 			String existing = imports.put( rename, entityName );
 			if ( existing != null ) {
                 if (existing.equals(entityName)) LOG.duplicateImport(entityName, rename);
                 else throw new DuplicateMappingException("duplicate import: " + rename + " refers to both " + entityName + " and "
                                                          + existing + " (try using auto-import=\"false\")", "import", rename);
 			}
 		}
 
 		public Collection getCollection(String role) {
 			return collections.get( role );
 		}
 
 		public Iterator<Collection> iterateCollections() {
 			return collections.values().iterator();
 		}
 
 		public void addCollection(Collection collection) throws DuplicateMappingException {
 			Object old = collections.put( collection.getRole(), collection );
 			if ( old != null ) {
 				throw new DuplicateMappingException( "collection role", collection.getRole() );
 			}
 		}
 
 		public Table getTable(String schema, String catalog, String name) {
 			String key = Table.qualify(catalog, schema, name);
 			return tables.get(key);
 		}
 
 		public Iterator<Table> iterateTables() {
 			return tables.values().iterator();
 		}
 
 		public Table addTable(
 				String schema,
 				String catalog,
 				String name,
 				String subselect,
 				boolean isAbstract) {
 			name = getObjectNameNormalizer().normalizeIdentifierQuoting( name );
 			schema = getObjectNameNormalizer().normalizeIdentifierQuoting( schema );
 			catalog = getObjectNameNormalizer().normalizeIdentifierQuoting( catalog );
 
 			String key = subselect == null ? Table.qualify( catalog, schema, name ) : subselect;
 			Table table = tables.get( key );
 
 			if ( table == null ) {
 				table = new Table();
 				table.setAbstract( isAbstract );
 				table.setName( name );
 				table.setSchema( schema );
 				table.setCatalog( catalog );
 				table.setSubselect( subselect );
 				tables.put( key, table );
 			}
 			else {
 				if ( !isAbstract ) {
 					table.setAbstract( false );
 				}
 			}
 
 			return table;
 		}
 
 		public Table addDenormalizedTable(
 				String schema,
 				String catalog,
 				String name,
 				boolean isAbstract,
 				String subselect,
 				Table includedTable) throws DuplicateMappingException {
 			name = getObjectNameNormalizer().normalizeIdentifierQuoting( name );
 			schema = getObjectNameNormalizer().normalizeIdentifierQuoting( schema );
 			catalog = getObjectNameNormalizer().normalizeIdentifierQuoting( catalog );
 
 			String key = subselect == null ? Table.qualify(catalog, schema, name) : subselect;
 			if ( tables.containsKey( key ) ) {
 				throw new DuplicateMappingException( "table", name );
 			}
 
 			Table table = new DenormalizedTable( includedTable );
 			table.setAbstract( isAbstract );
 			table.setName( name );
 			table.setSchema( schema );
 			table.setCatalog( catalog );
 			table.setSubselect( subselect );
 
 			tables.put( key, table );
 			return table;
 		}
 
 		public NamedQueryDefinition getQuery(String name) {
 			return namedQueries.get( name );
 		}
 
 		public void addQuery(String name, NamedQueryDefinition query) throws DuplicateMappingException {
 			if ( !defaultNamedQueryNames.contains( name ) ) {
 				applyQuery( name, query );
 			}
 		}
 
 		private void applyQuery(String name, NamedQueryDefinition query) {
 			checkQueryName( name );
 			namedQueries.put( name.intern(), query );
 		}
 
 		private void checkQueryName(String name) throws DuplicateMappingException {
 			if ( namedQueries.containsKey( name ) || namedSqlQueries.containsKey( name ) ) {
 				throw new DuplicateMappingException( "query", name );
 			}
 		}
 
 		public void addDefaultQuery(String name, NamedQueryDefinition query) {
 			applyQuery( name, query );
 			defaultNamedQueryNames.add( name );
 		}
 
 		public NamedSQLQueryDefinition getSQLQuery(String name) {
 			return namedSqlQueries.get( name );
 		}
 
 		public void addSQLQuery(String name, NamedSQLQueryDefinition query) throws DuplicateMappingException {
 			if ( !defaultNamedNativeQueryNames.contains( name ) ) {
 				applySQLQuery( name, query );
 			}
 		}
 
 		private void applySQLQuery(String name, NamedSQLQueryDefinition query) throws DuplicateMappingException {
 			checkQueryName( name );
 			namedSqlQueries.put( name.intern(), query );
 		}
 
 		public void addDefaultSQLQuery(String name, NamedSQLQueryDefinition query) {
 			applySQLQuery( name, query );
 			defaultNamedNativeQueryNames.add( name );
 		}
 
 		public ResultSetMappingDefinition getResultSetMapping(String name) {
 			return sqlResultSetMappings.get(name);
 		}
 
 		public void addResultSetMapping(ResultSetMappingDefinition sqlResultSetMapping) throws DuplicateMappingException {
 			if ( !defaultSqlResultSetMappingNames.contains( sqlResultSetMapping.getName() ) ) {
 				applyResultSetMapping( sqlResultSetMapping );
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/Environment.java b/hibernate-core/src/main/java/org/hibernate/cfg/Environment.java
index 825d156386..8cc6667472 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/Environment.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/Environment.java
@@ -1,354 +1,354 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.sql.Connection;
 import java.sql.Timestamp;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Properties;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Version;
 import org.hibernate.bytecode.spi.BytecodeProvider;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ConfigHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 
 
 /**
  * Provides access to configuration info passed in <tt>Properties</tt> objects.
  * <br><br>
  * Hibernate has two property scopes:
  * <ul>
  * <li><b>Factory-level</b> properties may be passed to the <tt>SessionFactory</tt> when it
  * instantiated. Each instance might have different property values. If no
  * properties are specified, the factory calls <tt>Environment.getProperties()</tt>.
  * <li><b>System-level</b> properties are shared by all factory instances and are always
  * determined by the <tt>Environment</tt> properties.
  * </ul>
  * The only system-level properties are
  * <ul>
  * <li><tt>hibernate.jdbc.use_streams_for_binary</tt>
  * <li><tt>hibernate.cglib.use_reflection_optimizer</tt>
  * </ul>
  * <tt>Environment</tt> properties are populated by calling <tt>System.getProperties()</tt>
  * and then from a resource named <tt>/hibernate.properties</tt> if it exists. System
  * properties override properties specified in <tt>hibernate.properties</tt>.<br>
  * <br>
  * The <tt>SessionFactory</tt> is controlled by the following properties.
  * Properties may be either be <tt>System</tt> properties, properties
  * defined in a resource named <tt>/hibernate.properties</tt> or an instance of
  * <tt>java.util.Properties</tt> passed to
  * <tt>Configuration.buildSessionFactory()</tt><br>
  * <br>
  * <table>
  * <tr><td><b>property</b></td><td><b>meaning</b></td></tr>
  * <tr>
  *   <td><tt>hibernate.dialect</tt></td>
  *   <td>classname of <tt>org.hibernate.dialect.Dialect</tt> subclass</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.connection.provider_class</tt></td>
- *   <td>classname of <tt>org.hibernate.service.jdbc.connections.spi.ConnectionProvider</tt>
+ *   <td>classname of <tt>ConnectionProvider</tt>
  *   subclass (if not specified hueristics are used)</td>
  * </tr>
  * <tr><td><tt>hibernate.connection.username</tt></td><td>database username</td></tr>
  * <tr><td><tt>hibernate.connection.password</tt></td><td>database password</td></tr>
  * <tr>
  *   <td><tt>hibernate.connection.url</tt></td>
  *   <td>JDBC URL (when using <tt>java.sql.DriverManager</tt>)</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.connection.driver_class</tt></td>
  *   <td>classname of JDBC driver</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.connection.isolation</tt></td>
  *   <td>JDBC transaction isolation level (only when using
  *     <tt>java.sql.DriverManager</tt>)
  *   </td>
  * </tr>
  *   <td><tt>hibernate.connection.pool_size</tt></td>
  *   <td>the maximum size of the connection pool (only when using
  *     <tt>java.sql.DriverManager</tt>)
  *   </td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.connection.datasource</tt></td>
  *   <td>databasource JNDI name (when using <tt>javax.sql.Datasource</tt>)</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.jndi.url</tt></td><td>JNDI <tt>InitialContext</tt> URL</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.jndi.class</tt></td><td>JNDI <tt>InitialContext</tt> classname</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.max_fetch_depth</tt></td>
  *   <td>maximum depth of outer join fetching</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.jdbc.batch_size</tt></td>
  *   <td>enable use of JDBC2 batch API for drivers which support it</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.jdbc.fetch_size</tt></td>
  *   <td>set the JDBC fetch size</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.jdbc.use_scrollable_resultset</tt></td>
  *   <td>enable use of JDBC2 scrollable resultsets (you only need this specify
  *   this property when using user supplied connections)</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.jdbc.use_getGeneratedKeys</tt></td>
  *   <td>enable use of JDBC3 PreparedStatement.getGeneratedKeys() to retrieve
  *   natively generated keys after insert. Requires JDBC3+ driver and JRE1.4+</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.hbm2ddl.auto</tt></td>
  *   <td>enable auto DDL export</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.default_schema</tt></td>
  *   <td>use given schema name for unqualified tables (always optional)</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.default_catalog</tt></td>
  *   <td>use given catalog name for unqualified tables (always optional)</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.session_factory_name</tt></td>
  *   <td>If set, the factory attempts to bind this name to itself in the
  *   JNDI context. This name is also used to support cross JVM <tt>
  *   Session</tt> (de)serialization.</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.transaction.manager_lookup_class</tt></td>
  *   <td>classname of <tt>org.hibernate.transaction.TransactionManagerLookup</tt>
  *   implementor</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.transaction.factory_class</tt></td>
  *   <td>the factory to use for instantiating <tt>Transaction</tt>s.
  *   (Defaults to <tt>JdbcTransactionFactory</tt>.)</td>
  * </tr>
  * <tr>
  *   <td><tt>hibernate.query.substitutions</tt></td><td>query language token substitutions</td>
  * </tr>
  * </table>
  *
  * @see org.hibernate.SessionFactory
  * @author Gavin King
  */
 public final class Environment implements AvailableSettings {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, Environment.class.getName());
 
 	private static final BytecodeProvider BYTECODE_PROVIDER_INSTANCE;
 	private static final boolean ENABLE_BINARY_STREAMS;
 	private static final boolean ENABLE_REFLECTION_OPTIMIZER;
 	private static final boolean JVM_HAS_TIMESTAMP_BUG;
 
 	private static final Properties GLOBAL_PROPERTIES;
 	private static final Map<Integer,String> ISOLATION_LEVELS;
 
 	private static final Map OBSOLETE_PROPERTIES = new HashMap();
 	private static final Map RENAMED_PROPERTIES = new HashMap();
 
 	/**
 	 * Issues warnings to the user when any obsolete or renamed property names are used.
 	 *
 	 * @param configurationValues The specified properties.
 	 */
 	public static void verifyProperties(Map<?,?> configurationValues) {
 		final Map propertiesToAdd = new HashMap();
 		for ( Map.Entry entry : configurationValues.entrySet() ) {
 			final Object replacementKey = OBSOLETE_PROPERTIES.get( entry.getKey() );
 			if ( replacementKey != null ) {
 				LOG.unsupportedProperty( entry.getKey(), replacementKey );
 			}
 			final Object renamedKey = RENAMED_PROPERTIES.get( entry.getKey() );
 			if ( renamedKey != null ) {
 				LOG.renamedProperty( entry.getKey(), renamedKey );
 				propertiesToAdd.put( renamedKey, entry.getValue() );
 			}
 		}
 		configurationValues.putAll( propertiesToAdd );
 	}
 
 	static {
 		Version.logVersion();
 
 		Map<Integer,String> temp = new HashMap<Integer,String>();
 		temp.put( Connection.TRANSACTION_NONE, "NONE" );
 		temp.put( Connection.TRANSACTION_READ_UNCOMMITTED, "READ_UNCOMMITTED" );
 		temp.put( Connection.TRANSACTION_READ_COMMITTED, "READ_COMMITTED" );
 		temp.put( Connection.TRANSACTION_REPEATABLE_READ, "REPEATABLE_READ" );
 		temp.put( Connection.TRANSACTION_SERIALIZABLE, "SERIALIZABLE" );
 		ISOLATION_LEVELS = Collections.unmodifiableMap( temp );
 		GLOBAL_PROPERTIES = new Properties();
 		//Set USE_REFLECTION_OPTIMIZER to false to fix HHH-227
 		GLOBAL_PROPERTIES.setProperty( USE_REFLECTION_OPTIMIZER, Boolean.FALSE.toString() );
 
 		try {
 			InputStream stream = ConfigHelper.getResourceAsStream( "/hibernate.properties" );
 			try {
 				GLOBAL_PROPERTIES.load(stream);
 				LOG.propertiesLoaded( ConfigurationHelper.maskOut( GLOBAL_PROPERTIES, PASS ) );
 			}
 			catch (Exception e) {
 				LOG.unableToLoadProperties();
 			}
 			finally {
 				try{
 					stream.close();
 				}
 				catch (IOException ioe){
 					LOG.unableToCloseStreamError( ioe );
 				}
 			}
 		}
 		catch (HibernateException he) {
 			LOG.propertiesNotFound();
 		}
 
 		try {
 			GLOBAL_PROPERTIES.putAll( System.getProperties() );
 		}
 		catch (SecurityException se) {
 			LOG.unableToCopySystemProperties();
 		}
 
 		verifyProperties(GLOBAL_PROPERTIES);
 
 		ENABLE_BINARY_STREAMS = ConfigurationHelper.getBoolean(USE_STREAMS_FOR_BINARY, GLOBAL_PROPERTIES);
 		if ( ENABLE_BINARY_STREAMS ) {
 			LOG.usingStreams();
 		}
 
 		ENABLE_REFLECTION_OPTIMIZER = ConfigurationHelper.getBoolean(USE_REFLECTION_OPTIMIZER, GLOBAL_PROPERTIES);
 		if ( ENABLE_REFLECTION_OPTIMIZER ) {
 			LOG.usingReflectionOptimizer();
 		}
 
 		BYTECODE_PROVIDER_INSTANCE = buildBytecodeProvider( GLOBAL_PROPERTIES );
 
 		long x = 123456789;
 		JVM_HAS_TIMESTAMP_BUG = new Timestamp(x).getTime() != x;
 		if ( JVM_HAS_TIMESTAMP_BUG ) {
 			LOG.usingTimestampWorkaround();
 		}
 	}
 
 	public static BytecodeProvider getBytecodeProvider() {
 		return BYTECODE_PROVIDER_INSTANCE;
 	}
 
 	/**
 	 * Does this JVM's implementation of {@link java.sql.Timestamp} have a bug in which the following is true:<code>
 	 * new java.sql.Timestamp( x ).getTime() != x
 	 * </code>
 	 * <p/>
 	 * NOTE : IBM JDK 1.3.1 the only known JVM to exhibit this behavior.
 	 *
 	 * @return True if the JVM's {@link Timestamp} implementa
 	 */
 	public static boolean jvmHasTimestampBug() {
 		return JVM_HAS_TIMESTAMP_BUG;
 	}
 
 	/**
 	 * Should we use streams to bind binary types to JDBC IN parameters?
 	 *
 	 * @return True if streams should be used for binary data handling; false otherwise.
 	 *
 	 * @see #USE_STREAMS_FOR_BINARY
 	 */
 	public static boolean useStreamsForBinary() {
 		return ENABLE_BINARY_STREAMS;
 	}
 
 	/**
 	 * Should we use reflection optimization?
 	 *
 	 * @return True if reflection optimization should be used; false otherwise.
 	 *
 	 * @see #USE_REFLECTION_OPTIMIZER
 	 * @see #getBytecodeProvider()
 	 * @see BytecodeProvider#getReflectionOptimizer
 	 */
 	public static boolean useReflectionOptimizer() {
 		return ENABLE_REFLECTION_OPTIMIZER;
 	}
 
 	/**
 	 * Disallow instantiation
 	 */
 	private Environment() {
 		throw new UnsupportedOperationException();
 	}
 
 	/**
 	 * Return <tt>System</tt> properties, extended by any properties specified
 	 * in <tt>hibernate.properties</tt>.
 	 * @return Properties
 	 */
 	public static Properties getProperties() {
 		Properties copy = new Properties();
 		copy.putAll(GLOBAL_PROPERTIES);
 		return copy;
 	}
 
 	/**
 	 * Get the name of a JDBC transaction isolation level
 	 *
 	 * @see java.sql.Connection
 	 * @param isolation as defined by <tt>java.sql.Connection</tt>
 	 * @return a human-readable name
 	 */
 	public static String isolationLevelToString(int isolation) {
 		return ISOLATION_LEVELS.get( isolation );
 	}
 
 	public static BytecodeProvider buildBytecodeProvider(Properties properties) {
 		String provider = ConfigurationHelper.getString( BYTECODE_PROVIDER, properties, "javassist" );
 		LOG.bytecodeProvider( provider );
 		return buildBytecodeProvider( provider );
 	}
 
 	private static BytecodeProvider buildBytecodeProvider(String providerName) {
 		if ( "javassist".equals( providerName ) ) {
 			return new org.hibernate.bytecode.internal.javassist.BytecodeProviderImpl();
 		}
 
 		LOG.unknownBytecodeProvider( providerName );
 		return new org.hibernate.bytecode.internal.javassist.BytecodeProviderImpl();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/Settings.java b/hibernate-core/src/main/java/org/hibernate/cfg/Settings.java
index 0a155ae00a..2529b656c1 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/Settings.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/Settings.java
@@ -1,461 +1,461 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 import java.util.Map;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.EntityMode;
 import org.hibernate.MultiTenancyStrategy;
 import org.hibernate.cache.spi.QueryCacheFactory;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.hql.spi.QueryTranslatorFactory;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.tuple.entity.EntityTuplizerFactory;
 
 /**
  * Settings that affect the behaviour of Hibernate at runtime.
  *
  * @author Gavin King
  */
 public final class Settings {
 
 	private Integer maximumFetchDepth;
 	private Map querySubstitutions;
 	private int jdbcBatchSize;
 	private int defaultBatchFetchSize;
 	private boolean scrollableResultSetsEnabled;
 	private boolean getGeneratedKeysEnabled;
 	private String defaultSchemaName;
 	private String defaultCatalogName;
 	private Integer jdbcFetchSize;
 	private String sessionFactoryName;
 	private boolean sessionFactoryNameAlsoJndiName;
 	private boolean autoCreateSchema;
 	private boolean autoDropSchema;
 	private boolean autoUpdateSchema;
 	private boolean autoValidateSchema;
 	private boolean queryCacheEnabled;
 	private boolean structuredCacheEntriesEnabled;
 	private boolean secondLevelCacheEnabled;
 	private String cacheRegionPrefix;
 	private boolean minimalPutsEnabled;
 	private boolean commentsEnabled;
 	private boolean statisticsEnabled;
 	private boolean jdbcBatchVersionedData;
 	private boolean identifierRollbackEnabled;
 	private boolean flushBeforeCompletionEnabled;
 	private boolean autoCloseSessionEnabled;
 	private ConnectionReleaseMode connectionReleaseMode;
 	private RegionFactory regionFactory;
 	private QueryCacheFactory queryCacheFactory;
 	private QueryTranslatorFactory queryTranslatorFactory;
 	private boolean wrapResultSetsEnabled;
 	private boolean orderUpdatesEnabled;
 	private boolean orderInsertsEnabled;
 	private EntityMode defaultEntityMode;
 	private boolean dataDefinitionImplicitCommit;
 	private boolean dataDefinitionInTransactionSupported;
 	private boolean strictJPAQLCompliance;
 	private boolean namedQueryStartupCheckingEnabled;
 	private EntityTuplizerFactory entityTuplizerFactory;
 	private boolean checkNullability;
 //	private ComponentTuplizerFactory componentTuplizerFactory; todo : HHH-3517 and HHH-1907
 //	private BytecodeProvider bytecodeProvider;
 	private String importFiles;
 	private MultiTenancyStrategy multiTenancyStrategy;
 
 	private JtaPlatform jtaPlatform;
 
 	/**
 	 * Package protected constructor
 	 */
 	Settings() {
 	}
 
 	// public getters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public String getImportFiles() {
 		return importFiles;
 	}
 
 	public void setImportFiles(String importFiles) {
 		this.importFiles = importFiles;
 	}
 
 	public String getDefaultSchemaName() {
 		return defaultSchemaName;
 	}
 
 	public String getDefaultCatalogName() {
 		return defaultCatalogName;
 	}
 
 	public int getJdbcBatchSize() {
 		return jdbcBatchSize;
 	}
 
 	public int getDefaultBatchFetchSize() {
 		return defaultBatchFetchSize;
 	}
 
 	public Map getQuerySubstitutions() {
 		return querySubstitutions;
 	}
 
 	public boolean isIdentifierRollbackEnabled() {
 		return identifierRollbackEnabled;
 	}
 
 	public boolean isScrollableResultSetsEnabled() {
 		return scrollableResultSetsEnabled;
 	}
 
 	public boolean isGetGeneratedKeysEnabled() {
 		return getGeneratedKeysEnabled;
 	}
 
 	public boolean isMinimalPutsEnabled() {
 		return minimalPutsEnabled;
 	}
 
 	public Integer getJdbcFetchSize() {
 		return jdbcFetchSize;
 	}
 
 	public String getSessionFactoryName() {
 		return sessionFactoryName;
 	}
 
 	public boolean isSessionFactoryNameAlsoJndiName() {
 		return sessionFactoryNameAlsoJndiName;
 	}
 
 	public boolean isAutoCreateSchema() {
 		return autoCreateSchema;
 	}
 
 	public boolean isAutoDropSchema() {
 		return autoDropSchema;
 	}
 
 	public boolean isAutoUpdateSchema() {
 		return autoUpdateSchema;
 	}
 
 	public Integer getMaximumFetchDepth() {
 		return maximumFetchDepth;
 	}
 
 	public RegionFactory getRegionFactory() {
 		return regionFactory;
 	}
 
 	public boolean isQueryCacheEnabled() {
 		return queryCacheEnabled;
 	}
 
 	public boolean isCommentsEnabled() {
 		return commentsEnabled;
 	}
 
 	public boolean isSecondLevelCacheEnabled() {
 		return secondLevelCacheEnabled;
 	}
 
 	public String getCacheRegionPrefix() {
 		return cacheRegionPrefix;
 	}
 
 	public QueryCacheFactory getQueryCacheFactory() {
 		return queryCacheFactory;
 	}
 
 	public boolean isStatisticsEnabled() {
 		return statisticsEnabled;
 	}
 
 	public boolean isJdbcBatchVersionedData() {
 		return jdbcBatchVersionedData;
 	}
 
 	public boolean isFlushBeforeCompletionEnabled() {
 		return flushBeforeCompletionEnabled;
 	}
 
 	public boolean isAutoCloseSessionEnabled() {
 		return autoCloseSessionEnabled;
 	}
 
 	public ConnectionReleaseMode getConnectionReleaseMode() {
 		return connectionReleaseMode;
 	}
 
 	public QueryTranslatorFactory getQueryTranslatorFactory() {
 		return queryTranslatorFactory;
 	}
 
 	public boolean isWrapResultSetsEnabled() {
 		return wrapResultSetsEnabled;
 	}
 
 	public boolean isOrderUpdatesEnabled() {
 		return orderUpdatesEnabled;
 	}
 
 	public boolean isOrderInsertsEnabled() {
 		return orderInsertsEnabled;
 	}
 
 	public boolean isStructuredCacheEntriesEnabled() {
 		return structuredCacheEntriesEnabled;
 	}
 
 	public EntityMode getDefaultEntityMode() {
 		return defaultEntityMode;
 	}
 
 	public boolean isAutoValidateSchema() {
 		return autoValidateSchema;
 	}
 
 	public boolean isDataDefinitionImplicitCommit() {
 		return dataDefinitionImplicitCommit;
 	}
 
 	public boolean isDataDefinitionInTransactionSupported() {
 		return dataDefinitionInTransactionSupported;
 	}
 
 	public boolean isStrictJPAQLCompliance() {
 		return strictJPAQLCompliance;
 	}
 
 	public boolean isNamedQueryStartupCheckingEnabled() {
 		return namedQueryStartupCheckingEnabled;
 	}
 
 	public EntityTuplizerFactory getEntityTuplizerFactory() {
 		return entityTuplizerFactory;
 	}
 
 //	public ComponentTuplizerFactory getComponentTuplizerFactory() {
 //		return componentTuplizerFactory;
 //	}
 
 	// package protected setters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	void setDefaultSchemaName(String string) {
 		defaultSchemaName = string;
 	}
 
 	void setDefaultCatalogName(String string) {
 		defaultCatalogName = string;
 	}
 
 	void setJdbcBatchSize(int i) {
 		jdbcBatchSize = i;
 	}
 
 	void setDefaultBatchFetchSize(int i) {
 		defaultBatchFetchSize = i;
 	}
 
 	void setQuerySubstitutions(Map map) {
 		querySubstitutions = map;
 	}
 
 	void setIdentifierRollbackEnabled(boolean b) {
 		identifierRollbackEnabled = b;
 	}
 
 	void setMinimalPutsEnabled(boolean b) {
 		minimalPutsEnabled = b;
 	}
 
 	void setScrollableResultSetsEnabled(boolean b) {
 		scrollableResultSetsEnabled = b;
 	}
 
 	void setGetGeneratedKeysEnabled(boolean b) {
 		getGeneratedKeysEnabled = b;
 	}
 
 	void setJdbcFetchSize(Integer integer) {
 		jdbcFetchSize = integer;
 	}
 
 	void setSessionFactoryName(String string) {
 		sessionFactoryName = string;
 	}
 
 	void setSessionFactoryNameAlsoJndiName(boolean sessionFactoryNameAlsoJndiName) {
 		this.sessionFactoryNameAlsoJndiName = sessionFactoryNameAlsoJndiName;
 	}
 
 	void setAutoCreateSchema(boolean b) {
 		autoCreateSchema = b;
 	}
 
 	void setAutoDropSchema(boolean b) {
 		autoDropSchema = b;
 	}
 
 	void setAutoUpdateSchema(boolean b) {
 		autoUpdateSchema = b;
 	}
 
 	void setMaximumFetchDepth(Integer i) {
 		maximumFetchDepth = i;
 	}
 
 	void setRegionFactory(RegionFactory regionFactory) {
 		this.regionFactory = regionFactory;
 	}
 
 	void setQueryCacheEnabled(boolean b) {
 		queryCacheEnabled = b;
 	}
 
 	void setCommentsEnabled(boolean commentsEnabled) {
 		this.commentsEnabled = commentsEnabled;
 	}
 
 	void setSecondLevelCacheEnabled(boolean secondLevelCacheEnabled) {
 		this.secondLevelCacheEnabled = secondLevelCacheEnabled;
 	}
 
 	void setCacheRegionPrefix(String cacheRegionPrefix) {
 		this.cacheRegionPrefix = cacheRegionPrefix;
 	}
 
 	void setQueryCacheFactory(QueryCacheFactory queryCacheFactory) {
 		this.queryCacheFactory = queryCacheFactory;
 	}
 
 	void setStatisticsEnabled(boolean statisticsEnabled) {
 		this.statisticsEnabled = statisticsEnabled;
 	}
 
 	void setJdbcBatchVersionedData(boolean jdbcBatchVersionedData) {
 		this.jdbcBatchVersionedData = jdbcBatchVersionedData;
 	}
 
 	void setFlushBeforeCompletionEnabled(boolean flushBeforeCompletionEnabled) {
 		this.flushBeforeCompletionEnabled = flushBeforeCompletionEnabled;
 	}
 
 	void setAutoCloseSessionEnabled(boolean autoCloseSessionEnabled) {
 		this.autoCloseSessionEnabled = autoCloseSessionEnabled;
 	}
 
 	void setConnectionReleaseMode(ConnectionReleaseMode connectionReleaseMode) {
 		this.connectionReleaseMode = connectionReleaseMode;
 	}
 
 	void setQueryTranslatorFactory(QueryTranslatorFactory queryTranslatorFactory) {
 		this.queryTranslatorFactory = queryTranslatorFactory;
 	}
 
 	void setWrapResultSetsEnabled(boolean wrapResultSetsEnabled) {
 		this.wrapResultSetsEnabled = wrapResultSetsEnabled;
 	}
 
 	void setOrderUpdatesEnabled(boolean orderUpdatesEnabled) {
 		this.orderUpdatesEnabled = orderUpdatesEnabled;
 	}
 
 	void setOrderInsertsEnabled(boolean orderInsertsEnabled) {
 		this.orderInsertsEnabled = orderInsertsEnabled;
 	}
 
 	void setStructuredCacheEntriesEnabled(boolean structuredCacheEntriesEnabled) {
 		this.structuredCacheEntriesEnabled = structuredCacheEntriesEnabled;
 	}
 
 	void setDefaultEntityMode(EntityMode defaultEntityMode) {
 		this.defaultEntityMode = defaultEntityMode;
 	}
 
 	void setAutoValidateSchema(boolean autoValidateSchema) {
 		this.autoValidateSchema = autoValidateSchema;
 	}
 
 	void setDataDefinitionImplicitCommit(boolean dataDefinitionImplicitCommit) {
 		this.dataDefinitionImplicitCommit = dataDefinitionImplicitCommit;
 	}
 
 	void setDataDefinitionInTransactionSupported(boolean dataDefinitionInTransactionSupported) {
 		this.dataDefinitionInTransactionSupported = dataDefinitionInTransactionSupported;
 	}
 
 	void setStrictJPAQLCompliance(boolean strictJPAQLCompliance) {
 		this.strictJPAQLCompliance = strictJPAQLCompliance;
 	}
 
 	void setNamedQueryStartupCheckingEnabled(boolean namedQueryStartupCheckingEnabled) {
 		this.namedQueryStartupCheckingEnabled = namedQueryStartupCheckingEnabled;
 	}
 
 	void setEntityTuplizerFactory(EntityTuplizerFactory entityTuplizerFactory) {
 		this.entityTuplizerFactory = entityTuplizerFactory;
 	}
 
 	public boolean isCheckNullability() {
 		return checkNullability;
 	}
 
 	public void setCheckNullability(boolean checkNullability) {
 		this.checkNullability = checkNullability;
 	}
 
 	//	void setComponentTuplizerFactory(ComponentTuplizerFactory componentTuplizerFactory) {
 //		this.componentTuplizerFactory = componentTuplizerFactory;
 //	}
 
 	//	public BytecodeProvider getBytecodeProvider() {
 //		return bytecodeProvider;
 //	}
 //
 //	void setBytecodeProvider(BytecodeProvider bytecodeProvider) {
 //		this.bytecodeProvider = bytecodeProvider;
 //	}
 
 
 	public JtaPlatform getJtaPlatform() {
 		return jtaPlatform;
 	}
 
 	void setJtaPlatform(JtaPlatform jtaPlatform) {
 		this.jtaPlatform = jtaPlatform;
 	}
 
 	public MultiTenancyStrategy getMultiTenancyStrategy() {
 		return multiTenancyStrategy;
 	}
 
 	void setMultiTenancyStrategy(MultiTenancyStrategy multiTenancyStrategy) {
 		this.multiTenancyStrategy = multiTenancyStrategy;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/SettingsFactory.java b/hibernate-core/src/main/java/org/hibernate/cfg/SettingsFactory.java
index d157ca406f..0eedef4f7e 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/SettingsFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/SettingsFactory.java
@@ -1,460 +1,460 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg;
 
 import java.io.Serializable;
 import java.util.Map;
 import java.util.Properties;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.EntityMode;
 import org.hibernate.HibernateException;
 import org.hibernate.MultiTenancyStrategy;
 import org.hibernate.cache.internal.NoCachingRegionFactory;
 import org.hibernate.cache.internal.RegionFactoryInitiator;
 import org.hibernate.cache.internal.StandardQueryCacheFactory;
 import org.hibernate.cache.spi.QueryCacheFactory;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.engine.jdbc.spi.ExtractedDatabaseMetaData;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.transaction.spi.TransactionFactory;
 import org.hibernate.hql.spi.QueryTranslatorFactory;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
-import org.hibernate.service.jdbc.connections.spi.MultiTenantConnectionProvider;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.tuple.entity.EntityTuplizerFactory;
 
 /**
  * Reads configuration properties and builds a {@link Settings} instance.
  *
  * @author Gavin King
  */
 public class SettingsFactory implements Serializable {
 
 	private static final long serialVersionUID = -1194386144994524825L;
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, SettingsFactory.class.getName());
 
 	public static final String DEF_CACHE_REG_FACTORY = NoCachingRegionFactory.class.getName();
 
 	public SettingsFactory() {
 	}
 
 	public Settings buildSettings(Properties props, ServiceRegistry serviceRegistry) {
 		final boolean debugEnabled =  LOG.isDebugEnabled();
 		final JdbcServices jdbcServices = serviceRegistry.getService( JdbcServices.class );
 		Settings settings = new Settings();
 
 		//SessionFactory name:
 
 		String sessionFactoryName = props.getProperty( Environment.SESSION_FACTORY_NAME );
 		settings.setSessionFactoryName( sessionFactoryName );
 		settings.setSessionFactoryNameAlsoJndiName(
 				ConfigurationHelper.getBoolean( AvailableSettings.SESSION_FACTORY_NAME_IS_JNDI, props, true )
 		);
 
 		//JDBC and connection settings:
 
 		//Interrogate JDBC metadata
 		ExtractedDatabaseMetaData meta = jdbcServices.getExtractedMetaDataSupport();
 
 		settings.setDataDefinitionImplicitCommit( meta.doesDataDefinitionCauseTransactionCommit() );
 		settings.setDataDefinitionInTransactionSupported( meta.supportsDataDefinitionInTransaction() );
 
 		//use dialect default properties
 		final Properties properties = new Properties();
 		properties.putAll( jdbcServices.getDialect().getDefaultProperties() );
 		properties.putAll( props );
 
 		// Transaction settings:
 		settings.setJtaPlatform( serviceRegistry.getService( JtaPlatform.class ) );
 
 		boolean flushBeforeCompletion = ConfigurationHelper.getBoolean(Environment.FLUSH_BEFORE_COMPLETION, properties);
 		if ( debugEnabled ) {
 			LOG.debugf( "Automatic flush during beforeCompletion(): %s", enabledDisabled(flushBeforeCompletion) );
 		}
 		settings.setFlushBeforeCompletionEnabled(flushBeforeCompletion);
 
 		boolean autoCloseSession = ConfigurationHelper.getBoolean(Environment.AUTO_CLOSE_SESSION, properties);
 		if ( debugEnabled ) {
 			LOG.debugf( "Automatic session close at end of transaction: %s", enabledDisabled(autoCloseSession) );
 		}
 		settings.setAutoCloseSessionEnabled(autoCloseSession);
 
 		//JDBC and connection settings:
 
 		int batchSize = ConfigurationHelper.getInt(Environment.STATEMENT_BATCH_SIZE, properties, 0);
 		if ( !meta.supportsBatchUpdates() ) {
 			batchSize = 0;
 		}
 		if ( batchSize > 0 && debugEnabled ) {
 			LOG.debugf( "JDBC batch size: %s", batchSize );
 		}
 		settings.setJdbcBatchSize(batchSize);
 
 		boolean jdbcBatchVersionedData = ConfigurationHelper.getBoolean(Environment.BATCH_VERSIONED_DATA, properties, false);
 		if ( batchSize > 0 && debugEnabled ) {
 			LOG.debugf( "JDBC batch updates for versioned data: %s", enabledDisabled(jdbcBatchVersionedData) );
 		}
 		settings.setJdbcBatchVersionedData(jdbcBatchVersionedData);
 
 		boolean useScrollableResultSets = ConfigurationHelper.getBoolean(
 				Environment.USE_SCROLLABLE_RESULTSET,
 				properties,
 				meta.supportsScrollableResults()
 		);
 		if ( debugEnabled ) {
 			LOG.debugf( "Scrollable result sets: %s", enabledDisabled(useScrollableResultSets) );
 		}
 		settings.setScrollableResultSetsEnabled(useScrollableResultSets);
 
 		boolean wrapResultSets = ConfigurationHelper.getBoolean(Environment.WRAP_RESULT_SETS, properties, false);
 		if ( debugEnabled ) {
 			LOG.debugf( "Wrap result sets: %s", enabledDisabled(wrapResultSets) );
 		}
 		settings.setWrapResultSetsEnabled(wrapResultSets);
 
 		boolean useGetGeneratedKeys = ConfigurationHelper.getBoolean(Environment.USE_GET_GENERATED_KEYS, properties, meta.supportsGetGeneratedKeys());
 		if ( debugEnabled ) {
 			LOG.debugf( "JDBC3 getGeneratedKeys(): %s", enabledDisabled(useGetGeneratedKeys) );
 		}
 		settings.setGetGeneratedKeysEnabled(useGetGeneratedKeys);
 
 		Integer statementFetchSize = ConfigurationHelper.getInteger(Environment.STATEMENT_FETCH_SIZE, properties);
 		if ( statementFetchSize != null && debugEnabled ) {
 			LOG.debugf( "JDBC result set fetch size: %s", statementFetchSize );
 		}
 		settings.setJdbcFetchSize(statementFetchSize);
 
 		MultiTenancyStrategy multiTenancyStrategy = MultiTenancyStrategy.determineMultiTenancyStrategy( properties );
 		if ( debugEnabled ) {
 			LOG.debugf( "multi-tenancy strategy : %s", multiTenancyStrategy );
 		}
 		settings.setMultiTenancyStrategy( multiTenancyStrategy );
 
 		String releaseModeName = ConfigurationHelper.getString( Environment.RELEASE_CONNECTIONS, properties, "auto" );
 		if ( debugEnabled ) {
 			LOG.debugf( "Connection release mode: %s", releaseModeName );
 		}
 		ConnectionReleaseMode releaseMode;
 		if ( "auto".equals(releaseModeName) ) {
 			releaseMode = serviceRegistry.getService( TransactionFactory.class ).getDefaultReleaseMode();
 		}
 		else {
 			releaseMode = ConnectionReleaseMode.parse( releaseModeName );
 			if ( releaseMode == ConnectionReleaseMode.AFTER_STATEMENT ) {
 				// we need to make sure the underlying JDBC connection access supports aggressive release...
 				boolean supportsAgrressiveRelease = multiTenancyStrategy.requiresMultiTenantConnectionProvider()
 						? serviceRegistry.getService( MultiTenantConnectionProvider.class ).supportsAggressiveRelease()
 						: serviceRegistry.getService( ConnectionProvider.class ).supportsAggressiveRelease();
 				if ( ! supportsAgrressiveRelease ) {
 					LOG.unsupportedAfterStatement();
 					releaseMode = ConnectionReleaseMode.AFTER_TRANSACTION;
 				}
 			}
 		}
 		settings.setConnectionReleaseMode( releaseMode );
 
 		//SQL Generation settings:
 
 		String defaultSchema = properties.getProperty( Environment.DEFAULT_SCHEMA );
 		String defaultCatalog = properties.getProperty( Environment.DEFAULT_CATALOG );
 		if ( defaultSchema != null && debugEnabled ) {
 			LOG.debugf( "Default schema: %s", defaultSchema );
 		}
 		if ( defaultCatalog != null && debugEnabled ) {
 			LOG.debugf( "Default catalog: %s", defaultCatalog );
 		}
 		settings.setDefaultSchemaName( defaultSchema );
 		settings.setDefaultCatalogName( defaultCatalog );
 
 		Integer maxFetchDepth = ConfigurationHelper.getInteger( Environment.MAX_FETCH_DEPTH, properties );
 		if ( maxFetchDepth != null ) {
 			LOG.debugf( "Maximum outer join fetch depth: %s", maxFetchDepth );
 		}
 		settings.setMaximumFetchDepth( maxFetchDepth );
 
 		int batchFetchSize = ConfigurationHelper.getInt(Environment.DEFAULT_BATCH_FETCH_SIZE, properties, 1);
 		if ( debugEnabled ) {
 			LOG.debugf( "Default batch fetch size: %s", batchFetchSize );
 		}
 		settings.setDefaultBatchFetchSize( batchFetchSize );
 
 		boolean comments = ConfigurationHelper.getBoolean( Environment.USE_SQL_COMMENTS, properties );
 		if ( debugEnabled ) {
 			LOG.debugf( "Generate SQL with comments: %s", enabledDisabled(comments) );
 		}
 		settings.setCommentsEnabled( comments );
 
 		boolean orderUpdates = ConfigurationHelper.getBoolean( Environment.ORDER_UPDATES, properties );
 		if ( debugEnabled ) {
 			LOG.debugf( "Order SQL updates by primary key: %s", enabledDisabled(orderUpdates) );
 		}
 		settings.setOrderUpdatesEnabled( orderUpdates );
 
 		boolean orderInserts = ConfigurationHelper.getBoolean(Environment.ORDER_INSERTS, properties);
 		if ( debugEnabled ) {
 			LOG.debugf( "Order SQL inserts for batching: %s", enabledDisabled(orderInserts) );
 		}
 		settings.setOrderInsertsEnabled( orderInserts );
 
 		//Query parser settings:
 
 		settings.setQueryTranslatorFactory( createQueryTranslatorFactory( properties, serviceRegistry ) );
 
 		Map querySubstitutions = ConfigurationHelper.toMap( Environment.QUERY_SUBSTITUTIONS, " ,=;:\n\t\r\f", properties );
 		if ( debugEnabled ) {
 			LOG.debugf( "Query language substitutions: %s", querySubstitutions );
 		}
 		settings.setQuerySubstitutions( querySubstitutions );
 
 		boolean jpaqlCompliance = ConfigurationHelper.getBoolean( Environment.JPAQL_STRICT_COMPLIANCE, properties, false );
 		if ( debugEnabled ) {
 			LOG.debugf( "JPA-QL strict compliance: %s", enabledDisabled(jpaqlCompliance) );
 		}
 		settings.setStrictJPAQLCompliance( jpaqlCompliance );
 
 		// Second-level / query cache:
 
 		boolean useSecondLevelCache = ConfigurationHelper.getBoolean( Environment.USE_SECOND_LEVEL_CACHE, properties, true );
 		if ( debugEnabled ) {
 			LOG.debugf( "Second-level cache: %s", enabledDisabled(useSecondLevelCache) );
 		}
 		settings.setSecondLevelCacheEnabled( useSecondLevelCache );
 
 		boolean useQueryCache = ConfigurationHelper.getBoolean(Environment.USE_QUERY_CACHE, properties);
 		if ( debugEnabled ) {
 			LOG.debugf( "Query cache: %s", enabledDisabled(useQueryCache) );
 		}
 		settings.setQueryCacheEnabled( useQueryCache );
 		if (useQueryCache) {
 			settings.setQueryCacheFactory( createQueryCacheFactory( properties, serviceRegistry ) );
 		}
 
 		// The cache provider is needed when we either have second-level cache enabled
 		// or query cache enabled.  Note that useSecondLevelCache is enabled by default
 		settings.setRegionFactory( createRegionFactory( properties, ( useSecondLevelCache || useQueryCache ), serviceRegistry ) );
 
 		boolean useMinimalPuts = ConfigurationHelper.getBoolean(
 				Environment.USE_MINIMAL_PUTS, properties, settings.getRegionFactory().isMinimalPutsEnabledByDefault()
 		);
 		if ( debugEnabled ) {
 			LOG.debugf( "Optimize cache for minimal puts: %s", enabledDisabled(useMinimalPuts) );
 		}
 		settings.setMinimalPutsEnabled( useMinimalPuts );
 
 		String prefix = properties.getProperty( Environment.CACHE_REGION_PREFIX );
 		if ( StringHelper.isEmpty(prefix) ) {
 			prefix=null;
 		}
 		if ( prefix != null && debugEnabled ) {
 			LOG.debugf( "Cache region prefix: %s", prefix );
 		}
 		settings.setCacheRegionPrefix( prefix );
 
 		boolean useStructuredCacheEntries = ConfigurationHelper.getBoolean( Environment.USE_STRUCTURED_CACHE, properties, false );
 		if ( debugEnabled ) {
 			LOG.debugf( "Structured second-level cache entries: %s", enabledDisabled(useStructuredCacheEntries) );
 		}
 		settings.setStructuredCacheEntriesEnabled( useStructuredCacheEntries );
 
 
 		//Statistics and logging:
 
 		boolean useStatistics = ConfigurationHelper.getBoolean( Environment.GENERATE_STATISTICS, properties );
 		if ( debugEnabled ) {
 			LOG.debugf( "Statistics: %s", enabledDisabled(useStatistics) );
 		}
 		settings.setStatisticsEnabled( useStatistics );
 
 		boolean useIdentifierRollback = ConfigurationHelper.getBoolean( Environment.USE_IDENTIFIER_ROLLBACK, properties );
 		if ( debugEnabled ) {
 			LOG.debugf( "Deleted entity synthetic identifier rollback: %s", enabledDisabled(useIdentifierRollback) );
 		}
 		settings.setIdentifierRollbackEnabled( useIdentifierRollback );
 
 		//Schema export:
 
 		String autoSchemaExport = properties.getProperty( Environment.HBM2DDL_AUTO );
 		if ( "validate".equals(autoSchemaExport) ) {
 			settings.setAutoValidateSchema( true );
 		}
 		if ( "update".equals(autoSchemaExport) ) {
 			settings.setAutoUpdateSchema( true );
 		}
 		if ( "create".equals(autoSchemaExport) ) {
 			settings.setAutoCreateSchema( true );
 		}
 		if ( "create-drop".equals( autoSchemaExport ) ) {
 			settings.setAutoCreateSchema( true );
 			settings.setAutoDropSchema( true );
 		}
 		settings.setImportFiles( properties.getProperty( Environment.HBM2DDL_IMPORT_FILES ) );
 
 		EntityMode defaultEntityMode = EntityMode.parse( properties.getProperty( Environment.DEFAULT_ENTITY_MODE ) );
 		if ( debugEnabled ) {
 			LOG.debugf( "Default entity-mode: %s", defaultEntityMode );
 		}
 		settings.setDefaultEntityMode( defaultEntityMode );
 
 		boolean namedQueryChecking = ConfigurationHelper.getBoolean( Environment.QUERY_STARTUP_CHECKING, properties, true );
 		if ( debugEnabled ) {
 			LOG.debugf( "Named query checking : %s", enabledDisabled(namedQueryChecking) );
 		}
 		settings.setNamedQueryStartupCheckingEnabled( namedQueryChecking );
 
 		boolean checkNullability = ConfigurationHelper.getBoolean(Environment.CHECK_NULLABILITY, properties, true);
 		if ( debugEnabled ) {
 			LOG.debugf( "Check Nullability in Core (should be disabled when Bean Validation is on): %s", enabledDisabled(checkNullability) );
 		}
 		settings.setCheckNullability(checkNullability);
 
 		// TODO: Does EntityTuplizerFactory really need to be configurable? revisit for HHH-6383
 		settings.setEntityTuplizerFactory( new EntityTuplizerFactory() );
 
 //		String provider = properties.getProperty( Environment.BYTECODE_PROVIDER );
 //		log.info( "Bytecode provider name : " + provider );
 //		BytecodeProvider bytecodeProvider = buildBytecodeProvider( provider );
 //		settings.setBytecodeProvider( bytecodeProvider );
 
 		return settings;
 
 	}
 
 //	protected BytecodeProvider buildBytecodeProvider(String providerName) {
 //		if ( "javassist".equals( providerName ) ) {
 //			return new org.hibernate.bytecode.internal.javassist.BytecodeProviderImpl();
 //		}
 //		else {
 //            LOG.debug("Using javassist as bytecode provider by default");
 //			return new org.hibernate.bytecode.internal.javassist.BytecodeProviderImpl();
 //		}
 //	}
 
 	private static String enabledDisabled(boolean value) {
 		return value ? "enabled" : "disabled";
 	}
 
 	protected QueryCacheFactory createQueryCacheFactory(Properties properties, ServiceRegistry serviceRegistry) {
 		String queryCacheFactoryClassName = ConfigurationHelper.getString(
 				Environment.QUERY_CACHE_FACTORY, properties, StandardQueryCacheFactory.class.getName()
 		);
 		LOG.debugf( "Query cache factory: %s", queryCacheFactoryClassName );
 		try {
 			return (QueryCacheFactory) serviceRegistry.getService( ClassLoaderService.class )
 					.classForName( queryCacheFactoryClassName )
 					.newInstance();
 		}
 		catch (Exception e) {
 			throw new HibernateException( "could not instantiate QueryCacheFactory: " + queryCacheFactoryClassName, e );
 		}
 	}
 
 	private static RegionFactory createRegionFactory(Properties properties, boolean cachingEnabled, ServiceRegistry serviceRegistry) {
 		String regionFactoryClassName = RegionFactoryInitiator.mapLegacyNames(
 				ConfigurationHelper.getString(
 						Environment.CACHE_REGION_FACTORY, properties, null
 				)
 		);
 		if ( regionFactoryClassName == null || !cachingEnabled) {
 			regionFactoryClassName = DEF_CACHE_REG_FACTORY;
 		}
 		LOG.debugf( "Cache region factory : %s", regionFactoryClassName );
 		try {
 			try {
 				return (RegionFactory) serviceRegistry.getService( ClassLoaderService.class )
 						.classForName( regionFactoryClassName )
 						.getConstructor( Properties.class )
 						.newInstance( properties );
 			}
 			catch ( NoSuchMethodException e ) {
 				// no constructor accepting Properties found, try no arg constructor
 				LOG.debugf(
 						"%s did not provide constructor accepting java.util.Properties; attempting no-arg constructor.",
 						regionFactoryClassName
 				);
 				return (RegionFactory) serviceRegistry.getService( ClassLoaderService.class )
 						.classForName( regionFactoryClassName )
 						.newInstance();
 			}
 		}
 		catch ( Exception e ) {
 			throw new HibernateException( "could not instantiate RegionFactory [" + regionFactoryClassName + "]", e );
 		}
 	}
 	//todo remove this once we move to new metamodel
 	public static RegionFactory createRegionFactory(Properties properties, boolean cachingEnabled) {
 		// todo : REMOVE!  THIS IS TOTALLY A TEMPORARY HACK FOR org.hibernate.cfg.AnnotationBinder which will be going away
 		String regionFactoryClassName = RegionFactoryInitiator.mapLegacyNames(
 				ConfigurationHelper.getString(
 						Environment.CACHE_REGION_FACTORY, properties, null
 				)
 		);
 		if ( regionFactoryClassName == null ) {
 			regionFactoryClassName = DEF_CACHE_REG_FACTORY;
 		}
 		LOG.debugf( "Cache region factory : %s", regionFactoryClassName );
 		try {
 			try {
 				return (RegionFactory) org.hibernate.internal.util.ReflectHelper.classForName( regionFactoryClassName )
 						.getConstructor( Properties.class )
 						.newInstance( properties );
 			}
 			catch ( NoSuchMethodException e ) {
 				// no constructor accepting Properties found, try no arg constructor
 				LOG.debugf(
 						"%s did not provide constructor accepting java.util.Properties; attempting no-arg constructor.",
 						regionFactoryClassName
 				);
 				return (RegionFactory) org.hibernate.internal.util.ReflectHelper.classForName( regionFactoryClassName )
 						.newInstance();
 			}
 		}
 		catch ( Exception e ) {
 			throw new HibernateException( "could not instantiate RegionFactory [" + regionFactoryClassName + "]", e );
 		}
 	}
 
 	protected QueryTranslatorFactory createQueryTranslatorFactory(Properties properties, ServiceRegistry serviceRegistry) {
 		String className = ConfigurationHelper.getString(
 				Environment.QUERY_TRANSLATOR, properties, "org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory"
 		);
 		LOG.debugf( "Query translator: %s", className );
 		try {
 			return (QueryTranslatorFactory) serviceRegistry.getService( ClassLoaderService.class )
 					.classForName( className )
 					.newInstance();
 		}
 		catch ( Exception e ) {
 			throw new HibernateException( "could not instantiate QueryTranslatorFactory: " + className, e );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationIntegrator.java b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationIntegrator.java
index 927e4d6f8f..8b55cda316 100644
--- a/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationIntegrator.java
+++ b/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationIntegrator.java
@@ -1,395 +1,395 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cfg.beanvalidation;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Properties;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * @author Steve Ebersole
  */
 public class BeanValidationIntegrator implements Integrator {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, BeanValidationIntegrator.class.getName());
 
 	public static final String APPLY_CONSTRAINTS = "hibernate.validator.apply_to_ddl";
 
 	public static final String BV_CHECK_CLASS = "javax.validation.Validation";
 
 	public static final String MODE_PROPERTY = "javax.persistence.validation.mode";
 
 	private static final String ACTIVATOR_CLASS = "org.hibernate.cfg.beanvalidation.TypeSafeActivator";
 	private static final String DDL_METHOD = "applyDDL";
 	private static final String ACTIVATE_METHOD = "activateBeanValidation";
 	private static final String VALIDATE_METHOD = "validateFactory";
 
 	public static void validateFactory(Object object) {
 		try {
 			final Class activatorClass = BeanValidationIntegrator.class.getClassLoader().loadClass( ACTIVATOR_CLASS );
 			try {
 				final Method validateMethod = activatorClass.getMethod( VALIDATE_METHOD, Object.class );
 				if ( ! validateMethod.isAccessible() ) {
 					validateMethod.setAccessible( true );
 				}
 				try {
 					validateMethod.invoke( null, object );
 				}
 				catch (InvocationTargetException e) {
 					if ( e.getTargetException() instanceof HibernateException ) {
 						throw (HibernateException) e.getTargetException();
 					}
 					throw new HibernateException( "Unable to check validity of passed ValidatorFactory", e );
 				}
 				catch (IllegalAccessException e) {
 					throw new HibernateException( "Unable to check validity of passed ValidatorFactory", e );
 				}
 			}
 			catch (HibernateException e) {
 				throw e;
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Could not locate method needed for ValidatorFactory validation", e );
 			}
 		}
 		catch (HibernateException e) {
 			throw e;
 		}
 		catch (Exception e) {
 			throw new HibernateException( "Could not locate TypeSafeActivator class", e );
 		}
 	}
 
 	@Override
 	public void integrate(
 			Configuration configuration,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		// determine requested validation modes.
 		final Set<ValidationMode> modes = ValidationMode.getModes( configuration.getProperties().get( MODE_PROPERTY ) );
 
 		final ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
         Dialect dialect = serviceRegistry.getService( JdbcServices.class ).getDialect();
 		// try to locate a BV class to see if it is available on the classpath
 		boolean isBeanValidationAvailable;
 		try {
 			classLoaderService.classForName( BV_CHECK_CLASS );
 			isBeanValidationAvailable = true;
 		}
 		catch ( Exception e ) {
 			isBeanValidationAvailable = false;
 		}
 
 		// locate the type safe activator class
 		final Class typeSafeActivatorClass = loadTypeSafeActivatorClass( serviceRegistry );
 
 		// todo : if this works out, probably better to simply alter TypeSafeActivator into a single method...
 		applyRelationalConstraints(
 				modes,
 				isBeanValidationAvailable,
 				typeSafeActivatorClass,
 				configuration,
                 dialect
 
 		);
 		applyHibernateListeners(
 				modes,
 				isBeanValidationAvailable,
 				typeSafeActivatorClass,
 				configuration,
 				sessionFactory,
 				serviceRegistry
 		);
 	}
 
 	/**
 	 * {@inheritDoc}
 	 *
 	 * @see org.hibernate.integrator.spi.Integrator#integrate(org.hibernate.metamodel.source.MetadataImplementor, org.hibernate.engine.spi.SessionFactoryImplementor, org.hibernate.service.spi.SessionFactoryServiceRegistry)
 	 */
 	@Override
 	public void integrate( MetadataImplementor metadata,
 	                       SessionFactoryImplementor sessionFactory,
 	                       SessionFactoryServiceRegistry serviceRegistry ) {
 //	    Properties props = sessionFactory.getProperties();
 //        final Set<ValidationMode> modes = ValidationMode.getModes(props.get(MODE_PROPERTY));
 //        final ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 //        // try to locate a BV class to see if it is available on the classpath
 //        boolean isBeanValidationAvailable;
 //        try {
 //            classLoaderService.classForName( BV_CHECK_CLASS );
 //            isBeanValidationAvailable = true;
 //        } catch (Exception error) {
 //            isBeanValidationAvailable = false;
 //        }
 //        // locate the type safe activator class
 //        final Class typeSafeActivatorClass = loadTypeSafeActivatorClass(serviceRegistry);
 //        // todo : if this works out, probably better to simply alter TypeSafeActivator into a single method...
 //        applyRelationalConstraints(modes, isBeanValidationAvailable, typeSafeActivatorClass, props, metadata);
 //        applyHibernateListeners(modes, isBeanValidationAvailable, typeSafeActivatorClass, sessionFactory, serviceRegistry);
 	}
 
 	private Class loadTypeSafeActivatorClass(SessionFactoryServiceRegistry serviceRegistry) {
 		try {
 			return serviceRegistry.getService( ClassLoaderService.class ).classForName( ACTIVATOR_CLASS );
 		}
 		catch (Exception e) {
 			return null;
 		}
 	}
 
 	private void applyRelationalConstraints(
 			Set<ValidationMode> modes,
 			boolean beanValidationAvailable,
 			Class typeSafeActivatorClass,
 			Configuration configuration,
             Dialect dialect) {
 		if ( ! ConfigurationHelper.getBoolean( APPLY_CONSTRAINTS, configuration.getProperties(), true ) ){
 			LOG.debug( "Skipping application of relational constraints from legacy Hibernate Validator" );
 			return;
 		}
 
 		if ( ! ( modes.contains( ValidationMode.DDL ) || modes.contains( ValidationMode.AUTO ) ) ) {
 			return;
 		}
 
 		if ( ! beanValidationAvailable ) {
 			if ( modes.contains( ValidationMode.DDL ) ) {
 				throw new HibernateException( "Bean Validation not available in the class path but required in " + MODE_PROPERTY );
 			}
 			else if (modes.contains( ValidationMode.AUTO ) ) {
 				//nothing to activate
 				return;
 			}
 		}
 
 		try {
 			Method applyDDLMethod = typeSafeActivatorClass.getMethod( DDL_METHOD, Collection.class, Properties.class, Dialect.class );
 			try {
 				applyDDLMethod.invoke(
 						null,
 						configuration.createMappings().getClasses().values(),
 						configuration.getProperties(),
                         dialect
 				);
 			}
 			catch (HibernateException e) {
 				throw e;
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Error applying BeanValidation relational constraints", e );
 			}
 		}
 		catch (HibernateException e) {
 			throw e;
 		}
 		catch (Exception e) {
 			throw new HibernateException( "Unable to locate TypeSafeActivator#applyDDL method", e );
 		}
 	}
 
 //    private void applyRelationalConstraints( Set<ValidationMode> modes,
 //                                             boolean beanValidationAvailable,
 //                                             Class typeSafeActivatorClass,
 //                                             Properties properties,
 //                                             MetadataImplementor metadata ) {
 //        if (!ConfigurationHelper.getBoolean(APPLY_CONSTRAINTS, properties, true)){
 //            LOG.debug("Skipping application of relational constraints from legacy Hibernate Validator");
 //            return;
 //        }
 //        if (!(modes.contains(ValidationMode.DDL) || modes.contains(ValidationMode.AUTO))) return;
 //        if (!beanValidationAvailable) {
 //            if (modes.contains(ValidationMode.DDL))
 //                throw new HibernateException("Bean Validation not available in the class path but required in " + MODE_PROPERTY);
 //            if(modes.contains(ValidationMode.AUTO)) return; //nothing to activate
 //        }
 //        try {
 //            Method applyDDLMethod = typeSafeActivatorClass.getMethod(DDL_METHOD, Iterable.class, Properties.class, ClassLoaderService.class);
 //            try {
 //                applyDDLMethod.invoke(null, metadata.getEntityBindings(), properties,
 //                                      metadata.getServiceRegistry().getService(ClassLoaderService.class));
 //            } catch (HibernateException error) {
 //                throw error;
 //            } catch (Exception error) {
 //                throw new HibernateException("Error applying BeanValidation relational constraints", error);
 //            }
 //        } catch (HibernateException error) {
 //            throw error;
 //        } catch (Exception error) {
 //            throw new HibernateException("Unable to locate TypeSafeActivator#applyDDL method", error);
 //        }
 //    }
 
 	private void applyHibernateListeners(
 			Set<ValidationMode> modes,
 			boolean beanValidationAvailable,
 			Class typeSafeActivatorClass,
 			Configuration configuration,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		// de-activate not-null tracking at the core level when Bean Validation is present unless the user explicitly
 		// asks for it
 		if ( configuration.getProperty( Environment.CHECK_NULLABILITY ) == null ) {
 			sessionFactory.getSettings().setCheckNullability( false );
 		}
 
 		if ( ! ( modes.contains( ValidationMode.CALLBACK ) || modes.contains( ValidationMode.AUTO ) ) ) {
 			return;
 		}
 
 		if ( ! beanValidationAvailable ) {
 			if ( modes.contains( ValidationMode.CALLBACK ) ) {
 				throw new HibernateException( "Bean Validation not available in the class path but required in " + MODE_PROPERTY );
 			}
 			else if (modes.contains( ValidationMode.AUTO ) ) {
 				//nothing to activate
 				return;
 			}
 		}
 
 		try {
 			Method activateMethod = typeSafeActivatorClass.getMethod( ACTIVATE_METHOD, EventListenerRegistry.class, Configuration.class );
 			try {
 				activateMethod.invoke(
 						null,
 						serviceRegistry.getService( EventListenerRegistry.class ),
 						configuration
 				);
 			}
 			catch (HibernateException e) {
 				throw e;
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Error applying BeanValidation relational constraints", e );
 			}
 		}
 		catch (HibernateException e) {
 			throw e;
 		}
 		catch (Exception e) {
 			throw new HibernateException( "Unable to locate TypeSafeActivator#applyDDL method", e );
 		}
 	}
 
 //    private void applyHibernateListeners( Set<ValidationMode> modes,
 //                                          boolean beanValidationAvailable,
 //                                          Class typeSafeActivatorClass,
 //                                          SessionFactoryImplementor sessionFactory,
 //                                          SessionFactoryServiceRegistry serviceRegistry ) {
 //        // de-activate not-null tracking at the core level when Bean Validation is present unless the user explicitly
 //        // asks for it
 //        if (sessionFactory.getProperties().getProperty(Environment.CHECK_NULLABILITY) == null)
 //            sessionFactory.getSettings().setCheckNullability( false );
 //        if (!(modes.contains( ValidationMode.CALLBACK) || modes.contains(ValidationMode.AUTO))) return;
 //        if (!beanValidationAvailable) {
 //            if (modes.contains(ValidationMode.CALLBACK))
 //                throw new HibernateException("Bean Validation not available in the class path but required in " + MODE_PROPERTY);
 //            if (modes.contains(ValidationMode.AUTO)) return; //nothing to activate
 //        }
 //        try {
 //            Method activateMethod = typeSafeActivatorClass.getMethod(ACTIVATE_METHOD, EventListenerRegistry.class);
 //            try {
 //                activateMethod.invoke(null, serviceRegistry.getService(EventListenerRegistry.class));
 //            }
 //            catch (HibernateException e) {
 //                throw e;
 //            }
 //            catch (Exception e) {
 //                throw new HibernateException( "Error applying BeanValidation relational constraints", e );
 //            }
 //        }
 //        catch (HibernateException e) {
 //            throw e;
 //        }
 //        catch (Exception e) {
 //            throw new HibernateException( "Unable to locate TypeSafeActivator#applyDDL method", e );
 //        }
 //    }
 
 	// Because the javax validation classes might not be on the runtime classpath
 	private static enum ValidationMode {
 		AUTO,
 		CALLBACK,
 		NONE,
 		DDL;
 
 		public static Set<ValidationMode> getModes(Object modeProperty) {
 			Set<ValidationMode> modes = new HashSet<ValidationMode>(3);
 			if (modeProperty == null) {
 				modes.add(ValidationMode.AUTO);
 			}
 			else {
 				final String[] modesInString = modeProperty.toString().split( "," );
 				for ( String modeInString : modesInString ) {
 					modes.add( getMode(modeInString) );
 				}
 			}
 			if ( modes.size() > 1 && ( modes.contains( ValidationMode.AUTO ) || modes.contains( ValidationMode.NONE ) ) ) {
 				StringBuilder message = new StringBuilder( "Incompatible validation modes mixed: " );
 				for (ValidationMode mode : modes) {
 					message.append( mode ).append( ", " );
 				}
 				throw new HibernateException( message.substring( 0, message.length() - 2 ) );
 			}
 			return modes;
 		}
 
 		private static ValidationMode getMode(String modeProperty) {
 			if (modeProperty == null || modeProperty.length() == 0) {
 				return AUTO;
 			}
 			else {
 				try {
 					return valueOf( modeProperty.trim().toUpperCase() );
 				}
 				catch ( IllegalArgumentException e ) {
 					throw new HibernateException( "Unknown validation mode in " + MODE_PROPERTY + ": " + modeProperty );
 				}
 			}
 		}
 	}
 
 	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 		// nothing to do here afaik
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/context/internal/JTASessionContext.java b/hibernate-core/src/main/java/org/hibernate/context/internal/JTASessionContext.java
index 5c4397bb34..f33a7e2502 100644
--- a/hibernate-core/src/main/java/org/hibernate/context/internal/JTASessionContext.java
+++ b/hibernate-core/src/main/java/org/hibernate/context/internal/JTASessionContext.java
@@ -1,212 +1,212 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.context.internal;
 
 import java.util.Hashtable;
 import java.util.Map;
 import javax.transaction.Synchronization;
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.HibernateException;
 import org.hibernate.Session;
 import org.hibernate.context.spi.AbstractCurrentSessionContext;
 import org.hibernate.context.spi.CurrentSessionContext;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 
 /**
  * An implementation of {@link CurrentSessionContext} which scopes the notion
  * of a current session to a JTA transaction.  Because JTA gives us a nice
  * tie-in to clean up after ourselves, this implementation will generate
  * Sessions as needed provided a JTA transaction is in effect.  If a session
  * is not already associated with the current JTA transaction at the time
  * {@link #currentSession()} is called, a new session will be opened and it
  * will be associated with that JTA transaction.
  * <p/>
  * Note that the sessions returned from this method are automatically configured with
  * both the {@link org.hibernate.cfg.Environment#FLUSH_BEFORE_COMPLETION auto-flush} and
  * {@link org.hibernate.cfg.Environment#AUTO_CLOSE_SESSION auto-close} attributes set to
  * true, meaning that the Session will be automatically flushed and closed
  * as part of the lifecycle for the JTA transaction to which it is associated.
  * Additionally, it will also be configured to aggressively release JDBC
  * connections after each statement is executed.  These settings are governed
  * by the {@link #isAutoFlushEnabled()}, {@link #isAutoCloseEnabled()}, and
  * {@link #getConnectionReleaseMode()} methods; these are provided (along with
  * the {@link #buildOrObtainSession()} method) for easier subclassing for custom
  * JTA-based session tracking logic (like maybe long-session semantics).
  *
  * @author Steve Ebersole
  */
 public class JTASessionContext extends AbstractCurrentSessionContext {
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, JTASessionContext.class.getName());
 
 	private transient Map currentSessionMap = new Hashtable();
 
 	public JTASessionContext(SessionFactoryImplementor factory) {
 		super( factory );
 	}
 
 	@Override
 	public Session currentSession() throws HibernateException {
 		final JtaPlatform jtaPlatform = factory().getServiceRegistry().getService( JtaPlatform.class );
 		final TransactionManager transactionManager = jtaPlatform.retrieveTransactionManager();
 		if ( transactionManager == null ) {
 			throw new HibernateException( "No TransactionManagerLookup specified" );
 		}
 
 		Transaction txn;
 		try {
 			txn = transactionManager.getTransaction();
 			if ( txn == null ) {
 				throw new HibernateException( "Unable to locate current JTA transaction" );
 			}
 			if ( !JtaStatusHelper.isActive( txn.getStatus() ) ) {
 				// We could register the session against the transaction even though it is
 				// not started, but we'd have no guarantee of ever getting the map
 				// entries cleaned up (aside from spawning threads).
 				throw new HibernateException( "Current transaction is not in progress" );
 			}
 		}
 		catch ( HibernateException e ) {
 			throw e;
 		}
 		catch ( Throwable t ) {
 			throw new HibernateException( "Problem locating/validating JTA transaction", t );
 		}
 
 		final Object txnIdentifier = jtaPlatform.getTransactionIdentifier( txn );
 
 		Session currentSession = ( Session ) currentSessionMap.get( txnIdentifier );
 
 		if ( currentSession == null ) {
 			currentSession = buildOrObtainSession();
 
 			try {
 				txn.registerSynchronization( buildCleanupSynch( txnIdentifier ) );
 			}
 			catch ( Throwable t ) {
 				try {
 					currentSession.close();
 				}
 				catch ( Throwable ignore ) {
 					LOG.debug( "Unable to release generated current-session on failed synch registration", ignore );
 				}
 				throw new HibernateException( "Unable to register cleanup Synchronization with TransactionManager" );
 			}
 
 			currentSessionMap.put( txnIdentifier, currentSession );
 		}
 		else {
 			validateExistingSession( currentSession );
 		}
 
 		return currentSession;
 	}
 
 	/**
 	 * Builds a {@link CleanupSynch} capable of cleaning up the the current session map as an after transaction
 	 * callback.
 	 *
 	 * @param transactionIdentifier The transaction identifier under which the current session is registered.
 	 * @return The cleanup synch.
 	 */
 	private CleanupSynch buildCleanupSynch(Object transactionIdentifier) {
 		return new CleanupSynch( transactionIdentifier, this );
 	}
 
 	/**
 	 * Strictly provided for subclassing purposes; specifically to allow long-session
 	 * support.
 	 * <p/>
 	 * This implementation always just opens a new session.
 	 *
 	 * @return the built or (re)obtained session.
 	 */
 	protected Session buildOrObtainSession() {
 		return baseSessionBuilder()
 				.autoClose( isAutoCloseEnabled() )
 				.connectionReleaseMode( getConnectionReleaseMode() )
 				.flushBeforeCompletion( isAutoFlushEnabled() )
 				.openSession();
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns true.
 	 *
 	 * @return Whether or not the the session should be closed by transaction completion.
 	 */
 	protected boolean isAutoCloseEnabled() {
 		return true;
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns true.
 	 *
 	 * @return Whether or not the the session should be flushed prior transaction completion.
 	 */
 	protected boolean isAutoFlushEnabled() {
 		return true;
 	}
 
 	/**
 	 * Mainly for subclass usage.  This impl always returns after_statement.
 	 *
 	 * @return The connection release mode for any built sessions.
 	 */
 	protected ConnectionReleaseMode getConnectionReleaseMode() {
 		return ConnectionReleaseMode.AFTER_STATEMENT;
 	}
 
 	/**
 	 * JTA transaction synch used for cleanup of the internal session map.
 	 */
 	protected static class CleanupSynch implements Synchronization {
 		private Object transactionIdentifier;
 		private JTASessionContext context;
 
 		public CleanupSynch(Object transactionIdentifier, JTASessionContext context) {
 			this.transactionIdentifier = transactionIdentifier;
 			this.context = context;
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public void beforeCompletion() {
 		}
 
 		/**
 		 * {@inheritDoc}
 		 */
 		public void afterCompletion(int i) {
 			context.currentSessionMap.remove( transactionIdentifier );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/config/internal/ConfigurationServiceImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/config/internal/ConfigurationServiceImpl.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/service/config/internal/ConfigurationServiceImpl.java
rename to hibernate-core/src/main/java/org/hibernate/engine/config/internal/ConfigurationServiceImpl.java
index 4c03d5f844..5118c5e782 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/config/internal/ConfigurationServiceImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/config/internal/ConfigurationServiceImpl.java
@@ -1,118 +1,118 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.config.internal;
+package org.hibernate.engine.config.internal;
 
 import java.util.Collections;
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.classloading.spi.ClassLoadingException;
-import org.hibernate.service.config.spi.ConfigurationService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.engine.config.spi.ConfigurationService;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * @author Steve Ebersole
  */
 public class ConfigurationServiceImpl implements ConfigurationService, ServiceRegistryAwareService {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			ConfigurationServiceImpl.class.getName()
 	);
 	private final Map settings;
 	private ServiceRegistryImplementor serviceRegistry;
 
 	@SuppressWarnings( "unchecked" )
 	public ConfigurationServiceImpl(Map settings) {
 		this.settings = Collections.unmodifiableMap( settings );
 	}
 
 	@Override
 	public Map getSettings() {
 		return settings;
 	}
 
 	@Override
 	public void injectServices(ServiceRegistryImplementor serviceRegistry) {
 		this.serviceRegistry = serviceRegistry;
 	}
 
 	@Override
 	public <T> T getSetting(String name, Converter<T> converter) {
 		return getSetting( name, converter, null );
 	}
 
 	@Override
 	public <T> T getSetting(String name, Converter<T> converter, T defaultValue) {
 		final Object value = settings.get( name );
 		if ( value == null ) {
 			return defaultValue;
 		}
 
 		return converter.convert( value );
 	}
 	@Override
 	public <T> T getSetting(String name, Class<T> expected, T defaultValue) {
 		Object value = settings.get( name );
 		T target = cast( expected, value );
 		return target !=null ? target : defaultValue;
 	}
 	@Override
 	public <T> T cast(Class<T> expected, Object candidate){
 		if(candidate == null) return null;
 		if ( expected.isInstance( candidate ) ) {
 			return (T) candidate;
 		}
 		Class<T> target;
 		if ( Class.class.isInstance( candidate ) ) {
 			target = Class.class.cast( candidate );
 		}
 		else {
 			try {
 				target = serviceRegistry.getService( ClassLoaderService.class ).classForName( candidate.toString() );
 			}
 			catch ( ClassLoadingException e ) {
 				LOG.debugf( "Unable to locate %s implementation class %s", expected.getName(), candidate.toString() );
 				target = null;
 			}
 		}
 		if ( target != null ) {
 			try {
 				return target.newInstance();
 			}
 			catch ( Exception e ) {
 				LOG.debugf(
 						"Unable to instantiate %s class %s", expected.getName(),
 						target.getName()
 				);
 			}
 		}
 		return null;
 	}
 
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/config/internal/ConfigurationServiceInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/config/internal/ConfigurationServiceInitiator.java
similarity index 85%
rename from hibernate-core/src/main/java/org/hibernate/service/config/internal/ConfigurationServiceInitiator.java
rename to hibernate-core/src/main/java/org/hibernate/engine/config/internal/ConfigurationServiceInitiator.java
index 610734ca8f..ff382aeb87 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/config/internal/ConfigurationServiceInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/config/internal/ConfigurationServiceInitiator.java
@@ -1,46 +1,46 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.config.internal;
+package org.hibernate.engine.config.internal;
 
 import java.util.Map;
 
-import org.hibernate.service.config.spi.ConfigurationService;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.StandardServiceInitiator;
+import org.hibernate.engine.config.spi.ConfigurationService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * @author Steve Ebersole
  */
-public class ConfigurationServiceInitiator implements BasicServiceInitiator<ConfigurationService> {
+public class ConfigurationServiceInitiator implements StandardServiceInitiator<ConfigurationService> {
 	public static final ConfigurationServiceInitiator INSTANCE = new ConfigurationServiceInitiator();
 
 	public ConfigurationService initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		return new ConfigurationServiceImpl( configurationValues );
 	}
 
 	@Override
 	public Class<ConfigurationService> getServiceInitiated() {
 		return ConfigurationService.class;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/config/spi/ConfigurationService.java b/hibernate-core/src/main/java/org/hibernate/engine/config/spi/ConfigurationService.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/service/config/spi/ConfigurationService.java
rename to hibernate-core/src/main/java/org/hibernate/engine/config/spi/ConfigurationService.java
index 6f8381f604..de5a4fb955 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/config/spi/ConfigurationService.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/config/spi/ConfigurationService.java
@@ -1,53 +1,53 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.config.spi;
+package org.hibernate.engine.config.spi;
 
 import java.util.Map;
 
 import org.hibernate.service.Service;
 
 /**
  * Provides access to the initial user-provided configuration values
  *
  * @author Steve Ebersole
  */
 public interface ConfigurationService extends Service {
 	public Map getSettings();
 
 	public <T> T getSetting(String name, Converter<T> converter);
 	public <T> T getSetting(String name, Converter<T> converter, T defaultValue);
 	public <T> T getSetting(String name, Class<T> expected, T defaultValue);
 
 	/**
 	 * Cast <tt>candidate</tt> to the instance of <tt>expected</tt> type.
 	 *
 	 * @param expected The type of instance expected to return.
 	 * @param candidate The candidate object to be casted.
 	 * @return The instance of expected type or null if this cast fail.
 	 */
 	public <T> T cast(Class<T> expected, Object candidate);
 	public static interface Converter<T> {
 		public T convert(Object value);
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchBuilderInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchBuilderInitiator.java
index fda0204233..374a51edd3 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchBuilderInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/batch/internal/BatchBuilderInitiator.java
@@ -1,71 +1,71 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.batch.internal;
 
 import java.util.Map;
 
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.jdbc.batch.spi.BatchBuilder;
 import org.hibernate.internal.util.config.ConfigurationHelper;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.service.spi.ServiceException;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * Initiator for the {@link BatchBuilder} service
  *
  * @author Steve Ebersole
  */
-public class BatchBuilderInitiator implements BasicServiceInitiator<BatchBuilder> {
+public class BatchBuilderInitiator implements StandardServiceInitiator<BatchBuilder> {
 	public static final BatchBuilderInitiator INSTANCE = new BatchBuilderInitiator();
 	public static final String BUILDER = "hibernate.jdbc.batch.builder";
 
 	@Override
 	public Class<BatchBuilder> getServiceInitiated() {
 		return BatchBuilder.class;
 	}
 
 	@Override
 	public BatchBuilder initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		final Object builder = configurationValues.get( BUILDER );
 		if ( builder == null ) {
 			return new BatchBuilderImpl(
 					ConfigurationHelper.getInt( Environment.STATEMENT_BATCH_SIZE, configurationValues, 1 )
 			);
 		}
 
 		if ( BatchBuilder.class.isInstance( builder ) ) {
 			return (BatchBuilder) builder;
 		}
 
 		final String builderClassName = builder.toString();
 		try {
 			return (BatchBuilder) registry.getService( ClassLoaderService.class ).classForName( builderClassName ).newInstance();
 		}
 		catch (Exception e) {
 			throw new ServiceException( "Could not build explicit BatchBuilder [" + builderClassName + "]", e );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/ConnectionProviderInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/ConnectionProviderInitiator.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/ConnectionProviderInitiator.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/ConnectionProviderInitiator.java
index fc0fc667d5..cde05919ce 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/ConnectionProviderInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/ConnectionProviderInitiator.java
@@ -1,286 +1,286 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.connections.internal;
+package org.hibernate.engine.jdbc.connections.internal;
 
 import java.beans.BeanInfo;
 import java.beans.PropertyDescriptor;
 import java.lang.reflect.Method;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MultiTenancyStrategy;
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Environment;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.beans.BeanInfoHelper;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * Instantiates and configures an appropriate {@link ConnectionProvider}.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
-public class ConnectionProviderInitiator implements BasicServiceInitiator<ConnectionProvider> {
+public class ConnectionProviderInitiator implements StandardServiceInitiator<ConnectionProvider> {
 	public static final ConnectionProviderInitiator INSTANCE = new ConnectionProviderInitiator();
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        ConnectionProviderInitiator.class.getName());
 	public static final String C3P0_PROVIDER_CLASS_NAME =
 			"org.hibernate.service.jdbc.connections.internal.C3P0ConnectionProvider";
 
 	public static final String PROXOOL_PROVIDER_CLASS_NAME =
 			"org.hibernate.service.jdbc.connections.internal.ProxoolConnectionProvider";
 
 	public static final String INJECTION_DATA = "hibernate.connection_provider.injection_data";
 
 	// mapping from legacy connection provider name to actual
 	// connection provider that will be used
 	private static final Map<String,String> LEGACY_CONNECTION_PROVIDER_MAPPING;
 
 	static {
 		LEGACY_CONNECTION_PROVIDER_MAPPING = new HashMap<String,String>( 5 );
 
 		LEGACY_CONNECTION_PROVIDER_MAPPING.put(
 				"org.hibernate.connection.DatasourceConnectionProvider",
 				DatasourceConnectionProviderImpl.class.getName()
 		);
 		LEGACY_CONNECTION_PROVIDER_MAPPING.put(
 				"org.hibernate.connection.DriverManagerConnectionProvider",
 				DriverManagerConnectionProviderImpl.class.getName()
 		);
 		LEGACY_CONNECTION_PROVIDER_MAPPING.put(
 				"org.hibernate.connection.UserSuppliedConnectionProvider",
 				UserSuppliedConnectionProviderImpl.class.getName()
 		);
 		LEGACY_CONNECTION_PROVIDER_MAPPING.put(
 				"org.hibernate.connection.C3P0ConnectionProvider",
 				C3P0_PROVIDER_CLASS_NAME
 		);
 		LEGACY_CONNECTION_PROVIDER_MAPPING.put(
 				"org.hibernate.connection.ProxoolConnectionProvider",
 				PROXOOL_PROVIDER_CLASS_NAME
 		);
 	}
 
 	@Override
 	public Class<ConnectionProvider> getServiceInitiated() {
 		return ConnectionProvider.class;
 	}
 
 	@Override
 	public ConnectionProvider initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		final MultiTenancyStrategy strategy = MultiTenancyStrategy.determineMultiTenancyStrategy(  configurationValues );
 		if ( strategy == MultiTenancyStrategy.DATABASE || strategy == MultiTenancyStrategy.SCHEMA ) {
 			// nothing to do, but given the separate hierarchies have to handle this here.
 			return null;
 		}
 
 		final ClassLoaderService classLoaderService = registry.getService( ClassLoaderService.class );
 
 		ConnectionProvider connectionProvider = null;
 		String providerClassName = getConfiguredConnectionProviderName( configurationValues );
 		if ( providerClassName != null ) {
 			connectionProvider = instantiateExplicitConnectionProvider( providerClassName, classLoaderService );
 		}
 		else if ( configurationValues.get( Environment.DATASOURCE ) != null ) {
 			connectionProvider = new DatasourceConnectionProviderImpl();
 		}
 
 		if ( connectionProvider == null ) {
 			if ( c3p0ConfigDefined( configurationValues ) && c3p0ProviderPresent( classLoaderService ) ) {
 				connectionProvider = instantiateExplicitConnectionProvider( C3P0_PROVIDER_CLASS_NAME,
 						classLoaderService
 				);
 			}
 		}
 
 		if ( connectionProvider == null ) {
 			if ( proxoolConfigDefined( configurationValues ) && proxoolProviderPresent( classLoaderService ) ) {
 				connectionProvider = instantiateExplicitConnectionProvider( PROXOOL_PROVIDER_CLASS_NAME,
 						classLoaderService
 				);
 			}
 		}
 
 		if ( connectionProvider == null ) {
 			if ( configurationValues.get( Environment.URL ) != null ) {
 				connectionProvider = new DriverManagerConnectionProviderImpl();
 			}
 		}
 
 		if ( connectionProvider == null ) {
             LOG.noAppropriateConnectionProvider();
 			connectionProvider = new UserSuppliedConnectionProviderImpl();
 		}
 
 
 		final Map injectionData = (Map) configurationValues.get( INJECTION_DATA );
 		if ( injectionData != null && injectionData.size() > 0 ) {
 			final ConnectionProvider theConnectionProvider = connectionProvider;
 			new BeanInfoHelper( connectionProvider.getClass() ).applyToBeanInfo(
 					connectionProvider,
 					new BeanInfoHelper.BeanInfoDelegate() {
 						public void processBeanInfo(BeanInfo beanInfo) throws Exception {
 							PropertyDescriptor[] descritors = beanInfo.getPropertyDescriptors();
 							for ( int i = 0, size = descritors.length; i < size; i++ ) {
 								String propertyName = descritors[i].getName();
 								if ( injectionData.containsKey( propertyName ) ) {
 									Method method = descritors[i].getWriteMethod();
 									method.invoke(
 											theConnectionProvider,
 											injectionData.get( propertyName )
 									);
 								}
 							}
 						}
 					}
 			);
 		}
 
 		return connectionProvider;
 	}
 
 	private String getConfiguredConnectionProviderName( Map configurationValues ) {
 		String providerClassName = ( String ) configurationValues.get( Environment.CONNECTION_PROVIDER );
 		if ( LEGACY_CONNECTION_PROVIDER_MAPPING.containsKey( providerClassName ) ) {
 			String actualProviderClassName = LEGACY_CONNECTION_PROVIDER_MAPPING.get( providerClassName );
             LOG.providerClassDeprecated(providerClassName, actualProviderClassName);
 			providerClassName = actualProviderClassName;
 		}
 		return providerClassName;
 	}
 
 	private ConnectionProvider instantiateExplicitConnectionProvider(
 			String providerClassName,
 			ClassLoaderService classLoaderService) {
 		try {
             LOG.instantiatingExplicitConnectionProvider( providerClassName );
 			return (ConnectionProvider) classLoaderService.classForName( providerClassName ).newInstance();
 		}
 		catch ( Exception e ) {
 			throw new HibernateException( "Could not instantiate connection provider [" + providerClassName + "]", e );
 		}
 	}
 
 	private boolean c3p0ProviderPresent(ClassLoaderService classLoaderService) {
 		try {
 			classLoaderService.classForName( C3P0_PROVIDER_CLASS_NAME );
 		}
 		catch ( Exception e ) {
             LOG.c3p0ProviderClassNotFound(C3P0_PROVIDER_CLASS_NAME);
 			return false;
 		}
 		return true;
 	}
 
 	private static boolean c3p0ConfigDefined(Map configValues) {
 		for ( Object key : configValues.keySet() ) {
 			if ( String.class.isInstance( key )
 					&& ( (String) key ).startsWith( AvailableSettings.C3P0_CONFIG_PREFIX ) ) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	private boolean proxoolProviderPresent(ClassLoaderService classLoaderService) {
 		try {
 			classLoaderService.classForName( PROXOOL_PROVIDER_CLASS_NAME );
 		}
 		catch ( Exception e ) {
             LOG.proxoolProviderClassNotFound(PROXOOL_PROVIDER_CLASS_NAME);
 			return false;
 		}
 		return true;
 	}
 
 	private static boolean proxoolConfigDefined(Map configValues) {
 		for ( Object key : configValues.keySet() ) {
 			if ( String.class.isInstance( key )
 					&& ( (String) key ).startsWith( AvailableSettings.PROXOOL_CONFIG_PREFIX ) ) {
 				return true;
 			}
 		}
 		return false;
 	}
 
 	/**
 	 * Build the connection properties capable of being passed to the {@link java.sql.DriverManager#getConnection}
 	 * forms taking {@link Properties} argument.  We seek out all keys in the passed map which start with
 	 * {@code hibernate.connection.}, using them to create a new {@link Properties} instance.  The keys in this
 	 * new {@link Properties} have the {@code hibernate.connection.} prefix trimmed.
 	 *
 	 * @param properties The map from which to build the connection specific properties.
 	 *
 	 * @return The connection properties.
 	 */
 	public static Properties getConnectionProperties(Map<?,?> properties) {
 		Properties result = new Properties();
 		for ( Map.Entry entry : properties.entrySet() ) {
 			if ( ! ( String.class.isInstance( entry.getKey() ) ) || ! String.class.isInstance( entry.getValue() ) ) {
 				continue;
 			}
 			final String key = (String) entry.getKey();
 			final String value = (String) entry.getValue();
 			if ( key.startsWith( Environment.CONNECTION_PREFIX ) ) {
 				if ( SPECIAL_PROPERTIES.contains( key ) ) {
 					if ( Environment.USER.equals( key ) ) {
 						result.setProperty( "user", value );
 					}
 				}
 				else {
 					result.setProperty(
 							key.substring( Environment.CONNECTION_PREFIX.length() + 1 ),
 							value
 					);
 				}
 			}
 		}
 		return result;
 	}
 
 	private static final Set<String> SPECIAL_PROPERTIES;
 
 	static {
 		SPECIAL_PROPERTIES = new HashSet<String>();
 		SPECIAL_PROPERTIES.add( Environment.DATASOURCE );
 		SPECIAL_PROPERTIES.add( Environment.URL );
 		SPECIAL_PROPERTIES.add( Environment.CONNECTION_PROVIDER );
 		SPECIAL_PROPERTIES.add( Environment.POOL_SIZE );
 		SPECIAL_PROPERTIES.add( Environment.ISOLATION );
 		SPECIAL_PROPERTIES.add( Environment.DRIVER );
 		SPECIAL_PROPERTIES.add( Environment.USER );
 
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/DatasourceConnectionProviderImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/DatasourceConnectionProviderImpl.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/DatasourceConnectionProviderImpl.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/DatasourceConnectionProviderImpl.java
index 98ba729b6a..71b6e7f10c 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/DatasourceConnectionProviderImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/DatasourceConnectionProviderImpl.java
@@ -1,157 +1,157 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.connections.internal;
+package org.hibernate.engine.jdbc.connections.internal;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.Map;
 import javax.sql.DataSource;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.Environment;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.UnknownUnwrapTypeException;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
-import org.hibernate.service.jndi.spi.JndiService;
+import org.hibernate.engine.jndi.spi.JndiService;
 import org.hibernate.service.spi.Configurable;
 import org.hibernate.service.spi.InjectService;
 import org.hibernate.service.spi.Stoppable;
 
 /**
- * A {@link ConnectionProvider} that manages connections from an underlying {@link DataSource}.
+ * A {@link org.hibernate.engine.jdbc.connections.spi.ConnectionProvider} that manages connections from an underlying {@link DataSource}.
  * <p/>
  * The {@link DataSource} to use may be specified by either:<ul>
  * <li>injection via {@link #setDataSource}</li>
  * <li>decaring the {@link DataSource} instance using the {@link Environment#DATASOURCE} config property</li>
  * <li>decaring the JNDI name under which the {@link DataSource} can be found via {@link Environment#DATASOURCE} config property</li>
  * </ul>
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class DatasourceConnectionProviderImpl implements ConnectionProvider, Configurable, Stoppable {
 
 	private DataSource dataSource;
 	private String user;
 	private String pass;
 	private boolean useCredentials;
 	private JndiService jndiService;
 
 	private boolean available;
 
 	public DataSource getDataSource() {
 		return dataSource;
 	}
 
 	public void setDataSource(DataSource dataSource) {
 		this.dataSource = dataSource;
 	}
 
 	@InjectService( required = false )
 	public void setJndiService(JndiService jndiService) {
 		this.jndiService = jndiService;
 	}
 
 	@Override
 	public boolean isUnwrappableAs(Class unwrapType) {
 		return ConnectionProvider.class.equals( unwrapType ) ||
 				DatasourceConnectionProviderImpl.class.isAssignableFrom( unwrapType ) ||
 				DataSource.class.isAssignableFrom( unwrapType );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> T unwrap(Class<T> unwrapType) {
 		if ( ConnectionProvider.class.equals( unwrapType ) ||
 				DatasourceConnectionProviderImpl.class.isAssignableFrom( unwrapType ) ) {
 			return (T) this;
 		}
 		else if ( DataSource.class.isAssignableFrom( unwrapType ) ) {
 			return (T) getDataSource();
 		}
 		else {
 			throw new UnknownUnwrapTypeException( unwrapType );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void configure(Map configValues) {
 		if ( this.dataSource == null ) {
 			final Object dataSource = configValues.get( Environment.DATASOURCE );
 			if ( DataSource.class.isInstance( dataSource ) ) {
 				this.dataSource = (DataSource) dataSource;
 			}
 			else {
 				final String dataSourceJndiName = (String) dataSource;
 				if ( dataSourceJndiName == null ) {
 					throw new HibernateException(
 							"DataSource to use was not injected nor specified by [" + Environment.DATASOURCE
 									+ "] configuration property"
 					);
 				}
 				if ( jndiService == null ) {
 					throw new HibernateException( "Unable to locate JndiService to lookup Datasource" );
 				}
 				this.dataSource = (DataSource) jndiService.locate( dataSourceJndiName );
 			}
 		}
 		if ( this.dataSource == null ) {
 			throw new HibernateException( "Unable to determine appropriate DataSource to use" );
 		}
 
 		user = (String) configValues.get( Environment.USER );
 		pass = (String) configValues.get( Environment.PASS );
 		useCredentials = user != null || pass != null;
 		available = true;
 	}
 
 	public void stop() {
 		available = false;
 		dataSource = null;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Connection getConnection() throws SQLException {
 		if ( !available ) {
 			throw new HibernateException( "Provider is closed!" );
 		}
 		return useCredentials ? dataSource.getConnection( user, pass ) : dataSource.getConnection();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void closeConnection(Connection connection) throws SQLException {
 		connection.close();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public boolean supportsAggressiveRelease() {
 		return true;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java
index 85f8874005..3b9d67da7b 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/DriverManagerConnectionProviderImpl.java
@@ -1,242 +1,242 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.connections.internal;
+package org.hibernate.engine.jdbc.connections.internal;
 
 import java.sql.Connection;
 import java.sql.DriverManager;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Map;
 import java.util.Properties;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Environment;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.UnknownUnwrapTypeException;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.classloading.spi.ClassLoadingException;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.service.spi.Configurable;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.Stoppable;
 
 /**
  * A connection provider that uses the {@link java.sql.DriverManager} directly to open connections and provides
  * a very rudimentary connection pool.
  * <p/>
  * IMPL NOTE : not intended for production use!
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 @SuppressWarnings( {"UnnecessaryUnboxing"})
 public class DriverManagerConnectionProviderImpl
 		implements ConnectionProvider, Configurable, Stoppable, ServiceRegistryAwareService {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, DriverManagerConnectionProviderImpl.class.getName() );
 
 	private String url;
 	private Properties connectionProps;
 	private Integer isolation;
 	private int poolSize;
 	private boolean autocommit;
 
 	private final ArrayList<Connection> pool = new ArrayList<Connection>();
 	private int checkedOut = 0;
 
 	private boolean stopped;
 
 	private transient ServiceRegistryImplementor serviceRegistry;
 
 	@Override
 	public boolean isUnwrappableAs(Class unwrapType) {
 		return ConnectionProvider.class.equals( unwrapType ) ||
 				DriverManagerConnectionProviderImpl.class.isAssignableFrom( unwrapType );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> T unwrap(Class<T> unwrapType) {
 		if ( ConnectionProvider.class.equals( unwrapType ) ||
 				DriverManagerConnectionProviderImpl.class.isAssignableFrom( unwrapType ) ) {
 			return (T) this;
 		}
 		else {
 			throw new UnknownUnwrapTypeException( unwrapType );
 		}
 	}
 
 	public void configure(Map configurationValues) {
         LOG.usingHibernateBuiltInConnectionPool();
 
 		String driverClassName = (String) configurationValues.get( AvailableSettings.DRIVER );
 		if ( driverClassName == null ) {
 			LOG.jdbcDriverNotSpecified( AvailableSettings.DRIVER );
 		}
 		else if ( serviceRegistry != null ) {
 			try {
 				serviceRegistry.getService( ClassLoaderService.class ).classForName( driverClassName );
 			}
 			catch ( ClassLoadingException e ) {
 				throw new ClassLoadingException(
 						"Specified JDBC Driver " + driverClassName + " class not found",
 						e
 				);
 			}
 		}
 		// guard dog, mostly for making test pass
 		else {
 			try {
 				// trying via forName() first to be as close to DriverManager's semantics
 				Class.forName( driverClassName );
 			}
 			catch ( ClassNotFoundException cnfe ) {
 				try{
 					ReflectHelper.classForName( driverClassName );
 				}
 				catch ( ClassNotFoundException e ) {
 					throw new HibernateException( "Specified JDBC Driver " + driverClassName + " class not found", e );
 				}
 			}
 		}
 
 		poolSize = ConfigurationHelper.getInt( AvailableSettings.POOL_SIZE, configurationValues, 20 ); // default pool size 20
         LOG.hibernateConnectionPoolSize(poolSize);
 
 		autocommit = ConfigurationHelper.getBoolean( AvailableSettings.AUTOCOMMIT, configurationValues );
         LOG.autoCommitMode( autocommit );
 
 		isolation = ConfigurationHelper.getInteger( AvailableSettings.ISOLATION, configurationValues );
         if (isolation != null) LOG.jdbcIsolationLevel(Environment.isolationLevelToString(isolation.intValue()));
 
 		url = (String) configurationValues.get( AvailableSettings.URL );
 		if ( url == null ) {
             String msg = LOG.jdbcUrlNotSpecified(AvailableSettings.URL);
             LOG.error(msg);
 			throw new HibernateException( msg );
 		}
 
 		connectionProps = ConnectionProviderInitiator.getConnectionProperties( configurationValues );
 
 		LOG.usingDriver( driverClassName, url );
 		// if debug level is enabled, then log the password, otherwise mask it
 		if ( LOG.isDebugEnabled() )
 			LOG.connectionProperties( connectionProps );
 		else
 			LOG.connectionProperties( ConfigurationHelper.maskOut( connectionProps, "password" ) );
 	}
 
 	public void stop() {
 		LOG.cleaningUpConnectionPool( url );
 
 		for ( Connection connection : pool ) {
 			try {
 				connection.close();
 			}
 			catch (SQLException sqle) {
 				LOG.unableToClosePooledConnection( sqle );
 			}
 		}
 		pool.clear();
 		stopped = true;
 	}
 
 	public Connection getConnection() throws SQLException {
 		LOG.tracev( "Total checked-out connections: {0}", checkedOut );
 
 		// essentially, if we have available connections in the pool, use one...
 		synchronized (pool) {
 			if ( !pool.isEmpty() ) {
 				int last = pool.size() - 1;
 				LOG.tracev( "Using pooled JDBC connection, pool size: {0}", last );
 				Connection pooled = pool.remove( last );
 				if ( isolation != null ) {
 					pooled.setTransactionIsolation( isolation.intValue() );
 				}
 				if ( pooled.getAutoCommit() != autocommit ) {
 					pooled.setAutoCommit( autocommit );
 				}
 				checkedOut++;
 				return pooled;
 			}
 		}
 
 		// otherwise we open a new connection...
 
 		LOG.debug( "Opening new JDBC connection" );
 		Connection conn = DriverManager.getConnection( url, connectionProps );
 		if ( isolation != null ) {
 			conn.setTransactionIsolation( isolation.intValue() );
 		}
 		if ( conn.getAutoCommit() != autocommit ) {
 			conn.setAutoCommit(autocommit);
 		}
 
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debugf( "Created connection to: %s, Isolation Level: %s", url, conn.getTransactionIsolation() );
 		}
 
 		checkedOut++;
 		return conn;
 	}
 
 	public void closeConnection(Connection conn) throws SQLException {
 		checkedOut--;
 
 		// add to the pool if the max size is not yet reached.
 		synchronized (pool) {
 			int currentSize = pool.size();
 			if ( currentSize < poolSize ) {
 				LOG.tracev( "Returning connection to pool, pool size: {0}", ( currentSize + 1 ) );
 				pool.add(conn);
 				return;
 			}
 		}
 
 		LOG.debug( "Closing JDBC connection" );
 		conn.close();
 	}
 
 	@Override
 	protected void finalize() throws Throwable {
 		if ( !stopped ) {
 			stop();
 		}
 		super.finalize();
 	}
 
 	public boolean supportsAggressiveRelease() {
 		return false;
 	}
 
 	@Override
 	public void injectServices(ServiceRegistryImplementor serviceRegistry) {
 		this.serviceRegistry = serviceRegistry;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/MultiTenantConnectionProviderInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/MultiTenantConnectionProviderInitiator.java
similarity index 85%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/MultiTenantConnectionProviderInitiator.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/MultiTenantConnectionProviderInitiator.java
index 3605291df4..deedad18f7 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/MultiTenantConnectionProviderInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/MultiTenantConnectionProviderInitiator.java
@@ -1,101 +1,101 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.connections.internal;
+package org.hibernate.engine.jdbc.connections.internal;
 
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.MultiTenancyStrategy;
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.cfg.AvailableSettings;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.classloading.spi.ClassLoadingException;
-import org.hibernate.service.jdbc.connections.spi.DataSourceBasedMultiTenantConnectionProviderImpl;
-import org.hibernate.service.jdbc.connections.spi.MultiTenantConnectionProvider;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.engine.jdbc.connections.spi.DataSourceBasedMultiTenantConnectionProviderImpl;
+import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
 import org.hibernate.service.spi.ServiceException;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * @author Steve Ebersole
  */
-public class MultiTenantConnectionProviderInitiator implements BasicServiceInitiator<MultiTenantConnectionProvider> {
+public class MultiTenantConnectionProviderInitiator implements StandardServiceInitiator<MultiTenantConnectionProvider> {
 	public static final MultiTenantConnectionProviderInitiator INSTANCE = new MultiTenantConnectionProviderInitiator();
 	private static final Logger log = Logger.getLogger( MultiTenantConnectionProviderInitiator.class );
 
 	@Override
 	public Class<MultiTenantConnectionProvider> getServiceInitiated() {
 		return MultiTenantConnectionProvider.class;
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public MultiTenantConnectionProvider initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		final MultiTenancyStrategy strategy = MultiTenancyStrategy.determineMultiTenancyStrategy(  configurationValues );
 		if ( strategy == MultiTenancyStrategy.NONE || strategy == MultiTenancyStrategy.DISCRIMINATOR ) {
 			// nothing to do, but given the separate hierarchies have to handle this here.
 		}
 
 		final Object configValue = configurationValues.get( AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER );
 		if ( configValue == null ) {
 			// if they also specified the data source *name*, then lets assume they want
-			// org.hibernate.service.jdbc.connections.spi.DataSourceBasedMultiTenantConnectionProviderImpl
+			// DataSourceBasedMultiTenantConnectionProviderImpl
 			final Object dataSourceConfigValue = configurationValues.get( AvailableSettings.DATASOURCE );
 			if ( dataSourceConfigValue != null && String.class.isInstance( dataSourceConfigValue ) ) {
 				return new DataSourceBasedMultiTenantConnectionProviderImpl();
 			}
 
 			return null;
 		}
 
 		if ( MultiTenantConnectionProvider.class.isInstance( configValue ) ) {
 			return (MultiTenantConnectionProvider) configValue;
 		}
 		else {
 			final Class<MultiTenantConnectionProvider> implClass;
 			if ( Class.class.isInstance( configValue ) ) {
 				implClass = (Class) configValue;
 			}
 			else {
 				final String className = configValue.toString();
 				final ClassLoaderService classLoaderService = registry.getService( ClassLoaderService.class );
 				try {
 					implClass = classLoaderService.classForName( className );
 				}
 				catch (ClassLoadingException cle) {
 					log.warn( "Unable to locate specified class [" + className + "]", cle );
 					throw new ServiceException( "Unable to locate specified multi-tenant connection provider [" + className + "]" );
 				}
 			}
 
 			try {
 				return implClass.newInstance();
 			}
 			catch (Exception e) {
 				log.warn( "Unable to instantiate specified class [" + implClass.getName() + "]", e );
 				throw new ServiceException( "Unable to instantiate specified multi-tenant connection provider [" + implClass.getName() + "]" );
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/UserSuppliedConnectionProviderImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/UserSuppliedConnectionProviderImpl.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/UserSuppliedConnectionProviderImpl.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/UserSuppliedConnectionProviderImpl.java
index f17e319694..b7c966ea4b 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/internal/UserSuppliedConnectionProviderImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/internal/UserSuppliedConnectionProviderImpl.java
@@ -1,78 +1,78 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.connections.internal;
+package org.hibernate.engine.jdbc.connections.internal;
 import java.sql.Connection;
 import java.sql.SQLException;
 
 import org.hibernate.service.UnknownUnwrapTypeException;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 
 /**
  * An implementation of the {@link ConnectionProvider} interface that simply throws an exception when a connection
  * is requested, the assumption being that the application is responsible for handing the connection to use to
  * the session
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class UserSuppliedConnectionProviderImpl implements ConnectionProvider {
 	@Override
 	public boolean isUnwrappableAs(Class unwrapType) {
 		return ConnectionProvider.class.equals( unwrapType ) ||
 				UserSuppliedConnectionProviderImpl.class.isAssignableFrom( unwrapType );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> T unwrap(Class<T> unwrapType) {
 		if ( ConnectionProvider.class.equals( unwrapType ) ||
 				UserSuppliedConnectionProviderImpl.class.isAssignableFrom( unwrapType ) ) {
 			return (T) this;
 		}
 		else {
 			throw new UnknownUnwrapTypeException( unwrapType );
 		}
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Connection getConnection() throws SQLException {
 		throw new UnsupportedOperationException( "The application must supply JDBC connections" );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public void closeConnection(Connection conn) throws SQLException {
 		throw new UnsupportedOperationException( "The application must supply JDBC connections" );
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public boolean supportsAggressiveRelease() {
 		return false;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/AbstractDataSourceBasedMultiTenantConnectionProviderImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/AbstractDataSourceBasedMultiTenantConnectionProviderImpl.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/AbstractDataSourceBasedMultiTenantConnectionProviderImpl.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/AbstractDataSourceBasedMultiTenantConnectionProviderImpl.java
index 9c2bc3e2e5..b60d3433d0 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/AbstractDataSourceBasedMultiTenantConnectionProviderImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/AbstractDataSourceBasedMultiTenantConnectionProviderImpl.java
@@ -1,81 +1,81 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.connections.spi;
+package org.hibernate.engine.jdbc.connections.spi;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 import javax.sql.DataSource;
 
 import org.hibernate.service.UnknownUnwrapTypeException;
 
 /**
  * Basic support for implementations of {@link MultiTenantConnectionProvider} based on DataSources.
  * @author Steve Ebersole
  */
 public abstract class AbstractDataSourceBasedMultiTenantConnectionProviderImpl implements MultiTenantConnectionProvider {
 	protected abstract DataSource selectAnyDataSource();
 	protected abstract DataSource selectDataSource(String tenantIdentifier);
 
 	@Override
 	public Connection getAnyConnection() throws SQLException {
 		return selectAnyDataSource().getConnection();
 	}
 
 	@Override
 	public void releaseAnyConnection(Connection connection) throws SQLException {
 		connection.close();
 	}
 
 	@Override
 	public Connection getConnection(String tenantIdentifier) throws SQLException {
 		return selectDataSource( tenantIdentifier ).getConnection();
 	}
 
 	@Override
 	public void releaseConnection(String tenantIdentifier, Connection connection) throws SQLException {
 		connection.close();
 	}
 
 	@Override
 	public boolean supportsAggressiveRelease() {
 		return true;
 	}
 
 	@Override
 	public boolean isUnwrappableAs(Class unwrapType) {
 		return MultiTenantConnectionProvider.class.equals( unwrapType ) ||
 				AbstractMultiTenantConnectionProvider.class.isAssignableFrom( unwrapType );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> T unwrap(Class<T> unwrapType) {
 		if ( isUnwrappableAs( unwrapType ) ) {
 			return (T) this;
 		}
 		else {
 			throw new UnknownUnwrapTypeException( unwrapType );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/AbstractMultiTenantConnectionProvider.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/AbstractMultiTenantConnectionProvider.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/AbstractMultiTenantConnectionProvider.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/AbstractMultiTenantConnectionProvider.java
index 8460a96acf..cd543ec6be 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/AbstractMultiTenantConnectionProvider.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/AbstractMultiTenantConnectionProvider.java
@@ -1,83 +1,83 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.connections.spi;
+package org.hibernate.engine.jdbc.connections.spi;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 
 import org.hibernate.service.UnknownUnwrapTypeException;
 
 /**
  * Basic support for {@link MultiTenantConnectionProvider} implementations using
  * individual {@link ConnectionProvider} instances per tenant behind the scenes.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractMultiTenantConnectionProvider implements MultiTenantConnectionProvider {
 	protected abstract ConnectionProvider getAnyConnectionProvider();
 	protected abstract ConnectionProvider selectConnectionProvider(String tenantIdentifier);
 
 	@Override
 	public Connection getAnyConnection() throws SQLException {
 		return getAnyConnectionProvider().getConnection();
 	}
 
 	@Override
 	public void releaseAnyConnection(Connection connection) throws SQLException {
 		getAnyConnectionProvider().closeConnection( connection );
 	}
 
 	@Override
 	public Connection getConnection(String tenantIdentifier) throws SQLException {
 		return selectConnectionProvider( tenantIdentifier ).getConnection();
 	}
 
 	@Override
 	public void releaseConnection(String tenantIdentifier, Connection connection) throws SQLException {
 		selectConnectionProvider( tenantIdentifier ).closeConnection( connection );
 	}
 
 	@Override
 	public boolean supportsAggressiveRelease() {
 		return getAnyConnectionProvider().supportsAggressiveRelease();
 	}
 
 	@Override
 	public boolean isUnwrappableAs(Class unwrapType) {
 		return ConnectionProvider.class.equals( unwrapType ) ||
 				MultiTenantConnectionProvider.class.equals( unwrapType ) ||
 				AbstractMultiTenantConnectionProvider.class.isAssignableFrom( unwrapType );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> T unwrap(Class<T> unwrapType) {
 		if ( isUnwrappableAs( unwrapType ) ) {
 			return (T) this;
 		}
 		else {
 			throw new UnknownUnwrapTypeException( unwrapType );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/ConnectionProvider.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/ConnectionProvider.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/ConnectionProvider.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/ConnectionProvider.java
index dd41e81a88..762d5b4613 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/ConnectionProvider.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/ConnectionProvider.java
@@ -1,80 +1,80 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.connections.spi;
+package org.hibernate.engine.jdbc.connections.spi;
 import java.sql.Connection;
 import java.sql.SQLException;
 
 import org.hibernate.HibernateException;
 import org.hibernate.service.Service;
 import org.hibernate.service.spi.Wrapped;
 
 /**
  * A contract for obtaining JDBC connections.
  * <p/>
  * Implementors might also implement connection pooling.
  * <p/>
  * Implementors should provide a public default constructor.
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public interface ConnectionProvider extends Service, Wrapped {
 	/**
 	 * Obtains a connection for Hibernate use according to the underlying strategy of this provider.
 	 *
 	 * @return The obtained JDBC connection
 	 *
 	 * @throws SQLException Indicates a problem opening a connection
 	 * @throws HibernateException Indicates a problem otherwise obtaining a connection.
 	 */
 	public Connection getConnection() throws SQLException;
 
 	/**
 	 * Release a connection from Hibernate use.
 	 *
 	 * @param conn The JDBC connection to release
 	 *
 	 * @throws SQLException Indicates a problem closing the connection
 	 * @throws HibernateException Indicates a problem otherwise releasing a connection.
 	 */
 	public void closeConnection(Connection conn) throws SQLException;
 
 	/**
 	 * Does this connection provider support aggressive release of JDBC
 	 * connections and re-acquisition of those connections (if need be) later?
 	 * <p/>
 	 * This is used in conjunction with {@link org.hibernate.cfg.Environment#RELEASE_CONNECTIONS}
 	 * to aggressively release JDBC connections.  However, the configured ConnectionProvider
 	 * must support re-acquisition of the same underlying connection for that semantic to work.
 	 * <p/>
 	 * Typically, this is only true in managed environments where a container
 	 * tracks connections by transaction or thread.
 	 *
 	 * Note that JTA semantic depends on the fact that the underlying connection provider does
 	 * support aggressive release.
 	 *
 	 * @return {@code true} if aggressive releasing is supported; {@code false} otherwise.
 	 */
 	public boolean supportsAggressiveRelease();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/DataSourceBasedMultiTenantConnectionProviderImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/DataSourceBasedMultiTenantConnectionProviderImpl.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/DataSourceBasedMultiTenantConnectionProviderImpl.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/DataSourceBasedMultiTenantConnectionProviderImpl.java
index cbc119b054..cb387f1421 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/DataSourceBasedMultiTenantConnectionProviderImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/DataSourceBasedMultiTenantConnectionProviderImpl.java
@@ -1,138 +1,138 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.connections.spi;
+package org.hibernate.engine.jdbc.connections.spi;
 
 import java.util.Map;
 import java.util.concurrent.ConcurrentHashMap;
 import javax.naming.Context;
 import javax.sql.DataSource;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.AvailableSettings;
-import org.hibernate.service.config.spi.ConfigurationService;
-import org.hibernate.service.jndi.spi.JndiService;
+import org.hibernate.engine.config.spi.ConfigurationService;
+import org.hibernate.engine.jndi.spi.JndiService;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.Stoppable;
 
 /**
  * A concrete implementation of the {@link MultiTenantConnectionProvider} contract bases on a number of
  * reasonable assumptions.  We assume that:<ul>
  *     <li>
  *         The {@link DataSource} instances are all available from JNDI named by the tenant identifier relative
  *         to a single base JNDI context
  *     </li>
  *     <li>
  *         {@link org.hibernate.cfg.AvailableSettings#DATASOURCE} is a string naming either the {@literal any}
  *         data source or the base JNDI context.  If the latter, {@link #TENANT_IDENTIFIER_TO_USE_FOR_ANY_KEY} must
  *         also be set.
  *     </li>
  * </ul>
  *
  * @author Steve Ebersole
  */
 public class DataSourceBasedMultiTenantConnectionProviderImpl
 		extends AbstractDataSourceBasedMultiTenantConnectionProviderImpl
 		implements ServiceRegistryAwareService, Stoppable {
 
 	public static final String TENANT_IDENTIFIER_TO_USE_FOR_ANY_KEY = "hibernate.multi_tenant.datasource.identifier_for_any";
 
 	private Map<String,DataSource> dataSourceMap;
 	private JndiService jndiService;
 	private String tenantIdentifierForAny;
 	private String baseJndiNamespace;
 
 	@Override
 	protected DataSource selectAnyDataSource() {
 		return selectDataSource( tenantIdentifierForAny );
 	}
 
 	@Override
 	protected DataSource selectDataSource(String tenantIdentifier) {
 		DataSource dataSource = dataSourceMap().get( tenantIdentifier );
 		if ( dataSource == null ) {
 			dataSource = (DataSource) jndiService.locate( baseJndiNamespace + '/' + tenantIdentifier );
 			dataSourceMap().put( tenantIdentifier, dataSource );
 		}
 		return dataSource;
 	}
 
 	private Map<String,DataSource> dataSourceMap() {
 		if ( dataSourceMap == null ) {
 			dataSourceMap = new ConcurrentHashMap<String, DataSource>();
 		}
 		return dataSourceMap;
 	}
 
 	@Override
 	public void injectServices(ServiceRegistryImplementor serviceRegistry) {
 		final Object dataSourceConfigValue = serviceRegistry.getService( ConfigurationService.class )
 				.getSettings()
 				.get( AvailableSettings.DATASOURCE );
 		if ( dataSourceConfigValue == null || ! String.class.isInstance( dataSourceConfigValue ) ) {
 			throw new HibernateException( "Improper set up of DataSourceBasedMultiTenantConnectionProviderImpl" );
 		}
 		final String jndiName = (String) dataSourceConfigValue;
 
 		jndiService = serviceRegistry.getService( JndiService.class );
 		if ( jndiService == null ) {
 			throw new HibernateException( "Could not locate JndiService from DataSourceBasedMultiTenantConnectionProviderImpl" );
 		}
 
 		Object namedObject = jndiService.locate( jndiName );
 		if ( namedObject == null ) {
 			throw new HibernateException( "JNDI name [" + jndiName + "] could not be resolved" );
 		}
 
 		if ( DataSource.class.isInstance( namedObject ) ) {
 			int loc = jndiName.lastIndexOf( "/" );
 			this.baseJndiNamespace = jndiName.substring( 0, loc );
 			this.tenantIdentifierForAny = jndiName.substring( loc + 1 );
 			dataSourceMap().put( tenantIdentifierForAny, (DataSource) namedObject );
 		}
 		else if ( Context.class.isInstance( namedObject ) ) {
 			this.baseJndiNamespace = jndiName;
 			this.tenantIdentifierForAny = (String) serviceRegistry.getService( ConfigurationService.class )
 					.getSettings()
 					.get( TENANT_IDENTIFIER_TO_USE_FOR_ANY_KEY );
 			if ( tenantIdentifierForAny == null ) {
 				throw new HibernateException( "JNDI name named a Context, but tenant identifier to use for ANY was not specified" );
 			}
 		}
 		else {
 			throw new HibernateException(
 					"Unknown object type [" + namedObject.getClass().getName() +
 							"] found in JNDI location [" + jndiName + "]"
 			);
 		}
 	}
 
 	@Override
 	public void stop() {
 		if ( dataSourceMap != null ) {
 			dataSourceMap.clear();
 			dataSourceMap = null;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/MultiTenantConnectionProvider.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/MultiTenantConnectionProvider.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/MultiTenantConnectionProvider.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/MultiTenantConnectionProvider.java
index 29ce194997..860d926c0b 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/connections/spi/MultiTenantConnectionProvider.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/connections/spi/MultiTenantConnectionProvider.java
@@ -1,95 +1,95 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.connections.spi;
+package org.hibernate.engine.jdbc.connections.spi;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 
 import org.hibernate.service.Service;
 import org.hibernate.service.spi.Wrapped;
 
 /**
  * @author Steve Ebersole
  */
 public interface MultiTenantConnectionProvider extends Service, Wrapped {
 	/**
 	 * Allows access to the database metadata of the underlying database(s) in situations where we do not have a
 	 * tenant id (like startup processing, for example).
 	 *
 	 * @return The database metadata.
 	 *
 	 * @throws SQLException Indicates a problem opening a connection
 	 */
 	public Connection getAnyConnection() throws SQLException;
 
 	/**
 	 * Release a connection obtained from {@link #getAnyConnection}
 	 *
 	 * @param connection The JDBC connection to release
 	 *
 	 * @throws SQLException Indicates a problem closing the connection
 	 */
 	public void releaseAnyConnection(Connection connection) throws SQLException;
 
 	/**
 	 * Obtains a connection for Hibernate use according to the underlying strategy of this provider.
 	 *
 	 * @param tenantIdentifier The identifier of the tenant for which to get a connection
 	 *
 	 * @return The obtained JDBC connection
 	 *
 	 * @throws SQLException Indicates a problem opening a connection
 	 * @throws org.hibernate.HibernateException Indicates a problem otherwise obtaining a connection.
 	 */
 	public Connection getConnection(String tenantIdentifier) throws SQLException;
 
 	/**
 	 * Release a connection from Hibernate use.
 	 *
 	 * @param connection The JDBC connection to release
 	 * @param tenantIdentifier The identifier of the tenant.
 	 *
 	 * @throws SQLException Indicates a problem closing the connection
 	 * @throws org.hibernate.HibernateException Indicates a problem otherwise releasing a connection.
 	 */
 	public void releaseConnection(String tenantIdentifier, Connection connection) throws SQLException;
 
 	/**
 	 * Does this connection provider support aggressive release of JDBC
 	 * connections and re-acquisition of those connections (if need be) later?
 	 * <p/>
 	 * This is used in conjunction with {@link org.hibernate.cfg.Environment#RELEASE_CONNECTIONS}
 	 * to aggressively release JDBC connections.  However, the configured ConnectionProvider
 	 * must support re-acquisition of the same underlying connection for that semantic to work.
 	 * <p/>
 	 * Typically, this is only true in managed environments where a container
 	 * tracks connections by transaction or thread.
 	 *
 	 * Note that JTA semantic depends on the fact that the underlying connection provider does
 	 * support aggressive release.
 	 *
 	 * @return {@code true} if aggressive releasing is supported; {@code false} otherwise.
 	 */
 	public boolean supportsAggressiveRelease();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/cursor/internal/RefCursorSupportInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/cursor/internal/RefCursorSupportInitiator.java
similarity index 84%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/cursor/internal/RefCursorSupportInitiator.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/cursor/internal/RefCursorSupportInitiator.java
index 7c7cc4fe11..2a74fe146e 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/cursor/internal/RefCursorSupportInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/cursor/internal/RefCursorSupportInitiator.java
@@ -1,47 +1,47 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.cursor.internal;
+package org.hibernate.engine.jdbc.cursor.internal;
 
 import java.util.Map;
 
-import org.hibernate.service.jdbc.cursor.spi.RefCursorSupport;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.StandardServiceInitiator;
+import org.hibernate.engine.jdbc.cursor.spi.RefCursorSupport;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * @author Steve Ebersole
  */
-public class RefCursorSupportInitiator implements BasicServiceInitiator<RefCursorSupport> {
+public class RefCursorSupportInitiator implements StandardServiceInitiator<RefCursorSupport> {
 	public static final RefCursorSupportInitiator INSTANCE = new RefCursorSupportInitiator();
 
 	@Override
 	public RefCursorSupport initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		return new StandardRefCursorSupport();
 	}
 
 	@Override
 	public Class<RefCursorSupport> getServiceInitiated() {
 		return RefCursorSupport.class;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/cursor/internal/StandardRefCursorSupport.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/cursor/internal/StandardRefCursorSupport.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/cursor/internal/StandardRefCursorSupport.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/cursor/internal/StandardRefCursorSupport.java
index cb48b29468..93f3e6a9de 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/cursor/internal/StandardRefCursorSupport.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/cursor/internal/StandardRefCursorSupport.java
@@ -1,233 +1,233 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.cursor.internal;
+package org.hibernate.engine.jdbc.cursor.internal;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.sql.CallableStatement;
 import java.sql.DatabaseMetaData;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.sql.Types;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
-import org.hibernate.service.jdbc.cursor.spi.RefCursorSupport;
+import org.hibernate.engine.jdbc.cursor.spi.RefCursorSupport;
 import org.hibernate.service.spi.InjectService;
 
 /**
  * @author Steve Ebersole
  */
 public class StandardRefCursorSupport implements RefCursorSupport {
 	private static final Logger log = Logger.getLogger( StandardRefCursorSupport.class );
 
 	private JdbcServices jdbcServices;
 
 	@InjectService
 	@SuppressWarnings("UnusedDeclaration")
 	public void injectJdbcServices(JdbcServices jdbcServices) {
 		this.jdbcServices = jdbcServices;
 	}
 
 	@Override
 	public void registerRefCursorParameter(CallableStatement statement, int position) {
 		if ( jdbcServices.getExtractedMetaDataSupport().supportsRefCursors() ) {
 			try {
 				statement.registerOutParameter( position, refCursorTypeCode() );
 			}
 			catch (SQLException e) {
 				throw jdbcServices.getSqlExceptionHelper().convert( e, "Error registering REF_CURSOR parameter [" + position + "]" );
 			}
 		}
 		else {
 			try {
 				jdbcServices.getDialect().registerResultSetOutParameter( statement, position );
 			}
 			catch (SQLException e) {
 				throw jdbcServices.getSqlExceptionHelper().convert( e, "Error asking dialect to register ref cursor parameter [" + position + "]" );
 			}
 		}
 	}
 
 	@Override
 	public void registerRefCursorParameter(CallableStatement statement, String name) {
 		if ( jdbcServices.getExtractedMetaDataSupport().supportsRefCursors() ) {
 			try {
 				statement.registerOutParameter( name, refCursorTypeCode() );
 			}
 			catch (SQLException e) {
 				throw jdbcServices.getSqlExceptionHelper().convert( e, "Error registering REF_CURSOR parameter [" + name + "]" );
 			}
 		}
 		else {
 			try {
 				jdbcServices.getDialect().registerResultSetOutParameter( statement, name );
 			}
 			catch (SQLException e) {
 				throw jdbcServices.getSqlExceptionHelper().convert( e, "Error asking dialect to register ref cursor parameter [" + name + "]" );
 			}
 		}
 	}
 
 	@Override
 	public ResultSet getResultSet(CallableStatement statement, int position) {
 		if ( jdbcServices.getExtractedMetaDataSupport().supportsRefCursors() ) {
 			try {
 				return (ResultSet) getResultSetByPositionMethod().invoke( statement, position, ResultSet.class );
 			}
 			catch (InvocationTargetException e) {
 				if ( e.getTargetException() instanceof SQLException ) {
 					throw jdbcServices.getSqlExceptionHelper().convert(
 							(SQLException) e.getTargetException(),
 							"Error extracting REF_CURSOR parameter [" + position + "]"
 					);
 				}
 				else {
 					throw new HibernateException( "Unexpected error extracting REF_CURSOR parameter [" + position + "]", e.getTargetException() );
 				}
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Unexpected error extracting REF_CURSOR parameter [" + position + "]", e );
 			}
 		}
 		else {
 			try {
 				return jdbcServices.getDialect().getResultSet( statement, position );
 			}
 			catch (SQLException e) {
 				throw jdbcServices.getSqlExceptionHelper().convert(
 						e,
 						"Error asking dialect to extract ResultSet from CallableStatement parameter [" + position + "]"
 				);
 			}
 		}
 	}
 
 	@Override
 	public ResultSet getResultSet(CallableStatement statement, String name) {
 		if ( jdbcServices.getExtractedMetaDataSupport().supportsRefCursors() ) {
 			try {
 				return (ResultSet) getResultSetByNameMethod().invoke( statement, name, ResultSet.class );
 			}
 			catch (InvocationTargetException e) {
 				if ( e.getTargetException() instanceof SQLException ) {
 					throw jdbcServices.getSqlExceptionHelper().convert(
 							(SQLException) e.getTargetException(),
 							"Error extracting REF_CURSOR parameter [" + name + "]"
 					);
 				}
 				else {
 					throw new HibernateException( "Unexpected error extracting REF_CURSOR parameter [" + name + "]", e.getTargetException() );
 				}
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Unexpected error extracting REF_CURSOR parameter [" + name + "]", e );
 			}
 		}
 		else {
 			try {
 				return jdbcServices.getDialect().getResultSet( statement, name );
 			}
 			catch (SQLException e) {
 				throw jdbcServices.getSqlExceptionHelper().convert(
 						e,
 						"Error asking dialect to extract ResultSet from CallableStatement parameter [" + name + "]"
 				);
 			}
 		}
 	}
 
 	@SuppressWarnings("UnnecessaryUnboxing")
 	public static boolean supportsRefCursors(DatabaseMetaData meta) {
 		// Standard JDBC REF_CURSOR support was not added until Java 8, so we need to use reflection to attempt to
 		// access these fields/methods...
 		try {
 			return ( (Boolean) meta.getClass().getMethod( "supportsRefCursors" ).invoke( null ) ).booleanValue();
 		}
 		catch (NoSuchMethodException e) {
 			log.trace( "JDBC DatabaseMetaData class does not define supportsRefCursors method..." );
 		}
 		catch (Exception e) {
 			log.debug( "Unexpected error trying to gauge level of JDBC REF_CURSOR support : " + e.getMessage() );
 		}
 		return false;
 	}
 
 
 	private static Integer refCursorTypeCode;
 
 	@SuppressWarnings("UnnecessaryUnboxing")
 	private int refCursorTypeCode() {
 		if ( refCursorTypeCode == null ) {
 			try {
 				refCursorTypeCode = (Integer) Types.class.getField( "REF_CURSOR" ).get( null );
 			}
 			catch (NoSuchFieldException e) {
 				throw new HibernateException( "java.sql.Types class does not define REF_CURSOR field..." );
 			}
 			catch (IllegalAccessException e) {
 				throw new HibernateException( "Unexpected error trying to determine REF_CURSOR field value : " + e.getMessage() );
 			}
 		}
 		return refCursorTypeCode.intValue();
 	}
 
 
 	private static Method getResultSetByPositionMethod;
 
 	private Method getResultSetByPositionMethod() {
 		if ( getResultSetByPositionMethod == null ) {
 			try {
 				getResultSetByPositionMethod = CallableStatement.class.getMethod( "getObject", int.class, Class.class );
 			}
 			catch (NoSuchMethodException e) {
 				throw new HibernateException( "CallableStatement class does not define getObject(int,Class) method" );
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Unexpected error trying to access CallableStatement#getObject(int,Class)" );
 			}
 		}
 		return getResultSetByPositionMethod;
 	}
 
 
 	private static Method getResultSetByNameMethod;
 
 	private Method getResultSetByNameMethod() {
 		if ( getResultSetByNameMethod == null ) {
 			try {
 				getResultSetByNameMethod = CallableStatement.class.getMethod( "getObject", String.class, Class.class );
 			}
 			catch (NoSuchMethodException e) {
 				throw new HibernateException( "CallableStatement class does not define getObject(String,Class) method" );
 			}
 			catch (Exception e) {
 				throw new HibernateException( "Unexpected error trying to access CallableStatement#getObject(String,Class)" );
 			}
 		}
 		return getResultSetByNameMethod;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/cursor/spi/RefCursorSupport.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/cursor/spi/RefCursorSupport.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/cursor/spi/RefCursorSupport.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/cursor/spi/RefCursorSupport.java
index 75babaaba8..7785f0954f 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/cursor/spi/RefCursorSupport.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/cursor/spi/RefCursorSupport.java
@@ -1,73 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.cursor.spi;
+package org.hibernate.engine.jdbc.cursor.spi;
 
 import java.sql.CallableStatement;
 import java.sql.ResultSet;
 
 import org.hibernate.service.Service;
 
 /**
  * @author Steve Ebersole
  */
 public interface RefCursorSupport extends Service {
 	/**
 	 * Register a parameter capable of returning a {@link java.sql.ResultSet} *by position*.
 	 *
 	 * @param statement The callable statement.
 	 * @param position The bind position at which to register the output param.
 	 */
 	public void registerRefCursorParameter(CallableStatement statement, int position);
 
 	/**
 	 * Register a parameter capable of returning a {@link java.sql.ResultSet} *by name*.
 	 *
 	 * @param statement The callable statement.
 	 * @param name The parameter name (for drivers which support named parameters).
 	 */
 	public void registerRefCursorParameter(CallableStatement statement, String name);
 
 	/**
 	 * Given a callable statement previously processed by {@link #registerRefCursorParameter(java.sql.CallableStatement, int)},
 	 * extract the {@link java.sql.ResultSet}.
 	 *
 	 *
 	 * @param statement The callable statement.
 	 * @param position The bind position at which to register the output param.
 	 *
 	 * @return The extracted result set.
 	 */
 	public ResultSet getResultSet(CallableStatement statement, int position);
 
 	/**
 	 * Given a callable statement previously processed by {@link #registerRefCursorParameter(java.sql.CallableStatement, String)},
 	 * extract the {@link java.sql.ResultSet}.
 	 *
 	 * @param statement The callable statement.
 	 * @param name The parameter name (for drivers which support named parameters).
 	 *
 	 * @return The extracted result set.
 	 */
 	public ResultSet getResultSet(CallableStatement statement, String name);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/AbstractDialectResolver.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/AbstractDialectResolver.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/AbstractDialectResolver.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/AbstractDialectResolver.java
index 4eab076eed..0d50ba37cf 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/AbstractDialectResolver.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/AbstractDialectResolver.java
@@ -1,79 +1,79 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.dialect.internal;
+package org.hibernate.engine.jdbc.dialect.internal;
 
 import java.sql.DatabaseMetaData;
 import java.sql.SQLException;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.JDBCException;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.resolver.BasicSQLExceptionConverter;
 import org.hibernate.exception.JDBCConnectionException;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.service.jdbc.dialect.spi.DialectResolver;
+import org.hibernate.engine.jdbc.dialect.spi.DialectResolver;
 
 /**
  * A templated resolver impl which delegates to the {@link #resolveDialectInternal} method
  * and handles any thrown {@link SQLException SQL errors}.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractDialectResolver implements DialectResolver {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        AbstractDialectResolver.class.getName());
 
 	/**
 	 * {@inheritDoc}
 	 * <p/>
 	 * Here we template the resolution, delegating to {@link #resolveDialectInternal} and handling
 	 * {@link java.sql.SQLException}s properly.
 	 */
 	public final Dialect resolveDialect(DatabaseMetaData metaData) {
 		try {
 			return resolveDialectInternal( metaData );
 		}
 		catch ( SQLException sqlException ) {
 			JDBCException jdbcException = BasicSQLExceptionConverter.INSTANCE.convert( sqlException );
             if (jdbcException instanceof JDBCConnectionException) throw jdbcException;
             LOG.warnf("%s : %s", BasicSQLExceptionConverter.MSG, sqlException.getMessage());
             return null;
 		}
 		catch ( Throwable t ) {
             LOG.unableToExecuteResolver(this, t.getMessage());
 			return null;
 		}
 	}
 
 	/**
 	 * Perform the actual resolution without caring about handling {@link SQLException}s.
 	 *
 	 * @param metaData The database metadata
 	 * @return The resolved dialect, or null if we could not resolve.
 	 * @throws SQLException Indicates problems accessing the metadata.
 	 */
 	protected abstract Dialect resolveDialectInternal(DatabaseMetaData metaData) throws SQLException;
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/BasicDialectResolver.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/BasicDialectResolver.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/BasicDialectResolver.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/BasicDialectResolver.java
index 0de006258e..79cd856ef3 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/BasicDialectResolver.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/BasicDialectResolver.java
@@ -1,79 +1,79 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.dialect.internal;
+package org.hibernate.engine.jdbc.dialect.internal;
 
 import java.sql.DatabaseMetaData;
 import java.sql.SQLException;
 
 import org.hibernate.HibernateException;
 import org.hibernate.dialect.Dialect;
 
 /**
  * Intended as support for custom resolvers.
  *
  * @author Steve Ebersole
  */
 public class BasicDialectResolver extends AbstractDialectResolver {
 	// TODO: should this disappear???
 
 	public static final int VERSION_INSENSITIVE_VERSION = -9999;
 
 	private final String matchingName;
 	private final int matchingVersion;
 	private final Class dialectClass;
 
 	public BasicDialectResolver(String matchingName, Class dialectClass) {
 		this( matchingName, VERSION_INSENSITIVE_VERSION, dialectClass );
 	}
 
 	public BasicDialectResolver(String matchingName, int matchingVersion, Class dialectClass) {
 		this.matchingName = matchingName;
 		this.matchingVersion = matchingVersion;
 		this.dialectClass = dialectClass;
 	}
 
 	protected final Dialect resolveDialectInternal(DatabaseMetaData metaData) throws SQLException {
 		final String databaseName = metaData.getDatabaseProductName();
 		final int databaseMajorVersion = metaData.getDatabaseMajorVersion();
 
 		if ( matchingName.equalsIgnoreCase( databaseName )
 				&& ( matchingVersion == VERSION_INSENSITIVE_VERSION || matchingVersion == databaseMajorVersion ) ) {
 			try {
 				return ( Dialect ) dialectClass.newInstance();
 			}
 			catch ( HibernateException e ) {
 				// conceivable that the dialect ctor could throw HibernateExceptions, so don't re-wrap
 				throw e;
 			}
 			catch ( Throwable t ) {
 				throw new HibernateException(
 						"Could not instantiate specified Dialect class [" + dialectClass.getName() + "]",
 						t
 				);
 			}
 		}
 
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/DialectFactoryImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/DialectFactoryImpl.java
similarity index 92%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/DialectFactoryImpl.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/DialectFactoryImpl.java
index 7c045603c9..a140f381b5 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/DialectFactoryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/DialectFactoryImpl.java
@@ -1,121 +1,121 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.dialect.internal;
+package org.hibernate.engine.jdbc.dialect.internal;
 
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.SQLException;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.dialect.Dialect;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.classloading.spi.ClassLoadingException;
-import org.hibernate.service.jdbc.dialect.spi.DialectFactory;
-import org.hibernate.service.jdbc.dialect.spi.DialectResolver;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.engine.jdbc.dialect.spi.DialectFactory;
+import org.hibernate.engine.jdbc.dialect.spi.DialectResolver;
 import org.hibernate.service.spi.InjectService;
 
 /**
  * Standard implementation of the {@link DialectFactory} service.
  *
  * @author Steve Ebersole
  */
 public class DialectFactoryImpl implements DialectFactory {
 	private ClassLoaderService classLoaderService;
 
 	@InjectService
 	public void setClassLoaderService(ClassLoaderService classLoaderService) {
 		this.classLoaderService = classLoaderService;
 	}
 
 	private DialectResolver dialectResolver;
 
 	@InjectService
 	public void setDialectResolver(DialectResolver dialectResolver) {
 		this.dialectResolver = dialectResolver;
 	}
 
 	@Override
 	public Dialect buildDialect(Map configValues, Connection connection) throws HibernateException {
 		final String dialectName = (String) configValues.get( AvailableSettings.DIALECT );
 		if ( dialectName != null ) {
 			return constructDialect( dialectName );
 		}
 		else {
 			return determineDialect( connection );
 		}
 	}
 
 	private Dialect constructDialect(String dialectName) {
 		try {
 			return ( Dialect ) classLoaderService.classForName( dialectName ).newInstance();
 		}
 		catch ( ClassLoadingException e ) {
 			throw new HibernateException( "Dialect class not found: " + dialectName, e );
 		}
 		catch ( HibernateException e ) {
 			throw e;
 		}
 		catch ( Exception e ) {
 			throw new HibernateException( "Could not instantiate dialect class", e );
 		}
 	}
 
 	/**
 	 * Determine the appropriate Dialect to use given the connection.
 	 *
 	 * @param connection The configured connection.
 	 * @return The appropriate dialect instance.
 	 *
 	 * @throws HibernateException No connection given or no resolver could make
 	 * the determination from the given connection.
 	 */
 	private Dialect determineDialect(Connection connection) {
 		if ( connection == null ) {
 			throw new HibernateException( "Connection cannot be null when 'hibernate.dialect' not set" );
 		}
 
 		try {
 			final DatabaseMetaData databaseMetaData = connection.getMetaData();
 			final Dialect dialect = dialectResolver.resolveDialect( databaseMetaData );
 
 			if ( dialect == null ) {
 				throw new HibernateException(
 						"Unable to determine Dialect to use [name=" + databaseMetaData.getDatabaseProductName() +
 								", majorVersion=" + databaseMetaData.getDatabaseMajorVersion() +
 								"]; user must register resolver or explicitly set 'hibernate.dialect'"
 				);
 			}
 
 			return dialect;
 		}
 		catch ( SQLException sqlException ) {
 			throw new HibernateException(
 					"Unable to access java.sql.DatabaseMetaData to determine appropriate Dialect to use",
 					sqlException
 			);
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/DialectFactoryInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/DialectFactoryInitiator.java
similarity index 85%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/DialectFactoryInitiator.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/DialectFactoryInitiator.java
index 0f2d7a3f05..a207465656 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/DialectFactoryInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/DialectFactoryInitiator.java
@@ -1,49 +1,49 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.dialect.internal;
+package org.hibernate.engine.jdbc.dialect.internal;
 
 import java.util.Map;
 
-import org.hibernate.service.jdbc.dialect.spi.DialectFactory;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.StandardServiceInitiator;
+import org.hibernate.engine.jdbc.dialect.spi.DialectFactory;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * Standard initiator for the standard {@link DialectFactory} service
  *
  * @author Steve Ebersole
  */
-public class DialectFactoryInitiator implements BasicServiceInitiator<DialectFactory> {
+public class DialectFactoryInitiator implements StandardServiceInitiator<DialectFactory> {
 	public static final DialectFactoryInitiator INSTANCE = new DialectFactoryInitiator();
 
 	@Override
 	public Class<DialectFactory> getServiceInitiated() {
 		return DialectFactory.class;
 	}
 
 	@Override
 	public DialectFactory initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		return new DialectFactoryImpl();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/DialectResolverInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/DialectResolverInitiator.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/DialectResolverInitiator.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/DialectResolverInitiator.java
index aba44b5bad..bd48a88630 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/DialectResolverInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/DialectResolverInitiator.java
@@ -1,80 +1,80 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.dialect.internal;
+package org.hibernate.engine.jdbc.dialect.internal;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.internal.util.StringHelper;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.jdbc.dialect.spi.DialectResolver;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.engine.jdbc.dialect.spi.DialectResolver;
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.service.spi.ServiceException;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * Standard initiator for the standard {@link DialectResolver} service
  *
  * @author Steve Ebersole
  */
-public class DialectResolverInitiator implements BasicServiceInitiator<DialectResolver> {
+public class DialectResolverInitiator implements StandardServiceInitiator<DialectResolver> {
 	public static final DialectResolverInitiator INSTANCE = new DialectResolverInitiator();
 
 	@Override
 	public Class<DialectResolver> getServiceInitiated() {
 		return DialectResolver.class;
 	}
 
 	@Override
 	public DialectResolver initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		return new DialectResolverSet( determineResolvers( configurationValues, registry ) );
 	}
 
 	private List<DialectResolver> determineResolvers(Map configurationValues, ServiceRegistryImplementor registry) {
 		final List<DialectResolver> resolvers = new ArrayList<DialectResolver>();
 
 		final String resolverImplNames = (String) configurationValues.get( AvailableSettings.DIALECT_RESOLVERS );
 
 		if ( StringHelper.isNotEmpty( resolverImplNames ) ) {
 			final ClassLoaderService classLoaderService = registry.getService( ClassLoaderService.class );
 			for ( String resolverImplName : StringHelper.split( ", \n\r\f\t", resolverImplNames ) ) {
 				try {
 					resolvers.add( (DialectResolver) classLoaderService.classForName( resolverImplName ).newInstance() );
 				}
 				catch (HibernateException e) {
 					throw e;
 				}
 				catch (Exception e) {
 					throw new ServiceException( "Unable to instantiate named dialect resolver [" + resolverImplName + "]", e );
 				}
 			}
 		}
 
 		resolvers.add( new StandardDialectResolver() );
 		return resolvers;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/DialectResolverSet.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/DialectResolverSet.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/DialectResolverSet.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/DialectResolverSet.java
index 8577d8cc1d..ed11ab2c5d 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/DialectResolverSet.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/DialectResolverSet.java
@@ -1,99 +1,99 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.dialect.internal;
+package org.hibernate.engine.jdbc.dialect.internal;
 
 import java.sql.DatabaseMetaData;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.List;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.exception.JDBCConnectionException;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.service.jdbc.dialect.spi.DialectResolver;
+import org.hibernate.engine.jdbc.dialect.spi.DialectResolver;
 
 /**
  * A {@link DialectResolver} implementation which coordinates resolution by delegating to sub-resolvers.
  *
  * @author Tomoto Shimizu Washio
  * @author Steve Ebersole
  */
 public class DialectResolverSet implements DialectResolver {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, DialectResolverSet.class.getName());
 
 	private List<DialectResolver> resolvers;
 
 	public DialectResolverSet() {
 		this( new ArrayList<DialectResolver>() );
 	}
 
 	public DialectResolverSet(List<DialectResolver> resolvers) {
 		this.resolvers = resolvers;
 	}
 
 	public DialectResolverSet(DialectResolver... resolvers) {
 		this( Arrays.asList( resolvers ) );
 	}
 
 	public Dialect resolveDialect(DatabaseMetaData metaData) throws JDBCConnectionException {
 		for ( DialectResolver resolver : resolvers ) {
 			try {
 				Dialect dialect = resolver.resolveDialect( metaData );
 				if ( dialect != null ) {
 					return dialect;
 				}
 			}
 			catch ( JDBCConnectionException e ) {
 				throw e;
 			}
 			catch ( Exception e ) {
                 LOG.exceptionInSubResolver(e.getMessage());
 			}
 		}
 		return null;
 	}
 
 	/**
 	 * Add a resolver at the end of the underlying resolver list.  The resolver added by this method is at lower
 	 * priority than any other existing resolvers.
 	 *
 	 * @param resolver The resolver to add.
 	 */
 	public void addResolver(DialectResolver resolver) {
 		resolvers.add( resolver );
 	}
 
 	/**
 	 * Add a resolver at the beginning of the underlying resolver list.  The resolver added by this method is at higher
 	 * priority than any other existing resolvers.
 	 *
 	 * @param resolver The resolver to add.
 	 */
 	public void addResolverAtFirst(DialectResolver resolver) {
 		resolvers.add( 0, resolver );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/StandardDialectResolver.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/StandardDialectResolver.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/StandardDialectResolver.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/StandardDialectResolver.java
index 3e6c4dba52..f26633f1ea 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/internal/StandardDialectResolver.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/internal/StandardDialectResolver.java
@@ -1,180 +1,180 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.dialect.internal;
+package org.hibernate.engine.jdbc.dialect.internal;
 
 import java.sql.DatabaseMetaData;
 import java.sql.SQLException;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.dialect.CUBRIDDialect;
 import org.hibernate.dialect.DB2400Dialect;
 import org.hibernate.dialect.DB2Dialect;
 import org.hibernate.dialect.DerbyDialect;
 import org.hibernate.dialect.DerbyTenFiveDialect;
 import org.hibernate.dialect.DerbyTenSevenDialect;
 import org.hibernate.dialect.DerbyTenSixDialect;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.InformixDialect;
 import org.hibernate.dialect.Ingres10Dialect;
 import org.hibernate.dialect.Ingres9Dialect;
 import org.hibernate.dialect.IngresDialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.Oracle10gDialect;
 import org.hibernate.dialect.Oracle8iDialect;
 import org.hibernate.dialect.Oracle9iDialect;
 import org.hibernate.dialect.PostgreSQL81Dialect;
 import org.hibernate.dialect.PostgreSQL82Dialect;
 import org.hibernate.dialect.SQLServer2005Dialect;
 import org.hibernate.dialect.SQLServer2008Dialect;
 import org.hibernate.dialect.SQLServerDialect;
 import org.hibernate.dialect.SybaseASE15Dialect;
 import org.hibernate.dialect.SybaseAnywhereDialect;
 import org.hibernate.internal.CoreMessageLogger;
 
 /**
  * The standard Hibernate Dialect resolver.
  *
  * @author Steve Ebersole
  */
 public class StandardDialectResolver extends AbstractDialectResolver {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        StandardDialectResolver.class.getName());
 
 	@Override
     protected Dialect resolveDialectInternal(DatabaseMetaData metaData) throws SQLException {
 		String databaseName = metaData.getDatabaseProductName();
 		int databaseMajorVersion = metaData.getDatabaseMajorVersion();
 
 		if ( "CUBRID".equalsIgnoreCase( databaseName ) ) {
 			return new CUBRIDDialect();
 		}
 
 		if ( "HSQL Database Engine".equals( databaseName ) ) {
 			return new HSQLDialect();
 		}
 
 		if ( "H2".equals( databaseName ) ) {
 			return new H2Dialect();
 		}
 
 		if ( "MySQL".equals( databaseName ) ) {
 			return new MySQLDialect();
 		}
 
 		if ( "PostgreSQL".equals( databaseName ) ) {
 			final int databaseMinorVersion = metaData.getDatabaseMinorVersion();
 			if (databaseMajorVersion >= 8 && databaseMinorVersion >= 2) {
 				return new PostgreSQL82Dialect();
 			}
 			return new PostgreSQL81Dialect();
 		}
 
 		if ( "Apache Derby".equals( databaseName ) ) {
 			final int databaseMinorVersion = metaData.getDatabaseMinorVersion();
             if ( databaseMajorVersion > 10 || ( databaseMajorVersion == 10 && databaseMinorVersion >= 7 ) ) {
 				return new DerbyTenSevenDialect();
 			}
 			else if ( databaseMajorVersion == 10 && databaseMinorVersion == 6 ) {
 				return new DerbyTenSixDialect();
 			}
 			else if ( databaseMajorVersion == 10 && databaseMinorVersion == 5 ) {
 				return new DerbyTenFiveDialect();
 			}
 			else {
 				return new DerbyDialect();
 			}
 		}
 
 		if ( "ingres".equalsIgnoreCase( databaseName ) ) {
             switch( databaseMajorVersion ) {
                 case 9:
                     int databaseMinorVersion = metaData.getDatabaseMinorVersion();
                     if (databaseMinorVersion > 2) {
                         return new Ingres9Dialect();
                     }
                     return new IngresDialect();
                 case 10:
                     return new Ingres10Dialect();
                 default:
                     LOG.unknownIngresVersion(databaseMajorVersion);
             }
 			return new IngresDialect();
 		}
 
 		if ( databaseName.startsWith( "Microsoft SQL Server" ) ) {
 			switch ( databaseMajorVersion ) {
                 case 8:
                     return new SQLServerDialect();
                 case 9:
                     return new SQLServer2005Dialect();
                 case 10:
                     return new SQLServer2008Dialect();
                 default:
                     LOG.unknownSqlServerVersion(databaseMajorVersion);
 			}
 			return new SQLServerDialect();
 		}
 
 		if ( "Sybase SQL Server".equals( databaseName ) || "Adaptive Server Enterprise".equals( databaseName ) ) {
 			return new SybaseASE15Dialect();
 		}
 
 		if ( databaseName.startsWith( "Adaptive Server Anywhere" ) ) {
 			return new SybaseAnywhereDialect();
 		}
 
 		if ( "Informix Dynamic Server".equals( databaseName ) ) {
 			return new InformixDialect();
 		}
 		
 		if ( databaseName.equals("DB2 UDB for AS/400" ) ) {
 			return new DB2400Dialect();
 		}
 
 		if ( databaseName.startsWith( "DB2/" ) ) {
 			return new DB2Dialect();
 		}
 
 		if ( "Oracle".equals( databaseName ) ) {
 			switch ( databaseMajorVersion ) {
 				case 11:
 					return new Oracle10gDialect();
 				case 10:
 					return new Oracle10gDialect();
 				case 9:
 					return new Oracle9iDialect();
 				case 8:
 					return new Oracle8iDialect();
 				default:
                     LOG.unknownOracleVersion(databaseMajorVersion);
 			}
 		}
 
 		return null;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/spi/DialectFactory.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/spi/DialectFactory.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/spi/DialectFactory.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/spi/DialectFactory.java
index 33e9c1dcad..876666d6da 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/spi/DialectFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/spi/DialectFactory.java
@@ -1,56 +1,56 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.dialect.spi;
+package org.hibernate.engine.jdbc.dialect.spi;
 
 import java.sql.Connection;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.service.Service;
 
 /**
  * A factory for generating Dialect instances.
  *
  * @author Steve Ebersole
  */
 public interface DialectFactory extends Service {
 	/**
 	 * Builds an appropriate Dialect instance.
 	 * <p/>
 	 * If a dialect is explicitly named in the incoming properties, it should used. Otherwise, it is
 	 * determined by dialect resolvers based on the passed connection.
 	 * <p/>
 	 * An exception is thrown if a dialect was not explicitly set and no resolver could make
 	 * the determination from the given connection.
 	 *
 	 * @param configValues The configuration properties.
 	 * @param connection The configured connection.
 	 *
 	 * @return The appropriate dialect instance.
 	 *
 	 * @throws HibernateException No dialect specified and no resolver could make the determination.
 	 */
 	public Dialect buildDialect(Map configValues, Connection connection) throws HibernateException;
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/spi/DialectResolver.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/spi/DialectResolver.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/spi/DialectResolver.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/spi/DialectResolver.java
index 1adfae2ecf..67ef46b4b2 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jdbc/dialect/spi/DialectResolver.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/dialect/spi/DialectResolver.java
@@ -1,52 +1,52 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jdbc.dialect.spi;
+package org.hibernate.engine.jdbc.dialect.spi;
 
 import java.sql.DatabaseMetaData;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.exception.JDBCConnectionException;
 import org.hibernate.service.Service;
 
 /**
  * Contract for determining the {@link Dialect} to use based on a JDBC {@link java.sql.Connection}.
  *
  * @author Tomoto Shimizu Washio
  * @author Steve Ebersole
  */
 public interface DialectResolver extends Service {
 	/**
 	 * Determine the {@link Dialect} to use based on the given JDBC {@link DatabaseMetaData}.  Implementations are
 	 * expected to return the {@link Dialect} instance to use, or null if the {@link DatabaseMetaData} does not match
 	 * the criteria handled by this impl.
 	 * 
 	 * @param metaData The JDBC metadata.
 	 *
 	 * @return The dialect to use, or null.
 	 *
 	 * @throws JDBCConnectionException Indicates a 'non transient connection problem', which indicates that
 	 * we should stop resolution attempts.
 	 */
 	public Dialect resolveDialect(DatabaseMetaData metaData) throws JDBCConnectionException;
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcServicesImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcServicesImpl.java
index 2b1c58ff02..3ded537eb0 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcServicesImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcServicesImpl.java
@@ -1,479 +1,479 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.internal;
 
 import java.lang.reflect.InvocationTargetException;
 import java.sql.Connection;
 import java.sql.DatabaseMetaData;
 import java.sql.ResultSet;
 import java.sql.SQLException;
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.Map;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.MultiTenancyStrategy;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.LobCreationContext;
 import org.hibernate.engine.jdbc.LobCreator;
 import org.hibernate.engine.jdbc.spi.ExtractedDatabaseMetaData;
 import org.hibernate.engine.jdbc.spi.JdbcConnectionAccess;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.ResultSetWrapper;
 import org.hibernate.engine.jdbc.spi.SchemaNameResolver;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.jdbc.spi.SqlStatementLogger;
 import org.hibernate.exception.internal.SQLExceptionTypeDelegate;
 import org.hibernate.exception.internal.SQLStateConversionDelegate;
 import org.hibernate.exception.internal.StandardSQLExceptionConverter;
 import org.hibernate.exception.spi.SQLExceptionConverter;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
-import org.hibernate.service.jdbc.connections.spi.MultiTenantConnectionProvider;
-import org.hibernate.service.jdbc.cursor.internal.StandardRefCursorSupport;
-import org.hibernate.service.jdbc.dialect.spi.DialectFactory;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
+import org.hibernate.engine.jdbc.cursor.internal.StandardRefCursorSupport;
+import org.hibernate.engine.jdbc.dialect.spi.DialectFactory;
 import org.hibernate.service.spi.Configurable;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * Standard implementation of the {@link JdbcServices} contract
  *
  * @author Steve Ebersole
  */
 public class JdbcServicesImpl implements JdbcServices, ServiceRegistryAwareService, Configurable {
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, JdbcServicesImpl.class.getName());
 
 	private ServiceRegistryImplementor serviceRegistry;
 
 	private Dialect dialect;
 	private ConnectionProvider connectionProvider;
 	private SqlStatementLogger sqlStatementLogger;
 	private SqlExceptionHelper sqlExceptionHelper;
 	private ExtractedDatabaseMetaData extractedMetaDataSupport;
 	private LobCreatorBuilder lobCreatorBuilder;
 
 	@Override
 	public void injectServices(ServiceRegistryImplementor serviceRegistry) {
 		this.serviceRegistry = serviceRegistry;
 	}
 
 	@Override
 	public void configure(Map configValues) {
 		final JdbcConnectionAccess jdbcConnectionAccess = buildJdbcConnectionAccess( configValues );
 		final DialectFactory dialectFactory = serviceRegistry.getService( DialectFactory.class );
 
 		Dialect dialect = null;
 		LobCreatorBuilder lobCreatorBuilder = null;
 
 		boolean metaSupportsRefCursors = false;
 		boolean metaSupportsNamedParams = false;
 		boolean metaSupportsScrollable = false;
 		boolean metaSupportsGetGeneratedKeys = false;
 		boolean metaSupportsBatchUpdates = false;
 		boolean metaReportsDDLCausesTxnCommit = false;
 		boolean metaReportsDDLInTxnSupported = true;
 		String extraKeywordsString = "";
 		int sqlStateType = -1;
 		boolean lobLocatorUpdateCopy = false;
 		String catalogName = null;
 		String schemaName = null;
 		LinkedHashSet<TypeInfo> typeInfoSet = new LinkedHashSet<TypeInfo>();
 
 		// 'hibernate.temp.use_jdbc_metadata_defaults' is a temporary magic value.
 		// The need for it is intended to be alleviated with future development, thus it is
 		// not defined as an Environment constant...
 		//
 		// it is used to control whether we should consult the JDBC metadata to determine
 		// certain Settings default values; it is useful to *not* do this when the database
 		// may not be available (mainly in tools usage).
 		boolean useJdbcMetadata = ConfigurationHelper.getBoolean( "hibernate.temp.use_jdbc_metadata_defaults", configValues, true );
 		if ( useJdbcMetadata ) {
 			try {
 				Connection connection = jdbcConnectionAccess.obtainConnection();
 				try {
 					DatabaseMetaData meta = connection.getMetaData();
 					if(LOG.isDebugEnabled()) {
 						LOG.debugf( "Database ->\n" + "       name : %s\n" + "    version : %s\n" + "      major : %s\n" + "      minor : %s",
 									meta.getDatabaseProductName(),
 									meta.getDatabaseProductVersion(),
 									meta.getDatabaseMajorVersion(),
 									meta.getDatabaseMinorVersion()
 						);
 						LOG.debugf( "Driver ->\n" + "       name : %s\n" + "    version : %s\n" + "      major : %s\n" + "      minor : %s",
 									meta.getDriverName(),
 									meta.getDriverVersion(),
 									meta.getDriverMajorVersion(),
 									meta.getDriverMinorVersion()
 						);
 						LOG.debugf( "JDBC version : %s.%s", meta.getJDBCMajorVersion(), meta.getJDBCMinorVersion() );
 					}
 
 					metaSupportsRefCursors = StandardRefCursorSupport.supportsRefCursors( meta );
 					metaSupportsNamedParams = meta.supportsNamedParameters();
 					metaSupportsScrollable = meta.supportsResultSetType( ResultSet.TYPE_SCROLL_INSENSITIVE );
 					metaSupportsBatchUpdates = meta.supportsBatchUpdates();
 					metaReportsDDLCausesTxnCommit = meta.dataDefinitionCausesTransactionCommit();
 					metaReportsDDLInTxnSupported = !meta.dataDefinitionIgnoredInTransactions();
 					metaSupportsGetGeneratedKeys = meta.supportsGetGeneratedKeys();
 					extraKeywordsString = meta.getSQLKeywords();
 					sqlStateType = meta.getSQLStateType();
 					lobLocatorUpdateCopy = meta.locatorsUpdateCopy();
 					typeInfoSet.addAll( TypeInfoExtracter.extractTypeInfo( meta ) );
 
 					dialect = dialectFactory.buildDialect( configValues, connection );
 
 					catalogName = connection.getCatalog();
 					SchemaNameResolver schemaNameResolver = determineExplicitSchemaNameResolver( configValues );
 					if ( schemaNameResolver == null ) {
 // todo : add dialect method
 //						schemaNameResolver = dialect.getSchemaNameResolver();
 					}
 					if ( schemaNameResolver != null ) {
 						schemaName = schemaNameResolver.resolveSchemaName( connection );
 					}
 					lobCreatorBuilder = new LobCreatorBuilder( configValues, connection );
 				}
 				catch ( SQLException sqle ) {
 					LOG.unableToObtainConnectionMetadata( sqle.getMessage() );
 				}
 				finally {
 					if ( connection != null ) {
 						jdbcConnectionAccess.releaseConnection( connection );
 					}
 				}
 			}
 			catch ( SQLException sqle ) {
 				LOG.unableToObtainConnectionToQueryMetadata( sqle.getMessage() );
 				dialect = dialectFactory.buildDialect( configValues, null );
 			}
 			catch ( UnsupportedOperationException uoe ) {
 				// user supplied JDBC connections
 				dialect = dialectFactory.buildDialect( configValues, null );
 			}
 		}
 		else {
 			dialect = dialectFactory.buildDialect( configValues, null );
 		}
 
 		final boolean showSQL = ConfigurationHelper.getBoolean( Environment.SHOW_SQL, configValues, false );
 		final boolean formatSQL = ConfigurationHelper.getBoolean( Environment.FORMAT_SQL, configValues, false );
 
 		this.dialect = dialect;
 		this.lobCreatorBuilder = (
 				lobCreatorBuilder == null ?
 						new LobCreatorBuilder( configValues, null ) :
 						lobCreatorBuilder
 		);
 
 		this.sqlStatementLogger =  new SqlStatementLogger( showSQL, formatSQL );
 
 		this.extractedMetaDataSupport = new ExtractedDatabaseMetaDataImpl(
 				metaSupportsRefCursors,
 				metaSupportsNamedParams,
 				metaSupportsScrollable,
 				metaSupportsGetGeneratedKeys,
 				metaSupportsBatchUpdates,
 				metaReportsDDLInTxnSupported,
 				metaReportsDDLCausesTxnCommit,
 				parseKeywords( extraKeywordsString ),
 				parseSQLStateType( sqlStateType ),
 				lobLocatorUpdateCopy,
 				schemaName,
 				catalogName,
 				typeInfoSet
 		);
 
 		SQLExceptionConverter sqlExceptionConverter = dialect.buildSQLExceptionConverter();
 		if ( sqlExceptionConverter == null ) {
 			final StandardSQLExceptionConverter converter = new StandardSQLExceptionConverter();
 			sqlExceptionConverter = converter;
 			converter.addDelegate( dialect.buildSQLExceptionConversionDelegate() );
 			converter.addDelegate( new SQLExceptionTypeDelegate( dialect ) );
 			// todo : vary this based on extractedMetaDataSupport.getSqlStateType()
 			converter.addDelegate( new SQLStateConversionDelegate( dialect ) );
 		}
 		this.sqlExceptionHelper = new SqlExceptionHelper( sqlExceptionConverter );
 	}
 
 	private JdbcConnectionAccess buildJdbcConnectionAccess(Map configValues) {
 		final MultiTenancyStrategy multiTenancyStrategy = MultiTenancyStrategy.determineMultiTenancyStrategy( configValues );
 
 		if ( MultiTenancyStrategy.NONE == multiTenancyStrategy ) {
 			connectionProvider = serviceRegistry.getService( ConnectionProvider.class );
 			return new ConnectionProviderJdbcConnectionAccess( connectionProvider );
 		}
 		else {
 			connectionProvider = null;
 			final MultiTenantConnectionProvider multiTenantConnectionProvider = serviceRegistry.getService( MultiTenantConnectionProvider.class );
 			return new MultiTenantConnectionProviderJdbcConnectionAccess( multiTenantConnectionProvider );
 		}
 	}
 
 	private static class ConnectionProviderJdbcConnectionAccess implements JdbcConnectionAccess {
 		private final ConnectionProvider connectionProvider;
 
 		public ConnectionProviderJdbcConnectionAccess(ConnectionProvider connectionProvider) {
 			this.connectionProvider = connectionProvider;
 		}
 
 		@Override
 		public Connection obtainConnection() throws SQLException {
 			return connectionProvider.getConnection();
 		}
 
 		@Override
 		public void releaseConnection(Connection connection) throws SQLException {
 			connectionProvider.closeConnection( connection );
 		}
 
 		@Override
 		public boolean supportsAggressiveRelease() {
 			return connectionProvider.supportsAggressiveRelease();
 		}
 	}
 
 	private static class MultiTenantConnectionProviderJdbcConnectionAccess implements JdbcConnectionAccess {
 		private final MultiTenantConnectionProvider connectionProvider;
 
 		public MultiTenantConnectionProviderJdbcConnectionAccess(MultiTenantConnectionProvider connectionProvider) {
 			this.connectionProvider = connectionProvider;
 		}
 
 		@Override
 		public Connection obtainConnection() throws SQLException {
 			return connectionProvider.getAnyConnection();
 		}
 
 		@Override
 		public void releaseConnection(Connection connection) throws SQLException {
 			connectionProvider.releaseAnyConnection( connection );
 		}
 
 		@Override
 		public boolean supportsAggressiveRelease() {
 			return connectionProvider.supportsAggressiveRelease();
 		}
 	}
 
 
 	// todo : add to Environment
 	public static final String SCHEMA_NAME_RESOLVER = "hibernate.schema_name_resolver";
 
 	private SchemaNameResolver determineExplicitSchemaNameResolver(Map configValues) {
 		Object setting = configValues.get( SCHEMA_NAME_RESOLVER );
 		if ( SchemaNameResolver.class.isInstance( setting ) ) {
 			return (SchemaNameResolver) setting;
 		}
 
 		String resolverClassName = (String) setting;
 		if ( resolverClassName != null ) {
 			try {
 				Class resolverClass = ReflectHelper.classForName( resolverClassName, getClass() );
 				return (SchemaNameResolver) ReflectHelper.getDefaultConstructor( resolverClass ).newInstance();
 			}
 			catch ( ClassNotFoundException e ) {
 				LOG.unableToLocateConfiguredSchemaNameResolver( resolverClassName, e.toString() );
 			}
 			catch ( InvocationTargetException e ) {
 				LOG.unableToInstantiateConfiguredSchemaNameResolver( resolverClassName, e.getTargetException().toString() );
 			}
 			catch ( Exception e ) {
 				LOG.unableToInstantiateConfiguredSchemaNameResolver( resolverClassName, e.toString() );
 			}
 		}
 		return null;
 	}
 
 	private Set<String> parseKeywords(String extraKeywordsString) {
 		Set<String> keywordSet = new HashSet<String>();
 		keywordSet.addAll( Arrays.asList( extraKeywordsString.split( "," ) ) );
 		return keywordSet;
 	}
 
 	private ExtractedDatabaseMetaData.SQLStateType parseSQLStateType(int sqlStateType) {
 		switch ( sqlStateType ) {
 			case DatabaseMetaData.sqlStateSQL99 : {
 				return ExtractedDatabaseMetaData.SQLStateType.SQL99;
 			}
 			case DatabaseMetaData.sqlStateXOpen : {
 				return ExtractedDatabaseMetaData.SQLStateType.XOpen;
 			}
 			default : {
 				return ExtractedDatabaseMetaData.SQLStateType.UNKOWN;
 			}
 		}
 	}
 
 	private static class ExtractedDatabaseMetaDataImpl implements ExtractedDatabaseMetaData {
 		private final boolean supportsRefCursors;
 		private final boolean supportsNamedParameters;
 		private final boolean supportsScrollableResults;
 		private final boolean supportsGetGeneratedKeys;
 		private final boolean supportsBatchUpdates;
 		private final boolean supportsDataDefinitionInTransaction;
 		private final boolean doesDataDefinitionCauseTransactionCommit;
 		private final Set<String> extraKeywords;
 		private final SQLStateType sqlStateType;
 		private final boolean lobLocatorUpdateCopy;
 		private final String connectionSchemaName;
 		private final String connectionCatalogName;
 		private final LinkedHashSet<TypeInfo> typeInfoSet;
 
 		private ExtractedDatabaseMetaDataImpl(
 				boolean supportsRefCursors,
 				boolean supportsNamedParameters,
 				boolean supportsScrollableResults,
 				boolean supportsGetGeneratedKeys,
 				boolean supportsBatchUpdates,
 				boolean supportsDataDefinitionInTransaction,
 				boolean doesDataDefinitionCauseTransactionCommit,
 				Set<String> extraKeywords,
 				SQLStateType sqlStateType,
 				boolean lobLocatorUpdateCopy,
 				String connectionSchemaName,
 				String connectionCatalogName,
 				LinkedHashSet<TypeInfo> typeInfoSet) {
 			this.supportsRefCursors = supportsRefCursors;
 			this.supportsNamedParameters = supportsNamedParameters;
 			this.supportsScrollableResults = supportsScrollableResults;
 			this.supportsGetGeneratedKeys = supportsGetGeneratedKeys;
 			this.supportsBatchUpdates = supportsBatchUpdates;
 			this.supportsDataDefinitionInTransaction = supportsDataDefinitionInTransaction;
 			this.doesDataDefinitionCauseTransactionCommit = doesDataDefinitionCauseTransactionCommit;
 			this.extraKeywords = extraKeywords;
 			this.sqlStateType = sqlStateType;
 			this.lobLocatorUpdateCopy = lobLocatorUpdateCopy;
 			this.connectionSchemaName = connectionSchemaName;
 			this.connectionCatalogName = connectionCatalogName;
 			this.typeInfoSet = typeInfoSet;
 		}
 
 		@Override
 		public boolean supportsRefCursors() {
 			return supportsRefCursors;
 		}
 
 		@Override
 		public boolean supportsNamedParameters() {
 			return supportsNamedParameters;
 		}
 
 		@Override
 		public boolean supportsScrollableResults() {
 			return supportsScrollableResults;
 		}
 
 		@Override
 		public boolean supportsGetGeneratedKeys() {
 			return supportsGetGeneratedKeys;
 		}
 
 		@Override
 		public boolean supportsBatchUpdates() {
 			return supportsBatchUpdates;
 		}
 
 		@Override
 		public boolean supportsDataDefinitionInTransaction() {
 			return supportsDataDefinitionInTransaction;
 		}
 
 		@Override
 		public boolean doesDataDefinitionCauseTransactionCommit() {
 			return doesDataDefinitionCauseTransactionCommit;
 		}
 
 		@Override
 		public Set<String> getExtraKeywords() {
 			return extraKeywords;
 		}
 
 		@Override
 		public SQLStateType getSqlStateType() {
 			return sqlStateType;
 		}
 
 		@Override
 		public boolean doesLobLocatorUpdateCopy() {
 			return lobLocatorUpdateCopy;
 		}
 
 		@Override
 		public String getConnectionSchemaName() {
 			return connectionSchemaName;
 		}
 
 		@Override
 		public String getConnectionCatalogName() {
 			return connectionCatalogName;
 		}
 
 		@Override
 		public LinkedHashSet<TypeInfo> getTypeInfoSet() {
 			return typeInfoSet;
 		}
 	}
 
 	@Override
 	public ConnectionProvider getConnectionProvider() {
 		return connectionProvider;
 	}
 
 	@Override
 	public SqlStatementLogger getSqlStatementLogger() {
 		return sqlStatementLogger;
 	}
 
 	@Override
 	public SqlExceptionHelper getSqlExceptionHelper() {
 		return sqlExceptionHelper;
 	}
 
 	@Override
 	public Dialect getDialect() {
 		return dialect;
 	}
 
 	@Override
 	public ExtractedDatabaseMetaData getExtractedMetaDataSupport() {
 		return extractedMetaDataSupport;
 	}
 
 	@Override
 	public LobCreator getLobCreator(LobCreationContext lobCreationContext) {
 		return lobCreatorBuilder.buildLobCreator( lobCreationContext );
 	}
 
 	@Override
 	public ResultSetWrapper getResultSetWrapper() {
 		return ResultSetWrapperImpl.INSTANCE;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcServicesInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcServicesInitiator.java
index c404917a30..a1704b075a 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcServicesInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/internal/JdbcServicesInitiator.java
@@ -1,51 +1,51 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.internal;
 
 import java.util.Map;
 
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
-import org.hibernate.service.spi.BasicServiceInitiator;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * Standard initiator for the standard {@link JdbcServices} service
  *
  * @todo : should this maybe be a SessionFactory service?
  *
  * @author Steve Ebersole
  */
-public class JdbcServicesInitiator implements BasicServiceInitiator<JdbcServices> {
+public class JdbcServicesInitiator implements StandardServiceInitiator<JdbcServices> {
 	public static final JdbcServicesInitiator INSTANCE = new JdbcServicesInitiator();
 
 	@Override
 	public Class<JdbcServices> getServiceInitiated() {
 		return JdbcServices.class;
 	}
 
 	@Override
 	public JdbcServices initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		return new JdbcServicesImpl();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcConnectionAccess.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcConnectionAccess.java
index 7256322d77..cb19212967 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcConnectionAccess.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcConnectionAccess.java
@@ -1,63 +1,63 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.spi;
 
 import java.io.Serializable;
 import java.sql.Connection;
 import java.sql.SQLException;
 
 /**
  * Provides centralized access to JDBC connections.  Centralized to hide the complexity of accounting for contextual
  * (multi-tenant) versus non-contextual access.
  *
  * @author Steve Ebersole
  */
 public interface JdbcConnectionAccess extends Serializable {
 	/**
 	 * Obtain a JDBC connection
 	 *
 	 * @return The obtained connection
 	 *
 	 * @throws SQLException Indicates a problem getting the connection
 	 */
 	public Connection obtainConnection() throws SQLException;
 
 	/**
 	 * Release a previously obtained connection
 	 *
 	 * @param connection The connection to release
 	 *
 	 * @throws SQLException Indicates a problem releasing the connection
 	 */
 	public void releaseConnection(Connection connection) throws SQLException;
 
 	/**
 	 * Does the underlying provider of connections support aggressive releasing of connections (and re-acquisition
 	 * of those connections later, if need be) in JTA environments?
 	 *
-	 * @see org.hibernate.service.jdbc.connections.spi.ConnectionProvider#supportsAggressiveRelease()
-	 * @see org.hibernate.service.jdbc.connections.spi.MultiTenantConnectionProvider#supportsAggressiveRelease()
+	 * @see org.hibernate.engine.jdbc.connections.spi.ConnectionProvider#supportsAggressiveRelease()
+	 * @see org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider#supportsAggressiveRelease()
 	 */
 	public boolean supportsAggressiveRelease();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcServices.java b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcServices.java
index 3ff092d19e..1580733fcb 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcServices.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jdbc/spi/JdbcServices.java
@@ -1,95 +1,95 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.jdbc.spi;
 
 import java.sql.ResultSet;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.LobCreationContext;
 import org.hibernate.engine.jdbc.LobCreator;
 import org.hibernate.service.Service;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 
 /**
  * Contract for services around JDBC operations.  These represent shared resources, aka not varied by session/use.
  *
  * @author Steve Ebersole
  */
 public interface JdbcServices extends Service {
 	/**
 	 * Obtain service for providing JDBC connections.
 	 *
 	 * @return The connection provider.
 	 *
 	 * @deprecated See deprecation notice on {@link org.hibernate.engine.spi.SessionFactoryImplementor#getConnectionProvider()}
 	 * for details
 	 */
 	@Deprecated
 	public ConnectionProvider getConnectionProvider();
 
 	/**
 	 * Obtain the dialect of the database.
 	 *
 	 * @return The database dialect.
 	 */
 	public Dialect getDialect();
 
 	/**
 	 * Obtain service for logging SQL statements.
 	 *
 	 * @return The SQL statement logger.
 	 */
 	public SqlStatementLogger getSqlStatementLogger();
 
 	/**
 	 * Obtain service for dealing with exceptions.
 	 *
 	 * @return The exception helper service.
 	 */
 	public SqlExceptionHelper getSqlExceptionHelper();
 
 	/**
 	 * Obtain information about supported behavior reported by the JDBC driver.
 	 * <p/>
 	 * Yuck, yuck, yuck!  Much prefer this to be part of a "basic settings" type object.
 	 * 
 	 * @return The extracted database metadata, oddly enough :)
 	 */
 	public ExtractedDatabaseMetaData getExtractedMetaDataSupport();
 
 	/**
 	 * Create an instance of a {@link LobCreator} appropriate for the current environment, mainly meant to account for
 	 * variance between JDBC 4 (<= JDK 1.6) and JDBC3 (>= JDK 1.5).
 	 *
 	 * @param lobCreationContext The context in which the LOB is being created
 	 * @return The LOB creator.
 	 */
 	public LobCreator getLobCreator(LobCreationContext lobCreationContext);
 
 	/**
 	 * Obtain service for wrapping a {@link ResultSet} in a "column name cache" wrapper.
 	 * @return The ResultSet wrapper.
 	 */
 	public ResultSetWrapper getResultSetWrapper();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jndi/JndiException.java b/hibernate-core/src/main/java/org/hibernate/engine/jndi/JndiException.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/service/jndi/JndiException.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jndi/JndiException.java
index 13431d4a7a..b7047ddbc1 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jndi/JndiException.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jndi/JndiException.java
@@ -1,36 +1,36 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jndi;
+package org.hibernate.engine.jndi;
 import org.hibernate.HibernateException;
 
 /**
  * An exception indicating trouble accessing JNDI
  *
  * @author Steve Ebersole
  */
 public class JndiException extends HibernateException {
 	public JndiException(String string, Throwable root) {
 		super( string, root );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jndi/JndiNameException.java b/hibernate-core/src/main/java/org/hibernate/engine/jndi/JndiNameException.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/service/jndi/JndiNameException.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jndi/JndiNameException.java
index 526a18276c..6114c6dbfa 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jndi/JndiNameException.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jndi/JndiNameException.java
@@ -1,37 +1,37 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jndi;
+package org.hibernate.engine.jndi;
 
 import org.hibernate.HibernateException;
 
 /**
  * Indicates a problem with a given JNDI name being deemed as not valid.
  *
  * @author Steve Ebersole
  */
 public class JndiNameException extends HibernateException {
 	public JndiNameException(String string, Throwable root) {
 		super( string, root );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jndi/internal/JndiServiceImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/jndi/internal/JndiServiceImpl.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/service/jndi/internal/JndiServiceImpl.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jndi/internal/JndiServiceImpl.java
index d149f2ce67..86a0882450 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jndi/internal/JndiServiceImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jndi/internal/JndiServiceImpl.java
@@ -1,203 +1,203 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jndi.internal;
+package org.hibernate.engine.jndi.internal;
 
 import java.util.Hashtable;
 import java.util.Map;
 import javax.naming.Context;
 import javax.naming.InitialContext;
 import javax.naming.InvalidNameException;
 import javax.naming.Name;
 import javax.naming.NameNotFoundException;
 import javax.naming.NamingException;
 import javax.naming.event.EventContext;
 import javax.naming.event.NamespaceChangeListener;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.jndi.JndiHelper;
-import org.hibernate.service.jndi.JndiException;
-import org.hibernate.service.jndi.JndiNameException;
-import org.hibernate.service.jndi.spi.JndiService;
+import org.hibernate.engine.jndi.JndiException;
+import org.hibernate.engine.jndi.JndiNameException;
+import org.hibernate.engine.jndi.spi.JndiService;
 
 /**
  * Standard implementation of JNDI services.
  *
  * @author Steve Ebersole
  */
 public class JndiServiceImpl implements JndiService {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, JndiServiceImpl.class.getName());
 
 	private final Hashtable initialContextSettings;
 
 	public JndiServiceImpl(Map configurationValues) {
 		this.initialContextSettings = JndiHelper.extractJndiProperties( configurationValues );
 	}
 
 	@Override
 	public Object locate(String jndiName) {
 		InitialContext initialContext = buildInitialContext();
 		Name name = parseName( jndiName, initialContext );
 		try {
 			return initialContext.lookup( name );
 		}
 		catch ( NamingException e ) {
 			throw new JndiException( "Unable to lookup JNDI name [" + jndiName + "]", e );
 		}
 		finally {
 			cleanUp( initialContext );
 		}
 	}
 
 	private InitialContext buildInitialContext() {
 		try {
 			return initialContextSettings.size() == 0 ? new InitialContext() : new InitialContext( initialContextSettings );
 		}
 		catch ( NamingException e ) {
 			throw new JndiException( "Unable to open InitialContext", e );
 		}
 	}
 
 	private Name parseName(String jndiName, Context context) {
 		try {
 			return context.getNameParser( "" ).parse( jndiName );
 		}
 		catch ( InvalidNameException e ) {
 			throw new JndiNameException( "JNDI name [" + jndiName + "] was not valid", e );
 		}
 		catch ( NamingException e ) {
 			throw new JndiException( "Error parsing JNDI name [" + jndiName + "]", e );
 		}
 	}
 
 	private void cleanUp(InitialContext initialContext) {
 		try {
 			initialContext.close();
 		}
 		catch ( NamingException e ) {
 			LOG.unableToCloseInitialContext(e.toString());
 		}
 	}
 
 	@Override
 	public void bind(String jndiName, Object value) {
 		InitialContext initialContext = buildInitialContext();
 		Name name = parseName( jndiName, initialContext );
 		try {
 			bind( name, value, initialContext );
 		}
 		finally {
 			cleanUp( initialContext );
 		}
 	}
 
 	private void bind(Name name, Object value, Context context) {
 		try {
 			LOG.tracef( "Binding : %s", name );
 			context.rebind( name, value );
 		}
 		catch ( Exception initialException ) {
 			// We had problems doing a simple bind operation.
 			if ( name.size() == 1 ) {
 				// if the jndi name had only 1 component there is nothing more we can do...
 				throw new JndiException( "Error performing bind [" + name + "]", initialException );
 			}
 
 			// Otherwise, there is a good chance this may have been caused by missing intermediate contexts.  So we
 			// attempt to create those missing intermediate contexts and bind again
 			Context intermediateContextBase = context;
 			while ( name.size() > 1 ) {
 				final String intermediateContextName = name.get( 0 );
 
 				Context intermediateContext = null;
 				try {
 					LOG.tracev( "Intermediate lookup: {0}", intermediateContextName );
 					intermediateContext = (Context) intermediateContextBase.lookup( intermediateContextName );
 				}
 				catch ( NameNotFoundException handledBelow ) {
 					// ok as we will create it below if not found
 				}
 				catch ( NamingException e ) {
 					throw new JndiException( "Unanticipated error doing intermediate lookup", e );
 				}
 
 				if ( intermediateContext != null ) {
 					LOG.tracev( "Found intermediate context: {0}", intermediateContextName );
 				}
 				else {
 					LOG.tracev( "Creating sub-context: {0}", intermediateContextName );
 					try {
 						intermediateContext = intermediateContextBase.createSubcontext( intermediateContextName );
 					}
 					catch ( NamingException e ) {
 						throw new JndiException( "Error creating intermediate context [" + intermediateContextName + "]", e );
 					}
 				}
 				intermediateContextBase = intermediateContext;
 				name = name.getSuffix( 1 );
 			}
 			LOG.tracev( "Binding : {0}", name );
 			try {
 				intermediateContextBase.rebind( name, value );
 			}
 			catch ( NamingException e ) {
 				throw new JndiException( "Error performing intermediate bind [" + name + "]", e );
 			}
 		}
 		LOG.debugf( "Bound name: %s", name );
 	}
 
 	@Override
 	public void unbind(String jndiName) {
 		InitialContext initialContext = buildInitialContext();
 		Name name = parseName( jndiName, initialContext );
 		try {
 			initialContext.unbind( name );
 		}
 		catch (Exception e) {
 			throw new JndiException( "Error performing unbind [" + name + "]", e );
 		}
 		finally {
 			cleanUp( initialContext );
 		}
 	}
 
 	@Override
 	public void addListener(String jndiName, NamespaceChangeListener listener) {
 		InitialContext initialContext = buildInitialContext();
 		Name name = parseName( jndiName, initialContext );
 		try {
 			( (EventContext) initialContext ).addNamingListener( name, EventContext.OBJECT_SCOPE, listener );
 		}
 		catch (Exception e) {
 			throw new JndiException( "Unable to bind listener to namespace [" + name + "]", e );
 		}
 		finally {
 			cleanUp( initialContext );
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jndi/internal/JndiServiceInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/jndi/internal/JndiServiceInitiator.java
similarity index 86%
rename from hibernate-core/src/main/java/org/hibernate/service/jndi/internal/JndiServiceInitiator.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jndi/internal/JndiServiceInitiator.java
index 5cd32042bb..3280c04b26 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jndi/internal/JndiServiceInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jndi/internal/JndiServiceInitiator.java
@@ -1,49 +1,49 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jndi.internal;
+package org.hibernate.engine.jndi.internal;
 
 import java.util.Map;
 
-import org.hibernate.service.jndi.spi.JndiService;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.engine.jndi.spi.JndiService;
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * Standard initiator for the standard {@link JndiService} service
  *
  * @author Steve Ebersole
  */
-public class JndiServiceInitiator implements BasicServiceInitiator<JndiService> {
+public class JndiServiceInitiator implements StandardServiceInitiator<JndiService> {
 	public static final JndiServiceInitiator INSTANCE = new JndiServiceInitiator();
 
 	@Override
 	public Class<JndiService> getServiceInitiated() {
 		return JndiService.class;
 	}
 
 	@Override
 	public JndiService initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		return new JndiServiceImpl( configurationValues );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jndi/spi/JndiService.java b/hibernate-core/src/main/java/org/hibernate/engine/jndi/spi/JndiService.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/service/jndi/spi/JndiService.java
rename to hibernate-core/src/main/java/org/hibernate/engine/jndi/spi/JndiService.java
index 3e01849149..95905dd720 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jndi/spi/JndiService.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/jndi/spi/JndiService.java
@@ -1,67 +1,67 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jndi.spi;
+package org.hibernate.engine.jndi.spi;
 
 import javax.naming.event.NamespaceChangeListener;
 
 import org.hibernate.service.Service;
 
 /**
  * Service providing simplified access to {@literal JNDI} related features needed by Hibernate.
  *
  * @author Steve Ebersole
  */
 public interface JndiService extends Service {
 	/**
 	 * Locate an object in {@literal JNDI} by name
 	 *
 	 * @param jndiName The {@literal JNDI} name of the object to locate
 	 *
 	 * @return The object found (may be null).
 	 */
 	public Object locate(String jndiName);
 
 	/**
 	 * Binds a value into {@literal JNDI} by name.
 	 *
 	 * @param jndiName The name under which to bind the object
 	 * @param value The value to bind
 	 */
 	public void bind(String jndiName, Object value);
 
 	/**
 	 * Unbind a value from {@literal JNDI} by name.
 	 *
 	 * @param jndiName The name under which the object is bound
 	 */
 	public void unbind(String jndiName);
 
 	/**
 	 * Adds the specified listener to the given {@literal JNDI} namespace.
 	 *
 	 * @param jndiName The {@literal JNDI} namespace
 	 * @param listener The listener
 	 */
 	public void addListener(String jndiName, NamespaceChangeListener listener);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/spi/SessionFactoryImplementor.java b/hibernate-core/src/main/java/org/hibernate/engine/spi/SessionFactoryImplementor.java
index 7922d2bc99..d86f6e4cf2 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/spi/SessionFactoryImplementor.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/spi/SessionFactoryImplementor.java
@@ -1,284 +1,284 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.spi;
 
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 
 import org.hibernate.CustomEntityDirtinessStrategy;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.MappingException;
 import org.hibernate.Session;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.cache.spi.QueryCache;
 import org.hibernate.cache.spi.Region;
 import org.hibernate.cache.spi.UpdateTimestampsCache;
 import org.hibernate.cfg.Settings;
 import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.function.SQLFunctionRegistry;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.profile.FetchProfile;
 import org.hibernate.engine.query.spi.QueryPlanCache;
 import org.hibernate.exception.spi.SQLExceptionConverter;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.proxy.EntityNotFoundDelegate;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.stat.spi.StatisticsImplementor;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeResolver;
 
 /**
  * Defines the internal contract between the <tt>SessionFactory</tt> and other parts of
  * Hibernate such as implementors of <tt>Type</tt>.
  *
  * @see org.hibernate.SessionFactory
  * @see org.hibernate.internal.SessionFactoryImpl
  * @author Gavin King
  */
 public interface SessionFactoryImplementor extends Mapping, SessionFactory {
 	@Override
 	public SessionBuilderImplementor withOptions();
 
 	/**
 	 * Retrieve the {@link Type} resolver associated with this factory.
 	 *
 	 * @return The type resolver
 	 */
 	public TypeResolver getTypeResolver();
 
 	/**
 	 * Get a copy of the Properties used to configure this session factory.
 	 *
 	 * @return The properties.
 	 */
 	public Properties getProperties();
 
 	/**
 	 * Get the persister for the named entity
 	 *
 	 * @param entityName The name of the entity for which to retrieve the persister.
 	 * @return The persister
 	 * @throws MappingException Indicates persister could not be found with that name.
 	 */
 	public EntityPersister getEntityPersister(String entityName) throws MappingException;
 
 	/**
 	 * Get all entity persisters as a Map, which entity name its the key and the persister is the value.
 	 *
 	 * @return The Map contains all entity persisters.
 	 */
 	public Map<String,EntityPersister> getEntityPersisters();
 
 	/**
 	 * Get the persister object for a collection role.
 	 *
 	 * @param role The role (name) of the collection for which to retrieve the
 	 * persister.
 	 * @return The persister
 	 * @throws MappingException Indicates persister could not be found with that role.
 	 */
 	public CollectionPersister getCollectionPersister(String role) throws MappingException;
 
 	/**
 	 * Get all collection persisters as a Map, which collection role as the key and the persister is the value.
 	 *
 	 * @return The Map contains all collection persisters.
 	 */
 	public Map<String, CollectionPersister> getCollectionPersisters();
 
 	/**
 	 * Get the JdbcServices.
 	 * @return the JdbcServices
 	 */
 	public JdbcServices getJdbcServices();
 
 	/**
 	 * Get the SQL dialect.
 	 * <p/>
 	 * Shorthand for {@code getJdbcServices().getDialect()}
 	 *
 	 * @return The dialect
 	 */
 	public Dialect getDialect();
 
 	/**
 	 * Get the factory scoped interceptor for this factory.
 	 *
 	 * @return The factory scope interceptor, or null if none.
 	 */
 	public Interceptor getInterceptor();
 
 	public QueryPlanCache getQueryPlanCache();
 
 	/**
 	 * Get the return types of a query
 	 */
 	public Type[] getReturnTypes(String queryString) throws HibernateException;
 
 	/**
 	 * Get the return aliases of a query
 	 */
 	public String[] getReturnAliases(String queryString) throws HibernateException;
 
 	/**
 	 * Get the connection provider
 	 *
 	 * @deprecated Access to connections via {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} should
 	 * be preferred over access via {@link ConnectionProvider}, whenever possible.
 	 * {@link org.hibernate.engine.jdbc.spi.JdbcConnectionAccess} is tied to the Hibernate Session to
 	 * properly account for contextual information.  See {@link SessionImplementor#getJdbcConnectionAccess()}
 	 */
 	@Deprecated
 	public ConnectionProvider getConnectionProvider();
 	/**
 	 * Get the names of all persistent classes that implement/extend the given interface/class
 	 */
 	public String[] getImplementors(String className) throws MappingException;
 	/**
 	 * Get a class name, using query language imports
 	 */
 	public String getImportedClassName(String name);
 
 	/**
 	 * Get the default query cache
 	 */
 	public QueryCache getQueryCache();
 	/**
 	 * Get a particular named query cache, or the default cache
 	 * @param regionName the name of the cache region, or null for the default query cache
 	 * @return the existing cache, or a newly created cache if none by that region name
 	 */
 	public QueryCache getQueryCache(String regionName) throws HibernateException;
 
 	/**
 	 * Get the cache of table update timestamps
 	 */
 	public UpdateTimestampsCache getUpdateTimestampsCache();
 	/**
 	 * Statistics SPI
 	 */
 	public StatisticsImplementor getStatisticsImplementor();
 
 	public NamedQueryDefinition getNamedQuery(String queryName);
 
 	public void registerNamedQueryDefinition(String name, NamedQueryDefinition definition);
 
 	public NamedSQLQueryDefinition getNamedSQLQuery(String queryName);
 
 	public void registerNamedSQLQueryDefinition(String name, NamedSQLQueryDefinition definition);
 
 	public ResultSetMappingDefinition getResultSetMapping(String name);
 
 	/**
 	 * Get the identifier generator for the hierarchy
 	 */
 	public IdentifierGenerator getIdentifierGenerator(String rootEntityName);
 
 	/**
 	 * Get a named second-level cache region
 	 *
 	 * @param regionName The name of the region to retrieve.
 	 * @return The region
 	 */
 	public Region getSecondLevelCacheRegion(String regionName);
 	
 	/**
 	 * Get a named naturalId cache region
 	 *
 	 * @param regionName The name of the region to retrieve.
 	 * @return The region
 	 */
 	public Region getNaturalIdCacheRegion(String regionName);
 
 	/**
 	 * Get a map of all the second level cache regions currently maintained in
 	 * this session factory.  The map is structured with the region name as the
 	 * key and the {@link Region} instances as the values.
 	 *
 	 * @return The map of regions
 	 */
 	public Map getAllSecondLevelCacheRegions();
 
 	/**
 	 * Retrieves the SQLExceptionConverter in effect for this SessionFactory.
 	 *
 	 * @return The SQLExceptionConverter for this SessionFactory.
 	 *
 	 */
 	public SQLExceptionConverter getSQLExceptionConverter();
 	   // TODO: deprecate???
 
 	/**
 	 * Retrieves the SqlExceptionHelper in effect for this SessionFactory.
 	 *
 	 * @return The SqlExceptionHelper for this SessionFactory.
 	 *
 	 */
     public SqlExceptionHelper getSQLExceptionHelper();
 
 	public Settings getSettings();
 
 	/**
 	 * Get a nontransactional "current" session for Hibernate EntityManager
 	 */
 	public Session openTemporarySession() throws HibernateException;
 
 	/**
 	 * Retrieves a set of all the collection roles in which the given entity
 	 * is a participant, as either an index or an element.
 	 *
 	 * @param entityName The entity name for which to get the collection roles.
 	 * @return set of all the collection roles in which the given entityName participates.
 	 */
 	public Set<String> getCollectionRolesByEntityParticipant(String entityName);
 
 	public EntityNotFoundDelegate getEntityNotFoundDelegate();
 
 	public SQLFunctionRegistry getSqlFunctionRegistry();
 
 	/**
 	 * Retrieve fetch profile by name.
 	 *
 	 * @param name The name of the profile to retrieve.
 	 * @return The profile definition
 	 */
 	public FetchProfile getFetchProfile(String name);
 
 	public ServiceRegistryImplementor getServiceRegistry();
 
 	public void addObserver(SessionFactoryObserver observer);
 
 	public CustomEntityDirtinessStrategy getCustomEntityDirtinessStrategy();
 
 	public CurrentTenantIdentifierResolver getCurrentTenantIdentifierResolver();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionCoordinatorImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionCoordinatorImpl.java
index 2324686ab9..4fc91f54ed 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionCoordinatorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionCoordinatorImpl.java
@@ -1,373 +1,373 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.transaction.internal;
 
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.sql.Connection;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.ResourceClosedException;
 import org.hibernate.engine.jdbc.internal.JdbcCoordinatorImpl;
 import org.hibernate.engine.jdbc.spi.JdbcCoordinator;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
 import org.hibernate.engine.transaction.spi.JoinStatus;
 import org.hibernate.engine.transaction.spi.SynchronizationRegistry;
 import org.hibernate.engine.transaction.spi.TransactionContext;
 import org.hibernate.engine.transaction.spi.TransactionCoordinator;
 import org.hibernate.engine.transaction.spi.TransactionEnvironment;
 import org.hibernate.engine.transaction.spi.TransactionFactory;
 import org.hibernate.engine.transaction.spi.TransactionImplementor;
 import org.hibernate.engine.transaction.spi.TransactionObserver;
 import org.hibernate.engine.transaction.synchronization.internal.RegisteredSynchronization;
 import org.hibernate.engine.transaction.synchronization.internal.SynchronizationCallbackCoordinatorImpl;
 import org.hibernate.engine.transaction.synchronization.spi.SynchronizationCallbackCoordinator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.collections.CollectionHelper;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 
 /**
  * Standard implementation of the Hibernate {@link TransactionCoordinator}
  * <p/>
  * IMPL NOTE : Custom serialization handling!
  *
  * @author Steve Ebersole
  */
 public class TransactionCoordinatorImpl implements TransactionCoordinator {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, TransactionCoordinatorImpl.class.getName());
 
 	private final transient TransactionContext transactionContext;
 	private final transient JdbcCoordinatorImpl jdbcCoordinator;
 	private final transient TransactionFactory transactionFactory;
 	private final transient TransactionEnvironment transactionEnvironment;
 
 	private final transient List<TransactionObserver> observers;
 	private final transient SynchronizationRegistryImpl synchronizationRegistry;
 
 	private transient TransactionImplementor currentHibernateTransaction;
 
 	private transient SynchronizationCallbackCoordinatorImpl callbackCoordinator;
 
 	private transient boolean open = true;
 	private transient boolean synchronizationRegistered;
 	private transient boolean ownershipTaken;
 
 	public TransactionCoordinatorImpl(
 			Connection userSuppliedConnection,
 			TransactionContext transactionContext) {
 		this.transactionContext = transactionContext;
 		this.jdbcCoordinator = new JdbcCoordinatorImpl( userSuppliedConnection, this );
 		this.transactionEnvironment = transactionContext.getTransactionEnvironment();
 		this.transactionFactory = this.transactionEnvironment.getTransactionFactory();
 		this.observers = new ArrayList<TransactionObserver>();
 		this.synchronizationRegistry = new SynchronizationRegistryImpl();
 		reset();
 
 		final boolean registerSynchronization = transactionContext.isAutoCloseSessionEnabled()
 		        || transactionContext.isFlushBeforeCompletionEnabled()
 		        || transactionContext.getConnectionReleaseMode() == ConnectionReleaseMode.AFTER_TRANSACTION;
 		if ( registerSynchronization ) {
 			pulse();
 		}
 	}
 
 	public TransactionCoordinatorImpl(
 			TransactionContext transactionContext,
 			JdbcCoordinatorImpl jdbcCoordinator,
 			List<TransactionObserver> observers) {
 		this.transactionContext = transactionContext;
 		this.jdbcCoordinator = jdbcCoordinator;
 		this.transactionEnvironment = transactionContext.getTransactionEnvironment();
 		this.transactionFactory = this.transactionEnvironment.getTransactionFactory();
 		this.observers = observers;
 		this.synchronizationRegistry = new SynchronizationRegistryImpl();
 		reset();
 	}
 
 	/**
 	 * Reset the internal state.
 	 */
 	public void reset() {
 		synchronizationRegistered = false;
 		ownershipTaken = false;
 
 		if ( currentHibernateTransaction != null ) {
 			currentHibernateTransaction.invalidate();
 		}
 		currentHibernateTransaction = transactionFactory().createTransaction( this );
 		if ( transactionContext.shouldAutoJoinTransaction() ) {
 			currentHibernateTransaction.markForJoin();
 			currentHibernateTransaction.join();
 		}
 
 		// IMPL NOTE : reset clears synchronizations (following jta spec), but not observers!
 		synchronizationRegistry.clearSynchronizations();
 	}
 
 	public void afterTransaction(TransactionImplementor hibernateTransaction, int status) {
 		LOG.trace( "after transaction completion" );
 
 		final boolean success = JtaStatusHelper.isCommitted( status );
 
 		if (sessionFactory().getStatistics().isStatisticsEnabled()) {
 			transactionEnvironment.getStatisticsImplementor().endTransaction( success );
 		}
 
 		getJdbcCoordinator().afterTransaction();
 
 		getTransactionContext().afterTransactionCompletion( hibernateTransaction, success );
 		sendAfterTransactionCompletionNotifications( hibernateTransaction, status );
 		reset();
 	}
 
 	private SessionFactoryImplementor sessionFactory() {
 		return transactionEnvironment.getSessionFactory();
 	}
 
 	public boolean isSynchronizationRegistered() {
 		return synchronizationRegistered;
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public boolean isTransactionInProgress() {
 		return open && getTransaction().isActive() && getTransaction().getJoinStatus() == JoinStatus.JOINED;
 	}
 
 	@Override
 	public TransactionContext getTransactionContext() {
 		return transactionContext;
 	}
 
 	@Override
 	public JdbcCoordinator getJdbcCoordinator() {
 		return jdbcCoordinator;
 	}
 
 	private TransactionFactory transactionFactory() {
 		return transactionFactory;
 	}
 
 	private TransactionEnvironment getTransactionEnvironment() {
 		return transactionEnvironment;
 	}
 
 	@Override
 	public TransactionImplementor getTransaction() {
 		if ( ! open ) {
 			throw new ResourceClosedException( "This TransactionCoordinator has been closed" );
 		}
 		pulse();
 		return currentHibernateTransaction;
 	}
 
 	public void afterNonTransactionalQuery(boolean success) {
 		// check to see if the connection is in auto-commit mode (no connection means aggressive connection
 		// release outside a JTA transaction context, so MUST be autocommit mode)
 		boolean isAutocommit = getJdbcCoordinator().getLogicalConnection().isAutoCommit();
 		getJdbcCoordinator().getLogicalConnection().afterTransaction();
 
 		if ( isAutocommit ) {
 			for ( TransactionObserver observer : observers ) {
 				observer.afterCompletion( success, this.getTransaction() );
 			}
 		}
 	}
 
 	@Override
 	public void resetJoinStatus() {
 		getTransaction().resetJoinStatus();
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private void attemptToRegisterJtaSync() {
 		if ( synchronizationRegistered ) {
 			return;
 		}
 
 		// Has the local transaction (Hibernate facade) taken on the responsibility of driving the transaction inflow?
 		if ( currentHibernateTransaction.isInitiator() ) {
 			return;
 		}
 
 		if ( currentHibernateTransaction.getJoinStatus() != JoinStatus.JOINED ) {
 			// the transaction is not (yet) joined, see if we should join...
 			if ( ! transactionContext.shouldAutoJoinTransaction() ) {
 				// we are supposed to not auto join transactions; if the transaction is not marked for join
 				// we cannot go any further in attempting to join (register sync).
 				if ( currentHibernateTransaction.getJoinStatus() != JoinStatus.MARKED_FOR_JOINED ) {
 					LOG.debug( "Skipping JTA sync registration due to auto join checking" );
 					return;
 				}
 			}
 		}
 
 		// IMPL NOTE : At this point the local callback is the "maybe" one.  The only time that needs to change is if
 		// we are able to successfully register the transaction synchronization in which case the local callback would  become
 		// non driving.  To that end, the following checks are simply opt outs where we are unable to register the
 		// synchronization
 
 		JtaPlatform jtaPlatform = getTransactionEnvironment().getJtaPlatform();
 		if ( jtaPlatform == null ) {
 			// if no jta platform was registered we wont be able to register a jta synchronization
 			return;
 		}
 
 		// Can we resister a synchronization
 		if ( !jtaPlatform.canRegisterSynchronization() ) {
 			LOG.trace( "registered JTA platform says we cannot currently resister synchronization; skipping" );
 			return;
 		}
 
 		// Should we resister a synchronization
 		if ( ! transactionFactory().isJoinableJtaTransaction( this, currentHibernateTransaction ) ) {
 			LOG.trace( "TransactionFactory reported no JTA transaction to join; skipping Synchronization registration" );
 			return;
 		}
 
 		jtaPlatform.registerSynchronization( new RegisteredSynchronization( getSynchronizationCallbackCoordinator() ) );
 		synchronizationRegistered = true;
 		LOG.debug( "successfully registered Synchronization" );
 	}
 
 	@Override
 	public SynchronizationCallbackCoordinator getSynchronizationCallbackCoordinator() {
 		if ( callbackCoordinator == null ) {
 			callbackCoordinator = new SynchronizationCallbackCoordinatorImpl( this );
 		}
 		return callbackCoordinator;
 	}
 
 	public void pulse() {
 		if ( transactionFactory().compatibleWithJtaSynchronization() ) {
 			// the configured transaction strategy says it supports callbacks via JTA synchronization, so attempt to
 			// register JTA synchronization if possible
 			attemptToRegisterJtaSync();
 		}
 	}
 
 	public Connection close() {
 		open = false;
 		reset();
 		observers.clear();
 		return jdbcCoordinator.close();
 	}
 
 	public SynchronizationRegistry getSynchronizationRegistry() {
 		return synchronizationRegistry;
 	}
 
 	public void addObserver(TransactionObserver observer) {
 		observers.add( observer );
 	}
 
 	@Override
 	public void removeObserver(TransactionObserver observer) {
 		observers.remove( observer );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public boolean isTransactionJoinable() {
 		return transactionFactory().isJoinableJtaTransaction( this, currentHibernateTransaction );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public boolean isTransactionJoined() {
 		return currentHibernateTransaction != null && currentHibernateTransaction.getJoinStatus() == JoinStatus.JOINED;
 	}
 
 	public void setRollbackOnly() {
 		getTransaction().markRollbackOnly();
 	}
 
 	@Override
 	public boolean takeOwnership() {
 		if ( ownershipTaken ) {
 			return false;
 		}
 		else {
 			ownershipTaken = true;
 			return true;
 		}
 	}
 
 	@Override
 	public void sendAfterTransactionBeginNotifications(TransactionImplementor hibernateTransaction) {
 		for ( TransactionObserver observer : observers ) {
 			observer.afterBegin( currentHibernateTransaction );
 		}
 	}
 
 	@Override
 	public void sendBeforeTransactionCompletionNotifications(TransactionImplementor hibernateTransaction) {
 		synchronizationRegistry.notifySynchronizationsBeforeTransactionCompletion();
 		for ( TransactionObserver observer : observers ) {
 			observer.beforeCompletion( hibernateTransaction );
 		}
 	}
 
 	@Override
 	public void sendAfterTransactionCompletionNotifications(TransactionImplementor hibernateTransaction, int status) {
 		final boolean successful = JtaStatusHelper.isCommitted( status );
 		for ( TransactionObserver observer : new ArrayList<TransactionObserver>( observers ) ) {
 			observer.afterCompletion( successful, hibernateTransaction );
 		}
 		synchronizationRegistry.notifySynchronizationsAfterTransactionCompletion( status );
 	}
 
 
 	// serialization ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	public void serialize(ObjectOutputStream oos) throws IOException {
 		jdbcCoordinator.serialize( oos );
 		oos.writeInt( observers.size() );
 		for ( TransactionObserver observer : observers ) {
 			oos.writeObject( observer );
 		}
 	}
 
 	public static TransactionCoordinatorImpl deserialize(
 			ObjectInputStream ois,
 			TransactionContext transactionContext) throws ClassNotFoundException, IOException {
 		final JdbcCoordinatorImpl jdbcCoordinator = JdbcCoordinatorImpl.deserialize( ois, transactionContext );
 		final int observerCount = ois.readInt();
 		final List<TransactionObserver> observers = CollectionHelper.arrayList( observerCount );
 		for ( int i = 0; i < observerCount; i++ ) {
 			observers.add( (TransactionObserver) ois.readObject() );
 		}
 		final TransactionCoordinatorImpl transactionCoordinator = new TransactionCoordinatorImpl( transactionContext, jdbcCoordinator, observers );
 		jdbcCoordinator.afterDeserialize( transactionCoordinator );
 		return transactionCoordinator;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionFactoryInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionFactoryInitiator.java
index 2f153e75f0..5cee1c627f 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionFactoryInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/TransactionFactoryInitiator.java
@@ -1,73 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.transaction.internal;
 
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.engine.transaction.internal.jdbc.JdbcTransactionFactory;
 import org.hibernate.engine.transaction.spi.TransactionFactory;
 import org.hibernate.engine.transaction.spi.TransactionImplementor;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.service.selector.spi.StrategySelector;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.selector.spi.StrategySelector;
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * Standard initiator for {@link TransactionFactory} service.
  *
  * @author Steve Ebersole
  */
 public class TransactionFactoryInitiator<T extends TransactionImplementor>
-		implements BasicServiceInitiator<TransactionFactory> {
+		implements StandardServiceInitiator<TransactionFactory> {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			TransactionFactoryInitiator.class.getName()
 	);
 
 	public static final TransactionFactoryInitiator INSTANCE = new TransactionFactoryInitiator();
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public Class<TransactionFactory> getServiceInitiated() {
 		return TransactionFactory.class;
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public TransactionFactory initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		final Object strategy = configurationValues.get( AvailableSettings.TRANSACTION_STRATEGY );
 
 		if ( strategy == null ) {
 			LOG.usingDefaultTransactionStrategy();
 			return new JdbcTransactionFactory();
 		}
 
 		return registry.getService( StrategySelector.class ).resolveStrategy( TransactionFactory.class, strategy );
 	}
 }
 
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaTransactionFactory.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaTransactionFactory.java
index 539a800040..f0e50881b9 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaTransactionFactory.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/internal/jta/JtaTransactionFactory.java
@@ -1,104 +1,104 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.transaction.internal.jta;
 
 import javax.transaction.SystemException;
 import javax.transaction.UserTransaction;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.TransactionException;
 import org.hibernate.engine.transaction.spi.TransactionCoordinator;
 import org.hibernate.engine.transaction.spi.TransactionFactory;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 
 /**
  * Factory for {@link JtaTransaction} instances.
  *
  * @author Gavin King
  * @author Steve Ebersole
  * @author Les Hazlewood
  */
 public class JtaTransactionFactory implements TransactionFactory<JtaTransaction> {
 	public static final String SHORT_NAME = "jta";
 
 	@Override
 	public JtaTransaction createTransaction(TransactionCoordinator transactionCoordinator) {
 		return new JtaTransaction( transactionCoordinator );
 	}
 
 	@Override
 	public boolean canBeDriver() {
 		return true;
 	}
 
 	@Override
 	public ConnectionReleaseMode getDefaultReleaseMode() {
 		return ConnectionReleaseMode.AFTER_STATEMENT;
 	}
 
 	@Override
 	public boolean compatibleWithJtaSynchronization() {
 		return true;
 	}
 
 	@Override
 	public boolean isJoinableJtaTransaction(TransactionCoordinator transactionCoordinator, JtaTransaction transaction) {
 		try {
 			// Essentially:
 			// 1) If we have a local (Hibernate) transaction in progress
 			//      and it already has the UserTransaction cached, use that
 			//      UserTransaction to determine the status.
 			// 2) If a transaction manager has been located, use
 			//      that transaction manager to determine the status.
 			// 3) Finally, as the last resort, try to lookup the
 			//      UserTransaction via JNDI and use that to determine the
 			//      status.
 			if ( transaction != null ) {
 				UserTransaction ut = transaction.getUserTransaction();
 				if ( ut != null ) {
 					return JtaStatusHelper.isActive( ut );
 				}
 			}
 
 			final JtaPlatform jtaPlatform = transactionCoordinator
 					.getTransactionContext()
 					.getTransactionEnvironment()
 					.getJtaPlatform();
 			if ( jtaPlatform == null ) {
 				throw new TransactionException( "Unable to check transaction status" );
 			}
 			if ( jtaPlatform.retrieveTransactionManager() != null ) {
 				return JtaStatusHelper.isActive( jtaPlatform.retrieveTransactionManager().getStatus() );
 			}
 			else {
 				final UserTransaction ut = jtaPlatform.retrieveUserTransaction();
 				return ut != null && JtaStatusHelper.isActive( ut );
 			}
 		}
 		catch ( SystemException se ) {
 			throw new TransactionException( "Unable to check transaction status", se );
 		}
 	}
 
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/AbstractJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/AbstractJtaPlatform.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/AbstractJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/AbstractJtaPlatform.java
index c05e261b3d..fc997d6551 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/AbstractJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/AbstractJtaPlatform.java
@@ -1,139 +1,139 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import java.util.Map;
 import javax.transaction.Synchronization;
 import javax.transaction.SystemException;
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.jndi.spi.JndiService;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.jndi.spi.JndiService;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.service.spi.Configurable;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * @author Steve Ebersole
  */
 public abstract class AbstractJtaPlatform
 		implements JtaPlatform, Configurable, ServiceRegistryAwareService, TransactionManagerAccess {
 	private boolean cacheTransactionManager;
 	private boolean cacheUserTransaction;
 	private ServiceRegistryImplementor serviceRegistry;
 
 	private final JtaSynchronizationStrategy tmSynchronizationStrategy = new TransactionManagerBasedSynchronizationStrategy( this );
 
 	@Override
 	public void injectServices(ServiceRegistryImplementor serviceRegistry) {
 		this.serviceRegistry = serviceRegistry;
 	}
 
 	protected ServiceRegistry serviceRegistry() {
 		return serviceRegistry;
 	}
 
 	protected JndiService jndiService() {
 		return serviceRegistry().getService( JndiService.class );
 	}
 
 	protected abstract TransactionManager locateTransactionManager();
 	protected abstract UserTransaction locateUserTransaction();
 
 	public void configure(Map configValues) {
 		cacheTransactionManager = ConfigurationHelper.getBoolean( AvailableSettings.JTA_CACHE_TM, configValues, true );
 		cacheUserTransaction = ConfigurationHelper.getBoolean( AvailableSettings.JTA_CACHE_UT, configValues, false );
 	}
 
 	protected boolean canCacheTransactionManager() {
 		return cacheTransactionManager;
 	}
 
 	protected boolean canCacheUserTransaction() {
 		return cacheUserTransaction;
 	}
 
 	private TransactionManager transactionManager;
 
 	@Override
 	public TransactionManager retrieveTransactionManager() {
 		if ( canCacheTransactionManager() ) {
 			if ( transactionManager == null ) {
 				transactionManager = locateTransactionManager();
 			}
 			return transactionManager;
 		}
 		else {
 			return locateTransactionManager();
 		}
 	}
 
 	@Override
 	public TransactionManager getTransactionManager() {
 		return retrieveTransactionManager();
 	}
 
 	private UserTransaction userTransaction;
 
 	@Override
 	public UserTransaction retrieveUserTransaction() {
 		if ( canCacheUserTransaction() ) {
 			if ( userTransaction == null ) {
 				userTransaction = locateUserTransaction();
 			}
 			return userTransaction;
 		}
 		return locateUserTransaction();
 	}
 
 	@Override
 	public Object getTransactionIdentifier(Transaction transaction) {
 		// generally we use the transaction itself.
 		return transaction;
 	}
 
 	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
 		return tmSynchronizationStrategy;
 	}
 
 	@Override
 	public void registerSynchronization(Synchronization synchronization) {
 		getSynchronizationStrategy().registerSynchronization( synchronization );
 	}
 
 	@Override
 	public boolean canRegisterSynchronization() {
 		return getSynchronizationStrategy().canRegisterSynchronization();
 	}
 
 	@Override
 	public int getCurrentStatus() throws SystemException {
 		return retrieveTransactionManager().getStatus();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/BitronixJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/BitronixJtaPlatform.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/BitronixJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/BitronixJtaPlatform.java
index 17b2505c76..e6f5f925f9 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/BitronixJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/BitronixJtaPlatform.java
@@ -1,55 +1,55 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import java.lang.reflect.Method;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.jta.platform.spi.JtaPlatformException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatformException;
 
 /**
  * @author Steve Ebersole
  */
 public class BitronixJtaPlatform extends AbstractJtaPlatform {
 	private static final String TM_CLASS_NAME = "bitronix.tm.TransactionManagerServices";
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		try {
 			Class transactionManagerServicesClass = serviceRegistry().getService( ClassLoaderService.class ).classForName( TM_CLASS_NAME );
 			final Method getTransactionManagerMethod = transactionManagerServicesClass.getMethod( "getTransactionManager" );
 			return (TransactionManager) getTransactionManagerMethod.invoke( null );
 		}
 		catch (Exception e) {
 			throw new JtaPlatformException( "Could not locate Bitronix TransactionManager", e );
 		}
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return (UserTransaction) jndiService().locate( "java:comp/UserTransaction" );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/BorlandEnterpriseServerJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/BorlandEnterpriseServerJtaPlatform.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/BorlandEnterpriseServerJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/BorlandEnterpriseServerJtaPlatform.java
index 9144f8e113..49390a89d0 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/BorlandEnterpriseServerJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/BorlandEnterpriseServerJtaPlatform.java
@@ -1,45 +1,45 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 /**
  * @author Steve Ebersole
  */
 public class BorlandEnterpriseServerJtaPlatform extends AbstractJtaPlatform {
 	protected static final String TM_NAME = "java:pm/TransactionManager";
 	protected static final String UT_NAME = "java:comp/UserTransaction";
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		return (TransactionManager) jndiService().locate( TM_NAME );
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return (UserTransaction) jndiService().locate( UT_NAME );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JBossAppServerJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JBossAppServerJtaPlatform.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JBossAppServerJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JBossAppServerJtaPlatform.java
index 92bef427a8..4ef9cf6f21 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JBossAppServerJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JBossAppServerJtaPlatform.java
@@ -1,60 +1,60 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
-import org.hibernate.service.jndi.JndiException;
+import org.hibernate.engine.jndi.JndiException;
 
 /**
  * JtaPlatform definition for JBoss Application Server.
  *
  * @author Steve Ebersole
  */
 public class JBossAppServerJtaPlatform extends AbstractJtaPlatform {
 	public static final String AS7_TM_NAME = "java:jboss/TransactionManager";
 	public static final String AS4_TM_NAME = "java:/TransactionManager";
 	public static final String UT_NAME = "java:comp/UserTransaction";  // should work with AS7 and earlier
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		try {
 			return (TransactionManager) jndiService().locate(AS7_TM_NAME);
 		}
 		catch(JndiException jndiException) {
 			try {
 				return (TransactionManager) jndiService().locate(AS4_TM_NAME);
 			}
 			catch(JndiException jndiExceptionInner) {
 				throw new JndiException("unable to find transaction manager", jndiException);
 			}
 		}
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return (UserTransaction) jndiService().locate( UT_NAME );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JBossStandAloneJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JBossStandAloneJtaPlatform.java
similarity index 91%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JBossStandAloneJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JBossStandAloneJtaPlatform.java
index 85f9861fd9..9ad1d0b871 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JBossStandAloneJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JBossStandAloneJtaPlatform.java
@@ -1,68 +1,68 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.jta.platform.spi.JtaPlatformException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatformException;
 
 /**
  * Return a standalone JTA transaction manager for JBoss Transactions
  * Known to work for org.jboss.jbossts:jbossjta:4.9.0.GA
  *
  * @author Emmanuel Bernard
  * @author Steve Ebersole
  */
 public class JBossStandAloneJtaPlatform extends AbstractJtaPlatform {
 	private static final String JBOSS_TM_CLASS_NAME = "com.arjuna.ats.jta.TransactionManager";
 	private static final String JBOSS_UT_CLASS_NAME = "com.arjuna.ats.jta.UserTransaction";
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		try {
 			final Class jbossTmClass = serviceRegistry()
 					.getService( ClassLoaderService.class )
 					.classForName( JBOSS_TM_CLASS_NAME );
 			return (TransactionManager) jbossTmClass.getMethod( "transactionManager" ).invoke( null );
 		}
 		catch ( Exception e ) {
 			throw new JtaPlatformException( "Could not obtain JBoss Transactions transaction manager instance", e );
 		}
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		try {
 			final Class jbossUtClass = serviceRegistry()
 					.getService( ClassLoaderService.class )
 					.classForName( JBOSS_UT_CLASS_NAME );
 			return (UserTransaction) jbossUtClass.getMethod( "userTransaction" ).invoke( null );
 		}
 		catch ( Exception e ) {
 			throw new JtaPlatformException( "Could not obtain JBoss Transactions user transaction instance", e );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JOTMJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JOTMJtaPlatform.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JOTMJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JOTMJtaPlatform.java
index 9de4f7bc54..255d2bfb83 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JOTMJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JOTMJtaPlatform.java
@@ -1,56 +1,56 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import java.lang.reflect.Method;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.jta.platform.spi.JtaPlatformException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatformException;
 
 /**
  * @author Steve Ebersole
  */
 public class JOTMJtaPlatform extends AbstractJtaPlatform {
 	public static final String TM_CLASS_NAME = "org.objectweb.jotm.Current";
 	public static final String UT_NAME = "java:comp/UserTransaction";
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		try {
 			final Class tmClass = serviceRegistry().getService( ClassLoaderService.class ).classForName( TM_CLASS_NAME );
 			final Method getTransactionManagerMethod = tmClass.getMethod( "getTransactionManager" );
 			return (TransactionManager) getTransactionManagerMethod.invoke( null, (Object[]) null );
 		}
 		catch (Exception e) {
 			throw new JtaPlatformException( "Could not obtain JOTM transaction manager instance", e );
 		}
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return (UserTransaction) jndiService().locate( UT_NAME );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JOnASJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JOnASJtaPlatform.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JOnASJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JOnASJtaPlatform.java
index b02c6b9218..7c2d16ca04 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JOnASJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JOnASJtaPlatform.java
@@ -1,57 +1,57 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import java.lang.reflect.Method;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
-import org.hibernate.service.jta.platform.spi.JtaPlatformException;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatformException;
 
 /**
  * JTA platform implementation for JOnAS
  *
  * @author Steve Ebersole
  */
 public class JOnASJtaPlatform extends AbstractJtaPlatform {
 	public static final String UT_NAME = "java:comp/UserTransaction";
 	private static final String TM_CLASS_NAME = "org.objectweb.jonas_tm.Current";
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		try {
 			final Class clazz = Class.forName( TM_CLASS_NAME );
 			final Method getTransactionManagerMethod = clazz.getMethod( "getTransactionManager" );
 			return (TransactionManager) getTransactionManagerMethod.invoke( null );
 		}
 		catch (Exception e) {
 			throw new JtaPlatformException( "Could not obtain JOnAS transaction manager instance", e );
 		}
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return (UserTransaction) jndiService().locate( UT_NAME );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JRun4JtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JRun4JtaPlatform.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JRun4JtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JRun4JtaPlatform.java
index 2242bcdbb3..a23d78a018 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JRun4JtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JRun4JtaPlatform.java
@@ -1,48 +1,48 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 /**
- * {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation for JRun4 AS
+ * {@link org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform} implementation for JRun4 AS
  *
  * @author Joseph Bissen
  * @author Steve Ebersole
  */
 public class JRun4JtaPlatform extends AbstractJtaPlatform {
 	public static final String TM_NAME = "java:/TransactionManager";
 	public static final String UT_NAME = "java:comp/UserTransaction";
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		return (TransactionManager) jndiService().locate( TM_NAME );
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return (UserTransaction) jndiService().locate( UT_NAME );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JtaPlatformInitiator.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JtaPlatformInitiator.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JtaPlatformInitiator.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JtaPlatformInitiator.java
index 5c7fb6d5cc..d5439a21aa 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JtaPlatformInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JtaPlatformInitiator.java
@@ -1,162 +1,162 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Environment;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.jndi.JndiHelper;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.config.spi.ConfigurationService;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
-import org.hibernate.service.jta.platform.spi.JtaPlatformException;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.engine.config.spi.ConfigurationService;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatformException;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.transaction.TransactionManagerLookup;
 
 /**
- * Standard initiator for the standard {@link org.hibernate.service.jta.platform.spi.JtaPlatform}
+ * Standard initiator for the standard {@link org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform}
  *
  * @author Steve Ebersole
  */
-public class JtaPlatformInitiator implements BasicServiceInitiator<JtaPlatform> {
+public class JtaPlatformInitiator implements StandardServiceInitiator<JtaPlatform> {
 	public static final JtaPlatformInitiator INSTANCE = new JtaPlatformInitiator();
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, JtaPlatformInitiator.class.getName());
 
 	@Override
 	public Class<JtaPlatform> getServiceInitiated() {
 		return JtaPlatform.class;
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public JtaPlatform initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		final Object platform = getConfiguredPlatform( configurationValues, registry );
 		if ( platform == null ) {
 			return new NoJtaPlatform();
 		}
 		return registry.getService( ConfigurationService.class )
 				.cast( JtaPlatform.class, platform );
 
 	}
 
 	private Object getConfiguredPlatform(Map configVales, ServiceRegistryImplementor registry) {
 		Object platform = configVales.get( AvailableSettings.JTA_PLATFORM );
 		if ( platform == null ) {
 			final String transactionManagerLookupImplName = (String) configVales.get( Environment.TRANSACTION_MANAGER_STRATEGY );
 			if ( transactionManagerLookupImplName != null ) {
                 LOG.deprecatedTransactionManagerStrategy(TransactionManagerLookup.class.getName(),
                                                          Environment.TRANSACTION_MANAGER_STRATEGY,
                                                          JtaPlatform.class.getName(),
                                                          AvailableSettings.JTA_PLATFORM);
 				platform = mapLegacyClasses( transactionManagerLookupImplName, configVales, registry );
                 LOG.debugf("Mapped %s -> %s", transactionManagerLookupImplName, platform);
 			}
 		}
 		return platform;
 	}
 
 	private JtaPlatform mapLegacyClasses(String tmlImplName, Map configVales, ServiceRegistryImplementor registry) {
 		if ( tmlImplName == null ) {
 			return null;
 		}
 
         LOG.legacyTransactionManagerStrategy(JtaPlatform.class.getName(), AvailableSettings.JTA_PLATFORM);
 
 		if ( "org.hibernate.transaction.BESTransactionManagerLookup".equals( tmlImplName ) ) {
 			return new BorlandEnterpriseServerJtaPlatform();
 		}
 
 		if ( "org.hibernate.transaction.BTMTransactionManagerLookup".equals( tmlImplName ) ) {
 			return new BitronixJtaPlatform();
 		}
 
 		if ( "org.hibernate.transaction.JBossTransactionManagerLookup".equals( tmlImplName ) ) {
 			return new JBossAppServerJtaPlatform();
 		}
 
 		if ( "org.hibernate.transaction.JBossTSStandaloneTransactionManagerLookup".equals( tmlImplName ) ) {
 			return new JBossStandAloneJtaPlatform();
 		}
 
 		if ( "org.hibernate.transaction.JOnASTransactionManagerLookup".equals( tmlImplName ) ) {
 			return new JOnASJtaPlatform();
 		}
 
 		if ( "org.hibernate.transaction.JOTMTransactionManagerLookup".equals( tmlImplName ) ) {
 			return new JOTMJtaPlatform();
 		}
 
 		if ( "org.hibernate.transaction.JRun4TransactionManagerLookup".equals( tmlImplName ) ) {
 			return new JRun4JtaPlatform();
 		}
 
 		if ( "org.hibernate.transaction.OC4JTransactionManagerLookup".equals( tmlImplName ) ) {
 			return new OC4JJtaPlatform();
 		}
 
 		if ( "org.hibernate.transaction.OrionTransactionManagerLookup".equals( tmlImplName ) ) {
 			return new OrionJtaPlatform();
 		}
 
 		if ( "org.hibernate.transaction.ResinTransactionManagerLookup".equals( tmlImplName ) ) {
 			return new ResinJtaPlatform();
 		}
 
 		if ( "org.hibernate.transaction.SunONETransactionManagerLookup".equals( tmlImplName ) ) {
 			return new SunOneJtaPlatform();
 		}
 
 		if ( "org.hibernate.transaction.WeblogicTransactionManagerLookup".equals( tmlImplName ) ) {
 			return new WeblogicJtaPlatform();
 		}
 
 		if ( "org.hibernate.transaction.WebSphereTransactionManagerLookup".equals( tmlImplName ) ) {
 			return new WebSphereJtaPlatform();
 		}
 
 		if ( "org.hibernate.transaction.WebSphereExtendedJTATransactionLookup".equals( tmlImplName ) ) {
 			return new WebSphereExtendedJtaPlatform();
 		}
 
 		try {
 			TransactionManagerLookup lookup = (TransactionManagerLookup) registry.getService( ClassLoaderService.class )
 					.classForName( tmlImplName )
 					.newInstance();
 			return new TransactionManagerLookupBridge( lookup, JndiHelper.extractJndiProperties( configVales ) );
 		}
 		catch ( Exception e ) {
 			throw new JtaPlatformException(
 					"Unable to build " + TransactionManagerLookupBridge.class.getName() + " from specified " +
 							TransactionManagerLookup.class.getName() + " implementation: " +
 							tmlImplName
 			);
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JtaSynchronizationStrategy.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JtaSynchronizationStrategy.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JtaSynchronizationStrategy.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JtaSynchronizationStrategy.java
index f33e461347..d296f0d603 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/JtaSynchronizationStrategy.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/JtaSynchronizationStrategy.java
@@ -1,48 +1,48 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import java.io.Serializable;
 import javax.transaction.Synchronization;
 
 /**
  * Contract used to centralize {@link Synchronization} handling logic.
  *
  * @author Steve Ebersole
  */
 public interface JtaSynchronizationStrategy extends Serializable {
 	/**
 	 * Register a synchronization
 	 *
 	 * @param synchronization The synchronization to register.
 	 */
 	public void registerSynchronization(Synchronization synchronization);
 
 	/**
 	 * Can a synchronization be registered?
 	 *
 	 * @return {@literal true}/{@literal false}
 	 */
 	public boolean canRegisterSynchronization();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/NoJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/NoJtaPlatform.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/NoJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/NoJtaPlatform.java
index 440674b07b..26c3235c75 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/NoJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/NoJtaPlatform.java
@@ -1,69 +1,69 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import javax.transaction.Status;
 import javax.transaction.Synchronization;
 import javax.transaction.SystemException;
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 
 /**
  * The non-configured form of JTA platform.  This is what is used if none was set up.
  *
  * @author Steve Ebersole
  */
 public class NoJtaPlatform implements JtaPlatform {
 	@Override
 	public TransactionManager retrieveTransactionManager() {
 		return null;
 	}
 
 	@Override
 	public UserTransaction retrieveUserTransaction() {
 		return null;
 	}
 
 	@Override
 	public Object getTransactionIdentifier(Transaction transaction) {
 		return null;
 	}
 
 	@Override
 	public void registerSynchronization(Synchronization synchronization) {
 	}
 
 	@Override
 	public boolean canRegisterSynchronization() {
 		return false;
 	}
 
 	@Override
 	public int getCurrentStatus() throws SystemException {
 		return Status.STATUS_UNKNOWN;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/OC4JJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/OC4JJtaPlatform.java
similarity index 90%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/OC4JJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/OC4JJtaPlatform.java
index c21c9c6019..3bdcbdfe96 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/OC4JJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/OC4JJtaPlatform.java
@@ -1,48 +1,48 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 /**
- * {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation for the OC4J (Oracle) AS.
+ * {@link org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform} implementation for the OC4J (Oracle) AS.
  *
  * @author Stijn Janssens
  * @author Steve Ebersole
  */
 public class OC4JJtaPlatform extends AbstractJtaPlatform {
 	public static final String TM_NAME = "java:comp/pm/TransactionManager";
 	public static final String UT_NAME = "java:comp/UserTransaction";
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		return (TransactionManager) jndiService().locate( TM_NAME );
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return (UserTransaction) jndiService().locate( UT_NAME );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/OrionJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/OrionJtaPlatform.java
similarity index 91%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/OrionJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/OrionJtaPlatform.java
index 40028e9539..0e9566d600 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/OrionJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/OrionJtaPlatform.java
@@ -1,48 +1,48 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 /**
- * {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation for Orion
+ * {@link org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform} implementation for Orion
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class OrionJtaPlatform extends AbstractJtaPlatform {
 	public static final String TM_NAME = "java:comp/UserTransaction";
 	public static final String UT_NAME = "java:comp/UserTransaction";
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		return (TransactionManager) jndiService().locate( TM_NAME );
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return (UserTransaction) jndiService().locate( UT_NAME );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/ResinJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/ResinJtaPlatform.java
similarity index 91%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/ResinJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/ResinJtaPlatform.java
index b2ad76130e..eaed24a3f9 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/ResinJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/ResinJtaPlatform.java
@@ -1,48 +1,48 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 /**
- * {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation for Resin
+ * {@link org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform} implementation for Resin
  *
  * @author Aapo Laakkonen
  * @author Steve Ebersole
  */
 public class ResinJtaPlatform extends AbstractJtaPlatform {
 	public static final String TM_NAME = "java:comp/TransactionManager";
 	public static final String UT_NAME = "java:comp/UserTransaction";
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		return (TransactionManager) jndiService().locate( TM_NAME );
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return (UserTransaction) jndiService().locate( UT_NAME );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SunOneJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/SunOneJtaPlatform.java
similarity index 89%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SunOneJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/SunOneJtaPlatform.java
index bd962698ec..fd6ebc98ac 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SunOneJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/SunOneJtaPlatform.java
@@ -1,50 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 /**
- * {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation for Sun ONE Application Server 7 and above
+ * {@link org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform} implementation for Sun ONE Application Server 7 and above
  *
  * @author Robert Davidson
  * @author Sanjeev Krishnan
  * @author Emmanuel Bernard
  * @author Steve Ebersole
  */
 public class SunOneJtaPlatform extends AbstractJtaPlatform {
 	public static final String TM_NAME = "java:appserver/TransactionManager";
 	public static final String UT_NAME = "java:comp/UserTransaction";
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		return (TransactionManager) jndiService().locate( TM_NAME );
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return (UserTransaction) jndiService().locate( UT_NAME );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SynchronizationRegistryAccess.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/SynchronizationRegistryAccess.java
similarity index 96%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SynchronizationRegistryAccess.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/SynchronizationRegistryAccess.java
index 9b4c1d400a..bab04fa19c 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SynchronizationRegistryAccess.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/SynchronizationRegistryAccess.java
@@ -1,42 +1,42 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import java.io.Serializable;
 import javax.transaction.TransactionSynchronizationRegistry;
 
 /**
  * Provides access to a {@link TransactionSynchronizationRegistry} for use by {@link TransactionSynchronizationRegistry}-based
  * {@link JtaSynchronizationStrategy} implementations.
  *
  * @author Steve Ebersole
  */
 public interface SynchronizationRegistryAccess extends Serializable {
 	/**
 	 * Obtain the synchronization registry
 	 *
 	 * @return the synchronization registry
 	 */
 	public TransactionSynchronizationRegistry getSynchronizationRegistry();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SynchronizationRegistryBasedSynchronizationStrategy.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/SynchronizationRegistryBasedSynchronizationStrategy.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SynchronizationRegistryBasedSynchronizationStrategy.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/SynchronizationRegistryBasedSynchronizationStrategy.java
index d8af05e484..d4b08df264 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/SynchronizationRegistryBasedSynchronizationStrategy.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/SynchronizationRegistryBasedSynchronizationStrategy.java
@@ -1,56 +1,56 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import javax.transaction.Synchronization;
 import javax.transaction.TransactionSynchronizationRegistry;
 
 import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
 
 /**
  * Implementation of the {@link JtaSynchronizationStrategy} contract based on using a
  * {@link TransactionSynchronizationRegistry}
  *
  * @author Steve Ebersole
  */
 public class SynchronizationRegistryBasedSynchronizationStrategy implements JtaSynchronizationStrategy {
 	private final SynchronizationRegistryAccess synchronizationRegistryAccess;
 
 	public SynchronizationRegistryBasedSynchronizationStrategy(SynchronizationRegistryAccess synchronizationRegistryAccess) {
 		this.synchronizationRegistryAccess = synchronizationRegistryAccess;
 	}
 
 	@Override
 	public void registerSynchronization(Synchronization synchronization) {
 		synchronizationRegistryAccess.getSynchronizationRegistry().registerInterposedSynchronization(
 				synchronization
 		);
 	}
 
 	@Override
 	public boolean canRegisterSynchronization() {
 		final TransactionSynchronizationRegistry registry = synchronizationRegistryAccess.getSynchronizationRegistry();
 		return JtaStatusHelper.isActive( registry.getTransactionStatus() ) && ! registry.getRollbackOnly();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerAccess.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/TransactionManagerAccess.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerAccess.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/TransactionManagerAccess.java
index ee4c8ec53a..26c7411743 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerAccess.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/TransactionManagerAccess.java
@@ -1,42 +1,42 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import java.io.Serializable;
 import javax.transaction.TransactionManager;
 
 /**
  * Provides access to a {@link TransactionManager} for use by {@link TransactionManager}-based
  * {@link JtaSynchronizationStrategy} implementations.
  *
  * @author Steve Ebersole
  */
 public interface TransactionManagerAccess extends Serializable {
 	/**
 	 * Obtain the transaction manager
 	 *
 	 * @return The transaction manager.
 	 */
 	public TransactionManager getTransactionManager();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerBasedSynchronizationStrategy.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/TransactionManagerBasedSynchronizationStrategy.java
similarity index 93%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerBasedSynchronizationStrategy.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/TransactionManagerBasedSynchronizationStrategy.java
index 070fb52ffb..b9e3614138 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerBasedSynchronizationStrategy.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/TransactionManagerBasedSynchronizationStrategy.java
@@ -1,58 +1,58 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import javax.transaction.Synchronization;
 
 import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
-import org.hibernate.service.jta.platform.spi.JtaPlatformException;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatformException;
 
 /**
  * Implementation of the {@link JtaSynchronizationStrategy} contract based on using a
  * {@link javax.transaction.TransactionManager}
  * 
  * @author Steve Ebersole
  */
 public class TransactionManagerBasedSynchronizationStrategy implements JtaSynchronizationStrategy {
 	private final TransactionManagerAccess transactionManagerAccess;
 
 	public TransactionManagerBasedSynchronizationStrategy(TransactionManagerAccess transactionManagerAccess) {
 		this.transactionManagerAccess = transactionManagerAccess;
 	}
 
 	@Override
 	public void registerSynchronization(Synchronization synchronization) {
 		try {
 			transactionManagerAccess.getTransactionManager().getTransaction().registerSynchronization( synchronization );
 		}
 		catch (Exception e) {
 			throw new JtaPlatformException( "Could not access JTA Transaction to register synchronization", e );
 		}
 	}
 
 	@Override
 	public boolean canRegisterSynchronization() {
 		return JtaStatusHelper.isActive( transactionManagerAccess.getTransactionManager() );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerLookupBridge.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/TransactionManagerLookupBridge.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerLookupBridge.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/TransactionManagerLookupBridge.java
index bd3889ce99..7664dd6e5b 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/TransactionManagerLookupBridge.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/TransactionManagerLookupBridge.java
@@ -1,60 +1,60 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import java.util.Properties;
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
-import org.hibernate.service.jndi.spi.JndiService;
+import org.hibernate.engine.jndi.spi.JndiService;
 import org.hibernate.transaction.TransactionManagerLookup;
 
 /**
  * @author Steve Ebersole
  */
 public class TransactionManagerLookupBridge extends AbstractJtaPlatform {
 	private final TransactionManagerLookup lookup;
 	private final Properties jndiProperties;
 
 	public TransactionManagerLookupBridge(TransactionManagerLookup lookup, Properties jndiProperties) {
 		this.lookup = lookup;
 		this.jndiProperties = jndiProperties;
 	}
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		return lookup.getTransactionManager( jndiProperties );
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return (UserTransaction) serviceRegistry().getService( JndiService.class ).locate( lookup.getUserTransactionName() );
 	}
 
 	@Override
 	public Object getTransactionIdentifier(Transaction transaction) {
 		return lookup.getTransactionIdentifier( transaction );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WebSphereExtendedJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/WebSphereExtendedJtaPlatform.java
similarity index 99%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WebSphereExtendedJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/WebSphereExtendedJtaPlatform.java
index ec2e971bae..19a81bdde7 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WebSphereExtendedJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/WebSphereExtendedJtaPlatform.java
@@ -1,255 +1,255 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import java.lang.reflect.InvocationHandler;
 import java.lang.reflect.Method;
 import java.lang.reflect.Proxy;
 import javax.transaction.NotSupportedException;
 import javax.transaction.RollbackException;
 import javax.transaction.Status;
 import javax.transaction.Synchronization;
 import javax.transaction.SystemException;
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 import javax.transaction.xa.XAResource;
 
 import org.hibernate.HibernateException;
 
 /**
  * JTA platform implementation intended for use with WebSphere Application Server (WAS).
  * <p/>
  * WAS, unlike every other app server on the planet, does not allow direct access to the JTS TransactionManager.
  * Instead, for common transaction-related tasks users must utilize a proprietary API known as ExtendedJTATransaction.
  * <p/>
  * Even more unfortunate, the exact TransactionManagerLookup to use inside of WAS is highly dependent upon<ul>
  *     <li>WAS version</li>
  *     <li>the WAS container in which Hibernate will be utilized</li>
  * </ul>
  * <p/>
  * This class is reported to work on WAS version 6 in any of the standard J2EE/JEE component containers.
  *
  * @author Gavin King
  * @author <a href="mailto:jesper@udby.com>Jesper Udby</a>
  * @author Steve Ebersole
  */
 public class WebSphereExtendedJtaPlatform extends AbstractJtaPlatform {
 	public static final String UT_NAME = "java:comp/UserTransaction";
 
 	@Override
 	protected boolean canCacheTransactionManager() {
 		return true;
 	}
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		return new TransactionManagerAdapter();
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return (UserTransaction) jndiService().locate( UT_NAME );
 	}
 
 	@Override
 	@SuppressWarnings( {"UnnecessaryBoxing"})
 	public Object getTransactionIdentifier(Transaction transaction) {
 		// WebSphere, however, is not a sane JEE/JTA container...
 		return Integer.valueOf( transaction.hashCode() );
 	}
 
 	public class TransactionManagerAdapter implements TransactionManager {
 		private final Class synchronizationCallbackClass;
 		private final Method registerSynchronizationMethod;
 		private final Method getLocalIdMethod;
 		private Object extendedJTATransaction;
 
 		private TransactionManagerAdapter() throws HibernateException {
 			try {
 				synchronizationCallbackClass = Class.forName( "com.ibm.websphere.jtaextensions.SynchronizationCallback" );
 				Class extendedJTATransactionClass = Class.forName( "com.ibm.websphere.jtaextensions.ExtendedJTATransaction" );
 				registerSynchronizationMethod = extendedJTATransactionClass.getMethod(
 						"registerSynchronizationCallbackForCurrentTran",
 						new Class[] { synchronizationCallbackClass }
 				);
 				getLocalIdMethod = extendedJTATransactionClass.getMethod( "getLocalId", (Class[]) null );
 			}
 			catch ( ClassNotFoundException cnfe ) {
 				throw new HibernateException( cnfe );
 			}
 			catch ( NoSuchMethodException nsme ) {
 				throw new HibernateException( nsme );
 			}
 		}
 
 		@Override
 		public void begin() throws NotSupportedException, SystemException {
 			throw new UnsupportedOperationException();
 		}
 
 		@Override
 		public void commit() throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
 		@Override
 		public int getStatus() throws SystemException {
 			return getTransaction() == null ? Status.STATUS_NO_TRANSACTION : getTransaction().getStatus();
 		}
 
 		@Override
 		public Transaction getTransaction() throws SystemException {
 			return new TransactionAdapter();
 		}
 
 		@Override
 		public void resume(Transaction txn) throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
 		@Override
 		public void rollback() throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
 		@Override
 		public void setRollbackOnly() throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
 		@Override
 		public void setTransactionTimeout(int i) throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
 		@Override
 		public Transaction suspend() throws UnsupportedOperationException {
 			throw new UnsupportedOperationException();
 		}
 
 		public class TransactionAdapter implements Transaction {
 
 			private TransactionAdapter() {
 				if ( extendedJTATransaction == null ) {
 					extendedJTATransaction = jndiService().locate( "java:comp/websphere/ExtendedJTATransaction" );
 				}
 			}
 
 			@Override
 			public void registerSynchronization(final Synchronization synchronization)
 					throws RollbackException, IllegalStateException,
 					SystemException {
 
 				final InvocationHandler ih = new InvocationHandler() {
 
 					@Override
 					public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
 						if ( "afterCompletion".equals( method.getName() ) ) {
 							int status = args[2].equals(Boolean.TRUE) ?
 									Status.STATUS_COMMITTED :
 									Status.STATUS_UNKNOWN;
 							synchronization.afterCompletion(status);
 						}
 						else if ( "beforeCompletion".equals( method.getName() ) ) {
 							synchronization.beforeCompletion();
 						}
 						else if ( "toString".equals( method.getName() ) ) {
 							return synchronization.toString();
 						}
 						return null;
 					}
 
 				};
 
 				final Object synchronizationCallback = Proxy.newProxyInstance(
 						getClass().getClassLoader(),
 						new Class[] {synchronizationCallbackClass},
 						ih
 				);
 
 				try {
 					registerSynchronizationMethod.invoke( extendedJTATransaction, synchronizationCallback );
 				}
 				catch (Exception e) {
 					throw new HibernateException(e);
 				}
 
 			}
 
 			@Override
 			public int hashCode() {
 				return getLocalId().hashCode();
 			}
 
 			@Override
 			public boolean equals(Object other) {
 				if ( !(other instanceof TransactionAdapter) ) return false;
 				TransactionAdapter that = (TransactionAdapter) other;
 				return getLocalId().equals( that.getLocalId() );
 			}
 
 			private Object getLocalId() throws HibernateException {
 				try {
 					return getLocalIdMethod.invoke( extendedJTATransaction, (Object[]) null );
 				}
 				catch ( Exception e ) {
 					throw new HibernateException( e );
 				}
 			}
 
 			@Override
 			public void commit() throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 
 			@Override
 			public boolean delistResource(XAResource resource, int i) throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 
 			@Override
 			public boolean enlistResource(XAResource resource) throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 
 			@Override
 			public int getStatus() {
 				return Integer.valueOf( 0 ).equals( getLocalId() ) ?
 						Status.STATUS_NO_TRANSACTION : Status.STATUS_ACTIVE;
 			}
 
 			@Override
 			public void rollback() throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 
 			@Override
 			public void setRollbackOnly() throws UnsupportedOperationException {
 				throw new UnsupportedOperationException();
 			}
 		}
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WebSphereJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/WebSphereJtaPlatform.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WebSphereJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/WebSphereJtaPlatform.java
index 1f8c758f9a..9113045d87 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WebSphereJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/WebSphereJtaPlatform.java
@@ -1,97 +1,97 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import java.lang.reflect.Method;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.service.jta.platform.spi.JtaPlatformException;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatformException;
 
 /**
  * JTA platform implementation for WebSphere (versions 4, 5.0 and 5.1)
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class WebSphereJtaPlatform extends AbstractJtaPlatform {
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, WebSphereJtaPlatform.class.getName());
 
 	public static final String VERSION_5_UT_NAME = "java:comp/UserTransaction";
 	public static final String VERSION_4_UT_NAME = "jta/usertransaction";
 
 	private final Class transactionManagerAccessClass;
 	private final int webSphereVersion;
 
 	public WebSphereJtaPlatform() {
 		try {
 			Class clazz;
 			int version;
 			try {
 				clazz = Class.forName( "com.ibm.ws.Transaction.TransactionManagerFactory" );
 				version = 5;
                 LOG.debug("WebSphere 5.1");
 			}
 			catch ( Exception e ) {
 				try {
 					clazz = Class.forName( "com.ibm.ejs.jts.jta.TransactionManagerFactory" );
 					version = 5;
                     LOG.debug("WebSphere 5.0");
 				}
 				catch ( Exception e2 ) {
 					clazz = Class.forName( "com.ibm.ejs.jts.jta.JTSXA" );
 					version = 4;
                     LOG.debug("WebSphere 4");
 				}
 			}
 
 			transactionManagerAccessClass = clazz;
 			webSphereVersion = version;
 		}
 		catch ( Exception e ) {
 			throw new JtaPlatformException( "Could not locate WebSphere TransactionManager access class", e );
 		}
 	}
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		try {
 			final Method method = transactionManagerAccessClass.getMethod( "getTransactionManager" );
 			return ( TransactionManager ) method.invoke( null );
 		}
 		catch ( Exception e ) {
 			throw new JtaPlatformException( "Could not obtain WebSphere TransactionManager", e );
 		}
 
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		final String utName = webSphereVersion == 5 ? VERSION_5_UT_NAME : VERSION_4_UT_NAME;
 		return (UserTransaction) jndiService().locate( utName );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WeblogicJtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/WeblogicJtaPlatform.java
similarity index 91%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WeblogicJtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/WeblogicJtaPlatform.java
index 26bc3a69f5..54c82f8ac1 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/internal/WeblogicJtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/internal/WeblogicJtaPlatform.java
@@ -1,48 +1,48 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.internal;
+package org.hibernate.engine.transaction.jta.platform.internal;
 
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 /**
- * {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation for Weblogic
+ * {@link org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform} implementation for Weblogic
  *
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class WeblogicJtaPlatform extends AbstractJtaPlatform {
 	public static final String TM_NAME = "javax.transaction.TransactionManager";
 	public static final String UT_NAME = "javax.transaction.UserTransaction";
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		return (TransactionManager) jndiService().locate( TM_NAME );
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return (UserTransaction) jndiService().locate( UT_NAME );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/spi/JtaPlatform.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/spi/JtaPlatform.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/spi/JtaPlatform.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/spi/JtaPlatform.java
index 86c56bc843..1bf027f9d3 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/spi/JtaPlatform.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/spi/JtaPlatform.java
@@ -1,89 +1,89 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.spi;
+package org.hibernate.engine.transaction.jta.platform.spi;
 
 import javax.transaction.Synchronization;
 import javax.transaction.SystemException;
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 import org.hibernate.service.Service;
 
 /**
  * Defines how we interact with various JTA services on the given platform/environment.
  *
  * @author Steve Ebersole
  */
 public interface JtaPlatform extends Service {
 
 	/**
 	 * Locate the {@link TransactionManager}
 	 *
 	 * @return The {@link TransactionManager}
 	 */
 	public TransactionManager retrieveTransactionManager();
 
 	/**
 	 * Locate the {@link UserTransaction}
 	 *
 	 * @return The {@link UserTransaction}
 	 */
 	public UserTransaction retrieveUserTransaction();
 
 	/**
 	 * Determine an identifier for the given transaction appropriate for use in caching/lookup usages.
 	 * <p/>
 	 * Generally speaking the transaction itself will be returned here.  This method was added specifically
 	 * for use in WebSphere and other unfriendly JEE containers (although WebSphere is still the only known
 	 * such brain-dead, sales-driven impl).
 	 *
 	 * @param transaction The transaction to be identified.
 	 * @return An appropriate identifier
 	 */
 	public Object getTransactionIdentifier(Transaction transaction);
 
 	/**
 	 * Can we currently register a {@link Synchronization}?
 	 *
 	 * @return True if registering a {@link Synchronization} is currently allowed; false otherwise.
 	 */
 	public boolean canRegisterSynchronization();
 
 	/**
 	 * Register a JTA {@link Synchronization} in the means defined by the platform.
 	 *
 	 * @param synchronization The synchronization to register
 	 */
 	public void registerSynchronization(Synchronization synchronization);
 
 	/**
 	 * Obtain the current transaction status using whatever means is preferred for this platform
 	 *
 	 * @return The current status.
 	 *
 	 * @throws SystemException Indicates a problem access the underlying status
 	 */
 	public int getCurrentStatus() throws SystemException;
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/spi/JtaPlatformException.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/spi/JtaPlatformException.java
similarity index 95%
rename from hibernate-core/src/main/java/org/hibernate/service/jta/platform/spi/JtaPlatformException.java
rename to hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/spi/JtaPlatformException.java
index abc7f31d79..28fc1b45da 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jta/platform/spi/JtaPlatformException.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/jta/platform/spi/JtaPlatformException.java
@@ -1,41 +1,41 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jta.platform.spi;
+package org.hibernate.engine.transaction.jta.platform.spi;
 
 import org.hibernate.HibernateException;
 
 /**
  * Indicates a problem interacting with the underlying JTA platform.
  *
  * @author Steve Ebersole
  */
 public class JtaPlatformException extends HibernateException {
 	public JtaPlatformException(String s) {
 		super( s );
 	}
 
 	public JtaPlatformException(String string, Throwable root) {
 		super( string, root );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/AbstractTransactionImpl.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/AbstractTransactionImpl.java
index 22463d4282..a1e8cf2bcd 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/AbstractTransactionImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/AbstractTransactionImpl.java
@@ -1,249 +1,249 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.transaction.spi;
 
 import javax.transaction.Status;
 import javax.transaction.Synchronization;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.TransactionException;
 import org.hibernate.internal.CoreMessageLogger;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 
 /**
  * Abstract support for creating {@link TransactionImplementor transaction} implementations
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractTransactionImpl implements TransactionImplementor {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class,
                                                                        AbstractTransactionImpl.class.getName());
 
 	private final TransactionCoordinator transactionCoordinator;
 
 	private boolean valid = true;
 
 	private LocalStatus localStatus = LocalStatus.NOT_ACTIVE;
 	private int timeout = -1;
 
 	protected AbstractTransactionImpl(TransactionCoordinator transactionCoordinator) {
 		this.transactionCoordinator = transactionCoordinator;
 	}
 
 	@Override
 	public void invalidate() {
 		valid = false;
 	}
 
 	/**
 	 * Perform the actual steps of beginning a transaction according to the strategy.
 	 *
 	 * @throws org.hibernate.TransactionException Indicates a problem beginning the transaction
 	 */
 	protected abstract void doBegin();
 
 	/**
 	 * Perform the actual steps of committing a transaction according to the strategy.
 	 *
 	 * @throws org.hibernate.TransactionException Indicates a problem committing the transaction
 	 */
 	protected abstract void doCommit();
 
 	/**
 	 * Perform the actual steps of rolling back a transaction according to the strategy.
 	 *
 	 * @throws org.hibernate.TransactionException Indicates a problem rolling back the transaction
 	 */
 	protected abstract void doRollback();
 
 	protected abstract void afterTransactionBegin();
 	protected abstract void beforeTransactionCommit();
 	protected abstract void beforeTransactionRollBack();
 	protected abstract void afterTransactionCompletion(int status);
 	protected abstract void afterAfterCompletion();
 
 	/**
 	 * Provide subclasses with access to the transaction coordinator.
 	 *
 	 * @return This transaction's context.
 	 */
 	protected TransactionCoordinator transactionCoordinator() {
 		return transactionCoordinator;
 	}
 
 	/**
 	 * Provide subclasses with convenient access to the configured {@link JtaPlatform}
 	 *
-	 * @return The {@link org.hibernate.service.jta.platform.spi.JtaPlatform}
+	 * @return The {@link org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform}
 	 */
 	protected JtaPlatform jtaPlatform() {
 		return transactionCoordinator().getTransactionContext().getTransactionEnvironment().getJtaPlatform();
 	}
 
 	@Override
 	public void registerSynchronization(Synchronization synchronization) {
 		transactionCoordinator().getSynchronizationRegistry().registerSynchronization( synchronization );
 	}
 
 	@Override
 	public LocalStatus getLocalStatus() {
 		return localStatus;
 	}
 
 	@Override
 	public boolean isActive() {
 		return localStatus == LocalStatus.ACTIVE && doExtendedActiveCheck();
 	}
 
 	@Override
 	public boolean isParticipating() {
 		return getJoinStatus() == JoinStatus.JOINED && isActive();
 	}
 
 	@Override
 	public boolean wasCommitted() {
 		return localStatus == LocalStatus.COMMITTED;
 	}
 
 	@Override
 	public boolean wasRolledBack() throws HibernateException {
 		return localStatus == LocalStatus.ROLLED_BACK;
 	}
 
 	/**
 	 * Active has been checked against local state.  Perform any needed checks against resource transactions.
 	 *
 	 * @return {@code true} if the extended active check checks out as well; false otherwise.
 	 */
 	protected boolean doExtendedActiveCheck() {
 		return true;
 	}
 
 	@Override
 	public void begin() throws HibernateException {
 		if ( ! valid ) {
 			throw new TransactionException( "Transaction instance is no longer valid" );
 		}
 		if ( localStatus == LocalStatus.ACTIVE ) {
 			throw new TransactionException( "nested transactions not supported" );
 		}
 		if ( localStatus != LocalStatus.NOT_ACTIVE ) {
 			throw new TransactionException( "reuse of Transaction instances not supported" );
 		}
 
 		LOG.debug( "begin" );
 
 		doBegin();
 
 		localStatus = LocalStatus.ACTIVE;
 
 		afterTransactionBegin();
 	}
 
 	@Override
 	public void commit() throws HibernateException {
 		if ( localStatus != LocalStatus.ACTIVE ) {
 			throw new TransactionException( "Transaction not successfully started" );
 		}
 
 		LOG.debug( "committing" );
 
 		beforeTransactionCommit();
 
 		try {
 			doCommit();
 			localStatus = LocalStatus.COMMITTED;
 			afterTransactionCompletion( Status.STATUS_COMMITTED );
 		}
 		catch ( Exception e ) {
 			localStatus = LocalStatus.FAILED_COMMIT;
 			afterTransactionCompletion( Status.STATUS_UNKNOWN );
 			throw new TransactionException( "commit failed", e );
 		}
 		finally {
 			invalidate();
 			afterAfterCompletion();
 		}
 	}
 
 	protected boolean allowFailedCommitToPhysicallyRollback() {
 		return false;
 	}
 
 	@Override
 	public void rollback() throws HibernateException {
 		if ( localStatus != LocalStatus.ACTIVE && localStatus != LocalStatus.FAILED_COMMIT ) {
 			throw new TransactionException( "Transaction not successfully started" );
 		}
 
 		LOG.debug( "rolling back" );
 
 		beforeTransactionRollBack();
 
 		if ( localStatus != LocalStatus.FAILED_COMMIT || allowFailedCommitToPhysicallyRollback() ) {
 			try {
 				doRollback();
 				localStatus = LocalStatus.ROLLED_BACK;
 				afterTransactionCompletion( Status.STATUS_ROLLEDBACK );
 			}
 			catch ( Exception e ) {
 				afterTransactionCompletion( Status.STATUS_UNKNOWN );
 				throw new TransactionException( "rollback failed", e );
 			}
 			finally {
 				invalidate();
 				afterAfterCompletion();
 			}
 		}
 
 	}
 
 	@Override
 	public void setTimeout(int seconds) {
 		timeout = seconds;
 	}
 
 	@Override
 	public int getTimeout() {
 		return timeout;
 	}
 
 	@Override
 	public void markForJoin() {
 		// generally speaking this is no-op
 	}
 
 	@Override
 	public void join() {
 		// generally speaking this is no-op
 	}
 
 	@Override
 	public void resetJoinStatus() {
 		// generally speaking this is no-op
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionEnvironment.java b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionEnvironment.java
index 65a5f5c622..e3e9e19f5a 100644
--- a/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionEnvironment.java
+++ b/hibernate-core/src/main/java/org/hibernate/engine/transaction/spi/TransactionEnvironment.java
@@ -1,71 +1,71 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.engine.transaction.spi;
 
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.stat.spi.StatisticsImplementor;
 
 /**
  * Provides access to transactional services.
  *
  * @author Steve Ebersole
  */
 public interface TransactionEnvironment {
 	/**
 	 * Retrieve the session factory for this environment.
 	 *
 	 * @return The session factory
 	 */
 	public SessionFactoryImplementor getSessionFactory();
 
 	/**
 	 * Retrieve the JDBC services for this environment.
 	 *
 	 * @return The JDBC services
 	 */
 	public JdbcServices getJdbcServices();
 
 	/**
 	 * Retrieve the JTA platform for this environment.
 	 *
 	 * @return The JTA platform
 	 */
 	public JtaPlatform getJtaPlatform();
 
 	/**
 	 * Retrieve the transaction factory for this environment.
 	 *
 	 * @return The transaction factory
 	 */
 	public TransactionFactory getTransactionFactory();
 
 	/**
 	 * Get access to the statistics collector
 	 *
 	 * @return The statistics collector
 	 */
 	public StatisticsImplementor getStatisticsImplementor();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/id/factory/internal/MutableIdentifierGeneratorFactoryInitiator.java b/hibernate-core/src/main/java/org/hibernate/id/factory/internal/MutableIdentifierGeneratorFactoryInitiator.java
index 92808e6379..868902fb29 100644
--- a/hibernate-core/src/main/java/org/hibernate/id/factory/internal/MutableIdentifierGeneratorFactoryInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/id/factory/internal/MutableIdentifierGeneratorFactoryInitiator.java
@@ -1,24 +1,24 @@
 package org.hibernate.id.factory.internal;
 
 import java.util.Map;
 
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.id.factory.spi.MutableIdentifierGeneratorFactory;
-import org.hibernate.service.spi.BasicServiceInitiator;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * @author Emmanuel Bernard <emmanuel@hibernate.org>
  */
-public class MutableIdentifierGeneratorFactoryInitiator implements BasicServiceInitiator<MutableIdentifierGeneratorFactory> {
+public class MutableIdentifierGeneratorFactoryInitiator implements StandardServiceInitiator<MutableIdentifierGeneratorFactory> {
 	public static final MutableIdentifierGeneratorFactoryInitiator INSTANCE = new MutableIdentifierGeneratorFactoryInitiator();
 
 	@Override
 	public Class<MutableIdentifierGeneratorFactory> getServiceInitiated() {
 		return MutableIdentifierGeneratorFactory.class;
 	}
 
 	@Override
 	public MutableIdentifierGeneratorFactory initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		return new DefaultIdentifierGeneratorFactory();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/integrator/internal/IntegratorServiceImpl.java b/hibernate-core/src/main/java/org/hibernate/integrator/internal/IntegratorServiceImpl.java
index 4ffa634769..b4cd7872d7 100644
--- a/hibernate-core/src/main/java/org/hibernate/integrator/internal/IntegratorServiceImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/integrator/internal/IntegratorServiceImpl.java
@@ -1,67 +1,67 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.integrator.internal;
 
 import java.util.LinkedHashSet;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.cfg.beanvalidation.BeanValidationIntegrator;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.integrator.spi.IntegratorService;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 /**
  * @author Steve Ebersole
  */
 public class IntegratorServiceImpl implements IntegratorService {
 	private static final Logger LOG = Logger.getLogger( IntegratorServiceImpl.class.getName() );
 
 	private final LinkedHashSet<Integrator> integrators = new LinkedHashSet<Integrator>();
 
 	public IntegratorServiceImpl(LinkedHashSet<Integrator> providedIntegrators, ClassLoaderService classLoaderService) {
 		// register standard integrators.  Envers and JPA, for example, need to be handled by discovery because in
 		// separate project/jars.
 		addIntegrator( new BeanValidationIntegrator() );
 
 		// register provided integrators
 		for ( Integrator integrator : providedIntegrators ) {
 			addIntegrator( integrator );
 		}
 
 		for ( Integrator integrator : classLoaderService.loadJavaServices( Integrator.class ) ) {
 			addIntegrator( integrator );
 		}
 	}
 
 	private void addIntegrator(Integrator integrator) {
 		LOG.debugf( "Adding Integrator [%s].", integrator.getClass().getName() );
 		integrators.add( integrator );
 	}
 
 	@Override
 	public Iterable<Integrator> getIntegrators() {
 		return integrators;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/integrator/spi/ServiceContributingIntegrator.java b/hibernate-core/src/main/java/org/hibernate/integrator/spi/ServiceContributingIntegrator.java
index 94154ef952..ccb136bb12 100644
--- a/hibernate-core/src/main/java/org/hibernate/integrator/spi/ServiceContributingIntegrator.java
+++ b/hibernate-core/src/main/java/org/hibernate/integrator/spi/ServiceContributingIntegrator.java
@@ -1,42 +1,42 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.integrator.spi;
 
-import org.hibernate.service.ServiceRegistryBuilder;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 
 /**
  * Additional, optional contract for Integrators that wish to contribute {@link org.hibernate.service.Service services}
  * to the Hibernate {@link org.hibernate.service.ServiceRegistry}.
  *
  * @author Steve Ebersole
  */
 public interface ServiceContributingIntegrator extends Integrator {
 	/**
 	 * Allow the integrator to alter the builder of {@link org.hibernate.service.ServiceRegistry}, presumably to
 	 * register services into it.
 	 *
 	 * @param serviceRegistryBuilder The build to prepare.
 	 */
-	public void prepareServices(ServiceRegistryBuilder serviceRegistryBuilder);
+	public void prepareServices(StandardServiceRegistryBuilder serviceRegistryBuilder);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/AbstractSessionImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/AbstractSessionImpl.java
index 51bf9caabd..8b51b21036 100755
--- a/hibernate-core/src/main/java/org/hibernate/internal/AbstractSessionImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/AbstractSessionImpl.java
@@ -1,371 +1,371 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import java.io.Serializable;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.List;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MappingException;
 import org.hibernate.MultiTenancyStrategy;
 import org.hibernate.Query;
 import org.hibernate.SQLQuery;
 import org.hibernate.ScrollableResults;
 import org.hibernate.SessionException;
 import org.hibernate.SharedSessionContract;
 import org.hibernate.StoredProcedureCall;
 import org.hibernate.cache.spi.CacheKey;
 import org.hibernate.engine.jdbc.LobCreationContext;
 import org.hibernate.engine.jdbc.spi.JdbcConnectionAccess;
 import org.hibernate.engine.query.spi.HQLQueryPlan;
 import org.hibernate.engine.query.spi.NativeSQLQueryPlan;
 import org.hibernate.engine.query.spi.ParameterMetadata;
 import org.hibernate.engine.query.spi.sql.NativeSQLQuerySpecification;
 import org.hibernate.engine.spi.EntityKey;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.transaction.spi.TransactionContext;
 import org.hibernate.engine.transaction.spi.TransactionEnvironment;
 import org.hibernate.jdbc.WorkExecutor;
 import org.hibernate.jdbc.WorkExecutorVisitable;
 import org.hibernate.persister.entity.EntityPersister;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
-import org.hibernate.service.jdbc.connections.spi.MultiTenantConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
 import org.hibernate.type.Type;
 
 /**
  * Functionality common to stateless and stateful sessions
  *
  * @author Gavin King
  */
 public abstract class AbstractSessionImpl implements Serializable, SharedSessionContract,
 													 SessionImplementor, TransactionContext {
 	protected transient SessionFactoryImpl factory;
 	private final String tenantIdentifier;
 	private boolean closed = false;
 
 	protected AbstractSessionImpl(SessionFactoryImpl factory, String tenantIdentifier) {
 		this.factory = factory;
 		this.tenantIdentifier = tenantIdentifier;
 		if ( MultiTenancyStrategy.NONE == factory.getSettings().getMultiTenancyStrategy() ) {
 			if ( tenantIdentifier != null ) {
 				throw new HibernateException( "SessionFactory was not configured for multi-tenancy" );
 			}
 		}
 		else {
 			if ( tenantIdentifier == null ) {
 				throw new HibernateException( "SessionFactory configured for multi-tenancy, but no tenant identifier specified" );
 			}
 		}
 	}
 
 	public SessionFactoryImplementor getFactory() {
 		return factory;
 	}
 
 	@Override
 	public TransactionEnvironment getTransactionEnvironment() {
 		return factory.getTransactionEnvironment();
 	}
 
 	@Override
 	public <T> T execute(final LobCreationContext.Callback<T> callback) {
 		return getTransactionCoordinator().getJdbcCoordinator().coordinateWork(
 				new WorkExecutorVisitable<T>() {
 					@Override
 					public T accept(WorkExecutor<T> workExecutor, Connection connection) throws SQLException {
 						try {
 							return callback.executeOnConnection( connection );
 						}
 						catch (SQLException e) {
 							throw getFactory().getSQLExceptionHelper().convert(
 									e,
 									"Error creating contextual LOB : " + e.getMessage()
 							);
 						}
 					}
 				}
 		);
 	}
 
 	@Override
 	public boolean isClosed() {
 		return closed;
 	}
 
 	protected void setClosed() {
 		closed = true;
 	}
 
 	protected void errorIfClosed() {
 		if ( closed ) {
 			throw new SessionException( "Session is closed!" );
 		}
 	}
 
 	@Override
 	public Query getNamedQuery(String queryName) throws MappingException {
 		errorIfClosed();
 		NamedQueryDefinition nqd = factory.getNamedQuery( queryName );
 		final Query query;
 		if ( nqd != null ) {
 			String queryString = nqd.getQueryString();
 			query = new QueryImpl(
 					queryString,
 			        nqd.getFlushMode(),
 			        this,
 			        getHQLQueryPlan( queryString, false ).getParameterMetadata()
 			);
 			query.setComment( "named HQL query " + queryName );
 			if ( nqd.getLockOptions() != null ) {
 				query.setLockOptions( nqd.getLockOptions() );
 			}
 		}
 		else {
 			NamedSQLQueryDefinition nsqlqd = factory.getNamedSQLQuery( queryName );
 			if ( nsqlqd==null ) {
 				throw new MappingException( "Named query not known: " + queryName );
 			}
 			ParameterMetadata parameterMetadata = factory.getQueryPlanCache().getSQLParameterMetadata( nsqlqd.getQueryString() );
 			query = new SQLQueryImpl(
 					nsqlqd,
 			        this,
 					parameterMetadata
 			);
 			query.setComment( "named native SQL query " + queryName );
 			nqd = nsqlqd;
 		}
 		initQuery( query, nqd );
 		return query;
 	}
 
 	@Override
 	public Query getNamedSQLQuery(String queryName) throws MappingException {
 		errorIfClosed();
 		NamedSQLQueryDefinition nsqlqd = factory.getNamedSQLQuery( queryName );
 		if ( nsqlqd==null ) {
 			throw new MappingException( "Named SQL query not known: " + queryName );
 		}
 		Query query = new SQLQueryImpl(
 				nsqlqd,
 		        this,
 		        factory.getQueryPlanCache().getSQLParameterMetadata( nsqlqd.getQueryString() )
 		);
 		query.setComment( "named native SQL query " + queryName );
 		initQuery( query, nsqlqd );
 		return query;
 	}
 
 	@SuppressWarnings("UnnecessaryUnboxing")
 	private void initQuery(Query query, NamedQueryDefinition nqd) {
 		// todo : cacheable and readonly should be Boolean rather than boolean...
 		query.setCacheable( nqd.isCacheable() );
 		query.setCacheRegion( nqd.getCacheRegion() );
 		query.setReadOnly( nqd.isReadOnly() );
 
 		if ( nqd.getTimeout() != null ) {
 			query.setTimeout( nqd.getTimeout().intValue() );
 		}
 		if ( nqd.getFetchSize() != null ) {
 			query.setFetchSize( nqd.getFetchSize().intValue() );
 		}
 		if ( nqd.getCacheMode() != null ) {
 			query.setCacheMode( nqd.getCacheMode() );
 		}
 		if ( nqd.getComment() != null ) {
 			query.setComment( nqd.getComment() );
 		}
 		if ( nqd.getFirstResult() != null ) {
 			query.setFirstResult( nqd.getFirstResult() );
 		}
 		if ( nqd.getMaxResults() != null ) {
 			query.setMaxResults( nqd.getMaxResults() );
 		}
 		if ( nqd.getFlushMode() != null ) {
 			query.setFlushMode( nqd.getFlushMode() );
 		}
 	}
 
 	@Override
 	public Query createQuery(String queryString) {
 		errorIfClosed();
 		QueryImpl query = new QueryImpl(
 				queryString,
 		        this,
 		        getHQLQueryPlan( queryString, false ).getParameterMetadata()
 		);
 		query.setComment( queryString );
 		return query;
 	}
 
 	@Override
 	public SQLQuery createSQLQuery(String sql) {
 		errorIfClosed();
 		SQLQueryImpl query = new SQLQueryImpl(
 				sql,
 		        this,
 		        factory.getQueryPlanCache().getSQLParameterMetadata( sql )
 		);
 		query.setComment( "dynamic native SQL query" );
 		return query;
 	}
 
 	@Override
 	@SuppressWarnings("UnnecessaryLocalVariable")
 	public StoredProcedureCall createStoredProcedureCall(String procedureName) {
 		errorIfClosed();
 		final StoredProcedureCall call = new StoredProcedureCallImpl( this, procedureName );
 //		call.setComment( "Dynamic stored procedure call" );
 		return call;
 	}
 
 	@Override
 	@SuppressWarnings("UnnecessaryLocalVariable")
 	public StoredProcedureCall createStoredProcedureCall(String procedureName, Class... resultClasses) {
 		errorIfClosed();
 		final StoredProcedureCall call = new StoredProcedureCallImpl( this, procedureName, resultClasses );
 //		call.setComment( "Dynamic stored procedure call" );
 		return call;
 	}
 
 	@Override
 	@SuppressWarnings("UnnecessaryLocalVariable")
 	public StoredProcedureCall createStoredProcedureCall(String procedureName, String... resultSetMappings) {
 		errorIfClosed();
 		final StoredProcedureCall call = new StoredProcedureCallImpl( this, procedureName, resultSetMappings );
 //		call.setComment( "Dynamic stored procedure call" );
 		return call;
 	}
 
 	protected HQLQueryPlan getHQLQueryPlan(String query, boolean shallow) throws HibernateException {
 		return factory.getQueryPlanCache().getHQLQueryPlan( query, shallow, getEnabledFilters() );
 	}
 
 	protected NativeSQLQueryPlan getNativeSQLQueryPlan(NativeSQLQuerySpecification spec) throws HibernateException {
 		return factory.getQueryPlanCache().getNativeSQLQueryPlan( spec );
 	}
 
 	@Override
 	public List list(NativeSQLQuerySpecification spec, QueryParameters queryParameters)
 			throws HibernateException {
 		return listCustomQuery( getNativeSQLQueryPlan( spec ).getCustomQuery(), queryParameters );
 	}
 
 	@Override
 	public ScrollableResults scroll(NativeSQLQuerySpecification spec, QueryParameters queryParameters)
 			throws HibernateException {
 		return scrollCustomQuery( getNativeSQLQueryPlan( spec ).getCustomQuery(), queryParameters );
 	}
 
 	@Override
 	public String getTenantIdentifier() {
 		return tenantIdentifier;
 	}
 
 	@Override
 	public EntityKey generateEntityKey(Serializable id, EntityPersister persister) {
 		return new EntityKey( id, persister, getTenantIdentifier() );
 	}
 
 	@Override
 	public CacheKey generateCacheKey(Serializable id, Type type, String entityOrRoleName) {
 		return new CacheKey( id, type, entityOrRoleName, getTenantIdentifier(), getFactory() );
 	}
 
 	private transient JdbcConnectionAccess jdbcConnectionAccess;
 
 	@Override
 	public JdbcConnectionAccess getJdbcConnectionAccess() {
 		if ( jdbcConnectionAccess == null ) {
 			if ( MultiTenancyStrategy.NONE == factory.getSettings().getMultiTenancyStrategy() ) {
 				jdbcConnectionAccess = new NonContextualJdbcConnectionAccess(
 						factory.getServiceRegistry().getService( ConnectionProvider.class )
 				);
 			}
 			else {
 				jdbcConnectionAccess = new ContextualJdbcConnectionAccess(
 						factory.getServiceRegistry().getService( MultiTenantConnectionProvider.class )
 				);
 			}
 		}
 		return jdbcConnectionAccess;
 	}
 
 	private static class NonContextualJdbcConnectionAccess implements JdbcConnectionAccess, Serializable {
 		private final ConnectionProvider connectionProvider;
 
 		private NonContextualJdbcConnectionAccess(ConnectionProvider connectionProvider) {
 			this.connectionProvider = connectionProvider;
 		}
 
 		@Override
 		public Connection obtainConnection() throws SQLException {
 			return connectionProvider.getConnection();
 		}
 
 		@Override
 		public void releaseConnection(Connection connection) throws SQLException {
 			connectionProvider.closeConnection( connection );
 		}
 
 		@Override
 		public boolean supportsAggressiveRelease() {
 			return connectionProvider.supportsAggressiveRelease();
 		}
 	}
 
 	private class ContextualJdbcConnectionAccess implements JdbcConnectionAccess, Serializable {
 		private final MultiTenantConnectionProvider connectionProvider;
 
 		private ContextualJdbcConnectionAccess(MultiTenantConnectionProvider connectionProvider) {
 			this.connectionProvider = connectionProvider;
 		}
 
 		@Override
 		public Connection obtainConnection() throws SQLException {
 			if ( tenantIdentifier == null ) {
 				throw new HibernateException( "Tenant identifier required!" );
 			}
 			return connectionProvider.getConnection( tenantIdentifier );
 		}
 
 		@Override
 		public void releaseConnection(Connection connection) throws SQLException {
 			if ( tenantIdentifier == null ) {
 				throw new HibernateException( "Tenant identifier required!" );
 			}
 			connectionProvider.releaseConnection( tenantIdentifier, connection );
 		}
 
 		@Override
 		public boolean supportsAggressiveRelease() {
 			return connectionProvider.supportsAggressiveRelease();
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/CoreMessageLogger.java b/hibernate-core/src/main/java/org/hibernate/internal/CoreMessageLogger.java
index 4cc0fd0986..8f2daf2efc 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/CoreMessageLogger.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/CoreMessageLogger.java
@@ -1,1057 +1,1057 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import java.io.File;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.lang.reflect.Method;
 import java.net.URL;
 import java.sql.SQLException;
 import java.sql.SQLWarning;
 import java.util.Hashtable;
 import java.util.Properties;
 import java.util.Set;
 import javax.naming.NameNotFoundException;
 import javax.naming.NamingException;
 import javax.transaction.Synchronization;
 import javax.transaction.SystemException;
 
 import org.jboss.logging.BasicLogger;
 import org.jboss.logging.Cause;
 import org.jboss.logging.LogMessage;
 import org.jboss.logging.Message;
 import org.jboss.logging.MessageLogger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cache.CacheException;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.loading.internal.CollectionLoadContext;
 import org.hibernate.engine.loading.internal.EntityLoadContext;
 import org.hibernate.engine.spi.CollectionKey;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.id.IntegralDataTypeHolder;
-import org.hibernate.service.jdbc.dialect.internal.AbstractDialectResolver;
-import org.hibernate.service.jndi.JndiException;
-import org.hibernate.service.jndi.JndiNameException;
+import org.hibernate.engine.jdbc.dialect.internal.AbstractDialectResolver;
+import org.hibernate.engine.jndi.JndiException;
+import org.hibernate.engine.jndi.JndiNameException;
 import org.hibernate.type.BasicType;
 import org.hibernate.type.SerializationException;
 import org.hibernate.type.Type;
 
 import static org.jboss.logging.Logger.Level.DEBUG;
 import static org.jboss.logging.Logger.Level.ERROR;
 import static org.jboss.logging.Logger.Level.INFO;
 import static org.jboss.logging.Logger.Level.WARN;
 
 /**
  * The jboss-logging {@link MessageLogger} for the hibernate-core module.  It reserves message ids ranging from
  * 00001 to 10000 inclusively.
  * <p/>
  * New messages must be added after the last message defined to ensure message codes are unique.
  */
 @MessageLogger(projectCode = "HHH")
 public interface CoreMessageLogger extends BasicLogger {
 
 	@LogMessage(level = WARN)
 	@Message(value = "Already session bound on call to bind(); make sure you clean up your sessions!", id = 2)
 	void alreadySessionBound();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Autocommit mode: %s", id = 6)
 	void autoCommitMode(boolean autocommit);
 
 	@LogMessage(level = WARN)
 	@Message(value = "JTASessionContext being used with JDBCTransactionFactory; auto-flush will not operate correctly with getCurrentSession()",
 			id = 8)
 	void autoFlushWillNotWork();
 
 	@LogMessage(level = INFO)
 	@Message(value = "On release of batch it still contained JDBC statements", id = 10)
 	void batchContainedStatementsOnRelease();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Bytecode provider name : %s", id = 21)
 	void bytecodeProvider(String provider);
 
 	@LogMessage(level = WARN)
 	@Message(value = "c3p0 properties were encountered, but the %s provider class was not found on the classpath; these properties are going to be ignored.",
 			id = 22)
 	void c3p0ProviderClassNotFound(String c3p0ProviderClassName);
 
 	@LogMessage(level = WARN)
 	@Message(value = "I/O reported cached file could not be found : %s : %s", id = 23)
 	void cachedFileNotFound(String path,
 							FileNotFoundException error);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Cache provider: %s", id = 24)
 	void cacheProvider(String name);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Calling joinTransaction() on a non JTA EntityManager", id = 27)
 	void callingJoinTransactionOnNonJtaEntityManager();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Cleaning up connection pool [%s]", id = 30)
 	void cleaningUpConnectionPool(String url);
 
 	@LogMessage(level = DEBUG)
 	@Message(value = "Closing", id = 31)
 	void closing();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Collections fetched (minimize this): %s", id = 32)
 	void collectionsFetched(long collectionFetchCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Collections loaded: %s", id = 33)
 	void collectionsLoaded(long collectionLoadCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Collections recreated: %s", id = 34)
 	void collectionsRecreated(long collectionRecreateCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Collections removed: %s", id = 35)
 	void collectionsRemoved(long collectionRemoveCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Collections updated: %s", id = 36)
 	void collectionsUpdated(long collectionUpdateCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Columns: %s", id = 37)
 	void columns(Set keySet);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Composite-id class does not override equals(): %s", id = 38)
 	void compositeIdClassDoesNotOverrideEquals(String name);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Composite-id class does not override hashCode(): %s", id = 39)
 	void compositeIdClassDoesNotOverrideHashCode(String name);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Configuration resource: %s", id = 40)
 	void configurationResource(String resource);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Configured SessionFactory: %s", id = 41)
 	void configuredSessionFactory(String name);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Configuring from file: %s", id = 42)
 	void configuringFromFile(String file);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Configuring from resource: %s", id = 43)
 	void configuringFromResource(String resource);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Configuring from URL: %s", id = 44)
 	void configuringFromUrl(URL url);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Configuring from XML document", id = 45)
 	void configuringFromXmlDocument();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Connection properties: %s", id = 46)
 	void connectionProperties(Properties connectionProps);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Connections obtained: %s", id = 48)
 	void connectionsObtained(long connectCount);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Container is providing a null PersistenceUnitRootUrl: discovery impossible", id = 50)
 	void containerProvidingNullPersistenceUnitRootUrl();
 
 	@LogMessage(level = WARN)
 	@Message(value = "Ignoring bag join fetch [%s] due to prior collection join fetch", id = 51)
 	void containsJoinFetchedCollection(String role);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Creating subcontext: %s", id = 53)
 	void creatingSubcontextInfo(String intermediateContextName);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Defining %s=true ignored in HEM", id = 59)
 	void definingFlushBeforeCompletionIgnoredInHem(String flushBeforeCompletion);
 
 	@LogMessage(level = WARN)
 	@Message(value = "@ForceDiscriminator is deprecated use @DiscriminatorOptions instead.", id = 62)
 	void deprecatedForceDescriminatorAnnotation();
 
 	@LogMessage(level = WARN)
 	@Message(value = "The Oracle9Dialect dialect has been deprecated; use either Oracle9iDialect or Oracle10gDialect instead",
 			id = 63)
 	void deprecatedOracle9Dialect();
 
 	@LogMessage(level = WARN)
 	@Message(value = "The OracleDialect dialect has been deprecated; use Oracle8iDialect instead", id = 64)
 	void deprecatedOracleDialect();
 
 	@LogMessage(level = WARN)
 	@Message(value = "DEPRECATED : use [%s] instead with custom [%s] implementation", id = 65)
 	void deprecatedUuidGenerator(String name,
 								 String name2);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Disallowing insert statement comment for select-identity due to Oracle driver bug", id = 67)
 	void disallowingInsertStatementComment();
 
 	@LogMessage(level = WARN)
 	@Message(value = "Duplicate generator name %s", id = 69)
 	void duplicateGeneratorName(String name);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Duplicate generator table: %s", id = 70)
 	void duplicateGeneratorTable(String name);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Duplicate import: %s -> %s", id = 71)
 	void duplicateImport(String entityName,
 						 String rename);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Duplicate joins for class: %s", id = 72)
 	void duplicateJoins(String entityName);
 
 	@LogMessage(level = INFO)
 	@Message(value = "entity-listener duplication, first event definition will be used: %s", id = 73)
 	void duplicateListener(String className);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Found more than one <persistence-unit-metadata>, subsequent ignored", id = 74)
 	void duplicateMetadata();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Entities deleted: %s", id = 76)
 	void entitiesDeleted(long entityDeleteCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Entities fetched (minimize this): %s", id = 77)
 	void entitiesFetched(long entityFetchCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Entities inserted: %s", id = 78)
 	void entitiesInserted(long entityInsertCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Entities loaded: %s", id = 79)
 	void entitiesLoaded(long entityLoadCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Entities updated: %s", id = 80)
 	void entitiesUpdated(long entityUpdateCount);
 
 	@LogMessage(level = WARN)
 	@Message(value = "@org.hibernate.annotations.Entity used on a non root entity: ignored for %s", id = 81)
 	void entityAnnotationOnNonRoot(String className);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Entity Manager closed by someone else (%s must not be used)", id = 82)
 	void entityManagerClosedBySomeoneElse(String autoCloseSession);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Entity [%s] is abstract-class/interface explicitly mapped as non-abstract; be sure to supply entity-names",
 			id = 84)
 	void entityMappedAsNonAbstract(String name);
 
 	@LogMessage(level = INFO)
 	@Message(value = "%s %s found", id = 85)
 	void exceptionHeaderFound(String exceptionHeader,
 							  String metaInfOrmXml);
 
 	@LogMessage(level = INFO)
 	@Message(value = "%s No %s found", id = 86)
 	void exceptionHeaderNotFound(String exceptionHeader,
 								 String metaInfOrmXml);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Exception in interceptor afterTransactionCompletion()", id = 87)
 	void exceptionInAfterTransactionCompletionInterceptor(@Cause Throwable e);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Exception in interceptor beforeTransactionCompletion()", id = 88)
 	void exceptionInBeforeTransactionCompletionInterceptor(@Cause Throwable e);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Sub-resolver threw unexpected exception, continuing to next : %s", id = 89)
 	void exceptionInSubResolver(String message);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Expected type: %s, actual value: %s", id = 91)
 	void expectedType(String name,
 					  String string);
 
 	@LogMessage(level = WARN)
 	@Message(value = "An item was expired by the cache while it was locked (increase your cache timeout): %s", id = 92)
 	void expired(Object key);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Bound factory to JNDI name: %s", id = 94)
 	void factoryBoundToJndiName(String name);
 
 	@LogMessage(level = INFO)
 	@Message(value = "A factory was renamed from [%s] to [%s] in JNDI", id = 96)
 	void factoryJndiRename(String oldName, String newName);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Unbound factory from JNDI name: %s", id = 97)
 	void factoryUnboundFromJndiName(String name);
 
 	@LogMessage(level = INFO)
 	@Message(value = "A factory was unbound from name: %s", id = 98)
 	void factoryUnboundFromName(String name);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "an assertion failure occured" + " (this may indicate a bug in Hibernate, but is more likely due"
 			+ " to unsafe use of the session): %s", id = 99)
 	void failed(Throwable throwable);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Fail-safe cleanup (collections) : %s", id = 100)
 	void failSafeCollectionsCleanup(CollectionLoadContext collectionLoadContext);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Fail-safe cleanup (entities) : %s", id = 101)
 	void failSafeEntitiesCleanup(EntityLoadContext entityLoadContext);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Fetching database metadata", id = 102)
 	void fetchingDatabaseMetadata();
 
 	@LogMessage(level = WARN)
 	@Message(value = "firstResult/maxResults specified with collection fetch; applying in memory!", id = 104)
 	void firstOrMaxResultsSpecifiedWithCollectionFetch();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Flushes: %s", id = 105)
 	void flushes(long flushCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Forcing container resource cleanup on transaction completion", id = 106)
 	void forcingContainerResourceCleanup();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Forcing table use for sequence-style generator due to pooled optimizer selection where db does not support pooled sequences",
 			id = 107)
 	void forcingTableUse();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Foreign keys: %s", id = 108)
 	void foreignKeys(Set keySet);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Found mapping document in jar: %s", id = 109)
 	void foundMappingDocument(String name);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Getters of lazy classes cannot be final: %s.%s", id = 112)
 	void gettersOfLazyClassesCannotBeFinal(String entityName,
 										   String name);
 
 	@LogMessage(level = WARN)
 	@Message(value = "GUID identifier generated: %s", id = 113)
 	void guidGenerated(String result);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Handling transient entity in delete processing", id = 114)
 	void handlingTransientEntity();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Hibernate connection pool size: %s", id = 115)
 	void hibernateConnectionPoolSize(int poolSize);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Config specified explicit optimizer of [%s], but [%s=%s; honoring optimizer setting", id = 116)
 	void honoringOptimizerSetting(String none,
 								  String incrementParam,
 								  int incrementSize);
 
 	@LogMessage(level = DEBUG)
 	@Message(value = "HQL: %s, time: %sms, rows: %s", id = 117)
 	void hql(String hql,
 			 Long valueOf,
 			 Long valueOf2);
 
 	@LogMessage(level = WARN)
 	@Message(value = "HSQLDB supports only READ_UNCOMMITTED isolation", id = 118)
 	void hsqldbSupportsOnlyReadCommittedIsolation();
 
 	@LogMessage(level = WARN)
 	@Message(value = "On EntityLoadContext#clear, hydratingEntities contained [%s] entries", id = 119)
 	void hydratingEntitiesCount(int size);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Ignoring unique constraints specified on table generator [%s]", id = 120)
 	void ignoringTableGeneratorConstraints(String name);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Ignoring unrecognized query hint [%s]", id = 121)
 	void ignoringUnrecognizedQueryHint(String hintName);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "IllegalArgumentException in class: %s, getter method of property: %s", id = 122)
 	void illegalPropertyGetterArgument(String name,
 									   String propertyName);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "IllegalArgumentException in class: %s, setter method of property: %s", id = 123)
 	void illegalPropertySetterArgument(String name,
 									   String propertyName);
 
 	@LogMessage(level = WARN)
 	@Message(value = "@Immutable used on a non root entity: ignored for %s", id = 124)
 	void immutableAnnotationOnNonRoot(String className);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Mapping metadata cache was not completely processed", id = 125)
 	void incompleteMappingMetadataCacheProcessing();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Indexes: %s", id = 126)
 	void indexes(Set keySet);
 
 	@LogMessage(level = DEBUG)
 	@Message(value = "Could not bind JNDI listener", id = 127)
 	void couldNotBindJndiListener();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Instantiating explicit connection provider: %s", id = 130)
 	void instantiatingExplicitConnectionProvider(String providerClassName);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Array element type error\n%s", id = 132)
 	void invalidArrayElementType(String message);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Discriminator column has to be defined in the root entity, it will be ignored in subclass: %s",
 			id = 133)
 	void invalidDiscriminatorAnnotation(String className);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Application attempted to edit read only item: %s", id = 134)
 	void invalidEditOfReadOnlyItem(Object key);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Invalid JNDI name: %s", id = 135)
 	void invalidJndiName(String name,
 						 @Cause JndiNameException e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Inapropriate use of @OnDelete on entity, annotation ignored: %s", id = 136)
 	void invalidOnDeleteAnnotation(String entityName);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Root entity should not hold an PrimaryKeyJoinColum(s), will be ignored", id = 137)
 	void invalidPrimaryKeyJoinColumnAnnotation();
 
 	@LogMessage(level = WARN)
 	@Message(value = "Mixing inheritance strategy in a entity hierarchy is not allowed, ignoring sub strategy in: %s",
 			id = 138)
 	void invalidSubStrategy(String className);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Illegal use of @Table in a subclass of a SINGLE_TABLE hierarchy: %s", id = 139)
 	void invalidTableAnnotation(String className);
 
 	@LogMessage(level = INFO)
 	@Message(value = "JACC contextID: %s", id = 140)
 	void jaccContextId(String contextId);
 
 	@LogMessage(level = INFO)
 	@Message(value = "java.sql.Types mapped the same code [%s] multiple times; was [%s]; now [%s]", id = 141)
 	void JavaSqlTypesMappedSameCodeMultipleTimes(int code,
 												 String old,
 												 String name);
 
 	@Message(value = "Javassist Enhancement failed: %s", id = 142)
 	String javassistEnhancementFailed(String entityName);
 
 	@LogMessage(level = WARN)
 	@Message(value = "%s = false breaks the EJB3 specification", id = 144)
 	void jdbcAutoCommitFalseBreaksEjb3Spec(String autocommit);
 
 	@LogMessage(level = WARN)
 	@Message(value = "No JDBC Driver class was specified by property %s", id = 148)
 	void jdbcDriverNotSpecified(String driver);
 
 	@LogMessage(level = INFO)
 	@Message(value = "JDBC isolation level: %s", id = 149)
 	void jdbcIsolationLevel(String isolationLevelToString);
 
 	@Message(value = "JDBC rollback failed", id = 151)
 	String jdbcRollbackFailed();
 
 	@Message(value = "JDBC URL was not specified by property %s", id = 152)
 	String jdbcUrlNotSpecified(String url);
 
 	@LogMessage(level = INFO)
 	@Message(value = "JNDI InitialContext properties:%s", id = 154)
 	void jndiInitialContextProperties(Hashtable hash);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "JNDI name %s does not handle a session factory reference", id = 155)
 	void jndiNameDoesNotHandleSessionFactoryReference(String sfJNDIName,
 													  @Cause ClassCastException e);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Lazy property fetching available for: %s", id = 157)
 	void lazyPropertyFetchingAvailable(String name);
 
 	@LogMessage(level = WARN)
 	@Message(value = "In CollectionLoadContext#endLoadingCollections, localLoadingCollectionKeys contained [%s], but no LoadingCollectionEntry was found in loadContexts",
 			id = 159)
 	void loadingCollectionKeyNotFound(CollectionKey collectionKey);
 
 	@LogMessage(level = WARN)
 	@Message(value = "On CollectionLoadContext#cleanup, localLoadingCollectionKeys contained [%s] entries", id = 160)
 	void localLoadingCollectionKeysCount(int size);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Logging statistics....", id = 161)
 	void loggingStatistics();
 
 	@LogMessage(level = DEBUG)
 	@Message(value = "*** Logical connection closed ***", id = 162)
 	void logicalConnectionClosed();
 
 	@LogMessage(level = DEBUG)
 	@Message(value = "Logical connection releasing its physical connection", id = 163)
 	void logicalConnectionReleasingPhysicalConnection();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Max query time: %sms", id = 173)
 	void maxQueryTime(long queryExecutionMaxTime);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Function template anticipated %s arguments, but %s arguments encountered", id = 174)
 	void missingArguments(int anticipatedNumberOfArguments,
 						  int numberOfArguments);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Class annotated @org.hibernate.annotations.Entity but not javax.persistence.Entity (most likely a user error): %s",
 			id = 175)
 	void missingEntityAnnotation(String className);
 
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Error in named query: %s", id = 177)
 	void namedQueryError(String queryName,
 						 @Cause HibernateException e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Naming exception occurred accessing factory: %s", id = 178)
 	void namingExceptionAccessingFactory(NamingException exception);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Narrowing proxy to %s - this operation breaks ==", id = 179)
 	void narrowingProxy(Class concreteProxyClass);
 
 	@LogMessage(level = WARN)
 	@Message(value = "FirstResult/maxResults specified on polymorphic query; applying in memory!", id = 180)
 	void needsLimit();
 
 	@LogMessage(level = WARN)
 	@Message(value = "No appropriate connection provider encountered, assuming application will be supplying connections",
 			id = 181)
 	void noAppropriateConnectionProvider();
 
 	@LogMessage(level = INFO)
 	@Message(value = "No default (no-argument) constructor for class: %s (class must be instantiated by Interceptor)",
 			id = 182)
 	void noDefaultConstructor(String name);
 
 	@LogMessage(level = WARN)
 	@Message(value = "no persistent classes found for query class: %s", id = 183)
 	void noPersistentClassesFound(String query);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "No session factory with JNDI name %s", id = 184)
 	void noSessionFactoryWithJndiName(String sfJNDIName,
 									  @Cause NameNotFoundException e);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Optimistic lock failures: %s", id = 187)
 	void optimisticLockFailures(long optimisticFailureCount);
 
 	@LogMessage(level = WARN)
 	@Message(value = "@OrderBy not allowed for an indexed collection, annotation ignored.", id = 189)
 	void orderByAnnotationIndexedCollection();
 
 	@LogMessage(level = WARN)
 	@Message(value = "Overriding %s is dangerous, this might break the EJB3 specification implementation", id = 193)
 	void overridingTransactionStrategyDangerous(String transactionStrategy);
 
 	@LogMessage(level = DEBUG)
 	@Message(value = "Package not found or wo package-info.java: %s", id = 194)
 	void packageNotFound(String packageName);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Parameter position [%s] occurred as both JPA and Hibernate positional parameter", id = 195)
 	void parameterPositionOccurredAsBothJpaAndHibernatePositionalParameter(Integer position);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Error parsing XML (%s) : %s", id = 196)
 	void parsingXmlError(int lineNumber,
 						 String message);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Error parsing XML: %s(%s) %s", id = 197)
 	void parsingXmlErrorForFile(String file,
 								int lineNumber,
 								String message);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Warning parsing XML (%s) : %s", id = 198)
 	void parsingXmlWarning(int lineNumber,
 						   String message);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Warning parsing XML: %s(%s) %s", id = 199)
 	void parsingXmlWarningForFile(String file,
 								  int lineNumber,
 								  String message);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Persistence provider caller does not implement the EJB3 spec correctly."
 			+ "PersistenceUnitInfo.getNewTempClassLoader() is null.", id = 200)
 	void persistenceProviderCallerDoesNotImplementEjb3SpecCorrectly();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Pooled optimizer source reported [%s] as the initial value; use of 1 or greater highly recommended",
 			id = 201)
 	void pooledOptimizerReportedInitialValue(IntegralDataTypeHolder value);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "PreparedStatement was already in the batch, [%s].", id = 202)
 	void preparedStatementAlreadyInBatch(String sql);
 
 	@LogMessage(level = WARN)
 	@Message(value = "processEqualityExpression() : No expression to process!", id = 203)
 	void processEqualityExpression();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Processing PersistenceUnitInfo [\n\tname: %s\n\t...]", id = 204)
 	void processingPersistenceUnitInfoName(String persistenceUnitName);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Loaded properties from resource hibernate.properties: %s", id = 205)
 	void propertiesLoaded(Properties maskOut);
 
 	@LogMessage(level = INFO)
 	@Message(value = "hibernate.properties not found", id = 206)
 	void propertiesNotFound();
 
 	@LogMessage(level = WARN)
 	@Message(value = "Property %s not found in class but described in <mapping-file/> (possible typo error)", id = 207)
 	void propertyNotFound(String property);
 
 	@LogMessage(level = WARN)
 	@Message(value = "%s has been deprecated in favor of %s; that provider will be used instead.", id = 208)
 	void providerClassDeprecated(String providerClassName,
 								 String actualProviderClassName);
 
 	@LogMessage(level = WARN)
 	@Message(value = "proxool properties were encountered, but the %s provider class was not found on the classpath; these properties are going to be ignored.",
 			id = 209)
 	void proxoolProviderClassNotFound(String proxoolProviderClassName);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Queries executed to database: %s", id = 210)
 	void queriesExecuted(long queryExecutionCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Query cache hits: %s", id = 213)
 	void queryCacheHits(long queryCacheHitCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Query cache misses: %s", id = 214)
 	void queryCacheMisses(long queryCacheMissCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Query cache puts: %s", id = 215)
 	void queryCachePuts(long queryCachePutCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "RDMSOS2200Dialect version: 1.0", id = 218)
 	void rdmsOs2200Dialect();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Reading mappings from cache file: %s", id = 219)
 	void readingCachedMappings(File cachedFile);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Reading mappings from file: %s", id = 220)
 	void readingMappingsFromFile(String path);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Reading mappings from resource: %s", id = 221)
 	void readingMappingsFromResource(String resourceName);
 
 	@LogMessage(level = WARN)
 	@Message(value = "read-only cache configured for mutable collection [%s]", id = 222)
 	void readOnlyCacheConfiguredForMutableCollection(String name);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Recognized obsolete hibernate namespace %s. Use namespace %s instead. Refer to Hibernate 3.6 Migration Guide!",
 			id = 223)
 	void recognizedObsoleteHibernateNamespace(String oldHibernateNamespace,
 											  String hibernateNamespace);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Property [%s] has been renamed to [%s]; update your properties appropriately", id = 225)
 	void renamedProperty(Object propertyName,
 						 Object newPropertyName);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Required a different provider: %s", id = 226)
 	void requiredDifferentProvider(String provider);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Running hbm2ddl schema export", id = 227)
 	void runningHbm2ddlSchemaExport();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Running hbm2ddl schema update", id = 228)
 	void runningHbm2ddlSchemaUpdate();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Running schema validator", id = 229)
 	void runningSchemaValidator();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Schema export complete", id = 230)
 	void schemaExportComplete();
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Schema export unsuccessful", id = 231)
 	void schemaExportUnsuccessful(@Cause Exception e);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Schema update complete", id = 232)
 	void schemaUpdateComplete();
 
 	@LogMessage(level = WARN)
 	@Message(value = "Scoping types to session factory %s after already scoped %s", id = 233)
 	void scopingTypesToSessionFactoryAfterAlreadyScoped(SessionFactoryImplementor factory,
 														SessionFactoryImplementor factory2);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Searching for mapping documents in jar: %s", id = 235)
 	void searchingForMappingDocuments(String name);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Second level cache hits: %s", id = 237)
 	void secondLevelCacheHits(long secondLevelCacheHitCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Second level cache misses: %s", id = 238)
 	void secondLevelCacheMisses(long secondLevelCacheMissCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Second level cache puts: %s", id = 239)
 	void secondLevelCachePuts(long secondLevelCachePutCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Service properties: %s", id = 240)
 	void serviceProperties(Properties properties);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Sessions closed: %s", id = 241)
 	void sessionsClosed(long sessionCloseCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Sessions opened: %s", id = 242)
 	void sessionsOpened(long sessionOpenCount);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Setters of lazy classes cannot be final: %s.%s", id = 243)
 	void settersOfLazyClassesCannotBeFinal(String entityName,
 										   String name);
 
 	@LogMessage(level = WARN)
 	@Message(value = "@Sort not allowed for an indexed collection, annotation ignored.", id = 244)
 	void sortAnnotationIndexedCollection();
 
 	@LogMessage(level = WARN)
 	@Message(value = "Manipulation query [%s] resulted in [%s] split queries", id = 245)
 	void splitQueries(String sourceQuery,
 					  int length);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "SQLException escaped proxy", id = 246)
 	void sqlExceptionEscapedProxy(@Cause SQLException e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "SQL Error: %s, SQLState: %s", id = 247)
 	void sqlWarning(int errorCode,
 					String sqlState);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Starting query cache at region: %s", id = 248)
 	void startingQueryCache(String region);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Starting service at JNDI name: %s", id = 249)
 	void startingServiceAtJndiName(String boundName);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Starting update timestamps cache at region: %s", id = 250)
 	void startingUpdateTimestampsCache(String region);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Start time: %s", id = 251)
 	void startTime(long startTime);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Statements closed: %s", id = 252)
 	void statementsClosed(long closeStatementCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Statements prepared: %s", id = 253)
 	void statementsPrepared(long prepareStatementCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Stopping service", id = 255)
 	void stoppingService();
 
 	@LogMessage(level = INFO)
 	@Message(value = "sub-resolver threw unexpected exception, continuing to next : %s", id = 257)
 	void subResolverException(String message);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Successful transactions: %s", id = 258)
 	void successfulTransactions(long committedTransactionCount);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Synchronization [%s] was already registered", id = 259)
 	void synchronizationAlreadyRegistered(Synchronization synchronization);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Exception calling user Synchronization [%s] : %s", id = 260)
 	void synchronizationFailed(Synchronization synchronization,
 							   Throwable t);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Table found: %s", id = 261)
 	void tableFound(String string);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Table not found: %s", id = 262)
 	void tableNotFound(String name);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Transactions: %s", id = 266)
 	void transactions(long transactionCount);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Transaction started on non-root session", id = 267)
 	void transactionStartedOnNonRootSession();
 
 	@LogMessage(level = INFO)
 	@Message(value = "Transaction strategy: %s", id = 268)
 	void transactionStrategy(String strategyClassName);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Type [%s] defined no registration keys; ignoring", id = 269)
 	void typeDefinedNoRegistrationKeys(BasicType type);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Type registration [%s] overrides previous : %s", id = 270)
 	void typeRegistrationOverridesPrevious(String key,
 										   Type old);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Naming exception occurred accessing Ejb3Configuration", id = 271)
 	void unableToAccessEjb3Configuration(@Cause NamingException e);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Error while accessing session factory with JNDI name %s", id = 272)
 	void unableToAccessSessionFactory(String sfJNDIName,
 									  @Cause NamingException e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Error accessing type info result set : %s", id = 273)
 	void unableToAccessTypeInfoResultSet(String string);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Unable to apply constraints on DDL for %s", id = 274)
 	void unableToApplyConstraints(String className,
 								  @Cause Exception e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Could not bind Ejb3Configuration to JNDI", id = 276)
 	void unableToBindEjb3ConfigurationToJndi(@Cause JndiException e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Could not bind factory to JNDI", id = 277)
 	void unableToBindFactoryToJndi(@Cause JndiException e);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Could not bind value '%s' to parameter: %s; %s", id = 278)
 	void unableToBindValueToParameter(String nullSafeToString,
 									  int index,
 									  String message);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Unable to build enhancement metamodel for %s", id = 279)
 	void unableToBuildEnhancementMetamodel(String className);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Could not build SessionFactory using the MBean classpath - will try again using client classpath: %s",
 			id = 280)
 	void unableToBuildSessionFactoryUsingMBeanClasspath(String message);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Unable to clean up callable statement", id = 281)
 	void unableToCleanUpCallableStatement(@Cause SQLException e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Unable to clean up prepared statement", id = 282)
 	void unableToCleanUpPreparedStatement(@Cause SQLException e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Unable to cleanup temporary id table after use [%s]", id = 283)
 	void unableToCleanupTemporaryIdTable(Throwable t);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Error closing connection", id = 284)
 	void unableToCloseConnection(@Cause Exception e);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Error closing InitialContext [%s]", id = 285)
 	void unableToCloseInitialContext(String string);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Error closing input files: %s", id = 286)
 	void unableToCloseInputFiles(String name,
 								 @Cause IOException e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Could not close input stream", id = 287)
 	void unableToCloseInputStream(@Cause IOException e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Could not close input stream for %s", id = 288)
 	void unableToCloseInputStreamForResource(String resourceName,
 											 @Cause IOException e);
 
 	@LogMessage(level = INFO)
 	@Message(value = "Unable to close iterator", id = 289)
 	void unableToCloseIterator(@Cause SQLException e);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Could not close jar: %s", id = 290)
 	void unableToCloseJar(String message);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Error closing output file: %s", id = 291)
 	void unableToCloseOutputFile(String outputFile,
 								 @Cause IOException e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "IOException occurred closing output stream", id = 292)
 	void unableToCloseOutputStream(@Cause IOException e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Problem closing pooled connection", id = 293)
 	void unableToClosePooledConnection(@Cause SQLException e);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Could not close session", id = 294)
 	void unableToCloseSession(@Cause HibernateException e);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Could not close session during rollback", id = 295)
 	void unableToCloseSessionDuringRollback(@Cause Exception e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "IOException occurred closing stream", id = 296)
 	void unableToCloseStream(@Cause IOException e);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Could not close stream on hibernate.properties: %s", id = 297)
 	void unableToCloseStreamError(IOException error);
 
 	@Message(value = "JTA commit failed", id = 298)
 	String unableToCommitJta();
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Could not complete schema update", id = 299)
 	void unableToCompleteSchemaUpdate(@Cause Exception e);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Could not complete schema validation", id = 300)
 	void unableToCompleteSchemaValidation(@Cause SQLException e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Unable to configure SQLExceptionConverter : %s", id = 301)
 	void unableToConfigureSqlExceptionConverter(HibernateException e);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Unable to construct current session context [%s]", id = 302)
 	void unableToConstructCurrentSessionContext(String impl,
 												@Cause Throwable e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Unable to construct instance of specified SQLExceptionConverter : %s", id = 303)
 	void unableToConstructSqlExceptionConverter(Throwable t);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Could not copy system properties, system properties will be ignored", id = 304)
 	void unableToCopySystemProperties();
 
 	@LogMessage(level = WARN)
 	@Message(value = "Could not create proxy factory for:%s", id = 305)
 	void unableToCreateProxyFactory(String entityName,
 									@Cause HibernateException e);
 
 	@LogMessage(level = ERROR)
 	@Message(value = "Error creating schema ", id = 306)
 	void unableToCreateSchema(@Cause Exception e);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Could not deserialize cache file: %s : %s", id = 307)
 	void unableToDeserializeCache(String path,
 								  SerializationException error);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Unable to destroy cache: %s", id = 308)
 	void unableToDestroyCache(String message);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Unable to destroy query cache: %s: %s", id = 309)
 	void unableToDestroyQueryCache(String region,
 								   String message);
 
 	@LogMessage(level = WARN)
 	@Message(value = "Unable to destroy update timestamps cache: %s: %s", id = 310)
 	void unableToDestroyUpdateTimestampsCache(String region,
 											  String message);
 
 	@LogMessage(level = INFO)
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java
index 1c444807a9..a4bad4c387 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryImpl.java
@@ -1,1166 +1,1166 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import javax.naming.Reference;
 import javax.naming.StringRefAddr;
 import java.io.IOException;
 import java.io.InvalidObjectException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.sql.Connection;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.Cache;
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.CustomEntityDirtinessStrategy;
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.EntityNameResolver;
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.MappingException;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.QueryException;
 import org.hibernate.Session;
 import org.hibernate.SessionBuilder;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
 import org.hibernate.StatelessSession;
 import org.hibernate.StatelessSessionBuilder;
 import org.hibernate.TypeHelper;
 import org.hibernate.cache.internal.CacheDataDescriptionImpl;
 import org.hibernate.cache.spi.CollectionRegion;
 import org.hibernate.cache.spi.EntityRegion;
 import org.hibernate.cache.spi.NaturalIdRegion;
 import org.hibernate.cache.spi.QueryCache;
 import org.hibernate.cache.spi.Region;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cache.spi.UpdateTimestampsCache;
 import org.hibernate.cache.spi.access.AccessType;
 import org.hibernate.cache.spi.access.CollectionRegionAccessStrategy;
 import org.hibernate.cache.spi.access.EntityRegionAccessStrategy;
 import org.hibernate.cache.spi.access.NaturalIdRegionAccessStrategy;
 import org.hibernate.cache.spi.access.RegionAccessStrategy;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.Settings;
 import org.hibernate.cfg.SettingsFactory;
 import org.hibernate.context.internal.JTASessionContext;
 import org.hibernate.context.internal.ManagedSessionContext;
 import org.hibernate.context.internal.ThreadLocalSessionContext;
 import org.hibernate.context.spi.CurrentSessionContext;
 import org.hibernate.context.spi.CurrentTenantIdentifierResolver;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.function.SQLFunction;
 import org.hibernate.dialect.function.SQLFunctionRegistry;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.profile.Association;
 import org.hibernate.engine.profile.Fetch;
 import org.hibernate.engine.profile.FetchProfile;
 import org.hibernate.engine.query.spi.QueryPlanCache;
 import org.hibernate.engine.query.spi.sql.NativeSQLQuerySpecification;
 import org.hibernate.engine.spi.CacheImplementor;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.engine.spi.Mapping;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.engine.spi.SessionBuilderImplementor;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionOwner;
 import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
 import org.hibernate.engine.transaction.spi.TransactionEnvironment;
 import org.hibernate.exception.spi.SQLExceptionConverter;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.UUIDGenerator;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.integrator.spi.IntegratorService;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.RootClass;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.metadata.CollectionMetadata;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.binding.PluralAttributeBinding;
 import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.persister.collection.CollectionPersister;
 import org.hibernate.persister.entity.EntityPersister;
 import org.hibernate.persister.entity.Loadable;
 import org.hibernate.persister.entity.Queryable;
 import org.hibernate.persister.spi.PersisterFactory;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.classloading.spi.ClassLoadingException;
-import org.hibernate.service.config.spi.ConfigurationService;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
-import org.hibernate.service.jndi.spi.JndiService;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.engine.config.spi.ConfigurationService;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jndi.spi.JndiService;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.service.spi.SessionFactoryServiceRegistryFactory;
 import org.hibernate.stat.Statistics;
 import org.hibernate.stat.spi.StatisticsImplementor;
 import org.hibernate.tool.hbm2ddl.ImportSqlCommandExtractor;
 import org.hibernate.tool.hbm2ddl.SchemaExport;
 import org.hibernate.tool.hbm2ddl.SchemaUpdate;
 import org.hibernate.tool.hbm2ddl.SchemaValidator;
 import org.hibernate.tuple.entity.EntityTuplizer;
 import org.hibernate.type.AssociationType;
 import org.hibernate.type.Type;
 import org.hibernate.type.TypeResolver;
 
 
 /**
  * Concrete implementation of the <tt>SessionFactory</tt> interface. Has the following
  * responsibilities
  * <ul>
  * <li>caches configuration settings (immutably)
  * <li>caches "compiled" mappings ie. <tt>EntityPersister</tt>s and
  *     <tt>CollectionPersister</tt>s (immutable)
  * <li>caches "compiled" queries (memory sensitive cache)
  * <li>manages <tt>PreparedStatement</tt>s
  * <li> delegates JDBC <tt>Connection</tt> management to the <tt>ConnectionProvider</tt>
  * <li>factory for instances of <tt>SessionImpl</tt>
  * </ul>
  * This class must appear immutable to clients, even if it does all kinds of caching
  * and pooling under the covers. It is crucial that the class is not only thread
  * safe, but also highly concurrent. Synchronization must be used extremely sparingly.
  *
- * @see org.hibernate.service.jdbc.connections.spi.ConnectionProvider
+ * @see org.hibernate.engine.jdbc.connections.spi.ConnectionProvider
  * @see org.hibernate.Session
  * @see org.hibernate.hql.spi.QueryTranslator
  * @see org.hibernate.persister.entity.EntityPersister
  * @see org.hibernate.persister.collection.CollectionPersister
  * @author Gavin King
  */
 public final class SessionFactoryImpl
 		implements SessionFactoryImplementor {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, SessionFactoryImpl.class.getName());
 	private static final IdentifierGenerator UUID_GENERATOR = UUIDGenerator.buildSessionFactoryUniqueIdentifierGenerator();
 
 	private final String name;
 	private final String uuid;
 
 	private final transient Map<String,EntityPersister> entityPersisters;
 	private final transient Map<String,ClassMetadata> classMetadata;
 	private final transient Map<String,CollectionPersister> collectionPersisters;
 	private final transient Map<String,CollectionMetadata> collectionMetadata;
 	private final transient Map<String,Set<String>> collectionRolesByEntityParticipant;
 	private final transient Map<String,IdentifierGenerator> identifierGenerators;
 	private final transient Map<String, NamedQueryDefinition> namedQueries;
 	private final transient Map<String, NamedSQLQueryDefinition> namedSqlQueries;
 	private final transient Map<String, ResultSetMappingDefinition> sqlResultSetMappings;
 	private final transient Map<String, FilterDefinition> filters;
 	private final transient Map<String, FetchProfile> fetchProfiles;
 	private final transient Map<String,String> imports;
 	private final transient SessionFactoryServiceRegistry serviceRegistry;
 	private final transient JdbcServices jdbcServices;
 	private final transient Dialect dialect;
 	private final transient Settings settings;
 	private final transient Properties properties;
 	private transient SchemaExport schemaExport;
 	private final transient CurrentSessionContext currentSessionContext;
 	private final transient SQLFunctionRegistry sqlFunctionRegistry;
 	private final transient SessionFactoryObserverChain observer = new SessionFactoryObserverChain();
 	private final transient ConcurrentHashMap<EntityNameResolver,Object> entityNameResolvers = new ConcurrentHashMap<EntityNameResolver, Object>();
 	private final transient QueryPlanCache queryPlanCache;
 	private final transient CacheImplementor cacheAccess;
 	private transient boolean isClosed = false;
 	private final transient TypeResolver typeResolver;
 	private final transient TypeHelper typeHelper;
 	private final transient TransactionEnvironment transactionEnvironment;
 	private final transient SessionFactoryOptions sessionFactoryOptions;
 	private final transient CustomEntityDirtinessStrategy customEntityDirtinessStrategy;
 	private final transient CurrentTenantIdentifierResolver currentTenantIdentifierResolver;
 
 	@SuppressWarnings( {"unchecked", "ThrowableResultOfMethodCallIgnored"})
 	public SessionFactoryImpl(
 			final Configuration cfg,
 			Mapping mapping,
 			ServiceRegistry serviceRegistry,
 			Settings settings,
 			SessionFactoryObserver observer) throws HibernateException {
 			LOG.debug( "Building session factory" );
 
 		sessionFactoryOptions = new SessionFactoryOptions() {
 			private EntityNotFoundDelegate entityNotFoundDelegate;
 
 			@Override
 			public Interceptor getInterceptor() {
 				return cfg.getInterceptor();
 			}
 
 			@Override
 			public EntityNotFoundDelegate getEntityNotFoundDelegate() {
 				if ( entityNotFoundDelegate == null ) {
 					if ( cfg.getEntityNotFoundDelegate() != null ) {
 						entityNotFoundDelegate = cfg.getEntityNotFoundDelegate();
 					}
 					else {
 						entityNotFoundDelegate = new EntityNotFoundDelegate() {
 							public void handleEntityNotFound(String entityName, Serializable id) {
 								throw new ObjectNotFoundException( id, entityName );
 							}
 						};
 					}
 				}
 				return entityNotFoundDelegate;
 			}
 		};
 
 		this.settings = settings;
 
 		this.properties = new Properties();
 		this.properties.putAll( cfg.getProperties() );
 
 		this.serviceRegistry = serviceRegistry.getService( SessionFactoryServiceRegistryFactory.class ).buildServiceRegistry(
 				this,
 				cfg
 		);
         this.jdbcServices = this.serviceRegistry.getService( JdbcServices.class );
         this.dialect = this.jdbcServices.getDialect();
 		this.cacheAccess = this.serviceRegistry.getService( CacheImplementor.class );
 		final RegionFactory regionFactory = cacheAccess.getRegionFactory();
 		this.sqlFunctionRegistry = new SQLFunctionRegistry( getDialect(), cfg.getSqlFunctions() );
 		if ( observer != null ) {
 			this.observer.addObserver( observer );
 		}
 
 		this.typeResolver = cfg.getTypeResolver().scope( this );
 		this.typeHelper = new TypeLocatorImpl( typeResolver );
 
 		this.filters = new HashMap<String, FilterDefinition>();
 		this.filters.putAll( cfg.getFilterDefinitions() );
 
 		LOG.debugf( "Session factory constructed with filter configurations : %s", filters );
 		LOG.debugf( "Instantiating session factory with properties: %s", properties );
 
 
 		this.queryPlanCache = new QueryPlanCache( this );
 
 		// todo : everything above here consider implementing as standard SF service.  specifically: stats, caches, types, function-reg
 
 		class IntegratorObserver implements SessionFactoryObserver {
 			private ArrayList<Integrator> integrators = new ArrayList<Integrator>();
 
 			@Override
 			public void sessionFactoryCreated(SessionFactory factory) {
 			}
 
 			@Override
 			public void sessionFactoryClosed(SessionFactory factory) {
 				for ( Integrator integrator : integrators ) {
 					integrator.disintegrate( SessionFactoryImpl.this, SessionFactoryImpl.this.serviceRegistry );
 				}
 			}
 		}
 
 		final IntegratorObserver integratorObserver = new IntegratorObserver();
 		this.observer.addObserver( integratorObserver );
 		for ( Integrator integrator : serviceRegistry.getService( IntegratorService.class ).getIntegrators() ) {
 			integrator.integrate( cfg, this, this.serviceRegistry );
 			integratorObserver.integrators.add( integrator );
 		}
 
 		//Generators:
 
 		identifierGenerators = new HashMap();
 		Iterator classes = cfg.getClassMappings();
 		while ( classes.hasNext() ) {
 			PersistentClass model = (PersistentClass) classes.next();
 			if ( !model.isInherited() ) {
 				IdentifierGenerator generator = model.getIdentifier().createIdentifierGenerator(
 						cfg.getIdentifierGeneratorFactory(),
 						getDialect(),
 				        settings.getDefaultCatalogName(),
 				        settings.getDefaultSchemaName(),
 				        (RootClass) model
 				);
 				identifierGenerators.put( model.getEntityName(), generator );
 			}
 		}
 
 
 		///////////////////////////////////////////////////////////////////////
 		// Prepare persisters and link them up with their cache
 		// region/access-strategy
 
 		final String cacheRegionPrefix = settings.getCacheRegionPrefix() == null ? "" : settings.getCacheRegionPrefix() + ".";
 
 		entityPersisters = new HashMap();
 		Map entityAccessStrategies = new HashMap();
 		Map<String,ClassMetadata> classMeta = new HashMap<String,ClassMetadata>();
 		classes = cfg.getClassMappings();
 		while ( classes.hasNext() ) {
 			final PersistentClass model = (PersistentClass) classes.next();
 			model.prepareTemporaryTables( mapping, getDialect() );
 			final String cacheRegionName = cacheRegionPrefix + model.getRootClass().getCacheRegionName();
 			// cache region is defined by the root-class in the hierarchy...
 			EntityRegionAccessStrategy accessStrategy = ( EntityRegionAccessStrategy ) entityAccessStrategies.get( cacheRegionName );
 			if ( accessStrategy == null && settings.isSecondLevelCacheEnabled() ) {
 				final AccessType accessType = AccessType.fromExternalName( model.getCacheConcurrencyStrategy() );
 				if ( accessType != null ) {
 					LOG.tracef( "Building shared cache region for entity data [%s]", model.getEntityName() );
 					EntityRegion entityRegion = regionFactory.buildEntityRegion( cacheRegionName, properties, CacheDataDescriptionImpl.decode( model ) );
 					accessStrategy = entityRegion.buildAccessStrategy( accessType );
 					entityAccessStrategies.put( cacheRegionName, accessStrategy );
 					cacheAccess.addCacheRegion( cacheRegionName, entityRegion );
 				}
 			}
 			
 			NaturalIdRegionAccessStrategy naturalIdAccessStrategy = null;
 			if ( model.hasNaturalId() && model.getNaturalIdCacheRegionName() != null ) {
 				final String naturalIdCacheRegionName = cacheRegionPrefix + model.getNaturalIdCacheRegionName();
 				naturalIdAccessStrategy = ( NaturalIdRegionAccessStrategy ) entityAccessStrategies.get( naturalIdCacheRegionName );
 				
 				if ( naturalIdAccessStrategy == null && settings.isSecondLevelCacheEnabled() ) {
 					final CacheDataDescriptionImpl cacheDataDescription = CacheDataDescriptionImpl.decode( model );
 					
 					NaturalIdRegion naturalIdRegion = null;
 					try {
 						naturalIdRegion = regionFactory.buildNaturalIdRegion( naturalIdCacheRegionName, properties,
 								cacheDataDescription );
 					}
 					catch ( UnsupportedOperationException e ) {
 						LOG.warnf(
 								"Shared cache region factory [%s] does not support natural id caching; " +
 										"shared NaturalId caching will be disabled for not be enabled for %s",
 								regionFactory.getClass().getName(),
 								model.getEntityName()
 						);
 					}
 					
 					if (naturalIdRegion != null) {
 						naturalIdAccessStrategy = naturalIdRegion.buildAccessStrategy( regionFactory.getDefaultAccessType() );
 						entityAccessStrategies.put( naturalIdCacheRegionName, naturalIdAccessStrategy );
 						cacheAccess.addCacheRegion(  naturalIdCacheRegionName, naturalIdRegion );
 					}
 				}
 			}
 			
 			EntityPersister cp = serviceRegistry.getService( PersisterFactory.class ).createEntityPersister(
 					model,
 					accessStrategy,
 					naturalIdAccessStrategy,
 					this,
 					mapping
 			);
 			entityPersisters.put( model.getEntityName(), cp );
 			classMeta.put( model.getEntityName(), cp.getClassMetadata() );
 		}
 		this.classMetadata = Collections.unmodifiableMap(classMeta);
 
 		Map<String,Set<String>> tmpEntityToCollectionRoleMap = new HashMap<String,Set<String>>();
 		collectionPersisters = new HashMap<String,CollectionPersister>();
 		Map<String,CollectionMetadata> tmpCollectionMetadata = new HashMap<String,CollectionMetadata>();
 		Iterator collections = cfg.getCollectionMappings();
 		while ( collections.hasNext() ) {
 			Collection model = (Collection) collections.next();
 			final String cacheRegionName = cacheRegionPrefix + model.getCacheRegionName();
 			final AccessType accessType = AccessType.fromExternalName( model.getCacheConcurrencyStrategy() );
 			CollectionRegionAccessStrategy accessStrategy = null;
 			if ( accessType != null && settings.isSecondLevelCacheEnabled() ) {
 				LOG.tracev( "Building shared cache region for collection data [{0}]", model.getRole() );
 				CollectionRegion collectionRegion = regionFactory.buildCollectionRegion( cacheRegionName, properties, CacheDataDescriptionImpl
 						.decode( model ) );
 				accessStrategy = collectionRegion.buildAccessStrategy( accessType );
 				entityAccessStrategies.put( cacheRegionName, accessStrategy );
 				cacheAccess.addCacheRegion( cacheRegionName, collectionRegion );
 			}
 			CollectionPersister persister = serviceRegistry.getService( PersisterFactory.class ).createCollectionPersister(
 					cfg,
 					model,
 					accessStrategy,
 					this
 			) ;
 			collectionPersisters.put( model.getRole(), persister );
 			tmpCollectionMetadata.put( model.getRole(), persister.getCollectionMetadata() );
 			Type indexType = persister.getIndexType();
 			if ( indexType != null && indexType.isAssociationType() && !indexType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) indexType ).getAssociatedEntityName( this );
 				Set roles = tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 			Type elementType = persister.getElementType();
 			if ( elementType.isAssociationType() && !elementType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) elementType ).getAssociatedEntityName( this );
 				Set roles = tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 		}
 		collectionMetadata = Collections.unmodifiableMap( tmpCollectionMetadata );
 		Iterator itr = tmpEntityToCollectionRoleMap.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			entry.setValue( Collections.unmodifiableSet( ( Set ) entry.getValue() ) );
 		}
 		collectionRolesByEntityParticipant = Collections.unmodifiableMap( tmpEntityToCollectionRoleMap );
 
 		//Named Queries:
 		namedQueries = new HashMap<String, NamedQueryDefinition>( cfg.getNamedQueries() );
 		namedSqlQueries = new HashMap<String, NamedSQLQueryDefinition>( cfg.getNamedSQLQueries() );
 		sqlResultSetMappings = new HashMap<String, ResultSetMappingDefinition>( cfg.getSqlResultSetMappings() );
 		imports = new HashMap<String,String>( cfg.getImports() );
 
 		// after *all* persisters and named queries are registered
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			final EntityPersister persister = ( ( EntityPersister ) iter.next() );
 			persister.postInstantiate();
 			registerEntityNameResolvers( persister );
 
 		}
 		iter = collectionPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			final CollectionPersister persister = ( ( CollectionPersister ) iter.next() );
 			persister.postInstantiate();
 		}
 
 		//JNDI + Serialization:
 
 		name = settings.getSessionFactoryName();
 		try {
 			uuid = (String) UUID_GENERATOR.generate(null, null);
 		}
 		catch (Exception e) {
 			throw new AssertionFailure("Could not generate UUID");
 		}
 		SessionFactoryRegistry.INSTANCE.addSessionFactory(
 				uuid,
 				name,
 				settings.isSessionFactoryNameAlsoJndiName(),
 				this,
 				serviceRegistry.getService( JndiService.class )
 		);
 
 		LOG.debug( "Instantiated session factory" );
 
 		if ( settings.isAutoCreateSchema() ) {
 			new SchemaExport( serviceRegistry, cfg )
 					.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) )
 					.create( false, true );
 		}
 		if ( settings.isAutoUpdateSchema() ) {
 			new SchemaUpdate( serviceRegistry, cfg ).execute( false, true );
 		}
 		if ( settings.isAutoValidateSchema() ) {
 			new SchemaValidator( serviceRegistry, cfg ).validate();
 		}
 		if ( settings.isAutoDropSchema() ) {
 			schemaExport = new SchemaExport( serviceRegistry, cfg )
 					.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) );
 		}
 
 		currentSessionContext = buildCurrentSessionContext();
 
 		//checking for named queries
 		if ( settings.isNamedQueryStartupCheckingEnabled() ) {
 			final Map<String,HibernateException> errors = checkNamedQueries();
 			if ( ! errors.isEmpty() ) {
 				StringBuilder failingQueries = new StringBuilder( "Errors in named queries: " );
 				String sep = "";
 				for ( Map.Entry<String,HibernateException> entry : errors.entrySet() ) {
 					LOG.namedQueryError( entry.getKey(), entry.getValue() );
 					failingQueries.append( entry.getKey() ).append( sep );
 					sep = ", ";
 				}
 				throw new HibernateException( failingQueries.toString() );
 			}
 		}
 
 		// this needs to happen after persisters are all ready to go...
 		this.fetchProfiles = new HashMap();
 		itr = cfg.iterateFetchProfiles();
 		while ( itr.hasNext() ) {
 			final org.hibernate.mapping.FetchProfile mappingProfile =
 					( org.hibernate.mapping.FetchProfile ) itr.next();
 			final FetchProfile fetchProfile = new FetchProfile( mappingProfile.getName() );
 			for ( org.hibernate.mapping.FetchProfile.Fetch mappingFetch : mappingProfile.getFetches() ) {
 				// resolve the persister owning the fetch
 				final String entityName = getImportedClassName( mappingFetch.getEntity() );
 				final EntityPersister owner = entityName == null
 						? null
 						: entityPersisters.get( entityName );
 				if ( owner == null ) {
 					throw new HibernateException(
 							"Unable to resolve entity reference [" + mappingFetch.getEntity()
 									+ "] in fetch profile [" + fetchProfile.getName() + "]"
 					);
 				}
 
 				// validate the specified association fetch
 				Type associationType = owner.getPropertyType( mappingFetch.getAssociation() );
 				if ( associationType == null || !associationType.isAssociationType() ) {
 					throw new HibernateException( "Fetch profile [" + fetchProfile.getName() + "] specified an invalid association" );
 				}
 
 				// resolve the style
 				final Fetch.Style fetchStyle = Fetch.Style.parse( mappingFetch.getStyle() );
 
 				// then construct the fetch instance...
 				fetchProfile.addFetch( new Association( owner, mappingFetch.getAssociation() ), fetchStyle );
 				((Loadable) owner).registerAffectingFetchProfile( fetchProfile.getName() );
 			}
 			fetchProfiles.put( fetchProfile.getName(), fetchProfile );
 		}
 
 		this.customEntityDirtinessStrategy = determineCustomEntityDirtinessStrategy();
 		this.currentTenantIdentifierResolver = determineCurrentTenantIdentifierResolver( cfg.getCurrentTenantIdentifierResolver() );
 		this.transactionEnvironment = new TransactionEnvironmentImpl( this );
 		this.observer.sessionFactoryCreated( this );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private CustomEntityDirtinessStrategy determineCustomEntityDirtinessStrategy() {
 		CustomEntityDirtinessStrategy defaultValue = new CustomEntityDirtinessStrategy() {
 			@Override
 			public boolean canDirtyCheck(Object entity, EntityPersister persister, Session session) {
 				return false;
 			}
 
 			@Override
 			public boolean isDirty(Object entity, EntityPersister persister, Session session) {
 				return false;
 			}
 
 			@Override
 			public void resetDirty(Object entity, EntityPersister persister, Session session) {
 			}
 
 			@Override
 			public void findDirty(
 					Object entity,
 					EntityPersister persister,
 					Session session,
 					DirtyCheckContext dirtyCheckContext) {
 				// todo : implement proper method body
 			}
 		};
 		return serviceRegistry.getService( ConfigurationService.class ).getSetting(
 				AvailableSettings.CUSTOM_ENTITY_DIRTINESS_STRATEGY,
 				CustomEntityDirtinessStrategy.class,
 				defaultValue
 		);
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private CurrentTenantIdentifierResolver determineCurrentTenantIdentifierResolver(
 			CurrentTenantIdentifierResolver explicitResolver) {
 		if ( explicitResolver != null ) {
 			return explicitResolver;
 		}
 		return serviceRegistry.getService( ConfigurationService.class )
 				.getSetting(
 						AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER,
 						CurrentTenantIdentifierResolver.class,
 						null
 				);
 
 	}
 
 	@SuppressWarnings( {"ThrowableResultOfMethodCallIgnored"})
 	public SessionFactoryImpl(
 			MetadataImplementor metadata,
 			SessionFactoryOptions sessionFactoryOptions,
 			SessionFactoryObserver observer) throws HibernateException {
 		LOG.debug( "Building session factory" );
 
 		this.sessionFactoryOptions = sessionFactoryOptions;
 
 		this.properties = createPropertiesFromMap(
 				metadata.getServiceRegistry().getService( ConfigurationService.class ).getSettings()
 		);
 
 		// TODO: these should be moved into SessionFactoryOptions
 		this.settings = new SettingsFactory().buildSettings(
 				properties,
 				metadata.getServiceRegistry()
 		);
 
 		this.serviceRegistry =
 				metadata.getServiceRegistry()
 						.getService( SessionFactoryServiceRegistryFactory.class )
 						.buildServiceRegistry( this, metadata );
 
 		this.jdbcServices = this.serviceRegistry.getService( JdbcServices.class );
 		this.dialect = this.jdbcServices.getDialect();
 		this.cacheAccess = this.serviceRegistry.getService( CacheImplementor.class );
 
 		// TODO: get SQL functions from JdbcServices (HHH-6559)
 		//this.sqlFunctionRegistry = new SQLFunctionRegistry( this.jdbcServices.getSqlFunctions() );
 		this.sqlFunctionRegistry = new SQLFunctionRegistry( this.dialect, new HashMap<String, SQLFunction>() );
 
 		// TODO: get SQL functions from a new service
 		// this.sqlFunctionRegistry = new SQLFunctionRegistry( getDialect(), cfg.getSqlFunctions() );
 
 		if ( observer != null ) {
 			this.observer.addObserver( observer );
 		}
 
 		this.typeResolver = metadata.getTypeResolver().scope( this );
 		this.typeHelper = new TypeLocatorImpl( typeResolver );
 
 		this.filters = new HashMap<String, FilterDefinition>();
 		for ( FilterDefinition filterDefinition : metadata.getFilterDefinitions() ) {
 			filters.put( filterDefinition.getFilterName(), filterDefinition );
 		}
 
 		LOG.debugf( "Session factory constructed with filter configurations : %s", filters );
 		LOG.debugf( "Instantiating session factory with properties: %s", properties );
 
 		this.queryPlanCache = new QueryPlanCache( this );
 
 		class IntegratorObserver implements SessionFactoryObserver {
 			private ArrayList<Integrator> integrators = new ArrayList<Integrator>();
 
 			@Override
 			public void sessionFactoryCreated(SessionFactory factory) {
 			}
 
 			@Override
 			public void sessionFactoryClosed(SessionFactory factory) {
 				for ( Integrator integrator : integrators ) {
 					integrator.disintegrate( SessionFactoryImpl.this, SessionFactoryImpl.this.serviceRegistry );
 				}
 			}
 		}
 
         final IntegratorObserver integratorObserver = new IntegratorObserver();
         this.observer.addObserver(integratorObserver);
         for (Integrator integrator : serviceRegistry.getService(IntegratorService.class).getIntegrators()) {
             integrator.integrate(metadata, this, this.serviceRegistry);
             integratorObserver.integrators.add(integrator);
         }
 
 
 		//Generators:
 
 		identifierGenerators = new HashMap<String,IdentifierGenerator>();
 		for ( EntityBinding entityBinding : metadata.getEntityBindings() ) {
 			if ( entityBinding.isRoot() ) {
 				identifierGenerators.put(
 						entityBinding.getEntity().getName(),
 						entityBinding.getHierarchyDetails().getEntityIdentifier().getIdentifierGenerator()
 				);
 			}
 		}
 
 		///////////////////////////////////////////////////////////////////////
 		// Prepare persisters and link them up with their cache
 		// region/access-strategy
 
 		StringBuilder stringBuilder = new StringBuilder();
 		if ( settings.getCacheRegionPrefix() != null) {
 			stringBuilder
 					.append( settings.getCacheRegionPrefix() )
 					.append( '.' );
 		}
 		final String cacheRegionPrefix = stringBuilder.toString();
 
 		entityPersisters = new HashMap<String,EntityPersister>();
 		Map<String, RegionAccessStrategy> entityAccessStrategies = new HashMap<String, RegionAccessStrategy>();
 		Map<String,ClassMetadata> classMeta = new HashMap<String,ClassMetadata>();
 		for ( EntityBinding model : metadata.getEntityBindings() ) {
 			// TODO: should temp table prep happen when metadata is being built?
 			//model.prepareTemporaryTables( metadata, getDialect() );
 			// cache region is defined by the root-class in the hierarchy...
 			EntityBinding rootEntityBinding = metadata.getRootEntityBinding( model.getEntity().getName() );
 			EntityRegionAccessStrategy accessStrategy = null;
 			if ( settings.isSecondLevelCacheEnabled() &&
 					rootEntityBinding.getHierarchyDetails().getCaching() != null &&
 					model.getHierarchyDetails().getCaching() != null &&
 					model.getHierarchyDetails().getCaching().getAccessType() != null ) {
 				final String cacheRegionName = cacheRegionPrefix + rootEntityBinding.getHierarchyDetails().getCaching().getRegion();
 				accessStrategy = EntityRegionAccessStrategy.class.cast( entityAccessStrategies.get( cacheRegionName ) );
 				if ( accessStrategy == null ) {
 					final AccessType accessType = model.getHierarchyDetails().getCaching().getAccessType();
 					if ( LOG.isTraceEnabled() ) {
 						LOG.tracev( "Building cache for entity data [{0}]", model.getEntity().getName() );
 					}
 					EntityRegion entityRegion = settings.getRegionFactory().buildEntityRegion(
 							cacheRegionName, properties, CacheDataDescriptionImpl.decode( model )
 					);
 					accessStrategy = entityRegion.buildAccessStrategy( accessType );
 					entityAccessStrategies.put( cacheRegionName, accessStrategy );
 					cacheAccess.addCacheRegion( cacheRegionName, entityRegion );
 				}
 			}
 			EntityPersister cp = serviceRegistry.getService( PersisterFactory.class ).createEntityPersister(
 					model, accessStrategy, this, metadata
 			);
 			entityPersisters.put( model.getEntity().getName(), cp );
 			classMeta.put( model.getEntity().getName(), cp.getClassMetadata() );
 		}
 		this.classMetadata = Collections.unmodifiableMap(classMeta);
 
 		Map<String,Set<String>> tmpEntityToCollectionRoleMap = new HashMap<String,Set<String>>();
 		collectionPersisters = new HashMap<String,CollectionPersister>();
 		Map<String, CollectionMetadata> tmpCollectionMetadata = new HashMap<String, CollectionMetadata>();
 		for ( PluralAttributeBinding model : metadata.getCollectionBindings() ) {
 			if ( model.getAttribute() == null ) {
 				throw new IllegalStateException( "No attribute defined for a AbstractPluralAttributeBinding: " +  model );
 			}
 			if ( model.getAttribute().isSingular() ) {
 				throw new IllegalStateException(
 						"AbstractPluralAttributeBinding has a Singular attribute defined: " + model.getAttribute().getName()
 				);
 			}
 			final String cacheRegionName = cacheRegionPrefix + model.getCaching().getRegion();
 			final AccessType accessType = model.getCaching().getAccessType();
 			CollectionRegionAccessStrategy accessStrategy = null;
 			if ( accessType != null && settings.isSecondLevelCacheEnabled() ) {
 				if ( LOG.isTraceEnabled() ) {
 					LOG.tracev( "Building cache for collection data [{0}]", model.getAttribute().getRole() );
 				}
 				CollectionRegion collectionRegion = settings.getRegionFactory().buildCollectionRegion(
 						cacheRegionName, properties, CacheDataDescriptionImpl.decode( model )
 				);
 				accessStrategy = collectionRegion.buildAccessStrategy( accessType );
 				entityAccessStrategies.put( cacheRegionName, accessStrategy );
 				cacheAccess.addCacheRegion(  cacheRegionName, collectionRegion );
 			}
 			CollectionPersister persister = serviceRegistry
 					.getService( PersisterFactory.class )
 					.createCollectionPersister( metadata, model, accessStrategy, this );
 			collectionPersisters.put( model.getAttribute().getRole(), persister );
 			tmpCollectionMetadata.put( model.getAttribute().getRole(), persister.getCollectionMetadata() );
 			Type indexType = persister.getIndexType();
 			if ( indexType != null && indexType.isAssociationType() && !indexType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) indexType ).getAssociatedEntityName( this );
 				Set<String> roles = tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet<String>();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 			Type elementType = persister.getElementType();
 			if ( elementType.isAssociationType() && !elementType.isAnyType() ) {
 				String entityName = ( ( AssociationType ) elementType ).getAssociatedEntityName( this );
 				Set<String> roles = tmpEntityToCollectionRoleMap.get( entityName );
 				if ( roles == null ) {
 					roles = new HashSet<String>();
 					tmpEntityToCollectionRoleMap.put( entityName, roles );
 				}
 				roles.add( persister.getRole() );
 			}
 		}
 		collectionMetadata = Collections.unmodifiableMap( tmpCollectionMetadata );
 		for ( Map.Entry<String, Set<String>> entry : tmpEntityToCollectionRoleMap.entrySet() ) {
 			entry.setValue( Collections.unmodifiableSet( entry.getValue() ) );
 		}
 		collectionRolesByEntityParticipant = Collections.unmodifiableMap( tmpEntityToCollectionRoleMap );
 
 		//Named Queries:
 		namedQueries = new HashMap<String,NamedQueryDefinition>();
 		for ( NamedQueryDefinition namedQueryDefinition :  metadata.getNamedQueryDefinitions() ) {
 			namedQueries.put( namedQueryDefinition.getName(), namedQueryDefinition );
 		}
 		namedSqlQueries = new HashMap<String, NamedSQLQueryDefinition>();
 		for ( NamedSQLQueryDefinition namedNativeQueryDefinition: metadata.getNamedNativeQueryDefinitions() ) {
 			namedSqlQueries.put( namedNativeQueryDefinition.getName(), namedNativeQueryDefinition );
 		}
 		sqlResultSetMappings = new HashMap<String, ResultSetMappingDefinition>();
 		for( ResultSetMappingDefinition resultSetMappingDefinition : metadata.getResultSetMappingDefinitions() ) {
 			sqlResultSetMappings.put( resultSetMappingDefinition.getName(), resultSetMappingDefinition );
 		}
 		imports = new HashMap<String,String>();
 		for ( Map.Entry<String,String> importEntry : metadata.getImports() ) {
 			imports.put( importEntry.getKey(), importEntry.getValue() );
 		}
 
 		// after *all* persisters and named queries are registered
 		Iterator iter = entityPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			final EntityPersister persister = ( ( EntityPersister ) iter.next() );
 			persister.postInstantiate();
 			registerEntityNameResolvers( persister );
 
 		}
 		iter = collectionPersisters.values().iterator();
 		while ( iter.hasNext() ) {
 			final CollectionPersister persister = ( ( CollectionPersister ) iter.next() );
 			persister.postInstantiate();
 		}
 
 		//JNDI + Serialization:
 
 		name = settings.getSessionFactoryName();
 		try {
 			uuid = (String) UUID_GENERATOR.generate(null, null);
 		}
 		catch (Exception e) {
 			throw new AssertionFailure("Could not generate UUID");
 		}
 		SessionFactoryRegistry.INSTANCE.addSessionFactory(
 				uuid, 
 				name,
 				settings.isSessionFactoryNameAlsoJndiName(),
 				this,
 				serviceRegistry.getService( JndiService.class )
 		);
 
 		LOG.debug("Instantiated session factory");
 
 		if ( settings.isAutoCreateSchema() ) {
 			new SchemaExport( metadata )
 					.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) )
 					.create( false, true );
 		}
 
 		if ( settings.isAutoDropSchema() ) {
 			schemaExport = new SchemaExport( metadata )
 					.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) );
 		}
 
 		currentSessionContext = buildCurrentSessionContext();
 
 		//checking for named queries
 		if ( settings.isNamedQueryStartupCheckingEnabled() ) {
 			final Map<String,HibernateException> errors = checkNamedQueries();
 			if ( ! errors.isEmpty() ) {
 				StringBuilder failingQueries = new StringBuilder( "Errors in named queries: " );
 				String sep = "";
 				for ( Map.Entry<String,HibernateException> entry : errors.entrySet() ) {
 					LOG.namedQueryError( entry.getKey(), entry.getValue() );
 					failingQueries.append( entry.getKey() ).append( sep );
 					sep = ", ";
 				}
 				throw new HibernateException( failingQueries.toString() );
 			}
 		}
 
 		// this needs to happen after persisters are all ready to go...
 		this.fetchProfiles = new HashMap<String,FetchProfile>();
 		for ( org.hibernate.metamodel.binding.FetchProfile mappingProfile : metadata.getFetchProfiles() ) {
 			final FetchProfile fetchProfile = new FetchProfile( mappingProfile.getName() );
 			for ( org.hibernate.metamodel.binding.FetchProfile.Fetch mappingFetch : mappingProfile.getFetches() ) {
 				// resolve the persister owning the fetch
 				final String entityName = getImportedClassName( mappingFetch.getEntity() );
 				final EntityPersister owner = entityName == null ? null : entityPersisters.get( entityName );
 				if ( owner == null ) {
 					throw new HibernateException(
 							"Unable to resolve entity reference [" + mappingFetch.getEntity()
 									+ "] in fetch profile [" + fetchProfile.getName() + "]"
 					);
 				}
 
 				// validate the specified association fetch
 				Type associationType = owner.getPropertyType( mappingFetch.getAssociation() );
 				if ( associationType == null || ! associationType.isAssociationType() ) {
 					throw new HibernateException( "Fetch profile [" + fetchProfile.getName() + "] specified an invalid association" );
 				}
 
 				// resolve the style
 				final Fetch.Style fetchStyle = Fetch.Style.parse( mappingFetch.getStyle() );
 
 				// then construct the fetch instance...
 				fetchProfile.addFetch( new Association( owner, mappingFetch.getAssociation() ), fetchStyle );
 				( ( Loadable ) owner ).registerAffectingFetchProfile( fetchProfile.getName() );
 			}
 			fetchProfiles.put( fetchProfile.getName(), fetchProfile );
 		}
 
 		this.customEntityDirtinessStrategy = determineCustomEntityDirtinessStrategy();
 		this.currentTenantIdentifierResolver = determineCurrentTenantIdentifierResolver( null );
 		this.transactionEnvironment = new TransactionEnvironmentImpl( this );
 		this.observer.sessionFactoryCreated( this );
 	}
 
 	@SuppressWarnings( {"unchecked"} )
 	private static Properties createPropertiesFromMap(Map map) {
 		Properties properties = new Properties();
 		properties.putAll( map );
 		return properties;
 	}
 
 	public Session openSession() throws HibernateException {
 		return withOptions().openSession();
 	}
 
 	public Session openTemporarySession() throws HibernateException {
 		return withOptions()
 				.autoClose( false )
 				.flushBeforeCompletion( false )
 				.connectionReleaseMode( ConnectionReleaseMode.AFTER_STATEMENT )
 				.openSession();
 	}
 
 	public Session getCurrentSession() throws HibernateException {
 		if ( currentSessionContext == null ) {
 			throw new HibernateException( "No CurrentSessionContext configured!" );
 		}
 		return currentSessionContext.currentSession();
 	}
 
 	@Override
 	public SessionBuilderImplementor withOptions() {
 		return new SessionBuilderImpl( this );
 	}
 
 	@Override
 	public StatelessSessionBuilder withStatelessOptions() {
 		return new StatelessSessionBuilderImpl( this );
 	}
 
 	public StatelessSession openStatelessSession() {
 		return withStatelessOptions().openStatelessSession();
 	}
 
 	public StatelessSession openStatelessSession(Connection connection) {
 		return withStatelessOptions().connection( connection ).openStatelessSession();
 	}
 
 	@Override
 	public void addObserver(SessionFactoryObserver observer) {
 		this.observer.addObserver( observer );
 	}
 
 	public TransactionEnvironment getTransactionEnvironment() {
 		return transactionEnvironment;
 	}
 
 	public Properties getProperties() {
 		return properties;
 	}
 
 	public IdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 		return null;
 	}
 
 	public TypeResolver getTypeResolver() {
 		return typeResolver;
 	}
 
 	private void registerEntityNameResolvers(EntityPersister persister) {
 		if ( persister.getEntityMetamodel() == null || persister.getEntityMetamodel().getTuplizer() == null ) {
 			return;
 		}
 		registerEntityNameResolvers( persister.getEntityMetamodel().getTuplizer() );
 	}
 
 	private void registerEntityNameResolvers(EntityTuplizer tuplizer) {
 		EntityNameResolver[] resolvers = tuplizer.getEntityNameResolvers();
 		if ( resolvers == null ) {
 			return;
 		}
 
 		for ( EntityNameResolver resolver : resolvers ) {
 			registerEntityNameResolver( resolver );
 		}
 	}
 
 	private static final Object ENTITY_NAME_RESOLVER_MAP_VALUE = new Object();
 
 	public void registerEntityNameResolver(EntityNameResolver resolver) {
 		entityNameResolvers.put( resolver, ENTITY_NAME_RESOLVER_MAP_VALUE );
 	}
 
 	public Iterable<EntityNameResolver> iterateEntityNameResolvers() {
 		return entityNameResolvers.keySet();
 	}
 
 	public QueryPlanCache getQueryPlanCache() {
 		return queryPlanCache;
 	}
 
 	@SuppressWarnings( {"ThrowableResultOfMethodCallIgnored"})
 	private Map<String,HibernateException> checkNamedQueries() throws HibernateException {
 		Map<String,HibernateException> errors = new HashMap<String,HibernateException>();
 
 		// Check named HQL queries
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debugf( "Checking %s named HQL queries", namedQueries.size() );
 		}
 		Iterator itr = namedQueries.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			final String queryName = ( String ) entry.getKey();
 			final NamedQueryDefinition qd = ( NamedQueryDefinition ) entry.getValue();
 			// this will throw an error if there's something wrong.
 			try {
 				LOG.debugf( "Checking named query: %s", queryName );
 				//TODO: BUG! this currently fails for named queries for non-POJO entities
 				queryPlanCache.getHQLQueryPlan( qd.getQueryString(), false, Collections.EMPTY_MAP );
 			}
 			catch ( QueryException e ) {
 				errors.put( queryName, e );
 			}
 			catch ( MappingException e ) {
 				errors.put( queryName, e );
 			}
 
 
 		}
 		if ( LOG.isDebugEnabled() ) {
 			LOG.debugf( "Checking %s named SQL queries", namedSqlQueries.size() );
 		}
 		itr = namedSqlQueries.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = ( Map.Entry ) itr.next();
 			final String queryName = ( String ) entry.getKey();
 			final NamedSQLQueryDefinition qd = ( NamedSQLQueryDefinition ) entry.getValue();
 			// this will throw an error if there's something wrong.
 			try {
 				LOG.debugf( "Checking named SQL query: %s", queryName );
 				// TODO : would be really nice to cache the spec on the query-def so as to not have to re-calc the hash;
 				// currently not doable though because of the resultset-ref stuff...
 				NativeSQLQuerySpecification spec;
 				if ( qd.getResultSetRef() != null ) {
 					ResultSetMappingDefinition definition = sqlResultSetMappings.get( qd.getResultSetRef() );
 					if ( definition == null ) {
 						throw new MappingException( "Unable to find resultset-ref definition: " + qd.getResultSetRef() );
 					}
 					spec = new NativeSQLQuerySpecification(
 							qd.getQueryString(),
 					        definition.getQueryReturns(),
 					        qd.getQuerySpaces()
 					);
 				}
 				else {
 					spec =  new NativeSQLQuerySpecification(
 							qd.getQueryString(),
 					        qd.getQueryReturns(),
 					        qd.getQuerySpaces()
 					);
 				}
 				queryPlanCache.getNativeSQLQueryPlan( spec );
 			}
 			catch ( QueryException e ) {
 				errors.put( queryName, e );
 			}
 			catch ( MappingException e ) {
 				errors.put( queryName, e );
 			}
 
 		}
 
 		return errors;
 	}
 
 	public EntityPersister getEntityPersister(String entityName) throws MappingException {
 		EntityPersister result = entityPersisters.get(entityName);
 		if ( result == null ) {
 			throw new MappingException( "Unknown entity: " + entityName );
 		}
 		return result;
 	}
 
 	@Override
 	public Map<String, CollectionPersister> getCollectionPersisters() {
 		return collectionPersisters;
 	}
 
 	@Override
 	public Map<String, EntityPersister> getEntityPersisters() {
 		return entityPersisters;
 	}
 
 	public CollectionPersister getCollectionPersister(String role) throws MappingException {
 		CollectionPersister result = collectionPersisters.get(role);
 		if ( result == null ) {
 			throw new MappingException( "Unknown collection role: " + role );
 		}
 		return result;
 	}
 
 	public Settings getSettings() {
 		return settings;
 	}
 
 	@Override
 	public SessionFactoryOptions getSessionFactoryOptions() {
 		return sessionFactoryOptions;
 	}
 
 	public JdbcServices getJdbcServices() {
 		return jdbcServices;
 	}
 
 	public Dialect getDialect() {
 		if ( serviceRegistry == null ) {
 			throw new IllegalStateException( "Cannot determine dialect because serviceRegistry is null." );
 		}
 		return dialect;
 	}
 
 	public Interceptor getInterceptor() {
 		return sessionFactoryOptions.getInterceptor();
 	}
 
 	public SQLExceptionConverter getSQLExceptionConverter() {
 		return getSQLExceptionHelper().getSqlExceptionConverter();
 	}
 
 	public SqlExceptionHelper getSQLExceptionHelper() {
 		return getJdbcServices().getSqlExceptionHelper();
 	}
 
 	public Set<String> getCollectionRolesByEntityParticipant(String entityName) {
 		return collectionRolesByEntityParticipant.get( entityName );
 	}
 
 	@Override
 	public Reference getReference() {
 		// from javax.naming.Referenceable
         LOG.debug( "Returning a Reference to the SessionFactory" );
 		return new Reference(
 				SessionFactoryImpl.class.getName(),
 				new StringRefAddr("uuid", uuid),
 				SessionFactoryRegistry.ObjectFactoryImpl.class.getName(),
 				null
 		);
 	}
 
 	public void registerNamedQueryDefinition(String name, NamedQueryDefinition definition) {
 		if ( NamedSQLQueryDefinition.class.isInstance( definition ) ) {
 			throw new IllegalArgumentException( "NamedSQLQueryDefinition instance incorrectly passed to registerNamedQueryDefinition" );
 		}
 		final NamedQueryDefinition previous = namedQueries.put( name, definition );
 		if ( previous != null ) {
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryRegistry.java b/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryRegistry.java
index 41dcfdeb71..9cdfd99886 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryRegistry.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/SessionFactoryRegistry.java
@@ -1,198 +1,198 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import java.util.Hashtable;
 import java.util.concurrent.ConcurrentHashMap;
 import javax.naming.Context;
 import javax.naming.Name;
 import javax.naming.Reference;
 import javax.naming.event.NamespaceChangeListener;
 import javax.naming.event.NamingEvent;
 import javax.naming.event.NamingExceptionEvent;
 import javax.naming.spi.ObjectFactory;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.SessionFactory;
-import org.hibernate.service.jndi.JndiException;
-import org.hibernate.service.jndi.JndiNameException;
-import org.hibernate.service.jndi.spi.JndiService;
+import org.hibernate.engine.jndi.JndiException;
+import org.hibernate.engine.jndi.JndiNameException;
+import org.hibernate.engine.jndi.spi.JndiService;
 
 /**
  * A registry of all {@link SessionFactory} instances for the same classloader as this class.
  *
  * This registry is used for serialization/deserialization as well as JNDI binding.
  *
  * @author Steve Ebersole
  */
 public class SessionFactoryRegistry {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			SessionFactoryRegistry.class.getName()
 	);
 
 	public static final SessionFactoryRegistry INSTANCE = new SessionFactoryRegistry();
 
 	private final ConcurrentHashMap<String, SessionFactory> sessionFactoryMap = new ConcurrentHashMap<String, SessionFactory>();
 	private final ConcurrentHashMap<String,String> nameUuidXref = new ConcurrentHashMap<String, String>();
 
 	public SessionFactoryRegistry() {
 		LOG.debugf( "Initializing SessionFactoryRegistry : %s", this );
 	}
 
 	public void addSessionFactory(
 			String uuid,
 			String name,
 			boolean isNameAlsoJndiName,
 			SessionFactory instance,
 			JndiService jndiService) {
 		if ( uuid == null ) {
 			throw new IllegalArgumentException( "SessionFactory UUID cannot be null" );
 		}
 
         LOG.debugf( "Registering SessionFactory: %s (%s)", uuid, name == null ? "<unnamed>" : name );
 		sessionFactoryMap.put( uuid, instance );
 		if ( name != null ) {
 			nameUuidXref.put( name, uuid );
 		}
 
 		if ( name == null || ! isNameAlsoJndiName ) {
 			LOG.debug( "Not binding SessionFactory to JNDI, no JNDI name configured" );
 			return;
 		}
 
 		LOG.debugf( "Attempting to bind SessionFactory [%s] to JNDI", name );
 
 		try {
 			jndiService.bind( name, instance );
 			LOG.factoryBoundToJndiName( name );
 			try {
 				jndiService.addListener( name, LISTENER );
 			}
 			catch (Exception e) {
 				LOG.couldNotBindJndiListener();
 			}
 		}
 		catch (JndiNameException e) {
 			LOG.invalidJndiName( name, e );
 		}
 		catch (JndiException e) {
 			LOG.unableToBindFactoryToJndi( e );
 		}
 	}
 
 	public void removeSessionFactory(
 			String uuid,
 			String name,
 			boolean isNameAlsoJndiName,
 			JndiService jndiService) {
 		if ( name != null ) {
 			nameUuidXref.remove( name );
 
 			if ( isNameAlsoJndiName ) {
 				try {
 					LOG.tracef( "Unbinding SessionFactory from JNDI : %s", name );
 					jndiService.unbind( name );
 					LOG.factoryUnboundFromJndiName( name );
 				}
 				catch ( JndiNameException e ) {
 					LOG.invalidJndiName( name, e );
 				}
 				catch ( JndiException e ) {
 					LOG.unableToUnbindFactoryFromJndi( e );
 				}
 			}
 		}
 
 		sessionFactoryMap.remove( uuid );
 	}
 
 	public SessionFactory getNamedSessionFactory(String name) {
         LOG.debugf( "Lookup: name=%s", name );
 		final String uuid = nameUuidXref.get( name );
 		return getSessionFactory( uuid );
 	}
 
 	public SessionFactory getSessionFactory(String uuid) {
 		LOG.debugf( "Lookup: uid=%s", uuid );
 		final SessionFactory sessionFactory = sessionFactoryMap.get( uuid );
 		if ( sessionFactory == null && LOG.isDebugEnabled() ) {
 			LOG.debugf( "Not found: %s", uuid );
 			LOG.debugf( sessionFactoryMap.toString() );
 		}
 		return sessionFactory;
 	}
 
 	/**
 	 * Implementation of {@literal JNDI} {@link javax.naming.event.NamespaceChangeListener} contract to listener for context events
 	 * and react accordingly if necessary
 	 */
 	private final NamespaceChangeListener LISTENER = new NamespaceChangeListener() {
 		@Override
 		public void objectAdded(NamingEvent evt) {
             LOG.debugf("A factory was successfully bound to name: %s", evt.getNewBinding().getName());
 		}
 
 		@Override
 		public void objectRemoved(NamingEvent evt) {
 			final String jndiName = evt.getOldBinding().getName();
             LOG.factoryUnboundFromName( jndiName );
 
 			final String uuid = nameUuidXref.remove( jndiName );
 			if ( uuid == null ) {
 				// serious problem... but not sure what to do yet
 			}
 			sessionFactoryMap.remove( uuid );
 		}
 
 		@Override
 		public void objectRenamed(NamingEvent evt) {
 			final String oldJndiName = evt.getOldBinding().getName();
 			final String newJndiName = evt.getNewBinding().getName();
 
             LOG.factoryJndiRename( oldJndiName, newJndiName );
 
 			final String uuid = nameUuidXref.remove( oldJndiName );
 			nameUuidXref.put( newJndiName, uuid );
 		}
 
 		@Override
 		public void namingExceptionThrown(NamingExceptionEvent evt) {
 			//noinspection ThrowableResultOfMethodCallIgnored
             LOG.namingExceptionAccessingFactory(evt.getException());
 		}
 	};
 
 	public static class ObjectFactoryImpl implements ObjectFactory {
 		@Override
 		public Object getObjectInstance(Object reference, Name name, Context nameCtx, Hashtable<?, ?> environment)
 				throws Exception {
 			LOG.debugf( "JNDI lookup: %s", name );
 			final String uuid = (String) ( (Reference) reference ).get( 0 ).getContent();
 			LOG.tracef( "Resolved to UUID = %s", uuid );
 			return INSTANCE.getSessionFactory( uuid );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/StoredProcedureCallImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/StoredProcedureCallImpl.java
index b56c2a549d..5f251dde38 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/StoredProcedureCallImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/StoredProcedureCallImpl.java
@@ -1,608 +1,608 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import javax.persistence.ParameterMode;
 import javax.persistence.TemporalType;
 import java.sql.CallableStatement;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.MappingException;
 import org.hibernate.QueryException;
 import org.hibernate.StoredProcedureCall;
 import org.hibernate.StoredProcedureOutputs;
 import org.hibernate.cfg.NotYetImplementedException;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.jdbc.spi.ExtractedDatabaseMetaData;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryReturn;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryRootReturn;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.persister.entity.EntityPersister;
-import org.hibernate.service.jdbc.cursor.spi.RefCursorSupport;
+import org.hibernate.engine.jdbc.cursor.spi.RefCursorSupport;
 import org.hibernate.type.DateType;
 import org.hibernate.type.ProcedureParameterExtractionAware;
 import org.hibernate.type.Type;
 
 /**
  * @author Steve Ebersole
  */
 public class StoredProcedureCallImpl extends AbstractBasicQueryContractImpl implements StoredProcedureCall {
 	private static final Logger log = Logger.getLogger( StoredProcedureCallImpl.class );
 
 	private final String procedureName;
 	private final NativeSQLQueryReturn[] queryReturns;
 
 	private TypeOfParameter typeOfParameters = TypeOfParameter.UNKNOWN;
 	private List<StoredProcedureParameterImplementor> registeredParameters = new ArrayList<StoredProcedureParameterImplementor>();
 
 	private Set<String> synchronizedQuerySpaces;
 
 	@SuppressWarnings("unchecked")
 	public StoredProcedureCallImpl(SessionImplementor session, String procedureName) {
 		this( session, procedureName, (List) null );
 	}
 
 	public StoredProcedureCallImpl(SessionImplementor session, String procedureName, List<NativeSQLQueryReturn> queryReturns) {
 		super( session );
 		this.procedureName = procedureName;
 
 		if ( queryReturns == null || queryReturns.isEmpty() ) {
 			this.queryReturns = new NativeSQLQueryReturn[0];
 		}
 		else {
 			this.queryReturns = queryReturns.toArray( new NativeSQLQueryReturn[ queryReturns.size() ] );
 		}
 	}
 
 	public StoredProcedureCallImpl(SessionImplementor session, String procedureName, Class... resultClasses) {
 		this( session, procedureName, collectQueryReturns( resultClasses ) );
 	}
 
 	private static List<NativeSQLQueryReturn> collectQueryReturns(Class[] resultClasses) {
 		if ( resultClasses == null || resultClasses.length == 0 ) {
 			return null;
 		}
 
 		List<NativeSQLQueryReturn> queryReturns = new ArrayList<NativeSQLQueryReturn>( resultClasses.length );
 		int i = 1;
 		for ( Class resultClass : resultClasses ) {
 			queryReturns.add( new NativeSQLQueryRootReturn( "alias" + i, resultClass.getName(), LockMode.READ ) );
 			i++;
 		}
 		return queryReturns;
 	}
 
 	public StoredProcedureCallImpl(SessionImplementor session, String procedureName, String... resultSetMappings) {
 		this( session, procedureName, collectQueryReturns( session, resultSetMappings ) );
 	}
 
 	private static List<NativeSQLQueryReturn> collectQueryReturns(SessionImplementor session, String[] resultSetMappings) {
 		if ( resultSetMappings == null || resultSetMappings.length == 0 ) {
 			return null;
 		}
 
 		List<NativeSQLQueryReturn> queryReturns = new ArrayList<NativeSQLQueryReturn>( resultSetMappings.length );
 		for ( String resultSetMapping : resultSetMappings ) {
 			ResultSetMappingDefinition mapping = session.getFactory().getResultSetMapping( resultSetMapping );
 			if ( mapping == null ) {
 				throw new MappingException( "Unknown SqlResultSetMapping [" + resultSetMapping + "]" );
 			}
 			queryReturns.addAll( Arrays.asList( mapping.getQueryReturns() ) );
 		}
 		return queryReturns;
 	}
 
 //	public StoredProcedureCallImpl(
 //			SessionImplementor session,
 //			String procedureName,
 //			List<StoredProcedureParameter> parameters) {
 //		// this form is intended for named stored procedure calls.
 //		// todo : introduce a NamedProcedureCallDefinition object to hold all needed info and pass that in here; will help with EM.addNamedQuery as well..
 //		this( session, procedureName );
 //		for ( StoredProcedureParameter parameter : parameters ) {
 //			registerParameter( (StoredProcedureParameterImplementor) parameter );
 //		}
 //	}
 
 	@Override
 	public String getProcedureName() {
 		return procedureName;
 	}
 
 	NativeSQLQueryReturn[] getQueryReturns() {
 		return queryReturns;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public StoredProcedureCall registerStoredProcedureParameter(int position, Class type, ParameterMode mode) {
 		registerParameter( new PositionalStoredProcedureParameter( this, position, mode, type ) );
 		return this;
 	}
 
 	private void registerParameter(StoredProcedureParameterImplementor parameter) {
 		if ( StringHelper.isNotEmpty( parameter.getName() ) ) {
 			prepareForNamedParameters();
 		}
 		else if ( parameter.getPosition() != null ) {
 			prepareForPositionalParameters();
 		}
 		else {
 			throw new IllegalArgumentException( "Given parameter did not define name nor position [" + parameter + "]" );
 		}
 		registeredParameters.add( parameter );
 	}
 
 	private void prepareForPositionalParameters() {
 		if ( typeOfParameters == TypeOfParameter.NAMED ) {
 			throw new QueryException( "Cannot mix named and positional parameters" );
 		}
 		typeOfParameters = TypeOfParameter.POSITIONAL;
 	}
 
 	private void prepareForNamedParameters() {
 		if ( typeOfParameters == TypeOfParameter.POSITIONAL ) {
 			throw new QueryException( "Cannot mix named and positional parameters" );
 		}
 		if ( typeOfParameters == null ) {
 			// protect to only do this check once
 			final ExtractedDatabaseMetaData databaseMetaData = session().getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getLogicalConnection()
 					.getJdbcServices()
 					.getExtractedMetaDataSupport();
 			if ( ! databaseMetaData.supportsNamedParameters() ) {
 				throw new QueryException(
 						"Named stored procedure parameters used, but JDBC driver does not support named parameters"
 				);
 			}
 			typeOfParameters = TypeOfParameter.NAMED;
 		}
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public StoredProcedureCall registerStoredProcedureParameter(String name, Class type, ParameterMode mode) {
 		registerParameter( new NamedStoredProcedureParameter( this, name, mode, type ) );
 		return this;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public List<StoredProcedureParameter> getRegisteredParameters() {
 		return new ArrayList<StoredProcedureParameter>( registeredParameters );
 	}
 
 	@Override
 	public StoredProcedureParameterImplementor getRegisteredParameter(String name) {
 		if ( typeOfParameters != TypeOfParameter.NAMED ) {
 			throw new IllegalArgumentException( "Names were not used to register parameters with this stored procedure call" );
 		}
 		for ( StoredProcedureParameterImplementor parameter : registeredParameters ) {
 			if ( name.equals( parameter.getName() ) ) {
 				return parameter;
 			}
 		}
 		throw new IllegalArgumentException( "Could not locate parameter registered under that name [" + name + "]" );
 	}
 
 	@Override
 	public StoredProcedureParameterImplementor getRegisteredParameter(int position) {
 		try {
 			return registeredParameters.get( position );
 		}
 		catch ( Exception e ) {
 			throw new QueryException( "Could not locate parameter registered using that position [" + position + "]" );
 		}
 	}
 
 	@Override
 	public StoredProcedureOutputs getOutputs() {
 
 		// todo : going to need a very specialized Loader for this.
 		// or, might be a good time to look at splitting Loader up into:
 		//		1) building statement objects
 		//		2) executing statement objects
 		//		3) processing result sets
 
 		// for now assume there are no resultClasses nor mappings defined..
 		// 	TOTAL PROOF-OF-CONCEPT!!!!!!
 
 		final StringBuilder buffer = new StringBuilder().append( "{call " )
 				.append( procedureName )
 				.append( "(" );
 		String sep = "";
 		for ( StoredProcedureParameterImplementor parameter : registeredParameters ) {
 			for ( int i = 0; i < parameter.getSqlTypes().length; i++ ) {
 				buffer.append( sep ).append( "?" );
 				sep = ",";
 			}
 		}
 		buffer.append( ")}" );
 
 		try {
 			final CallableStatement statement = session().getTransactionCoordinator()
 					.getJdbcCoordinator()
 					.getLogicalConnection()
 					.getShareableConnectionProxy()
 					.prepareCall( buffer.toString() );
 
 			// prepare parameters
 			int i = 1;
 			for ( StoredProcedureParameterImplementor parameter : registeredParameters ) {
 				if ( parameter == null ) {
 					throw new QueryException( "Registered stored procedure parameters had gaps" );
 				}
 
 				parameter.prepare( statement, i );
 				i += parameter.getSqlTypes().length;
 			}
 
 			return new StoredProcedureOutputsImpl( this, statement );
 		}
 		catch (SQLException e) {
 			throw session().getFactory().getSQLExceptionHelper().convert(
 					e,
 					"Error preparing CallableStatement",
 					getProcedureName()
 			);
 		}
 	}
 
 
 	@Override
 	public Type[] getReturnTypes() throws HibernateException {
 		throw new NotYetImplementedException();
 	}
 
 	protected Set<String> synchronizedQuerySpaces() {
 		if ( synchronizedQuerySpaces == null ) {
 			synchronizedQuerySpaces = new HashSet<String>();
 		}
 		return synchronizedQuerySpaces;
 	}
 
 	@Override
 	@SuppressWarnings("unchecked")
 	public Collection<String> getSynchronizedQuerySpaces() {
 		if ( synchronizedQuerySpaces == null ) {
 			return Collections.emptySet();
 		}
 		else {
 			return Collections.unmodifiableSet( synchronizedQuerySpaces );
 		}
 	}
 
 	public Set<String> getSynchronizedQuerySpacesSet() {
 		return (Set<String>) getSynchronizedQuerySpaces();
 	}
 
 	@Override
 	public StoredProcedureCallImpl addSynchronizedQuerySpace(String querySpace) {
 		synchronizedQuerySpaces().add( querySpace );
 		return this;
 	}
 
 	@Override
 	public StoredProcedureCallImpl addSynchronizedEntityName(String entityName) {
 		addSynchronizedQuerySpaces( session().getFactory().getEntityPersister( entityName ) );
 		return this;
 	}
 
 	protected void addSynchronizedQuerySpaces(EntityPersister persister) {
 		synchronizedQuerySpaces().addAll( Arrays.asList( (String[]) persister.getQuerySpaces() ) );
 	}
 
 	@Override
 	public StoredProcedureCallImpl addSynchronizedEntityClass(Class entityClass) {
 		addSynchronizedQuerySpaces( session().getFactory().getEntityPersister( entityClass.getName() ) );
 		return this;
 	}
 
 	public QueryParameters buildQueryParametersObject() {
 		QueryParameters qp = super.buildQueryParametersObject();
 		// both of these are for documentation purposes, they are actually handled directly...
 		qp.setAutoDiscoverScalarTypes( true );
 		qp.setCallable( true );
 		return qp;
 	}
 
 	public StoredProcedureParameterImplementor[] collectRefCursorParameters() {
 		List<StoredProcedureParameterImplementor> refCursorParams = new ArrayList<StoredProcedureParameterImplementor>();
 		for ( StoredProcedureParameterImplementor param : registeredParameters ) {
 			if ( param.getMode() == ParameterMode.REF_CURSOR ) {
 				refCursorParams.add( param );
 			}
 		}
 		return refCursorParams.toArray( new StoredProcedureParameterImplementor[refCursorParams.size()] );
 	}
 
 	/**
 	 * Ternary logic enum
 	 */
 	private static enum TypeOfParameter {
 		NAMED,
 		POSITIONAL,
 		UNKNOWN
 	}
 
 	protected static interface StoredProcedureParameterImplementor<T> extends StoredProcedureParameter<T> {
 		public void prepare(CallableStatement statement, int i) throws SQLException;
 
 		public int[] getSqlTypes();
 
 		public T extract(CallableStatement statement);
 	}
 
 	public static abstract class AbstractStoredProcedureParameterImpl<T> implements StoredProcedureParameterImplementor<T> {
 		private final StoredProcedureCallImpl procedureCall;
 
 		private final ParameterMode mode;
 		private final Class<T> type;
 
 		private int startIndex;
 		private Type hibernateType;
 		private int[] sqlTypes;
 
 		private StoredProcedureParameterBindImpl bind;
 
 		protected AbstractStoredProcedureParameterImpl(
 				StoredProcedureCallImpl procedureCall,
 				ParameterMode mode,
 				Class<T> type) {
 			this.procedureCall = procedureCall;
 			this.mode = mode;
 			this.type = type;
 
 			setHibernateType( session().getFactory().getTypeResolver().heuristicType( type.getName() ) );
 		}
 
 		@Override
 		public String getName() {
 			return null;
 		}
 
 		@Override
 		public Integer getPosition() {
 			return null;
 		}
 
 		@Override
 		public Class<T> getType() {
 			return type;
 		}
 
 		@Override
 		public ParameterMode getMode() {
 			return mode;
 		}
 
 		@Override
 		public void setHibernateType(Type type) {
 			if ( type == null ) {
 				throw new IllegalArgumentException( "Type cannot be null" );
 			}
 			this.hibernateType = type;
 			this.sqlTypes = hibernateType.sqlTypes( session().getFactory() );
 		}
 
 		protected SessionImplementor session() {
 			return procedureCall.session();
 		}
 
 		@Override
 		public void prepare(CallableStatement statement, int startIndex) throws SQLException {
 			if ( mode == ParameterMode.REF_CURSOR ) {
 				throw new NotYetImplementedException( "Support for REF_CURSOR parameters not yet supported" );
 			}
 
 			this.startIndex = startIndex;
 			if ( mode == ParameterMode.IN || mode == ParameterMode.INOUT || mode == ParameterMode.OUT ) {
 				if ( mode == ParameterMode.INOUT || mode == ParameterMode.OUT ) {
 					if ( sqlTypes.length > 1 ) {
 						if ( ProcedureParameterExtractionAware.class.isInstance( hibernateType )
 								&& ( (ProcedureParameterExtractionAware) hibernateType ).canDoExtraction() ) {
 							// the type can handle multi-param extraction...
 						}
 						else {
 							// it cannot...
 							throw new UnsupportedOperationException(
 									"Type [" + hibernateType + "] does support multi-parameter value extraction"
 							);
 						}
 					}
 					for ( int i = 0; i < sqlTypes.length; i++ ) {
 						statement.registerOutParameter( startIndex + i, sqlTypes[i] );
 					}
 				}
 
 				if ( mode == ParameterMode.INOUT || mode == ParameterMode.IN ) {
 					if ( bind == null || bind.getValue() == null ) {
 						log.debugf(
 								"Stored procedure [%s] IN/INOUT parameter [%s] not bound; assuming procedure defines default value",
 								procedureCall.getProcedureName(),
 								this
 						);
 					}
 					else {
 						final Type typeToUse;
 						if ( bind.getExplicitTemporalType() != null && bind.getExplicitTemporalType() == TemporalType.TIMESTAMP ) {
 							typeToUse = hibernateType;
 						}
 						else if ( bind.getExplicitTemporalType() != null && bind.getExplicitTemporalType() == TemporalType.DATE ) {
 							typeToUse = DateType.INSTANCE;
 						}
 						else {
 							typeToUse = hibernateType;
 						}
 						typeToUse.nullSafeSet( statement, bind.getValue(), startIndex, session() );
 					}
 				}
 			}
 			else {
 				// we have a REF_CURSOR type param
 				if ( procedureCall.typeOfParameters == TypeOfParameter.NAMED ) {
 					session().getFactory().getServiceRegistry()
 							.getService( RefCursorSupport.class )
 							.registerRefCursorParameter( statement, getName() );
 				}
 				else {
 					session().getFactory().getServiceRegistry()
 							.getService( RefCursorSupport.class )
 							.registerRefCursorParameter( statement, getPosition() );
 				}
 			}
 		}
 
 		public int[] getSqlTypes() {
 			return sqlTypes;
 		}
 
 		@Override
 		public StoredProcedureParameterBind getParameterBind() {
 			return bind;
 		}
 
 		@Override
 		public void bindValue(T value) {
 			this.bind = new StoredProcedureParameterBindImpl<T>( value );
 		}
 
 		@Override
 		public void bindValue(T value, TemporalType explicitTemporalType) {
 			if ( explicitTemporalType != null ) {
 				if ( ! isDateTimeType() ) {
 					throw new IllegalArgumentException( "TemporalType should not be specified for non date/time type" );
 				}
 			}
 			this.bind = new StoredProcedureParameterBindImpl<T>( value, explicitTemporalType );
 		}
 
 		private boolean isDateTimeType() {
 			return Date.class.isAssignableFrom( type )
 					|| Calendar.class.isAssignableFrom( type );
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public T extract(CallableStatement statement) {
 			if ( mode == ParameterMode.IN ) {
 				throw new QueryException( "IN parameter not valid for output extraction" );
 			}
 			else if ( mode == ParameterMode.REF_CURSOR ) {
 				throw new QueryException( "REF_CURSOR parameters should be accessed via results" );
 			}
 
 			try {
 				if ( ProcedureParameterExtractionAware.class.isInstance( hibernateType ) ) {
 					return (T) ( (ProcedureParameterExtractionAware) hibernateType ).extract( statement, startIndex, session() );
 				}
 				else {
 					return (T) statement.getObject( startIndex );
 				}
 			}
 			catch (SQLException e) {
 				throw procedureCall.session().getFactory().getSQLExceptionHelper().convert(
 						e,
 						"Unable to extract OUT/INOUT parameter value"
 				);
 			}
 		}
 	}
 
 	public static class StoredProcedureParameterBindImpl<T> implements StoredProcedureParameterBind<T> {
 		private final T value;
 		private final TemporalType explicitTemporalType;
 
 		public StoredProcedureParameterBindImpl(T value) {
 			this( value, null );
 		}
 
 		public StoredProcedureParameterBindImpl(T value, TemporalType explicitTemporalType) {
 			this.value = value;
 			this.explicitTemporalType = explicitTemporalType;
 		}
 
 		@Override
 		public T getValue() {
 			return value;
 		}
 
 		@Override
 		public TemporalType getExplicitTemporalType() {
 			return explicitTemporalType;
 		}
 	}
 
 	public static class NamedStoredProcedureParameter<T> extends AbstractStoredProcedureParameterImpl<T> {
 		private final String name;
 
 		public NamedStoredProcedureParameter(
 				StoredProcedureCallImpl procedureCall,
 				String name,
 				ParameterMode mode,
 				Class<T> type) {
 			super( procedureCall, mode, type );
 			this.name = name;
 		}
 
 		@Override
 		public String getName() {
 			return name;
 		}
 	}
 
 	public static class PositionalStoredProcedureParameter<T> extends AbstractStoredProcedureParameterImpl<T> {
 		private final Integer position;
 
 		public PositionalStoredProcedureParameter(
 				StoredProcedureCallImpl procedureCall,
 				Integer position,
 				ParameterMode mode,
 				Class<T> type) {
 			super( procedureCall, mode, type );
 			this.position = position;
 		}
 
 		@Override
 		public Integer getPosition() {
 			return position;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/StoredProcedureOutputsImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/StoredProcedureOutputsImpl.java
index 590b8b8c75..31e5e1f77f 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/StoredProcedureOutputsImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/StoredProcedureOutputsImpl.java
@@ -1,317 +1,314 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
-import javax.persistence.ParameterMode;
 import java.sql.CallableStatement;
 import java.sql.ResultSet;
 import java.sql.SQLException;
-import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.JDBCException;
-import org.hibernate.StoredProcedureCall.StoredProcedureParameter;
 import org.hibernate.StoredProcedureOutputs;
 import org.hibernate.StoredProcedureResultSetReturn;
 import org.hibernate.StoredProcedureReturn;
 import org.hibernate.StoredProcedureUpdateCountReturn;
 import org.hibernate.engine.spi.QueryParameters;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.StoredProcedureCallImpl.StoredProcedureParameterImplementor;
 import org.hibernate.loader.custom.CustomLoader;
 import org.hibernate.loader.custom.CustomQuery;
 import org.hibernate.loader.custom.Return;
 import org.hibernate.loader.custom.sql.SQLQueryReturnProcessor;
-import org.hibernate.service.jdbc.cursor.spi.RefCursorSupport;
+import org.hibernate.engine.jdbc.cursor.spi.RefCursorSupport;
 
 /**
  * @author Steve Ebersole
  */
 public class StoredProcedureOutputsImpl implements StoredProcedureOutputs {
 	private final StoredProcedureCallImpl procedureCall;
 	private final CallableStatement callableStatement;
 
 	private final StoredProcedureParameterImplementor[] refCursorParameters;
 	private final CustomLoaderExtension loader;
 
 	private CurrentReturnDescriptor currentReturnDescriptor;
 
 	private boolean executed = false;
 	private int refCursorParamIndex = 0;
 
 	StoredProcedureOutputsImpl(StoredProcedureCallImpl procedureCall, CallableStatement callableStatement) {
 		this.procedureCall = procedureCall;
 		this.callableStatement = callableStatement;
 
 		this.refCursorParameters = procedureCall.collectRefCursorParameters();
 		// For now...
 		this.loader = buildSpecializedCustomLoader( procedureCall );
 	}
 
 	@Override
 	public Object getOutputParameterValue(String name) {
 		return procedureCall.getRegisteredParameter( name ).extract( callableStatement );
 	}
 
 	@Override
 	public Object getOutputParameterValue(int position) {
 		return procedureCall.getRegisteredParameter( position ).extract( callableStatement );
 	}
 
 	@Override
 	public boolean hasMoreReturns() {
 		if ( currentReturnDescriptor == null ) {
 			final boolean isResultSet;
 
 			if ( executed ) {
 				try {
 					isResultSet = callableStatement.getMoreResults();
 				}
 				catch (SQLException e) {
 					throw convert( e, "Error calling CallableStatement.getMoreResults" );
 				}
 			}
 			else {
 				try {
 					isResultSet = callableStatement.execute();
 				}
 				catch (SQLException e) {
 					throw convert( e, "Error calling CallableStatement.execute" );
 				}
 				executed = true;
 			}
 
 			int updateCount = -1;
 			if ( ! isResultSet ) {
 				try {
 					updateCount = callableStatement.getUpdateCount();
 				}
 				catch (SQLException e) {
 					throw convert( e, "Error calling CallableStatement.getUpdateCount" );
 				}
 			}
 
 			currentReturnDescriptor = new CurrentReturnDescriptor( isResultSet, updateCount, refCursorParamIndex );
 		}
 
 		return hasMoreResults( currentReturnDescriptor );
 	}
 
 	private boolean hasMoreResults(CurrentReturnDescriptor descriptor) {
 		return descriptor.isResultSet
 				|| descriptor.updateCount >= 0
 				|| descriptor.refCursorParamIndex < refCursorParameters.length;
 	}
 
 	@Override
 	public StoredProcedureReturn getNextReturn() {
 		if ( currentReturnDescriptor == null ) {
 			if ( executed ) {
 				throw new IllegalStateException( "Unexpected condition" );
 			}
 			else {
 				throw new IllegalStateException( "hasMoreReturns() not called before getNextReturn()" );
 			}
 		}
 
 		if ( ! hasMoreResults( currentReturnDescriptor ) ) {
 			throw new IllegalStateException( "Results have been exhausted" );
 		}
 
 		CurrentReturnDescriptor copyReturnDescriptor = currentReturnDescriptor;
 		currentReturnDescriptor = null;
 
 		if ( copyReturnDescriptor.isResultSet ) {
 			try {
 				return new ResultSetReturn( this, callableStatement.getResultSet() );
 			}
 			catch (SQLException e) {
 				throw convert( e, "Error calling CallableStatement.getResultSet" );
 			}
 		}
 		else if ( copyReturnDescriptor.updateCount >= 0 ) {
 			return new UpdateCountReturn( this, copyReturnDescriptor.updateCount );
 		}
 		else {
 			this.refCursorParamIndex++;
 			ResultSet resultSet;
 			int refCursorParamIndex = copyReturnDescriptor.refCursorParamIndex;
 			StoredProcedureParameterImplementor refCursorParam = refCursorParameters[refCursorParamIndex];
 			if ( refCursorParam.getName() != null ) {
 				resultSet = procedureCall.session().getFactory().getServiceRegistry()
 						.getService( RefCursorSupport.class )
 						.getResultSet( callableStatement, refCursorParam.getName() );
 			}
 			else {
 				resultSet = procedureCall.session().getFactory().getServiceRegistry()
 						.getService( RefCursorSupport.class )
 						.getResultSet( callableStatement, refCursorParam.getPosition() );
 			}
 			return new ResultSetReturn( this, resultSet );
 		}
 	}
 
 	protected JDBCException convert(SQLException e, String message) {
 		return procedureCall.session().getFactory().getSQLExceptionHelper().convert(
 				e,
 				message,
 				procedureCall.getProcedureName()
 		);
 	}
 
 	private static class CurrentReturnDescriptor {
 		private final boolean isResultSet;
 		private final int updateCount;
 		private final int refCursorParamIndex;
 
 		private CurrentReturnDescriptor(boolean isResultSet, int updateCount, int refCursorParamIndex) {
 			this.isResultSet = isResultSet;
 			this.updateCount = updateCount;
 			this.refCursorParamIndex = refCursorParamIndex;
 		}
 	}
 
 	private static class ResultSetReturn implements StoredProcedureResultSetReturn {
 		private final StoredProcedureOutputsImpl storedProcedureOutputs;
 		private final ResultSet resultSet;
 
 		public ResultSetReturn(StoredProcedureOutputsImpl storedProcedureOutputs, ResultSet resultSet) {
 			this.storedProcedureOutputs = storedProcedureOutputs;
 			this.resultSet = resultSet;
 		}
 
 		@Override
 		public boolean isResultSet() {
 			return true;
 		}
 
 		@Override
 		@SuppressWarnings("unchecked")
 		public List getResultList() {
 			try {
 				return storedProcedureOutputs.loader.processResultSet( resultSet );
 			}
 			catch (SQLException e) {
 				throw storedProcedureOutputs.convert( e, "Error calling ResultSet.next" );
 			}
 		}
 
 		@Override
 		public Object getSingleResult() {
 			List results = getResultList();
 			if ( results == null || results.isEmpty() ) {
 				return null;
 			}
 			else {
 				return results.get( 0 );
 			}
 		}
 	}
 
 	private class UpdateCountReturn implements StoredProcedureUpdateCountReturn {
 		private final StoredProcedureOutputsImpl storedProcedureOutputs;
 		private final int updateCount;
 
 		public UpdateCountReturn(StoredProcedureOutputsImpl storedProcedureOutputs, int updateCount) {
 			this.storedProcedureOutputs = storedProcedureOutputs;
 			this.updateCount = updateCount;
 		}
 
 		@Override
 		public int getUpdateCount() {
 			return updateCount;
 		}
 
 		@Override
 		public boolean isResultSet() {
 			return false;
 		}
 	}
 
 	private static CustomLoaderExtension buildSpecializedCustomLoader(final StoredProcedureCallImpl procedureCall) {
 		final SQLQueryReturnProcessor processor = new SQLQueryReturnProcessor(
 				procedureCall.getQueryReturns(),
 				procedureCall.session().getFactory()
 		);
 		processor.process();
 		final List<Return> customReturns = processor.generateCustomReturns( false );
 
 		CustomQuery customQuery = new CustomQuery() {
 			@Override
 			public String getSQL() {
 				return procedureCall.getProcedureName();
 			}
 
 			@Override
 			public Set<String> getQuerySpaces() {
 				return procedureCall.getSynchronizedQuerySpacesSet();
 			}
 
 			@Override
 			public Map getNamedParameterBindPoints() {
 				// no named parameters in terms of embedded in the SQL string
 				return null;
 			}
 
 			@Override
 			public List<Return> getCustomQueryReturns() {
 				return customReturns;
 			}
 		};
 
 		return new CustomLoaderExtension(
 				customQuery,
 				procedureCall.buildQueryParametersObject(),
 				procedureCall.session()
 		);
 	}
 
 	private static class CustomLoaderExtension extends CustomLoader {
 		private QueryParameters queryParameters;
 		private SessionImplementor session;
 
 		public CustomLoaderExtension(
 				CustomQuery customQuery,
 				QueryParameters queryParameters,
 				SessionImplementor session) {
 			super( customQuery, session.getFactory() );
 			this.queryParameters = queryParameters;
 			this.session = session;
 		}
 
 		public List processResultSet(ResultSet resultSet) throws SQLException {
 			super.autoDiscoverTypes( resultSet );
 			return super.processResultSet(
 					resultSet,
 					queryParameters,
 					session,
 					true,
 					null,
 					Integer.MAX_VALUE
 			);
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/TransactionEnvironmentImpl.java b/hibernate-core/src/main/java/org/hibernate/internal/TransactionEnvironmentImpl.java
index e864ecfea5..e818e84e63 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/TransactionEnvironmentImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/TransactionEnvironmentImpl.java
@@ -1,82 +1,82 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal;
 
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.transaction.spi.TransactionEnvironment;
 import org.hibernate.engine.transaction.spi.TransactionFactory;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.stat.spi.StatisticsImplementor;
 
 /**
  * @author Steve Ebersole
  */
 public class TransactionEnvironmentImpl implements TransactionEnvironment {
     private final SessionFactoryImpl sessionFactory;
     private final transient StatisticsImplementor statisticsImplementor;
     private final transient ServiceRegistry serviceRegistry;
     private final transient JdbcServices jdbcServices;
     private final transient JtaPlatform jtaPlatform;
     private final transient TransactionFactory transactionFactory;
 
     public TransactionEnvironmentImpl(SessionFactoryImpl sessionFactory) {
         this.sessionFactory = sessionFactory;
         this.statisticsImplementor = sessionFactory.getStatisticsImplementor();
         this.serviceRegistry = sessionFactory.getServiceRegistry();
         this.jdbcServices = serviceRegistry.getService( JdbcServices.class );
         this.jtaPlatform = serviceRegistry.getService( JtaPlatform.class );
         this.transactionFactory = serviceRegistry.getService( TransactionFactory.class );
     }
 
     @Override
     public SessionFactoryImplementor getSessionFactory() {
         return sessionFactory;
     }
 
     protected ServiceRegistry serviceRegistry() {
         return serviceRegistry;
     }
 
     @Override
     public JdbcServices getJdbcServices() {
         return jdbcServices;
     }
 
     @Override
     public JtaPlatform getJtaPlatform() {
         return jtaPlatform;
     }
 
     @Override
     public TransactionFactory getTransactionFactory() {
         return transactionFactory;
     }
 
     @Override
     public StatisticsImplementor getStatisticsImplementor() {
         return statisticsImplementor;
     }
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/util/ConfigHelper.java b/hibernate-core/src/main/java/org/hibernate/internal/util/ConfigHelper.java
index fe2da98d0e..e43aea33b0 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/util/ConfigHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/util/ConfigHelper.java
@@ -1,206 +1,206 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal.util;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.util.Properties;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.Environment;
 import org.hibernate.internal.CoreMessageLogger;
 
 /**
  * A simple class to centralize logic needed to locate config files on the system.
  *
- * @todo : Update usages to use {@link org.hibernate.service.classloading.spi.ClassLoaderService}
+ * @todo : Update usages to use {@link org.hibernate.boot.registry.classloading.spi.ClassLoaderService}
  *
  * @author Steve Ebersole
  */
 public final class ConfigHelper {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, ConfigHelper.class.getName());
 
 	/** Try to locate a local URL representing the incoming path.  The first attempt
 	 * assumes that the incoming path is an actual URL string (file://, etc).  If this
 	 * does not work, then the next attempts try to locate this UURL as a java system
 	 * resource.
 	 *
 	 * @param path The path representing the config location.
 	 * @return An appropriate URL or null.
 	 */
 	public static URL locateConfig(final String path) {
 		try {
 			return new URL(path);
 		}
 		catch(MalformedURLException e) {
 			return findAsResource(path);
 		}
 	}
 
 	/**
 	 * Try to locate a local URL representing the incoming path.
 	 * This method <b>only</b> attempts to locate this URL as a
 	 * java system resource.
 	 *
 	 * @param path The path representing the config location.
 	 * @return An appropriate URL or null.
 	 */
 	public static URL findAsResource(final String path) {
 		URL url = null;
 
 		// First, try to locate this resource through the current
 		// context classloader.
 		ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
 		if (contextClassLoader!=null) {
 			url = contextClassLoader.getResource(path);
 		}
 		if (url != null)
 			return url;
 
 		// Next, try to locate this resource through this class's classloader
 		url = ConfigHelper.class.getClassLoader().getResource(path);
 		if (url != null)
 			return url;
 
 		// Next, try to locate this resource through the system classloader
 		url = ClassLoader.getSystemClassLoader().getResource(path);
 
 		// Anywhere else we should look?
 		return url;
 	}
 
 	/** Open an InputStream to the URL represented by the incoming path.  First makes a call
 	 * to {@link #locateConfig(java.lang.String)} in order to find an appropriate URL.
 	 * {@link java.net.URL#openStream()} is then called to obtain the stream.
 	 *
 	 * @param path The path representing the config location.
 	 * @return An input stream to the requested config resource.
 	 * @throws HibernateException Unable to open stream to that resource.
 	 */
 	public static InputStream getConfigStream(final String path) throws HibernateException {
 		final URL url = ConfigHelper.locateConfig(path);
 
 		if (url == null) {
             String msg = LOG.unableToLocateConfigFile(path);
             LOG.error(msg);
 			throw new HibernateException(msg);
 		}
 
 		try {
 			return url.openStream();
         }
 		catch(IOException e) {
 	        throw new HibernateException("Unable to open config file: " + path, e);
         }
 	}
 
 	/** Open an Reader to the URL represented by the incoming path.  First makes a call
 	 * to {@link #locateConfig(java.lang.String)} in order to find an appropriate URL.
 	 * {@link java.net.URL#openStream()} is then called to obtain a stream, which is then
 	 * wrapped in a Reader.
 	 *
 	 * @param path The path representing the config location.
 	 * @return An input stream to the requested config resource.
 	 * @throws HibernateException Unable to open reader to that resource.
 	 */
 	public static Reader getConfigStreamReader(final String path) throws HibernateException {
 		return new InputStreamReader( getConfigStream(path) );
 	}
 
 	/** Loads a properties instance based on the data at the incoming config location.
 	 *
 	 * @param path The path representing the config location.
 	 * @return The loaded properties instance.
 	 * @throws HibernateException Unable to load properties from that resource.
 	 */
 	public static Properties getConfigProperties(String path) throws HibernateException {
 		try {
 			Properties properties = new Properties();
 			properties.load( getConfigStream(path) );
 			return properties;
 		}
 		catch(IOException e) {
 			throw new HibernateException("Unable to load properties from specified config file: " + path, e);
 		}
 	}
 
 	private ConfigHelper() {}
 
 	public static InputStream getResourceAsStream(String resource) {
 		String stripped = resource.startsWith("/") ?
 				resource.substring(1) : resource;
 
 		InputStream stream = null;
 		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
 		if (classLoader!=null) {
 			stream = classLoader.getResourceAsStream( stripped );
 		}
 		if ( stream == null ) {
 			stream = Environment.class.getResourceAsStream( resource );
 		}
 		if ( stream == null ) {
 			stream = Environment.class.getClassLoader().getResourceAsStream( stripped );
 		}
 		if ( stream == null ) {
 			throw new HibernateException( resource + " not found" );
 		}
 		return stream;
 	}
 
 
 	public static InputStream getUserResourceAsStream(String resource) {
 		boolean hasLeadingSlash = resource.startsWith( "/" );
 		String stripped = hasLeadingSlash ? resource.substring(1) : resource;
 
 		InputStream stream = null;
 
 		ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
 		if ( classLoader != null ) {
 			stream = classLoader.getResourceAsStream( resource );
 			if ( stream == null && hasLeadingSlash ) {
 				stream = classLoader.getResourceAsStream( stripped );
 			}
 		}
 
 		if ( stream == null ) {
 			stream = Environment.class.getClassLoader().getResourceAsStream( resource );
 		}
 		if ( stream == null && hasLeadingSlash ) {
 			stream = Environment.class.getClassLoader().getResourceAsStream( stripped );
 		}
 
 		if ( stream == null ) {
 			throw new HibernateException( resource + " not found" );
 		}
 
 		return stream;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/internal/util/jndi/JndiHelper.java b/hibernate-core/src/main/java/org/hibernate/internal/util/jndi/JndiHelper.java
index fdc5191a94..a93b83df39 100644
--- a/hibernate-core/src/main/java/org/hibernate/internal/util/jndi/JndiHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/internal/util/jndi/JndiHelper.java
@@ -1,132 +1,132 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.internal.util.jndi;
 
 import java.util.Hashtable;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import javax.naming.Context;
 import javax.naming.InitialContext;
 import javax.naming.Name;
 import javax.naming.NameNotFoundException;
 import javax.naming.NamingException;
 
 import org.hibernate.cfg.Environment;
 
 /**
  * Helper for dealing with JNDI.
  *
- * @deprecated As JNDI access should get routed through {@link org.hibernate.service.jndi.spi.JndiService}
+ * @deprecated As JNDI access should get routed through {@link org.hibernate.engine.jndi.spi.JndiService}
  */
 @Deprecated
 public final class JndiHelper {
 	private JndiHelper() {
 	}
 
 	/**
 	 * Given a hodgepodge of properties, extract out the ones relevant for JNDI interaction.
 	 *
 	 * @param configurationValues The map of config values
 	 *
 	 * @return The extracted JNDI specific properties.
 	 */
 	@SuppressWarnings({ "unchecked" })
 	public static Properties extractJndiProperties(Map configurationValues) {
 		final Properties jndiProperties = new Properties();
 
 		for ( Map.Entry entry : (Set<Map.Entry>) configurationValues.entrySet() ) {
 			if ( !String.class.isInstance( entry.getKey() ) ) {
 				continue;
 			}
 			final String propertyName = (String) entry.getKey();
 			final Object propertyValue = entry.getValue();
 			if ( propertyName.startsWith( Environment.JNDI_PREFIX ) ) {
 				// write the IntialContextFactory class and provider url to the result only if they are
 				// non-null; this allows the environmental defaults (if any) to remain in effect
 				if ( Environment.JNDI_CLASS.equals( propertyName ) ) {
 					if ( propertyValue != null ) {
 						jndiProperties.put( Context.INITIAL_CONTEXT_FACTORY, propertyValue );
 					}
 				}
 				else if ( Environment.JNDI_URL.equals( propertyName ) ) {
 					if ( propertyValue != null ) {
 						jndiProperties.put( Context.PROVIDER_URL, propertyValue );
 					}
 				}
 				else {
 					final String passThruPropertyname = propertyName.substring( Environment.JNDI_PREFIX.length() + 1 );
 					jndiProperties.put( passThruPropertyname, propertyValue );
 				}
 			}
 		}
 
 		return jndiProperties;
 	}
 
 	public static InitialContext getInitialContext(Properties props) throws NamingException {
 		Hashtable hash = extractJndiProperties(props);
 		return hash.size()==0 ?
 				new InitialContext() :
 				new InitialContext(hash);
 	}
 
 	/**
 	 * Bind val to name in ctx, and make sure that all intermediate contexts exist.
 	 *
 	 * @param ctx the root context
 	 * @param name the name as a string
 	 * @param val the object to be bound
 	 *
 	 * @throws NamingException Indicates a problem performing the bind.
 	 */
 	public static void bind(Context ctx, String name, Object val) throws NamingException {
 		try {
 			ctx.rebind(name, val);
 		}
 		catch (Exception e) {
 			Name n = ctx.getNameParser("").parse(name);
 			while ( n.size() > 1 ) {
 				String ctxName = n.get(0);
 
 				Context subctx=null;
 				try {
 					subctx = (Context) ctx.lookup(ctxName);
 				}
 				catch (NameNotFoundException ignore) {
 				}
 
 				if (subctx!=null) {
 					ctx = subctx;
 				}
 				else {
 					ctx = ctx.createSubcontext(ctxName);
 				}
 				n = n.getSuffix(1);
 			}
 			ctx.rebind(n, val);
 		}
 	}
 }
 
diff --git a/hibernate-core/src/main/java/org/hibernate/jmx/HibernateService.java b/hibernate-core/src/main/java/org/hibernate/jmx/HibernateService.java
index 99810fb517..666c1be0a9 100644
--- a/hibernate-core/src/main/java/org/hibernate/jmx/HibernateService.java
+++ b/hibernate-core/src/main/java/org/hibernate/jmx/HibernateService.java
@@ -1,200 +1,200 @@
 //$Id: HibernateService.java 6100 2005-03-17 10:48:03Z turin42 $
 package org.hibernate.jmx;
 
 import java.util.Map;
 import java.util.Properties;
 import javax.naming.InitialContext;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.SessionFactory;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.ExternalSessionFactoryConfig;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.jndi.JndiHelper;
-import org.hibernate.service.ServiceRegistryBuilder;
 import org.hibernate.tool.hbm2ddl.SchemaExport;
 
 
 /**
  * Implementation of <tt>HibernateServiceMBean</tt>. Creates a
  * <tt>SessionFactory</tt> and binds it to the specified JNDI name.<br>
  * <br>
  * All mapping documents are loaded as resources by the MBean.
  * @see HibernateServiceMBean
  * @see org.hibernate.SessionFactory
  * @author John Urberg, Gavin King
  * @deprecated See <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-6190">HHH-6190</a> for details
  */
 @Deprecated
 public class HibernateService extends ExternalSessionFactoryConfig implements HibernateServiceMBean {
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, HibernateService.class.getName());
 
 	private String boundName;
 	private Properties properties = new Properties();
 
 	@Override
 	public void start() throws HibernateException {
 		boundName = getJndiName();
 		try {
 			buildSessionFactory();
 		}
 		catch (HibernateException he) {
             LOG.unableToBuildSessionFactoryUsingMBeanClasspath(he.getMessage());
             LOG.debug("Error was", he);
 			new SessionFactoryStub(this);
 		}
 	}
 
 	@Override
 	public void stop() {
         LOG.stoppingService();
 		try {
 			InitialContext context = JndiHelper.getInitialContext( buildProperties() );
 			( (SessionFactory) context.lookup(boundName) ).close();
 			//context.unbind(boundName);
 		}
 		catch (Exception e) {
             LOG.unableToStopHibernateService(e);
 		}
 	}
 
 	SessionFactory buildSessionFactory() throws HibernateException {
         LOG.startingServiceAtJndiName( boundName );
         LOG.serviceProperties( properties );
         return buildConfiguration().buildSessionFactory(
-				new ServiceRegistryBuilder().applySettings( properties ).buildServiceRegistry()
+				new StandardServiceRegistryBuilder().applySettings( properties ).buildServiceRegistry()
 		);
 	}
 
 	@Override
 	protected Map getExtraProperties() {
 		return properties;
 	}
 
 	@Override
 	public String getTransactionStrategy() {
 		return getProperty(Environment.TRANSACTION_STRATEGY);
 	}
 
 	@Override
 	public void setTransactionStrategy(String txnStrategy) {
 		setProperty(Environment.TRANSACTION_STRATEGY, txnStrategy);
 	}
 
 	@Override
 	public String getUserTransactionName() {
 		return getProperty(Environment.USER_TRANSACTION);
 	}
 
 	@Override
 	public void setUserTransactionName(String utName) {
 		setProperty(Environment.USER_TRANSACTION, utName);
 	}
 
 	@Override
 	public String getJtaPlatformName() {
 		return getProperty( AvailableSettings.JTA_PLATFORM );
 	}
 
 	@Override
 	public void setJtaPlatformName(String name) {
 		setProperty( AvailableSettings.JTA_PLATFORM, name );
 	}
 
 	@Override
 	public String getPropertyList() {
 		return buildProperties().toString();
 	}
 
 	@Override
 	public String getProperty(String property) {
 		return properties.getProperty(property);
 	}
 
 	@Override
 	public void setProperty(String property, String value) {
 		properties.setProperty(property, value);
 	}
 
 	@Override
 	public void dropSchema() {
 		new SchemaExport( buildConfiguration() ).drop(false, true);
 	}
 
 	@Override
 	public void createSchema() {
 		new SchemaExport( buildConfiguration() ).create(false, true);
 	}
 
 	public String getName() {
 		return getProperty(Environment.SESSION_FACTORY_NAME);
 	}
 
 	@Override
 	public String getDatasource() {
 		return getProperty(Environment.DATASOURCE);
 	}
 
 	@Override
 	public void setDatasource(String datasource) {
 		setProperty(Environment.DATASOURCE, datasource);
 	}
 
 	@Override
 	public String getJndiName() {
 		return getProperty(Environment.SESSION_FACTORY_NAME);
 	}
 
 	@Override
 	public void setJndiName(String jndiName) {
 		setProperty(Environment.SESSION_FACTORY_NAME, jndiName);
 	}
 
 	@Override
 	public String getUserName() {
 		return getProperty(Environment.USER);
 	}
 
 	@Override
 	public void setUserName(String userName) {
 		setProperty(Environment.USER, userName);
 	}
 
 	@Override
 	public String getPassword() {
 		return getProperty(Environment.PASS);
 	}
 
 	@Override
 	public void setPassword(String password) {
 		setProperty(Environment.PASS, password);
 	}
 
 	@Override
 	public void setFlushBeforeCompletionEnabled(String enabled) {
 		setProperty(Environment.FLUSH_BEFORE_COMPLETION, enabled);
 	}
 
 	@Override
 	public String getFlushBeforeCompletionEnabled() {
 		return getProperty(Environment.FLUSH_BEFORE_COMPLETION);
 	}
 
 	@Override
 	public void setAutoCloseSessionEnabled(String enabled) {
 		setProperty(Environment.AUTO_CLOSE_SESSION, enabled);
 	}
 
 	@Override
 	public String getAutoCloseSessionEnabled() {
 		return getProperty(Environment.AUTO_CLOSE_SESSION);
 	}
 
 	public Properties getProperties() {
 		return buildProperties();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/jmx/HibernateServiceMBean.java b/hibernate-core/src/main/java/org/hibernate/jmx/HibernateServiceMBean.java
index 2d2913d7a3..25db707ede 100644
--- a/hibernate-core/src/main/java/org/hibernate/jmx/HibernateServiceMBean.java
+++ b/hibernate-core/src/main/java/org/hibernate/jmx/HibernateServiceMBean.java
@@ -1,337 +1,337 @@
 //$Id: HibernateServiceMBean.java 10860 2006-11-22 00:02:55Z steve.ebersole@jboss.com $
 package org.hibernate.jmx;
 import org.hibernate.HibernateException;
 
 /**
  * Hibernate JMX Management API
  * @see HibernateService
  * @author John Urberg, Gavin King
  * @deprecated See <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-6190">HHH-6190</a> for details
  */
 @Deprecated
 public interface HibernateServiceMBean {
 
 	/**
 	 * The Hibernate mapping files (might be overridden by subclasses
 	 * that want to specify the mapping files by some other mechanism)
 	 * @return String
 	 */
 	public String getMapResources();
 	/**
 	 * Specify the Hibernate mapping files
 	 * @param mappingFiles
 	 */
 	public void setMapResources(String mappingFiles);
 	/**
 	 * Add a mapping file
 	 * @param mapResource
 	 */
 	public void addMapResource(String mapResource);
 
 	/**
 	 * Set a property
 	 * @param property the property name
 	 * @param value the property value
 	 */
 	public void setProperty(String property, String value);
 
 	/**
 	 * Get a property
 	 * @param property the property name
 	 * @return the property value
 	 */
 	public String getProperty(String property);
 
 	/**
 	 * Display the properties
 	 * @return a list of property names and values
 	 */
 	public String getPropertyList();
 
 	/**
 	 * The JNDI name of the datasource to use in this <tt>SessionFactory</tt>
 	 * @return String
 	 */
 	public String getDatasource();
 	/**
 	 * Set the JNDI name of the datasource to use in this <tt>SessionFactory</tt>
 	 * @param datasource
 	 */
 	public void setDatasource(String datasource);
 
 	/**
 	 * Log into the database with this name
 	 * @return String
 	 */
 	public String getUserName();
 	/**
 	 * Log into the database with this name
 	 * @param userName
 	 */
 	public void setUserName(String userName);
 
 	/**
 	 * Log into the database with this password
 	 * @return String
 	 */
 	public String getPassword();
 	/**
 	 * Log into the database with this password
 	 * @param password
 	 */
 	public void setPassword(String password);
 
 	/**
 	 * The JNDI name of the dialect class to use in this <tt>SessionFactory</tt>
 	 * @return String
 	 */
 	public String getDialect();
 	/**
 	 * The name of the dialect class to use in this <tt>SessionFactory</tt>
 	 * @param dialect fully qualified class name of <tt>Dialect</tt> subclass
 	 * @see org.hibernate.dialect.Dialect
 	 */
 	public void setDialect(String dialect);
 
 	/**
 	 * The JNDI name to bind to the <tt>SessionFactory</tt>
 	 * @return String
 	 */
 	public String getJndiName();
 	/**
 	 * The JNDI name to bind to the <tt>SessionFactory</tt>
 	 * @param jndiName
 	 */
 	public void setJndiName(String jndiName);
 
 	/**
 	 * The fully qualified class name of the Hibernate {@link org.hibernate.engine.transaction.spi.TransactionFactory}
 	 * implementation to use
 	 *
 	 * @return the class name
 	 */
 	public String getTransactionStrategy();
 
 	/**
 	 * Set the fully qualified class name of the Hibernate {@link org.hibernate.engine.transaction.spi.TransactionFactory}
 	 * implementation to use.
 	 *
 	 * @param txnStrategy the class name
 	 */
 	public void setTransactionStrategy(String txnStrategy);
 
 	/**
 	 * The JNDI name of the JTA UserTransaction object (used only be <tt>JtaTransaction</tt>).
 	 * @return the JNDI name
 	 * @see org.hibernate.engine.transaction.internal.jta.JtaTransaction
 	 */
 	public String getUserTransactionName();
 	/**
 	 * Set the JNDI name of the JTA UserTransaction object (used only by <tt>JtaTransaction</tt>).
 	 * @param utName the JNDI name
 	 * @see org.hibernate.engine.transaction.internal.jta.JtaTransaction
 	 */
 	public void setUserTransactionName(String utName);
 
 	/**
-	 * Get the name of the {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation to use.
+	 * Get the name of the {@link org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform} implementation to use.
 	 *
-	 * @return The name of the {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation to use.
+	 * @return The name of the {@link org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform} implementation to use.
 	 */
 	public String getJtaPlatformName();
 
 	/**
-	 * Sets the name of the {@link org.hibernate.service.jta.platform.spi.JtaPlatform} implementation to use.
+	 * Sets the name of the {@link org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform} implementation to use.
 	 *
 	 * @param name The implementation class name.
 	 */
 	public void setJtaPlatformName(String name);
 
 	/**
 	 * Is SQL logging enabled?
 	 */
 	public String getShowSqlEnabled();
 	/**
 	 * Enable logging of SQL to console
 	 */
 	public void setShowSqlEnabled(String showSql);
 	/**
 	 * Get the maximum outer join fetch depth
 	 */
 	public String getMaximumFetchDepth();
 	/**
 	 * Set the maximum outer join fetch depth
 	 */
 	public void setMaximumFetchDepth(String fetchDepth);
 	/**
 	 * Get the maximum JDBC batch size
 	 */
 	public String getJdbcBatchSize();
 	/**
 	 * Set the maximum JDBC batch size
 	 */
 	public void setJdbcBatchSize(String batchSize);
 	/**
 	 * Get the JDBC fetch size
 	 */
 	public String getJdbcFetchSize();
 	/**
 	 * Set the JDBC fetch size
 	 */
 	public void setJdbcFetchSize(String fetchSize);
 	/**
 	 * Get the query language substitutions
 	 */
 	public String getQuerySubstitutions();
 	/**
 	 * Set the query language substitutions
 	 */
 	public void setQuerySubstitutions(String querySubstitutions);
 	/**
 	 * Get the default schema
 	 */
 	public String getDefaultSchema();
 	/**
 	 * Set the default schema
 	 */
 	public void setDefaultSchema(String schema);
 	/**
 	 * Get the default catalog
 	 */
 	public String getDefaultCatalog();
 	/**
 	 * Set the default catalog
 	 */
 	public void setDefaultCatalog(String catalog);
 	/**
 	 * Is use of scrollable resultsets enabled?
 	 */
 	public String getJdbcScrollableResultSetEnabled();
 	/**
 	 * Enable or disable the use of scrollable resultsets 
 	 */
 	public void setJdbcScrollableResultSetEnabled(String enabled);
 	/**
 	 * Is use of JDBC3 <tt>getGeneratedKeys()</tt> enabled?
 	 */
 	public String getGetGeneratedKeysEnabled();
 	/**
 	 * Enable or disable the use <tt>getGeneratedKeys()</tt> 
 	 */
 	public void setGetGeneratedKeysEnabled(String enabled);
 	/**
 	 * Get the second-level cache provider class name
 	 */
 	public String getCacheRegionFactory();
 	/**
 	 * Set the second-level cache provider class name
 	 */
 	public void setCacheRegionFactory(String cacheRegionFactory);
 	/**
 	 * For cache providers which support this setting, get the
 	 * provider's specific configuration resource.
 	 */
 	public String getCacheProviderConfig();
 	/**
 	 * For cache providers which support this setting, specify the
 	 * provider's specific configuration resource.
 	 */
 	public void setCacheProviderConfig(String cacheProviderConfig);
 	/**
 	 * Is the query cache enabled?
 	 */
 	public String getQueryCacheEnabled();
 	/**
 	 * Enable or disable the query cache
 	 */
 	public void setQueryCacheEnabled(String enabled);
 	/**
 	 * Is the second-level cache enabled?
 	 */
 	public String getSecondLevelCacheEnabled();
 	/**
 	 * Enable or disable the second-level cache
 	 */
 	public void setSecondLevelCacheEnabled(String enabled);
 	/**
 	 * Get the cache region prefix
 	 */
 	public String getCacheRegionPrefix();
 	/**
 	 * Set the cache region prefix
 	 */
 	public void setCacheRegionPrefix(String prefix);
 	/**
 	 * Is the second-level cache optimized for miminal puts?
 	 */
 	public String getMinimalPutsEnabled();
 	/**
 	 * Enable or disable optimization of second-level cache
 	 * for minimal puts 
 	 */
 	public void setMinimalPutsEnabled(String enabled);
 	/**
 	 * Are SQL comments enabled?
 	 */
 	public String getCommentsEnabled();
 	/**
 	 * Enable or disable the inclusion of comments in
 	 * generated SQL
 	 */
 	public void setCommentsEnabled(String enabled);
 	/**
 	 * Is JDBC batch update for versioned entities enabled?
 	 */
 	public String getBatchVersionedDataEnabled();
 	/**
 	 * Enable or disable the use of batch updates for
 	 * versioned entities
 	 */
 	public void setBatchVersionedDataEnabled(String enabled);
 	
 	/**
 	 * Enable automatic flushing of the Session when JTA transaction ends.
 	 */
 	public void setFlushBeforeCompletionEnabled(String enabled);
 	/**
 	 * Is automatic Session flusing enabled?
 	 */
 	public String getFlushBeforeCompletionEnabled();
 
 	/**
 	 * Enable automatic closing of Session when JTA transaction ends.
 	 */
 	public void setAutoCloseSessionEnabled(String enabled);
 	/**
 	 * Is automatic Session closing enabled?
 	 */
 	public String getAutoCloseSessionEnabled();
 
 	/**
 	 * Export the <tt>CREATE</tt> DDL to the database
 	 * @throws HibernateException
 	 */
 	public void createSchema() throws HibernateException;
 	/**
 	 * Export the <tt>DROP</tt> DDL to the database
 	 * @throws HibernateException
 	 */
 	public void dropSchema() throws HibernateException;
 
 
 	/**
 	 * Create the <tt>SessionFactory</tt> and bind to the jndi name on startup
 	 */
 	public void start() throws HibernateException;
 	/**
 	 * Unbind the <tt>SessionFactory</tt> or stub from JNDI
 	 */
 	public void stop();
 
 }
 
 
 
 
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/jmx/SessionFactoryStub.java b/hibernate-core/src/main/java/org/hibernate/jmx/SessionFactoryStub.java
index 837aa39be0..974277ebee 100644
--- a/hibernate-core/src/main/java/org/hibernate/jmx/SessionFactoryStub.java
+++ b/hibernate-core/src/main/java/org/hibernate/jmx/SessionFactoryStub.java
@@ -1,258 +1,258 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jmx;
 
 import java.io.InvalidObjectException;
 import java.io.ObjectStreamException;
 import java.io.Serializable;
 import java.sql.Connection;
 import java.util.Map;
 import java.util.Set;
 import javax.naming.NamingException;
 import javax.naming.Reference;
 import javax.naming.StringRefAddr;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.Cache;
 import org.hibernate.HibernateException;
 import org.hibernate.Session;
 import org.hibernate.SessionBuilder;
 import org.hibernate.SessionFactory;
 import org.hibernate.StatelessSession;
 import org.hibernate.StatelessSessionBuilder;
 import org.hibernate.TypeHelper;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.UUIDGenerator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.SessionFactoryRegistry;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.metadata.ClassMetadata;
 import org.hibernate.metadata.CollectionMetadata;
-import org.hibernate.service.jndi.internal.JndiServiceImpl;
+import org.hibernate.engine.jndi.internal.JndiServiceImpl;
 import org.hibernate.stat.Statistics;
 
 /**
  * A flyweight for <tt>SessionFactory</tt>. If the MBean itself does not
  * have classpath to the persistent classes, then a stub will be registered
  * with JNDI and the actual <tt>SessionFactoryImpl</tt> built upon first
  * access.
  *
  * @author Gavin King
  *
  * @deprecated See <a href="http://opensource.atlassian.com/projects/hibernate/browse/HHH-6190">HHH-6190</a> for details
  */
 @Deprecated
 @SuppressWarnings( {"deprecation"})
 public class SessionFactoryStub implements SessionFactory {
 	private static final IdentifierGenerator UUID_GENERATOR = UUIDGenerator.buildSessionFactoryUniqueIdentifierGenerator();
 
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, SessionFactoryStub.class.getName());
 
 	private transient SessionFactory impl;
 	private transient HibernateService service;
 	private String uuid;
 	private String name;
 
 	SessionFactoryStub(HibernateService service) {
 		this.service = service;
 		this.name = service.getJndiName();
 		try {
 			uuid = (String) UUID_GENERATOR.generate(null, null);
 		}
 		catch (Exception e) {
 			throw new AssertionFailure("Could not generate UUID");
 		}
 
 		SessionFactoryRegistry.INSTANCE.addSessionFactory(
 				uuid,
 				name,
 				ConfigurationHelper.getBoolean(
 						AvailableSettings.SESSION_FACTORY_NAME_IS_JNDI,
 						service.getProperties(),
 						true
 				),
 				this,
 				new JndiServiceImpl( service.getProperties() )
 		);
 	}
 
 	@Override
 	public SessionFactoryOptions getSessionFactoryOptions() {
 		return impl.getSessionFactoryOptions();
 	}
 
 	@Override
 	public SessionBuilder withOptions() {
 		return getImpl().withOptions();
 	}
 
 	public Session openSession() throws HibernateException {
 		return getImpl().openSession();
 	}
 
 	public Session getCurrentSession() {
 		return getImpl().getCurrentSession();
 	}
 
 	private synchronized SessionFactory getImpl() {
 		if (impl==null) impl = service.buildSessionFactory();
 		return impl;
 	}
 
 	//readResolveObject
 	private Object readResolve() throws ObjectStreamException {
 		// look for the instance by uuid
 		Object result = SessionFactoryRegistry.INSTANCE.getSessionFactory( uuid ) ;
 		if ( result == null ) {
             // in case we were deserialized in a different JVM, look for an instance with the same name
 			// (alternatively we could do an actual JNDI lookup here....)
 			result = SessionFactoryRegistry.INSTANCE.getNamedSessionFactory( name );
 			if ( result == null ) {
 				throw new InvalidObjectException( "Could not find a SessionFactory [uuid=" + uuid + ",name=" + name + "]" );
 			}
 			LOG.debug("Resolved stub SessionFactory by name");
 		}
 		else {
 			LOG.debug("Resolved stub SessionFactory by UUID");
 		}
 		return result;
 	}
 
 	/**
 	 * @see javax.naming.Referenceable#getReference()
 	 */
 	@Override
 	public Reference getReference() throws NamingException {
 		return new Reference(
 				SessionFactoryStub.class.getName(),
 				new StringRefAddr("uuid", uuid),
 				SessionFactoryRegistry.ObjectFactoryImpl.class.getName(),
 				null
 		);
 	}
 
 	public ClassMetadata getClassMetadata(Class persistentClass) throws HibernateException {
 		return getImpl().getClassMetadata(persistentClass);
 	}
 
 	public ClassMetadata getClassMetadata(String entityName)
 	throws HibernateException {
 		return getImpl().getClassMetadata(entityName);
 	}
 
 	public CollectionMetadata getCollectionMetadata(String roleName) throws HibernateException {
 		return getImpl().getCollectionMetadata(roleName);
 	}
 
 	public Map<String,ClassMetadata> getAllClassMetadata() throws HibernateException {
 		return getImpl().getAllClassMetadata();
 	}
 
 	public Map getAllCollectionMetadata() throws HibernateException {
 		return getImpl().getAllCollectionMetadata();
 	}
 
 	public void close() throws HibernateException {
 	}
 
 	public boolean isClosed() {
 		return false;
 	}
 
 	public Cache getCache() {
 		return getImpl().getCache();
 	}
 
 	public void evict(Class persistentClass, Serializable id)
 		throws HibernateException {
 		getImpl().evict(persistentClass, id);
 	}
 
 	public void evict(Class persistentClass) throws HibernateException {
 		getImpl().evict(persistentClass);
 	}
 
 	public void evictEntity(String entityName, Serializable id)
 	throws HibernateException {
 		getImpl().evictEntity(entityName, id);
 	}
 
 	public void evictEntity(String entityName) throws HibernateException {
 		getImpl().evictEntity(entityName);
 	}
 
 	public void evictCollection(String roleName, Serializable id)
 		throws HibernateException {
 		getImpl().evictCollection(roleName, id);
 	}
 
 	public void evictCollection(String roleName) throws HibernateException {
 		getImpl().evictCollection(roleName);
 	}
 
 	public void evictQueries() throws HibernateException {
 		getImpl().evictQueries();
 	}
 
 	public void evictQueries(String cacheRegion) throws HibernateException {
 		getImpl().evictQueries(cacheRegion);
 	}
 
 	public Statistics getStatistics() {
 		return getImpl().getStatistics();
 	}
 
 	@Override
 	public StatelessSessionBuilder withStatelessOptions() {
 		return getImpl().withStatelessOptions();
 	}
 
 	public StatelessSession openStatelessSession() {
 		return getImpl().openStatelessSession();
 	}
 
 	public StatelessSession openStatelessSession(Connection conn) {
 		return getImpl().openStatelessSession(conn);
 	}
 
 	public Set getDefinedFilterNames() {
 		return getImpl().getDefinedFilterNames();
 	}
 
 	public FilterDefinition getFilterDefinition(String filterName) throws HibernateException {
 		return getImpl().getFilterDefinition( filterName );
 	}
 
 	public boolean containsFetchProfileDefinition(String name) {
 		return getImpl().containsFetchProfileDefinition( name );
 	}
 
 	public TypeHelper getTypeHelper() {
 		return getImpl().getTypeHelper();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jmx/internal/DisabledJmxServiceImpl.java b/hibernate-core/src/main/java/org/hibernate/jmx/internal/DisabledJmxServiceImpl.java
similarity index 94%
rename from hibernate-core/src/main/java/org/hibernate/service/jmx/internal/DisabledJmxServiceImpl.java
rename to hibernate-core/src/main/java/org/hibernate/jmx/internal/DisabledJmxServiceImpl.java
index d9a1efe228..943a9a6769 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jmx/internal/DisabledJmxServiceImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/jmx/internal/DisabledJmxServiceImpl.java
@@ -1,45 +1,45 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jmx.internal;
+package org.hibernate.jmx.internal;
 import javax.management.ObjectName;
 
-import org.hibernate.service.jmx.spi.JmxService;
+import org.hibernate.jmx.spi.JmxService;
 import org.hibernate.service.spi.Manageable;
 
 /**
  * A no-op version of the {@link JmxService}
  *
  * @author Steve Ebersole
  */
 public class DisabledJmxServiceImpl  implements JmxService {
 	public static final DisabledJmxServiceImpl INSTANCE = new DisabledJmxServiceImpl();
 
 	@Override
 	public void registerService(Manageable service, Class serviceRole) {
 	}
 
 	@Override
 	public void registerMBean(ObjectName objectName, Object mBean) {
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jmx/internal/JmxServiceImpl.java b/hibernate-core/src/main/java/org/hibernate/jmx/internal/JmxServiceImpl.java
similarity index 98%
rename from hibernate-core/src/main/java/org/hibernate/service/jmx/internal/JmxServiceImpl.java
rename to hibernate-core/src/main/java/org/hibernate/jmx/internal/JmxServiceImpl.java
index 4ba6ca1ba2..384f56e6ec 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jmx/internal/JmxServiceImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/jmx/internal/JmxServiceImpl.java
@@ -1,211 +1,211 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jmx.internal;
+package org.hibernate.jmx.internal;
 import java.lang.management.ManagementFactory;
 import java.util.ArrayList;
 import java.util.Map;
 import javax.management.MBeanServer;
 import javax.management.MBeanServerFactory;
 import javax.management.MalformedObjectNameException;
 import javax.management.ObjectName;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Environment;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.Service;
-import org.hibernate.service.jmx.spi.JmxService;
+import org.hibernate.jmx.spi.JmxService;
 import org.hibernate.service.spi.Manageable;
 import org.hibernate.service.spi.Stoppable;
 
 /**
  * Standard implementation of JMX services
  *
  * @author Steve Ebersole
  */
 public class JmxServiceImpl implements JmxService, Stoppable {
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, JmxServiceImpl.class.getName());
 
 	public static final String OBJ_NAME_TEMPLATE = "%s:sessionFactory=%s,serviceRole=%s,serviceType=%s";
 
 	private final boolean usePlatformServer;
 	private final String agentId;
 	private final String defaultDomain;
 	private final String sessionFactoryName;
 
 	public JmxServiceImpl(Map configValues) {
 		usePlatformServer = ConfigurationHelper.getBoolean( AvailableSettings.JMX_PLATFORM_SERVER, configValues );
 		agentId = (String) configValues.get( AvailableSettings.JMX_AGENT_ID );
 		defaultDomain = (String) configValues.get( AvailableSettings.JMX_DOMAIN_NAME );
 		sessionFactoryName = ConfigurationHelper.getString(
 				AvailableSettings.JMX_SF_NAME,
 				configValues,
 				ConfigurationHelper.getString( Environment.SESSION_FACTORY_NAME, configValues )
 		);
 	}
 
 	private boolean startedServer;
 	private ArrayList<ObjectName> registeredMBeans;
 
 	@Override
 	public void stop() {
 		try {
 			// if we either started the JMX server or we registered some MBeans we at least need to look up
 			// MBean server and do *some* work on shutdown.
 			if ( startedServer || registeredMBeans != null ) {
 				MBeanServer mBeanServer = findServer();
 				if ( mBeanServer == null ) {
 					LOG.unableToLocateMBeanServer();
 					return;
 				}
 
 				// release any MBeans we registered
 				if ( registeredMBeans != null ) {
 					for ( ObjectName objectName : registeredMBeans ) {
 						try {
 							LOG.tracev( "Unregistering registered MBean [ON={0}]", objectName );
 							mBeanServer.unregisterMBean( objectName );
 						}
 						catch ( Exception e ) {
 							LOG.debugf( "Unable to unregsiter registered MBean [ON=%s] : %s", objectName, e.toString() );
 						}
 					}
 				}
 
 				// stop the MBean server if we started it
 				if ( startedServer ) {
 					LOG.trace( "Attempting to release created MBeanServer" );
 					try {
 						MBeanServerFactory.releaseMBeanServer( mBeanServer );
 					}
 					catch ( Exception e ) {
 						LOG.unableToReleaseCreatedMBeanServer( e.toString() );
 					}
 				}
 			}
 		}
 		finally {
 			startedServer = false;
 			if ( registeredMBeans != null ) {
 				registeredMBeans.clear();
 				registeredMBeans = null;
 			}
 		}
 	}
 
 
 	// todo : should serviceRole come first in ObjectName template?  depends on the groupings we want in the UI.
 	// 		as-is mbeans from each sessionFactory are grouped primarily.
 
 	@Override
 	public void registerService(Manageable service, Class<? extends Service> serviceRole) {
 		final String domain = service.getManagementDomain() == null
 				? AvailableSettings.JMX_DEFAULT_OBJ_NAME_DOMAIN
 				: service.getManagementDomain();
 		final String serviceType = service.getManagementServiceType() == null
 				? service.getClass().getName()
 				: service.getManagementServiceType();
 		try {
 			final ObjectName objectName = new ObjectName(
 					String.format(
 							OBJ_NAME_TEMPLATE,
 							domain,
 							sessionFactoryName,
 							serviceRole.getName(),
 							serviceType
 					)
 			);
 			registerMBean( objectName, service.getManagementBean() );
 		}
 		catch ( MalformedObjectNameException e ) {
 			throw new HibernateException( "Unable to generate service IbjectName", e );
 		}
 	}
 
 	@Override
 	public void registerMBean(ObjectName objectName, Object mBean) {
 		MBeanServer mBeanServer = findServer();
 		if ( mBeanServer == null ) {
 			if ( startedServer ) {
 				throw new HibernateException( "Could not locate previously started MBeanServer" );
 			}
 			mBeanServer = startMBeanServer();
 			startedServer = true;
 		}
 
 		try {
 			mBeanServer.registerMBean( mBean, objectName );
 			if ( registeredMBeans == null ) {
 				registeredMBeans = new ArrayList<ObjectName>();
 			}
 			registeredMBeans.add( objectName );
 		}
 		catch ( Exception e ) {
 			throw new HibernateException( "Unable to register MBean [ON=" + objectName + "]", e );
 		}
 	}
 
 	/**
 	 * Locate the MBean server to use based on user input from startup.
 	 *
 	 * @return The MBean server to use.
 	 */
 	private MBeanServer findServer() {
 		if ( usePlatformServer ) {
 			// they specified to use the platform (vm) server
 			return ManagementFactory.getPlatformMBeanServer();
 		}
 
 		// otherwise lookup all servers by (optional) agentId.
 		// IMPL NOTE : the findMBeanServer call treats a null agentId to mean match all...
 		ArrayList<MBeanServer> mbeanServers = MBeanServerFactory.findMBeanServer( agentId );
 
 		if ( defaultDomain == null ) {
 			// they did not specify a domain by which to locate a particular MBeanServer to use, so chose the first
 			return mbeanServers.get( 0 );
 		}
 
 		for ( MBeanServer mbeanServer : mbeanServers ) {
 			// they did specify a domain, so attempt to locate an MBEanServer with a matching default domain, returning it
 			// if we find it.
 			if ( defaultDomain.equals( mbeanServer.getDefaultDomain() ) ) {
 				return mbeanServer;
 			}
 		}
 
 		return null;
 	}
 
 	private MBeanServer startMBeanServer() {
 		try {
 			return MBeanServerFactory.createMBeanServer( defaultDomain );
 		}
 		catch ( Exception e ) {
 			throw new HibernateException( "Unable to start MBeanServer", e );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jmx/internal/JmxServiceInitiator.java b/hibernate-core/src/main/java/org/hibernate/jmx/internal/JmxServiceInitiator.java
similarity index 88%
rename from hibernate-core/src/main/java/org/hibernate/service/jmx/internal/JmxServiceInitiator.java
rename to hibernate-core/src/main/java/org/hibernate/jmx/internal/JmxServiceInitiator.java
index 1d2cc97eb9..e3c7b51a45 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jmx/internal/JmxServiceInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/jmx/internal/JmxServiceInitiator.java
@@ -1,53 +1,53 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jmx.internal;
+package org.hibernate.jmx.internal;
 
 import java.util.Map;
 
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.internal.util.config.ConfigurationHelper;
-import org.hibernate.service.jmx.spi.JmxService;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.jmx.spi.JmxService;
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * Standard initiator for the standard {@link JmxService} service
  *
  * @author Steve Ebersole
  */
-public class JmxServiceInitiator implements BasicServiceInitiator<JmxService> {
+public class JmxServiceInitiator implements StandardServiceInitiator<JmxService> {
 	public static final JmxServiceInitiator INSTANCE = new JmxServiceInitiator();
 
 	@Override
 	public Class<JmxService> getServiceInitiated() {
 		return JmxService.class;
 	}
 
 	@Override
 	public JmxService initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		return ConfigurationHelper.getBoolean( AvailableSettings.JMX_ENABLED, configurationValues, false )
 				? new JmxServiceImpl( configurationValues )
 				: DisabledJmxServiceImpl.INSTANCE;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/jmx/package.html b/hibernate-core/src/main/java/org/hibernate/jmx/package.html
deleted file mode 100755
index 66827f9090..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/jmx/package.html
+++ /dev/null
@@ -1,14 +0,0 @@
-<html>
-<head></head>
-<body>
-<p>
-	This package exposes a Hibernate instance via JMX.
-</p>
-<p>
-	<tt>HibernateService</tt> allows configuration and management
-	of the Hibernate runtime. <tt>StatisticsService</tt>
-	reports information that might be useful for performance
-	tuning.
-</p>
-</body>
-</html>
diff --git a/hibernate-core/src/main/java/org/hibernate/service/jmx/spi/JmxService.java b/hibernate-core/src/main/java/org/hibernate/jmx/spi/JmxService.java
similarity index 97%
rename from hibernate-core/src/main/java/org/hibernate/service/jmx/spi/JmxService.java
rename to hibernate-core/src/main/java/org/hibernate/jmx/spi/JmxService.java
index 629cf8faec..96a52d4730 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/jmx/spi/JmxService.java
+++ b/hibernate-core/src/main/java/org/hibernate/jmx/spi/JmxService.java
@@ -1,52 +1,52 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
-package org.hibernate.service.jmx.spi;
+package org.hibernate.jmx.spi;
 
 import javax.management.ObjectName;
 
 import org.hibernate.service.Service;
 import org.hibernate.service.spi.Manageable;
 
 /**
  * Service providing simplified access to JMX related features needed by Hibernate.
  *
  * @author Steve Ebersole
  */
 public interface JmxService extends Service {
 	/**
 	 * Handles registration of a manageable service.
 	 *
 	 * @param service The manageable service
 	 * @param serviceRole The service's role.
 	 */
 	public void registerService(Manageable service, Class<? extends Service> serviceRole);
 
 	/**
 	 * Registers the given {@code mBean} under the given {@code objectName}
 	 *
 	 * @param objectName The name under which to register the MBean
 	 * @param mBean The MBean to register
 	 */
 	public void registerMBean(ObjectName objectName, Object mBean);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataSources.java b/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataSources.java
index 24a46ffbf1..ba0b78e69c 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataSources.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/MetadataSources.java
@@ -1,382 +1,382 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Enumeration;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.jar.JarFile;
 import java.util.zip.ZipEntry;
 
 import org.jboss.logging.Logger;
 import org.w3c.dom.Document;
 import org.xml.sax.EntityResolver;
 
 import org.hibernate.cfg.EJB3DTDEntityResolver;
 import org.hibernate.cfg.EJB3NamingStrategy;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.internal.jaxb.JaxbRoot;
 import org.hibernate.internal.jaxb.Origin;
 import org.hibernate.internal.jaxb.SourceType;
 import org.hibernate.metamodel.source.MappingException;
 import org.hibernate.metamodel.source.MappingNotFoundException;
 import org.hibernate.metamodel.source.internal.JaxbHelper;
 import org.hibernate.metamodel.source.internal.MetadataBuilderImpl;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 /**
  * @author Steve Ebersole
  */
 public class MetadataSources {
 	private static final Logger LOG = Logger.getLogger( MetadataSources.class );
 
 	private List<JaxbRoot> jaxbRootList = new ArrayList<JaxbRoot>();
 	private LinkedHashSet<Class<?>> annotatedClasses = new LinkedHashSet<Class<?>>();
 	private LinkedHashSet<String> annotatedPackages = new LinkedHashSet<String>();
 
 	private final JaxbHelper jaxbHelper;
 
 	private final ServiceRegistry serviceRegistry;
 	private final EntityResolver entityResolver;
 	private final NamingStrategy namingStrategy;
 
 	private final MetadataBuilderImpl metadataBuilder;
 
 	public MetadataSources(ServiceRegistry serviceRegistry) {
 		this( serviceRegistry, EJB3DTDEntityResolver.INSTANCE, EJB3NamingStrategy.INSTANCE );
 	}
 
 	public MetadataSources(ServiceRegistry serviceRegistry, EntityResolver entityResolver, NamingStrategy namingStrategy) {
 		this.serviceRegistry = serviceRegistry;
 		this.entityResolver = entityResolver;
 		this.namingStrategy = namingStrategy;
 
 		this.jaxbHelper = new JaxbHelper( this );
 		this.metadataBuilder = new MetadataBuilderImpl( this );
 	}
 
 	public List<JaxbRoot> getJaxbRootList() {
 		return jaxbRootList;
 	}
 
 	public Iterable<String> getAnnotatedPackages() {
 		return annotatedPackages;
 	}
 
 	public Iterable<Class<?>> getAnnotatedClasses() {
 		return annotatedClasses;
 	}
 
 	public ServiceRegistry getServiceRegistry() {
 		return serviceRegistry;
 	}
 
 	public NamingStrategy getNamingStrategy() {
 		return namingStrategy;
 	}
 
 	public MetadataBuilder getMetadataBuilder() {
 		return metadataBuilder;
 	}
 
 	public Metadata buildMetadata() {
 		return getMetadataBuilder().buildMetadata();
 	}
 
 	/**
 	 * Read metadata from the annotations attached to the given class.
 	 *
 	 * @param annotatedClass The class containing annotations
 	 *
 	 * @return this (for method chaining)
 	 */
 	public MetadataSources addAnnotatedClass(Class annotatedClass) {
 		annotatedClasses.add( annotatedClass );
 		return this;
 	}
 
 	/**
 	 * Read package-level metadata.
 	 *
 	 * @param packageName java package name without trailing '.', cannot be {@code null}
 	 *
 	 * @return this (for method chaining)
 	 */
 	public MetadataSources addPackage(String packageName) {
 		if ( packageName == null ) {
 			throw new IllegalArgumentException( "The specified package name cannot be null" );
 		}
 		if ( packageName.endsWith( "." ) ) {
 			packageName = packageName.substring( 0, packageName.length() - 1 );
 		}
 		annotatedPackages.add( packageName );
 		return this;
 	}
 
 	/**
 	 * Read mappings as a application resourceName (i.e. classpath lookup).
 	 *
 	 * @param name The resource name
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addResource(String name) {
 		LOG.tracef( "reading mappings from resource : %s", name );
 
 		final Origin origin = new Origin( SourceType.RESOURCE, name );
 		InputStream resourceInputStream = classLoaderService().locateResourceStream( name );
 		if ( resourceInputStream == null ) {
 			throw new MappingNotFoundException( origin );
 		}
 		add( resourceInputStream, origin, true );
 
 		return this;
 	}
 
 	private ClassLoaderService classLoaderService() {
 		return serviceRegistry.getService( ClassLoaderService.class );
 	}
 
 	private JaxbRoot add(InputStream inputStream, Origin origin, boolean close) {
 		try {
 			JaxbRoot jaxbRoot = jaxbHelper.unmarshal( inputStream, origin );
 			jaxbRootList.add( jaxbRoot );
 			return jaxbRoot;
 		}
 		finally {
 			if ( close ) {
 				try {
 					inputStream.close();
 				}
 				catch ( IOException ignore ) {
 					LOG.trace( "Was unable to close input stream" );
 				}
 			}
 		}
 	}
 
 	/**
 	 * Read a mapping as an application resource using the convention that a class named {@code foo.bar.Foo} is
 	 * mapped by a file named {@code foo/bar/Foo.hbm.xml} which can be resolved as a classpath resource.
 	 *
 	 * @param entityClass The mapped class. Cannot be {@code null} null.
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addClass(Class entityClass) {
 		if ( entityClass == null ) {
 			throw new IllegalArgumentException( "The specified class cannot be null" );
 		}
 		LOG.debugf( "adding resource mappings from class convention : %s", entityClass.getName() );
 		final String mappingResourceName = entityClass.getName().replace( '.', '/' ) + ".hbm.xml";
 		addResource( mappingResourceName );
 		return this;
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param path The path to a file.  Expected to be resolvable by {@link File#File(String)}
 	 *
 	 * @return this (for method chaining purposes)
 	 *
 	 * @see #addFile(java.io.File)
 	 */
 	public MetadataSources addFile(String path) {
 		return addFile( new File( path ) );
 	}
 
 	/**
 	 * Read mappings from a particular XML file
 	 *
 	 * @param file The reference to the XML file
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addFile(File file) {
 		final String name = file.getAbsolutePath();
 		LOG.tracef( "reading mappings from file : %s", name );
 		final Origin origin = new Origin( SourceType.FILE, name );
 		try {
 			add( new FileInputStream( file ), origin, true );
 		}
 		catch ( FileNotFoundException e ) {
 			throw new MappingNotFoundException( e, origin );
 		}
 		return this;
 	}
 
 	/**
 	 * See {@link #addCacheableFile(java.io.File)} for description
 	 *
 	 * @param path The path to a file.  Expected to be resolvable by {@link File#File(String)}
 	 *
 	 * @return this (for method chaining purposes)
 	 *
 	 * @see #addCacheableFile(java.io.File)
 	 */
 	public MetadataSources addCacheableFile(String path) {
 		return this; // todo : implement method body
 	}
 
 	/**
 	 * Add a cached mapping file.  A cached file is a serialized representation of the DOM structure of a
 	 * particular mapping.  It is saved from a previous call as a file with the name {@code {xmlFile}.bin}
 	 * where {@code {xmlFile}} is the name of the original mapping file.
 	 * </p>
 	 * If a cached {@code {xmlFile}.bin} exists and is newer than {@code {xmlFile}}, the {@code {xmlFile}.bin}
 	 * file will be read directly. Otherwise {@code {xmlFile}} is read and then serialized to {@code {xmlFile}.bin} for
 	 * use the next time.
 	 *
 	 * @param file The cacheable mapping file to be added, {@code {xmlFile}} in above discussion.
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addCacheableFile(File file) {
 		return this; // todo : implement method body
 	}
 
 	/**
 	 * Read metadata from an {@link InputStream}.
 	 *
 	 * @param xmlInputStream The input stream containing a DOM.
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addInputStream(InputStream xmlInputStream) {
 		add( xmlInputStream, new Origin( SourceType.INPUT_STREAM, "<unknown>" ), false );
 		return this;
 	}
 
 	/**
 	 * Read mappings from a {@link URL}
 	 *
 	 * @param url The url for the mapping document to be read.
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addURL(URL url) {
 		final String urlExternalForm = url.toExternalForm();
 		LOG.debugf( "Reading mapping document from URL : %s", urlExternalForm );
 
 		final Origin origin = new Origin( SourceType.URL, urlExternalForm );
 		try {
 			add( url.openStream(), origin, true );
 		}
 		catch ( IOException e ) {
 			throw new MappingNotFoundException( "Unable to open url stream [" + urlExternalForm + "]", e, origin );
 		}
 		return this;
 	}
 
 	/**
 	 * Read mappings from a DOM {@link Document}
 	 *
 	 * @param document The DOM document
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addDocument(Document document) {
 		final Origin origin = new Origin( SourceType.DOM, "<unknown>" );
 		JaxbRoot jaxbRoot = jaxbHelper.unmarshal( document, origin );
 		jaxbRootList.add( jaxbRoot );
 		return this;
 	}
 
 	/**
 	 * Read all mappings from a jar file.
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param jar a jar file
 	 *
 	 * @return this (for method chaining purposes)
 	 */
 	public MetadataSources addJar(File jar) {
 		LOG.debugf( "Seeking mapping documents in jar file : %s", jar.getName() );
 		final Origin origin = new Origin( SourceType.JAR, jar.getAbsolutePath() );
 		try {
 			JarFile jarFile = new JarFile( jar );
 			try {
 				Enumeration jarEntries = jarFile.entries();
 				while ( jarEntries.hasMoreElements() ) {
 					final ZipEntry zipEntry = (ZipEntry) jarEntries.nextElement();
 					if ( zipEntry.getName().endsWith( ".hbm.xml" ) ) {
 						LOG.tracef( "found mapping document : %s", zipEntry.getName() );
 						try {
 							add( jarFile.getInputStream( zipEntry ), origin, true );
 						}
 						catch ( Exception e ) {
 							throw new MappingException( "could not read mapping documents", e, origin );
 						}
 					}
 				}
 			}
 			finally {
 				try {
 					jarFile.close();
 				}
 				catch ( Exception ignore ) {
 				}
 			}
 		}
 		catch ( IOException e ) {
 			throw new MappingNotFoundException( e, origin );
 		}
 		return this;
 	}
 
 	/**
 	 * Read all mapping documents from a directory tree.
 	 * <p/>
 	 * Assumes that any file named <tt>*.hbm.xml</tt> is a mapping document.
 	 *
 	 * @param dir The directory
 	 *
 	 * @return this (for method chaining purposes)
 	 *
 	 * @throws org.hibernate.MappingException Indicates problems reading the jar file or
 	 * processing the contained mapping documents.
 	 */
 	public MetadataSources addDirectory(File dir) {
 		File[] files = dir.listFiles();
 		for ( File file : files ) {
 			if ( file.isDirectory() ) {
 				addDirectory( file );
 			}
 			else if ( file.getName().endsWith( ".hbm.xml" ) ) {
 				addFile( file );
 			}
 		}
 		return this;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/JavaType.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/JavaType.java
index d6c6a0eeff..59c5639387 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/JavaType.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/JavaType.java
@@ -1,70 +1,70 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.domain;
 
 import org.hibernate.internal.util.ValueHolder;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 /**
  * Models the naming of a Java type where we may not have access to that type's {@link Class} reference.  Generally
  * speaking this is the case in various hibernate-tools and reverse-engineering use cases.
  *
  * @author Steve Ebersole
  */
 public class JavaType {
 	private final String name;
 	private final ValueHolder<Class<?>> classReference;
 
 	public JavaType(final String name, final ClassLoaderService classLoaderService) {
 		this.name = name;
 		this.classReference = new ValueHolder<Class<?>>(
 				new ValueHolder.DeferredInitializer<Class<?>>() {
 					@Override
 					public Class<?> initialize() {
 						return classLoaderService.classForName( name );
 					}
 				}
 		);
 	}
 
 	public JavaType(Class<?> theClass) {
 		this.name = theClass.getName();
 		this.classReference = new ValueHolder<Class<?>>( theClass );
 	}
 
 	public String getName() {
 		return name;
 	}
 
 	public Class<?> getClassReference() {
 		return classReference.getValue();
 	}
 
 	@Override
 	public String toString() {
 		return new StringBuilder( super.toString() )
 				.append( "[name=" ).append( name ).append( "]" )
 				.toString();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Type.java b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Type.java
index dac9779b6a..58d0f9592a 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Type.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/domain/Type.java
@@ -1,64 +1,64 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.domain;
 
 import org.hibernate.internal.util.ValueHolder;
 
 /**
  * Basic information about a Java type, in regards to its role in particular set of mappings.
  *
  * @author Steve Ebersole
  */
 public interface Type {
 	/**
 	 * Obtain the name of the type.
 	 *
 	 * @return The name
 	 */
 	public String getName();
 
 	/**
 	 * Obtain the java class name for this type.
 	 *
 	 * @return The class name
 	 */
 	public String getClassName();
 
 	/**
 	 * Obtain the java {@link Class} reference for this type
 	 *
 	 * @return The {@link Class} reference
 	 *
-	 * @throws org.hibernate.service.classloading.spi.ClassLoadingException Indicates the class reference
+	 * @throws org.hibernate.boot.registry.classloading.spi.ClassLoadingException Indicates the class reference
 	 * could not be determined.  Generally this is the case in reverse-engineering scenarios where the specified
 	 * domain model classes do not yet exist.
 	 */
 	public Class<?> getClassReference();
 
 	public ValueHolder<Class<?>> getClassReferenceUnresolved();
 
 	public boolean isAssociation();
 
 	public boolean isComponent();
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationBindingContextImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationBindingContextImpl.java
index b3aa93d03c..27642a5be2 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationBindingContextImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationBindingContextImpl.java
@@ -1,161 +1,161 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations;
 
 import java.util.HashMap;
 import java.util.Map;
 
 import com.fasterxml.classmate.MemberResolver;
 import com.fasterxml.classmate.ResolvedType;
 import com.fasterxml.classmate.ResolvedTypeWithMembers;
 import com.fasterxml.classmate.TypeResolver;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.internal.util.ValueHolder;
 import org.hibernate.metamodel.domain.Type;
 import org.hibernate.metamodel.source.MappingDefaults;
 import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 /**
  * @author Steve Ebersole
  */
 public class AnnotationBindingContextImpl implements AnnotationBindingContext {
 	private final MetadataImplementor metadata;
 	private final ValueHolder<ClassLoaderService> classLoaderService;
 	private final Index index;
 	private final TypeResolver typeResolver = new TypeResolver();
 	private final Map<Class<?>, ResolvedType> resolvedTypeCache = new HashMap<Class<?>, ResolvedType>();
 
 	public AnnotationBindingContextImpl(MetadataImplementor metadata, Index index) {
 		this.metadata = metadata;
 		this.classLoaderService = new ValueHolder<ClassLoaderService>(
 				new ValueHolder.DeferredInitializer<ClassLoaderService>() {
 					@Override
 					public ClassLoaderService initialize() {
 						return AnnotationBindingContextImpl.this.metadata
 								.getServiceRegistry()
 								.getService( ClassLoaderService.class );
 					}
 				}
 		);
 		this.index = index;
 	}
 
 	@Override
 	public Index getIndex() {
 		return index;
 	}
 
 	@Override
 	public ClassInfo getClassInfo(String name) {
 		DotName dotName = DotName.createSimple( name );
 		return index.getClassByName( dotName );
 	}
 
 	@Override
 	public void resolveAllTypes(String className) {
 		// the resolved type for the top level class in the hierarchy
 		Class<?> clazz = classLoaderService.getValue().classForName( className );
 		ResolvedType resolvedType = typeResolver.resolve( clazz );
 		while ( resolvedType != null ) {
 			// todo - check whether there is already something in the map
 			resolvedTypeCache.put( clazz, resolvedType );
 			resolvedType = resolvedType.getParentClass();
 			if ( resolvedType != null ) {
 				clazz = resolvedType.getErasedType();
 			}
 		}
 	}
 
 	@Override
 	public ResolvedType getResolvedType(Class<?> clazz) {
 		// todo - error handling
 		return resolvedTypeCache.get( clazz );
 	}
 
 	@Override
 	public ResolvedTypeWithMembers resolveMemberTypes(ResolvedType type) {
 		// todo : is there a reason we create this resolver every time?
 		MemberResolver memberResolver = new MemberResolver( typeResolver );
 		return memberResolver.resolve( type, null, null );
 	}
 
 	@Override
 	public ServiceRegistry getServiceRegistry() {
 		return getMetadataImplementor().getServiceRegistry();
 	}
 
 	@Override
 	public NamingStrategy getNamingStrategy() {
 		return metadata.getNamingStrategy();
 	}
 
 	@Override
 	public MappingDefaults getMappingDefaults() {
 		return metadata.getMappingDefaults();
 	}
 
 	@Override
 	public MetadataImplementor getMetadataImplementor() {
 		return metadata;
 	}
 
 	@Override
 	public <T> Class<T> locateClassByName(String name) {
 		return classLoaderService.getValue().classForName( name );
 	}
 
 	private Map<String, Type> nameToJavaTypeMap = new HashMap<String, Type>();
 
 	@Override
 	public Type makeJavaType(String className) {
 		Type javaType = nameToJavaTypeMap.get( className );
 		if ( javaType == null ) {
 			javaType = metadata.makeJavaType( className );
 			nameToJavaTypeMap.put( className, javaType );
 		}
 		return javaType;
 	}
 
 	@Override
 	public ValueHolder<Class<?>> makeClassReference(String className) {
 		return new ValueHolder<Class<?>>( locateClassByName( className ) );
 	}
 
 	@Override
 	public String qualifyClassName(String name) {
 		return name;
 	}
 
 	@Override
 	public boolean isGloballyQuotedIdentifiers() {
 		return metadata.isGloballyQuotedIdentifiers();
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationMetadataSourceProcessorImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationMetadataSourceProcessorImpl.java
index 5b4855d352..c945491589 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationMetadataSourceProcessorImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/AnnotationMetadataSourceProcessorImpl.java
@@ -1,167 +1,167 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Set;
 
 import org.jboss.jandex.Index;
 import org.jboss.jandex.Indexer;
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
 import org.hibernate.internal.jaxb.JaxbRoot;
 import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityMappings;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.metamodel.source.MetadataSourceProcessor;
 import org.hibernate.metamodel.source.annotations.global.FetchProfileBinder;
 import org.hibernate.metamodel.source.annotations.global.FilterDefBinder;
 import org.hibernate.metamodel.source.annotations.global.IdGeneratorBinder;
 import org.hibernate.metamodel.source.annotations.global.QueryBinder;
 import org.hibernate.metamodel.source.annotations.global.TableBinder;
 import org.hibernate.metamodel.source.annotations.global.TypeDefBinder;
 import org.hibernate.metamodel.source.annotations.xml.PseudoJpaDotNames;
 import org.hibernate.metamodel.source.annotations.xml.mocker.EntityMappingsMocker;
 import org.hibernate.metamodel.source.binder.Binder;
 import org.hibernate.metamodel.source.binder.EntityHierarchy;
 import org.hibernate.metamodel.source.internal.MetadataImpl;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 /**
  * Main class responsible to creating and binding the Hibernate meta-model from annotations.
  * This binder only has to deal with the (jandex) annotation index/repository. XML configuration is already processed
  * and pseudo annotations are created.
  *
  * @author Hardy Ferentschik
  * @author Steve Ebersole
  */
 public class AnnotationMetadataSourceProcessorImpl implements MetadataSourceProcessor {
 	private static final Logger LOG = Logger.getLogger( AnnotationMetadataSourceProcessorImpl.class );
 
 	private final MetadataImplementor metadata;
 	private AnnotationBindingContext bindingContext;
 
 	public AnnotationMetadataSourceProcessorImpl(MetadataImpl metadata) {
 		this.metadata = metadata;
 	}
 
 	@Override
 	@SuppressWarnings( { "unchecked" })
 	public void prepare(MetadataSources sources) {
 		// create a jandex index from the annotated classes
 		Indexer indexer = new Indexer();
 		for ( Class<?> clazz : sources.getAnnotatedClasses() ) {
 			indexClass( indexer, clazz.getName().replace( '.', '/' ) + ".class" );
 		}
 
 		// add package-info from the configured packages
 		for ( String packageName : sources.getAnnotatedPackages() ) {
 			indexClass( indexer, packageName.replace( '.', '/' ) + "/package-info.class" );
 		}
 
 		Index index = indexer.complete();
 
 		List<JaxbRoot<JaxbEntityMappings>> mappings = new ArrayList<JaxbRoot<JaxbEntityMappings>>();
 		for ( JaxbRoot<?> root : sources.getJaxbRootList() ) {
 			if ( root.getRoot() instanceof JaxbEntityMappings ) {
 				mappings.add( (JaxbRoot<JaxbEntityMappings>) root );
 			}
 		}
 		if ( !mappings.isEmpty() ) {
 			index = parseAndUpdateIndex( mappings, index );
 		}
 
 		if ( index.getAnnotations( PseudoJpaDotNames.DEFAULT_DELIMITED_IDENTIFIERS ) != null ) {
 			// todo : this needs to move to AnnotationBindingContext
 			// what happens right now is that specifying this in an orm.xml causes it to effect all orm.xmls
 			metadata.setGloballyQuotedIdentifiers( true );
 		}
 		bindingContext = new AnnotationBindingContextImpl( metadata, index );
 	}
 
 	@Override
 	public void processIndependentMetadata(MetadataSources sources) {
 		assertBindingContextExists();
 		TypeDefBinder.bind( bindingContext );
 	}
 
 	private void assertBindingContextExists() {
 		if ( bindingContext == null ) {
 			throw new AssertionFailure( "The binding context should exist. Has prepare been called!?" );
 		}
 	}
 
 	@Override
 	public void processTypeDependentMetadata(MetadataSources sources) {
 		assertBindingContextExists();
 		IdGeneratorBinder.bind( bindingContext );
 	}
 
 	@Override
 	public void processMappingMetadata(MetadataSources sources, List<String> processedEntityNames) {
 		assertBindingContextExists();
 		// need to order our annotated entities into an order we can process
 		Set<EntityHierarchy> hierarchies = EntityHierarchyBuilder.createEntityHierarchies( bindingContext );
 
 		Binder binder = new Binder( bindingContext.getMetadataImplementor(), new ArrayList<String>() );
 		for ( EntityHierarchy hierarchy : hierarchies ) {
 			binder.processEntityHierarchy( hierarchy );
 		}
 	}
 
 	@Override
 	public void processMappingDependentMetadata(MetadataSources sources) {
 		TableBinder.bind( bindingContext );
 		FetchProfileBinder.bind( bindingContext );
 		QueryBinder.bind( bindingContext );
 		FilterDefBinder.bind( bindingContext );
 	}
 
 	private Index parseAndUpdateIndex(List<JaxbRoot<JaxbEntityMappings>> mappings, Index annotationIndex) {
 		List<JaxbEntityMappings> list = new ArrayList<JaxbEntityMappings>( mappings.size() );
 		for ( JaxbRoot<JaxbEntityMappings> jaxbRoot : mappings ) {
 			list.add( jaxbRoot.getRoot() );
 		}
 		return new EntityMappingsMocker( list, annotationIndex, metadata.getServiceRegistry() ).mockNewIndex();
 	}
 
 	private void indexClass(Indexer indexer, String className) {
 		InputStream stream = metadata.getServiceRegistry().getService( ClassLoaderService.class ).locateResourceStream(
 				className
 		);
 		try {
 			indexer.index( stream );
 		}
 		catch ( IOException e ) {
 			throw new HibernateException( "Unable to open input stream for class " + className, e );
 		}
 	}
 }
 
 
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JandexHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JandexHelper.java
index 6f7eca24a6..fd527435b7 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JandexHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/JandexHelper.java
@@ -1,363 +1,363 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations;
 
 import java.beans.Introspector;
 import java.io.IOException;
 import java.io.InputStream;
 import java.lang.reflect.Array;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.FieldInfo;
 import org.jboss.jandex.Index;
 import org.jboss.jandex.Indexer;
 import org.jboss.jandex.MethodInfo;
 import org.jboss.jandex.Type;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.HibernateException;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 /**
  * Utility methods for working with the jandex annotation index.
  *
  * @author Hardy Ferentschik
  */
 public class JandexHelper {
 	private static final Map<String, Object> DEFAULT_VALUES_BY_ELEMENT = new HashMap<String, Object>();
 
 	private JandexHelper() {
 	}
 
 	/**
 	 * Retrieves a jandex annotation element value. If the value is {@code null}, the default value specified in the
 	 * annotation class is retrieved instead.
 	 * <p>
 	 * There are two special cases. {@code Class} parameters should be retrieved as strings (and then can later be
 	 * loaded) and enumerated values should be retrieved via {@link #getEnumValue(AnnotationInstance, String, Class)}.
 	 * </p>
 	 *
 	 * @param annotation the annotation containing the element with the supplied name
 	 * @param element the name of the element value to be retrieve
 	 * @param type the type of element to retrieve. The following types are supported:
 	 * <ul>
 	 * <li>Byte</li>
 	 * <li>Short</li>
 	 * <li>Integer</li>
 	 * <li>Character</li>
 	 * <li>Float</li>
 	 * <li>Double</li>
 	 * <li>Long</li>
 	 * <li>Boolean</li>
 	 * <li>String</li>
 	 * <li>AnnotationInstance</li>
 	 *
 	 * @return the value if not {@code null}, else the default value if not
 	 *         {@code null}, else {@code null}.
 	 *
 	 * @throws AssertionFailure in case the specified {@code type} is a class instance or the specified type causes a {@code ClassCastException}
 	 * when retrieving the value.
 	 */
 	@SuppressWarnings("unchecked")
 	public static <T> T getValue(AnnotationInstance annotation, String element, Class<T> type) throws AssertionFailure {
 		if ( Class.class.equals( type ) ) {
 			throw new AssertionFailure(
 					"Annotation parameters of type Class should be retrieved as strings (fully qualified class names)"
 			);
 		}
 
 		// try getting the untyped value from Jandex
 		AnnotationValue annotationValue = annotation.value( element );
 
 		try {
 			if ( annotationValue != null ) {
 				return explicitAnnotationParameter( annotationValue, type );
 			}
 			else {
 				return defaultAnnotationParameter( getDefaultValue( annotation, element ), type );
 			}
 		}
 		catch ( ClassCastException e ) {
 			throw new AssertionFailure(
 					String.format(
 							"the annotation property %s of annotation %s is not of type %s",
 							element,
 							annotation.name(),
 							type.getName()
 					)
 			);
 		}
 	}
 
 	/**
 	 * Retrieves a jandex annotation element value, converting it to the supplied enumerated type.  If the value is
 	 * <code>null</code>, the default value specified in the annotation class is retrieved instead.
 	 *
 	 * @param <T> an enumerated type
 	 * @param annotation the annotation containing the enumerated element with the supplied name
 	 * @param element the name of the enumerated element value to be retrieve
 	 * @param type the type to which to convert the value before being returned
 	 *
 	 * @return the value converted to the supplied enumerated type if the value is not <code>null</code>, else the default value if
 	 *         not <code>null</code>, else <code>null</code>.
 	 *
 	 * @see #getValue(AnnotationInstance, String, Class)
 	 */
 	@SuppressWarnings("unchecked")
 	public static <T extends Enum<T>> T getEnumValue(AnnotationInstance annotation, String element, Class<T> type) {
 		AnnotationValue val = annotation.value( element );
 		if ( val == null ) {
 			return (T) getDefaultValue( annotation, element );
 		}
 		return Enum.valueOf( type, val.asEnum() );
 	}
 
 	/**
 	 * Expects a method or field annotation target and returns the property name for this target
 	 *
 	 * @param target the annotation target
 	 *
 	 * @return the property name of the target. For a field it is the field name and for a method name it is
 	 *         the method name stripped of 'is', 'has' or 'get'
 	 */
 	public static String getPropertyName(AnnotationTarget target) {
 		if ( !( target instanceof MethodInfo || target instanceof FieldInfo ) ) {
 			throw new AssertionFailure( "Unexpected annotation target " + target.toString() );
 		}
 
 		if ( target instanceof FieldInfo ) {
 			return ( (FieldInfo) target ).name();
 		}
 		else {
 			final String methodName = ( (MethodInfo) target ).name();
 			String propertyName;
 			if ( methodName.startsWith( "is" ) ) {
 				propertyName = Introspector.decapitalize( methodName.substring( 2 ) );
 			}
 			else if ( methodName.startsWith( "has" ) ) {
 				propertyName = Introspector.decapitalize( methodName.substring( 3 ) );
 			}
 			else if ( methodName.startsWith( "get" ) ) {
 				propertyName = Introspector.decapitalize( methodName.substring( 3 ) );
 			}
 			else {
 				throw new AssertionFailure( "Expected a method following the Java Bean notation" );
 			}
 			return propertyName;
 		}
 	}
 
 	/**
 	 * @param classInfo the class info from which to retrieve the annotation instance
 	 * @param annotationName the annotation to retrieve from the class info
 	 *
 	 * @return the single annotation defined on the class or {@code null} in case the annotation is not specified at all
 	 *
 	 * @throws org.hibernate.AssertionFailure in case there is there is more than one annotation of this type.
 	 */
 	public static AnnotationInstance getSingleAnnotation(ClassInfo classInfo, DotName annotationName)
 			throws AssertionFailure {
 		return getSingleAnnotation( classInfo.annotations(), annotationName );
 	}
 
 	/**
 	 * @param annotations List of annotation instances keyed against their dot name.
 	 * @param annotationName the annotation to retrieve from map
 	 *
 	 * @return the single annotation of the specified dot name or {@code null} in case the annotation is not specified at all
 	 *
 	 * @throws org.hibernate.AssertionFailure in case there is there is more than one annotation of this type.
 	 */
 	public static AnnotationInstance getSingleAnnotation(Map<DotName, List<AnnotationInstance>> annotations, DotName annotationName)
 			throws AssertionFailure {
 		List<AnnotationInstance> annotationList = annotations.get( annotationName );
 		if ( annotationList == null ) {
 			return null;
 		}
 		else if ( annotationList.size() == 1 ) {
 			return annotationList.get( 0 );
 		}
 		else {
 			throw new AssertionFailure(
 					"Found more than one instance of the annotation "
 							+ annotationList.get( 0 ).name().toString()
 							+ ". Expected was one."
 			);
 		}
 	}
 
 	/**
 	 * @param annotations List of annotation instances keyed against their dot name.
 	 * @param annotationName the annotation to check
 	 *
 	 * @return returns {@code true} if the map contains only a single instance of specified annotation or {@code false} otherwise.
 	 *
 	 * @throws org.hibernate.AssertionFailure in case there is there is more than one annotation of this type.
 	 */
 	public static boolean containsSingleAnnotations(Map<DotName, List<AnnotationInstance>> annotations, DotName annotationName)
 			throws AssertionFailure {
 		return getSingleAnnotation( annotations, annotationName ) != null;
 	}
 
 	/**
 	 * Creates a jandex index for the specified classes
 	 *
 	 * @param classLoaderService class loader service
 	 * @param classes the classes to index
 	 *
 	 * @return an annotation repository w/ all the annotation discovered in the specified classes
 	 */
 	public static Index indexForClass(ClassLoaderService classLoaderService, Class<?>... classes) {
 		Indexer indexer = new Indexer();
 		for ( Class<?> clazz : classes ) {
 			InputStream stream = classLoaderService.locateResourceStream(
 					clazz.getName().replace( '.', '/' ) + ".class"
 			);
 			try {
 				indexer.index( stream );
 			}
 			catch ( IOException e ) {
 				StringBuilder builder = new StringBuilder();
 				builder.append( "[" );
 				int count = 0;
 				for ( Class<?> c : classes ) {
 					builder.append( c.getName() );
 					if ( count < classes.length - 1 ) {
 						builder.append( "," );
 					}
 					count++;
 				}
 				builder.append( "]" );
 				throw new HibernateException( "Unable to create annotation index for " + builder.toString() );
 			}
 		}
 		return indexer.complete();
 	}
 
 	public static Map<DotName, List<AnnotationInstance>> getMemberAnnotations(ClassInfo classInfo, String name) {
 		if ( classInfo == null ) {
 			throw new IllegalArgumentException( "classInfo cannot be null" );
 		}
 
 		if ( name == null ) {
 			throw new IllegalArgumentException( "name cannot be null" );
 		}
 
 		Map<DotName, List<AnnotationInstance>> annotations = new HashMap<DotName, List<AnnotationInstance>>();
 		for ( List<AnnotationInstance> annotationList : classInfo.annotations().values() ) {
 			for ( AnnotationInstance instance : annotationList ) {
 				String targetName = null;
 				if ( instance.target() instanceof FieldInfo ) {
 					targetName = ( (FieldInfo) instance.target() ).name();
 				}
 				else if ( instance.target() instanceof MethodInfo ) {
 					targetName = ( (MethodInfo) instance.target() ).name();
 				}
 				if ( targetName != null && name.equals( targetName ) ) {
 					addAnnotationToMap( instance, annotations );
 				}
 			}
 		}
 		return annotations;
 	}
 
 	private static void addAnnotationToMap(AnnotationInstance instance, Map<DotName, List<AnnotationInstance>> annotations) {
 		DotName dotName = instance.name();
 		List<AnnotationInstance> list;
 		if ( annotations.containsKey( dotName ) ) {
 			list = annotations.get( dotName );
 		}
 		else {
 			list = new ArrayList<AnnotationInstance>();
 			annotations.put( dotName, list );
 		}
 		list.add( instance );
 	}
 
 	private static Object getDefaultValue(AnnotationInstance annotation, String element) {
 		String name = annotation.name().toString();
 		String fqElement = name + '.' + element;
 		Object val = DEFAULT_VALUES_BY_ELEMENT.get( fqElement );
 		if ( val != null ) {
 			return val;
 		}
 		try {
 			val = Index.class.getClassLoader().loadClass( name ).getMethod( element ).getDefaultValue();
 			DEFAULT_VALUES_BY_ELEMENT.put( fqElement, val );
 			return val == null ? null : val;
 		}
 		catch ( RuntimeException error ) {
 			throw error;
 		}
 		catch ( Exception error ) {
 			throw new AssertionFailure(
 					String.format( "The annotation %s does not define a parameter '%s'", name, element ),
 					error
 			);
 		}
 	}
 
 	private static <T> T defaultAnnotationParameter(Object defaultValue, Class<T> type) {
 		Object returnValue = defaultValue;
 
 		// resolve some mismatches between what's stored in jandex and what the defaults are for annotations
 		// in case of nested annotation arrays, jandex returns arrays of AnnotationInstances, hence we return
 		// an empty array of this type here
 		if ( defaultValue.getClass().isArray() && defaultValue.getClass().getComponentType().isAnnotation() ) {
 			returnValue = new AnnotationInstance[0];
 		}
 		return type.cast( returnValue );
 	}
 
 	private static <T> T explicitAnnotationParameter(AnnotationValue annotationValue, Class<T> type) {
 		Object returnValue = annotationValue.value();
 
 		// if the jandex return type is Type we actually try to retrieve a class parameter
 		// for our purposes we just return the fqcn of the class
 		if ( returnValue instanceof Type ) {
 			returnValue = ( (Type) returnValue ).name().toString();
 		}
 
 		// arrays we have to handle explicitly
 		if ( type.isArray() ) {
 			AnnotationValue[] values = (AnnotationValue[]) returnValue;
 			Class<?> componentType = type.getComponentType();
 			Object[] arr = (Object[]) Array.newInstance( componentType, values.length );
 			for ( int i = 0; i < values.length; i++ ) {
 				arr[i] = componentType.cast( values[i].value() );
 			}
 			returnValue = arr;
 		}
 
 		return type.cast( returnValue );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilder.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilder.java
index 6440ddf1b1..1266eb1ad4 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/IndexBuilder.java
@@ -1,307 +1,307 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.metamodel.source.annotations.xml.filter.IndexedAnnotationFilter;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 /**
  * @author Strong Liu
  */
 public class IndexBuilder {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			IndexBuilder.class.getName()
 	);
 	private Map<DotName, List<AnnotationInstance>> annotations;
 	private Map<DotName, List<ClassInfo>> subclasses;
 	private Map<DotName, List<ClassInfo>> implementors;
 	private Map<DotName, ClassInfo> classes;
 	private Index index;
 	private Map<DotName, Map<DotName, List<AnnotationInstance>>> classInfoAnnotationsMap;
 	private Map<DotName, Map<DotName, List<AnnotationInstance>>> indexedClassInfoAnnotationsMap;
 	private ServiceRegistry serviceRegistry;
 
 	IndexBuilder(Index index, ServiceRegistry serviceRegistry) {
 		this.index = index;
 		this.serviceRegistry = serviceRegistry;
 		this.annotations = new HashMap<DotName, List<AnnotationInstance>>();
 		this.subclasses = new HashMap<DotName, List<ClassInfo>>();
 		this.implementors = new HashMap<DotName, List<ClassInfo>>();
 		this.classes = new HashMap<DotName, ClassInfo>();
 		this.classInfoAnnotationsMap = new HashMap<DotName, Map<DotName, List<AnnotationInstance>>>();
 		this.indexedClassInfoAnnotationsMap = new HashMap<DotName, Map<DotName, List<AnnotationInstance>>>();
 	}
 
 	/**
 	 * Build new {@link Index} with mocked annotations from orm.xml.
 	 * This method should be only called once per {@org.hibernate.metamodel.source.annotations.xml.mocker.IndexBuilder IndexBuilder} instance.
 	 *
 	 * @param globalDefaults Global defaults from <persistence-unit-metadata>, or null.
 	 *
 	 * @return Index.
 	 */
 	Index build(EntityMappingsMocker.Default globalDefaults) {
 		//merge annotations that not overrided by xml into the new Index
 		for ( ClassInfo ci : index.getKnownClasses() ) {
 			DotName name = ci.name();
 			if ( indexedClassInfoAnnotationsMap.containsKey( name ) ) {
 				//this class has been overrided by orm.xml
 				continue;
 			}
 			if ( ci.annotations() != null && !ci.annotations().isEmpty() ) {
 				Map<DotName, List<AnnotationInstance>> tmp = new HashMap<DotName, List<AnnotationInstance>>( ci.annotations() );
 				DefaultConfigurationHelper.INSTANCE.applyDefaults( tmp, globalDefaults );
 				mergeAnnotationMap( tmp, annotations );
 				classes.put( name, ci );
 				if ( ci.superName() != null ) {
 					addSubClasses( ci.superName(), ci );
 				}
 				if ( ci.interfaces() != null && ci.interfaces().length > 0 ) {
 					addImplementors( ci.interfaces(), ci );
 				}
 			}
 		}
 		return Index.create(
 				annotations, subclasses, implementors, classes
 		);
 	}
 	Map<DotName, List<AnnotationInstance>> getAnnotations(){
 		return Collections.unmodifiableMap( annotations );
 	}
 	/**
 	 * If {@code xml-mapping-metadata-complete} is defined in PersistenceUnitMetadata, we create a new empty {@link Index} here.
 	 */
 	void mappingMetadataComplete() {
 		LOG.debug(
 				"xml-mapping-metadata-complete is specified in persistence-unit-metadata, ignore JPA annotations."
 		);
 		index = Index.create(
 				new HashMap<DotName, List<AnnotationInstance>>(),
 				new HashMap<DotName, List<ClassInfo>>(),
 				new HashMap<DotName, List<ClassInfo>>(),
 				new HashMap<DotName, ClassInfo>()
 		);
 	}
 
 	/**
 	 * @param name Entity Object dot name which is being process.
 	 */
 	void metadataComplete(DotName name) {
 		LOG.debug(
 				"metadata-complete is specified in " + name + ", ignore JPA annotations."
 		);
 		getIndexedAnnotations( name ).clear();
 	}
 
 	public Map<DotName, List<AnnotationInstance>> getIndexedAnnotations(DotName name) {
 		Map<DotName, List<AnnotationInstance>> map = indexedClassInfoAnnotationsMap.get( name );
 		if ( map == null ) {
 			ClassInfo ci = index.getClassByName( name );
 			if ( ci == null || ci.annotations() == null ) {
 				map = Collections.emptyMap();
 			}
 			else {
 				map = new HashMap<DotName, List<AnnotationInstance>>( ci.annotations() );
 				//here we ignore global annotations
 				for ( DotName globalAnnotationName : DefaultConfigurationHelper.GLOBAL_ANNOTATIONS ) {
 					if ( map.containsKey( globalAnnotationName ) ) {
 						map.put( globalAnnotationName, Collections.<AnnotationInstance>emptyList() );
 					}
 				}
 			}
 			indexedClassInfoAnnotationsMap.put( name, map );
 		}
 		return map;
 	}
 
 	public Map<DotName, List<AnnotationInstance>> getClassInfoAnnotationsMap(DotName name) {
 		return classInfoAnnotationsMap.get( name );
 	}
 
 	public ClassInfo getClassInfo(DotName name) {
 		return classes.get( name );
 	}
 
 	public ClassInfo getIndexedClassInfo(DotName name) {
 		return index.getClassByName( name );
 	}
 
 	void collectGlobalConfigurationFromIndex(GlobalAnnotations globalAnnotations) {
 		for ( DotName annName : DefaultConfigurationHelper.GLOBAL_ANNOTATIONS ) {
 			List<AnnotationInstance> annotationInstanceList = index.getAnnotations( annName );
 			if ( MockHelper.isNotEmpty( annotationInstanceList ) ) {
 				globalAnnotations.addIndexedAnnotationInstance( annotationInstanceList );
 			}
 		}
 		globalAnnotations.filterIndexedAnnotations();
 	}
 
 	void finishGlobalConfigurationMocking(GlobalAnnotations globalAnnotations) {
 		annotations.putAll( globalAnnotations.getAnnotationInstanceMap() );
 	}
 
 	void finishEntityObject(final DotName name, final EntityMappingsMocker.Default defaults) {
 		Map<DotName, List<AnnotationInstance>> map = classInfoAnnotationsMap.get( name );
 		if ( map == null ) {
 			throw new AssertionFailure( "Calling finish entity object " + name + " before create it." );
 		}
 		// annotations classes overrided by xml
 		if ( indexedClassInfoAnnotationsMap.containsKey( name ) ) {
 			Map<DotName, List<AnnotationInstance>> tmp = getIndexedAnnotations( name );
 			mergeAnnotationMap( tmp, map );
 		}
 		DefaultConfigurationHelper.INSTANCE.applyDefaults( map, defaults );
 		
 		mergeAnnotationMap( map, annotations );
 	}
 
 
 	void addAnnotationInstance(DotName targetClassName, AnnotationInstance annotationInstance) {
 		if ( annotationInstance == null ) {
 			return;
 		}
 		for ( IndexedAnnotationFilter indexedAnnotationFilter : IndexedAnnotationFilter.ALL_FILTERS ) {
 			indexedAnnotationFilter.beforePush( this, targetClassName, annotationInstance );
 		}
 		Map<DotName, List<AnnotationInstance>> map = classInfoAnnotationsMap.get( targetClassName );
 		if ( map == null ) {
 			throw new AssertionFailure( "Can't find " + targetClassName + " in internal cache, should call createClassInfo first" );
 		}
 
 		List<AnnotationInstance> annotationInstanceList = map.get( annotationInstance.name() );
 		if ( annotationInstanceList == null ) {
 			annotationInstanceList = new ArrayList<AnnotationInstance>();
 			map.put( annotationInstance.name(), annotationInstanceList );
 		}
 		annotationInstanceList.add( annotationInstance );
 	}
 
 	ServiceRegistry getServiceRegistry() {
 		return serviceRegistry;
 	}
 
 	ClassInfo createClassInfo(String className) {
 		if ( StringHelper.isEmpty( className ) ) {
 			throw new AssertionFailure( "Class Name used to create ClassInfo is empty." );
 		}
 		DotName classDotName = DotName.createSimple( className );
 		if ( classes.containsKey( classDotName ) ) {
 			//classInfoAnnotationsMap.put( classDotName, new HashMap<DotName, List<AnnotationInstance>>(classes.get( classDotName ).annotations()) );
 			return classes.get( classDotName );
 		}
 		Class clazz = serviceRegistry.getService( ClassLoaderService.class ).classForName( className );
 		DotName superName = null;
 		DotName[] interfaces = null;
 		short access_flag;
 		ClassInfo annClassInfo = index.getClassByName( classDotName );
 		if ( annClassInfo != null ) {
 			superName = annClassInfo.superName();
 			interfaces = annClassInfo.interfaces();
 			access_flag = annClassInfo.flags();
 		}
 		else {
 			Class superClass = clazz.getSuperclass();
 			if ( superClass != null ) {
 				superName = DotName.createSimple( superClass.getName() );
 			}
 			Class[] classInterfaces = clazz.getInterfaces();
 			if ( classInterfaces != null && classInterfaces.length > 0 ) {
 				interfaces = new DotName[classInterfaces.length];
 				for ( int i = 0; i < classInterfaces.length; i++ ) {
 					interfaces[i] = DotName.createSimple( classInterfaces[i].getName() );
 				}
 			}
 			access_flag = (short) ( clazz.getModifiers() | 0x20 );//(modifiers | ACC_SUPER)
 		}
 		Map<DotName, List<AnnotationInstance>> map = new HashMap<DotName, List<AnnotationInstance>>();
 		classInfoAnnotationsMap.put( classDotName, map );
 		ClassInfo classInfo = ClassInfo.create(
 				classDotName, superName, access_flag, interfaces, map
 		);
 		classes.put( classDotName, classInfo );
 		addSubClasses( superName, classInfo );
 		addImplementors( interfaces, classInfo );
 		return classInfo;
 	}
 
 	private void addSubClasses(DotName superClassDotName, ClassInfo classInfo) {
 		if ( superClassDotName != null ) {
 			List<ClassInfo> classInfoList = subclasses.get( superClassDotName );
 			if ( classInfoList == null ) {
 				classInfoList = new ArrayList<ClassInfo>();
 				subclasses.put( superClassDotName, classInfoList );
 			}
 			classInfoList.add( classInfo );
 		}
 	}
 
 	private void addImplementors(DotName[] dotNames, ClassInfo classInfo) {
 		if ( dotNames != null && dotNames.length > 0 ) {
 			for ( DotName dotName : dotNames ) {
 				List<ClassInfo> classInfoList = implementors.get( dotName );
 				if ( classInfoList == null ) {
 					classInfoList = new ArrayList<ClassInfo>();
 					implementors.put( dotName, classInfoList );
 				}
 				classInfoList.add( classInfo );
 			}
 		}
 	}
 
 	//merge source into target
 	private void mergeAnnotationMap(Map<DotName, List<AnnotationInstance>> source, Map<DotName, List<AnnotationInstance>> target) {
 		if ( source != null ) {
 			for ( Map.Entry<DotName, List<AnnotationInstance>> el : source.entrySet() ) {
 				if ( el.getValue().isEmpty() ) {
 					continue;
 				}
 				DotName annotationName = el.getKey();
 				List<AnnotationInstance> value = el.getValue();
 				List<AnnotationInstance> annotationInstanceList = target.get( annotationName );
 				if ( annotationInstanceList == null ) {
 					annotationInstanceList = new ArrayList<AnnotationInstance>();
 					target.put( annotationName, annotationInstanceList );
 				}
 				annotationInstanceList.addAll( value );
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MockHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MockHelper.java
index b8f15c67b6..c608100712 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MockHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/annotations/xml/mocker/MockHelper.java
@@ -1,471 +1,471 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.beans.Introspector;
 import java.lang.reflect.Field;
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.List;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationTarget;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.FieldInfo;
 import org.jboss.jandex.MethodInfo;
 import org.jboss.jandex.Type;
 
 import org.hibernate.HibernateException;
 import org.hibernate.internal.jaxb.mapping.orm.JaxbCascadeType;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.metamodel.source.annotations.JPADotNames;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 /**
  * @author Strong Liu
  */
 public class MockHelper {
 
 	static final AnnotationValue[] EMPTY_ANNOTATION_VALUE_ARRAY = new AnnotationValue[0];
 	static final Type[] EMPTY_TYPE_ARRAY = new Type[0];
 
 	/**
 	 * util method for String Array attribute Annotation
 	 *
 	 * @param name
 	 * @param values
 	 * @param annotationValueList
 	 */
 	static void stringArrayValue(String name, List<String> values, List<AnnotationValue> annotationValueList) {
 		if ( isNotEmpty( values ) ) {
 			AnnotationValue[] annotationValues = new AnnotationValue[values.size()];
 			for ( int j = 0; j < values.size(); j++ ) {
 				annotationValues[j] = stringValue( "", values.get( j ) );
 			}
 			annotationValueList.add(
 					AnnotationValue.createArrayValue(
 							name, annotationValues
 					)
 			);
 		}
 	}
 
 	/**
 	 * util method for single string attribute Annotation only
 	 */
 	static AnnotationValue[] stringValueArray(String name, String value) {
 		return nullSafe( stringValue( name, value ) );
 	}
 
 	private static AnnotationValue stringValue(String name, String value) {
 		if ( StringHelper.isNotEmpty( value ) ) {
 			return AnnotationValue.createStringValue( name, value );
 		}
 		return null;
 	}
 
 	static void stringValue(String name, String value, List<AnnotationValue> annotationValueList) {
 		addToCollectionIfNotNull( annotationValueList, stringValue( name, value ) );
 	}
 
 	private static AnnotationValue integerValue(String name, Integer value) {
 		if ( value == null ) {
 			return null;
 		}
 		return AnnotationValue.createIntegerValue( name, value );
 	}
 
 	static void integerValue(String name, Integer value, List<AnnotationValue> annotationValueList) {
 		addToCollectionIfNotNull( annotationValueList, integerValue( name, value ) );
 	}
 
 	static AnnotationValue[] booleanValueArray(String name, Boolean value) {
 		return nullSafe( booleanValue( name, value ) );
 	}
 
 	static void booleanValue(String name, Boolean value, List<AnnotationValue> annotationValueList) {
 		addToCollectionIfNotNull( annotationValueList, booleanValue( name, value ) );
 	}
 
 	private static AnnotationValue booleanValue(String name, Boolean value) {
 		if ( value == null ) {
 			return null;
 		}
 		return AnnotationValue.createBooleanValue( name, value );
 	}
 
 	private static AnnotationValue classValue(String name, String className, ServiceRegistry serviceRegistry) {
 		if ( StringHelper.isNotEmpty( className ) ) {
 			return AnnotationValue.createClassValue( name, getType( className, serviceRegistry ) );
 		}
 		return null;
 	}
 
 
 	static void classValue(String name, String className, List<AnnotationValue> list, ServiceRegistry serviceRegistry) {
 		addToCollectionIfNotNull( list, classValue( name, className, serviceRegistry ) );
 	}
 
 	static AnnotationValue[] classValueArray(String name, String className, ServiceRegistry serviceRegistry) {
 		return nullSafe( classValue( name, className, serviceRegistry ) );
 	}
 
 	static AnnotationValue nestedAnnotationValue(String name, AnnotationInstance value) {
 		if ( value == null ) {
 			return null;
 		}
 		return AnnotationValue.createNestedAnnotationValue(
 				name, value
 		);
 	}
 
 	static void nestedAnnotationValue(String name, AnnotationInstance value, List<AnnotationValue> list) {
 		addToCollectionIfNotNull( list, nestedAnnotationValue( name, value ) );
 	}
 
 	private static AnnotationValue[] nullSafe(AnnotationValue value) {
 		return value == null ? EMPTY_ANNOTATION_VALUE_ARRAY : new AnnotationValue[] {
 				value
 		};
 	}
 
 	static void classArrayValue(String name, List<String> classNameList, List<AnnotationValue> list, ServiceRegistry serviceRegistry) {
 		if ( isNotEmpty( classNameList ) ) {
 
 			List<AnnotationValue> clazzValueList = new ArrayList<AnnotationValue>( classNameList.size() );
 			for ( String clazz : classNameList ) {
 				addToCollectionIfNotNull( clazzValueList, classValue( "", clazz, serviceRegistry ) );
 			}
 
 			list.add(
 					AnnotationValue.createArrayValue(
 							name, toArray( clazzValueList )
 					)
 			);
 		}
 	}
 
 	public static AnnotationValue[] toArray(List<AnnotationValue> list) {
 		AnnotationValue[] values = EMPTY_ANNOTATION_VALUE_ARRAY;
 		if ( isNotEmpty( list ) ) {
 			values = list.toArray( new AnnotationValue[list.size()] );
 		}
 		return values;
 	}
 
 	private static AnnotationValue enumValue(String name, DotName typeName, Enum value) {
 		if ( value != null && StringHelper.isNotEmpty( value.toString() ) ) {
 			return AnnotationValue.createEnumValue( name, typeName, value.toString() );
 		}
 		return null;
 	}
 
 	static void cascadeValue(String name, JaxbCascadeType cascadeType, boolean isCascadePersistDefault, List<AnnotationValue> annotationValueList) {
 		List<Enum> enumList = new ArrayList<Enum>();
 		if ( isCascadePersistDefault ) {
 			enumList.add( javax.persistence.CascadeType.PERSIST );
 		}
 		if ( cascadeType != null ) {
 			if ( cascadeType.getCascadeAll() != null ) {
 				enumList.add( javax.persistence.CascadeType.ALL );
 			}
 			if ( cascadeType.getCascadePersist() != null && !isCascadePersistDefault ) {
 				enumList.add( javax.persistence.CascadeType.PERSIST );
 			}
 			if ( cascadeType.getCascadeMerge() != null ) {
 				enumList.add( javax.persistence.CascadeType.MERGE );
 			}
 			if ( cascadeType.getCascadeRemove() != null ) {
 				enumList.add( javax.persistence.CascadeType.REMOVE );
 			}
 			if ( cascadeType.getCascadeRefresh() != null ) {
 				enumList.add( javax.persistence.CascadeType.REFRESH );
 			}
 			if ( cascadeType.getCascadeDetach() != null ) {
 				enumList.add( javax.persistence.CascadeType.DETACH );
 			}
 		}
 		if ( !enumList.isEmpty() ) {
 			MockHelper.enumArrayValue( name, JPADotNames.CASCADE_TYPE, enumList, annotationValueList );
 		}
 	}
 
 	static void enumArrayValue(String name, DotName typeName, List<Enum> valueList, List<AnnotationValue> list) {
 		if ( isNotEmpty( valueList ) ) {
 
 			List<AnnotationValue> enumValueList = new ArrayList<AnnotationValue>( valueList.size() );
 			for ( Enum e : valueList ) {
 				addToCollectionIfNotNull( enumValueList, enumValue( "", typeName, e ) );
 			}
 			list.add(
 					AnnotationValue.createArrayValue(
 							name, toArray( enumValueList )
 					)
 			);
 		}
 	}
 
 	static void enumValue(String name, DotName typeName, Enum value, List<AnnotationValue> list) {
 		addToCollectionIfNotNull( list, enumValue( name, typeName, value ) );
 	}
 
 	static AnnotationValue[] enumValueArray(String name, DotName typeName, Enum value) {
 		return nullSafe( enumValue( name, typeName, value ) );
 	}
 
 	public static void addToCollectionIfNotNull(Collection collection, Object value) {
 		if ( value != null && collection != null ) {
 			collection.add( value );
 		}
 	}
 
 
 	/**
 	 * @param t1 can't be null
 	 * @param t2 can't be null
 	 */
 	public static boolean targetEquals(AnnotationTarget t1, AnnotationTarget t2) {
 		if ( t1 == t2 ) {
 			return true;
 		}
 		if ( t1 != null && t2 != null ) {
 
 			if ( t1.getClass() == t2.getClass() ) {
 				if ( t1.getClass() == ClassInfo.class ) {
 					return ( (ClassInfo) t1 ).name().equals( ( (ClassInfo) t2 ).name() );
 				}
 				else if ( t1.getClass() == MethodInfo.class ) {
 					return ( (MethodInfo) t1 ).name().equals( ( (MethodInfo) t2 ).name() );
 				}
 				else {
 					return ( (FieldInfo) t1 ).name().equals( ( (FieldInfo) t2 ).name() );
 				}
 			}
 		}
 		return false;
 	}
 
 	public static boolean isNotEmpty(Collection collection) {
 		return collection != null && !collection.isEmpty();
 	}
 
 
 	static AnnotationInstance create(DotName name, AnnotationTarget target, List<AnnotationValue> annotationValueList) {
 		return create(
 				name, target, toArray( annotationValueList )
 		);
 
 	}
 
 	static String buildSafeClassName(String className, String defaultPackageName) {
 		if ( className.indexOf( '.' ) < 0 && StringHelper.isNotEmpty( defaultPackageName ) ) {
 			className = StringHelper.qualify( defaultPackageName, className );
 		}
 		return className;
 	}
 
 	static AnnotationInstance create(DotName name, AnnotationTarget target, AnnotationValue[] values) {
 		if ( values == null || values.length == 0 ) {
 			values = EMPTY_ANNOTATION_VALUE_ARRAY;
 		}
 		return AnnotationInstance.create( name, target, addMockMark( values ) );
 	}
 
 	private static AnnotationValue[] addMockMark(AnnotationValue[] values) {
 		AnnotationValue[] newValues = new AnnotationValue[values.length + 1];
 		System.arraycopy( values, 0, newValues, 0, values.length );
 		newValues[values.length] = booleanValue( "isMocked", true );
 		return newValues;
 	}
 
 
 	private static MethodInfo getMethodInfo(ClassInfo classInfo, Method method) {
 		Class returnTypeClass = method.getReturnType();
 		short access_flags = (short) method.getModifiers();
 		return MethodInfo.create(
 				classInfo,
 				method.getName(),
 				getTypes( method.getParameterTypes() ),
 				getType( returnTypeClass ),
 				access_flags
 		);
 	}
 
 	enum TargetType {METHOD, FIELD, PROPERTY}
 
 	static AnnotationTarget getTarget(ServiceRegistry serviceRegistry, ClassInfo classInfo, String name, TargetType type) {
 		Class clazz = serviceRegistry.getService( ClassLoaderService.class ).classForName( classInfo.toString() );
 		switch ( type ) {
 			case FIELD:
 				Field field = getField( clazz, name );
 				if ( field == null ) {
 					throw new HibernateException(
 							"Unable to load field "
 									+ name
 									+ " of class " + clazz.getName()
 					);
 				}
 
 				return FieldInfo.create(
 						classInfo, name, getType( field.getType() ), (short) ( field.getModifiers() )
 				);
 			case METHOD:
 				Method method = getMethod( clazz, name );
 				if ( method == null ) {
 					throw new HibernateException(
 							"Unable to load method "
 									+ name
 									+ " of class " + clazz.getName()
 					);
 				}
 				return getMethodInfo( classInfo, method );
 			case PROPERTY:
 				method = getterMethod( clazz, name );
 				if ( method == null ) {
 					throw new HibernateException(
 							"Unable to load property "
 									+ name
 									+ " of class " + clazz.getName()
 					);
 				}
 				return getMethodInfo( classInfo, method );
 
 		}
 		throw new HibernateException( "" );
 	}
 
 	//copied from org.hibernate.internal.util.ReflectHelper
 	private static Method getterMethod(Class theClass, String propertyName) {
 		Method[] methods = theClass.getDeclaredMethods();
 		Method.setAccessible( methods, true );
 		for ( Method method : methods ) {
 			// if the method has parameters, skip it
 			if ( method.getParameterTypes().length != 0 ) {
 				continue;
 			}
 			// if the method is a "bridge", skip it
 			if ( method.isBridge() ) {
 				continue;
 			}
 
 			final String methodName = method.getName();
 
 			// try "get"
 			if ( methodName.startsWith( "get" ) || methodName.startsWith( "has" ) ) {
 				String testStdMethod = Introspector.decapitalize( methodName.substring( 3 ) );
 				String testOldMethod = methodName.substring( 3 );
 				if ( testStdMethod.equals( propertyName ) || testOldMethod.equals( propertyName ) ) {
 					return method;
 				}
 			}
 
 			// if not "get", then try "is"
 			if ( methodName.startsWith( "is" ) ) {
 				String testStdMethod = Introspector.decapitalize( methodName.substring( 2 ) );
 				String testOldMethod = methodName.substring( 2 );
 				if ( testStdMethod.equals( propertyName ) || testOldMethod.equals( propertyName ) ) {
 					return method;
 				}
 			}
 		}
 
 		return null;
 	}
 
 
 	private static Method getMethod(Class theClass, String propertyName) {
 		Method[] methods = theClass.getDeclaredMethods();
 		Method.setAccessible( methods, true );
 		for ( Method method : methods ) {
 			// if the method has parameters, skip it
 			if ( method.getParameterTypes().length != 0 ) {
 				continue;
 			}
 			// if the method is a "bridge", skip it
 			if ( method.isBridge() ) {
 				continue;
 			}
 
 			final String methodName = method.getName();
 			if ( methodName.equals( propertyName ) ) {
 				return method;
 			}
 		}
 
 		return null;
 	}
 
 	private static Field getField(Class clazz, String name) {
 		Field[] fields = clazz.getDeclaredFields();
 		Field.setAccessible( fields, true );
 		for ( Field field : fields ) {
 			if ( field.getName().equals( name ) ) {
 				return field;
 			}
 		}
 		return null;
 	}
 
 	private static Type[] getTypes(Class[] classes) {
 		if ( classes == null || classes.length == 0 ) {
 			return EMPTY_TYPE_ARRAY;
 		}
 		Type[] types = new Type[classes.length];
 		for ( int i = 0; i < types.length; i++ ) {
 			types[i] = getType( classes[i] );
 		}
 		return types;
 	}
 
 
 	private static Type getType(String className, ServiceRegistry serviceRegistry) {
 		return getType( serviceRegistry.getService( ClassLoaderService.class ).classForName( className ) );
 	}
 
 	private static Type getType(Class clazz) {
 		return Type.create( DotName.createSimple( clazz.getName() ), getTypeKind( clazz ) );
 	}
 
 	private static Type.Kind getTypeKind(Class clazz) {
 		Type.Kind kind;
 		if ( clazz == Void.TYPE ) {
 			kind = Type.Kind.VOID;
 		}
 		else if ( clazz.isPrimitive() ) {
 			kind = Type.Kind.PRIMITIVE;
 		}
 		else if ( clazz.isArray() ) {
 			kind = Type.Kind.ARRAY;
 		}
 		else {
 			kind = Type.Kind.CLASS;
 		}
 		return kind;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/Helper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/Helper.java
index a9c09233e4..e70ecf46cb 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/Helper.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/Helper.java
@@ -1,378 +1,378 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.hbm;
 
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.MappingException;
 import org.hibernate.engine.spi.CascadeStyle;
 import org.hibernate.engine.spi.CascadeStyles;
 import org.hibernate.engine.spi.ExecuteUpdateResultCheckStyle;
 import org.hibernate.internal.jaxb.mapping.hbm.CustomSqlElement;
 import org.hibernate.internal.jaxb.mapping.hbm.EntityElement;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbColumnElement;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbJoinedSubclassElement;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbMetaElement;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbParamElement;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbSubclassElement;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbUnionSubclassElement;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.metamodel.binding.CustomSQL;
 import org.hibernate.metamodel.binding.InheritanceType;
 import org.hibernate.metamodel.binding.MetaAttribute;
 import org.hibernate.metamodel.relational.Identifier;
 import org.hibernate.metamodel.relational.Schema;
 import org.hibernate.metamodel.source.LocalBindingContext;
 import org.hibernate.metamodel.source.MetaAttributeContext;
 import org.hibernate.metamodel.source.binder.ExplicitHibernateTypeSource;
 import org.hibernate.metamodel.source.binder.MetaAttributeSource;
 import org.hibernate.metamodel.source.binder.RelationalValueSource;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 
 /**
  * @author Steve Ebersole
  * @author Gail Badner
  */
 public class Helper {
 	public static final ExplicitHibernateTypeSource TO_ONE_ATTRIBUTE_TYPE_SOURCE = new ExplicitHibernateTypeSource() {
 		@Override
 		public String getName() {
 			return null;
 		}
 
 		@Override
 		public Map<String, String> getParameters() {
 			return null;
 		}
 	};
 
 	public static InheritanceType interpretInheritanceType(EntityElement entityElement) {
 		if ( JaxbSubclassElement.class.isInstance( entityElement ) ) {
 			return InheritanceType.SINGLE_TABLE;
 		}
 		else if ( JaxbJoinedSubclassElement.class.isInstance( entityElement ) ) {
 			return InheritanceType.JOINED;
 		}
 		else if ( JaxbUnionSubclassElement.class.isInstance( entityElement ) ) {
 			return InheritanceType.TABLE_PER_CLASS;
 		}
 		else {
 			return InheritanceType.NO_INHERITANCE;
 		}
 	}
 
 	/**
 	 * Given a user-specified description of how to perform custom SQL, build the {@link CustomSQL} representation.
 	 *
 	 * @param customSqlElement User-specified description of how to perform custom SQL
 	 *
 	 * @return The {@link CustomSQL} representation
 	 */
 	public static CustomSQL buildCustomSql(CustomSqlElement customSqlElement) {
 		if ( customSqlElement == null ) {
 			return null;
 		}
 		final ExecuteUpdateResultCheckStyle checkStyle = customSqlElement.getCheck() == null
 				? customSqlElement.isCallable()
 						? ExecuteUpdateResultCheckStyle.NONE
 						: ExecuteUpdateResultCheckStyle.COUNT
 				: ExecuteUpdateResultCheckStyle.fromExternalName( customSqlElement.getCheck().value() );
 		return new CustomSQL( customSqlElement.getValue(), customSqlElement.isCallable(), checkStyle );
 	}
 
 	/**
 	 * Given the user-specified entity mapping, determine the appropriate entity name
 	 *
 	 * @param entityElement The user-specified entity mapping
 	 * @param unqualifiedClassPackage The package to use for unqualified class names
 	 *
 	 * @return The appropriate entity name
 	 */
 	public static String determineEntityName(EntityElement entityElement, String unqualifiedClassPackage) {
 		return entityElement.getEntityName() != null
 				? entityElement.getEntityName()
 				: qualifyIfNeeded( entityElement.getName(), unqualifiedClassPackage );
 	}
 
 	/**
 	 * Qualify a (supposed class) name with the unqualified-class package name if it is not already qualified
 	 *
 	 * @param name The name
 	 * @param unqualifiedClassPackage The unqualified-class package name
 	 *
 	 * @return {@code null} if the incoming name was {@code null}; or the qualified name.
 	 */
 	public static String qualifyIfNeeded(String name, String unqualifiedClassPackage) {
 		if ( name == null ) {
 			return null;
 		}
 		if ( name.indexOf( '.' ) < 0 && unqualifiedClassPackage != null ) {
 			return unqualifiedClassPackage + '.' + name;
 		}
 		return name;
 	}
 
 	public static String getPropertyAccessorName(String access, boolean isEmbedded, String defaultAccess) {
 		return getStringValue( access, isEmbedded ? "embedded" : defaultAccess );
 	}
 
 	public static MetaAttributeContext extractMetaAttributeContext(
 			List<JaxbMetaElement> metaElementList,
 			boolean onlyInheritable,
 			MetaAttributeContext parentContext) {
 		final MetaAttributeContext subContext = new MetaAttributeContext( parentContext );
 
 		for ( JaxbMetaElement metaElement : metaElementList ) {
 			if ( onlyInheritable & !metaElement.isInherit() ) {
 				continue;
 			}
 
 			final String name = metaElement.getAttribute();
 			final MetaAttribute inheritedMetaAttribute = parentContext.getMetaAttribute( name );
 			MetaAttribute metaAttribute = subContext.getLocalMetaAttribute( name );
 			if ( metaAttribute == null || metaAttribute == inheritedMetaAttribute ) {
 				metaAttribute = new MetaAttribute( name );
 				subContext.add( metaAttribute );
 			}
 			metaAttribute.addValue( metaElement.getValue() );
 		}
 
 		return subContext;
 	}
 
 	public static String getStringValue(String value, String defaultValue) {
 		return value == null ? defaultValue : value;
 	}
 
 	public static int getIntValue(String value, int defaultValue) {
 		return value == null ? defaultValue : Integer.parseInt( value );
 	}
 
 	public static long getLongValue(String value, long defaultValue) {
 		return value == null ? defaultValue : Long.parseLong( value );
 	}
 
 	public static boolean getBooleanValue(Boolean value, boolean defaultValue) {
 		return value == null ? defaultValue : value;
 	}
 
 	public static Iterable<CascadeStyle> interpretCascadeStyles(String cascades, LocalBindingContext bindingContext) {
 		final Set<CascadeStyle> cascadeStyles = new HashSet<CascadeStyle>();
 		if ( StringHelper.isEmpty( cascades ) ) {
 			cascades = bindingContext.getMappingDefaults().getCascadeStyle();
 		}
 		for ( String cascade : StringHelper.split( ",", cascades ) ) {
 			cascadeStyles.add( CascadeStyles.getCascadeStyle( cascade ) );
 		}
 		return cascadeStyles;
 	}
 
 	public static Map<String, String> extractParameters(List<JaxbParamElement> xmlParamElements) {
 		if ( xmlParamElements == null || xmlParamElements.isEmpty() ) {
 			return null;
 		}
 		final HashMap<String,String> params = new HashMap<String, String>();
 		for ( JaxbParamElement paramElement : xmlParamElements ) {
 			params.put( paramElement.getName(), paramElement.getValue() );
 		}
 		return params;
 	}
 
 	public static Iterable<MetaAttributeSource> buildMetaAttributeSources(List<JaxbMetaElement> metaElements) {
 		ArrayList<MetaAttributeSource> result = new ArrayList<MetaAttributeSource>();
 		if ( metaElements == null || metaElements.isEmpty() ) {
 			// do nothing
 		}
 		else {
 			for ( final JaxbMetaElement metaElement : metaElements ) {
 				result.add(
 						new MetaAttributeSource() {
 							@Override
 							public String getName() {
 								return metaElement.getAttribute();
 							}
 
 							@Override
 							public String getValue() {
 								return metaElement.getValue();
 							}
 
 							@Override
 							public boolean isInheritable() {
 								return metaElement.isInherit();
 							}
 						}
 				);
 			}
 		}
 		return result;
 	}
 
 	public static Schema.Name determineDatabaseSchemaName(
 			String explicitSchemaName,
 			String explicitCatalogName,
 			LocalBindingContext bindingContext) {
 		return new Schema.Name(
 				resolveIdentifier(
 						explicitSchemaName,
 						bindingContext.getMappingDefaults().getSchemaName(),
 						bindingContext.isGloballyQuotedIdentifiers()
 				),
 				resolveIdentifier(
 						explicitCatalogName,
 						bindingContext.getMappingDefaults().getCatalogName(),
 						bindingContext.isGloballyQuotedIdentifiers()
 				)
 		);
 	}
 
 	public static Identifier resolveIdentifier(String explicitName, String defaultName, boolean globalQuoting) {
 		String name = StringHelper.isNotEmpty( explicitName ) ? explicitName : defaultName;
 		if ( globalQuoting ) {
 			name = StringHelper.quote( name );
 		}
 		return Identifier.toIdentifier( name );
 	}
 
     public static class ValueSourcesAdapter {
         public String getContainingTableName() {
             return null;
         }
 
         public boolean isIncludedInInsertByDefault() {
             return false;
         }
 
         public boolean isIncludedInUpdateByDefault() {
             return false;
         }
 
         public String getColumnAttribute() {
             return null;
         }
 
         public String getFormulaAttribute() {
             return null;
         }
 
         public List getColumnOrFormulaElements() {
             return null;
         }
 
         public boolean isForceNotNull() {
             return false;
         }
     }
 
     public static List<RelationalValueSource> buildValueSources(
 			ValueSourcesAdapter valueSourcesAdapter,
 			LocalBindingContext bindingContext) {
 		List<RelationalValueSource> result = new ArrayList<RelationalValueSource>();
 
 		if ( StringHelper.isNotEmpty( valueSourcesAdapter.getColumnAttribute() ) ) {
 			if ( valueSourcesAdapter.getColumnOrFormulaElements() != null
 					&& ! valueSourcesAdapter.getColumnOrFormulaElements().isEmpty() ) {
 				throw new org.hibernate.metamodel.source.MappingException(
 						"column/formula attribute may not be used together with <column>/<formula> subelement",
 						bindingContext.getOrigin()
 				);
 			}
 			if ( StringHelper.isNotEmpty( valueSourcesAdapter.getFormulaAttribute() ) ) {
 				throw new org.hibernate.metamodel.source.MappingException(
 						"column and formula attributes may not be used together",
 						bindingContext.getOrigin()
 				);
 			}
 			result.add(
 					new ColumnAttributeSourceImpl(
 							valueSourcesAdapter.getContainingTableName(),
 							valueSourcesAdapter.getColumnAttribute(),
 							valueSourcesAdapter.isIncludedInInsertByDefault(),
 							valueSourcesAdapter.isIncludedInUpdateByDefault(),
                             valueSourcesAdapter.isForceNotNull()
 					)
 			);
 		}
 		else if ( StringHelper.isNotEmpty( valueSourcesAdapter.getFormulaAttribute() ) ) {
 			if ( valueSourcesAdapter.getColumnOrFormulaElements() != null
 					&& ! valueSourcesAdapter.getColumnOrFormulaElements().isEmpty() ) {
 				throw new org.hibernate.metamodel.source.MappingException(
 						"column/formula attribute may not be used together with <column>/<formula> subelement",
 						bindingContext.getOrigin()
 				);
 			}
 			// column/formula attribute combo checked already
 			result.add(
 					new FormulaImpl(
 							valueSourcesAdapter.getContainingTableName(),
 							valueSourcesAdapter.getFormulaAttribute()
 					)
 			);
 		}
 		else if ( valueSourcesAdapter.getColumnOrFormulaElements() != null
 				&& ! valueSourcesAdapter.getColumnOrFormulaElements().isEmpty() ) {
 			for ( Object columnOrFormulaElement : valueSourcesAdapter.getColumnOrFormulaElements() ) {
 				if ( JaxbColumnElement.class.isInstance( columnOrFormulaElement ) ) {
 					result.add(
 							new ColumnSourceImpl(
 									valueSourcesAdapter.getContainingTableName(),
 									(JaxbColumnElement) columnOrFormulaElement,
 									valueSourcesAdapter.isIncludedInInsertByDefault(),
 									valueSourcesAdapter.isIncludedInUpdateByDefault(),
                                     valueSourcesAdapter.isForceNotNull()
 							)
 					);
 				}
 				else {
 					result.add(
 							new FormulaImpl(
 									valueSourcesAdapter.getContainingTableName(),
 									(String) columnOrFormulaElement
 							)
 					);
 				}
 			}
 		}
 		return result;
 	}
 
 	// todo : remove this once the state objects are cleaned up
 
 	public static Class classForName(String className, ServiceRegistry serviceRegistry) {
 		ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 		try {
 			return classLoaderService.classForName( className );
 		}
 		catch ( ClassLoadingException e ) {
 			throw new MappingException( "Could not find class: " + className );
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HibernateMappingProcessor.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HibernateMappingProcessor.java
index 5769cb950a..b7a4644b3b 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HibernateMappingProcessor.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/hbm/HibernateMappingProcessor.java
@@ -1,287 +1,287 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.hbm;
 
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Set;
 
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.internal.jaxb.Origin;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbFetchProfileElement;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbHibernateMapping;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbParamElement;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbQueryElement;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbSqlQueryElement;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.ValueHolder;
 import org.hibernate.metamodel.binding.FetchProfile;
 import org.hibernate.metamodel.binding.TypeDef;
 import org.hibernate.metamodel.relational.AuxiliaryDatabaseObject;
 import org.hibernate.metamodel.relational.BasicAuxiliaryDatabaseObjectImpl;
 import org.hibernate.metamodel.source.MappingException;
 import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.type.Type;
 
 /**
  * Responsible for processing a {@code <hibernate-mapping/>} element.  Allows processing to be coordinated across
  * all hbm files in an ordered fashion.  The order is essentially the same as defined in
  * {@link org.hibernate.metamodel.source.MetadataSourceProcessor}
  *
  * @author Steve Ebersole
  */
 public class HibernateMappingProcessor {
 	private final MetadataImplementor metadata;
 	private final MappingDocument mappingDocument;
 
 	private ValueHolder<ClassLoaderService> classLoaderService = new ValueHolder<ClassLoaderService>(
 			new ValueHolder.DeferredInitializer<ClassLoaderService>() {
 				@Override
 				public ClassLoaderService initialize() {
 					return metadata.getServiceRegistry().getService( ClassLoaderService.class );
 				}
 			}
 	);
 
 	public HibernateMappingProcessor(MetadataImplementor metadata, MappingDocument mappingDocument) {
 		this.metadata = metadata;
 		this.mappingDocument = mappingDocument;
 	}
 
 	private JaxbHibernateMapping mappingRoot() {
 		return mappingDocument.getMappingRoot();
 	}
 
 	private Origin origin() {
 		return mappingDocument.getOrigin();
 	}
 
 	private HbmBindingContext bindingContext() {
 		return mappingDocument.getMappingLocalBindingContext();
 	}
 
 	private <T> Class<T> classForName(String name) {
 		return classLoaderService.getValue().classForName( bindingContext().qualifyClassName( name ) );
 	}
 
 	public void processIndependentMetadata() {
 		processDatabaseObjectDefinitions();
 		processTypeDefinitions();
 	}
 
 	private void processDatabaseObjectDefinitions() {
 		if ( mappingRoot().getDatabaseObject() == null ) {
 			return;
 		}
 
 		for ( JaxbHibernateMapping.JaxbDatabaseObject databaseObjectElement : mappingRoot().getDatabaseObject() ) {
 			final AuxiliaryDatabaseObject auxiliaryDatabaseObject;
 			if ( databaseObjectElement.getDefinition() != null ) {
 				final String className = databaseObjectElement.getDefinition().getClazz();
 				try {
 					auxiliaryDatabaseObject = (AuxiliaryDatabaseObject) classForName( className ).newInstance();
 				}
 				catch (ClassLoadingException e) {
 					throw e;
 				}
 				catch (Exception e) {
 					throw new MappingException(
 							"could not instantiate custom database object class [" + className + "]",
 							origin()
 					);
 				}
 			}
 			else {
 				Set<String> dialectScopes = new HashSet<String>();
 				if ( databaseObjectElement.getDialectScope() != null ) {
 					for ( JaxbHibernateMapping.JaxbDatabaseObject.JaxbDialectScope dialectScope : databaseObjectElement.getDialectScope() ) {
 						dialectScopes.add( dialectScope.getName() );
 					}
 				}
 				auxiliaryDatabaseObject = new BasicAuxiliaryDatabaseObjectImpl(
 						metadata.getDatabase().getDefaultSchema(),
 						databaseObjectElement.getCreate(),
 						databaseObjectElement.getDrop(),
 						dialectScopes
 				);
 			}
 			metadata.getDatabase().addAuxiliaryDatabaseObject( auxiliaryDatabaseObject );
 		}
 	}
 
 	private void processTypeDefinitions() {
 		if ( mappingRoot().getTypedef() == null ) {
 			return;
 		}
 
 		for ( JaxbHibernateMapping.JaxbTypedef typedef : mappingRoot().getTypedef() ) {
 			final Map<String, String> parameters = new HashMap<String, String>();
 			for ( JaxbParamElement paramElement : typedef.getParam() ) {
 				parameters.put( paramElement.getName(), paramElement.getValue() );
 			}
 			metadata.addTypeDefinition(
 					new TypeDef(
 							typedef.getName(),
 							typedef.getClazz(),
 							parameters
 					)
 			);
 		}
 	}
 
 	public void processTypeDependentMetadata() {
 		processFilterDefinitions();
 		processIdentifierGenerators();
 	}
 
 	private void processFilterDefinitions() {
 		if ( mappingRoot().getFilterDef() == null ) {
 			return;
 		}
 
 		for ( JaxbHibernateMapping.JaxbFilterDef filterDefinition : mappingRoot().getFilterDef() ) {
 			final String name = filterDefinition.getName();
 			final Map<String,Type> parameters = new HashMap<String, Type>();
 			String condition = null;
 			for ( Object o : filterDefinition.getContent() ) {
 				if ( o instanceof String ) {
 					// represents the condition
 					if ( condition != null ) {
 						// log?
 					}
 					condition = (String) o;
 				}
 				else if ( o instanceof JaxbHibernateMapping.JaxbFilterDef.JaxbFilterParam ) {
 					final JaxbHibernateMapping.JaxbFilterDef.JaxbFilterParam paramElement =
 							JaxbHibernateMapping.JaxbFilterDef.JaxbFilterParam.class.cast( o );
 					// todo : should really delay this resolution until later to allow typedef names
 					parameters.put(
 							paramElement.getName(),
 							metadata.getTypeResolver().heuristicType( paramElement.getType() )
 					);
 				}
 				else {
 					throw new MappingException( "Unrecognized nested filter content", origin() );
 				}
 			}
 			if ( condition == null ) {
 				condition = filterDefinition.getCondition();
 			}
 			metadata.addFilterDefinition( new FilterDefinition( name, condition, parameters ) );
 		}
 	}
 
 	private void processIdentifierGenerators() {
 		if ( mappingRoot().getIdentifierGenerator() == null ) {
 			return;
 		}
 
 		for ( JaxbHibernateMapping.JaxbIdentifierGenerator identifierGeneratorElement : mappingRoot().getIdentifierGenerator() ) {
 			metadata.registerIdentifierGenerator(
 					identifierGeneratorElement.getName(),
 					identifierGeneratorElement.getClazz()
 			);
 		}
 	}
 
 	public void processMappingDependentMetadata() {
 		processFetchProfiles();
 		processImports();
 		processResultSetMappings();
 		processNamedQueries();
 	}
 
 	private void processFetchProfiles(){
 		if ( mappingRoot().getFetchProfile() == null ) {
 			return;
 		}
 
 		processFetchProfiles( mappingRoot().getFetchProfile(), null );
 	}
 
 	public void processFetchProfiles(List<JaxbFetchProfileElement> fetchProfiles, String containingEntityName) {
 		for ( JaxbFetchProfileElement fetchProfile : fetchProfiles ) {
 			String profileName = fetchProfile.getName();
 			Set<FetchProfile.Fetch> fetches = new HashSet<FetchProfile.Fetch>();
 			for ( JaxbFetchProfileElement.JaxbFetch fetch : fetchProfile.getFetch() ) {
 				String entityName = fetch.getEntity() == null ? containingEntityName : fetch.getEntity();
 				if ( entityName == null ) {
 					throw new MappingException(
 							"could not determine entity for fetch-profile fetch [" + profileName + "]:[" +
 									fetch.getAssociation() + "]",
 							origin()
 					);
 				}
 				fetches.add( new FetchProfile.Fetch( entityName, fetch.getAssociation(), fetch.getStyle() ) );
 			}
 			metadata.addFetchProfile( new FetchProfile( profileName, fetches ) );
 		}
 	}
 
 	private void processImports() {
 		if ( mappingRoot().getImport() == null ) {
 			return;
 		}
 
 		for ( JaxbHibernateMapping.JaxbImport importValue : mappingRoot().getImport() ) {
 			String className = mappingDocument.getMappingLocalBindingContext().qualifyClassName( importValue.getClazz() );
 			String rename = importValue.getRename();
 			rename = ( rename == null ) ? StringHelper.unqualify( className ) : rename;
 			metadata.addImport( className, rename );
 		}
 	}
 
 	private void processResultSetMappings() {
 		if ( mappingRoot().getResultset() == null ) {
 			return;
 		}
 
 //			bindResultSetMappingDefinitions( element, null, mappings );
 	}
 
 	private void processNamedQueries() {
 		if ( mappingRoot().getQueryOrSqlQuery() == null ) {
 			return;
 		}
 
 		for ( Object queryOrSqlQuery : mappingRoot().getQueryOrSqlQuery() ) {
 			if ( JaxbQueryElement.class.isInstance( queryOrSqlQuery ) ) {
 //					bindNamedQuery( element, null, mappings );
 			}
 			else if ( JaxbSqlQueryElement.class.isInstance( queryOrSqlQuery ) ) {
 //				bindNamedSQLQuery( element, null, mappings );
 			}
 			else {
 				throw new MappingException(
 						"unknown type of query: " +
 								queryOrSqlQuery.getClass().getName(), origin()
 				);
 			}
 		}
 	}
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/IdentifierGeneratorResolver.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/IdentifierGeneratorResolver.java
index bec3410649..c40e936b2e 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/IdentifierGeneratorResolver.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/IdentifierGeneratorResolver.java
@@ -1,97 +1,97 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.internal;
 
 import java.io.Serializable;
 import java.util.Properties;
 
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.cfg.ObjectNameNormalizer;
 import org.hibernate.id.PersistentIdentifierGenerator;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.service.config.spi.ConfigurationService;
+import org.hibernate.engine.config.spi.ConfigurationService;
 
 /**
  * @author Gail Badner
  */
 public class IdentifierGeneratorResolver {
 
 	private final MetadataImplementor metadata;
 
 	IdentifierGeneratorResolver(MetadataImplementor metadata) {
 		this.metadata = metadata;
 	}
 
 	// IdentifierGeneratorResolver.resolve() must execute after AttributeTypeResolver.resolve()
 	// to ensure that identifier type is resolved.
 	@SuppressWarnings( {"unchecked"} )
 	void resolve() {
 		for ( EntityBinding entityBinding : metadata.getEntityBindings() ) {
 			if ( entityBinding.isRoot() ) {
 				Properties properties = new Properties( );
 				properties.putAll(
 						metadata.getServiceRegistry()
 								.getService( ConfigurationService.class )
 								.getSettings()
 				);
 				//TODO: where should these be added???
 				if ( ! properties.contains( AvailableSettings.PREFER_POOLED_VALUES_LO ) ) {
 					properties.put( AvailableSettings.PREFER_POOLED_VALUES_LO, "false" );
 				}
 				if ( ! properties.contains( PersistentIdentifierGenerator.IDENTIFIER_NORMALIZER ) ) {
 					properties.put(
 							PersistentIdentifierGenerator.IDENTIFIER_NORMALIZER,
 							new ObjectNameNormalizerImpl( metadata )
 					);
 				}
 				entityBinding.getHierarchyDetails().getEntityIdentifier().createIdentifierGenerator(
 						metadata.getIdentifierGeneratorFactory(),
 						properties
 				);
 			}
 		}
 	}
 
 	private static class ObjectNameNormalizerImpl extends ObjectNameNormalizer implements Serializable {
 		private final boolean useQuotedIdentifiersGlobally;
 		private final NamingStrategy namingStrategy;
 
 		private ObjectNameNormalizerImpl(MetadataImplementor metadata ) {
 			this.useQuotedIdentifiersGlobally = metadata.isGloballyQuotedIdentifiers();
 			this.namingStrategy = metadata.getNamingStrategy();
 		}
 
 		@Override
 		protected boolean isUseQuotedIdentifiersGlobally() {
 			return useQuotedIdentifiersGlobally;
 		}
 
 		@Override
 		protected NamingStrategy getNamingStrategy() {
 			return namingStrategy;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/JaxbHelper.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/JaxbHelper.java
index f3aeefe48e..f1fdb0bf6d 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/JaxbHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/JaxbHelper.java
@@ -1,313 +1,313 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
 package org.hibernate.metamodel.source.internal;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import javax.xml.XMLConstants;
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Unmarshaller;
 import javax.xml.bind.ValidationEvent;
 import javax.xml.bind.ValidationEventHandler;
 import javax.xml.bind.ValidationEventLocator;
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLEventReader;
 import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.events.Attribute;
 import javax.xml.stream.events.XMLEvent;
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 
 import org.jboss.logging.Logger;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.xml.sax.SAXException;
 
 import org.hibernate.internal.jaxb.JaxbRoot;
 import org.hibernate.internal.jaxb.Origin;
 import org.hibernate.internal.jaxb.mapping.hbm.JaxbHibernateMapping;
 import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityMappings;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.source.MappingException;
 import org.hibernate.metamodel.source.XsdException;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 /**
  * Helper class for unmarshalling xml configuration using StAX and JAXB.
  *
  * @author Steve Ebersole
  * @author Hardy Ferentschik
  */
 public class JaxbHelper {
 	private static final Logger log = Logger.getLogger( JaxbHelper.class );
 
 	public static final String ASSUMED_ORM_XSD_VERSION = "2.0";
 
 	private final MetadataSources metadataSources;
 
 	public JaxbHelper(MetadataSources metadataSources) {
 		this.metadataSources = metadataSources;
 	}
 
 	public JaxbRoot unmarshal(InputStream stream, Origin origin) {
 		try {
 			XMLEventReader staxReader = staxFactory().createXMLEventReader( stream );
 			try {
 				return unmarshal( staxReader, origin );
 			}
 			finally {
 				try {
 					staxReader.close();
 				}
 				catch ( Exception ignore ) {
 				}
 			}
 		}
 		catch ( XMLStreamException e ) {
 			throw new MappingException( "Unable to create stax reader", e, origin );
 		}
 	}
 
 	private XMLInputFactory staxFactory;
 
 	private XMLInputFactory staxFactory() {
 		if ( staxFactory == null ) {
 			staxFactory = buildStaxFactory();
 		}
 		return staxFactory;
 	}
 
 	@SuppressWarnings( { "UnnecessaryLocalVariable" })
 	private XMLInputFactory buildStaxFactory() {
 		XMLInputFactory staxFactory = XMLInputFactory.newInstance();
 		return staxFactory;
 	}
 
 	private static final QName ORM_VERSION_ATTRIBUTE_QNAME = new QName( "version" );
 
 	@SuppressWarnings( { "unchecked" })
 	private JaxbRoot unmarshal(XMLEventReader staxEventReader, final Origin origin) {
 		XMLEvent event;
 		try {
 			event = staxEventReader.peek();
 			while ( event != null && !event.isStartElement() ) {
 				staxEventReader.nextEvent();
 				event = staxEventReader.peek();
 			}
 		}
 		catch ( Exception e ) {
 			throw new MappingException( "Error accessing stax stream", e, origin );
 		}
 
 		if ( event == null ) {
 			throw new MappingException( "Could not locate root element", origin );
 		}
 
 		final Schema validationSchema;
 		final Class jaxbTarget;
 
 		final String elementName = event.asStartElement().getName().getLocalPart();
 
 		if ( "entity-mappings".equals( elementName ) ) {
 			final Attribute attribute = event.asStartElement().getAttributeByName( ORM_VERSION_ATTRIBUTE_QNAME );
 			final String explicitVersion = attribute == null ? null : attribute.getValue();
 			validationSchema = resolveSupportedOrmXsd( explicitVersion );
 			jaxbTarget = JaxbEntityMappings.class;
 		}
 		else {
 			validationSchema = hbmSchema();
 			jaxbTarget = JaxbHibernateMapping.class;
 		}
 
 		final Object target;
 		final ContextProvidingValidationEventHandler handler = new ContextProvidingValidationEventHandler();
 		try {
 			JAXBContext jaxbContext = JAXBContext.newInstance( jaxbTarget );
 			Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
 			unmarshaller.setSchema( validationSchema );
 			unmarshaller.setEventHandler( handler );
 			target = unmarshaller.unmarshal( staxEventReader );
 		}
 
 		catch ( JAXBException e ) {
 			StringBuilder builder = new StringBuilder();
 			builder.append( "Unable to perform unmarshalling at line number " );
 			builder.append( handler.getLineNumber() );
 			builder.append( " and column " );
 			builder.append( handler.getColumnNumber() );
 			builder.append( ". Message: " );
 			builder.append( handler.getMessage() );
 			throw new MappingException( builder.toString(), e, origin );
 		}
 
 		return new JaxbRoot( target, origin );
 	}
 
 	@SuppressWarnings( { "unchecked" })
 	public JaxbRoot unmarshal(Document document, Origin origin) {
 		Element rootElement = document.getDocumentElement();
 		if ( rootElement == null ) {
 			throw new MappingException( "No root element found", origin );
 		}
 
 		final Schema validationSchema;
 		final Class jaxbTarget;
 
 		if ( "entity-mappings".equals( rootElement.getNodeName() ) ) {
 			final String explicitVersion = rootElement.getAttribute( "version" );
 			validationSchema = resolveSupportedOrmXsd( explicitVersion );
 			jaxbTarget = JaxbEntityMappings.class;
 		}
 		else {
 			validationSchema = hbmSchema();
 			jaxbTarget = JaxbHibernateMapping.class;
 		}
 
 		final Object target;
 		try {
 			JAXBContext jaxbContext = JAXBContext.newInstance( jaxbTarget );
 			Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
 			unmarshaller.setSchema( validationSchema );
 			target = unmarshaller.unmarshal( new DOMSource( document ) );
 		}
 		catch ( JAXBException e ) {
 			throw new MappingException( "Unable to perform unmarshalling", e, origin );
 		}
 
 		return new JaxbRoot( target, origin );
 	}
 
 	private Schema resolveSupportedOrmXsd(String explicitVersion) {
 		final String xsdVersionString = explicitVersion == null ? ASSUMED_ORM_XSD_VERSION : explicitVersion;
 		if ( "1.0".equals( xsdVersionString ) ) {
 			return orm1Schema();
 		}
 		else if ( "2.0".equals( xsdVersionString ) ) {
 			return orm2Schema();
 		}
 		throw new IllegalArgumentException( "Unsupported orm.xml XSD version encountered [" + xsdVersionString + "]" );
 	}
 
 	public static final String HBM_SCHEMA_NAME = "org/hibernate/hibernate-mapping-4.0.xsd";
 	public static final String ORM_1_SCHEMA_NAME = "org/hibernate/ejb/orm_1_0.xsd";
 	public static final String ORM_2_SCHEMA_NAME = "org/hibernate/ejb/orm_2_0.xsd";
 
 	private Schema hbmSchema;
 
 	private Schema hbmSchema() {
 		if ( hbmSchema == null ) {
 			hbmSchema = resolveLocalSchema( HBM_SCHEMA_NAME );
 		}
 		return hbmSchema;
 	}
 
 	private Schema orm1Schema;
 
 	private Schema orm1Schema() {
 		if ( orm1Schema == null ) {
 			orm1Schema = resolveLocalSchema( ORM_1_SCHEMA_NAME );
 		}
 		return orm1Schema;
 	}
 
 	private Schema orm2Schema;
 
 	private Schema orm2Schema() {
 		if ( orm2Schema == null ) {
 			orm2Schema = resolveLocalSchema( ORM_2_SCHEMA_NAME );
 		}
 		return orm2Schema;
 	}
 
 	private Schema resolveLocalSchema(String schemaName) {
 		return resolveLocalSchema( schemaName, XMLConstants.W3C_XML_SCHEMA_NS_URI );
 	}
 
 	private Schema resolveLocalSchema(String schemaName, String schemaLanguage) {
 		URL url = metadataSources.getServiceRegistry()
 				.getService( ClassLoaderService.class )
 				.locateResource( schemaName );
 		if ( url == null ) {
 			throw new XsdException( "Unable to locate schema [" + schemaName + "] via classpath", schemaName );
 		}
 		try {
 			InputStream schemaStream = url.openStream();
 			try {
 				StreamSource source = new StreamSource( url.openStream() );
 				SchemaFactory schemaFactory = SchemaFactory.newInstance( schemaLanguage );
 				return schemaFactory.newSchema( source );
 			}
 			catch ( SAXException e ) {
 				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
 			}
 			catch ( IOException e ) {
 				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
 			}
 			finally {
 				try {
 					schemaStream.close();
 				}
 				catch ( IOException e ) {
 					log.debugf( "Problem closing schema stream [%s]", e.toString() );
 				}
 			}
 		}
 		catch ( IOException e ) {
 			throw new XsdException( "Stream error handling schema url [" + url.toExternalForm() + "]", schemaName );
 		}
 	}
 
 	static class ContextProvidingValidationEventHandler implements ValidationEventHandler {
 		private int lineNumber;
 		private int columnNumber;
 		private String message;
 
 		@Override
 		public boolean handleEvent(ValidationEvent validationEvent) {
 			ValidationEventLocator locator = validationEvent.getLocator();
 			lineNumber = locator.getLineNumber();
 			columnNumber = locator.getColumnNumber();
 			message = validationEvent.getMessage();
 			return false;
 		}
 
 		public int getLineNumber() {
 			return lineNumber;
 		}
 
 		public int getColumnNumber() {
 			return columnNumber;
 		}
 
 		public String getMessage() {
 			return message;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataBuilderImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataBuilderImpl.java
index 5e07de1e95..5af4980c7e 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataBuilderImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataBuilderImpl.java
@@ -1,196 +1,196 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.internal;
 
 import javax.persistence.SharedCacheMode;
 
 import org.hibernate.cache.spi.access.AccessType;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.EJB3NamingStrategy;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.metamodel.Metadata;
 import org.hibernate.metamodel.MetadataBuilder;
 import org.hibernate.metamodel.MetadataSourceProcessingOrder;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.config.spi.ConfigurationService;
+import org.hibernate.engine.config.spi.ConfigurationService;
 
 /**
  * @author Steve Ebersole
  */
 public class MetadataBuilderImpl implements MetadataBuilder {
 	private final MetadataSources sources;
 	private final OptionsImpl options;
 
 	public MetadataBuilderImpl(MetadataSources sources) {
 		this.sources = sources;
 		this.options = new OptionsImpl( sources.getServiceRegistry() );
 	}
 
 	@Override
 	public MetadataBuilder with(NamingStrategy namingStrategy) {
 		this.options.namingStrategy = namingStrategy;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(MetadataSourceProcessingOrder metadataSourceProcessingOrder) {
 		this.options.metadataSourceProcessingOrder = metadataSourceProcessingOrder;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(SharedCacheMode sharedCacheMode) {
 		this.options.sharedCacheMode = sharedCacheMode;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder with(AccessType accessType) {
 		this.options.defaultCacheAccessType = accessType;
 		return this;
 	}
 
 	@Override
 	public MetadataBuilder withNewIdentifierGeneratorsEnabled(boolean enabled) {
 		this.options.useNewIdentifierGenerators = enabled;
 		return this;
 	}
 
 	@Override
 	public Metadata buildMetadata() {
 		return new MetadataImpl( sources, options );
 	}
 
 	private static class OptionsImpl implements Metadata.Options {
 		private MetadataSourceProcessingOrder metadataSourceProcessingOrder = MetadataSourceProcessingOrder.HBM_FIRST;
 		private NamingStrategy namingStrategy = EJB3NamingStrategy.INSTANCE;
 		private SharedCacheMode sharedCacheMode = SharedCacheMode.ENABLE_SELECTIVE;
 		private AccessType defaultCacheAccessType;
         private boolean useNewIdentifierGenerators;
         private boolean globallyQuotedIdentifiers;
 		private String defaultSchemaName;
 		private String defaultCatalogName;
 
 		public OptionsImpl(ServiceRegistry serviceRegistry) {
 			ConfigurationService configService = serviceRegistry.getService( ConfigurationService.class );
 
 			// cache access type
 			defaultCacheAccessType = configService.getSetting(
 					AvailableSettings.DEFAULT_CACHE_CONCURRENCY_STRATEGY,
 					new ConfigurationService.Converter<AccessType>() {
 						@Override
 						public AccessType convert(Object value) {
 							return AccessType.fromExternalName( value.toString() );
 						}
 					}
 			);
 
 			useNewIdentifierGenerators = configService.getSetting(
 					AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS,
 					new ConfigurationService.Converter<Boolean>() {
 						@Override
 						public Boolean convert(Object value) {
 							return Boolean.parseBoolean( value.toString() );
 						}
 					},
 					false
 			);
 
 			defaultSchemaName = configService.getSetting(
 					AvailableSettings.DEFAULT_SCHEMA,
 					new ConfigurationService.Converter<String>() {
 						@Override
 						public String convert(Object value) {
 							return value.toString();
 						}
 					},
 					null
 			);
 
 			defaultCatalogName = configService.getSetting(
 					AvailableSettings.DEFAULT_CATALOG,
 					new ConfigurationService.Converter<String>() {
 						@Override
 						public String convert(Object value) {
 							return value.toString();
 						}
 					},
 					null
 			);
 
             globallyQuotedIdentifiers = configService.getSetting(
                     AvailableSettings.GLOBALLY_QUOTED_IDENTIFIERS,
                     new ConfigurationService.Converter<Boolean>() {
                         @Override
                         public Boolean convert(Object value) {
                             return Boolean.parseBoolean( value.toString() );
                         }
                     },
                     false
             );
 		}
 
 
 		@Override
 		public MetadataSourceProcessingOrder getMetadataSourceProcessingOrder() {
 			return metadataSourceProcessingOrder;
 		}
 
 		@Override
 		public NamingStrategy getNamingStrategy() {
 			return namingStrategy;
 		}
 
 		@Override
 		public AccessType getDefaultAccessType() {
 			return defaultCacheAccessType;
 		}
 
 		@Override
 		public SharedCacheMode getSharedCacheMode() {
 			return sharedCacheMode;
 		}
 
 		@Override
         public boolean useNewIdentifierGenerators() {
             return useNewIdentifierGenerators;
         }
 
         @Override
         public boolean isGloballyQuotedIdentifiers() {
             return globallyQuotedIdentifiers;
         }
 
         @Override
 		public String getDefaultSchemaName() {
 			return defaultSchemaName;
 		}
 
 		@Override
 		public String getDefaultCatalogName() {
 			return defaultCatalogName;
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataImpl.java b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataImpl.java
index bf6baa9786..0e25b152ed 100644
--- a/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/metamodel/source/internal/MetadataImpl.java
@@ -1,602 +1,602 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.internal;
 
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.DuplicateMappingException;
 import org.hibernate.MappingException;
 import org.hibernate.SessionFactory;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cache.spi.access.AccessType;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.spi.FilterDefinition;
 import org.hibernate.engine.spi.NamedQueryDefinition;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.id.factory.IdentifierGeneratorFactory;
 import org.hibernate.id.factory.spi.MutableIdentifierGeneratorFactory;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ValueHolder;
 import org.hibernate.metamodel.MetadataSourceProcessingOrder;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.SessionFactoryBuilder;
 import org.hibernate.metamodel.binding.AttributeBinding;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.binding.FetchProfile;
 import org.hibernate.metamodel.binding.IdGenerator;
 import org.hibernate.metamodel.binding.PluralAttributeBinding;
 import org.hibernate.metamodel.binding.TypeDef;
 import org.hibernate.metamodel.domain.BasicType;
 import org.hibernate.metamodel.domain.Type;
 import org.hibernate.metamodel.relational.Database;
 import org.hibernate.metamodel.source.MappingDefaults;
 import org.hibernate.metamodel.source.MetaAttributeContext;
 import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.metamodel.source.MetadataSourceProcessor;
 import org.hibernate.metamodel.source.annotations.AnnotationMetadataSourceProcessorImpl;
 import org.hibernate.metamodel.source.hbm.HbmMetadataSourceProcessorImpl;
 import org.hibernate.persister.spi.PersisterClassResolver;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.type.TypeResolver;
 
 /**
  * Container for configuration data collected during binding the metamodel.
  *
  * @author Steve Ebersole
  * @author Hardy Ferentschik
  * @author Gail Badner
  */
 public class MetadataImpl implements MetadataImplementor, Serializable {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			MetadataImpl.class.getName()
 	);
 
 	private final ServiceRegistry serviceRegistry;
 	private final Options options;
 
 	private final ValueHolder<ClassLoaderService> classLoaderService;
 	private final ValueHolder<PersisterClassResolver> persisterClassResolverService;
 
 	private TypeResolver typeResolver = new TypeResolver();
 
 	private SessionFactoryBuilder sessionFactoryBuilder = new SessionFactoryBuilderImpl( this );
 
 	private final MutableIdentifierGeneratorFactory identifierGeneratorFactory;
 
 	private final Database database;
 
 	private final MappingDefaults mappingDefaults;
 
 	/**
 	 * Maps the fully qualified class name of an entity to its entity binding
 	 */
 	private Map<String, EntityBinding> entityBindingMap = new HashMap<String, EntityBinding>();
 
 	private Map<String, PluralAttributeBinding> collectionBindingMap = new HashMap<String, PluralAttributeBinding>();
 	private Map<String, FetchProfile> fetchProfiles = new HashMap<String, FetchProfile>();
 	private Map<String, String> imports = new HashMap<String, String>();
 	private Map<String, TypeDef> typeDefs = new HashMap<String, TypeDef>();
 	private Map<String, IdGenerator> idGenerators = new HashMap<String, IdGenerator>();
 	private Map<String, NamedQueryDefinition> namedQueryDefs = new HashMap<String, NamedQueryDefinition>();
 	private Map<String, NamedSQLQueryDefinition> namedNativeQueryDefs = new HashMap<String, NamedSQLQueryDefinition>();
 	private Map<String, ResultSetMappingDefinition> resultSetMappings = new HashMap<String, ResultSetMappingDefinition>();
 	private Map<String, FilterDefinition> filterDefs = new HashMap<String, FilterDefinition>();
 
     private boolean globallyQuotedIdentifiers = false;
 
 	public MetadataImpl(MetadataSources metadataSources, Options options) {
 		this.serviceRegistry =  metadataSources.getServiceRegistry();
 		this.options = options;
 		this.identifierGeneratorFactory = serviceRegistry.getService( MutableIdentifierGeneratorFactory.class );
 				//new DefaultIdentifierGeneratorFactory( dialect );
 		this.database = new Database( options );
 
 		this.mappingDefaults = new MappingDefaultsImpl();
 
 		final MetadataSourceProcessor[] metadataSourceProcessors;
 		if ( options.getMetadataSourceProcessingOrder() == MetadataSourceProcessingOrder.HBM_FIRST ) {
 			metadataSourceProcessors = new MetadataSourceProcessor[] {
 					new HbmMetadataSourceProcessorImpl( this ),
 					new AnnotationMetadataSourceProcessorImpl( this )
 			};
 		}
 		else {
 			metadataSourceProcessors = new MetadataSourceProcessor[] {
 					new AnnotationMetadataSourceProcessorImpl( this ),
 					new HbmMetadataSourceProcessorImpl( this )
 			};
 		}
 
 		this.classLoaderService = new ValueHolder<ClassLoaderService>(
 				new ValueHolder.DeferredInitializer<ClassLoaderService>() {
 					@Override
 					public ClassLoaderService initialize() {
 						return serviceRegistry.getService( ClassLoaderService.class );
 					}
 				}
 		);
 		this.persisterClassResolverService = new ValueHolder<PersisterClassResolver>(
 				new ValueHolder.DeferredInitializer<PersisterClassResolver>() {
 					@Override
 					public PersisterClassResolver initialize() {
 						return serviceRegistry.getService( PersisterClassResolver.class );
 					}
 				}
 		);
 
 
 		final ArrayList<String> processedEntityNames = new ArrayList<String>();
 
 		prepare( metadataSourceProcessors, metadataSources );
 		bindIndependentMetadata( metadataSourceProcessors, metadataSources );
 		bindTypeDependentMetadata( metadataSourceProcessors, metadataSources );
 		bindMappingMetadata( metadataSourceProcessors, metadataSources, processedEntityNames );
 		bindMappingDependentMetadata( metadataSourceProcessors, metadataSources );
 
 		// todo : remove this by coordinated ordering of entity processing
 		new AssociationResolver( this ).resolve();
 		new HibernateTypeResolver( this ).resolve();
 		// IdentifierGeneratorResolver.resolve() must execute after AttributeTypeResolver.resolve()
 		new IdentifierGeneratorResolver( this ).resolve();
 	}
 
 	private void prepare(MetadataSourceProcessor[] metadataSourceProcessors, MetadataSources metadataSources) {
 		for ( MetadataSourceProcessor metadataSourceProcessor : metadataSourceProcessors ) {
 			metadataSourceProcessor.prepare( metadataSources );
 		}
 	}
 
 	private void bindIndependentMetadata(MetadataSourceProcessor[] metadataSourceProcessors, MetadataSources metadataSources) {
 		for ( MetadataSourceProcessor metadataSourceProcessor : metadataSourceProcessors ) {
 			metadataSourceProcessor.processIndependentMetadata( metadataSources );
 		}
 	}
 
 	private void bindTypeDependentMetadata(MetadataSourceProcessor[] metadataSourceProcessors, MetadataSources metadataSources) {
 		for ( MetadataSourceProcessor metadataSourceProcessor : metadataSourceProcessors ) {
 			metadataSourceProcessor.processTypeDependentMetadata( metadataSources );
 		}
 	}
 
 	private void bindMappingMetadata(MetadataSourceProcessor[] metadataSourceProcessors, MetadataSources metadataSources, List<String> processedEntityNames) {
 		for ( MetadataSourceProcessor metadataSourceProcessor : metadataSourceProcessors ) {
 			metadataSourceProcessor.processMappingMetadata( metadataSources, processedEntityNames );
 		}
 	}
 
 	private void bindMappingDependentMetadata(MetadataSourceProcessor[] metadataSourceProcessors, MetadataSources metadataSources) {
 		for ( MetadataSourceProcessor metadataSourceProcessor : metadataSourceProcessors ) {
 			metadataSourceProcessor.processMappingDependentMetadata( metadataSources );
 		}
 	}
 
 	@Override
 	public void addFetchProfile(FetchProfile profile) {
 		if ( profile == null || profile.getName() == null ) {
 			throw new IllegalArgumentException( "Fetch profile object or name is null: " + profile );
 		}
 		fetchProfiles.put( profile.getName(), profile );
 	}
 
 	@Override
 	public void addFilterDefinition(FilterDefinition def) {
 		if ( def == null || def.getFilterName() == null ) {
 			throw new IllegalArgumentException( "Filter definition object or name is null: "  + def );
 		}
 		filterDefs.put( def.getFilterName(), def );
 	}
 
 	public Iterable<FilterDefinition> getFilterDefinitions() {
 		return filterDefs.values();
 	}
 
 	@Override
 	public void addIdGenerator(IdGenerator generator) {
 		if ( generator == null || generator.getName() == null ) {
 			throw new IllegalArgumentException( "ID generator object or name is null." );
 		}
 		idGenerators.put( generator.getName(), generator );
 	}
 
 	@Override
 	public IdGenerator getIdGenerator(String name) {
 		if ( name == null ) {
 			throw new IllegalArgumentException( "null is not a valid generator name" );
 		}
 		return idGenerators.get( name );
 	}
 	@Override
 	public void registerIdentifierGenerator(String name, String generatorClassName) {
 		 identifierGeneratorFactory.register( name, classLoaderService().classForName( generatorClassName ) );
 	}
 
 	@Override
 	public void addNamedNativeQuery(NamedSQLQueryDefinition def) {
 		if ( def == null || def.getName() == null ) {
 			throw new IllegalArgumentException( "Named native query definition object or name is null: " + def.getQueryString() );
 		}
 		namedNativeQueryDefs.put( def.getName(), def );
 	}
 
 	public NamedSQLQueryDefinition getNamedNativeQuery(String name) {
 		if ( name == null ) {
 			throw new IllegalArgumentException( "null is not a valid native query name" );
 		}
 		return namedNativeQueryDefs.get( name );
 	}
 
 	@Override
 	public Iterable<NamedSQLQueryDefinition> getNamedNativeQueryDefinitions() {
 		return namedNativeQueryDefs.values();
 	}
 
 	@Override
 	public void addNamedQuery(NamedQueryDefinition def) {
 		if ( def == null ) {
 			throw new IllegalArgumentException( "Named query definition is null" );
 		}
 		else if ( def.getName() == null ) {
 			throw new IllegalArgumentException( "Named query definition name is null: " + def.getQueryString() );
 		}
 		namedQueryDefs.put( def.getName(), def );
 	}
 
 	public NamedQueryDefinition getNamedQuery(String name) {
 		if ( name == null ) {
 			throw new IllegalArgumentException( "null is not a valid query name" );
 		}
 		return namedQueryDefs.get( name );
 	}
 
 	@Override
 	public Iterable<NamedQueryDefinition> getNamedQueryDefinitions() {
 		return namedQueryDefs.values();
 	}
 
 	@Override
 	public void addResultSetMapping(ResultSetMappingDefinition resultSetMappingDefinition) {
 		if ( resultSetMappingDefinition == null || resultSetMappingDefinition.getName() == null ) {
 			throw new IllegalArgumentException( "Result-set mapping object or name is null: " + resultSetMappingDefinition );
 		}
 		resultSetMappings.put( resultSetMappingDefinition.getName(), resultSetMappingDefinition );
 	}
 
 	@Override
 	public Iterable<ResultSetMappingDefinition> getResultSetMappingDefinitions() {
 		return resultSetMappings.values();
 	}
 
 	@Override
 	public void addTypeDefinition(TypeDef typeDef) {
 		if ( typeDef == null ) {
 			throw new IllegalArgumentException( "Type definition is null" );
 		}
 		else if ( typeDef.getName() == null ) {
 			throw new IllegalArgumentException( "Type definition name is null: " + typeDef.getTypeClass() );
 		}
 		final TypeDef previous = typeDefs.put( typeDef.getName(), typeDef );
 		if ( previous != null ) {
 			LOG.debugf( "Duplicate typedef name [%s] now -> %s", typeDef.getName(), typeDef.getTypeClass() );
 		}
 	}
 
 	@Override
 	public Iterable<TypeDef> getTypeDefinitions() {
 		return typeDefs.values();
 	}
 
 	@Override
 	public TypeDef getTypeDefinition(String name) {
 		return typeDefs.get( name );
 	}
 
 	private ClassLoaderService classLoaderService() {
 		return classLoaderService.getValue();
 	}
 
 	private PersisterClassResolver persisterClassResolverService() {
 		return persisterClassResolverService.getValue();
 	}
 
 	@Override
 	public Options getOptions() {
 		return options;
 	}
 
 	@Override
 	public SessionFactory buildSessionFactory() {
 		return sessionFactoryBuilder.buildSessionFactory();
 	}
 
 	@Override
 	public ServiceRegistry getServiceRegistry() {
 		return serviceRegistry;
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> Class<T> locateClassByName(String name) {
 		return classLoaderService().classForName( name );
 	}
 
 	@Override
 	public Type makeJavaType(String className) {
 		// todo : have this perform some analysis of the incoming type name to determine appropriate return
 		return new BasicType( className, makeClassReference( className ) );
 	}
 
 	@Override
 	public ValueHolder<Class<?>> makeClassReference(final String className) {
 		return new ValueHolder<Class<?>>(
 				new ValueHolder.DeferredInitializer<Class<?>>() {
 					@Override
 					public Class<?> initialize() {
 						return classLoaderService.getValue().classForName( className );
 					}
 				}
 		);
 	}
 
 	@Override
 	public String qualifyClassName(String name) {
 		return name;
 	}
 
 	@Override
 	public Database getDatabase() {
 		return database;
 	}
 
 	public EntityBinding getEntityBinding(String entityName) {
 		return entityBindingMap.get( entityName );
 	}
 
 	@Override
 	public EntityBinding getRootEntityBinding(String entityName) {
 		EntityBinding binding = entityBindingMap.get( entityName );
 		if ( binding == null ) {
 			throw new IllegalStateException( "Unknown entity binding: " + entityName );
 		}
 
 		do {
 			if ( binding.isRoot() ) {
 				return binding;
 			}
 			binding = binding.getSuperEntityBinding();
 		} while ( binding != null );
 
 		throw new AssertionFailure( "Entity binding has no root: " + entityName );
 	}
 
 	public Iterable<EntityBinding> getEntityBindings() {
 		return entityBindingMap.values();
 	}
 
 	public void addEntity(EntityBinding entityBinding) {
 		final String entityName = entityBinding.getEntity().getName();
 		if ( entityBindingMap.containsKey( entityName ) ) {
 			throw new DuplicateMappingException( DuplicateMappingException.Type.ENTITY, entityName );
 		}
 		entityBindingMap.put( entityName, entityBinding );
 	}
 
 	public PluralAttributeBinding getCollection(String collectionRole) {
 		return collectionBindingMap.get( collectionRole );
 	}
 
 	@Override
 	public Iterable<PluralAttributeBinding> getCollectionBindings() {
 		return collectionBindingMap.values();
 	}
 
 	public void addCollection(PluralAttributeBinding pluralAttributeBinding) {
 		final String owningEntityName = pluralAttributeBinding.getContainer().getPathBase();
 		final String attributeName = pluralAttributeBinding.getAttribute().getName();
 		final String collectionRole = owningEntityName + '.' + attributeName;
 		if ( collectionBindingMap.containsKey( collectionRole ) ) {
 			throw new DuplicateMappingException( DuplicateMappingException.Type.ENTITY, collectionRole );
 		}
 		collectionBindingMap.put( collectionRole, pluralAttributeBinding );
 	}
 
 	public void addImport(String importName, String entityName) {
 		if ( importName == null || entityName == null ) {
 			throw new IllegalArgumentException( "Import name or entity name is null" );
 		}
 		LOG.tracev( "Import: {0} -> {1}", importName, entityName );
 		String old = imports.put( importName, entityName );
 		if ( old != null ) {
 			LOG.debug( "import name [" + importName + "] overrode previous [{" + old + "}]" );
 		}
 	}
 
 	@Override
 	public Iterable<Map.Entry<String, String>> getImports() {
 		return imports.entrySet();
 	}
 
 	@Override
 	public Iterable<FetchProfile> getFetchProfiles() {
 		return fetchProfiles.values();
 	}
 
 	public TypeResolver getTypeResolver() {
 		return typeResolver;
 	}
 
 	@Override
 	public SessionFactoryBuilder getSessionFactoryBuilder() {
 		return sessionFactoryBuilder;
 	}
 
 	@Override
 	public NamingStrategy getNamingStrategy() {
 		return options.getNamingStrategy();
 	}
 
     @Override
     public boolean isGloballyQuotedIdentifiers() {
         return globallyQuotedIdentifiers || getOptions().isGloballyQuotedIdentifiers();
     }
 
     public void setGloballyQuotedIdentifiers(boolean globallyQuotedIdentifiers){
        this.globallyQuotedIdentifiers = globallyQuotedIdentifiers;
     }
 
     @Override
 	public MappingDefaults getMappingDefaults() {
 		return mappingDefaults;
 	}
 
 	private final MetaAttributeContext globalMetaAttributeContext = new MetaAttributeContext();
 
 	@Override
 	public MetaAttributeContext getGlobalMetaAttributeContext() {
 		return globalMetaAttributeContext;
 	}
 
 	@Override
 	public MetadataImplementor getMetadataImplementor() {
 		return this;
 	}
 
 	private static final String DEFAULT_IDENTIFIER_COLUMN_NAME = "id";
 	private static final String DEFAULT_DISCRIMINATOR_COLUMN_NAME = "class";
 	private static final String DEFAULT_CASCADE = "none";
 	private static final String DEFAULT_PROPERTY_ACCESS = "property";
 
 	@Override
 	public IdentifierGeneratorFactory getIdentifierGeneratorFactory() {
 		return identifierGeneratorFactory;
 	}
 
 	@Override
 	public org.hibernate.type.Type getIdentifierType(String entityName) throws MappingException {
 		EntityBinding entityBinding = getEntityBinding( entityName );
 		if ( entityBinding == null ) {
 			throw new MappingException( "Entity binding not known: " + entityName );
 		}
 		return entityBinding
 				.getHierarchyDetails()
 				.getEntityIdentifier()
 				.getValueBinding()
 				.getHibernateTypeDescriptor()
 				.getResolvedTypeMapping();
 	}
 
 	@Override
 	public String getIdentifierPropertyName(String entityName) throws MappingException {
 		EntityBinding entityBinding = getEntityBinding( entityName );
 		if ( entityBinding == null ) {
 			throw new MappingException( "Entity binding not known: " + entityName );
 		}
 		AttributeBinding idBinding = entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding();
 		return idBinding == null ? null : idBinding.getAttribute().getName();
 	}
 
 	@Override
 	public org.hibernate.type.Type getReferencedPropertyType(String entityName, String propertyName) throws MappingException {
 		EntityBinding entityBinding = getEntityBinding( entityName );
 		if ( entityBinding == null ) {
 			throw new MappingException( "Entity binding not known: " + entityName );
 		}
 		// TODO: should this call EntityBinding.getReferencedAttributeBindingString), which does not exist yet?
 		AttributeBinding attributeBinding = entityBinding.locateAttributeBinding( propertyName );
 		if ( attributeBinding == null ) {
 			throw new MappingException( "unknown property: " + entityName + '.' + propertyName );
 		}
 		return attributeBinding.getHibernateTypeDescriptor().getResolvedTypeMapping();
 	}
 
 	private class MappingDefaultsImpl implements MappingDefaults {
 
 		@Override
 		public String getPackageName() {
 			return null;
 		}
 
 		@Override
 		public String getSchemaName() {
 			return options.getDefaultSchemaName();
 		}
 
 		@Override
 		public String getCatalogName() {
 			return options.getDefaultCatalogName();
 		}
 
 		@Override
 		public String getIdColumnName() {
 			return DEFAULT_IDENTIFIER_COLUMN_NAME;
 		}
 
 		@Override
 		public String getDiscriminatorColumnName() {
 			return DEFAULT_DISCRIMINATOR_COLUMN_NAME;
 		}
 
 		@Override
 		public String getCascadeStyle() {
 			return DEFAULT_CASCADE;
 		}
 
 		@Override
 		public String getPropertyAccessorName() {
 			return DEFAULT_PROPERTY_ACCESS;
 		}
 
 		@Override
 		public boolean areAssociationsLazy() {
 			return true;
 		}
 
 		private final ValueHolder<AccessType> regionFactorySpecifiedDefaultAccessType = new ValueHolder<AccessType>(
 				new ValueHolder.DeferredInitializer<AccessType>() {
 					@Override
 					public AccessType initialize() {
 						final RegionFactory regionFactory = getServiceRegistry().getService( RegionFactory.class );
 						return regionFactory.getDefaultAccessType();
 					}
 				}
 		);
 
 		@Override
 		public AccessType getCacheAccessType() {
 			return options.getDefaultAccessType() != null
 					? options.getDefaultAccessType()
 					: regionFactorySpecifiedDefaultAccessType.getValue();
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterClassResolverInitiator.java b/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterClassResolverInitiator.java
index 0f5a9d71b7..95db7a0271 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterClassResolverInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterClassResolverInitiator.java
@@ -1,73 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.internal;
 
 import java.util.Map;
 
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.persister.spi.PersisterClassResolver;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.service.spi.ServiceException;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * @author Steve Ebersole
  */
-public class PersisterClassResolverInitiator implements BasicServiceInitiator<PersisterClassResolver> {
+public class PersisterClassResolverInitiator implements StandardServiceInitiator<PersisterClassResolver> {
 	public static final PersisterClassResolverInitiator INSTANCE = new PersisterClassResolverInitiator();
 	public static final String IMPL_NAME = "hibernate.persister.resolver";
 
 	@Override
 	public Class<PersisterClassResolver> getServiceInitiated() {
 		return PersisterClassResolver.class;
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public PersisterClassResolver initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		final Object customImpl = configurationValues.get( IMPL_NAME );
 		if ( customImpl == null ) {
 			return new StandardPersisterClassResolver();
 		}
 
 		if ( PersisterClassResolver.class.isInstance( customImpl ) ) {
 			return (PersisterClassResolver) customImpl;
 		}
 
 		final Class<? extends PersisterClassResolver> customImplClass = Class.class.isInstance( customImpl )
 				? (Class<? extends PersisterClassResolver>) customImpl
 				: locate( registry, customImpl.toString() );
 
 		try {
 			return customImplClass.newInstance();
 		}
 		catch (Exception e) {
 			throw new ServiceException( "Could not initialize custom PersisterClassResolver impl [" + customImplClass.getName() + "]", e );
 		}
 	}
 
 	private Class<? extends PersisterClassResolver> locate(ServiceRegistryImplementor registry, String className) {
 		return registry.getService( ClassLoaderService.class ).classForName( className );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterFactoryInitiator.java b/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterFactoryInitiator.java
index 74227a9c60..2ad3ae3614 100644
--- a/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterFactoryInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/persister/internal/PersisterFactoryInitiator.java
@@ -1,73 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.persister.internal;
 
 import java.util.Map;
 
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.persister.spi.PersisterFactory;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.service.spi.ServiceException;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * @author Steve Ebersole
  */
-public class PersisterFactoryInitiator implements BasicServiceInitiator<PersisterFactory> {
+public class PersisterFactoryInitiator implements StandardServiceInitiator<PersisterFactory> {
 	public static final PersisterFactoryInitiator INSTANCE = new PersisterFactoryInitiator();
 
 	public static final String IMPL_NAME = "hibernate.persister.factory";
 
 	@Override
 	public Class<PersisterFactory> getServiceInitiated() {
 		return PersisterFactory.class;
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public PersisterFactory initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		final Object customImpl = configurationValues.get( IMPL_NAME );
 		if ( customImpl == null ) {
 			return new PersisterFactoryImpl();
 		}
 
 		if ( PersisterFactory.class.isInstance( customImpl ) ) {
 			return (PersisterFactory) customImpl;
 		}
 
 		final Class<? extends PersisterFactory> customImplClass = Class.class.isInstance( customImpl )
 				? ( Class<? extends PersisterFactory> ) customImpl
 				: locate( registry, customImpl.toString() );
 		try {
 			return customImplClass.newInstance();
 		}
 		catch (Exception e) {
 			throw new ServiceException( "Could not initialize custom PersisterFactory impl [" + customImplClass.getName() + "]", e );
 		}
 	}
 
 	private Class<? extends PersisterFactory> locate(ServiceRegistryImplementor registry, String className) {
 		return registry.getService( ClassLoaderService.class ).classForName( className );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/BootstrapServiceRegistry.java b/hibernate-core/src/main/java/org/hibernate/service/BootstrapServiceRegistry.java
index 9b0a74e24a..623b54e35d 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/BootstrapServiceRegistry.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/BootstrapServiceRegistry.java
@@ -1,33 +1,31 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service;
 
 /**
- * Specialization of the {@link ServiceRegistry} contract mainly to make the
- * {@link ServiceRegistryBuilder#ServiceRegistryBuilder(BootstrapServiceRegistry)} signature type-safe
- *
- * @author Steve Ebersole
+ * @deprecated Use {@link org.hibernate.boot.registry.BootstrapServiceRegistry} instead
  */
-public interface BootstrapServiceRegistry extends ServiceRegistry {
+@Deprecated
+public interface BootstrapServiceRegistry extends org.hibernate.boot.registry.BootstrapServiceRegistry {
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/BootstrapServiceRegistryBuilder.java b/hibernate-core/src/main/java/org/hibernate/service/BootstrapServiceRegistryBuilder.java
index 6c1107bb6b..5d707232dd 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/BootstrapServiceRegistryBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/BootstrapServiceRegistryBuilder.java
@@ -1,153 +1,73 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service;
 
-import java.util.LinkedHashSet;
-
-import org.hibernate.integrator.internal.IntegratorServiceImpl;
 import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.service.classloading.internal.ClassLoaderServiceImpl;
-import org.hibernate.service.internal.BootstrapServiceRegistryImpl;
-import org.hibernate.service.selector.internal.StrategySelectorBuilder;
-import org.hibernate.service.selector.internal.StrategySelectorImpl;
 
 /**
- * Builder for bootstrap {@link ServiceRegistry} instances.
- *
- * @author Steve Ebersole
- *
- * @see BootstrapServiceRegistryImpl
- * @see ServiceRegistryBuilder#ServiceRegistryBuilder(BootstrapServiceRegistry)
+ * @deprecated Use {@link org.hibernate.boot.registry.BootstrapServiceRegistryBuilder} instead
  */
-public class BootstrapServiceRegistryBuilder {
-	private final LinkedHashSet<Integrator> providedIntegrators = new LinkedHashSet<Integrator>();
-	private ClassLoader applicationClassLoader;
-	private ClassLoader resourcesClassLoader;
-	private ClassLoader hibernateClassLoader;
-	private ClassLoader environmentClassLoader;
-
-	private StrategySelectorBuilder strategySelectorBuilder = new StrategySelectorBuilder();
-
-	/**
-	 * Add an {@link Integrator} to be applied to the bootstrap registry.
-	 *
-	 * @param integrator The integrator to add.
-	 * @return {@code this}, for method chaining
-	 */
+@Deprecated
+public class BootstrapServiceRegistryBuilder extends org.hibernate.boot.registry.BootstrapServiceRegistryBuilder {
+	@Override
 	public BootstrapServiceRegistryBuilder with(Integrator integrator) {
-		providedIntegrators.add( integrator );
+		super.with( integrator );
 		return this;
 	}
 
-	/**
-	 * Applies the specified {@link ClassLoader} as the application class loader for the bootstrap registry
-	 *
-	 * @param classLoader The class loader to use
-	 * @return {@code this}, for method chaining
-	 */
-	@SuppressWarnings( {"UnusedDeclaration"})
+	@Override
 	public BootstrapServiceRegistryBuilder withApplicationClassLoader(ClassLoader classLoader) {
-		this.applicationClassLoader = classLoader;
+		super.withApplicationClassLoader( classLoader );
 		return this;
 	}
 
-	/**
-	 * Applies the specified {@link ClassLoader} as the resource class loader for the bootstrap registry
-	 *
-	 * @param classLoader The class loader to use
-	 * @return {@code this}, for method chaining
-	 */
-	@SuppressWarnings( {"UnusedDeclaration"})
+	@Override
 	public BootstrapServiceRegistryBuilder withResourceClassLoader(ClassLoader classLoader) {
-		this.resourcesClassLoader = classLoader;
+		super.withResourceClassLoader( classLoader );
 		return this;
 	}
 
-	/**
-	 * Applies the specified {@link ClassLoader} as the Hibernate class loader for the bootstrap registry
-	 *
-	 * @param classLoader The class loader to use
-	 * @return {@code this}, for method chaining
-	 */
-	@SuppressWarnings( {"UnusedDeclaration"})
+	@Override
 	public BootstrapServiceRegistryBuilder withHibernateClassLoader(ClassLoader classLoader) {
-		this.hibernateClassLoader = classLoader;
+		super.withHibernateClassLoader( classLoader );
 		return this;
 	}
 
-	/**
-	 * Applies the specified {@link ClassLoader} as the environment (or system) class loader for the bootstrap registry
-	 *
-	 * @param classLoader The class loader to use
-	 * @return {@code this}, for method chaining
-	 */
-	@SuppressWarnings( {"UnusedDeclaration"})
+	@Override
 	public BootstrapServiceRegistryBuilder withEnvironmentClassLoader(ClassLoader classLoader) {
-		this.environmentClassLoader = classLoader;
+		super.withEnvironmentClassLoader( classLoader );
 		return this;
 	}
 
-	/**
-	 * Applies a named strategy implementation to the bootstrap registry
-	 *
-	 * @param strategy The strategy
-	 * @param name The registered name
-	 * @param implementation The strategy implementation Class
-	 *
-	 * @return {@code this}, for method chaining
-	 *
-	 * @see org.hibernate.service.selector.spi.StrategySelector#registerStrategyImplementor(Class, String, Class)
-	 */
-	@SuppressWarnings( {"UnusedDeclaration"})
+	@Override
 	public <T> BootstrapServiceRegistryBuilder withStrategySelector(Class<T> strategy, String name, Class<? extends T> implementation) {
-		this.strategySelectorBuilder.addCustomRegistration( strategy, name, implementation );
+		super.withStrategySelector( strategy, name, implementation );
 		return this;
 	}
 
-	/**
-	 * Build the bootstrap registry.
-	 *
-	 * @return The built bootstrap registry
-	 */
+	@Override
 	public BootstrapServiceRegistry build() {
-		final ClassLoaderServiceImpl classLoaderService = new ClassLoaderServiceImpl(
-				applicationClassLoader,
-				resourcesClassLoader,
-				hibernateClassLoader,
-				environmentClassLoader
-		);
-
-		final IntegratorServiceImpl integratorService = new IntegratorServiceImpl(
-				providedIntegrators,
-				classLoaderService
-		);
-
-
-		return new BootstrapServiceRegistryImpl(
-				classLoaderService,
-				strategySelectorBuilder.buildSelector( classLoaderService ),
-				integratorService
-		);
+		return (BootstrapServiceRegistry) super.build();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/ConfigLoader.java b/hibernate-core/src/main/java/org/hibernate/service/ConfigLoader.java
index 43e04792db..30aed6570b 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/ConfigLoader.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/ConfigLoader.java
@@ -1,93 +1,94 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.Properties;
 
 import org.jboss.logging.Logger;
 
+import org.hibernate.boot.registry.BootstrapServiceRegistry;
 import org.hibernate.internal.jaxb.Origin;
 import org.hibernate.internal.jaxb.SourceType;
 import org.hibernate.internal.jaxb.cfg.JaxbHibernateConfiguration;
 import org.hibernate.internal.util.ValueHolder;
 import org.hibernate.internal.util.config.ConfigurationException;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.service.internal.JaxbProcessor;
 
 /**
  * Loads {@code cfg.xml} files.
  *
  * @author Steve Ebersole
  */
 public class ConfigLoader {
 	private static final Logger log = Logger.getLogger( ConfigLoader.class );
 
 	private final BootstrapServiceRegistry bootstrapServiceRegistry;
 
 	private ValueHolder<JaxbProcessor> jaxbProcessorHolder = new ValueHolder<JaxbProcessor>(
 			new ValueHolder.DeferredInitializer<JaxbProcessor>() {
 				@Override
 				public JaxbProcessor initialize() {
 					return new JaxbProcessor( bootstrapServiceRegistry.getService( ClassLoaderService.class ) );
 				}
 			}
 	);
 
 	public ConfigLoader(BootstrapServiceRegistry bootstrapServiceRegistry) {
 		this.bootstrapServiceRegistry = bootstrapServiceRegistry;
 	}
 
 	public JaxbHibernateConfiguration loadConfigXmlResource(String cfgXmlResourceName) {
 		final InputStream stream = bootstrapServiceRegistry.getService( ClassLoaderService.class ).locateResourceStream( cfgXmlResourceName );
 		if ( stream == null ) {
 			throw new ConfigurationException( "Could not locate cfg.xml resource [" + cfgXmlResourceName + "]" );
 		}
 		return jaxbProcessorHolder.getValue().unmarshal( stream, new Origin( SourceType.RESOURCE, cfgXmlResourceName ) );
 	}
 
 	public Properties loadProperties(String resourceName) {
 		final InputStream stream = bootstrapServiceRegistry.getService( ClassLoaderService.class ).locateResourceStream( resourceName );
 		try {
 			Properties properties = new Properties();
 			properties.load( stream );
 			return properties;
 		}
 		catch (IOException e) {
 			throw new ConfigurationException( "Unable to apply settings from properties file [" + resourceName + "]", e );
 		}
 		finally {
 			try {
 				stream.close();
 			}
 			catch (IOException e) {
 				log.debug(
 						String.format( "Unable to close properties file [%s] stream", resourceName ),
 						e
 				);
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/ServiceRegistry.java b/hibernate-core/src/main/java/org/hibernate/service/ServiceRegistry.java
index 910f301a8f..87fba8c9af 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/ServiceRegistry.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/ServiceRegistry.java
@@ -1,53 +1,53 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service;
 
 /**
  * A registry of {@link Service services}.
  *
  * @author Steve Ebersole
  */
 public interface ServiceRegistry {
 	/**
 	 * Retrieve this registry's parent registry.
 	 * 
 	 * @return The parent registry.  May be null.
 	 */
 	public ServiceRegistry getParentServiceRegistry();
 
 	/**
-	 * Retrieve a service by role.  If service is not found, but a {@link org.hibernate.service.spi.BasicServiceInitiator} is registered for
-	 * this service role, the service will be initialized and returned.
+	 * Retrieve a service by role.  If service is not found, but a {@link org.hibernate.service.spi.ServiceInitiator} is
+	 * registered for this service role, the service will be initialized and returned.
 	 * <p/>
 	 * NOTE: We cannot return {@code <R extends Service<T>>} here because the service might come from the parent...
 	 * 
 	 * @param serviceRole The service role
 	 * @param <R> The service role type
 	 *
 	 * @return The requested service.
 	 *
 	 * @throws UnknownServiceException Indicates the service was not known.
 	 */
 	public <R extends Service> R getService(Class<R> serviceRole);
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/ServiceRegistryBuilder.java b/hibernate-core/src/main/java/org/hibernate/service/ServiceRegistryBuilder.java
index 3395938948..6d9c358aef 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/ServiceRegistryBuilder.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/ServiceRegistryBuilder.java
@@ -1,221 +1,89 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
- * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
+ * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service;
 
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
 import java.util.Map;
-import java.util.Properties;
 
-import org.hibernate.cfg.Environment;
-import org.hibernate.integrator.spi.Integrator;
-import org.hibernate.integrator.spi.IntegratorService;
-import org.hibernate.integrator.spi.ServiceContributingIntegrator;
-import org.hibernate.internal.jaxb.cfg.JaxbHibernateConfiguration;
-import org.hibernate.internal.util.config.ConfigurationHelper;
-import org.hibernate.service.internal.BootstrapServiceRegistryImpl;
-import org.hibernate.service.internal.ProvidedService;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.StandardServiceInitiator;
 
 /**
- * Builder for standard {@link ServiceRegistry} instances.
- *
- * @author Steve Ebersole
- * 
- * @see StandardServiceRegistryImpl
- * @see BootstrapServiceRegistryBuilder
+ * @deprecated Use {@link org.hibernate.boot.registry.StandardServiceRegistryBuilder} instead
  */
-public class ServiceRegistryBuilder {
-	public static final String DEFAULT_CFG_RESOURCE_NAME = "hibernate.cfg.xml";
-
-	private final Map settings;
-	private final List<BasicServiceInitiator> initiators = standardInitiatorList();
-	private final List<ProvidedService> providedServices = new ArrayList<ProvidedService>();
-
-	private final BootstrapServiceRegistry bootstrapServiceRegistry;
-	private final ConfigLoader configLoader;
-
-	/**
-	 * Create a default builder
-	 */
+@Deprecated
+public class ServiceRegistryBuilder extends org.hibernate.boot.registry.StandardServiceRegistryBuilder {
 	public ServiceRegistryBuilder() {
-		this( new BootstrapServiceRegistryImpl() );
+		super();    //To change body of overridden methods use File | Settings | File Templates.
 	}
 
-	/**
-	 * Create a builder with the specified bootstrap services.
-	 *
-	 * @param bootstrapServiceRegistry Provided bootstrap registry to use.
-	 */
 	public ServiceRegistryBuilder(BootstrapServiceRegistry bootstrapServiceRegistry) {
-		this.settings = Environment.getProperties();
-		this.bootstrapServiceRegistry = bootstrapServiceRegistry;
-		this.configLoader = new ConfigLoader( bootstrapServiceRegistry );
-	}
-
-	/**
-	 * Used from the {@link #initiators} variable initializer
-	 *
-	 * @return List of standard initiators
-	 */
-	private static List<BasicServiceInitiator> standardInitiatorList() {
-		final List<BasicServiceInitiator> initiators = new ArrayList<BasicServiceInitiator>();
-		initiators.addAll( StandardServiceInitiators.LIST );
-		return initiators;
+		super( bootstrapServiceRegistry );    //To change body of overridden methods use File | Settings | File Templates.
 	}
 
-	/**
-	 * Read settings from a {@link Properties} file.  Differs from {@link #configure()} and {@link #configure(String)}
-	 * in that here we read a {@link Properties} file while for {@link #configure} we read the XML variant.
-	 *
-	 * @param resourceName The name by which to perform a resource look up for the properties file.
-	 *
-	 * @return this, for method chaining
-	 *
-	 * @see #configure()
-	 * @see #configure(String)
-	 */
-	@SuppressWarnings( {"unchecked"})
+	@Override
 	public ServiceRegistryBuilder loadProperties(String resourceName) {
-		settings.putAll( configLoader.loadProperties( resourceName ) );
+		super.loadProperties( resourceName );
 		return this;
 	}
 
-	/**
-	 * Read setting information from an XML file using the standard resource location
-	 *
-	 * @return this, for method chaining
-	 *
-	 * @see #DEFAULT_CFG_RESOURCE_NAME
-	 * @see #configure(String)
-	 * @see #loadProperties(String)
-	 */
+	@Override
 	public ServiceRegistryBuilder configure() {
-		return configure( DEFAULT_CFG_RESOURCE_NAME );
+		super.configure();
+		return this;
 	}
 
-	/**
-	 * Read setting information from an XML file using the named resource location
-	 *
-	 * @param resourceName The named resource
-	 *
-	 * @return this, for method chaining
-	 *
-	 * @see #loadProperties(String)
-	 */
-	@SuppressWarnings( {"unchecked"})
+	@Override
 	public ServiceRegistryBuilder configure(String resourceName) {
-		JaxbHibernateConfiguration configurationElement = configLoader.loadConfigXmlResource( resourceName );
-		for ( JaxbHibernateConfiguration.JaxbSessionFactory.JaxbProperty xmlProperty : configurationElement.getSessionFactory().getProperty() ) {
-			settings.put( xmlProperty.getName(), xmlProperty.getValue() );
-		}
-
+		super.configure( resourceName );
 		return this;
 	}
 
-	/**
-	 * Apply a setting value
-	 *
-	 * @param settingName The name of the setting
-	 * @param value The value to use.
-	 *
-	 * @return this, for method chaining
-	 */
-	@SuppressWarnings( {"unchecked", "UnusedDeclaration"})
+	@Override
 	public ServiceRegistryBuilder applySetting(String settingName, Object value) {
-		settings.put( settingName, value );
+		super.applySetting( settingName, value );
 		return this;
 	}
 
-	/**
-	 * Apply a groups of setting values
-	 *
-	 * @param settings The incoming settings to apply
-	 *
-	 * @return this, for method chaining
-	 */
-	@SuppressWarnings( {"unchecked", "UnusedDeclaration"})
+	@Override
 	public ServiceRegistryBuilder applySettings(Map settings) {
-		this.settings.putAll( settings );
+		super.applySettings( settings );
 		return this;
 	}
 
-	/**
-	 * Adds a service initiator.
-	 *
-	 * @param initiator The initiator to be added
-	 *
-	 * @return this, for method chaining
-	 */
-	@SuppressWarnings( {"UnusedDeclaration"})
-	public ServiceRegistryBuilder addInitiator(BasicServiceInitiator initiator) {
-		initiators.add( initiator );
+	@Override
+	public ServiceRegistryBuilder addInitiator(StandardServiceInitiator initiator) {
+		super.addInitiator( initiator );
 		return this;
 	}
 
-	/**
-	 * Adds a user-provided service
-	 *
-	 * @param serviceRole The role of the service being added
-	 * @param service The service implementation
-	 *
-	 * @return this, for method chaining
-	 */
-	@SuppressWarnings( {"unchecked"})
-	public ServiceRegistryBuilder addService(final Class serviceRole, final Service service) {
-		providedServices.add( new ProvidedService( serviceRole, service ) );
+	@Override
+	public ServiceRegistryBuilder addService(Class serviceRole, Service service) {
+		super.addService( serviceRole, service );
 		return this;
 	}
 
-	/**
-	 * Build the service registry accounting for all settings and service initiators and services.
-	 *
-	 * @return The built service registry
-	 */
+	@Override
 	public ServiceRegistry buildServiceRegistry() {
-		Map<?,?> settingsCopy = new HashMap();
-		settingsCopy.putAll( settings );
-		Environment.verifyProperties( settingsCopy );
-		ConfigurationHelper.resolvePlaceHolders( settingsCopy );
-
-		for ( Integrator integrator : bootstrapServiceRegistry.getService( IntegratorService.class ).getIntegrators() ) {
-			if ( ServiceContributingIntegrator.class.isInstance( integrator ) ) {
-				ServiceContributingIntegrator.class.cast( integrator ).prepareServices( this );
-			}
-		}
-
-		return new StandardServiceRegistryImpl( bootstrapServiceRegistry, initiators, providedServices, settingsCopy );
-	}
-
-	/**
-	 * Destroy a service registry.  Applications should only destroy registries they have explicitly created.
-	 *
-	 * @param serviceRegistry The registry to be closed.
-	 */
-	public static void destroy(ServiceRegistry serviceRegistry) {
-		( (StandardServiceRegistryImpl) serviceRegistry ).destroy();
+		return super.buildServiceRegistry();
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/StandardServiceInitiators.java b/hibernate-core/src/main/java/org/hibernate/service/StandardServiceInitiators.java
index 8d630f0953..2ef6115e72 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/StandardServiceInitiators.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/StandardServiceInitiators.java
@@ -1,89 +1,89 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service;
 
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.cache.internal.RegionFactoryInitiator;
 import org.hibernate.engine.jdbc.batch.internal.BatchBuilderInitiator;
 import org.hibernate.engine.jdbc.internal.JdbcServicesInitiator;
 import org.hibernate.engine.transaction.internal.TransactionFactoryInitiator;
 import org.hibernate.id.factory.internal.MutableIdentifierGeneratorFactoryInitiator;
 import org.hibernate.persister.internal.PersisterClassResolverInitiator;
 import org.hibernate.persister.internal.PersisterFactoryInitiator;
-import org.hibernate.service.config.internal.ConfigurationServiceInitiator;
+import org.hibernate.engine.config.internal.ConfigurationServiceInitiator;
 import org.hibernate.service.internal.SessionFactoryServiceRegistryFactoryInitiator;
-import org.hibernate.service.jdbc.connections.internal.ConnectionProviderInitiator;
-import org.hibernate.service.jdbc.connections.internal.MultiTenantConnectionProviderInitiator;
-import org.hibernate.service.jdbc.cursor.internal.RefCursorSupportInitiator;
-import org.hibernate.service.jdbc.dialect.internal.DialectFactoryInitiator;
-import org.hibernate.service.jdbc.dialect.internal.DialectResolverInitiator;
-import org.hibernate.service.jmx.internal.JmxServiceInitiator;
-import org.hibernate.service.jndi.internal.JndiServiceInitiator;
-import org.hibernate.service.jta.platform.internal.JtaPlatformInitiator;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.engine.jdbc.connections.internal.ConnectionProviderInitiator;
+import org.hibernate.engine.jdbc.connections.internal.MultiTenantConnectionProviderInitiator;
+import org.hibernate.engine.jdbc.cursor.internal.RefCursorSupportInitiator;
+import org.hibernate.engine.jdbc.dialect.internal.DialectFactoryInitiator;
+import org.hibernate.engine.jdbc.dialect.internal.DialectResolverInitiator;
+import org.hibernate.jmx.internal.JmxServiceInitiator;
+import org.hibernate.engine.jndi.internal.JndiServiceInitiator;
+import org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformInitiator;
 import org.hibernate.tool.hbm2ddl.ImportSqlCommandExtractorInitiator;
 
 /**
  * Central definition of the standard set of service initiators defined by Hibernate.
  * 
  * @author Steve Ebersole
  */
 public class StandardServiceInitiators {
-	public static List<BasicServiceInitiator> LIST = buildStandardServiceInitiatorList();
+	public static List<StandardServiceInitiator> LIST = buildStandardServiceInitiatorList();
 
-	private static List<BasicServiceInitiator> buildStandardServiceInitiatorList() {
-		final List<BasicServiceInitiator> serviceInitiators = new ArrayList<BasicServiceInitiator>();
+	private static List<StandardServiceInitiator> buildStandardServiceInitiatorList() {
+		final List<StandardServiceInitiator> serviceInitiators = new ArrayList<StandardServiceInitiator>();
 
 		serviceInitiators.add( ConfigurationServiceInitiator.INSTANCE );
 		serviceInitiators.add( ImportSqlCommandExtractorInitiator.INSTANCE );
 
 		serviceInitiators.add( JndiServiceInitiator.INSTANCE );
 		serviceInitiators.add( JmxServiceInitiator.INSTANCE );
 
 		serviceInitiators.add( PersisterClassResolverInitiator.INSTANCE );
 		serviceInitiators.add( PersisterFactoryInitiator.INSTANCE );
 
 		serviceInitiators.add( ConnectionProviderInitiator.INSTANCE );
 		serviceInitiators.add( MultiTenantConnectionProviderInitiator.INSTANCE );
 		serviceInitiators.add( DialectResolverInitiator.INSTANCE );
 		serviceInitiators.add( DialectFactoryInitiator.INSTANCE );
 		serviceInitiators.add( BatchBuilderInitiator.INSTANCE );
 		serviceInitiators.add( JdbcServicesInitiator.INSTANCE );
 		serviceInitiators.add( RefCursorSupportInitiator.INSTANCE );
 
 		serviceInitiators.add( MutableIdentifierGeneratorFactoryInitiator.INSTANCE);
 
 		serviceInitiators.add( JtaPlatformInitiator.INSTANCE );
 		serviceInitiators.add( TransactionFactoryInitiator.INSTANCE );
 
 		serviceInitiators.add( SessionFactoryServiceRegistryFactoryInitiator.INSTANCE );
 
 		serviceInitiators.add( RegionFactoryInitiator.INSTANCE );
 
 		return Collections.unmodifiableList( serviceInitiators );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/internal/AbstractServiceRegistryImpl.java b/hibernate-core/src/main/java/org/hibernate/service/internal/AbstractServiceRegistryImpl.java
index dda22639b0..0b160a1636 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/internal/AbstractServiceRegistryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/internal/AbstractServiceRegistryImpl.java
@@ -1,291 +1,291 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.internal;
 
 import java.lang.reflect.Method;
 import java.util.List;
 import java.util.ListIterator;
 import java.util.concurrent.ConcurrentHashMap;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.collections.CollectionHelper;
-import org.hibernate.service.BootstrapServiceRegistry;
+import org.hibernate.boot.registry.BootstrapServiceRegistry;
 import org.hibernate.service.Service;
 import org.hibernate.service.ServiceRegistry;
 import org.hibernate.service.UnknownServiceException;
-import org.hibernate.service.jmx.spi.JmxService;
+import org.hibernate.jmx.spi.JmxService;
 import org.hibernate.service.spi.InjectService;
 import org.hibernate.service.spi.Manageable;
 import org.hibernate.service.spi.ServiceBinding;
 import org.hibernate.service.spi.ServiceException;
 import org.hibernate.service.spi.ServiceInitiator;
 import org.hibernate.service.spi.ServiceRegistryAwareService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.Startable;
 import org.hibernate.service.spi.Stoppable;
 
 /**
  * @author Steve Ebersole
  */
 public abstract class AbstractServiceRegistryImpl
 		implements ServiceRegistryImplementor, ServiceBinding.ServiceLifecycleOwner {
 
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger(
 			CoreMessageLogger.class,
 			AbstractServiceRegistryImpl.class.getName()
 	);
 
 	private final ServiceRegistryImplementor parent;
 
 	private final ConcurrentHashMap<Class,ServiceBinding> serviceBindingMap = CollectionHelper.concurrentMap( 20 );
 
 	// IMPL NOTE : the list used for ordered destruction.  Cannot used map above because we need to
 	// iterate it in reverse order which is only available through ListIterator
 	// assume 20 services for initial sizing
 	private final List<ServiceBinding> serviceBindingList = CollectionHelper.arrayList( 20 );
 
 	@SuppressWarnings( {"UnusedDeclaration"})
 	protected AbstractServiceRegistryImpl() {
 		this( (ServiceRegistryImplementor) null );
 	}
 
 	protected AbstractServiceRegistryImpl(ServiceRegistryImplementor parent) {
 		this.parent = parent;
 	}
 
 	public AbstractServiceRegistryImpl(BootstrapServiceRegistry bootstrapServiceRegistry) {
 		if ( ! ServiceRegistryImplementor.class.isInstance( bootstrapServiceRegistry ) ) {
 			throw new IllegalArgumentException( "Boot-strap registry was not " );
 		}
 		this.parent = (ServiceRegistryImplementor) bootstrapServiceRegistry;
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	protected <R extends Service> void createServiceBinding(ServiceInitiator<R> initiator) {
 		serviceBindingMap.put( initiator.getServiceInitiated(), new ServiceBinding( this, initiator ) );
 	}
 
 	protected <R extends Service> void createServiceBinding(ProvidedService<R> providedService) {
 		ServiceBinding<R> binding = locateServiceBinding( providedService.getServiceRole(), false );
 		if ( binding == null ) {
 			binding = new ServiceBinding<R>( this, providedService.getServiceRole(), providedService.getService() );
 			serviceBindingMap.put( providedService.getServiceRole(), binding );
 		}
 		registerService( binding, providedService.getService() );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public ServiceRegistry getParentServiceRegistry() {
 		return parent;
 	}
 
 	@Override
 	@SuppressWarnings({ "unchecked" })
 	public <R extends Service> ServiceBinding<R> locateServiceBinding(Class<R> serviceRole) {
 		return locateServiceBinding( serviceRole, true );
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	protected <R extends Service> ServiceBinding<R> locateServiceBinding(Class<R> serviceRole, boolean checkParent) {
 		ServiceBinding<R> serviceBinding = serviceBindingMap.get( serviceRole );
 		if ( serviceBinding == null && checkParent && parent != null ) {
 			// look in parent
 			serviceBinding = parent.locateServiceBinding( serviceRole );
 		}
 		return serviceBinding;
 	}
 
 	@Override
 	public <R extends Service> R getService(Class<R> serviceRole) {
 		final ServiceBinding<R> serviceBinding = locateServiceBinding( serviceRole );
 		if ( serviceBinding == null ) {
 			throw new UnknownServiceException( serviceRole );
 		}
 
 		R service = serviceBinding.getService();
 		if ( service == null ) {
 			service = initializeService( serviceBinding );
 		}
 
 		return service;
 	}
 
 	protected <R extends Service> void registerService(ServiceBinding<R> serviceBinding, R service) {
 		serviceBinding.setService( service );
 		synchronized ( serviceBindingList ) {
 			serviceBindingList.add( serviceBinding );
 		}
 	}
 
 	private <R extends Service> R initializeService(ServiceBinding<R> serviceBinding) {
 		if ( LOG.isTraceEnabled() ) {
 			LOG.tracev( "Initializing service [role={0}]", serviceBinding.getServiceRole().getName() );
 		}
 
 		// PHASE 1 : create service
 		R service = createService( serviceBinding );
 		if ( service == null ) {
 			return null;
 		}
 
 		// PHASE 2 : inject service (***potentially recursive***)
 		serviceBinding.getLifecycleOwner().injectDependencies( serviceBinding );
 
 		// PHASE 3 : configure service
 		serviceBinding.getLifecycleOwner().configureService( serviceBinding );
 
 		// PHASE 4 : Start service
 		serviceBinding.getLifecycleOwner().startService( serviceBinding );
 
 		return service;
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	protected <R extends Service> R createService(ServiceBinding<R> serviceBinding) {
 		final ServiceInitiator<R> serviceInitiator = serviceBinding.getServiceInitiator();
 		if ( serviceInitiator == null ) {
 			// this condition should never ever occur
 			throw new UnknownServiceException( serviceBinding.getServiceRole() );
 		}
 
 		try {
 			R service = serviceBinding.getLifecycleOwner().initiateService( serviceInitiator );
 			// IMPL NOTE : the register call here is important to avoid potential stack overflow issues
 			//		from recursive calls through #configureService
 			registerService( serviceBinding, service );
 			return service;
 		}
 		catch ( ServiceException e ) {
 			throw e;
 		}
 		catch ( Exception e ) {
 			throw new ServiceException( "Unable to create requested service [" + serviceBinding.getServiceRole().getName() + "]", e );
 		}
 	}
 
 	@Override
 	public <R extends Service> void injectDependencies(ServiceBinding<R> serviceBinding) {
 		final R service = serviceBinding.getService();
 
 		applyInjections( service );
 
 		if ( ServiceRegistryAwareService.class.isInstance( service ) ) {
 			( (ServiceRegistryAwareService) service ).injectServices( this );
 		}
 	}
 
 	private <R extends Service> void applyInjections(R service) {
 		try {
 			for ( Method method : service.getClass().getMethods() ) {
 				InjectService injectService = method.getAnnotation( InjectService.class );
 				if ( injectService == null ) {
 					continue;
 				}
 
 				processInjection( service, method, injectService );
 			}
 		}
 		catch (NullPointerException e) {
             LOG.error("NPE injecting service deps : " + service.getClass().getName());
 		}
 	}
 
 	@SuppressWarnings({ "unchecked" })
 	private <T extends Service> void processInjection(T service, Method injectionMethod, InjectService injectService) {
 		if ( injectionMethod.getParameterTypes() == null || injectionMethod.getParameterTypes().length != 1 ) {
 			throw new ServiceDependencyException(
 					"Encountered @InjectService on method with unexpected number of parameters"
 			);
 		}
 
 		Class dependentServiceRole = injectService.serviceRole();
 		if ( dependentServiceRole == null || dependentServiceRole.equals( Void.class ) ) {
 			dependentServiceRole = injectionMethod.getParameterTypes()[0];
 		}
 
 		// todo : because of the use of proxies, this is no longer returning null here...
 
 		final Service dependantService = getService( dependentServiceRole );
 		if ( dependantService == null ) {
 			if ( injectService.required() ) {
 				throw new ServiceDependencyException(
 						"Dependency [" + dependentServiceRole + "] declared by service [" + service + "] not found"
 				);
 			}
 		}
 		else {
 			try {
 				injectionMethod.invoke( service, dependantService );
 			}
 			catch ( Exception e ) {
 				throw new ServiceDependencyException( "Cannot inject dependency service", e );
 			}
 		}
 	}
 
 	@Override
 	@SuppressWarnings({ "unchecked" })
 	public <R extends Service> void startService(ServiceBinding<R> serviceBinding) {
 		if ( Startable.class.isInstance( serviceBinding.getService() ) ) {
 			( (Startable) serviceBinding.getService() ).start();
 		}
 
 		if ( Manageable.class.isInstance( serviceBinding.getService() ) ) {
 			getService( JmxService.class ).registerService(
 					(Manageable) serviceBinding.getService(),
 					serviceBinding.getServiceRole()
 			);
 		}
 	}
 
 	@Override
     @SuppressWarnings( {"unchecked"})
 	public void destroy() {
 		synchronized ( serviceBindingList ) {
 			ListIterator<ServiceBinding> serviceBindingsIterator = serviceBindingList.listIterator( serviceBindingList.size() );
 			while ( serviceBindingsIterator.hasPrevious() ) {
 				final ServiceBinding serviceBinding = serviceBindingsIterator.previous();
 				serviceBinding.getLifecycleOwner().stopService( serviceBinding );
 			}
 			serviceBindingList.clear();
 		}
 		serviceBindingMap.clear();
 	}
 
 	@Override
 	public <R extends Service> void stopService(ServiceBinding<R> binding) {
 		final Service service = binding.getService();
 		if ( Stoppable.class.isInstance( service ) ) {
 			try {
 				( (Stoppable) service ).stop();
 			}
 			catch ( Exception e ) {
 				LOG.unableToStopService( service.getClass(), e.toString() );
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/internal/JaxbProcessor.java b/hibernate-core/src/main/java/org/hibernate/service/internal/JaxbProcessor.java
index baa1485f06..19b8e617d4 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/internal/JaxbProcessor.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/internal/JaxbProcessor.java
@@ -1,282 +1,282 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.internal;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import javax.xml.XMLConstants;
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Unmarshaller;
 import javax.xml.bind.ValidationEvent;
 import javax.xml.bind.ValidationEventHandler;
 import javax.xml.bind.ValidationEventLocator;
 import javax.xml.namespace.QName;
 import javax.xml.stream.XMLEventFactory;
 import javax.xml.stream.XMLEventReader;
 import javax.xml.stream.XMLInputFactory;
 import javax.xml.stream.XMLStreamException;
 import javax.xml.stream.events.Namespace;
 import javax.xml.stream.events.StartElement;
 import javax.xml.stream.events.XMLEvent;
 import javax.xml.stream.util.EventReaderDelegate;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 
 import org.jboss.logging.Logger;
 import org.xml.sax.SAXException;
 
 import org.hibernate.internal.jaxb.Origin;
 import org.hibernate.internal.jaxb.cfg.JaxbHibernateConfiguration;
 import org.hibernate.internal.util.config.ConfigurationException;
 import org.hibernate.metamodel.source.MappingException;
 import org.hibernate.metamodel.source.XsdException;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 /**
  * @author Steve Ebersole
  */
 public class JaxbProcessor {
 	private static final Logger log = Logger.getLogger( JaxbProcessor.class );
 
 	public static final String HIBERNATE_CONFIGURATION_URI = "http://www.hibernate.org/xsd/hibernate-configuration";
 
 	private final ClassLoaderService classLoaderService;
 
 	public JaxbProcessor(ClassLoaderService classLoaderService) {
 		this.classLoaderService = classLoaderService;
 	}
 
 	public JaxbHibernateConfiguration unmarshal(InputStream stream, Origin origin) {
 		try {
 			XMLEventReader staxReader = staxFactory().createXMLEventReader( stream );
 			try {
 				return unmarshal( staxReader, origin );
 			}
 			finally {
 				try {
 					staxReader.close();
 				}
 				catch ( Exception ignore ) {
 				}
 			}
 		}
 		catch ( XMLStreamException e ) {
 			throw new MappingException( "Unable to create stax reader", e, origin );
 		}
 	}
 
 	private XMLInputFactory staxFactory;
 
 	private XMLInputFactory staxFactory() {
 		if ( staxFactory == null ) {
 			staxFactory = buildStaxFactory();
 		}
 		return staxFactory;
 	}
 
 	@SuppressWarnings( { "UnnecessaryLocalVariable" })
 	private XMLInputFactory buildStaxFactory() {
 		XMLInputFactory staxFactory = XMLInputFactory.newInstance();
 		return staxFactory;
 	}
 
 	@SuppressWarnings( { "unchecked" })
 	private JaxbHibernateConfiguration unmarshal(XMLEventReader staxEventReader, final Origin origin) {
 		XMLEvent event;
 		try {
 			event = staxEventReader.peek();
 			while ( event != null && !event.isStartElement() ) {
 				staxEventReader.nextEvent();
 				event = staxEventReader.peek();
 			}
 		}
 		catch ( Exception e ) {
 			throw new MappingException( "Error accessing stax stream", e, origin );
 		}
 
 		if ( event == null ) {
 			throw new MappingException( "Could not locate root element", origin );
 		}
 
 		if ( !isNamespaced( event.asStartElement() ) ) {
 			// if the elements are not namespaced, wrap the reader in a reader which will namespace them as pulled.
 			log.debug( "cfg.xml document did not define namespaces; wrapping in custom event reader to introduce namespace information" );
 			staxEventReader = new NamespaceAddingEventReader( staxEventReader, HIBERNATE_CONFIGURATION_URI );
 		}
 
 		final Object target;
 		final ContextProvidingValidationEventHandler handler = new ContextProvidingValidationEventHandler();
 		try {
 			JAXBContext jaxbContext = JAXBContext.newInstance( JaxbHibernateConfiguration.class );
 			Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
 			unmarshaller.setSchema( schema() );
 			unmarshaller.setEventHandler( handler );
 			target = unmarshaller.unmarshal( staxEventReader );
 			return (JaxbHibernateConfiguration) target;
 		}
 		catch ( JAXBException e ) {
 			StringBuilder builder = new StringBuilder();
 			builder.append( "Unable to perform unmarshalling at line number " )
 					.append( handler.getLineNumber() )
 					.append( " and column " )
 					.append( handler.getColumnNumber() )
 					.append( " in " ).append( origin.getType().name() ).append( " " ).append( origin.getName() )
 					.append( ". Message: " )
 					.append( handler.getMessage() );
 			throw new ConfigurationException( builder.toString(), e );
 		}
 	}
 
 	private boolean isNamespaced(StartElement startElement) {
 		return ! "".equals( startElement.getName().getNamespaceURI() );
 	}
 
 	private Schema schema;
 
 	private Schema schema() {
 		if ( schema == null ) {
 			schema = resolveLocalSchema( "org/hibernate/hibernate-configuration-4.0.xsd" );
 		}
 		return schema;
 	}
 
 	private Schema resolveLocalSchema(String schemaName) {
 		return resolveLocalSchema( schemaName, XMLConstants.W3C_XML_SCHEMA_NS_URI );
 	}
 
 	private Schema resolveLocalSchema(String schemaName, String schemaLanguage) {
 		URL url = classLoaderService.locateResource( schemaName );
 		if ( url == null ) {
 			throw new XsdException( "Unable to locate schema [" + schemaName + "] via classpath", schemaName );
 		}
 		try {
 			InputStream schemaStream = url.openStream();
 			try {
 				StreamSource source = new StreamSource( url.openStream() );
 				SchemaFactory schemaFactory = SchemaFactory.newInstance( schemaLanguage );
 				return schemaFactory.newSchema( source );
 			}
 			catch ( SAXException e ) {
 				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
 			}
 			catch ( IOException e ) {
 				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
 			}
 			finally {
 				try {
 					schemaStream.close();
 				}
 				catch ( IOException e ) {
 					log.debugf( "Problem closing schema stream [%s]", e.toString() );
 				}
 			}
 		}
 		catch ( IOException e ) {
 			throw new XsdException( "Stream error handling schema url [" + url.toExternalForm() + "]", schemaName );
 		}
 	}
 
 	static class ContextProvidingValidationEventHandler implements ValidationEventHandler {
 		private int lineNumber;
 		private int columnNumber;
 		private String message;
 
 		@Override
 		public boolean handleEvent(ValidationEvent validationEvent) {
 			ValidationEventLocator locator = validationEvent.getLocator();
 			lineNumber = locator.getLineNumber();
 			columnNumber = locator.getColumnNumber();
 			message = validationEvent.getMessage();
 			return false;
 		}
 
 		public int getLineNumber() {
 			return lineNumber;
 		}
 
 		public int getColumnNumber() {
 			return columnNumber;
 		}
 
 		public String getMessage() {
 			return message;
 		}
 	}
 
 	public class NamespaceAddingEventReader extends EventReaderDelegate {
 		private final XMLEventFactory xmlEventFactory;
 		private final String namespaceUri;
 
 		public NamespaceAddingEventReader(XMLEventReader reader, String namespaceUri) {
 			this( reader, XMLEventFactory.newInstance(), namespaceUri );
 		}
 
 		public NamespaceAddingEventReader(XMLEventReader reader, XMLEventFactory xmlEventFactory, String namespaceUri) {
 			super( reader );
 			this.xmlEventFactory = xmlEventFactory;
 			this.namespaceUri = namespaceUri;
 		}
 
 		private StartElement withNamespace(StartElement startElement) {
 			// otherwise, wrap the start element event to provide a default namespace mapping
 			final List<Namespace> namespaces = new ArrayList<Namespace>();
 			namespaces.add( xmlEventFactory.createNamespace( "", namespaceUri ) );
 			Iterator<?> originalNamespaces = startElement.getNamespaces();
 			while ( originalNamespaces.hasNext() ) {
 				namespaces.add( (Namespace) originalNamespaces.next() );
 			}
 			return xmlEventFactory.createStartElement(
 					new QName( namespaceUri, startElement.getName().getLocalPart() ),
 					startElement.getAttributes(),
 					namespaces.iterator()
 			);
 		}
 
 		@Override
 		public XMLEvent nextEvent() throws XMLStreamException {
 			XMLEvent event = super.nextEvent();
 			if ( event.isStartElement() ) {
 				return withNamespace( event.asStartElement() );
 			}
 			return event;
 		}
 
 		@Override
 		public XMLEvent peek() throws XMLStreamException {
 			XMLEvent event = super.peek();
 			if ( event.isStartElement() ) {
 				return withNamespace( event.asStartElement() );
 			}
 			else {
 				return event;
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryImpl.java b/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryImpl.java
index dc04d9f48c..ab12132940 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryImpl.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryImpl.java
@@ -1,60 +1,60 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.internal;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.Service;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistryFactory;
 
 /**
- * Acts as a {@link Service} in the {@link StandardServiceRegistryImpl} whose function is as a factory for
+ * Acts as a {@link Service} in the {@link org.hibernate.boot.registry.internal.StandardServiceRegistryImpl} whose function is as a factory for
  * {@link SessionFactoryServiceRegistryImpl} implementations.
  *
  * @author Steve Ebersole
  */
 public class SessionFactoryServiceRegistryFactoryImpl implements SessionFactoryServiceRegistryFactory {
 	private final ServiceRegistryImplementor theBasicServiceRegistry;
 
 	public SessionFactoryServiceRegistryFactoryImpl(ServiceRegistryImplementor theBasicServiceRegistry) {
 		this.theBasicServiceRegistry = theBasicServiceRegistry;
 	}
 
 	@Override
 	public SessionFactoryServiceRegistryImpl buildServiceRegistry(
 			SessionFactoryImplementor sessionFactory,
 			Configuration configuration) {
 		return new SessionFactoryServiceRegistryImpl( theBasicServiceRegistry, sessionFactory, configuration );
 	}
 
 	@Override
 	public SessionFactoryServiceRegistryImpl buildServiceRegistry(
 			SessionFactoryImplementor sessionFactory,
 			MetadataImplementor metadata) {
 		return new SessionFactoryServiceRegistryImpl( theBasicServiceRegistry, sessionFactory, metadata );
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryInitiator.java b/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryInitiator.java
index 5cabc73b87..e935561682 100644
--- a/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/service/internal/SessionFactoryServiceRegistryFactoryInitiator.java
@@ -1,47 +1,47 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.internal;
 
 import java.util.Map;
 
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistryFactory;
 
 /**
  * @author Steve Ebersole
  */
-public class SessionFactoryServiceRegistryFactoryInitiator implements BasicServiceInitiator<SessionFactoryServiceRegistryFactory> {
+public class SessionFactoryServiceRegistryFactoryInitiator implements StandardServiceInitiator<SessionFactoryServiceRegistryFactory> {
 	public static final SessionFactoryServiceRegistryFactoryInitiator INSTANCE = new SessionFactoryServiceRegistryFactoryInitiator();
 
 	@Override
 	public Class<SessionFactoryServiceRegistryFactory> getServiceInitiated() {
 		return SessionFactoryServiceRegistryFactory.class;
 	}
 
 	@Override
 	public SessionFactoryServiceRegistryFactoryImpl initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		return new SessionFactoryServiceRegistryFactoryImpl( registry );
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/service/selector/package-info.java b/hibernate-core/src/main/java/org/hibernate/service/selector/package-info.java
deleted file mode 100644
index 885cc72a2e..0000000000
--- a/hibernate-core/src/main/java/org/hibernate/service/selector/package-info.java
+++ /dev/null
@@ -1 +0,0 @@
-package org.hibernate.service.selector;
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/stat/internal/StatisticsInitiator.java b/hibernate-core/src/main/java/org/hibernate/stat/internal/StatisticsInitiator.java
index 373f8600fb..e6b523f58a 100644
--- a/hibernate-core/src/main/java/org/hibernate/stat/internal/StatisticsInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/stat/internal/StatisticsInitiator.java
@@ -1,120 +1,120 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.stat.internal;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.config.spi.ConfigurationService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.engine.config.spi.ConfigurationService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceInitiator;
 import org.hibernate.stat.spi.StatisticsFactory;
 import org.hibernate.stat.spi.StatisticsImplementor;
 
 /**
  * @author Steve Ebersole
  */
 public class StatisticsInitiator implements SessionFactoryServiceInitiator<StatisticsImplementor> {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, StatisticsInitiator.class.getName() );
 
 	public static final StatisticsInitiator INSTANCE = new StatisticsInitiator();
 
 	/**
 	 * Names the {@link StatisticsFactory} to use.  Recognizes both a class name as well as an instance of
 	 * {@link StatisticsFactory}.
 	 */
 	public static final String STATS_BUILDER = "hibernate.stats.factory";
 
 	@Override
 	public Class<StatisticsImplementor> getServiceInitiated() {
 		return StatisticsImplementor.class;
 	}
 
 	@Override
 	public StatisticsImplementor initiateService(
 			SessionFactoryImplementor sessionFactory,
 			Configuration configuration,
 			ServiceRegistryImplementor registry) {
 		final Object configValue = configuration.getProperties().get( STATS_BUILDER );
 		return initiateServiceInternal( sessionFactory, configValue, registry );
 	}
 
 	@Override
 	public StatisticsImplementor initiateService(
 			SessionFactoryImplementor sessionFactory,
 			MetadataImplementor metadata,
 			ServiceRegistryImplementor registry) {
 		ConfigurationService configurationService =  registry.getService( ConfigurationService.class );
 		final Object configValue = configurationService.getSetting( STATS_BUILDER, null );
 		return initiateServiceInternal( sessionFactory, configValue, registry );
 	}
 
 	private StatisticsImplementor initiateServiceInternal(
 			SessionFactoryImplementor sessionFactory,
 			Object configValue,
 			ServiceRegistryImplementor registry) {
 
 		StatisticsFactory statisticsFactory;
 		if ( configValue == null ) {
 			statisticsFactory = DEFAULT_STATS_BUILDER;
 		}
 		else if ( StatisticsFactory.class.isInstance( configValue ) ) {
 			statisticsFactory = (StatisticsFactory) configValue;
 		}
 		else {
 			// assume it names the factory class
 			final ClassLoaderService classLoaderService = registry.getService( ClassLoaderService.class );
 			try {
 				statisticsFactory = (StatisticsFactory) classLoaderService.classForName( configValue.toString() ).newInstance();
 			}
 			catch (HibernateException e) {
 				throw e;
 			}
 			catch (Exception e) {
 				throw new HibernateException(
 						"Unable to instantiate specified StatisticsFactory implementation [" + configValue.toString() + "]",
 						e
 				);
 			}
 		}
 
 		StatisticsImplementor statistics = statisticsFactory.buildStatistics( sessionFactory );
 		final boolean enabled = sessionFactory.getSettings().isStatisticsEnabled();
 		statistics.setStatisticsEnabled( enabled );
 		LOG.debugf( "Statistics initialized [enabled=%s]", enabled );
 		return statistics;
 	}
 
 	private static StatisticsFactory DEFAULT_STATS_BUILDER = new StatisticsFactory() {
 		@Override
 		public StatisticsImplementor buildStatistics(SessionFactoryImplementor sessionFactory) {
 			return new ConcurrentStatisticsImpl( sessionFactory );
 		}
 	};
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/stat/spi/StatisticsImplementor.java b/hibernate-core/src/main/java/org/hibernate/stat/spi/StatisticsImplementor.java
index 985479b10a..4373587f80 100644
--- a/hibernate-core/src/main/java/org/hibernate/stat/spi/StatisticsImplementor.java
+++ b/hibernate-core/src/main/java/org/hibernate/stat/spi/StatisticsImplementor.java
@@ -1,252 +1,252 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.stat.spi;
 
 import org.hibernate.service.Service;
 import org.hibernate.stat.Statistics;
 
 /**
  * Statistics SPI for the Hibernate core.  This is essentially the "statistic collector" API, its the contract
  * called to collect various stats.
  * 
  * @author Emmanuel Bernard
  */
 public interface StatisticsImplementor extends Statistics, Service {
 	/**
 	 * Callback about a session being opened.
 	 */
 	public void openSession();
 
 	/**
 	 * Callback about a session being closed.
 	 */
 	public void closeSession();
 
 	/**
 	 * Callback about a flush occurring
 	 */
 	public void flush();
 
 	/**
-	 * Callback about a connection being obtained from {@link org.hibernate.service.jdbc.connections.spi.ConnectionProvider}
+	 * Callback about a connection being obtained from {@link org.hibernate.engine.jdbc.connections.spi.ConnectionProvider}
 	 */
 	public void connect();
 
 	/**
 	 * Callback about a statement being prepared.
 	 */
 	public void prepareStatement();
 
 	/**
 	 * Callback about a statement being closed.
 	 */
 	public void closeStatement();
 
 	/**
 	 * Callback about a transaction completing.
 	 *
 	 * @param success Was the transaction successful?
 	 */
 	public void endTransaction(boolean success);
 
 	/**
 	 * Callback about an entity being loaded.  This might indicate a proxy or a fully initialized entity, but in either
 	 * case it means without a separate SQL query being needed.
 	 *
 	 * @param entityName The name of the entity loaded.
 	 */
 	public void loadEntity(String entityName);
 
 	/**
 	 * Callback about an entity being fetched.  Unlike {@link #loadEntity} this indicates a separate query being
 	 * performed.
 	 *
 	 * @param entityName The name of the entity fetched.
 	 */
 	public void fetchEntity(String entityName);
 
 	/**
 	 * Callback about an entity being updated.
 	 *
 	 * @param entityName The name of the entity updated.
 	 */
 	public void updateEntity(String entityName);
 
 	/**
 	 * Callback about an entity being inserted
 	 *
 	 * @param entityName The name of the entity inserted
 	 */
 	public void insertEntity(String entityName);
 
 	/**
 	 * Callback about an entity being deleted.
 	 *
 	 * @param entityName The name of the entity deleted.
 	 */
 	public void deleteEntity(String entityName);
 
 	/**
 	 * Callback about an optimistic lock failure on an entity
 	 *
 	 * @param entityName The name of the entity.
 	 */
 	public void optimisticFailure(String entityName);
 
 	/**
 	 * Callback about a collection loading.  This might indicate a lazy collection or an initialized collection being
 	 * created, but in either case it means without a separate SQL query being needed.
 	 *
 	 * @param role The collection role.
 	 */
 	public void loadCollection(String role);
 
 	/**
 	 * Callback to indicate a collection being fetched.  Unlike {@link #loadCollection}, this indicates a separate
 	 * query was needed.
 	 *
 	 * @param role The collection role.
 	 */
 	public void fetchCollection(String role);
 
 	/**
 	 * Callback indicating a collection was updated.
 	 *
 	 * @param role The collection role.
 	 */
 	public void updateCollection(String role);
 
 	/**
 	 * Callback indicating a collection recreation (full deletion + full (re-)insertion).
 	 *
 	 * @param role The collection role.
 	 */
 	public void recreateCollection(String role);
 
 	/**
 	 * Callback indicating a collection removal.
 	 *
 	 * @param role The collection role.
 	 */
 	public void removeCollection(String role);
 
 	/**
 	 * Callback indicating a put into second level cache.
 	 *
 	 * @param regionName The name of the cache region
 	 */
 	public void secondLevelCachePut(String regionName);
 
 	/**
 	 * Callback indicating a get from second level cache resulted in a hit.
 	 *
 	 * @param regionName The name of the cache region
 	 */
 	public void secondLevelCacheHit(String regionName);
 
 	/**
 	 * Callback indicating a get from second level cache resulted in a miss.
 	 *
 	 * @param regionName The name of the cache region
 	 */
 	public void secondLevelCacheMiss(String regionName);
 	
 	/**
 	 * Callback indicating a put into natural id cache.
 	 *
 	 * @param regionName The name of the cache region
 	 */
 	public void naturalIdCachePut(String regionName);
 	
 	/**
 	 * Callback indicating a get from natural id cache resulted in a hit.
 	 *
 	 * @param regionName The name of the cache region
 	 */
 	public void naturalIdCacheHit(String regionName);
 	
 	/**
 	 * Callback indicating a get from natural id cache resulted in a miss.
 	 *
 	 * @param regionName The name of the cache region
 	 */
 	public void naturalIdCacheMiss(String regionName);
 
 	/**
 	 * Callback indicating execution of a natural id query
 	 *
 	 * @param regionName The name of the cache region
 	 * @param time execution time
 	 */
 	public void naturalIdQueryExecuted(String regionName, long time);
 
 	/**
 	 * Callback indicating a put into the query cache.
 	 *
 	 * @param hql The query
 	 * @param regionName The cache region
 	 */
 	public void queryCachePut(String hql, String regionName);
 
 	/**
 	 * Callback indicating a get from the query cache resulted in a hit.
 	 *
 	 * @param hql The query
 	 * @param regionName The name of the cache region
 	 */
 	public void queryCacheHit(String hql, String regionName);
 
 	/**
 	 * Callback indicating a get from the query cache resulted in a miss.
 	 *
 	 * @param hql The query
 	 * @param regionName The name of the cache region
 	 */
 	public void queryCacheMiss(String hql, String regionName);
 
 	/**
 	 * Callback indicating execution of a sql/hql query
 	 *
 	 * @param hql The query
 	 * @param rows Number of rows returned
 	 * @param time execution time
 	 */
 	public void queryExecuted(String hql, int rows, long time);
 
 
 	/**
 	 * Callback indicating a hit to the timestamp cache
 	 */
 	public void updateTimestampsCacheHit();
 
 	/**
 	 * Callback indicating a miss to the timestamp cache
 	 */
 	public void updateTimestampsCacheMiss();
 
 	/**
 	 * Callback indicating a put to the timestamp cache
 	 */
 	public void updateTimestampsCachePut();
 }
\ No newline at end of file
diff --git a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/ImportSqlCommandExtractorInitiator.java b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/ImportSqlCommandExtractorInitiator.java
index 6ea13eef8f..7f6a75552d 100644
--- a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/ImportSqlCommandExtractorInitiator.java
+++ b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/ImportSqlCommandExtractorInitiator.java
@@ -1,48 +1,48 @@
 package org.hibernate.tool.hbm2ddl;
 
 import java.util.Map;
 
 import org.hibernate.HibernateException;
+import org.hibernate.boot.registry.StandardServiceInitiator;
 import org.hibernate.cfg.Environment;
 import org.hibernate.internal.util.StringHelper;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.spi.BasicServiceInitiator;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * Instantiates and configures an appropriate {@link ImportSqlCommandExtractor}. By default
  * {@link SingleLineSqlCommandExtractor} is used.
  *
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
-public class ImportSqlCommandExtractorInitiator implements BasicServiceInitiator<ImportSqlCommandExtractor> {
+public class ImportSqlCommandExtractorInitiator implements StandardServiceInitiator<ImportSqlCommandExtractor> {
 	public static final ImportSqlCommandExtractorInitiator INSTANCE = new ImportSqlCommandExtractorInitiator();
 	public static final ImportSqlCommandExtractor DEFAULT_EXTRACTOR = new SingleLineSqlCommandExtractor();
 
 	@Override
 	public ImportSqlCommandExtractor initiateService(Map configurationValues, ServiceRegistryImplementor registry) {
 		String extractorClassName = (String) configurationValues.get( Environment.HBM2DDL_IMPORT_FILES_SQL_EXTRACTOR );
 		if ( StringHelper.isEmpty( extractorClassName ) ) {
 			return DEFAULT_EXTRACTOR;
 		}
 		final ClassLoaderService classLoaderService = registry.getService( ClassLoaderService.class );
 		return instantiateExplicitCommandExtractor( extractorClassName, classLoaderService );
 	}
 
 	private ImportSqlCommandExtractor instantiateExplicitCommandExtractor(String extractorClassName,
 																		  ClassLoaderService classLoaderService) {
 		try {
 			return (ImportSqlCommandExtractor) classLoaderService.classForName( extractorClassName ).newInstance();
 		}
 		catch ( Exception e ) {
 			throw new HibernateException(
 					"Could not instantiate import sql command extractor [" + extractorClassName + "]", e
 			);
 		}
 	}
 
 	@Override
 	public Class<ImportSqlCommandExtractor> getServiceInitiated() {
 		return ImportSqlCommandExtractor.class;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/ManagedProviderConnectionHelper.java b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/ManagedProviderConnectionHelper.java
index 00391b6b16..411866f517 100644
--- a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/ManagedProviderConnectionHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/ManagedProviderConnectionHelper.java
@@ -1,107 +1,107 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.tool.hbm2ddl;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.Properties;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 
 /**
  * A {@link ConnectionHelper} implementation based on an internally
  * built and managed {@link ConnectionProvider}.
  *
  * @author Steve Ebersole
  */
 class ManagedProviderConnectionHelper implements ConnectionHelper {
 	private Properties cfgProperties;
 	private StandardServiceRegistryImpl serviceRegistry;
 	private Connection connection;
 
 	public ManagedProviderConnectionHelper(Properties cfgProperties) {
 		this.cfgProperties = cfgProperties;
 	}
 
 	public void prepare(boolean needsAutoCommit) throws SQLException {
 		serviceRegistry = createServiceRegistry( cfgProperties );
 		connection = serviceRegistry.getService( ConnectionProvider.class ).getConnection();
 		if ( needsAutoCommit && ! connection.getAutoCommit() ) {
 			connection.commit();
 			connection.setAutoCommit( true );
 		}
 	}
 
 	private static StandardServiceRegistryImpl createServiceRegistry(Properties properties) {
 		Environment.verifyProperties( properties );
 		ConfigurationHelper.resolvePlaceHolders( properties );
-		return (StandardServiceRegistryImpl) new ServiceRegistryBuilder().applySettings( properties ).buildServiceRegistry();
+		return (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().applySettings( properties ).buildServiceRegistry();
 	}
 
 	public Connection getConnection() throws SQLException {
 		return connection;
 	}
 
 	public void release() throws SQLException {
 		try {
 			releaseConnection();
 		}
 		finally {
 			releaseServiceRegistry();
 		}
 	}
 
 	private void releaseConnection() throws SQLException {
 		if ( connection != null ) {
 			try {
 				new SqlExceptionHelper().logAndClearWarnings( connection );
 			}
 			finally {
 				try  {
 					serviceRegistry.getService( ConnectionProvider.class ).closeConnection( connection );
 				}
 				finally {
 					connection = null;
 				}
 			}
 		}
 	}
 
 	private void releaseServiceRegistry() {
 		if ( serviceRegistry != null ) {
 			try {
 				serviceRegistry.destroy();
 			}
 			finally {
 				serviceRegistry = null;
 			}
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaExport.java b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaExport.java
index f8ce45e5b2..2d25d7a380 100644
--- a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaExport.java
+++ b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaExport.java
@@ -1,621 +1,621 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tool.hbm2ddl;
 
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
 import java.io.Reader;
 import java.io.Writer;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.sql.SQLWarning;
 import java.sql.Statement;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Properties;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.internal.FormatStyle;
 import org.hibernate.engine.jdbc.internal.Formatter;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.jdbc.spi.SqlStatementLogger;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ConfigHelper;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.config.spi.ConfigurationService;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.config.spi.ConfigurationService;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 
 /**
  * Commandline tool to export table schema to the database. This class may also be called from inside an application.
  *
  * @author Daniel Bradby
  * @author Gavin King
  * @author Steve Ebersole
  */
 public class SchemaExport {
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, SchemaExport.class.getName());
 	private static final String DEFAULT_IMPORT_FILE = "/import.sql";
 
 	public static enum Type {
 		CREATE,
 		DROP,
 		NONE,
 		BOTH;
 
 		public boolean doCreate() {
 			return this == BOTH || this == CREATE;
 		}
 
 		public boolean doDrop() {
 			return this == BOTH || this == DROP;
 		}
 	}
 
 	private final ConnectionHelper connectionHelper;
 	private final SqlStatementLogger sqlStatementLogger;
 	private final SqlExceptionHelper sqlExceptionHelper;
 	private final String[] dropSQL;
 	private final String[] createSQL;
 	private final String importFiles;
 
 	private final List<Exception> exceptions = new ArrayList<Exception>();
 
 	private Formatter formatter;
 	private ImportSqlCommandExtractor importSqlCommandExtractor = ImportSqlCommandExtractorInitiator.DEFAULT_EXTRACTOR;
 
 	private String outputFile = null;
 	private String delimiter;
 	private boolean haltOnError = false;
 
 	public SchemaExport(ServiceRegistry serviceRegistry, Configuration configuration) {
 		this.connectionHelper = new SuppliedConnectionProviderConnectionHelper(
 				serviceRegistry.getService( ConnectionProvider.class )
 		);
 		this.sqlStatementLogger = serviceRegistry.getService( JdbcServices.class ).getSqlStatementLogger();
 		this.formatter = ( sqlStatementLogger.isFormat() ? FormatStyle.DDL : FormatStyle.NONE ).getFormatter();
 		this.sqlExceptionHelper = serviceRegistry.getService( JdbcServices.class ).getSqlExceptionHelper();
 
 		this.importFiles = ConfigurationHelper.getString(
 				AvailableSettings.HBM2DDL_IMPORT_FILES,
 				configuration.getProperties(),
 				DEFAULT_IMPORT_FILE
 		);
 
 		final Dialect dialect = serviceRegistry.getService( JdbcServices.class ).getDialect();
 		this.dropSQL = configuration.generateDropSchemaScript( dialect );
 		this.createSQL = configuration.generateSchemaCreationScript( dialect );
 	}
 
 	public SchemaExport(MetadataImplementor metadata) {
 		ServiceRegistry serviceRegistry = metadata.getServiceRegistry();
 		this.connectionHelper = new SuppliedConnectionProviderConnectionHelper(
 				serviceRegistry.getService( ConnectionProvider.class )
 		);
         JdbcServices jdbcServices = serviceRegistry.getService( JdbcServices.class );
 		this.sqlStatementLogger = jdbcServices.getSqlStatementLogger();
 		this.formatter = ( sqlStatementLogger.isFormat() ? FormatStyle.DDL : FormatStyle.NONE ).getFormatter();
 		this.sqlExceptionHelper = jdbcServices.getSqlExceptionHelper();
 
 		this.importFiles = ConfigurationHelper.getString(
 				AvailableSettings.HBM2DDL_IMPORT_FILES,
 				serviceRegistry.getService( ConfigurationService.class ).getSettings(),
 				DEFAULT_IMPORT_FILE
 		);
 
 		final Dialect dialect = jdbcServices.getDialect();
 		this.dropSQL = metadata.getDatabase().generateDropSchemaScript( dialect );
 		this.createSQL = metadata.getDatabase().generateSchemaCreationScript( dialect );
 	}
 
 	/**
 	 * Create a schema exporter for the given Configuration
 	 *
 	 * @param configuration The configuration from which to build a schema export.
 	 * @throws HibernateException Indicates problem preparing for schema export.
 	 */
 	public SchemaExport(Configuration configuration) {
 		this( configuration, configuration.getProperties() );
 	}
 
 	/**
 	 * Create a schema exporter for the given Configuration, with the given
 	 * database connection properties.
 	 *
 	 * @param configuration The configuration from which to build a schema export.
 	 * @param properties The properties from which to configure connectivity etc.
 	 * @throws HibernateException Indicates problem preparing for schema export.
 	 *
 	 * @deprecated properties may be specified via the Configuration object
 	 */
 	@Deprecated
     public SchemaExport(Configuration configuration, Properties properties) throws HibernateException {
 		final Dialect dialect = Dialect.getDialect( properties );
 
 		Properties props = new Properties();
 		props.putAll( dialect.getDefaultProperties() );
 		props.putAll( properties );
 		this.connectionHelper = new ManagedProviderConnectionHelper( props );
 
 		this.sqlStatementLogger = new SqlStatementLogger( false, true );
 		this.formatter = FormatStyle.DDL.getFormatter();
 		this.sqlExceptionHelper = new SqlExceptionHelper();
 
 		this.importFiles = ConfigurationHelper.getString(
 				AvailableSettings.HBM2DDL_IMPORT_FILES,
 				properties,
 				DEFAULT_IMPORT_FILE
 		);
 
 		this.dropSQL = configuration.generateDropSchemaScript( dialect );
 		this.createSQL = configuration.generateSchemaCreationScript( dialect );
 	}
 
 	/**
 	 * Create a schema exporter for the given Configuration, using the supplied connection for connectivity.
 	 *
 	 * @param configuration The configuration to use.
 	 * @param connection The JDBC connection to use.
 	 * @throws HibernateException Indicates problem preparing for schema export.
 	 */
 	public SchemaExport(Configuration configuration, Connection connection) throws HibernateException {
 		this.connectionHelper = new SuppliedConnectionHelper( connection );
 
 		this.sqlStatementLogger = new SqlStatementLogger( false, true );
 		this.formatter = FormatStyle.DDL.getFormatter();
 		this.sqlExceptionHelper = new SqlExceptionHelper();
 
 		this.importFiles = ConfigurationHelper.getString(
 				AvailableSettings.HBM2DDL_IMPORT_FILES,
 				configuration.getProperties(),
 				DEFAULT_IMPORT_FILE
 		);
 
 		final Dialect dialect = Dialect.getDialect( configuration.getProperties() );
 		this.dropSQL = configuration.generateDropSchemaScript( dialect );
 		this.createSQL = configuration.generateSchemaCreationScript( dialect );
 	}
 
 	public SchemaExport(
 			ConnectionHelper connectionHelper,
 			String[] dropSql,
 			String[] createSql) {
 		this.connectionHelper = connectionHelper;
 		this.dropSQL = dropSql;
 		this.createSQL = createSql;
 		this.importFiles = "";
 		this.sqlStatementLogger = new SqlStatementLogger( false, true );
 		this.sqlExceptionHelper = new SqlExceptionHelper();
 		this.formatter = FormatStyle.DDL.getFormatter();
 	}
 
 	/**
 	 * For generating a export script file, this is the file which will be written.
 	 *
 	 * @param filename The name of the file to which to write the export script.
 	 * @return this
 	 */
 	public SchemaExport setOutputFile(String filename) {
 		outputFile = filename;
 		return this;
 	}
 
 	/**
 	 * Set the end of statement delimiter
 	 *
 	 * @param delimiter The delimiter
 	 * @return this
 	 */
 	public SchemaExport setDelimiter(String delimiter) {
 		this.delimiter = delimiter;
 		return this;
 	}
 
 	/**
 	 * Should we format the sql strings?
 	 *
 	 * @param format Should we format SQL strings
 	 * @return this
 	 */
 	public SchemaExport setFormat(boolean format) {
 		this.formatter = ( format ? FormatStyle.DDL : FormatStyle.NONE ).getFormatter();
 		return this;
 	}
 
 	/**
 	 * Set <i>import.sql</i> command extractor. By default {@link SingleLineSqlCommandExtractor} is used.
 	 *
 	 * @param importSqlCommandExtractor <i>import.sql</i> command extractor.
 	 * @return this
 	 */
 	public SchemaExport setImportSqlCommandExtractor(ImportSqlCommandExtractor importSqlCommandExtractor) {
 		this.importSqlCommandExtractor = importSqlCommandExtractor;
 		return this;
 	}
 
 	/**
 	 * Should we stop once an error occurs?
 	 *
 	 * @param haltOnError True if export should stop after error.
 	 * @return this
 	 */
 	public SchemaExport setHaltOnError(boolean haltOnError) {
 		this.haltOnError = haltOnError;
 		return this;
 	}
 
 	/**
 	 * Run the schema creation script; drop script is automatically
 	 * executed before running the creation script.
 	 *
 	 * @param script print the DDL to the console
 	 * @param export export the script to the database
 	 */
 	public void create(boolean script, boolean export) {
 		create( Target.interpret( script, export ) );
 	}
 
 	/**
 	 * Run the schema creation script; drop script is automatically
 	 * executed before running the creation script.
 	 *
 	 * @param output the target of the script.
 	 */
 	public void create(Target output) {
 		// need to drop tables before creating so need to specify Type.BOTH
 		execute( output, Type.BOTH );
 	}
 
 	/**
 	 * Run the drop schema script.
 	 *
 	 * @param script print the DDL to the console
 	 * @param export export the script to the database
 	 */
 	public void drop(boolean script, boolean export) {
 		drop( Target.interpret( script, export ) );
 	}
 
 	public void drop(Target output) {
 		execute( output, Type.DROP );
 	}
 
 	public void execute(boolean script, boolean export, boolean justDrop, boolean justCreate) {
 		execute( Target.interpret( script, export ), interpretType( justDrop, justCreate ) );
 	}
 
 	private Type interpretType(boolean justDrop, boolean justCreate) {
 		if ( justDrop ) {
 			return Type.DROP;
 		}
 		else if ( justCreate ) {
 			return Type.CREATE;
 		}
 		else {
 			return Type.BOTH;
 		}
 	}
 
 	public void execute(Target output, Type type) {
 		if ( output == Target.NONE || type == SchemaExport.Type.NONE ) {
 			return;
 		}
 		exceptions.clear();
 
 		LOG.runningHbm2ddlSchemaExport();
 
 		final List<NamedReader> importFileReaders = new ArrayList<NamedReader>();
 		for ( String currentFile : importFiles.split(",") ) {
 			try {
 				final String resourceName = currentFile.trim();
 				InputStream stream = ConfigHelper.getResourceAsStream( resourceName );
 				importFileReaders.add( new NamedReader( resourceName, stream ) );
 			}
 			catch ( HibernateException e ) {
 				LOG.debugf("Import file not found: %s", currentFile);
 			}
 		}
 
 		final List<Exporter> exporters = new ArrayList<Exporter>();
 		try {
 			// prepare exporters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 			if ( output.doScript() ) {
 				exporters.add( new ScriptExporter() );
 			}
 			if ( outputFile != null ) {
 				exporters.add( new FileExporter( outputFile ) );
 			}
 			if ( output.doExport() ) {
 				exporters.add( new DatabaseExporter( connectionHelper, sqlExceptionHelper ) );
 			}
 
 			// perform exporters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 			if ( type.doDrop() ) {
 				perform( dropSQL, exporters );
 			}
 			if ( type.doCreate() ) {
 				perform( createSQL, exporters );
 				if ( ! importFileReaders.isEmpty() ) {
 					for ( NamedReader namedReader : importFileReaders ) {
 						importScript( namedReader, exporters );
 					}
 				}
 			}
 		}
 		catch (Exception e) {
 			exceptions.add( e );
 			LOG.schemaExportUnsuccessful( e );
 		}
 		finally {
 			// release exporters ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 			for ( Exporter exporter : exporters ) {
 				try {
 					exporter.release();
 				}
 				catch (Exception ignore) {
 				}
 			}
 
 			// release the named readers from import scripts
 			for ( NamedReader namedReader : importFileReaders ) {
 				try {
 					namedReader.getReader().close();
 				}
 				catch (Exception ignore) {
 				}
 			}
             LOG.schemaExportComplete();
 		}
 	}
 
 	private void perform(String[] sqlCommands, List<Exporter> exporters) {
 		for ( String sqlCommand : sqlCommands ) {
 			String formatted = formatter.format( sqlCommand );
 	        if ( delimiter != null ) {
 				formatted += delimiter;
 			}
 			sqlStatementLogger.logStatement( sqlCommand, formatter );
 			for ( Exporter exporter : exporters ) {
 				try {
 					exporter.export( formatted );
 				}
 				catch (Exception e) {
 					if ( haltOnError ) {
 						throw new HibernateException( "Error during DDL export", e );
 					}
 					exceptions.add( e );
 					LOG.unsuccessfulCreate( sqlCommand );
 					LOG.error( e.getMessage() );
 				}
 			}
 		}
 	}
 
 	private void importScript(NamedReader namedReader, List<Exporter> exporters) throws Exception {
 		BufferedReader reader = new BufferedReader( namedReader.getReader() );
 		String[] statements = importSqlCommandExtractor.extractCommands( reader );
 		if (statements != null) {
 			for ( String statement : statements ) {
 				if ( statement != null ) {
 					String trimmedSql = statement.trim();
 					if ( trimmedSql.endsWith( ";" )) {
 						trimmedSql = trimmedSql.substring( 0, statement.length() - 1 );
 					}
 					if ( !StringHelper.isEmpty( trimmedSql ) ) {
 						try {
 							for ( Exporter exporter : exporters ) {
 								if ( exporter.acceptsImportScripts() ) {
 									exporter.export( trimmedSql );
 								}
 							}
 						}
 						catch ( Exception e ) {
 							throw new ImportScriptException( "Error during statement execution (file: '" + namedReader.getName() + "'): " + trimmedSql, e );
 						}
 					}
 				}
 			}
 		}
 	}
 
 	private static class NamedReader {
 		private final Reader reader;
 		private final String name;
 
 		public NamedReader(String name, InputStream stream) {
 			this.name = name;
 			this.reader = new InputStreamReader( stream );
 		}
 
 		public Reader getReader() {
 			return reader;
 		}
 
 		public String getName() {
 			return name;
 		}
 	}
 
 	private void execute(boolean script, boolean export, Writer fileOutput, Statement statement, final String sql)
 			throws IOException, SQLException {
 		final SqlExceptionHelper sqlExceptionHelper = new SqlExceptionHelper();
 
 		String formatted = formatter.format( sql );
         if (delimiter != null) formatted += delimiter;
         if (script) System.out.println(formatted);
         LOG.debug(formatted);
 		if ( outputFile != null ) {
 			fileOutput.write( formatted + "\n" );
 		}
 		if ( export ) {
 
 			statement.executeUpdate( sql );
 			try {
 				SQLWarning warnings = statement.getWarnings();
 				if ( warnings != null) {
 					sqlExceptionHelper.logAndClearWarnings( connectionHelper.getConnection() );
 				}
 			}
 			catch( SQLException sqle ) {
                 LOG.unableToLogSqlWarnings(sqle);
 			}
 		}
 
 	}
 
 	private static StandardServiceRegistryImpl createServiceRegistry(Properties properties) {
 		Environment.verifyProperties( properties );
 		ConfigurationHelper.resolvePlaceHolders( properties );
-		return (StandardServiceRegistryImpl) new ServiceRegistryBuilder().applySettings( properties ).buildServiceRegistry();
+		return (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().applySettings( properties ).buildServiceRegistry();
 	}
 
 	public static void main(String[] args) {
 		try {
 			Configuration cfg = new Configuration();
 
 			boolean script = true;
 			boolean drop = false;
 			boolean create = false;
 			boolean halt = false;
 			boolean export = true;
 			String outFile = null;
 			String importFile = DEFAULT_IMPORT_FILE;
 			String propFile = null;
 			boolean format = false;
 			String delim = null;
 
 			for ( int i = 0; i < args.length; i++ ) {
 				if ( args[i].startsWith( "--" ) ) {
 					if ( args[i].equals( "--quiet" ) ) {
 						script = false;
 					}
 					else if ( args[i].equals( "--drop" ) ) {
 						drop = true;
 					}
 					else if ( args[i].equals( "--create" ) ) {
 						create = true;
 					}
 					else if ( args[i].equals( "--haltonerror" ) ) {
 						halt = true;
 					}
 					else if ( args[i].equals( "--text" ) ) {
 						export = false;
 					}
 					else if ( args[i].startsWith( "--output=" ) ) {
 						outFile = args[i].substring( 9 );
 					}
 					else if ( args[i].startsWith( "--import=" ) ) {
 						importFile = args[i].substring( 9 );
 					}
 					else if ( args[i].startsWith( "--properties=" ) ) {
 						propFile = args[i].substring( 13 );
 					}
 					else if ( args[i].equals( "--format" ) ) {
 						format = true;
 					}
 					else if ( args[i].startsWith( "--delimiter=" ) ) {
 						delim = args[i].substring( 12 );
 					}
 					else if ( args[i].startsWith( "--config=" ) ) {
 						cfg.configure( args[i].substring( 9 ) );
 					}
 					else if ( args[i].startsWith( "--naming=" ) ) {
 						cfg.setNamingStrategy(
 								( NamingStrategy ) ReflectHelper.classForName( args[i].substring( 9 ) )
 										.newInstance()
 						);
 					}
 				}
 				else {
 					String filename = args[i];
 					if ( filename.endsWith( ".jar" ) ) {
 						cfg.addJar( new File( filename ) );
 					}
 					else {
 						cfg.addFile( filename );
 					}
 				}
 
 			}
 
 			if ( propFile != null ) {
 				Properties props = new Properties();
 				props.putAll( cfg.getProperties() );
 				props.load( new FileInputStream( propFile ) );
 				cfg.setProperties( props );
 			}
 
 			if (importFile != null) {
 				cfg.setProperty( AvailableSettings.HBM2DDL_IMPORT_FILES, importFile );
 			}
 
 			StandardServiceRegistryImpl serviceRegistry = createServiceRegistry( cfg.getProperties() );
 			try {
 				SchemaExport se = new SchemaExport( serviceRegistry, cfg )
 						.setHaltOnError( halt )
 						.setOutputFile( outFile )
 						.setDelimiter( delim )
 						.setImportSqlCommandExtractor( serviceRegistry.getService( ImportSqlCommandExtractor.class ) );
 				if ( format ) {
 					se.setFormat( true );
 				}
 				se.execute( script, export, drop, create );
 			}
 			finally {
 				serviceRegistry.destroy();
 			}
 		}
 		catch ( Exception e ) {
             LOG.unableToCreateSchema(e);
 			e.printStackTrace();
 		}
 	}
 
 	/**
 	 * Returns a List of all Exceptions which occured during the export.
 	 *
 	 * @return A List containig the Exceptions occured during the export
 	 */
 	public List getExceptions() {
 		return exceptions;
 	}
 
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaUpdate.java b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaUpdate.java
index 713370850d..451fae85bf 100644
--- a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaUpdate.java
+++ b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaUpdate.java
@@ -1,295 +1,295 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tool.hbm2ddl;
 
 import java.io.FileInputStream;
 import java.io.FileWriter;
 import java.io.Writer;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Properties;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
 import org.hibernate.JDBCException;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.internal.FormatStyle;
 import org.hibernate.engine.jdbc.internal.Formatter;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.jdbc.spi.SqlStatementLogger;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 
 /**
  * A commandline tool to update a database schema. May also be called from inside an application.
  *
  * @author Christoph Sturm
  * @author Steve Ebersole
  */
 public class SchemaUpdate {
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, SchemaUpdate.class.getName());
 
 	private final Configuration configuration;
 	private final ConnectionHelper connectionHelper;
 	private final SqlStatementLogger sqlStatementLogger;
 	private final SqlExceptionHelper sqlExceptionHelper;
 	private final Dialect dialect;
 
 	private final List<Exception> exceptions = new ArrayList<Exception>();
 
 	private Formatter formatter;
 
 	private boolean haltOnError = false;
 	private boolean format = true;
 	private String outputFile = null;
 	private String delimiter;
 
 	public SchemaUpdate(Configuration cfg) throws HibernateException {
 		this( cfg, cfg.getProperties() );
 	}
 
 	public SchemaUpdate(Configuration configuration, Properties properties) throws HibernateException {
 		this.configuration = configuration;
 		this.dialect = Dialect.getDialect( properties );
 
 		Properties props = new Properties();
 		props.putAll( dialect.getDefaultProperties() );
 		props.putAll( properties );
 		this.connectionHelper = new ManagedProviderConnectionHelper( props );
 
 		this.sqlExceptionHelper = new SqlExceptionHelper();
 		this.sqlStatementLogger = new SqlStatementLogger( false, true );
 		this.formatter = FormatStyle.DDL.getFormatter();
 	}
 
 	public SchemaUpdate(ServiceRegistry serviceRegistry, Configuration cfg) throws HibernateException {
 		this.configuration = cfg;
 
 		final JdbcServices jdbcServices = serviceRegistry.getService( JdbcServices.class );
 		this.dialect = jdbcServices.getDialect();
 		this.connectionHelper = new SuppliedConnectionProviderConnectionHelper( jdbcServices.getConnectionProvider() );
 
 		this.sqlExceptionHelper = new SqlExceptionHelper();
 		this.sqlStatementLogger = jdbcServices.getSqlStatementLogger();
 		this.formatter = ( sqlStatementLogger.isFormat() ? FormatStyle.DDL : FormatStyle.NONE ).getFormatter();
 	}
 
 	private static StandardServiceRegistryImpl createServiceRegistry(Properties properties) {
 		Environment.verifyProperties( properties );
 		ConfigurationHelper.resolvePlaceHolders( properties );
-		return (StandardServiceRegistryImpl) new ServiceRegistryBuilder().applySettings( properties ).buildServiceRegistry();
+		return (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().applySettings( properties ).buildServiceRegistry();
 	}
 
 	public static void main(String[] args) {
 		try {
 			Configuration cfg = new Configuration();
 
 			boolean script = true;
 			// If true then execute db updates, otherwise just generate and display updates
 			boolean doUpdate = true;
 			String propFile = null;
 
 			for ( int i = 0; i < args.length; i++ ) {
 				if ( args[i].startsWith( "--" ) ) {
 					if ( args[i].equals( "--quiet" ) ) {
 						script = false;
 					}
 					else if ( args[i].startsWith( "--properties=" ) ) {
 						propFile = args[i].substring( 13 );
 					}
 					else if ( args[i].startsWith( "--config=" ) ) {
 						cfg.configure( args[i].substring( 9 ) );
 					}
 					else if ( args[i].startsWith( "--text" ) ) {
 						doUpdate = false;
 					}
 					else if ( args[i].startsWith( "--naming=" ) ) {
 						cfg.setNamingStrategy(
 								( NamingStrategy ) ReflectHelper.classForName( args[i].substring( 9 ) ).newInstance()
 						);
 					}
 				}
 				else {
 					cfg.addFile( args[i] );
 				}
 
 			}
 
 			if ( propFile != null ) {
 				Properties props = new Properties();
 				props.putAll( cfg.getProperties() );
 				props.load( new FileInputStream( propFile ) );
 				cfg.setProperties( props );
 			}
 
 			StandardServiceRegistryImpl serviceRegistry = createServiceRegistry( cfg.getProperties() );
 			try {
 				new SchemaUpdate( serviceRegistry, cfg ).execute( script, doUpdate );
 			}
 			finally {
 				serviceRegistry.destroy();
 			}
 		}
 		catch ( Exception e ) {
             LOG.unableToRunSchemaUpdate(e);
 			e.printStackTrace();
 		}
 	}
 
 	/**
 	 * Execute the schema updates
 	 *
 	 * @param script print all DDL to the console
 	 */
 	public void execute(boolean script, boolean doUpdate) {
 		execute( Target.interpret( script, doUpdate ) );
 	}
 	
 	public void execute(Target target) {
         LOG.runningHbm2ddlSchemaUpdate();
 
 		Connection connection = null;
 		Statement stmt = null;
 		Writer outputFileWriter = null;
 
 		exceptions.clear();
 
 		try {
 			DatabaseMetadata meta;
 			try {
                 LOG.fetchingDatabaseMetadata();
 				connectionHelper.prepare( true );
 				connection = connectionHelper.getConnection();
 				meta = new DatabaseMetadata( connection, dialect );
 				stmt = connection.createStatement();
 			}
 			catch ( SQLException sqle ) {
 				exceptions.add( sqle );
                 LOG.unableToGetDatabaseMetadata(sqle);
 				throw sqle;
 			}
 
             LOG.updatingSchema();
 
 			if ( outputFile != null ) {
                 LOG.writingGeneratedSchemaToFile( outputFile );
 				outputFileWriter = new FileWriter( outputFile );
 			}
 
 			String[] sqlStrings = configuration.generateSchemaUpdateScript( dialect, meta );
 			for ( String sql : sqlStrings ) {
 				String formatted = formatter.format( sql );
 				try {
 					if ( delimiter != null ) {
 						formatted += delimiter;
 					}
 					if ( target.doScript() ) {
 						System.out.println( formatted );
 					}
 					if ( outputFile != null ) {
 						outputFileWriter.write( formatted + "\n" );
 					}
 					if ( target.doExport() ) {
                         LOG.debug( sql );
 						stmt.executeUpdate( formatted );
 					}
 				}
 				catch ( SQLException e ) {
 					if ( haltOnError ) {
 						throw new JDBCException( "Error during DDL export", e );
 					}
 					exceptions.add( e );
                     LOG.unsuccessful(sql);
                     LOG.error(e.getMessage());
 				}
 			}
 
             LOG.schemaUpdateComplete();
 
 		}
 		catch ( Exception e ) {
 			exceptions.add( e );
             LOG.unableToCompleteSchemaUpdate(e);
 		}
 		finally {
 
 			try {
 				if ( stmt != null ) {
 					stmt.close();
 				}
 				connectionHelper.release();
 			}
 			catch ( Exception e ) {
 				exceptions.add( e );
                 LOG.unableToCloseConnection(e);
 			}
 			try {
 				if( outputFileWriter != null ) {
 					outputFileWriter.close();
 				}
 			}
 			catch(Exception e) {
 				exceptions.add(e);
                 LOG.unableToCloseConnection(e);
 			}
 		}
 	}
 
 	/**
 	 * Returns a List of all Exceptions which occured during the export.
 	 *
 	 * @return A List containig the Exceptions occured during the export
 	 */
 	public List getExceptions() {
 		return exceptions;
 	}
 
 	public void setHaltOnError(boolean haltOnError) {
 		this.haltOnError = haltOnError;
 	}
 
 	public void setFormat(boolean format) {
 		this.formatter = ( format ? FormatStyle.DDL : FormatStyle.NONE ).getFormatter();
 	}
 
 	public void setOutputFile(String outputFile) {
 		this.outputFile = outputFile;
 	}
 
 	public void setDelimiter(String delimiter) {
 		this.delimiter = delimiter;
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaValidator.java b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaValidator.java
index af64cfa563..8a748cffdc 100755
--- a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaValidator.java
+++ b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SchemaValidator.java
@@ -1,172 +1,172 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.tool.hbm2ddl;
 
 import java.io.FileInputStream;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.Properties;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.HibernateException;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 
 /**
  * A commandline tool to update a database schema. May also be called from
  * inside an application.
  *
  * @author Christoph Sturm
  */
 public class SchemaValidator {
     private static final CoreMessageLogger LOG = Logger.getMessageLogger(CoreMessageLogger.class, SchemaValidator.class.getName());
 
 	private ConnectionHelper connectionHelper;
 	private Configuration configuration;
 	private Dialect dialect;
 
 	public SchemaValidator(Configuration cfg) throws HibernateException {
 		this( cfg, cfg.getProperties() );
 	}
 
 	public SchemaValidator(Configuration cfg, Properties connectionProperties) throws HibernateException {
 		this.configuration = cfg;
 		dialect = Dialect.getDialect( connectionProperties );
 		Properties props = new Properties();
 		props.putAll( dialect.getDefaultProperties() );
 		props.putAll( connectionProperties );
 		connectionHelper = new ManagedProviderConnectionHelper( props );
 	}
 
 	public SchemaValidator(ServiceRegistry serviceRegistry, Configuration cfg ) throws HibernateException {
 		this.configuration = cfg;
 		final JdbcServices jdbcServices = serviceRegistry.getService( JdbcServices.class );
 		this.dialect = jdbcServices.getDialect();
 		this.connectionHelper = new SuppliedConnectionProviderConnectionHelper( jdbcServices.getConnectionProvider() );
 	}
 
 	private static StandardServiceRegistryImpl createServiceRegistry(Properties properties) {
 		Environment.verifyProperties( properties );
 		ConfigurationHelper.resolvePlaceHolders( properties );
-		return (StandardServiceRegistryImpl) new ServiceRegistryBuilder().applySettings( properties ).buildServiceRegistry();
+		return (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().applySettings( properties ).buildServiceRegistry();
 	}
 
 	public static void main(String[] args) {
 		try {
 			Configuration cfg = new Configuration();
 
 			String propFile = null;
 
 			for ( int i = 0; i < args.length; i++ ) {
 				if ( args[i].startsWith( "--" ) ) {
 					if ( args[i].startsWith( "--properties=" ) ) {
 						propFile = args[i].substring( 13 );
 					}
 					else if ( args[i].startsWith( "--config=" ) ) {
 						cfg.configure( args[i].substring( 9 ) );
 					}
 					else if ( args[i].startsWith( "--naming=" ) ) {
 						cfg.setNamingStrategy(
 								( NamingStrategy ) ReflectHelper.classForName( args[i].substring( 9 ) ).newInstance()
 						);
 					}
 				}
 				else {
 					cfg.addFile( args[i] );
 				}
 
 			}
 
 			if ( propFile != null ) {
 				Properties props = new Properties();
 				props.putAll( cfg.getProperties() );
 				props.load( new FileInputStream( propFile ) );
 				cfg.setProperties( props );
 			}
 
 			StandardServiceRegistryImpl serviceRegistry = createServiceRegistry( cfg.getProperties() );
 			try {
 				new SchemaValidator( serviceRegistry, cfg ).validate();
 			}
 			finally {
 				serviceRegistry.destroy();
 			}
 		}
 		catch ( Exception e ) {
             LOG.unableToRunSchemaUpdate(e);
 			e.printStackTrace();
 		}
 	}
 
 	/**
 	 * Perform the validations.
 	 */
 	public void validate() {
 
         LOG.runningSchemaValidator();
 
 		Connection connection = null;
 
 		try {
 
 			DatabaseMetadata meta;
 			try {
                 LOG.fetchingDatabaseMetadata();
 				connectionHelper.prepare( false );
 				connection = connectionHelper.getConnection();
 				meta = new DatabaseMetadata( connection, dialect, false );
 			}
 			catch ( SQLException sqle ) {
                 LOG.unableToGetDatabaseMetadata(sqle);
 				throw sqle;
 			}
 
 			configuration.validateSchema( dialect, meta );
 
 		}
 		catch ( SQLException e ) {
             LOG.unableToCompleteSchemaValidation(e);
 		}
 		finally {
 
 			try {
 				connectionHelper.release();
 			}
 			catch ( Exception e ) {
                 LOG.unableToCloseConnection(e);
 			}
 
 		}
 	}
 }
diff --git a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SuppliedConnectionProviderConnectionHelper.java b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SuppliedConnectionProviderConnectionHelper.java
index 8dd589ae43..b98f550629 100644
--- a/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SuppliedConnectionProviderConnectionHelper.java
+++ b/hibernate-core/src/main/java/org/hibernate/tool/hbm2ddl/SuppliedConnectionProviderConnectionHelper.java
@@ -1,79 +1,79 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  *
  */
 package org.hibernate.tool.hbm2ddl;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 
 /**
  * A {@link ConnectionHelper} implementation based on a provided
  * {@link ConnectionProvider}.  Essentially, ensures that the connection
  * gets cleaned up, but that the provider itself remains usable since it
  * was externally provided to us.
  *
  * @author Steve Ebersole
  */
 class SuppliedConnectionProviderConnectionHelper implements ConnectionHelper {
 	private ConnectionProvider provider;
 	private Connection connection;
 	private boolean toggleAutoCommit;
 
 	public SuppliedConnectionProviderConnectionHelper(ConnectionProvider provider) {
 		this.provider = provider;
 	}
 
 	public void prepare(boolean needsAutoCommit) throws SQLException {
 		connection = provider.getConnection();
 		toggleAutoCommit = needsAutoCommit && !connection.getAutoCommit();
 		if ( toggleAutoCommit ) {
 			try {
 				connection.commit();
 			}
 			catch( Throwable ignore ) {
 				// might happen with a managed connection
 			}
 			connection.setAutoCommit( true );
 		}
 	}
 
 	public Connection getConnection() throws SQLException {
 		return connection;
 	}
 
 	public void release() throws SQLException {
 		// we only release the connection
 		if ( connection != null ) {
 			new SqlExceptionHelper().logAndClearWarnings( connection );
 			if ( toggleAutoCommit ) {
 				connection.setAutoCommit( false );
 			}
 			provider.closeConnection( connection );
 			connection = null;
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/connection/PropertiesTest.java b/hibernate-core/src/test/java/org/hibernate/connection/PropertiesTest.java
index c1a0e70f7f..1ae674536b 100644
--- a/hibernate-core/src/test/java/org/hibernate/connection/PropertiesTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/connection/PropertiesTest.java
@@ -1,54 +1,54 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.connection;
 import java.util.Properties;
 
 import org.junit.Assert;
 import org.junit.Test;
 
-import org.hibernate.service.jdbc.connections.internal.ConnectionProviderInitiator;
+import org.hibernate.engine.jdbc.connections.internal.ConnectionProviderInitiator;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 /**
  * @author kbow
  */
 public class PropertiesTest extends BaseUnitTestCase {
 	@Test
 	public void testProperties() throws Exception {
 		final Properties props = new Properties();
 
 		props.put("rpt.1.hibernate.dialect", "org.hibernate.dialect.DerbyDialect");
 		props.put("rpt.2.hibernate.connection.driver_class", "org.apache.derby.jdbc.ClientDriver");
 		props.put("rpt.3.hibernate.connection.url", "jdbc:derby://localhost:1527/db/reports.db");
 		props.put("rpt.4.hibernate.connection.username", "sa");
 		props.put("rpt.5.hibernate.connection.password_enc", "76f271db3661fd50082e68d4b953fbee");
 		props.put("rpt.6.hibernate.connection.password_enc", "76f271db3661fd50082e68d4b953fbee");
 		props.put("hibernate.connection.create", "true");
 
 		final Properties outputProps = ConnectionProviderInitiator.getConnectionProperties( props );
 		Assert.assertEquals( 1, outputProps.size() );
 		Assert.assertEquals( "true", outputProps.get( "create" ) );
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/dialect/TestingDialects.java b/hibernate-core/src/test/java/org/hibernate/dialect/TestingDialects.java
index dd440c5deb..8c7bb01edf 100644
--- a/hibernate-core/src/test/java/org/hibernate/dialect/TestingDialects.java
+++ b/hibernate-core/src/test/java/org/hibernate/dialect/TestingDialects.java
@@ -1,105 +1,105 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect;
 import java.sql.DatabaseMetaData;
 import java.sql.SQLException;
 
 import org.hibernate.HibernateException;
-import org.hibernate.service.jdbc.dialect.internal.AbstractDialectResolver;
-import org.hibernate.service.jdbc.dialect.internal.BasicDialectResolver;
+import org.hibernate.engine.jdbc.dialect.internal.AbstractDialectResolver;
+import org.hibernate.engine.jdbc.dialect.internal.BasicDialectResolver;
 
 /**
  * @author Steve Ebersole
  */
 public class TestingDialects {
 
 	public static class MyDialect1 extends Dialect {
 	}
 
 	public static class MyDialect21 extends Dialect {
 	}
 
 	public static class MyDialect22 extends Dialect {
 	}
 
 	public static class MySpecialDB2Dialect extends Dialect {
 	}
 
 	public static class MyDialectResolver1 extends AbstractDialectResolver {
 		protected Dialect resolveDialectInternal(DatabaseMetaData metaData) throws SQLException {
 			String databaseName = metaData.getDatabaseProductName();
 			int databaseMajorVersion = metaData.getDatabaseMajorVersion();
 			if ( "MyDatabase1".equals( databaseName ) ) {
 				return new MyDialect1();
 			}
 			if ( "MyDatabase2".equals( databaseName ) ) {
 				if ( databaseMajorVersion >= 2 ) {
 					return new MyDialect22();
 				}
 				if ( databaseMajorVersion >= 1 ) {
 					return new MyDialect21();
 				}
 			}
 			return null;
 		}
 	}
 
 	public static class MyDialectResolver2 extends BasicDialectResolver {
 		public MyDialectResolver2() {
 			super( "MyTrickyDatabase1", MyDialect1.class );
 		}
 	}
 
 	public static class ErrorDialectResolver1 extends AbstractDialectResolver {
 		public Dialect resolveDialectInternal(DatabaseMetaData metaData) throws SQLException {
 			String databaseName = metaData.getDatabaseProductName();
 			if ( databaseName.equals( "ConnectionErrorDatabase1" ) ) {
 				throw new SQLException( "Simulated connection error", "08001" );
 			}
 			else {
 				throw new SQLException();
 			}
 		}
 	}
 
 	public static class ErrorDialectResolver2 extends AbstractDialectResolver {
 		public Dialect resolveDialectInternal(DatabaseMetaData metaData) throws SQLException {
 			String databaseName = metaData.getDatabaseProductName();
 			if ( databaseName.equals( "ErrorDatabase1" ) ) {
 				throw new SQLException();
 			}
 			if ( databaseName.equals( "ErrorDatabase2" ) ) {
 				throw new HibernateException( "This is a trap!" );
 			}
 			return null;
 		}
 	}
 
 	public static class MyOverridingDialectResolver1 extends BasicDialectResolver {
 		public MyOverridingDialectResolver1() {
 			super( "DB2/MySpecialPlatform", MySpecialDB2Dialect.class );
 		}
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/dialect/resolver/DialectFactoryTest.java b/hibernate-core/src/test/java/org/hibernate/dialect/resolver/DialectFactoryTest.java
index 4d763ff5a5..957392a496 100644
--- a/hibernate-core/src/test/java/org/hibernate/dialect/resolver/DialectFactoryTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/dialect/resolver/DialectFactoryTest.java
@@ -1,220 +1,220 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect.resolver;
 
 import java.sql.Connection;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.Map;
 import java.util.Properties;
 
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.DB2400Dialect;
 import org.hibernate.dialect.DB2Dialect;
 import org.hibernate.dialect.DerbyDialect;
 import org.hibernate.dialect.DerbyTenFiveDialect;
 import org.hibernate.dialect.DerbyTenSevenDialect;
 import org.hibernate.dialect.DerbyTenSixDialect;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.InformixDialect;
 import org.hibernate.dialect.IngresDialect;
 import org.hibernate.dialect.Mocks;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.Oracle10gDialect;
 import org.hibernate.dialect.Oracle8iDialect;
 import org.hibernate.dialect.Oracle9iDialect;
 import org.hibernate.dialect.PostgreSQL81Dialect;
 import org.hibernate.dialect.PostgreSQL82Dialect;
 import org.hibernate.dialect.SQLServerDialect;
 import org.hibernate.dialect.SybaseASE15Dialect;
 import org.hibernate.dialect.SybaseAnywhereDialect;
 import org.hibernate.dialect.TestingDialects;
-import org.hibernate.service.classloading.internal.ClassLoaderServiceImpl;
-import org.hibernate.service.classloading.spi.ClassLoadingException;
-import org.hibernate.service.jdbc.dialect.internal.DialectFactoryImpl;
-import org.hibernate.service.jdbc.dialect.internal.DialectResolverSet;
-import org.hibernate.service.jdbc.dialect.internal.StandardDialectResolver;
-import org.hibernate.service.jdbc.dialect.spi.DialectResolver;
+import org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
+import org.hibernate.engine.jdbc.dialect.internal.DialectFactoryImpl;
+import org.hibernate.engine.jdbc.dialect.internal.DialectResolverSet;
+import org.hibernate.engine.jdbc.dialect.internal.StandardDialectResolver;
+import org.hibernate.engine.jdbc.dialect.spi.DialectResolver;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
 /**
  * @author Steve Ebersole
  */
 public class DialectFactoryTest extends BaseUnitTestCase {
 	private DialectFactoryImpl dialectFactory;
 
 	@Before
 	public void setUp() {
 		dialectFactory = new DialectFactoryImpl();
 		dialectFactory.setClassLoaderService( new ClassLoaderServiceImpl( getClass().getClassLoader() ) );
 		dialectFactory.setDialectResolver( new StandardDialectResolver() );
 	}
 
 	@Test
 	public void testExplicitlySuppliedDialectClassName() {
 		final Map<String, String> configValues = new HashMap<String, String>();
 
 		configValues.put( Environment.DIALECT, "org.hibernate.dialect.HSQLDialect" );
 		assertEquals( HSQLDialect.class, dialectFactory.buildDialect( configValues, null ).getClass() );
 
 		configValues.put( Environment.DIALECT, "org.hibernate.dialect.NoSuchDialect" );
 		try {
 			dialectFactory.buildDialect( configValues, null );
 			fail();
 		}
 		catch ( HibernateException e ) {
 			assertEquals( "unexpected exception type", ClassLoadingException.class, e.getCause().getClass() );
 		}
 
 		configValues.put( Environment.DIALECT, "java.lang.Object" );
 		try {
 			dialectFactory.buildDialect( configValues, null );
 			fail();
 		}
 		catch ( HibernateException e ) {
 			assertEquals( "unexpected exception type", ClassCastException.class, e.getCause().getClass() );
 		}
 	}
 
 	@Test
 	public void testBuildDialectByProperties() {
 		Properties props = new Properties();
 
 		try {
 			dialectFactory.buildDialect( props, null );
 			fail();
 		}
 		catch ( HibernateException e ) {
 			assertNull( e.getCause() );
 		}
 
 		props.setProperty( Environment.DIALECT, "org.hibernate.dialect.HSQLDialect" );
 		assertEquals( HSQLDialect.class, dialectFactory.buildDialect( props, null ).getClass() );
 	}
 
 	@Test
 	public void testPreregisteredDialects() {
 		DialectResolver resolver = new StandardDialectResolver();
 		testDetermination( "HSQL Database Engine", HSQLDialect.class, resolver );
 		testDetermination( "H2", H2Dialect.class, resolver );
 		testDetermination( "MySQL", MySQLDialect.class, resolver );
 		testDetermination( "PostgreSQL", PostgreSQL81Dialect.class, resolver );
 		testDetermination( "PostgreSQL", 8, 2, PostgreSQL82Dialect.class, resolver );
 		testDetermination( "Apache Derby", 10, 4, DerbyDialect.class, resolver );
 		testDetermination( "Apache Derby", 10, 5, DerbyTenFiveDialect.class, resolver );
 		testDetermination( "Apache Derby", 10, 6, DerbyTenSixDialect.class, resolver );
 		testDetermination( "Apache Derby", 11, 5, DerbyTenSevenDialect.class, resolver );
 		testDetermination( "Ingres", IngresDialect.class, resolver );
 		testDetermination( "ingres", IngresDialect.class, resolver );
 		testDetermination( "INGRES", IngresDialect.class, resolver );
 		testDetermination( "Microsoft SQL Server Database", SQLServerDialect.class, resolver );
 		testDetermination( "Microsoft SQL Server", SQLServerDialect.class, resolver );
 		testDetermination( "Sybase SQL Server", SybaseASE15Dialect.class, resolver );
 		testDetermination( "Adaptive Server Enterprise", SybaseASE15Dialect.class, resolver );
 		testDetermination( "Adaptive Server Anywhere", SybaseAnywhereDialect.class, resolver );
 		testDetermination( "Informix Dynamic Server", InformixDialect.class, resolver );
 		testDetermination( "DB2/NT", DB2Dialect.class, resolver );
 		testDetermination( "DB2/LINUX", DB2Dialect.class, resolver );
 		testDetermination( "DB2/6000", DB2Dialect.class, resolver );
 		testDetermination( "DB2/HPUX", DB2Dialect.class, resolver );
 		testDetermination( "DB2/SUN", DB2Dialect.class, resolver );
 		testDetermination( "DB2/LINUX390", DB2Dialect.class, resolver );
 		testDetermination( "DB2/AIX64", DB2Dialect.class, resolver );
 		testDetermination( "DB2 UDB for AS/400", DB2400Dialect.class, resolver );
 		testDetermination( "Oracle", 8, Oracle8iDialect.class, resolver );
 		testDetermination( "Oracle", 9, Oracle9iDialect.class, resolver );
 		testDetermination( "Oracle", 10, Oracle10gDialect.class, resolver );
 		testDetermination( "Oracle", 11, Oracle10gDialect.class, resolver );
 	}
 
 	@Test
 	public void testCustomDialects() {
 		DialectResolverSet resolvers = new DialectResolverSet();
 		resolvers.addResolver( new TestingDialects.MyDialectResolver1() );
 		resolvers.addResolver( new TestingDialects.MyDialectResolver2() );
 		resolvers.addResolver( new TestingDialects.ErrorDialectResolver1() );
 		resolvers.addResolver( new TestingDialects.ErrorDialectResolver2() );
 		resolvers.addResolver( new TestingDialects.MyOverridingDialectResolver1() );
 		//DialectFactory.registerDialectResolver( "org.hibernate.dialect.NoSuchDialectResolver" );
 		//DialectFactory.registerDialectResolver( "java.lang.Object" );
 
 		testDetermination( "MyDatabase1", TestingDialects.MyDialect1.class, resolvers );
 		testDetermination( "MyDatabase2", 1, TestingDialects.MyDialect21.class, resolvers );
 		testDetermination( "MyTrickyDatabase1", TestingDialects.MyDialect1.class, resolvers );
 
 		// This should be mapped to DB2Dialect by default, but actually it will be
 		// my custom dialect because I have registered MyOverridingDialectResolver1.
 		testDetermination( "DB2/MySpecialPlatform", TestingDialects.MySpecialDB2Dialect.class, resolvers );
 
 		try {
 			testDetermination( "ErrorDatabase1", Void.TYPE, resolvers );
 			fail();
 		}
 		catch ( HibernateException e ) {
 		}
 
 		try {
 			testDetermination( "ErrorDatabase2", Void.TYPE, resolvers );
 			fail();
 		}
 		catch ( HibernateException e ) {
 		}
 	}
 
 	@Test
 	public void testDialectNotFound() {
 		Map properties = Collections.EMPTY_MAP;
 		try {
 			dialectFactory.buildDialect( properties, Mocks.createConnection( "NoSuchDatabase", 666 ) );
 			fail();
 		}
 		catch ( HibernateException e ) {
 			assertNull( e.getCause() );
 		}
 	}
 
 	private void testDetermination(String databaseName, Class clazz, DialectResolver resolver) {
 		testDetermination( databaseName, -9999, clazz, resolver );
 	}
 
 	private void testDetermination(String databaseName, int databaseMajorVersion, Class clazz, DialectResolver resolver) {
 		testDetermination( databaseName, databaseMajorVersion, -9999, clazz, resolver );
 	}
 
 	private void testDetermination(String databaseName, int majorVersion, int minorVersion, Class clazz, DialectResolver resolver) {
 		dialectFactory.setDialectResolver( resolver );
 		Properties properties = new Properties();
 		Connection conn = Mocks.createConnection( databaseName, majorVersion, minorVersion );
 		assertEquals( clazz, dialectFactory.buildDialect( properties, conn ).getClass() );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/dialect/resolver/DialectResolverTest.java b/hibernate-core/src/test/java/org/hibernate/dialect/resolver/DialectResolverTest.java
index ae774dcb61..ba49a7e109 100644
--- a/hibernate-core/src/test/java/org/hibernate/dialect/resolver/DialectResolverTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/dialect/resolver/DialectResolverTest.java
@@ -1,116 +1,116 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.dialect.resolver;
 import java.sql.SQLException;
 
 import org.junit.Test;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.Mocks;
 import org.hibernate.dialect.TestingDialects;
 import org.hibernate.exception.JDBCConnectionException;
-import org.hibernate.service.jdbc.dialect.internal.BasicDialectResolver;
-import org.hibernate.service.jdbc.dialect.internal.DialectResolverSet;
-import org.hibernate.service.jdbc.dialect.spi.DialectResolver;
+import org.hibernate.engine.jdbc.dialect.internal.BasicDialectResolver;
+import org.hibernate.engine.jdbc.dialect.internal.DialectResolverSet;
+import org.hibernate.engine.jdbc.dialect.spi.DialectResolver;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 /**
  * @author Steve Ebersole
  */
 public class DialectResolverTest extends BaseUnitTestCase {
 	@Test
 	public void testDialects() throws Exception {
 		DialectResolverSet resolvers = new DialectResolverSet();
 
 		resolvers.addResolverAtFirst( new TestingDialects.MyDialectResolver1() );
 		resolvers.addResolverAtFirst( new TestingDialects.MyDialectResolver2() );
 
 		testDetermination( resolvers, "MyDatabase1", 1, TestingDialects.MyDialect1.class );
 		testDetermination( resolvers, "MyDatabase1", 2, TestingDialects.MyDialect1.class );
 		testDetermination( resolvers, "MyDatabase2", 0, null );
 		testDetermination( resolvers, "MyDatabase2", 1, TestingDialects.MyDialect21.class );
 		testDetermination( resolvers, "MyDatabase2", 2, TestingDialects.MyDialect22.class );
 		testDetermination( resolvers, "MyDatabase2", 3, TestingDialects.MyDialect22.class );
 		testDetermination( resolvers, "MyDatabase3", 1, null );
 		testDetermination( resolvers, "MyTrickyDatabase1", 1, TestingDialects.MyDialect1.class );
 	}
 
 	@Test
 	public void testErrorAndOrder() throws Exception {
 		DialectResolverSet resolvers = new DialectResolverSet();
 		resolvers.addResolverAtFirst( new TestingDialects.MyDialectResolver1() );
 		resolvers.addResolver( new TestingDialects.ErrorDialectResolver1() );
 		resolvers.addResolverAtFirst( new TestingDialects.ErrorDialectResolver1() );
 		resolvers.addResolver( new TestingDialects.MyDialectResolver2() );
 
 		// Non-connection errors are suppressed.
 		testDetermination( resolvers, "MyDatabase1", 1, TestingDialects.MyDialect1.class );
 		testDetermination( resolvers, "MyTrickyDatabase1", 1, TestingDialects.MyDialect1.class );
 		testDetermination( resolvers, "NoSuchDatabase", 1, null );
 
 		// Connection errors are reported
 		try {
 			testDetermination( resolvers, "ConnectionErrorDatabase1", 1, null );
 			fail();
 		}
 		catch ( JDBCConnectionException e ) {
 			// expected
 		}
 	}
 
 	@Test
 	public void testBasicDialectResolver() throws Exception {
 		DialectResolverSet resolvers = new DialectResolverSet();
 		// Simulating MyDialectResolver1 by BasicDialectResolvers
 		resolvers.addResolver( new BasicDialectResolver( "MyDatabase1", TestingDialects.MyDialect1.class ) );
 		resolvers.addResolver( new BasicDialectResolver( "MyDatabase2", 1, TestingDialects.MyDialect21.class ) );
 		resolvers.addResolver( new BasicDialectResolver( "MyDatabase2", 2, TestingDialects.MyDialect22.class ) );
 		resolvers.addResolver( new BasicDialectResolver( "ErrorDatabase1", Object.class ) );
 		testDetermination( resolvers, "MyDatabase1", 1, TestingDialects.MyDialect1.class );
 
 		testDetermination( resolvers, "MyDatabase1", 2, TestingDialects.MyDialect1.class );
 		testDetermination( resolvers, "MyDatabase2", 0, null );
 		testDetermination( resolvers, "MyDatabase2", 1, TestingDialects.MyDialect21.class );
 		testDetermination( resolvers, "MyDatabase2", 2, TestingDialects.MyDialect22.class );
 		testDetermination( resolvers, "ErrorDatabase1", 0, null );
 	}
 
 
 	private void testDetermination(
 			DialectResolver resolver,
 			String databaseName,
 			int version,
 			Class dialectClass) throws SQLException {
 		Dialect dialect = resolver.resolveDialect( Mocks.createConnection( databaseName, version ).getMetaData() );
 		if ( dialectClass == null ) {
 			assertEquals( null, dialect );
 		}
 		else {
 			assertEquals( dialectClass, dialect.getClass() );
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/AbstractBasicBindingTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/AbstractBasicBindingTests.java
index 9e9f26a82a..1fecfaeabd 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/AbstractBasicBindingTests.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/AbstractBasicBindingTests.java
@@ -1,206 +1,206 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.binding;
 
 import java.sql.Types;
 import java.util.Iterator;
 import java.util.Set;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.domain.BasicType;
 import org.hibernate.metamodel.domain.SingularAttribute;
 import org.hibernate.metamodel.relational.Column;
 import org.hibernate.metamodel.relational.Datatype;
 import org.hibernate.metamodel.relational.SimpleValue;
 import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.metamodel.source.internal.MetadataImpl;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 import org.hibernate.type.LongType;
 import org.hibernate.type.StringType;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Basic tests of {@code hbm.xml} and annotation binding code
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractBasicBindingTests extends BaseUnitTestCase {
 
 	private StandardServiceRegistryImpl serviceRegistry;
 
 	@Before
 	public void setUp() {
-		serviceRegistry = (StandardServiceRegistryImpl) new ServiceRegistryBuilder().buildServiceRegistry();
+		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().buildServiceRegistry();
 	}
 
 	@After
 	public void tearDown() {
 		serviceRegistry.destroy();
 	}
 
 	protected ServiceRegistry basicServiceRegistry() {
 		return serviceRegistry;
 	}
 
 	@Test
 	public void testSimpleEntityMapping() {
 		MetadataSources sources = new MetadataSources( serviceRegistry );
 		addSourcesForSimpleEntityBinding( sources );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 		EntityBinding entityBinding = metadata.getEntityBinding( SimpleEntity.class.getName() );
 		assertRoot( metadata, entityBinding );
 		assertIdAndSimpleProperty( entityBinding );
 
 		assertNull( entityBinding.getHierarchyDetails().getVersioningAttributeBinding() );
 	}
 
 	@Test
 	public void testSimpleVersionedEntityMapping() {
 		MetadataSources sources = new MetadataSources( serviceRegistry );
 		addSourcesForSimpleVersionedEntityBinding( sources );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 		EntityBinding entityBinding = metadata.getEntityBinding( SimpleVersionedEntity.class.getName() );
 		assertIdAndSimpleProperty( entityBinding );
 
 		assertNotNull( entityBinding.getHierarchyDetails().getVersioningAttributeBinding() );
 		assertNotNull( entityBinding.getHierarchyDetails().getVersioningAttributeBinding().getAttribute() );
 	}
 
 	@Test
 	public void testEntityWithManyToOneMapping() {
 		MetadataSources sources = new MetadataSources( serviceRegistry );
 		addSourcesForSimpleEntityBinding( sources );
 		addSourcesForManyToOne( sources );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 
 		EntityBinding simpleEntityBinding = metadata.getEntityBinding( SimpleEntity.class.getName() );
 		assertIdAndSimpleProperty( simpleEntityBinding );
 
 		Set<SingularAssociationAttributeBinding> referenceBindings = simpleEntityBinding.locateAttributeBinding( "id" )
 				.getEntityReferencingAttributeBindings();
 		assertEquals( "There should be only one reference binding", 1, referenceBindings.size() );
 
 		SingularAssociationAttributeBinding referenceBinding = referenceBindings.iterator().next();
 		EntityBinding referencedEntityBinding = referenceBinding.getReferencedEntityBinding();
 		// TODO - Is this assertion correct (HF)?
 		assertEquals( "Should be the same entity binding", referencedEntityBinding, simpleEntityBinding );
 
 		EntityBinding entityWithManyToOneBinding = metadata.getEntityBinding( ManyToOneEntity.class.getName() );
 		Iterator<SingularAssociationAttributeBinding> it = entityWithManyToOneBinding.getEntityReferencingAttributeBindings()
 				.iterator();
 		assertTrue( it.hasNext() );
 		assertSame( entityWithManyToOneBinding.locateAttributeBinding( "simpleEntity" ), it.next() );
 		assertFalse( it.hasNext() );
 	}
 
 	@Test
 	public void testSimpleEntityWithSimpleComponentMapping() {
 		MetadataSources sources = new MetadataSources( serviceRegistry );
 		addSourcesForComponentBinding( sources );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 		EntityBinding entityBinding = metadata.getEntityBinding( SimpleEntityWithSimpleComponent.class.getName() );
 		assertRoot( metadata, entityBinding );
 		assertIdAndSimpleProperty( entityBinding );
 
 		ComponentAttributeBinding componentAttributeBinding = (ComponentAttributeBinding) entityBinding.locateAttributeBinding( "simpleComponent" );
 		assertNotNull( componentAttributeBinding );
 		assertSame( componentAttributeBinding.getAttribute().getSingularAttributeType(), componentAttributeBinding.getAttributeContainer() );
 		assertEquals( SimpleEntityWithSimpleComponent.class.getName() + ".simpleComponent", componentAttributeBinding.getPathBase() );
 		assertSame( entityBinding, componentAttributeBinding.seekEntityBinding() );
 		assertNotNull( componentAttributeBinding.getComponent() );
 	}
 
 	public abstract void addSourcesForSimpleVersionedEntityBinding(MetadataSources sources);
 
 	public abstract void addSourcesForSimpleEntityBinding(MetadataSources sources);
 
 	public abstract void addSourcesForManyToOne(MetadataSources sources);
 
 	public abstract void addSourcesForComponentBinding(MetadataSources sources);
 
 	protected void assertIdAndSimpleProperty(EntityBinding entityBinding) {
 		assertNotNull( entityBinding );
 		assertNotNull( entityBinding.getHierarchyDetails().getEntityIdentifier() );
 		assertNotNull( entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding() );
 
 		AttributeBinding idAttributeBinding = entityBinding.locateAttributeBinding( "id" );
 		assertNotNull( idAttributeBinding );
 		assertSame( idAttributeBinding, entityBinding.getHierarchyDetails().getEntityIdentifier().getValueBinding() );
 		assertSame( LongType.INSTANCE, idAttributeBinding.getHibernateTypeDescriptor().getResolvedTypeMapping() );
 
 		assertTrue( idAttributeBinding.getAttribute().isSingular() );
 		assertNotNull( idAttributeBinding.getAttribute() );
 		SingularAttributeBinding singularIdAttributeBinding = (SingularAttributeBinding) idAttributeBinding;
 		assertFalse( singularIdAttributeBinding.isNullable() );
 		SingularAttribute singularIdAttribute =  ( SingularAttribute ) idAttributeBinding.getAttribute();
 		BasicType basicIdAttributeType = ( BasicType ) singularIdAttribute.getSingularAttributeType();
 		assertSame( Long.class, basicIdAttributeType.getClassReference() );
 
 		assertNotNull( singularIdAttributeBinding.getValue() );
 		assertTrue( singularIdAttributeBinding.getValue() instanceof Column );
 		Datatype idDataType = ( (Column) singularIdAttributeBinding.getValue() ).getDatatype();
 		assertSame( Long.class, idDataType.getJavaType() );
 		assertSame( Types.BIGINT, idDataType.getTypeCode() );
 		assertSame( LongType.INSTANCE.getName(), idDataType.getTypeName() );
 
 		assertNotNull( entityBinding.locateAttributeBinding( "name" ) );
 		assertNotNull( entityBinding.locateAttributeBinding( "name" ).getAttribute() );
 		assertTrue( entityBinding.locateAttributeBinding( "name" ).getAttribute().isSingular() );
 
 		SingularAttributeBinding nameBinding = (SingularAttributeBinding) entityBinding.locateAttributeBinding( "name" );
 		assertTrue( nameBinding.isNullable() );
 		assertSame( StringType.INSTANCE, nameBinding.getHibernateTypeDescriptor().getResolvedTypeMapping() );
 		assertNotNull( nameBinding.getAttribute() );
 		assertNotNull( nameBinding.getValue() );
 		SingularAttribute singularNameAttribute =  ( SingularAttribute ) nameBinding.getAttribute();
 		BasicType basicNameAttributeType = ( BasicType ) singularNameAttribute.getSingularAttributeType();
 		assertSame( String.class, basicNameAttributeType.getClassReference() );
 
 		assertNotNull( nameBinding.getValue() );
 		SimpleValue nameValue = (SimpleValue) nameBinding.getValue();
 		assertTrue( nameValue instanceof Column );
 		Datatype nameDataType = nameValue.getDatatype();
 		assertSame( String.class, nameDataType.getJavaType() );
 		assertSame( Types.VARCHAR, nameDataType.getTypeCode() );
 		assertSame( StringType.INSTANCE.getName(), nameDataType.getTypeName() );
 	}
 
 	protected void assertRoot(MetadataImplementor metadata, EntityBinding entityBinding) {
 		assertTrue( entityBinding.isRoot() );
 		assertSame( entityBinding, metadata.getRootEntityBinding( entityBinding.getEntity().getName() ) );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicCollectionBindingTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicCollectionBindingTests.java
index 80cc00ee6d..98b8e26dc3 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicCollectionBindingTests.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/BasicCollectionBindingTests.java
@@ -1,90 +1,90 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.binding;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.metamodel.MetadataSourceProcessingOrder;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.source.internal.MetadataImpl;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertSame;
 
 /**
  * @author Steve Ebersole
  */
 public class BasicCollectionBindingTests extends BaseUnitTestCase {
 	private StandardServiceRegistryImpl serviceRegistry;
 
 	@Before
 	public void setUp() {
-		serviceRegistry = (StandardServiceRegistryImpl) new ServiceRegistryBuilder().buildServiceRegistry();
+		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().buildServiceRegistry();
 	}
 
 	@After
 	public void tearDown() {
 		serviceRegistry.destroy();
 	}
 
 //	@Test
 //	public void testAnnotations() {
 //		doTest( MetadataSourceProcessingOrder.ANNOTATIONS_FIRST );
 //	}
 
 	@Test
 	public void testHbm() {
 		doTest( MetadataSourceProcessingOrder.HBM_FIRST );
 	}
 
 	private void doTest(MetadataSourceProcessingOrder processingOrder) {
 		MetadataSources sources = new MetadataSources( serviceRegistry );
 //		sources.addAnnotatedClass( EntityWithBasicCollections.class );
 		sources.addResource( "org/hibernate/metamodel/binding/EntityWithBasicCollections.hbm.xml" );
 		MetadataImpl metadata = (MetadataImpl) sources.getMetadataBuilder().with( processingOrder ).buildMetadata();
 
 		final EntityBinding entityBinding = metadata.getEntityBinding( EntityWithBasicCollections.class.getName() );
 		assertNotNull( entityBinding );
 
 		PluralAttributeBinding bagBinding = metadata.getCollection( EntityWithBasicCollections.class.getName() + ".theBag" );
 		assertNotNull( bagBinding );
 		assertSame( bagBinding, entityBinding.locateAttributeBinding( "theBag" ) );
 		assertNotNull( bagBinding.getCollectionTable() );
 		assertEquals( CollectionElementNature.BASIC, bagBinding.getCollectionElement().getCollectionElementNature() );
 		assertEquals( String.class.getName(), ( (BasicCollectionElement) bagBinding.getCollectionElement() ).getHibernateTypeDescriptor().getJavaTypeName() );
 
 		PluralAttributeBinding setBinding = metadata.getCollection( EntityWithBasicCollections.class.getName() + ".theSet" );
 		assertNotNull( setBinding );
 		assertSame( setBinding, entityBinding.locateAttributeBinding( "theSet" ) );
 		assertNotNull( setBinding.getCollectionTable() );
 		assertEquals( CollectionElementNature.BASIC, setBinding.getCollectionElement().getCollectionElementNature() );
 		assertEquals( String.class.getName(), ( (BasicCollectionElement) setBinding.getCollectionElement() ).getHibernateTypeDescriptor().getJavaTypeName() );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleValueBindingTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleValueBindingTests.java
index 2b62e8b585..bf7c6d177c 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleValueBindingTests.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/binding/SimpleValueBindingTests.java
@@ -1,92 +1,92 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.binding;
 
 import java.sql.Types;
 
 import org.junit.Test;
 
 import org.hibernate.EntityMode;
 import org.hibernate.internal.util.ValueHolder;
 import org.hibernate.metamodel.domain.Entity;
 import org.hibernate.metamodel.domain.SingularAttribute;
 import org.hibernate.metamodel.relational.Column;
 import org.hibernate.metamodel.relational.Datatype;
 import org.hibernate.metamodel.relational.Schema;
 import org.hibernate.metamodel.relational.Size;
 import org.hibernate.metamodel.relational.Table;
-import org.hibernate.service.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertSame;
 
 /**
  * Basic binding "smoke" tests
  *
  * @author Steve Ebersole
  */
 public class SimpleValueBindingTests extends BaseUnitTestCase {
 	public static final Datatype BIGINT = new Datatype( Types.BIGINT, "BIGINT", Long.class );
 	public static final Datatype VARCHAR = new Datatype( Types.VARCHAR, "VARCHAR", String.class );
 
 
 	@Test
 	public void testBasicMiddleOutBuilding() {
 		Table table = new Table( new Schema( null, null ), "the_table" );
 		Entity entity = new Entity( "TheEntity", "NoSuchClass", makeJavaType( "NoSuchClass" ), null );
 		EntityBinding entityBinding = new EntityBinding( InheritanceType.NO_INHERITANCE, EntityMode.POJO );
 		entityBinding.setEntity( entity );
 		entityBinding.setPrimaryTable( table );
 
 		SingularAttribute idAttribute = entity.createSingularAttribute( "id" );
 		BasicAttributeBinding attributeBinding = entityBinding.makeBasicAttributeBinding( idAttribute );
 		attributeBinding.getHibernateTypeDescriptor().setExplicitTypeName( "long" );
 		assertSame( idAttribute, attributeBinding.getAttribute() );
 
 		entityBinding.getHierarchyDetails().getEntityIdentifier().setValueBinding( attributeBinding );
 
 		Column idColumn = table.locateOrCreateColumn( "id" );
 		idColumn.setDatatype( BIGINT );
 		idColumn.setSize( Size.precision( 18, 0 ) );
 		table.getPrimaryKey().addColumn( idColumn );
 		table.getPrimaryKey().setName( "my_table_pk" );
 		//attributeBinding.setValue( idColumn );
 	}
 
 	ValueHolder<Class<?>> makeJavaType(final String name) {
 		return new ValueHolder<Class<?>>(
 				new ValueHolder.DeferredInitializer<Class<?>>() {
 					@Override
 					public Class<?> initialize() {
 						try {
 							return Class.forName( name );
 						}
 						catch ( Exception e ) {
 							throw new ClassLoadingException( "Could not load class : " + name, e );
 						}
 					}
 				}
 		);
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/BaseAnnotationBindingTestCase.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/BaseAnnotationBindingTestCase.java
index 5f9ed9dd90..09e8ccd094 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/BaseAnnotationBindingTestCase.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/BaseAnnotationBindingTestCase.java
@@ -1,128 +1,129 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.entity;
 
 import org.junit.After;
 import org.junit.Rule;
 import org.junit.Test;
 import org.junit.rules.MethodRule;
 import org.junit.runners.model.FrameworkMethod;
 import org.junit.runners.model.Statement;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.source.internal.MetadataImpl;
-import org.hibernate.service.ServiceRegistryBuilder;
+
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 /**
  * @author Hardy Ferentschik
  */
 public abstract class BaseAnnotationBindingTestCase extends BaseUnitTestCase {
 	protected MetadataSources sources;
 	protected MetadataImpl meta;
 
 	@Rule
 	public MethodRule buildMetaData = new MethodRule() {
 		@Override
 		public Statement apply(final Statement statement, FrameworkMethod frameworkMethod, Object o) {
 			return new KeepSetupFailureStatement( statement, frameworkMethod );
 		}
 	};
 
 	@After
 	public void tearDown() {
 		sources = null;
 		meta = null;
 	}
 
 	public EntityBinding getEntityBinding(Class<?> clazz) {
 		return meta.getEntityBinding( clazz.getName() );
 	}
 
 	public EntityBinding getRootEntityBinding(Class<?> clazz) {
 		return meta.getRootEntityBinding( clazz.getName() );
 	}
 
 	class KeepSetupFailureStatement extends Statement {
 		private final Statement origStatement;
 		private final FrameworkMethod origFrameworkMethod;
 		private Throwable setupError;
 		private boolean expectedException;
 
 		KeepSetupFailureStatement(Statement statement, FrameworkMethod frameworkMethod) {
 			this.origStatement = statement;
 			this.origFrameworkMethod = frameworkMethod;
 		}
 
 		@Override
 		public void evaluate() throws Throwable {
 			try {
 				createBindings();
 				origStatement.evaluate();
 				if ( setupError != null ) {
 					throw setupError;
 				}
 			}
 			catch ( Throwable t ) {
 				if ( setupError == null ) {
 					throw t;
 				}
 				else {
 					if ( !expectedException ) {
 						throw setupError;
 					}
 				}
 			}
 		}
 
 		private void createBindings() {
 			try {
-				sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
+				sources = new MetadataSources( new StandardServiceRegistryBuilder().buildServiceRegistry() );
 				Resources resourcesAnnotation = origFrameworkMethod.getAnnotation( Resources.class );
 				if ( resourcesAnnotation != null ) {
 					sources.getMetadataBuilder().with( resourcesAnnotation.cacheMode() );
 
 					for ( Class<?> annotatedClass : resourcesAnnotation.annotatedClasses() ) {
 						sources.addAnnotatedClass( annotatedClass );
 					}
 					if ( !resourcesAnnotation.ormXmlPath().isEmpty() ) {
 						sources.addResource( resourcesAnnotation.ormXmlPath() );
 					}
 				}
 				meta = (MetadataImpl) sources.buildMetadata();
 			}
 			catch ( final Throwable t ) {
 				setupError = t;
 				Test testAnnotation = origFrameworkMethod.getAnnotation( Test.class );
 				Class<?> expected = testAnnotation.expected();
 				if ( t.getClass().equals( expected ) ) {
 					expectedException = true;
 				}
 			}
 		}
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/IdentifierGeneratorTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/IdentifierGeneratorTest.java
index 12c87aa8b6..1e54fc4fa2 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/IdentifierGeneratorTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/IdentifierGeneratorTest.java
@@ -1,182 +1,182 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
 package org.hibernate.metamodel.source.annotations.entity;
 
 import javax.persistence.Entity;
 import javax.persistence.GeneratedValue;
 import javax.persistence.GenerationType;
 import javax.persistence.Id;
 
 import org.junit.Test;
 
 import org.hibernate.annotations.GenericGenerator;
 import org.hibernate.id.Assigned;
 import org.hibernate.id.IdentifierGenerator;
 import org.hibernate.id.IdentityGenerator;
 import org.hibernate.id.MultipleHiLoPerTableGenerator;
 import org.hibernate.id.SequenceHiLoGenerator;
 import org.hibernate.id.UUIDHexGenerator;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.binding.EntityIdentifier;
 import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.service.ServiceRegistryBuilder;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertTrue;
 import static junit.framework.Assert.fail;
 
 /**
  * @author Hardy Ferentschik
  */
 public class IdentifierGeneratorTest extends BaseAnnotationBindingTestCase {
 	@Entity
 	class NoGenerationEntity {
 		@Id
 		private long id;
 	}
 
 	@Test
 	@Resources(annotatedClasses = NoGenerationEntity.class)
 	public void testNoIdGeneration() {
 		EntityBinding binding = getEntityBinding( NoGenerationEntity.class );
         EntityIdentifier identifier = binding.getHierarchyDetails().getEntityIdentifier();
 		IdentifierGenerator generator =identifier.getIdentifierGenerator();
         assertNotNull( generator );
         assertEquals( "Wrong generator", Assigned.class, generator.getClass() );
         assertFalse( identifier.isEmbedded() );
 
 	}
 
 	@Entity
 	class AutoEntity {
 		@Id
 		@GeneratedValue
 		private long id;
 
 		public long getId() {
 			return id;
 		}
 	}
 
 	@Test
 	@Resources(annotatedClasses = AutoEntity.class)
 	public void testAutoGenerationType() {
 		EntityBinding binding = getEntityBinding( AutoEntity.class );
 		IdentifierGenerator generator = binding.getHierarchyDetails().getEntityIdentifier().getIdentifierGenerator();
 
 		assertEquals( "Wrong generator", IdentityGenerator.class, generator.getClass() );
 	}
 
 	@Entity
 	class TableEntity {
 		@Id
 		@GeneratedValue(strategy = GenerationType.TABLE)
 		private long id;
 
 		public long getId() {
 			return id;
 		}
 	}
 
 	@Test
 	@Resources(annotatedClasses = TableEntity.class)
 	public void testTableGenerationType() {
 		EntityBinding binding = getEntityBinding( TableEntity.class );
 		IdentifierGenerator generator = binding.getHierarchyDetails().getEntityIdentifier().getIdentifierGenerator();
 
 		assertEquals( "Wrong generator", MultipleHiLoPerTableGenerator.class, generator.getClass() );
 	}
 
 	@Entity
 	class SequenceEntity {
 		@Id
 		@GeneratedValue(strategy = GenerationType.SEQUENCE)
 		private long id;
 
 		public long getId() {
 			return id;
 		}
 	}
 
 	@Test
 	@Resources(annotatedClasses = SequenceEntity.class)
 	public void testSequenceGenerationType() {
 		EntityBinding binding = getEntityBinding( SequenceEntity.class );
 		IdentifierGenerator generator = binding.getHierarchyDetails().getEntityIdentifier().getIdentifierGenerator();
 
 		assertEquals( "Wrong generator", SequenceHiLoGenerator.class, generator.getClass() );
 	}
 
 
 	@Entity
 	class NamedGeneratorEntity {
 		@Id
 		@GeneratedValue(generator = "my-generator")
 		private long id;
 
 		public long getId() {
 			return id;
 		}
 	}
 
 	@Test
 	public void testUndefinedGenerator() {
 		try {
-			sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
+			sources = new MetadataSources( new StandardServiceRegistryBuilder().buildServiceRegistry() );
 			sources.addAnnotatedClass( NamedGeneratorEntity.class );
 			sources.buildMetadata();
 			fail();
 		}
 		catch ( MappingException e ) {
 			assertTrue( e.getMessage().startsWith( "Unable to find named generator" ) );
 		}
 	}
 
 	@Entity
 	@GenericGenerator(name = "my-generator", strategy = "uuid")
 	class NamedGeneratorEntity2 {
 		@Id
 		@GeneratedValue(generator = "my-generator")
 		private long id;
 
 		public long getId() {
 			return id;
 		}
 	}
 
 	@Test
 	@Resources(annotatedClasses = NamedGeneratorEntity2.class)
 	public void testNamedGenerator() {
 		EntityBinding binding = getEntityBinding( NamedGeneratorEntity2.class );
 		IdentifierGenerator generator = binding.getHierarchyDetails().getEntityIdentifier().getIdentifierGenerator();
 
 		assertEquals( "Wrong generator", UUIDHexGenerator.class, generator.getClass() );
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/MapsIdTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/MapsIdTest.java
index f97e61ef67..810e552820 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/MapsIdTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/entity/MapsIdTest.java
@@ -1,96 +1,96 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
 package org.hibernate.metamodel.source.annotations.entity;
 
 import javax.persistence.Embeddable;
 import javax.persistence.Entity;
 import javax.persistence.Id;
 import javax.persistence.MapsId;
 import javax.persistence.OneToMany;
 
 import org.junit.Test;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.source.MappingException;
-import org.hibernate.service.ServiceRegistryBuilder;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertTrue;
 import static junit.framework.Assert.fail;
 
 /**
  * @author Hardy Ferentschik
  */
 public class MapsIdTest extends BaseAnnotationBindingTestCase {
 	@Entity
 	public class Employee {
 		@Id
 		long empId;
 		String name;
 	}
 
 	@Embeddable
 	public class DependentId {
 		String name;
 		long empid; // corresponds to PK type of Employee
 	}
 
 	@Entity
 	public class Dependent {
 		@Id
 		// should be @EmbeddedId, but embedded id are not working atm
 				DependentId id;
 
 		@MapsId("empid")
 		@OneToMany
 		Employee emp; // maps the empid attribute of embedded id @ManyToOne Employee emp;
 	}
 
 	@Test
 	@Resources(annotatedClasses = DependentId.class)
 	public void testMapsIsOnOneToManyThrowsException() {
 		try {
-			sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
+			sources = new MetadataSources( new StandardServiceRegistryBuilder().buildServiceRegistry() );
 			sources.addAnnotatedClass( DependentId.class );
 			sources.addAnnotatedClass( Dependent.class );
 			sources.addAnnotatedClass( Employee.class );
 			sources.buildMetadata();
 			fail();
 		}
 		catch ( MappingException e ) {
 			assertTrue(
 					e.getMessage()
 							.startsWith( "@MapsId can only be specified on a many-to-one or one-to-one associations" )
 			);
 			assertEquals(
 					"Wrong error origin",
 					"org.hibernate.metamodel.source.annotations.entity.MapsIdTest$Dependent",
 					e.getOrigin().getName()
 			);
 		}
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinderTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinderTest.java
index 344f7da7a2..c82551a5f8 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinderTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/FetchProfileBinderTest.java
@@ -1,146 +1,146 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.global;
 
 import java.util.Iterator;
 
 import org.jboss.jandex.Index;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.MappingException;
 import org.hibernate.annotations.FetchMode;
 import org.hibernate.annotations.FetchProfile;
 import org.hibernate.annotations.FetchProfiles;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.source.annotations.AnnotationBindingContextImpl;
 import org.hibernate.metamodel.source.annotations.JandexHelper;
 import org.hibernate.metamodel.source.internal.MetadataImpl;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static junit.framework.Assert.fail;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Hardy Ferentschik
  */
 public class FetchProfileBinderTest extends BaseUnitTestCase {
 
 	private StandardServiceRegistryImpl serviceRegistry;
 	private ClassLoaderService service;
 	private MetadataImpl meta;
 
 	@Before
 	public void setUp() {
-		serviceRegistry = (StandardServiceRegistryImpl) new ServiceRegistryBuilder().buildServiceRegistry();
+		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().buildServiceRegistry();
 		service = serviceRegistry.getService( ClassLoaderService.class );
 		meta = (MetadataImpl) new MetadataSources( serviceRegistry ).buildMetadata();
 	}
 
 	@After
 	public void tearDown() {
 		serviceRegistry.destroy();
 	}
 
 	@Test
 	public void testSingleFetchProfile() {
 		@FetchProfile(name = "foo", fetchOverrides = {
 				@FetchProfile.FetchOverride(entity = Foo.class, association = "bar", mode = FetchMode.JOIN)
 		})
 		class Foo {
 		}
 		Index index = JandexHelper.indexForClass( service, Foo.class );
 
 		FetchProfileBinder.bind( new AnnotationBindingContextImpl( meta, index ) );
 
 		Iterator<org.hibernate.metamodel.binding.FetchProfile> mappedFetchProfiles = meta.getFetchProfiles().iterator();
 		assertTrue( mappedFetchProfiles.hasNext() );
 		org.hibernate.metamodel.binding.FetchProfile profile = mappedFetchProfiles.next();
 		assertEquals( "Wrong fetch profile name", "foo", profile.getName() );
 		org.hibernate.metamodel.binding.FetchProfile.Fetch fetch = profile.getFetches().iterator().next();
 		assertEquals( "Wrong association name", "bar", fetch.getAssociation() );
 		assertEquals( "Wrong association type", Foo.class.getName(), fetch.getEntity() );
 	}
 
 	@Test
 	public void testFetchProfiles() {
 		Index index = JandexHelper.indexForClass( service, FooBar.class );
 		FetchProfileBinder.bind( new AnnotationBindingContextImpl( meta, index ) );
 
 		Iterator<org.hibernate.metamodel.binding.FetchProfile> mappedFetchProfiles = meta.getFetchProfiles().iterator();
 		assertTrue( mappedFetchProfiles.hasNext() );
 		org.hibernate.metamodel.binding.FetchProfile profile = mappedFetchProfiles.next();
 		assertProfiles( profile );
 
 		assertTrue( mappedFetchProfiles.hasNext() );
 		profile = mappedFetchProfiles.next();
 		assertProfiles( profile );
 	}
 
 	private void assertProfiles(org.hibernate.metamodel.binding.FetchProfile profile) {
 		if ( profile.getName().equals( "foobar" ) ) {
 			org.hibernate.metamodel.binding.FetchProfile.Fetch fetch = profile.getFetches().iterator().next();
 			assertEquals( "Wrong association name", "foobar", fetch.getAssociation() );
 			assertEquals( "Wrong association type", FooBar.class.getName(), fetch.getEntity() );
 		}
 		else if ( profile.getName().equals( "fubar" ) ) {
 			org.hibernate.metamodel.binding.FetchProfile.Fetch fetch = profile.getFetches().iterator().next();
 			assertEquals( "Wrong association name", "fubar", fetch.getAssociation() );
 			assertEquals( "Wrong association type", FooBar.class.getName(), fetch.getEntity() );
 		}
 		else {
 			fail( "Wrong fetch name:" + profile.getName() );
 		}
 	}
 
 	@Test(expected = MappingException.class)
 	public void testNonJoinFetchThrowsException() {
 		@FetchProfile(name = "foo", fetchOverrides = {
 				@FetchProfile.FetchOverride(entity = Foo.class, association = "bar", mode = FetchMode.SELECT)
 		})
 		class Foo {
 		}
 		Index index = JandexHelper.indexForClass( service, Foo.class );
 
 		FetchProfileBinder.bind( new AnnotationBindingContextImpl( meta, index ) );
 	}
 
 	@FetchProfiles( {
 			@FetchProfile(name = "foobar", fetchOverrides = {
 					@FetchProfile.FetchOverride(entity = FooBar.class, association = "foobar", mode = FetchMode.JOIN)
 			}),
 			@FetchProfile(name = "fubar", fetchOverrides = {
 					@FetchProfile.FetchOverride(entity = FooBar.class, association = "fubar", mode = FetchMode.JOIN)
 			})
 	})
 	class FooBar {
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/QueryBinderTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/QueryBinderTest.java
index 50e8a80b04..f84ee9b688 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/QueryBinderTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/global/QueryBinderTest.java
@@ -1,98 +1,98 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.global;
 
 import javax.persistence.NamedNativeQuery;
 
 import org.jboss.jandex.Index;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.NotYetImplementedException;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryReturn;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryRootReturn;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.source.annotations.AnnotationBindingContextImpl;
 import org.hibernate.metamodel.source.annotations.JandexHelper;
 import org.hibernate.metamodel.source.internal.MetadataImpl;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertTrue;
 
 /**
  * @author Hardy Ferentschik
  */
 public class QueryBinderTest extends BaseUnitTestCase {
 
 	private StandardServiceRegistryImpl serviceRegistry;
 	private ClassLoaderService service;
 	private MetadataImpl meta;
 
 	@Before
 	public void setUp() {
-		serviceRegistry = (StandardServiceRegistryImpl) new ServiceRegistryBuilder().buildServiceRegistry();
+		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().buildServiceRegistry();
 		service = serviceRegistry.getService( ClassLoaderService.class );
 		meta = (MetadataImpl) new MetadataSources( serviceRegistry ).buildMetadata();
 	}
 
 	@After
 	public void tearDown() {
 		serviceRegistry.destroy();
 	}
 
 	@Test(expected = NotYetImplementedException.class)
 	public void testNoResultClass() {
 		@NamedNativeQuery(name = "fubar", query = "SELECT * FROM FOO")
 		class Foo {
 		}
 		Index index = JandexHelper.indexForClass( service, Foo.class );
 		QueryBinder.bind( new AnnotationBindingContextImpl( meta, index ) );
 	}
 
 	@Test
 	public void testResultClass() {
 		@NamedNativeQuery(name = "fubar", query = "SELECT * FROM FOO", resultClass = Foo.class)
 		class Foo {
 		}
 		Index index = JandexHelper.indexForClass( service, Foo.class );
 		QueryBinder.bind( new AnnotationBindingContextImpl( meta, index ) );
 
 		NamedSQLQueryDefinition namedQuery = meta.getNamedNativeQuery( "fubar" );
 		assertNotNull( namedQuery );
 		NativeSQLQueryReturn queryReturns[] = namedQuery.getQueryReturns();
 		assertTrue( "Wrong number of returns", queryReturns.length == 1 );
 		assertTrue( "Wrong query return type", queryReturns[0] instanceof NativeSQLQueryRootReturn );
 		NativeSQLQueryRootReturn rootReturn = (NativeSQLQueryRootReturn) queryReturns[0];
 		assertEquals( "Wrong result class", Foo.class.getName(), rootReturn.getReturnEntityName() );
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/BaseAnnotationIndexTestCase.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/BaseAnnotationIndexTestCase.java
index 0166c85a0b..d067e55ecd 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/BaseAnnotationIndexTestCase.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/BaseAnnotationIndexTestCase.java
@@ -1,80 +1,80 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.util;
 
 import java.util.Set;
 import javax.persistence.AccessType;
 
 import org.jboss.jandex.Index;
 import org.junit.After;
 import org.junit.Before;
 
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.source.annotations.AnnotationBindingContext;
 import org.hibernate.metamodel.source.annotations.AnnotationBindingContextImpl;
 import org.hibernate.metamodel.source.annotations.EntityHierarchyBuilder;
 import org.hibernate.metamodel.source.annotations.JandexHelper;
 import org.hibernate.metamodel.source.annotations.entity.EmbeddableHierarchy;
 import org.hibernate.metamodel.source.binder.EntityHierarchy;
 import org.hibernate.metamodel.source.internal.MetadataImpl;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 /**
  * @author Hardy Ferentschik
  */
 public abstract class BaseAnnotationIndexTestCase extends BaseUnitTestCase {
 	private MetadataImpl meta;
 
 	@Before
 	public void setUp() {
-		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
+		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().buildServiceRegistry() );
 		meta = (MetadataImpl) sources.buildMetadata();
 	}
 
 	@After
 	public void tearDown() {
 	}
 
 	public Set<EntityHierarchy> createEntityHierarchies(Class<?>... clazz) {
 		Index index = JandexHelper.indexForClass(
 				meta.getServiceRegistry().getService( ClassLoaderService.class ),
 				clazz
 		);
 		AnnotationBindingContext context = new AnnotationBindingContextImpl( meta, index );
 		return EntityHierarchyBuilder.createEntityHierarchies( context );
 	}
 
 	public EmbeddableHierarchy createEmbeddableHierarchy(AccessType accessType, Class<?>... configuredClasses) {
 		Index index = JandexHelper.indexForClass(
 				meta.getServiceRegistry().getService( ClassLoaderService.class ),
 				configuredClasses
 		);
 		AnnotationBindingContext context = new AnnotationBindingContextImpl( meta, index );
 		return EmbeddableHierarchy.createEmbeddableHierarchy( configuredClasses[0], "", accessType, context );
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/JandexHelperTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/JandexHelperTest.java
index ec326a806a..a77347ccab 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/JandexHelperTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/util/JandexHelperTest.java
@@ -1,249 +1,249 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.util;
 
 import java.util.List;
 import java.util.Map;
 import javax.persistence.AttributeOverride;
 import javax.persistence.Basic;
 import javax.persistence.Column;
 import javax.persistence.Entity;
 import javax.persistence.LockModeType;
 import javax.persistence.NamedQuery;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.annotations.NamedNativeQuery;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.metamodel.source.annotations.HibernateDotNames;
 import org.hibernate.metamodel.source.annotations.JPADotNames;
 import org.hibernate.metamodel.source.annotations.JandexHelper;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static junit.framework.Assert.assertTrue;
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.fail;
 
 /**
  * Tests for the helper class {@link JandexHelper}.
  *
  * @author Hardy Ferentschik
  */
 public class JandexHelperTest extends BaseUnitTestCase {
 	private StandardServiceRegistryImpl serviceRegistry;
 	private ClassLoaderService classLoaderService;
 
 	@Before
 	public void setUp() {
-		serviceRegistry = (StandardServiceRegistryImpl) new ServiceRegistryBuilder().buildServiceRegistry();
+		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder().buildServiceRegistry();
 		classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 	}
 
 	@After
 	public void tearDown() {
 		serviceRegistry.destroy();
 	}
 
 	@Test
 	public void testGetMemberAnnotations() {
 		class Foo {
 			@Column
 			@Basic
 			private String bar;
 			private String fubar;
 		}
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 
 		ClassInfo classInfo = index.getClassByName( DotName.createSimple( Foo.class.getName() ) );
 		Map<DotName, List<AnnotationInstance>> memberAnnotations = JandexHelper.getMemberAnnotations(
 				classInfo, "bar"
 		);
 		assertTrue(
 				"property bar should defines @Column annotation",
 				memberAnnotations.containsKey( DotName.createSimple( Column.class.getName() ) )
 		);
 		assertTrue(
 				"property bar should defines @Basic annotation",
 				memberAnnotations.containsKey( DotName.createSimple( Basic.class.getName() ) )
 		);
 
 		memberAnnotations = JandexHelper.getMemberAnnotations( classInfo, "fubar" );
 		assertTrue( "there should be no annotations in fubar", memberAnnotations.isEmpty() );
 	}
 
 	@Test
 	public void testGettingNestedAnnotation() {
 		@AttributeOverride(name = "foo", column = @Column(name = "FOO"))
 		class Foo {
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.ATTRIBUTE_OVERRIDE );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		// try to retrieve the name
 		String name = JandexHelper.getValue( annotationInstance, "name", String.class );
 		assertEquals( "Wrong nested annotation", "foo", name );
 
 		// try to retrieve the nested column annotation instance
 		AnnotationInstance columnAnnotationInstance = JandexHelper.getValue(
 				annotationInstance,
 				"column",
 				AnnotationInstance.class
 		);
 		assertNotNull( columnAnnotationInstance );
 		assertEquals(
 				"Wrong nested annotation",
 				"javax.persistence.Column",
 				columnAnnotationInstance.name().toString()
 		);
 	}
 
 	@Test(expected = AssertionFailure.class)
 	public void testTryingToRetrieveWrongType() {
 		@AttributeOverride(name = "foo", column = @Column(name = "FOO"))
 		class Foo {
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.ATTRIBUTE_OVERRIDE );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		JandexHelper.getValue( annotationInstance, "name", Float.class );
 	}
 
 	@Test
 	public void testRetrieveDefaultEnumElement() {
 		@NamedQuery(name = "foo", query = "fubar")
 		class Foo {
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.NAMED_QUERY );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		LockModeType lockMode = JandexHelper.getEnumValue( annotationInstance, "lockMode", LockModeType.class );
 		assertEquals( "Wrong lock mode", LockModeType.NONE, lockMode );
 	}
 
 	@Test
 	public void testRetrieveExplicitEnumElement() {
 		@NamedQuery(name = "foo", query = "bar", lockMode = LockModeType.OPTIMISTIC)
 		class Foo {
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.NAMED_QUERY );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		LockModeType lockMode = JandexHelper.getEnumValue( annotationInstance, "lockMode", LockModeType.class );
 		assertEquals( "Wrong lock mode", LockModeType.OPTIMISTIC, lockMode );
 	}
 
 	@Test
 	public void testRetrieveStringArray() {
 		class Foo {
 			@org.hibernate.annotations.Index(name = "index", columnNames = { "a", "b", "c" })
 			private String foo;
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( HibernateDotNames.INDEX );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		String[] columnNames = JandexHelper.getValue( annotationInstance, "columnNames", String[].class );
 		Assert.assertTrue( columnNames.length == 3 );
 	}
 
 	@Test(expected = AssertionFailure.class)
 	public void testRetrieveClassParameterAsClass() {
 		@NamedNativeQuery(name = "foo", query = "bar", resultClass = Foo.class)
 		class Foo {
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( HibernateDotNames.NAMED_NATIVE_QUERY );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		JandexHelper.getValue( annotationInstance, "resultClass", Class.class );
 	}
 
 	@Test
 	public void testRetrieveClassParameterAsString() {
 		@NamedNativeQuery(name = "foo", query = "bar", resultClass = Foo.class)
 		class Foo {
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( HibernateDotNames.NAMED_NATIVE_QUERY );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		String fqcn = JandexHelper.getValue( annotationInstance, "resultClass", String.class );
 		assertEquals( "Wrong class names", Foo.class.getName(), fqcn );
 	}
 
 	@Test
 	public void testRetrieveUnknownParameter() {
 		@Entity
 		class Foo {
 		}
 
 		Index index = JandexHelper.indexForClass( classLoaderService, Foo.class );
 		List<AnnotationInstance> annotationInstances = index.getAnnotations( JPADotNames.ENTITY );
 		assertTrue( annotationInstances.size() == 1 );
 		AnnotationInstance annotationInstance = annotationInstances.get( 0 );
 
 		try {
 			JandexHelper.getValue( annotationInstance, "foo", String.class );
 			fail();
 		}
 		catch ( AssertionFailure e ) {
 			assertTrue(
 					e.getMessage()
 							.startsWith( "The annotation javax.persistence.Entity does not define a parameter 'foo'" )
 			);
 		}
 	}
 
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/OrmXmlParserTests.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/OrmXmlParserTests.java
index ef2d70125d..c1935b1efd 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/OrmXmlParserTests.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/OrmXmlParserTests.java
@@ -1,69 +1,70 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.xml;
 
 import org.junit.Test;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.source.MappingException;
 import org.hibernate.metamodel.source.internal.MetadataImpl;
-import org.hibernate.service.ServiceRegistryBuilder;
+
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static junit.framework.Assert.assertNotNull;
 
 /**
  * @author Hardy Ferentschik
  */
 public class OrmXmlParserTests extends BaseUnitTestCase {
 	@Test
 	public void testSimpleOrmVersion2() {
-		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
+		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addResource( "org/hibernate/metamodel/source/annotations/xml/orm-father.xml" );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 
 		EntityBinding binding = metadata.getEntityBinding( Father.class.getName() );
 		assertNotNull( binding );
 	}
 
 	@Test
 	public void testSimpleOrmVersion1() {
-		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
+		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addResource( "org/hibernate/metamodel/source/annotations/xml/orm-star.xml" );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 
 		EntityBinding binding = metadata.getEntityBinding( Star.class.getName() );
 		assertNotNull( binding );
 	}
 
 	@Test(expected = MappingException.class)
 	public void testInvalidOrmXmlThrowsException() {
-		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
+		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addResource( "org/hibernate/metamodel/source/annotations/xml/orm-invalid.xml" );
 		sources.buildMetadata();
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMockerTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMockerTest.java
index 62a3c98b2e..0a47735ea3 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMockerTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/AbstractMockerTest.java
@@ -1,206 +1,206 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc..
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.util.ArrayList;
 import java.util.List;
 import javax.xml.bind.JAXBException;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.AnnotationValue;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.jboss.jandex.Indexer;
 
 import org.hibernate.AnnotationException;
 import org.hibernate.HibernateException;
 import org.hibernate.internal.jaxb.mapping.orm.JaxbEntityMappings;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.testing.ServiceRegistryBuilder;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 /**
  * @author Strong Liu
  */
 public abstract class AbstractMockerTest {
 	private static final String ORM1_MAPPING_XSD = "org/hibernate/ejb/orm_1_0.xsd";
 	private static final String ORM2_MAPPING_XSD = "org/hibernate/ejb/orm_2_0.xsd";
 	private IndexBuilder indexBuilder;
 	private Index index;
 	private ServiceRegistry serviceRegistry;
 	protected String packagePrefix = getClass().getPackage().getName().replace( '.', '/' ) + '/';
 
 	protected IndexBuilder getIndexBuilder() {
 		if ( indexBuilder == null ) {
 			indexBuilder = new IndexBuilder( getIndex(), getServiceRegistry() );
 		}
 		return indexBuilder;
 
 	}
 
 	protected EntityMappingsMocker getEntityMappingsMocker(String... mappingFiles) {
 		ClassLoaderService classLoaderService = getServiceRegistry().getService( ClassLoaderService.class );
 		List<JaxbEntityMappings> xmlEntityMappingsList = new ArrayList<JaxbEntityMappings>();
 		for ( String fileName : mappingFiles ) {
 			JaxbEntityMappings entityMappings;
 			try {
 				entityMappings = XmlHelper.unmarshallXml(
 						packagePrefix + fileName, ORM2_MAPPING_XSD, JaxbEntityMappings.class, classLoaderService
 				).getRoot();
 			}
 			catch ( JAXBException orm2Exception ) {
 				// if we cannot parse against orm_2_0.xsd we try orm_1_0.xsd for backwards compatibility
 				try {
 					entityMappings = XmlHelper.unmarshallXml(
 							packagePrefix + fileName, ORM1_MAPPING_XSD, JaxbEntityMappings.class, classLoaderService
 					).getRoot();
 				}
 				catch ( JAXBException orm1Exception ) {
 					throw new AnnotationException( "Unable to parse xml configuration.", orm1Exception );
 				}
 			}
 			xmlEntityMappingsList.add( entityMappings );
 		}
 		return new EntityMappingsMocker( xmlEntityMappingsList, getIndex(), getServiceRegistry() );
 	}
 
 	protected Index getIndex() {
 		if ( index == null ) {
 			Indexer indexer = new Indexer();
 			for ( Class<?> clazz : getAnnotatedClasses() ) {
 				indexClass( indexer, clazz.getName().replace( '.', '/' ) + ".class" );
 			}
 
 			// add package-info from the configured packages
 			for ( String packageName : getAnnotatedPackages() ) {
 				indexClass( indexer, packageName.replace( '.', '/' ) + "/package-info.class" );
 			}
 			index = indexer.complete();
 		}
 		return index;
 
 	}
 
 	protected Index getMockedIndex(String ormFileName) {
 		EntityMappingsMocker mocker = getEntityMappingsMocker( ormFileName );
 		return mocker.mockNewIndex();
 	}
 
 	private void indexClass(Indexer indexer, String className) {
 		ClassLoaderService classLoaderService = getServiceRegistry().getService( ClassLoaderService.class );
 		InputStream stream = classLoaderService.locateResourceStream( className );
 		try {
 			indexer.index( stream );
 		}
 		catch ( IOException e ) {
 			throw new HibernateException( "Unable to open input stream for class " + className, e );
 		}
 	}
 
 	protected Class[] getAnnotatedClasses() {
 		return new Class[0];
 	}
 
 	protected String[] getAnnotatedPackages() {
 		return new String[0];
 	}
 
 	protected ServiceRegistry getServiceRegistry() {
 		if ( serviceRegistry == null ) {
 			serviceRegistry = ServiceRegistryBuilder.buildServiceRegistry();
 		}
 		return serviceRegistry;
 	}
 
 	protected void assertHasNoAnnotation(Index index, DotName className, DotName annName) {
 		List<AnnotationInstance> annotationInstanceList = getAnnotationInstances( index, className, annName );
 		if ( annotationInstanceList != null ) {
 			if ( !annotationInstanceList.isEmpty() ) {
 				fail( className + " has Annotation " + annName );
 			}
 		}
 	}
 	protected void assertHasAnnotation(Index index,  DotName annName) {
 		assertHasAnnotation( index, null, annName, 1 );
 	}
 	protected void assertHasAnnotation(Index index, DotName className, DotName annName) {
 		assertHasAnnotation( index, className, annName, 1 );
 	}
 
 	protected void assertHasAnnotation(Index index, DotName className, DotName annName, int size) {
 		List<AnnotationInstance> annotationInstanceList = getAnnotationInstances( index, className, annName );
 		if ( annotationInstanceList == null || annotationInstanceList.isEmpty() ) {
 			fail( "Expected annotation " + annName + " size is " + size + ", but no one can be found in Index" );
 		}
 		assertEquals(
 				"Expected annotation " + annName + " size is " + size + ", but it actually is " + annotationInstanceList
 						.size(), size, annotationInstanceList.size()
 		);
 	}
 
 	protected void assertStringAnnotationValue(String expected, AnnotationValue annotationValue) {
 		if ( annotationValue == null ) {
 			fail( "Annotation Value is null." );
 		}
 		assertEquals( expected, annotationValue.asString() );
 	}
 
 	protected void assertAnnotationValue(Index index, DotName className, DotName annName, AnnotationValueChecker checker) {
 		assertAnnotationValue( index, className, annName, 1, checker );
 	}
 
 	protected void assertAnnotationValue(Index index, DotName className, DotName annName, int size, AnnotationValueChecker checker) {
 		assertHasAnnotation( index, className, annName, size );
 		List<AnnotationInstance> annotationInstanceList = getAnnotationInstances( index,className,annName );
 		for ( AnnotationInstance annotationInstance : annotationInstanceList ) {
 			checker.check( annotationInstance );
 		}
 	}
 
 	private List<AnnotationInstance> getAnnotationInstances(Index index, DotName className, DotName annName) {
 		if ( className != null ) {
 			ClassInfo classInfo = index.getClassByName( className );
 			if ( classInfo == null ) {
 				fail( "Can't find " + className + " from Index" );
 			}
 			if ( classInfo.annotations() == null ) {
 				fail( classInfo + " doesn't have any annotations defined" );
 			}
 			return classInfo.annotations().get( annName );
 		}
 		else {
 			return index.getAnnotations( annName );
 		}
 	}
 
 	static interface AnnotationValueChecker {
 		void check(AnnotationInstance annotationInstance);
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/XmlHelper.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/XmlHelper.java
index e247c28084..e7cc270ade 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/XmlHelper.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/annotations/xml/mocker/XmlHelper.java
@@ -1,79 +1,79 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.annotations.xml.mocker;
 
 import java.io.InputStream;
 import java.net.URL;
 import javax.xml.bind.JAXBContext;
 import javax.xml.bind.JAXBElement;
 import javax.xml.bind.JAXBException;
 import javax.xml.bind.Unmarshaller;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 
 import org.jboss.logging.Logger;
 import org.xml.sax.SAXException;
 
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.jaxb.JaxbRoot;
 import org.hibernate.internal.jaxb.Origin;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 /**
  * @author Hardy Ferentschik
  */
 public class XmlHelper {
     private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, XmlHelper.class.getName() );
 
     private XmlHelper() {
     }
 
     public static <T> JaxbRoot<T> unmarshallXml(String fileName, String schemaName, Class<T> clazz, ClassLoaderService classLoaderService)
             throws JAXBException {
         Schema schema = getMappingSchema( schemaName, classLoaderService );
         InputStream in = classLoaderService.locateResourceStream( fileName );
         JAXBContext jc = JAXBContext.newInstance( clazz );
         Unmarshaller unmarshaller = jc.createUnmarshaller();
         unmarshaller.setSchema( schema );
         StreamSource stream = new StreamSource( in );
         JAXBElement<T> elem = unmarshaller.unmarshal( stream, clazz );
         Origin origin = new Origin( null, fileName );
         return new JaxbRoot<T>( elem.getValue(), origin );
     }
 
     private static Schema getMappingSchema(String schemaVersion, ClassLoaderService classLoaderService) {
         URL schemaUrl = classLoaderService.locateResource( schemaVersion );
         SchemaFactory sf = SchemaFactory.newInstance( javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI );
         Schema schema = null;
         try {
             schema = sf.newSchema( schemaUrl );
         }
         catch ( SAXException e ) {
             LOG.debugf( "Unable to create schema for %s: %s", schemaVersion, e.getMessage() );
         }
         return schema;
     }
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/MetadataImplTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/MetadataImplTest.java
index 5720f43aa7..4fb1caa912 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/MetadataImplTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/MetadataImplTest.java
@@ -1,110 +1,111 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.internal;
 
 import java.util.Iterator;
 
 import org.junit.Test;
 
 import org.hibernate.HibernateException;
 import org.hibernate.SessionFactory;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.metamodel.Metadata;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.SessionFactoryBuilder;
 import org.hibernate.metamodel.binding.FetchProfile;
-import org.hibernate.service.ServiceRegistryBuilder;
+
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static junit.framework.Assert.assertEquals;
 import static junit.framework.Assert.assertFalse;
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertTrue;
 
 /**
  * @author Hardy Ferentschik
  */
 public class MetadataImplTest extends BaseUnitTestCase {
 
 	@Test(expected = IllegalArgumentException.class)
 	public void testAddingNullClass() {
-		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
+		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addClass( null );
 		sources.buildMetadata();
 	}
 
 	@Test(expected = IllegalArgumentException.class)
 	public void testAddingNullPackageName() {
-		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
+		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addPackage( null );
 		sources.buildMetadata();
 	}
 
 	@Test(expected = HibernateException.class)
 	public void testAddingNonExistingPackageName() {
-		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
+		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addPackage( "not.a.package" );
 		sources.buildMetadata();
 	}
 
 	@Test
 	public void testAddingPackageName() {
-		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
+		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addPackage( "org.hibernate.metamodel.source.internal" );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 
 		assertFetchProfile( metadata );
 	}
 
 	@Test
 	public void testAddingPackageNameWithTrailingDot() {
-		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
+		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addPackage( "org.hibernate.metamodel.source.internal." );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 
 		assertFetchProfile( metadata );
 	}
 
 	@Test
 	public void testGettingSessionFactoryBuilder() {
-		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
+		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().buildServiceRegistry() );
 		Metadata metadata = sources.buildMetadata();
 
 		SessionFactoryBuilder sessionFactoryBuilder = metadata.getSessionFactoryBuilder();
 		assertNotNull( sessionFactoryBuilder );
 		assertTrue( SessionFactoryBuilderImpl.class.isInstance( sessionFactoryBuilder ) );
 
 		SessionFactory sessionFactory = metadata.buildSessionFactory();
 		assertNotNull( sessionFactory );
 	}
 
 	private void assertFetchProfile(MetadataImpl metadata) {
 		Iterator<FetchProfile> profiles = metadata.getFetchProfiles().iterator();
 		assertTrue( profiles.hasNext() );
 		FetchProfile profile = profiles.next();
 		assertEquals( "wrong profile name", "package-configured-profile", profile.getName() );
 		assertFalse( profiles.hasNext() );
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImplTest.java b/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImplTest.java
index b32dfa9514..5f91b112c2 100644
--- a/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImplTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/metamodel/source/internal/SessionFactoryBuilderImplTest.java
@@ -1,197 +1,198 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.metamodel.source.internal;
 
 import java.io.Serializable;
 import java.util.Iterator;
 
 import org.junit.Test;
 
 import org.hibernate.CallbackException;
 import org.hibernate.EmptyInterceptor;
 import org.hibernate.EntityMode;
 import org.hibernate.Interceptor;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.SessionFactory;
 import org.hibernate.Transaction;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.SessionFactoryBuilder;
 import org.hibernate.proxy.EntityNotFoundDelegate;
-import org.hibernate.service.ServiceRegistryBuilder;
+
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 import org.hibernate.type.Type;
 
 import static junit.framework.Assert.assertNotNull;
 import static junit.framework.Assert.assertSame;
 import static junit.framework.Assert.assertTrue;
 
 /**
  * @author Gail Badner
  */
 public class SessionFactoryBuilderImplTest extends BaseUnitTestCase {
 
 	@Test
 	public void testGettingSessionFactoryBuilder() {
 		SessionFactoryBuilder sessionFactoryBuilder = getSessionFactoryBuilder();
 		assertNotNull( sessionFactoryBuilder );
 		assertTrue( SessionFactoryBuilderImpl.class.isInstance( sessionFactoryBuilder ) );
 	}
 
 	@Test
 	public void testBuildSessionFactoryWithDefaultOptions() {
 		SessionFactoryBuilder sessionFactoryBuilder = getSessionFactoryBuilder();
 		SessionFactory sessionFactory = sessionFactoryBuilder.buildSessionFactory();
 		assertSame( EmptyInterceptor.INSTANCE, sessionFactory.getSessionFactoryOptions().getInterceptor() );
 		assertTrue( EntityNotFoundDelegate.class.isInstance(
 				sessionFactory.getSessionFactoryOptions().getEntityNotFoundDelegate()
 		) );
 		sessionFactory.close();
 	}
 
 	@Test
 	public void testBuildSessionFactoryWithUpdatedOptions() {
 		SessionFactoryBuilder sessionFactoryBuilder = getSessionFactoryBuilder();
 		Interceptor interceptor = new AnInterceptor();
 		EntityNotFoundDelegate entityNotFoundDelegate = new EntityNotFoundDelegate() {
 			@Override
 			public void handleEntityNotFound(String entityName, Serializable id) {
 				throw new ObjectNotFoundException( id, entityName );
 			}
 		};
 		sessionFactoryBuilder.with( interceptor );
 		sessionFactoryBuilder.with( entityNotFoundDelegate );
 		SessionFactory sessionFactory = sessionFactoryBuilder.buildSessionFactory();
 		assertSame( interceptor, sessionFactory.getSessionFactoryOptions().getInterceptor() );
 		assertSame( entityNotFoundDelegate, sessionFactory.getSessionFactoryOptions().getEntityNotFoundDelegate() );
 		sessionFactory.close();
 	}
 
 	private SessionFactoryBuilder getSessionFactoryBuilder() {
-		MetadataSources sources = new MetadataSources( new ServiceRegistryBuilder().buildServiceRegistry() );
+		MetadataSources sources = new MetadataSources( new StandardServiceRegistryBuilder().buildServiceRegistry() );
 		sources.addAnnotatedClass( SimpleEntity.class );
 		MetadataImpl metadata = (MetadataImpl) sources.buildMetadata();
 		return  metadata.getSessionFactoryBuilder();
 	}
 
 	private static class AnInterceptor implements Interceptor {
 		private static final Interceptor INSTANCE = EmptyInterceptor.INSTANCE;
 
 		@Override
 		public boolean onLoad(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)
 				throws CallbackException {
 			return INSTANCE.onLoad( entity, id, state, propertyNames, types );
 		}
 
 		@Override
 		public boolean onFlushDirty(Object entity, Serializable id, Object[] currentState, Object[] previousState, String[] propertyNames, Type[] types)
 				throws CallbackException {
 			return INSTANCE.onFlushDirty( entity, id, currentState, previousState, propertyNames, types );
 		}
 
 		@Override
 		public boolean onSave(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)
 				throws CallbackException {
 			return INSTANCE.onSave( entity, id, state, propertyNames, types );
 		}
 
 		@Override
 		public void onDelete(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)
 				throws CallbackException {
 			INSTANCE.onDelete( entity, id, state, propertyNames, types );
 		}
 
 		@Override
 		public void onCollectionRecreate(Object collection, Serializable key) throws CallbackException {
 			INSTANCE.onCollectionRecreate( collection, key );
 		}
 
 		@Override
 		public void onCollectionRemove(Object collection, Serializable key) throws CallbackException {
 			INSTANCE.onCollectionRemove( collection, key );
 		}
 
 		@Override
 		public void onCollectionUpdate(Object collection, Serializable key) throws CallbackException {
 			INSTANCE.onCollectionUpdate( collection, key );
 		}
 
 		@Override
 		public void preFlush(Iterator entities) throws CallbackException {
 			INSTANCE.preFlush( entities );
 		}
 
 		@Override
 		public void postFlush(Iterator entities) throws CallbackException {
 			INSTANCE.postFlush( entities );
 		}
 
 		@Override
 		public Boolean isTransient(Object entity) {
 			return INSTANCE.isTransient( entity );
 		}
 
 		@Override
 		public int[] findDirty(Object entity, Serializable id, Object[] currentState, Object[] previousState, String[] propertyNames, Type[] types) {
 			return INSTANCE.findDirty( entity, id, currentState, previousState, propertyNames, types );
 		}
 
 		@Override
 		public Object instantiate(String entityName, EntityMode entityMode, Serializable id)
 				throws CallbackException {
 			return INSTANCE.instantiate( entityName, entityMode, id );
 		}
 
 		@Override
 		public String getEntityName(Object object) throws CallbackException {
 			return INSTANCE.getEntityName( object );
 		}
 
 		@Override
 		public Object getEntity(String entityName, Serializable id) throws CallbackException {
 			return INSTANCE.getEntity( entityName, id );
 		}
 
 		@Override
 		public void afterTransactionBegin(Transaction tx) {
 			INSTANCE.afterTransactionBegin( tx );
 		}
 
 		@Override
 		public void beforeTransactionCompletion(Transaction tx) {
 			INSTANCE.beforeTransactionCompletion( tx );
 		}
 
 		@Override
 		public void afterTransactionCompletion(Transaction tx) {
 			INSTANCE.afterTransactionCompletion( tx );
 		}
 
 		@Override
 		public String onPrepareStatement(String sql) {
 			return INSTANCE.onPrepareStatement( sql );
 		}
 	}
 }
 
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/annotations/embeddables/EmbeddableIntegratorTest.java b/hibernate-core/src/test/java/org/hibernate/test/annotations/embeddables/EmbeddableIntegratorTest.java
index 5a0688b67c..568559ea4e 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/annotations/embeddables/EmbeddableIntegratorTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/annotations/embeddables/EmbeddableIntegratorTest.java
@@ -1,117 +1,117 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.annotations.embeddables;
 
 import java.math.BigDecimal;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.List;
 
 import org.hibernate.Session;
 import org.hibernate.SessionFactory;
+import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.exception.GenericJDBCException;
-import org.hibernate.service.BootstrapServiceRegistryBuilder;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.internal.BootstrapServiceRegistryImpl;
+import org.hibernate.boot.registry.internal.BootstrapServiceRegistryImpl;
 
 import org.junit.Test;
 
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 /**
  * @author Chris Pheby
  */
 public class EmbeddableIntegratorTest extends BaseUnitTestCase {
 
 	/**
 	 * Throws a mapping exception because DollarValue is not mapped
 	 */
 	@Test(expected=GenericJDBCException.class)
 	public void testWithoutIntegrator() {
 		
-		ServiceRegistry reg = new ServiceRegistryBuilder(new BootstrapServiceRegistryImpl())
+		ServiceRegistry reg = new StandardServiceRegistryBuilder(new BootstrapServiceRegistryImpl())
 		.buildServiceRegistry();
 		
 		SessionFactory sf = new Configuration()
 		.addAnnotatedClass( Investor.class )
 
 		.buildSessionFactory(reg);
 		
 		Session sess = sf.openSession();
 		Investor myInv = getInvestor();
 		myInv.setId(1L);
 		
 		sess.save(myInv);
 		sess.flush();
 		sess.clear();
 		
 		Investor inv = (Investor) sess.get(Investor.class, 1L);
 		assertEquals(new BigDecimal("100"), inv.getInvestments().get(0).getAmount().getAmount());
 		
 		sess.close();
 	}
 
 	@Test
 	public void testWithIntegrator() {
-		ServiceRegistry reg = new ServiceRegistryBuilder(
+		ServiceRegistry reg = new StandardServiceRegistryBuilder(
 				new BootstrapServiceRegistryBuilder().with( new InvestorIntegrator() ).build()
 		).buildServiceRegistry();
 		
 		SessionFactory sf = new Configuration()
 		.addAnnotatedClass( Investor.class )
 
 		.setProperty("hibernate.hbm2ddl.auto", "create-drop")
 		.buildSessionFactory(reg);
 		
 		Session sess = sf.openSession();
 		Investor myInv = getInvestor();
 		myInv.setId(2L);
 		
 		sess.save(myInv);
 		sess.flush();
 		sess.clear();
 		
 		Investor inv = (Investor) sess.get(Investor.class, 2L);
 		assertEquals(new BigDecimal("100"), inv.getInvestments().get(0).getAmount().getAmount());
 		
 		sess.close();
 	}
 	
 	private Investor getInvestor() {
 		Investor i = new Investor();
 		List<Investment> investments = new ArrayList<Investment>();
 		Investment i1 = new Investment();
 		i1.setAmount(new DollarValue(new BigDecimal("100")));
 		i1.setDate(new MyDate(new Date()));
 		i1.setDescription("Test Investment");
 		investments.add(i1);
 		i.setInvestments(investments);
 		
 		return i;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/cfg/persister/PersisterClassProviderTest.java b/hibernate-core/src/test/java/org/hibernate/test/cfg/persister/PersisterClassProviderTest.java
index 177df15ed2..706391588b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/cfg/persister/PersisterClassProviderTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/cfg/persister/PersisterClassProviderTest.java
@@ -1,120 +1,121 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * JBoss, Home of Professional Open Source
  * Copyright 2011 Red Hat Inc. and/or its affiliates and other contributors
  * as indicated by the @authors tag. All rights reserved.
  * See the copyright.txt in the distribution for a
  * full listing of individual contributors.
  *
  * This copyrighted material is made available to anyone wishing to use,
  * modify, copy, or redistribute it subject to the terms and conditions
  * of the GNU Lesser General Public License, v. 2.1.
  * This program is distributed in the hope that it will be useful, but WITHOUT A
  * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
  * PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
  * You should have received a copy of the GNU Lesser General Public License,
  * v.2.1 along with this distribution; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
 package org.hibernate.test.cfg.persister;
 
 import org.junit.Test;
 
 import org.hibernate.MappingException;
 import org.hibernate.SessionFactory;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.persister.spi.PersisterClassResolver;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.ServiceRegistryBuilder;
+
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 /**
  * @author Emmanuel Bernard <emmanuel@hibernate.org>
  */
 public class PersisterClassProviderTest extends BaseUnitTestCase {
 	@Test
 	public void testPersisterClassProvider() throws Exception {
 
 		Configuration cfg = new Configuration();
 		cfg.addAnnotatedClass( Gate.class );
-		ServiceRegistry serviceRegistry = new ServiceRegistryBuilder()
+		ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()
 				.applySettings( cfg.getProperties() )
 				.buildServiceRegistry();
 		//no exception as the GoofyPersisterClassProvider is not set
 		SessionFactory sessionFactory = cfg.buildSessionFactory( serviceRegistry );
 		sessionFactory.close();
-		ServiceRegistryBuilder.destroy( serviceRegistry );
+		StandardServiceRegistryBuilder.destroy( serviceRegistry );
 
-		serviceRegistry = new ServiceRegistryBuilder()
+		serviceRegistry = new StandardServiceRegistryBuilder()
 				.applySettings( cfg.getProperties() )
 				.addService( PersisterClassResolver.class, new GoofyPersisterClassProvider() )
 				.buildServiceRegistry();
 		cfg = new Configuration();
 		cfg.addAnnotatedClass( Gate.class );
 		try {
 			sessionFactory = cfg.buildSessionFactory( serviceRegistry );
 			sessionFactory.close();
             fail("The entity persister should be overridden");
 		}
 		catch ( MappingException e ) {
 			assertEquals(
 					"The entity persister should be overridden",
 					GoofyPersisterClassProvider.NoopEntityPersister.class,
 					( (GoofyException) e.getCause() ).getValue()
 			);
 		}
 		finally {
-			ServiceRegistryBuilder.destroy( serviceRegistry );
+			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 
 		cfg = new Configuration();
 		cfg.addAnnotatedClass( Portal.class );
 		cfg.addAnnotatedClass( Window.class );
-		serviceRegistry = new ServiceRegistryBuilder()
+		serviceRegistry = new StandardServiceRegistryBuilder()
 				.applySettings( cfg.getProperties() )
 				.addService( PersisterClassResolver.class, new GoofyPersisterClassProvider() )
 				.buildServiceRegistry();
 		try {
 			sessionFactory = cfg.buildSessionFactory( serviceRegistry );
 			sessionFactory.close();
             fail("The collection persister should be overridden but not the entity persister");
 		}
 		catch ( MappingException e ) {
 			assertEquals(
 					"The collection persister should be overridden but not the entity persister",
 					GoofyPersisterClassProvider.NoopCollectionPersister.class,
 					( (GoofyException) e.getCause() ).getValue() );
 		}
 		finally {
-			ServiceRegistryBuilder.destroy( serviceRegistry );
+			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 
 
         cfg = new Configuration();
 		cfg.addAnnotatedClass( Tree.class );
 		cfg.addAnnotatedClass( Palmtree.class );
-		serviceRegistry = new ServiceRegistryBuilder()
+		serviceRegistry = new StandardServiceRegistryBuilder()
 				.applySettings( cfg.getProperties() )
 				.addService( PersisterClassResolver.class, new GoofyPersisterClassProvider() )
 				.buildServiceRegistry();
 		try {
 			sessionFactory = cfg.buildSessionFactory( serviceRegistry );
 			sessionFactory.close();
             fail("The entity persisters should be overridden in a class hierarchy");
 		}
 		catch ( MappingException e ) {
 			assertEquals(
 					"The entity persisters should be overridden in a class hierarchy",
 					GoofyPersisterClassProvider.NoopEntityPersister.class,
 					( (GoofyException) e.getCause() ).getValue() );
 		}
 		finally {
-			ServiceRegistryBuilder.destroy( serviceRegistry );
+			StandardServiceRegistryBuilder.destroy( serviceRegistry );
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/common/BasicTestingJdbcServiceImpl.java b/hibernate-core/src/test/java/org/hibernate/test/common/BasicTestingJdbcServiceImpl.java
index a84e7dcf29..c8e73cba51 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/common/BasicTestingJdbcServiceImpl.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/common/BasicTestingJdbcServiceImpl.java
@@ -1,163 +1,163 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.common;
 
 import java.util.Collections;
 import java.util.LinkedHashSet;
 import java.util.Set;
 
 import org.hibernate.dialect.Dialect;
 import org.hibernate.engine.jdbc.LobCreationContext;
 import org.hibernate.engine.jdbc.LobCreator;
 import org.hibernate.engine.jdbc.internal.ResultSetWrapperImpl;
 import org.hibernate.engine.jdbc.internal.TypeInfo;
 import org.hibernate.engine.jdbc.spi.ExtractedDatabaseMetaData;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.jdbc.spi.ResultSetWrapper;
 import org.hibernate.engine.jdbc.spi.SqlExceptionHelper;
 import org.hibernate.engine.jdbc.spi.SqlStatementLogger;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.spi.Stoppable;
 import org.hibernate.testing.env.ConnectionProviderBuilder;
 
 
 /**
  * Implementation of the {@link JdbcServices} contract for use by these
  * tests.
  *
  * @author Steve Ebersole
  */
 public class BasicTestingJdbcServiceImpl implements JdbcServices {
 	private ConnectionProvider connectionProvider;
 	private Dialect dialect;
 	private SqlStatementLogger sqlStatementLogger;
 	private SqlExceptionHelper exceptionHelper;
 	private final ExtractedDatabaseMetaData metaDataSupport = new MetaDataSupportImpl();
 	private final ResultSetWrapper resultSetWrapper = ResultSetWrapperImpl.INSTANCE;
 
 	public void start() {
 	}
 
 	public void stop() {
 		release();
 	}
 
 	public void prepare(boolean allowAggressiveRelease) {
 		connectionProvider = ConnectionProviderBuilder.buildConnectionProvider( allowAggressiveRelease );
 		dialect = ConnectionProviderBuilder.getCorrespondingDialect();
 		sqlStatementLogger = new SqlStatementLogger( true, false );
 		exceptionHelper = new SqlExceptionHelper();
 
 	}
 
 	public void release() {
 		if ( connectionProvider instanceof Stoppable ) {
 			( (Stoppable) connectionProvider ).stop();
 		}
 	}
 
 	public ConnectionProvider getConnectionProvider() {
 		return connectionProvider;
 	}
 
 	public Dialect getDialect() {
 		return dialect;
 	}
 
 	public LobCreator getLobCreator(LobCreationContext lobCreationContext) {
 		return null;
 	}
 
 	public ResultSetWrapper getResultSetWrapper() {
 		return null;
 	}
 
 	public SqlStatementLogger getSqlStatementLogger() {
 		return sqlStatementLogger;
 	}
 
 	public SqlExceptionHelper getSqlExceptionHelper() {
 		return exceptionHelper;
 	}
 
 	public ExtractedDatabaseMetaData getExtractedMetaDataSupport() {
 		return metaDataSupport;
 	}
 
 	private static class MetaDataSupportImpl implements ExtractedDatabaseMetaData {
 		@Override
 		public boolean supportsRefCursors() {
 			return false;
 		}
 
 		@Override
 		public boolean supportsNamedParameters() {
 			return false;
 		}
 
 		public boolean supportsScrollableResults() {
 			return false;
 		}
 
 		public boolean supportsGetGeneratedKeys() {
 			return false;
 		}
 
 		public boolean supportsBatchUpdates() {
 			return false;
 		}
 
 		public boolean supportsDataDefinitionInTransaction() {
 			return false;
 		}
 
 		public boolean doesDataDefinitionCauseTransactionCommit() {
 			return false;
 		}
 
 		public Set<String> getExtraKeywords() {
 			return Collections.emptySet();
 		}
 
 		public SQLStateType getSqlStateType() {
 			return SQLStateType.UNKOWN;
 		}
 
 		public boolean doesLobLocatorUpdateCopy() {
 			return false;
 		}
 
 		public String getConnectionSchemaName() {
 			return null;
 		}
 
 		public String getConnectionCatalogName() {
 			return null;
 		}
 
 		public LinkedHashSet<TypeInfo> getTypeInfoSet() {
 			return null;
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/common/JdbcConnectionAccessImpl.java b/hibernate-core/src/test/java/org/hibernate/test/common/JdbcConnectionAccessImpl.java
index 8ba9d7555a..2ba0228189 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/common/JdbcConnectionAccessImpl.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/common/JdbcConnectionAccessImpl.java
@@ -1,66 +1,66 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.common;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 
 import org.hibernate.engine.jdbc.spi.JdbcConnectionAccess;
 import org.hibernate.engine.transaction.spi.TransactionEnvironment;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 
 /**
  * @author Steve Ebersole
  */
 public class JdbcConnectionAccessImpl implements JdbcConnectionAccess {
 	private final ConnectionProvider connectionProvider;
 
 	public JdbcConnectionAccessImpl(TransactionEnvironment transactionEnvironment) {
 		this( transactionEnvironment.getSessionFactory().getServiceRegistry() );
 	}
 
 	public JdbcConnectionAccessImpl(ConnectionProvider connectionProvider) {
 		this.connectionProvider = connectionProvider;
 	}
 
 	public JdbcConnectionAccessImpl(ServiceRegistry serviceRegistry) {
 		this( serviceRegistry.getService( ConnectionProvider.class ) );
 	}
 
 	@Override
 	public Connection obtainConnection() throws SQLException {
 		return connectionProvider.getConnection();
 	}
 
 	@Override
 	public void releaseConnection(Connection connection) throws SQLException {
 		connectionProvider.closeConnection( connection );
 	}
 
 	@Override
 	public boolean supportsAggressiveRelease() {
 		return connectionProvider.supportsAggressiveRelease();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/common/TransactionEnvironmentImpl.java b/hibernate-core/src/test/java/org/hibernate/test/common/TransactionEnvironmentImpl.java
index 41e8f596a4..be0ed8f3a5 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/common/TransactionEnvironmentImpl.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/common/TransactionEnvironmentImpl.java
@@ -1,80 +1,80 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.common;
 
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.transaction.spi.TransactionEnvironment;
 import org.hibernate.engine.transaction.spi.TransactionFactory;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.stat.internal.ConcurrentStatisticsImpl;
 import org.hibernate.stat.spi.StatisticsImplementor;
 
 /**
  * @author Steve Ebersole
  */
 public class TransactionEnvironmentImpl implements TransactionEnvironment {
 	private final ServiceRegistry serviceRegistry;
 	private final ConcurrentStatisticsImpl statistics = new ConcurrentStatisticsImpl();
 	private final SessionFactoryImplementor sessionFactory;
 
 	public static final String NAME = "TransactionEnvironmentImpl_testSF";
 
 	public TransactionEnvironmentImpl(ServiceRegistry serviceRegistry) {
 		this.serviceRegistry = serviceRegistry;
 
 		Configuration cfg = new Configuration()
 				.setProperty( AvailableSettings.SESSION_FACTORY_NAME, NAME )
 				.setProperty( AvailableSettings.SESSION_FACTORY_NAME_IS_JNDI, "false" ); // default is true
 		sessionFactory = (SessionFactoryImplementor) cfg.buildSessionFactory(serviceRegistry);
 	}
 
 	@Override
 	public SessionFactoryImplementor getSessionFactory() {
 		return sessionFactory;
 	}
 
 	@Override
 	public JdbcServices getJdbcServices() {
 		return serviceRegistry.getService( JdbcServices.class );
 	}
 
 	@Override
 	public JtaPlatform getJtaPlatform() {
 		return serviceRegistry.getService( JtaPlatform.class );
 	}
 
 	@Override
 	public TransactionFactory getTransactionFactory() {
 		return serviceRegistry.getService( TransactionFactory.class );
 	}
 
 	@Override
 	public StatisticsImplementor getStatisticsImplementor() {
 		return statistics;
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/connections/AggressiveReleaseTest.java b/hibernate-core/src/test/java/org/hibernate/test/connections/AggressiveReleaseTest.java
index 6de8f89e25..2db4ec9c42 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/connections/AggressiveReleaseTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/connections/AggressiveReleaseTest.java
@@ -1,245 +1,245 @@
 // $Id: AggressiveReleaseTest.java 10977 2006-12-12 23:28:04Z steve.ebersole@jboss.com $
 package org.hibernate.test.connections;
 
 import java.sql.Connection;
 import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
 import org.junit.Test;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.Hibernate;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
 import org.hibernate.internal.util.SerializationHelper;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.testing.jta.TestingJtaBootstrap;
 import org.hibernate.testing.jta.TestingJtaPlatformImpl;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * Implementation of AggressiveReleaseTest.
  *
  * @author Steve Ebersole
  */
 public class AggressiveReleaseTest extends ConnectionManagementTestCase {
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		TestingJtaBootstrap.prepare( cfg.getProperties() );
 		cfg.setProperty( Environment.TRANSACTION_STRATEGY, CMTTransactionFactory.class.getName() );
 		cfg.setProperty( Environment.RELEASE_CONNECTIONS, ConnectionReleaseMode.AFTER_STATEMENT.toString() );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 		cfg.setProperty( Environment.STATEMENT_BATCH_SIZE, "0" );
 	}
 
 	@Override
 	protected Session getSessionUnderTest() throws Throwable {
 		return openSession();
 	}
 
 	@Override
 	protected void reconnect(Session session) {
 	}
 
 	@Override
 	protected void prepare() throws Throwable {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().begin();
 	}
 
 	@Override
 	protected void done() throws Throwable {
 		TestingJtaPlatformImpl.INSTANCE.getTransactionManager().commit();
 	}
 
 	// Some additional tests specifically for the aggressive-release functionality...
 
 	@Test
 	public void testSerializationOnAfterStatementAggressiveRelease() throws Throwable {
 		prepare();
 		try {
 			Session s = getSessionUnderTest();
 			Silly silly = new Silly( "silly" );
 			s.save( silly );
 
 			// this should cause the CM to obtain a connection, and then release it
 			s.flush();
 
 			// We should be able to serialize the session at this point...
 			SerializationHelper.serialize( s );
 
 			s.delete( silly );
 			s.flush();
 
 			release( s );
 		}
 		finally {
 			done();
 		}
 	}
 
 	@Test
 	public void testSerializationFailsOnAfterStatementAggressiveReleaseWithOpenResources() throws Throwable {
 		prepare();
 		Session s = getSessionUnderTest();
 
 		Silly silly = new Silly( "silly" );
 		s.save( silly );
 
 		// this should cause the CM to obtain a connection, and then release it
 		s.flush();
 
 		// both scroll() and iterate() cause batching to hold on
 		// to resources, which should make aggressive-release not release
 		// the connection (and thus cause serialization to fail)
 		ScrollableResults sr = s.createQuery( "from Silly" ).scroll();
 
 		try {
 			SerializationHelper.serialize( s );
 			fail( "Serialization allowed on connected session; or aggressive release released connection with open resources" );
 		}
 		catch( IllegalStateException e ) {
 			// expected behavior
 		}
 
 		// getting the first row only because SybaseASE15Dialect throws NullPointerException
 		// if data is not read before closing the ResultSet
 		sr.next();
 
 		// Closing the ScrollableResults does currently force batching to
 		// aggressively release the connection
 		sr.close();
 		SerializationHelper.serialize( s );
 
 		s.delete( silly );
 		s.flush();
 
 		release( s );
 		done();
 	}
 
 	@Test
 	public void testQueryIteration() throws Throwable {
 		prepare();
 		Session s = getSessionUnderTest();
 		Silly silly = new Silly( "silly" );
 		s.save( silly );
 		s.flush();
 
 		Iterator itr = s.createQuery( "from Silly" ).iterate();
 		assertTrue( itr.hasNext() );
 		Silly silly2 = ( Silly ) itr.next();
 		assertEquals( silly, silly2 );
 		Hibernate.close( itr );
 
 		itr = s.createQuery( "from Silly" ).iterate();
 		Iterator itr2 = s.createQuery( "from Silly where name = 'silly'" ).iterate();
 
 		assertTrue( itr.hasNext() );
 		assertEquals( silly, itr.next() );
 		assertTrue( itr2.hasNext() );
 		assertEquals( silly, itr2.next() );
 
 		Hibernate.close( itr );
 		Hibernate.close( itr2 );
 
 		s.delete( silly );
 		s.flush();
 
 		release( s );
 		done();
 	}
 
 	@Test
 	public void testQueryScrolling() throws Throwable {
 		prepare();
 		Session s = getSessionUnderTest();
 		Silly silly = new Silly( "silly" );
 		s.save( silly );
 		s.flush();
 
 		ScrollableResults sr = s.createQuery( "from Silly" ).scroll();
 		assertTrue( sr.next() );
 		Silly silly2 = ( Silly ) sr.get( 0 );
 		assertEquals( silly, silly2 );
 		sr.close();
 
 		sr = s.createQuery( "from Silly" ).scroll();
 		ScrollableResults sr2 = s.createQuery( "from Silly where name = 'silly'" ).scroll();
 
 		assertTrue( sr.next() );
 		assertEquals( silly, sr.get( 0 ) );
 		assertTrue( sr2.next() );
 		assertEquals( silly, sr2.get( 0 ) );
 
 		sr.close();
 		sr2.close();
 
 		s.delete( silly );
 		s.flush();
 
 		release( s );
 		done();
 	}
 
 	@Test
 	public void testSuppliedConnection() throws Throwable {
 		prepare();
 
 		Connection originalConnection = sessionFactory().getServiceRegistry().getService( ConnectionProvider.class ).getConnection();
 		Session session = sessionFactory().withOptions().connection( originalConnection ).openSession();
 
 		Silly silly = new Silly( "silly" );
 		session.save( silly );
 
 		// this will cause the connection manager to cycle through the aggressive release logic;
 		// it should not release the connection since we explicitly suplied it ourselves.
 		session.flush();
 		assertTrue( session.isConnected() );
 
 		session.delete( silly );
 		session.flush();
 
 		release( session );
 		done();
 
 		sessionFactory().getServiceRegistry().getService( ConnectionProvider.class ).closeConnection( originalConnection );
 	}
 
 	@Test
 	public void testConnectionMaintanenceDuringFlush() throws Throwable {
 		prepare();
 		Session s = getSessionUnderTest();
 		s.beginTransaction();
 
 		List<Silly> entities = new ArrayList<Silly>();
 		for ( int i = 0; i < 10; i++ ) {
 			Other other = new Other( "other-" + i );
 			Silly silly = new Silly( "silly-" + i, other );
 			entities.add( silly );
 			s.save( silly );
 		}
 		s.flush();
 
 		for ( Silly silly : entities ) {
 			silly.setName( "new-" + silly.getName() );
 			silly.getOther().setName( "new-" + silly.getOther().getName() );
 		}
 		long initialCount = sessionFactory().getStatistics().getConnectCount();
 		s.flush();
 		assertEquals( "connection not maintained through flush", initialCount + 1, sessionFactory().getStatistics().getConnectCount() );
 
 		s.createQuery( "delete from Silly" ).executeUpdate();
 		s.createQuery( "delete from Other" ).executeUpdate();
 		s.getTransaction().commit();
 		release( s );
 		done();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/connections/SuppliedConnectionTest.java b/hibernate-core/src/test/java/org/hibernate/test/connections/SuppliedConnectionTest.java
index 103665315a..32525c5289 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/connections/SuppliedConnectionTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/connections/SuppliedConnectionTest.java
@@ -1,155 +1,155 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 
 package org.hibernate.test.connections;
 
 import java.sql.Connection;
 import java.sql.ResultSet;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
-import org.hibernate.service.jdbc.connections.internal.UserSuppliedConnectionProviderImpl;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.internal.UserSuppliedConnectionProviderImpl;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.spi.Stoppable;
 import org.hibernate.testing.AfterClassOnce;
 import org.hibernate.testing.BeforeClassOnce;
 import org.hibernate.testing.env.ConnectionProviderBuilder;
 import org.hibernate.tool.hbm2ddl.SchemaExport;
 
 /**
  * Implementation of SuppliedConnectionTest.
  *
  * @author Steve Ebersole
  */
 public class SuppliedConnectionTest extends ConnectionManagementTestCase {
 	private ConnectionProvider cp = ConnectionProviderBuilder.buildConnectionProvider();
 	private Connection connectionUnderTest;
 
 	@BeforeClassOnce
 	private void prepareConnectionProvider() {
 		cp = ConnectionProviderBuilder.buildConnectionProvider();
 	}
 
 	@AfterClassOnce
 	private void releaseConnectionProvider() {
 		try {
 			if ( cp instanceof Stoppable ) {
 					( ( Stoppable ) cp ).stop();
 			}
 			cp = null;
 		}
 		catch( Throwable ignore ) {
 		}
 	}
 
 	@Override
 	protected Session getSessionUnderTest() throws Throwable {
 		connectionUnderTest = cp.getConnection();
 		return sessionFactory().withOptions().connection( connectionUnderTest ).openSession();
 	}
 
 	@Override
 	protected void reconnect(Session session) {
 		session.reconnect( connectionUnderTest );
 	}
 
 	@Override
 	protected void done() throws Throwable {
 		cp.closeConnection( connectionUnderTest );
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.RELEASE_CONNECTIONS, ConnectionReleaseMode.ON_CLOSE.toString() );
 		cfg.setProperty( Environment.CONNECTION_PROVIDER, UserSuppliedConnectionProviderImpl.class.getName() );
 		boolean supportsScroll = true;
 		Connection conn = null;
 		try {
 			conn = cp.getConnection();
 			supportsScroll = conn.getMetaData().supportsResultSetType(ResultSet.TYPE_SCROLL_INSENSITIVE);
 		}
 		catch( Throwable ignore ) {
 		}
 		finally {
 			if ( conn != null ) {
 				try {
 					conn.close();
 				}
 				catch( Throwable ignore ) {
 					// ignore it...
 				}
 			}
 		}
 		cfg.setProperty( Environment.USE_SCROLLABLE_RESULTSET, "" + supportsScroll );
 	}
 
 	@Override
 	public boolean createSchema() {
 		return false;
 	}
 
 	@Override
 	public boolean rebuildSessionFactoryOnError() {
 		return false;
 	}
 
 	@Override
 	protected void prepareTest() throws Exception {
 		super.prepareTest();
 		Connection conn = cp.getConnection();
 		try {
 			new SchemaExport( configuration(), conn ).create( false, true );
 		}
 		finally {
 			if ( conn != null ) {
 				try {
 					cp.closeConnection( conn );
 				}
 				catch( Throwable ignore ) {
 				}
 			}
 		}
 	}
 
 	@Override
 	protected void cleanupTest() throws Exception {
 		Connection conn = cp.getConnection();
 		try {
 			new SchemaExport( configuration(), conn ).drop( false, true );
 		}
 		finally {
 			if ( conn != null ) {
 				try {
 					cp.closeConnection( conn );
 				}
 				catch( Throwable ignore ) {
 				}
 			}
 		}
 		super.cleanupTest();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/events/CallbackTest.java b/hibernate-core/src/test/java/org/hibernate/test/events/CallbackTest.java
index 8b1aafb885..acf281804b 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/events/CallbackTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/events/CallbackTest.java
@@ -1,144 +1,144 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.events;
 
 import java.util.Set;
 
 import org.junit.Test;
 
 import org.hibernate.HibernateException;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
+import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.DeleteEvent;
 import org.hibernate.event.spi.DeleteEventListener;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.service.BootstrapServiceRegistryBuilder;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 
 
 /**
  * CallbackTest implementation
  *
  * @author Steve Ebersole
  */
 public class CallbackTest extends BaseCoreFunctionalTestCase {
 	private TestingObserver observer = new TestingObserver();
 	private TestingListener listener = new TestingListener();
 
 	@Override
     public String[] getMappings() {
 		return NO_MAPPINGS;
 	}
 
 	@Override
     public void configure(Configuration cfg) {
 		cfg.setSessionFactoryObserver( observer );
 	}
 
 	@Override
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 		super.prepareBootstrapRegistryBuilder( builder );
 		builder.with(
 				new Integrator() {
 
 				    @Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
                         integrate(serviceRegistry);
 					}
 
                     @Override
 				    public void integrate( MetadataImplementor metadata,
 				                           SessionFactoryImplementor sessionFactory,
 				                           SessionFactoryServiceRegistry serviceRegistry ) {
                         integrate(serviceRegistry);
 				    }
 
                     private void integrate( SessionFactoryServiceRegistry serviceRegistry ) {
                         serviceRegistry.getService( EventListenerRegistry.class ).setListeners(EventType.DELETE, listener);
                         listener.initialize();
                     }
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 						listener.cleanup();
 					}
 				}
 		);
 	}
 
 	@Test
 	public void testCallbacks() {
 		assertEquals( "observer not notified of creation", 1, observer.creationCount );
 		assertEquals( "listener not notified of creation", 1, listener.initCount );
 
 		sessionFactory().close();
 
 		assertEquals( "observer not notified of close", 1, observer.closedCount );
 		assertEquals( "listener not notified of close", 1, listener.destoryCount );
 	}
 
 	private static class TestingObserver implements SessionFactoryObserver {
 		private int creationCount = 0;
 		private int closedCount = 0;
 
 		public void sessionFactoryCreated(SessionFactory factory) {
 			creationCount++;
 		}
 
 		public void sessionFactoryClosed(SessionFactory factory) {
 			closedCount++;
 		}
 	}
 
 	private static class TestingListener implements DeleteEventListener {
 		private int initCount = 0;
 		private int destoryCount = 0;
 
 		public void initialize() {
 			initCount++;
 		}
 
 		public void cleanup() {
 			destoryCount++;
 		}
 
 		public void onDelete(DeleteEvent event) throws HibernateException {
 		}
 
 		public void onDelete(DeleteEvent event, Set transientEntities) throws HibernateException {
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/extendshbm/ExtendsTest.java b/hibernate-core/src/test/java/org/hibernate/test/extendshbm/ExtendsTest.java
index bb7a228b18..d4ce19796c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/extendshbm/ExtendsTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/extendshbm/ExtendsTest.java
@@ -1,210 +1,210 @@
 //$Id: ExtendsTest.java 10977 2006-12-12 23:28:04Z steve.ebersole@jboss.com $
 package org.hibernate.test.extendshbm;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.Configuration;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.testing.ServiceRegistryBuilder;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.fail;
 
 /**
  * @author Gavin King
  */
 public class ExtendsTest extends BaseUnitTestCase {
 	private StandardServiceRegistryImpl serviceRegistry;
 
 	@Before
 	public void setUp() {
 		serviceRegistry = ServiceRegistryBuilder.buildServiceRegistry();
 	}
 
 	@After
 	public void tearDown() {
 		ServiceRegistryBuilder.destroy( serviceRegistry );
 	}
 
 	private String getBaseForMappings() {
 		return "org/hibernate/test/";
 	}
 
 	@Test
 	public void testAllInOne() {
 		Configuration cfg = new Configuration();
 
 		cfg.addResource( getBaseForMappings() + "extendshbm/allinone.hbm.xml" );
 		cfg.buildMappings();
 		assertNotNull( cfg.getClassMapping( "org.hibernate.test.extendshbm.Customer" ) );
 		assertNotNull( cfg.getClassMapping( "org.hibernate.test.extendshbm.Person" ) );
 		assertNotNull( cfg.getClassMapping( "org.hibernate.test.extendshbm.Employee" ) );
 	}
 
 	@Test
 	public void testOutOfOrder() {
 		Configuration cfg = new Configuration();
 
 		try {
 			cfg.addResource( getBaseForMappings() + "extendshbm/Customer.hbm.xml" );
 			assertNull(
 					"cannot be in the configuration yet!",
 					cfg.getClassMapping( "org.hibernate.test.extendshbm.Customer" )
 			);
 			cfg.addResource( getBaseForMappings() + "extendshbm/Person.hbm.xml" );
 			cfg.addResource( getBaseForMappings() + "extendshbm/Employee.hbm.xml" );
 
 			cfg.buildSessionFactory( serviceRegistry );
 
 			assertNotNull( cfg.getClassMapping( "org.hibernate.test.extendshbm.Customer" ) );
 			assertNotNull( cfg.getClassMapping( "org.hibernate.test.extendshbm.Person" ) );
 			assertNotNull( cfg.getClassMapping( "org.hibernate.test.extendshbm.Employee" ) );
 
 		}
 		catch ( HibernateException e ) {
 			fail( "should not fail with exception! " + e );
 		}
 
 	}
 
 	@Test
 	public void testNwaitingForSuper() {
 		Configuration cfg = new Configuration();
 
 		try {
 			cfg.addResource( getBaseForMappings() + "extendshbm/Customer.hbm.xml" );
 			assertNull(
 					"cannot be in the configuration yet!",
 					cfg.getClassMapping( "org.hibernate.test.extendshbm.Customer" )
 			);
 			cfg.addResource( getBaseForMappings() + "extendshbm/Employee.hbm.xml" );
 			assertNull(
 					"cannot be in the configuration yet!",
 					cfg.getClassMapping( "org.hibernate.test.extendshbm.Employee" )
 			);
 			cfg.addResource( getBaseForMappings() + "extendshbm/Person.hbm.xml" );
 
 			cfg.buildMappings();
 
 			assertNotNull( cfg.getClassMapping( "org.hibernate.test.extendshbm.Person" ) );
 			assertNotNull( cfg.getClassMapping( "org.hibernate.test.extendshbm.Employee" ) );
 			assertNotNull( cfg.getClassMapping( "org.hibernate.test.extendshbm.Customer" ) );
 
 
 		}
 		catch ( HibernateException e ) {
 			e.printStackTrace();
 			fail( "should not fail with exception! " + e );
 
 		}
 
 	}
 
 	@Test
 	public void testMissingSuper() {
 		Configuration cfg = new Configuration();
 
 		try {
 			cfg.addResource( getBaseForMappings() + "extendshbm/Customer.hbm.xml" );
 			assertNull(
 					"cannot be in the configuration yet!",
 					cfg.getClassMapping( "org.hibernate.test.extendshbm.Customer" )
 			);
 			cfg.addResource( getBaseForMappings() + "extendshbm/Employee.hbm.xml" );
 
 			cfg.buildSessionFactory( serviceRegistry );
 
 			fail( "Should not be able to build sessionFactory without a Person" );
 		}
 		catch ( HibernateException e ) {
 
 		}
 
 	}
 
 	@Test
 	public void testAllSeparateInOne() {
 		Configuration cfg = new Configuration();
 
 		try {
 			cfg.addResource( getBaseForMappings() + "extendshbm/allseparateinone.hbm.xml" );
 
 			cfg.buildSessionFactory( serviceRegistry );
 
 			assertNotNull( cfg.getClassMapping( "org.hibernate.test.extendshbm.Customer" ) );
 			assertNotNull( cfg.getClassMapping( "org.hibernate.test.extendshbm.Person" ) );
 			assertNotNull( cfg.getClassMapping( "org.hibernate.test.extendshbm.Employee" ) );
 
 		}
 		catch ( HibernateException e ) {
 			fail( "should not fail with exception! " + e );
 		}
 
 	}
 
 	@Test
 	public void testJoinedSubclassAndEntityNamesOnly() {
 		Configuration cfg = new Configuration();
 
 		try {
 			cfg.addResource( getBaseForMappings() + "extendshbm/entitynames.hbm.xml" );
 
 			cfg.buildMappings();
 
 			assertNotNull( cfg.getClassMapping( "EntityHasName" ) );
 			assertNotNull( cfg.getClassMapping( "EntityCompany" ) );
 
 		}
 		catch ( HibernateException e ) {
 			e.printStackTrace();
 			fail( "should not fail with exception! " + e );
 
 		}
 	}
 
 	@Test
 	public void testEntityNamesWithPackage() {
 		Configuration cfg = new Configuration();
 		try {
 			cfg.addResource( getBaseForMappings() + "extendshbm/packageentitynames.hbm.xml" );
 
 			cfg.buildMappings();
 
 			assertNotNull( cfg.getClassMapping( "EntityHasName" ) );
 			assertNotNull( cfg.getClassMapping( "EntityCompany" ) );
 
 		}
 		catch ( HibernateException e ) {
 			e.printStackTrace();
 			fail( "should not fail with exception! " + e );
 
 		}
 	}
 
 	@Test
 	public void testUnionSubclass() {
 		Configuration cfg = new Configuration();
 
 		try {
 			cfg.addResource( getBaseForMappings() + "extendshbm/unionsubclass.hbm.xml" );
 
 			cfg.buildMappings();
 
 			assertNotNull( cfg.getClassMapping( "org.hibernate.test.extendshbm.Person" ) );
 			assertNotNull( cfg.getClassMapping( "org.hibernate.test.extendshbm.Customer" ) );
 
 		}
 		catch ( HibernateException e ) {
 			e.printStackTrace();
 			fail( "should not fail with exception! " + e );
 
 		}
 	}
 
 }
 
diff --git a/hibernate-core/src/test/java/org/hibernate/test/fileimport/CommandExtractorServiceTest.java b/hibernate-core/src/test/java/org/hibernate/test/fileimport/CommandExtractorServiceTest.java
index 516b659e86..5f37af583f 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/fileimport/CommandExtractorServiceTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/fileimport/CommandExtractorServiceTest.java
@@ -1,48 +1,49 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.fileimport;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
-import org.hibernate.service.ServiceRegistryBuilder;
+
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.tool.hbm2ddl.ImportSqlCommandExtractor;
 import org.hibernate.tool.hbm2ddl.MultipleLinesSqlCommandExtractor;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 @TestForIssue( jiraKey = "HHH-2403" )
 public class CommandExtractorServiceTest extends MultiLineImportFileTest {
 	@Override
 	public void configure(Configuration cfg) {
 		cfg.setProperty( Environment.HBM2DDL_IMPORT_FILES, "/org/hibernate/test/fileimport/multi-line-statements.sql" );
 	}
 
 	@Override
-	protected void prepareBasicRegistryBuilder(ServiceRegistryBuilder serviceRegistryBuilder) {
+	protected void prepareBasicRegistryBuilder(StandardServiceRegistryBuilder serviceRegistryBuilder) {
 		super.prepareBasicRegistryBuilder( serviceRegistryBuilder );
 		serviceRegistryBuilder.addService( ImportSqlCommandExtractor.class, new MultipleLinesSqlCommandExtractor() );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/flush/TestAutoFlushBeforeQueryExecution.java b/hibernate-core/src/test/java/org/hibernate/test/flush/TestAutoFlushBeforeQueryExecution.java
index 1b356fbc98..b86bf36cfa 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/flush/TestAutoFlushBeforeQueryExecution.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/flush/TestAutoFlushBeforeQueryExecution.java
@@ -1,291 +1,290 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.flush;
 
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.cfg.Configuration;
-import org.hibernate.collection.internal.PersistentSet;
 import org.hibernate.engine.spi.ActionQueue;
 import org.hibernate.engine.spi.PersistenceContext;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.event.spi.PreUpdateEvent;
 import org.hibernate.event.spi.PreUpdateEventListener;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.SessionImpl;
 import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.service.BootstrapServiceRegistryBuilder;
+import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Gail Badner
  */
 @TestForIssue( jiraKey = "HHH-6960" )
 public class TestAutoFlushBeforeQueryExecution extends BaseCoreFunctionalTestCase {
 
 	@Test
 	public void testAutoflushIsRequired() {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Publisher publisher = new Publisher();
 		publisher.setName( "name" );
 		s.save( publisher );
 		assertTrue( "autoflush entity create", s.createQuery( "from Publisher p" ).list().size() == 1 );
 		publisher.setName( "name" );
 		assertTrue( "autoflush entity update", s.createQuery( "from Publisher p where p.name='name'" ).list().size() == 1 );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		publisher = (Publisher) s.get( Publisher.class, publisher.getId() );
 		assertTrue( publisher.getAuthors().isEmpty() );
 
 		final PersistenceContext persistenceContext = ( (SessionImplementor) s ).getPersistenceContext();
 		final ActionQueue actionQueue = ( (SessionImpl) s ).getActionQueue();
 		assertEquals( 1, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 1, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		Author author1 = new Author( );
 		author1.setPublisher( publisher );
 		publisher.getAuthors().add( author1 );
 		assertTrue(
 				"autoflush collection update",
 				s.createQuery( "select a from Publisher p join p.authors a" ).list().size() == 1
 		);
 		assertEquals( 2, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 2, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( author1.getBooks() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( author1.getBooks() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		author1.setPublisher( null );
 		s.delete( author1 );
 		publisher.getAuthors().clear();
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 		assertTrue( "autoflush collection update",
 				s.createQuery( "select a from Publisher p join p.authors a" ).list().size() == 0
 		);
 		assertEquals( 1, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 1, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		Set<Author> authorsOld = publisher.getAuthors();
 		publisher.setAuthors( new HashSet<Author>() );
 		Author author2 = new Author( );
 		author2.setName( "author2" );
 		author2.setPublisher( publisher );
 		publisher.getAuthors().add( author2 );
 		List results = s.createQuery( "select a from Publisher p join p.authors a" ).list();
 		assertEquals( 1, results.size() );
 		assertEquals( 2, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 2, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( author2.getBooks() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( author2.getBooks() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		s.delete(publisher);
 		assertTrue( "autoflush delete", s.createQuery( "from Publisher p" ).list().size()==0 );
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testAutoflushIsNotRequiredWithUnrelatedCollectionChange() {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Publisher publisher = new Publisher();
 		publisher.setName( "name" );
 		s.save( publisher );
 		assertTrue( "autoflush entity create", s.createQuery( "from Publisher p" ).list().size() == 1 );
 		publisher.setName( "name" );
 		assertTrue( "autoflush entity update", s.createQuery( "from Publisher p where p.name='name'" ).list().size() == 1 );
 		UnrelatedEntity unrelatedEntity = new UnrelatedEntity( );
 		s.save( unrelatedEntity );
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		unrelatedEntity = (UnrelatedEntity) s.get( UnrelatedEntity.class, unrelatedEntity.getId() );
 		publisher = (Publisher) s.get( Publisher.class, publisher.getId() );
 		assertTrue( publisher.getAuthors().isEmpty() );
 
 		final PersistenceContext persistenceContext = ( (SessionImplementor) s ).getPersistenceContext();
 		final ActionQueue actionQueue = ( (SessionImpl) s ).getActionQueue();
 		assertEquals( 1, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 1, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		Author author1 = new Author( );
 		author1.setPublisher( publisher );
 		publisher.getAuthors().add( author1 );
 		assertTrue(	s.createQuery( "from UnrelatedEntity" ).list().size() == 1 );
 		assertEquals( 2, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 1, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( author1.getBooks() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		author1.setPublisher( null );
 		s.delete( author1 );
 		publisher.getAuthors().clear();
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 		assertTrue( s.createQuery( "from UnrelatedEntity" ).list().size() == 1 );
 		assertEquals( 2, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 1, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( author1.getBooks() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		Set<Author> authorsOld = publisher.getAuthors();
 		publisher.setAuthors( new HashSet<Author>() );
 		Author author2 = new Author( );
 		author2.setName( "author2" );
 		author2.setPublisher( publisher );
 		publisher.getAuthors().add( author2 );
 		List results = s.createQuery( "from UnrelatedEntity" ).list();
 		assertEquals( 1, results.size() );
 		assertEquals( 4, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 1, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( author2.getBooks() ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( authorsOld ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( author1.getBooks() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( authorsOld ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		s.flush();
 		assertEquals( 2, persistenceContext.getCollectionEntries().size() );
 		assertEquals( 2, persistenceContext.getCollectionsByKey().size() );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionEntries().containsKey( author2.getBooks() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( publisher.getAuthors() ) );
 		assertTrue( persistenceContext.getCollectionsByKey().values().contains( author2.getBooks() ) );
 		assertEquals( 0, actionQueue.numberOfCollectionRemovals() );
 
 		s.delete(publisher);
 		assertTrue( "autoflush delete", s.createQuery( "from UnrelatedEntity" ).list().size()==1 );
 		s.delete( unrelatedEntity );
 		txn.commit();
 		s.close();
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] { Author.class, Book.class, Publisher.class, UnrelatedEntity.class };
 	}
 
 	@Override
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 		super.prepareBootstrapRegistryBuilder( builder );
 		builder.with(
 				new Integrator() {
 
 					@Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						integrate( serviceRegistry );
 					}
 
 					@Override
 					public void integrate(
 							MetadataImplementor metadata,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						integrate( serviceRegistry );
 					}
 
 					private void integrate(SessionFactoryServiceRegistry serviceRegistry) {
 						serviceRegistry.getService( EventListenerRegistry.class )
 								.getEventListenerGroup( EventType.PRE_UPDATE )
 								.appendListener( InitializingPreUpdateEventListener.INSTANCE );
 					}
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 					}
 				}
 		);
 	}
 
 	public static class InitializingPreUpdateEventListener implements PreUpdateEventListener {
 		public static final InitializingPreUpdateEventListener INSTANCE = new InitializingPreUpdateEventListener();
 
 		private boolean executed = false;
 		private boolean foundAny = false;
 
 		@Override
 		public boolean onPreUpdate(PreUpdateEvent event) {
 			executed = true;
 
 			final Object[] oldValues = event.getOldState();
 			final String[] properties = event.getPersister().getPropertyNames();
 
 			// Iterate through all fields of the updated object
 			for ( int i = 0; i < properties.length; i++ ) {
 				if ( oldValues != null && oldValues[i] != null ) {
 					if ( ! Hibernate.isInitialized( oldValues[i] ) ) {
 						// force any proxies and/or collections to initialize to illustrate HHH-2763
 						foundAny = true;
 						Hibernate.initialize( oldValues );
 					}
 				}
 			}
 			return true;
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/flush/TestCollectionInitializingDuringFlush.java b/hibernate-core/src/test/java/org/hibernate/test/flush/TestCollectionInitializingDuringFlush.java
index dcfb74c33b..8170107e61 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/flush/TestCollectionInitializingDuringFlush.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/flush/TestCollectionInitializingDuringFlush.java
@@ -1,152 +1,152 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.flush;
 
 import org.junit.Test;
 
 import org.hibernate.Hibernate;
 import org.hibernate.Session;
+import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.event.spi.PreUpdateEvent;
 import org.hibernate.event.spi.PreUpdateEventListener;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.service.BootstrapServiceRegistryBuilder;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Steve Ebersole
  */
 @TestForIssue( jiraKey = "HHH-2763" )
 public class TestCollectionInitializingDuringFlush extends BaseCoreFunctionalTestCase {
 	@Test
 	public void testInitializationDuringFlush() {
 		assertFalse( InitializingPreUpdateEventListener.INSTANCE.executed );
 		assertFalse( InitializingPreUpdateEventListener.INSTANCE.foundAny );
 
 		Session s = openSession();
 		s.beginTransaction();
 		Publisher publisher = new Publisher( "acme" );
 		Author author = new Author( "john" );
 		author.setPublisher( publisher );
 		publisher.getAuthors().add( author );
 		author.getBooks().add( new Book( "Reflections on a Wimpy Kid", author ) );
 		s.save( author );
 		s.getTransaction().commit();
 		s.clear();
 
 		s = openSession();
 		s.beginTransaction();
 		publisher = (Publisher) s.get( Publisher.class, publisher.getId() );
 		publisher.setName( "random nally" );
 		s.flush();
 		s.getTransaction().commit();
 		s.clear();
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( author );
 		s.getTransaction().commit();
 		s.clear();
 
 		assertTrue( InitializingPreUpdateEventListener.INSTANCE.executed );
 		assertTrue( InitializingPreUpdateEventListener.INSTANCE.foundAny );
 	}
 
 	@Override
 	protected Class<?>[] getAnnotatedClasses() {
 		return new Class<?>[] { Author.class, Book.class, Publisher.class };
 	}
 
 	@Override
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 		super.prepareBootstrapRegistryBuilder( builder );
 		builder.with(
 				new Integrator() {
 
 					@Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						integrate( serviceRegistry );
 					}
 
 					@Override
 					public void integrate(
 							MetadataImplementor metadata,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						integrate( serviceRegistry );
 					}
 
 					private void integrate(SessionFactoryServiceRegistry serviceRegistry) {
 						serviceRegistry.getService( EventListenerRegistry.class )
 								.getEventListenerGroup( EventType.PRE_UPDATE )
 								.appendListener( InitializingPreUpdateEventListener.INSTANCE );
 					}
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 					}
 				}
 		);
 	}
 
 	public static class InitializingPreUpdateEventListener implements PreUpdateEventListener {
 		public static final InitializingPreUpdateEventListener INSTANCE = new InitializingPreUpdateEventListener();
 
 		private boolean executed = false;
 		private boolean foundAny = false;
 
 		@Override
 		public boolean onPreUpdate(PreUpdateEvent event) {
 			executed = true;
 
 			final Object[] oldValues = event.getOldState();
 			final String[] properties = event.getPersister().getPropertyNames();
 
 			// Iterate through all fields of the updated object
 			for ( int i = 0; i < properties.length; i++ ) {
 				if ( oldValues != null && oldValues[i] != null ) {
 					if ( ! Hibernate.isInitialized( oldValues[i] ) ) {
 						// force any proxies and/or collections to initialize to illustrate HHH-2763
 						foundAny = true;
 						Hibernate.initialize( oldValues );
 					}
 				}
 			}
 			return true;
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/BatchingTest.java b/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/BatchingTest.java
index 5f787044b8..df5624df10 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/BatchingTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/jdbc/proxies/BatchingTest.java
@@ -1,220 +1,220 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.jdbc.proxies;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.Statement;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.engine.jdbc.batch.internal.BasicBatchKey;
 import org.hibernate.engine.jdbc.batch.internal.BatchBuilderImpl;
 import org.hibernate.engine.jdbc.batch.internal.BatchingBatch;
 import org.hibernate.engine.jdbc.batch.internal.NonBatchingBatch;
 import org.hibernate.engine.jdbc.batch.spi.Batch;
 import org.hibernate.engine.jdbc.batch.spi.BatchBuilder;
 import org.hibernate.engine.jdbc.batch.spi.BatchKey;
 import org.hibernate.engine.jdbc.spi.JdbcCoordinator;
 import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
 import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
 import org.hibernate.engine.transaction.spi.TransactionContext;
 import org.hibernate.engine.transaction.spi.TransactionImplementor;
 import org.hibernate.jdbc.Expectation;
 import org.hibernate.jdbc.Expectations;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.test.common.JournalingBatchObserver;
 import org.hibernate.test.common.JournalingTransactionObserver;
 import org.hibernate.test.common.TransactionContextImpl;
 import org.hibernate.test.common.TransactionEnvironmentImpl;
 import org.hibernate.testing.env.ConnectionProviderBuilder;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Steve Ebersole
  */
 public class BatchingTest extends BaseUnitTestCase implements BatchKey {
 	private StandardServiceRegistryImpl serviceRegistry;
 
 	@Before
 	public void setUp() throws Exception {
-		serviceRegistry = (StandardServiceRegistryImpl) new ServiceRegistryBuilder()
+		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder()
 				.applySettings( ConnectionProviderBuilder.getConnectionProviderProperties() )
 				.buildServiceRegistry();
 	}
 
 	@After
 	public void tearDown() throws Exception {
 		serviceRegistry.destroy();
 	}
 
 	@Override
 	public int getBatchedStatementCount() {
 		return 1;
 	}
 
 	@Override
 	public Expectation getExpectation() {
 		return Expectations.BASIC;
 	}
 
 	@Test
 	public void testNonBatchingUsage() throws Exception {
 		final TransactionContext transactionContext = new TransactionContextImpl(
 				new TransactionEnvironmentImpl( serviceRegistry )
 		);
 
 		TransactionCoordinatorImpl transactionCoordinator = new TransactionCoordinatorImpl( null, transactionContext );
 		JournalingTransactionObserver observer = new JournalingTransactionObserver();
 		transactionCoordinator.addObserver( observer );
 
 		final JdbcCoordinator jdbcCoordinator = transactionCoordinator.getJdbcCoordinator();
 		LogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();
 		Connection connection = logicalConnection.getShareableConnectionProxy();
 
 		// set up some tables to use
 		Statement statement = connection.createStatement();
 		statement.execute( "drop table SANDBOX_JDBC_TST if exists" );
 		statement.execute( "create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )" );
 		assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 		assertTrue( logicalConnection.isPhysicallyConnected() );
 		statement.close();
 		assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 		assertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified
 
 		// ok, now we can get down to it...
 		TransactionImplementor txn = transactionCoordinator.getTransaction();  // same as Session#getTransaction
 		txn.begin();
 		assertEquals( 1, observer.getBegins() );
 
 		final String insertSql = "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )";
 
 		final BatchBuilder batchBuilder = new BatchBuilderImpl( -1 );
 		final BatchKey batchKey = new BasicBatchKey( "this", Expectations.BASIC );
 		final Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );
 
 		final JournalingBatchObserver batchObserver = new JournalingBatchObserver();
 		insertBatch.addObserver( batchObserver );
 
 		assertTrue( "unexpected Batch impl", NonBatchingBatch.class.isInstance( insertBatch ) );
 		PreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );
 		insert.setLong( 1, 1 );
 		insert.setString( 2, "name" );
 		assertEquals( 0, batchObserver.getExplicitExecutionCount() );
 		assertEquals( 0, batchObserver.getImplicitExecutionCount() );
 		insertBatch.addToBatch();
 		assertEquals( 0, batchObserver.getExplicitExecutionCount() );
 		assertEquals( 1, batchObserver.getImplicitExecutionCount() );
 		assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 
 		insertBatch.execute();
 		assertEquals( 1, batchObserver.getExplicitExecutionCount() );
 		assertEquals( 1, batchObserver.getImplicitExecutionCount() );
 		assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 
 		insertBatch.release();
 
 		txn.commit();
 		logicalConnection.close();
 	}
 
 	@Test
 	public void testBatchingUsage() throws Exception {
 		final TransactionContext transactionContext = new TransactionContextImpl( new TransactionEnvironmentImpl( serviceRegistry ) );
 
 		TransactionCoordinatorImpl transactionCoordinator = new TransactionCoordinatorImpl( null, transactionContext );
 		JournalingTransactionObserver transactionObserver = new JournalingTransactionObserver();
 		transactionCoordinator.addObserver( transactionObserver );
 
 		final JdbcCoordinator jdbcCoordinator = transactionCoordinator.getJdbcCoordinator();
 		LogicalConnectionImplementor logicalConnection = jdbcCoordinator.getLogicalConnection();
 		Connection connection = logicalConnection.getShareableConnectionProxy();
 
 		// set up some tables to use
 		Statement statement = connection.createStatement();
 		statement.execute( "drop table SANDBOX_JDBC_TST if exists" );
 		statement.execute( "create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )" );
 		assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 		assertTrue( logicalConnection.isPhysicallyConnected() );
 		statement.close();
 		assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 		assertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified
 
 		// ok, now we can get down to it...
 		TransactionImplementor txn = transactionCoordinator.getTransaction();  // same as Session#getTransaction
 		txn.begin();
 		assertEquals( 1, transactionObserver.getBegins() );
 
 		final BatchBuilder batchBuilder = new BatchBuilderImpl( 2 );
 		final BatchKey batchKey = new BasicBatchKey( "this", Expectations.BASIC );
 		final Batch insertBatch = batchBuilder.buildBatch( batchKey, jdbcCoordinator );
 		assertTrue( "unexpected Batch impl", BatchingBatch.class.isInstance( insertBatch ) );
 
 		final JournalingBatchObserver batchObserver = new JournalingBatchObserver();
 		insertBatch.addObserver( batchObserver );
 
 		final String insertSql = "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )";
 
 		PreparedStatement insert = insertBatch.getBatchStatement( insertSql, false );
 		insert.setLong( 1, 1 );
 		insert.setString( 2, "name" );
 		assertEquals( 0, batchObserver.getExplicitExecutionCount() );
 		assertEquals( 0, batchObserver.getImplicitExecutionCount() );
 		insertBatch.addToBatch();
 		assertEquals( 0, batchObserver.getExplicitExecutionCount() );
 		assertEquals( 0, batchObserver.getImplicitExecutionCount() );
 		assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 
 		PreparedStatement insert2 = insertBatch.getBatchStatement( insertSql, false );
 		assertSame( insert, insert2 );
 		insert = insert2;
 		insert.setLong( 1, 2 );
 		insert.setString( 2, "another name" );
 		assertEquals( 0, batchObserver.getExplicitExecutionCount() );
 		assertEquals( 0, batchObserver.getImplicitExecutionCount() );
 		insertBatch.addToBatch();
 		assertEquals( 0, batchObserver.getExplicitExecutionCount() );
 		assertEquals( 1, batchObserver.getImplicitExecutionCount() );
 		assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 
 		insertBatch.execute();
 		assertEquals( 1, batchObserver.getExplicitExecutionCount() );
 		assertEquals( 1, batchObserver.getImplicitExecutionCount() );
 		assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 
 		insertBatch.release();
 
 		txn.commit();
 		logicalConnection.close();
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/jpa/AbstractJPATest.java b/hibernate-core/src/test/java/org/hibernate/test/jpa/AbstractJPATest.java
index 40f8cb9eff..06ec5a95ea 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/jpa/AbstractJPATest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/jpa/AbstractJPATest.java
@@ -1,192 +1,192 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.jpa;
 
 import java.io.Serializable;
 import java.util.IdentityHashMap;
 import javax.persistence.EntityNotFoundException;
 
+import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.CascadingActions;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.internal.DefaultAutoFlushEventListener;
 import org.hibernate.event.internal.DefaultFlushEntityEventListener;
 import org.hibernate.event.internal.DefaultFlushEventListener;
 import org.hibernate.event.internal.DefaultPersistEventListener;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.AutoFlushEventListener;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.event.spi.FlushEntityEventListener;
 import org.hibernate.event.spi.FlushEventListener;
 import org.hibernate.event.spi.PersistEventListener;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.proxy.EntityNotFoundDelegate;
-import org.hibernate.service.BootstrapServiceRegistryBuilder;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 /**
  * An abstract test for all JPA spec related tests.
  *
  * @author Steve Ebersole
  */
 public abstract class AbstractJPATest extends BaseCoreFunctionalTestCase {
 	@Override
 	public String[] getMappings() {
 		return new String[] { "jpa/Part.hbm.xml", "jpa/Item.hbm.xml", "jpa/MyEntity.hbm.xml" };
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.JPAQL_STRICT_COMPLIANCE, "true" );
 		cfg.setProperty( Environment.USE_SECOND_LEVEL_CACHE, "false" );
 		cfg.setEntityNotFoundDelegate( new JPAEntityNotFoundDelegate() );
 	}
 
 	@Override
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 		builder.with(
 				new Integrator() {
 
 					@Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						integrate( serviceRegistry );
 					}
 
 					@Override
 					public void integrate(
 							MetadataImplementor metadata,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
 						integrate( serviceRegistry );
 					}
 
 					private void integrate(SessionFactoryServiceRegistry serviceRegistry) {
 						EventListenerRegistry eventListenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 						eventListenerRegistry.setListeners( EventType.PERSIST, buildPersistEventListeners() );
 						eventListenerRegistry.setListeners(
 								EventType.PERSIST_ONFLUSH, buildPersisOnFlushEventListeners()
 						);
 						eventListenerRegistry.setListeners( EventType.AUTO_FLUSH, buildAutoFlushEventListeners() );
 						eventListenerRegistry.setListeners( EventType.FLUSH, buildFlushEventListeners() );
 						eventListenerRegistry.setListeners( EventType.FLUSH_ENTITY, buildFlushEntityEventListeners() );
 					}
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 					}
 				}
 		);
 	}
 
 	@Override
 	public String getCacheConcurrencyStrategy() {
 		// no second level caching
 		return null;
 	}
 
 
 	// mimic specific exception aspects of the JPA environment ~~~~~~~~~~~~~~~~
 
 	private static class JPAEntityNotFoundDelegate implements EntityNotFoundDelegate {
 		public void handleEntityNotFound(String entityName, Serializable id) {
 			throw new EntityNotFoundException("Unable to find " + entityName  + " with id " + id);
 		}
 	}
 
 	// mimic specific event aspects of the JPA environment ~~~~~~~~~~~~~~~~~~~~
 
 	protected PersistEventListener[] buildPersistEventListeners() {
 		return new PersistEventListener[] { new JPAPersistEventListener() };
 	}
 
 	protected PersistEventListener[] buildPersisOnFlushEventListeners() {
 		return new PersistEventListener[] { new JPAPersistOnFlushEventListener() };
 	}
 
 	protected AutoFlushEventListener[] buildAutoFlushEventListeners() {
 		return new AutoFlushEventListener[] { JPAAutoFlushEventListener.INSTANCE };
 	}
 
 	protected FlushEventListener[] buildFlushEventListeners() {
 		return new FlushEventListener[] { JPAFlushEventListener.INSTANCE };
 	}
 
 	protected FlushEntityEventListener[] buildFlushEntityEventListeners() {
 		return new FlushEntityEventListener[] { new JPAFlushEntityEventListener() };
 	}
 
 	public static class JPAPersistEventListener extends DefaultPersistEventListener {
 		// overridden in JPA impl for entity callbacks...
 	}
 
 	public static class JPAPersistOnFlushEventListener extends JPAPersistEventListener {
 		@Override
         protected CascadingAction getCascadeAction() {
 			return CascadingActions.PERSIST_ON_FLUSH;
 		}
 	}
 
 	public static class JPAAutoFlushEventListener extends DefaultAutoFlushEventListener {
 		// not sure why EM code has this ...
 		public static final AutoFlushEventListener INSTANCE = new JPAAutoFlushEventListener();
 
 		@Override
         protected CascadingAction getCascadingAction() {
 			return CascadingActions.PERSIST_ON_FLUSH;
 		}
 
 		@Override
         protected Object getAnything() {
 			return new IdentityHashMap( 10 );
 		}
 	}
 
 	public static class JPAFlushEventListener extends DefaultFlushEventListener {
 		// not sure why EM code has this ...
 		public static final FlushEventListener INSTANCE = new JPAFlushEventListener();
 
 		@Override
         protected CascadingAction getCascadingAction() {
 			return CascadingActions.PERSIST_ON_FLUSH;
 		}
 
 		@Override
         protected Object getAnything() {
 			return new IdentityHashMap( 10 );
 		}
 	}
 
 	public static class JPAFlushEntityEventListener extends DefaultFlushEntityEventListener {
 		// in JPA, used mainly for preUpdate callbacks...
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/keymanytoone/bidir/component/EagerKeyManyToOneTest.java b/hibernate-core/src/test/java/org/hibernate/test/keymanytoone/bidir/component/EagerKeyManyToOneTest.java
index 412170b778..6b22592a89 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/keymanytoone/bidir/component/EagerKeyManyToOneTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/keymanytoone/bidir/component/EagerKeyManyToOneTest.java
@@ -1,210 +1,210 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.keymanytoone.bidir.component;
 
 import org.junit.Test;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.internal.DefaultLoadEventListener;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.event.spi.LoadEvent;
 import org.hibernate.event.spi.LoadEventListener;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.service.BootstrapServiceRegistryBuilder;
+import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.fail;
 
 /**
  * @author Steve Ebersole
  */
 @SuppressWarnings( {"unchecked"})
 public class EagerKeyManyToOneTest extends BaseCoreFunctionalTestCase {
 	@Override
     public String[] getMappings() {
 		return new String[] { "keymanytoone/bidir/component/EagerMapping.hbm.xml" };
 	}
 
 	@Override
     public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 	}
 
 	@Override
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 		super.prepareBootstrapRegistryBuilder( builder );
 		builder.with(
 				new Integrator() {
 
 				    @Override
 					public void integrate(
 							Configuration configuration,
 							SessionFactoryImplementor sessionFactory,
 							SessionFactoryServiceRegistry serviceRegistry) {
                         integrate(serviceRegistry);
 					}
 
                     @Override
 				    public void integrate( MetadataImplementor metadata,
 				                           SessionFactoryImplementor sessionFactory,
 				                           SessionFactoryServiceRegistry serviceRegistry ) {
                         integrate(serviceRegistry);
 				    }
 
                     private void integrate( SessionFactoryServiceRegistry serviceRegistry ) {
                         serviceRegistry.getService( EventListenerRegistry.class ).prependListeners(EventType.LOAD,
                                                                                                    new CustomLoadListener());
                     }
 
 					@Override
 					public void disintegrate(
 							SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 					}
 				}
 		);
 	}
 
 	@Test
 	public void testSaveCascadedToKeyManyToOne() {
 		sessionFactory().getStatistics().clear();
 
 		// test cascading a save to an association with a key-many-to-one which refers to a
 		// just saved entity
 		Session s = openSession();
 		s.beginTransaction();
 		Customer cust = new Customer( "Acme, Inc." );
 		Order order = new Order( new Order.Id( cust, 1 ) );
 		cust.getOrders().add( order );
 		s.save( cust );
 		s.flush();
 		assertEquals( 2, sessionFactory().getStatistics().getEntityInsertCount() );
 		s.delete( cust );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testLoadingStrategies() {
 		sessionFactory().getStatistics().clear();
 
 		Session s = openSession();
 		s.beginTransaction();
 		Customer cust = new Customer( "Acme, Inc." );
 		Order order = new Order( new Order.Id( cust, 1 ) );
 		cust.getOrders().add( order );
 		s.save( cust );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 
 		cust = ( Customer ) s.createQuery( "from Customer" ).uniqueResult();
 		assertEquals( 1, cust.getOrders().size() );
 		s.clear();
 
 		cust = ( Customer ) s.createQuery( "from Customer c join fetch c.orders" ).uniqueResult();
 		assertEquals( 1, cust.getOrders().size() );
 		s.clear();
 
 		cust = ( Customer ) s.createQuery( "from Customer c join fetch c.orders as o join fetch o.id.customer" ).uniqueResult();
 		assertEquals( 1, cust.getOrders().size() );
 		s.clear();
 
 		cust = ( Customer ) s.createCriteria( Customer.class ).uniqueResult();
 		assertEquals( 1, cust.getOrders().size() );
 		s.clear();
 
 		s.delete( cust );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@TestForIssue( jiraKey = "HHH-2277")
 	public void testLoadEntityWithEagerFetchingToKeyManyToOneReferenceBackToSelf() {
 		sessionFactory().getStatistics().clear();
 
 		// long winded method name to say that this is a test specifically for HHH-2277 ;)
 		// essentially we have a bidirectional association where one side of the
 		// association is actually part of a composite PK.
 		//
 		// The way these are mapped causes the problem because both sides
 		// are defined as eager which leads to the infinite loop; if only
 		// one side is marked as eager, then all is ok.  In other words the
 		// problem arises when both pieces of instance data are coming from
 		// the same result set.  This is because no "entry" can be placed
 		// into the persistence context for the association with the
 		// composite key because we are in the process of trying to build
 		// the composite-id instance
 		Session s = openSession();
 		s.beginTransaction();
 		Customer cust = new Customer( "Acme, Inc." );
 		Order order = new Order( new Order.Id( cust, 1 ) );
 		cust.getOrders().add( order );
 		s.save( cust );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		try {
 			cust = ( Customer ) s.get( Customer.class, cust.getId() );
 		}
 		catch( OverflowCondition overflow ) {
 			fail( "get()/load() caused overflow condition" );
 		}
 		s.delete( cust );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	private static class OverflowCondition extends RuntimeException {
 	}
 
 	private static class CustomLoadListener extends DefaultLoadEventListener {
 		private int internalLoadCount = 0;
 		@Override
         public void onLoad(LoadEvent event, LoadType loadType) throws HibernateException {
 			if ( LoadEventListener.INTERNAL_LOAD_EAGER.getName().equals( loadType.getName() ) ) {
 				internalLoadCount++;
 				if ( internalLoadCount > 10 ) {
 					throw new OverflowCondition();
 				}
 			}
 			super.onLoad( event, loadType );
 			internalLoadCount--;
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/legacy/FooBarTest.java b/hibernate-core/src/test/java/org/hibernate/test/legacy/FooBarTest.java
index 121cb08d82..9d6cb6c83c 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/legacy/FooBarTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/legacy/FooBarTest.java
@@ -1,1087 +1,1087 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2006-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.legacy;
 
 import java.io.Serializable;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.sql.Time;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Date;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Locale;
 import java.util.Set;
 import java.util.SortedSet;
 import java.util.TimeZone;
 import java.util.TreeMap;
 import java.util.TreeSet;
 
 import org.jboss.logging.Logger;
 import org.junit.Test;
 
 import org.hibernate.Criteria;
 import org.hibernate.FetchMode;
 import org.hibernate.FlushMode;
 import org.hibernate.Hibernate;
 import org.hibernate.HibernateException;
 import org.hibernate.LazyInitializationException;
 import org.hibernate.LockMode;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.Query;
 import org.hibernate.QueryException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.Transaction;
 import org.hibernate.criterion.Example;
 import org.hibernate.criterion.MatchMode;
 import org.hibernate.criterion.Order;
 import org.hibernate.criterion.Restrictions;
 import org.hibernate.dialect.DB2Dialect;
 import org.hibernate.dialect.DerbyDialect;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.dialect.HSQLDialect;
 import org.hibernate.dialect.InterbaseDialect;
 import org.hibernate.dialect.MckoiDialect;
 import org.hibernate.dialect.MySQLDialect;
 import org.hibernate.dialect.Oracle8iDialect;
 import org.hibernate.dialect.PointbaseDialect;
 import org.hibernate.dialect.PostgreSQL81Dialect;
 import org.hibernate.dialect.PostgreSQLDialect;
 import org.hibernate.dialect.SAPDBDialect;
 import org.hibernate.dialect.Sybase11Dialect;
 import org.hibernate.dialect.SybaseASE15Dialect;
 import org.hibernate.dialect.SybaseDialect;
 import org.hibernate.dialect.TimesTenDialect;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.internal.util.SerializationHelper;
 import org.hibernate.internal.util.collections.JoinedIterator;
 import org.hibernate.jdbc.AbstractReturningWork;
 import org.hibernate.jdbc.AbstractWork;
 import org.hibernate.proxy.HibernateProxy;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.testing.DialectChecks;
 import org.hibernate.testing.RequiresDialect;
 import org.hibernate.testing.RequiresDialectFeature;
 import org.hibernate.testing.env.ConnectionProviderBuilder;
 import org.hibernate.type.StandardBasicTypes;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertSame;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 public class FooBarTest extends LegacyTestCase {
 	private static final Logger log = Logger.getLogger( FooBarTest.class );
 
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 			"legacy/FooBar.hbm.xml",
 			"legacy/Baz.hbm.xml",
 			"legacy/Qux.hbm.xml",
 			"legacy/Glarch.hbm.xml",
 			"legacy/Fum.hbm.xml",
 			"legacy/Fumm.hbm.xml",
 			"legacy/Fo.hbm.xml",
 			"legacy/One.hbm.xml",
 			"legacy/Many.hbm.xml",
 			"legacy/Immutable.hbm.xml",
 			"legacy/Fee.hbm.xml",
 			"legacy/Vetoer.hbm.xml",
 			"legacy/Holder.hbm.xml",
 			"legacy/Location.hbm.xml",
 			"legacy/Stuff.hbm.xml",
 			"legacy/Container.hbm.xml",
 			"legacy/Simple.hbm.xml",
 			"legacy/XY.hbm.xml"
 		};
 	}
 
 	@Test
 	public void testSaveOrUpdateCopyAny() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Bar bar = new Bar();
 		One one = new One();
 		bar.setObject(one);
 		s.save(bar);
 		GlarchProxy g = bar.getComponent().getGlarch();
 		bar.getComponent().setGlarch(null);
 		s.delete(g);
 		s.flush();
 		assertTrue( s.contains(one) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Bar bar2 = (Bar) s.merge( bar );
 		s.flush();
 		s.delete(bar2);
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testRefreshProxy() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Glarch g = new Glarch();
 		Serializable gid = s.save(g);
 		s.flush();
 		s.clear();
 		GlarchProxy gp = (GlarchProxy) s.load(Glarch.class, gid);
 		gp.getName(); //force init
 		s.refresh(gp);
 		s.delete(gp);
 		s.flush();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	@RequiresDialectFeature(
 			value = DialectChecks.SupportsCircularCascadeDeleteCheck.class,
 			comment = "db/dialect does not support circular cascade delete constraints"
 	)
 	public void testOnCascadeDelete() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.subs = new ArrayList();
 		Baz sub = new Baz();
 		sub.superBaz = baz;
 		baz.subs.add(sub);
 		s.save(baz);
 		s.flush();
 		assertTrue( s.createQuery("from Baz").list().size()==2 );
 		s.getTransaction().commit();
 		s.beginTransaction();
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.beginTransaction();
 		assertTrue( s.createQuery("from Baz").list().size()==0 );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testRemoveFromIdbag() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setByteBag( new ArrayList() );
 		byte[] bytes = { 12, 13 };
 		baz.getByteBag().add( new byte[] { 10, 45 } );
 		baz.getByteBag().add(bytes);
 		baz.getByteBag().add( new byte[] { 1, 11 } );
 		baz.getByteBag().add( new byte[] { 12 } );
 		s.save(baz);
 		s.flush();
 		baz.getByteBag().remove(bytes);
 		s.flush();
 		baz.getByteBag().add(bytes);
 		s.flush();
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testLoad() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Qux q = new Qux();
 		s.save(q);
 		BarProxy b = new Bar();
 		s.save(b);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		q = (Qux) s.load(Qux.class, q.getKey() );
 		b = (BarProxy) s.load( Foo.class, b.getKey() );
 		b.getKey();
 		assertFalse( Hibernate.isInitialized(b) );
 		b.getBarString();
 		assertTrue( Hibernate.isInitialized(b) );
 		BarProxy b2 = (BarProxy) s.load( Bar.class, b.getKey() );
 		Qux q2 = (Qux) s.load( Qux.class, q.getKey() );
 		assertTrue( "loaded same object", q==q2 );
 		assertTrue( "loaded same object", b==b2 );
 		assertTrue( Math.round( b.getFormula() ) == b.getInt() / 2 );
 		s.delete(q2);
 		s.delete( b2 );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testJoin() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Foo foo = new Foo();
 		foo.setJoinedProp("foo");
 		s.save( foo );
 		s.flush();
 		foo.setJoinedProp("bar");
 		s.flush();
 		String fid = foo.getKey();
 		s.delete( foo );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Foo foo2 = new Foo();
 		foo2.setJoinedProp("foo");
 		s.save(foo2);
 		s.createQuery( "select foo.id from Foo foo where foo.joinedProp = 'foo'" ).list();
 		assertNull( s.get(Foo.class, fid) );
 		s.delete(foo2);
 		s.getTransaction().commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testDereferenceLazyCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setFooSet( new HashSet() );
 		Foo foo = new Foo();
 		baz.getFooSet().add(foo);
 		s.save(foo);
 		s.save(baz);
 		foo.setBytes( "foobar".getBytes() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo = (Foo) s.get( Foo.class, foo.getKey() );
 		assertTrue( Hibernate.isInitialized( foo.getBytes() ) );
 		assertTrue( foo.getBytes().length==6 );
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		assertTrue( baz.getFooSet().size()==1 );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().evictCollection("org.hibernate.test.legacy.Baz.fooSet");
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		assertFalse( Hibernate.isInitialized( baz.getFooSet() ) );
 		baz.setFooSet(null);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo = (Foo) s.get( Foo.class, foo.getKey() );
 		assertTrue( foo.getBytes().length==6 );
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		assertFalse( Hibernate.isInitialized( baz.getFooSet() ) );
 		assertTrue( baz.getFooSet().size()==0 );
 		s.delete(baz);
 		s.delete(foo);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testMoveLazyCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		Baz baz2 = new Baz();
 		baz.setFooSet( new HashSet() );
 		Foo foo = new Foo();
 		baz.getFooSet().add(foo);
 		s.save(foo);
 		s.save(baz);
 		s.save(baz2);
 		foo.setBytes( "foobar".getBytes() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo = (Foo) s.get( Foo.class, foo.getKey() );
 		assertTrue( Hibernate.isInitialized( foo.getBytes() ) );
 		assertTrue( foo.getBytes().length==6 );
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		assertTrue( baz.getFooSet().size()==1 );
 		s.getTransaction().commit();
 		s.close();
 
 		sessionFactory().evictCollection("org.hibernate.test.legacy.Baz.fooSet");
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		assertFalse( Hibernate.isInitialized( baz.getFooSet() ) );
 		baz2 = (Baz) s.get( Baz.class, baz2.getCode() );
 		baz2.setFooSet( baz.getFooSet() );
 		baz.setFooSet(null);
 		assertFalse( Hibernate.isInitialized( baz2.getFooSet() ) );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		foo = (Foo) s.get( Foo.class, foo.getKey() );
 		assertTrue( foo.getBytes().length==6 );
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		baz2 = (Baz) s.get( Baz.class, baz2.getCode() );
 		assertFalse( Hibernate.isInitialized( baz.getFooSet() ) );
 		assertTrue( baz.getFooSet().size()==0 );
 		assertTrue( Hibernate.isInitialized( baz2.getFooSet() ) ); //fooSet has batching enabled
 		assertTrue( baz2.getFooSet().size()==1 );
 		s.delete(baz);
 		s.delete(baz2);
 		s.delete(foo);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testCriteriaCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz bb = (Baz) s.createCriteria(Baz.class).uniqueResult();
 		assertTrue( bb == null );
 		Baz baz = new Baz();
 		s.save( baz );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		Baz b = (Baz) s.createCriteria(Baz.class).uniqueResult();
 		assertTrue( Hibernate.isInitialized( b.getTopGlarchez() ) );
 		assertTrue( b.getTopGlarchez().size() == 0 );
 		s.delete( b );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testQuery() throws Exception {
 		Session s = openSession();
 		Transaction txn = s.beginTransaction();
 		Foo foo = new Foo();
 		s.save(foo);
 		Foo foo2 = new Foo();
 		s.save(foo2);
 		foo.setFoo(foo2);
 
 		List list = s.createQuery( "from Foo foo inner join fetch foo.foo" ).list();
 		Foo foof = (Foo) list.get(0);
 		assertTrue( Hibernate.isInitialized( foof.getFoo() ) );
 
 		s.createQuery( "from Baz baz left outer join fetch baz.fooToGlarch" ).list();
 
 		list = s.createQuery( "select foo, bar from Foo foo left outer join foo.foo bar where foo = ?" )
 				.setParameter( 0, foo, s.getTypeHelper().entity(Foo.class) )
 				.list();
 		Object[] row1 = (Object[]) list.get(0);
 		assertTrue( row1[0]==foo && row1[1]==foo2 );
 
 		s.createQuery( "select foo.foo.foo.string from Foo foo where foo.foo = 'bar'" ).list();
 		s.createQuery( "select foo.foo.foo.foo.string from Foo foo where foo.foo = 'bar'" ).list();
 		s.createQuery( "select foo from Foo foo where foo.foo.foo = 'bar'" ).list();
 		s.createQuery( "select foo.foo.foo.foo.string from Foo foo where foo.foo.foo = 'bar'" ).list();
 		s.createQuery( "select foo.foo.foo.string from Foo foo where foo.foo.foo.foo.string = 'bar'" ).list();
 		if ( ! (getDialect() instanceof HSQLDialect) )
 			s.createQuery( "select foo.string from Foo foo where foo.foo.foo.foo = foo.foo.foo" ).list();
 		s.createQuery( "select foo.string from Foo foo where foo.foo.foo = 'bar' and foo.foo.foo.foo = 'baz'" ).list();
 		s.createQuery( "select foo.string from Foo foo where foo.foo.foo.foo.string = 'a' and foo.foo.string = 'b'" )
 				.list();
 
 		s.createQuery( "from Bar bar, foo in elements(bar.baz.fooArray)" ).list();
 
 		//s.find("from Baz as baz where baz.topComponents[baz].name = 'bazzz'");
 
 		if ( (getDialect() instanceof DB2Dialect) && !(getDialect() instanceof DerbyDialect) ) {
 			s.createQuery( "from Foo foo where lower( foo.foo.string ) = 'foo'" ).list();
 			s.createQuery( "from Foo foo where lower( (foo.foo.string || 'foo') || 'bar' ) = 'foo'" ).list();
 			s.createQuery( "from Foo foo where repeat( (foo.foo.string || 'foo') || 'bar', 2 ) = 'foo'" ).list();
 			s.createQuery(
 					"from Bar foo where foo.foo.integer is not null and repeat( (foo.foo.string || 'foo') || 'bar', (5+5)/2 ) = 'foo'"
 			).list();
 			s.createQuery(
 					"from Bar foo where foo.foo.integer is not null or repeat( (foo.foo.string || 'foo') || 'bar', (5+5)/2 ) = 'foo'"
 			).list();
 		}
 		if (getDialect() instanceof SybaseDialect) {
 			s.createQuery( "select baz from Baz as baz join baz.fooArray foo group by baz order by sum(foo.float)" )
 					.iterate();
 		}
 
 		s.createQuery( "from Foo as foo where foo.component.glarch.name is not null" ).list();
 		s.createQuery( "from Foo as foo left outer join foo.component.glarch as glarch where glarch.name = 'foo'" )
 				.list();
 
 		list = s.createQuery( "from Foo" ).list();
 		assertTrue( list.size()==2 && list.get(0) instanceof FooProxy );
 		list = s.createQuery( "from Foo foo left outer join foo.foo" ).list();
 		assertTrue( list.size()==2 && ( (Object[]) list.get(0) )[0] instanceof FooProxy );
 
 		s.createQuery("from Bar, Bar").list();
 		s.createQuery("from Foo, Bar").list();
 		s.createQuery( "from Baz baz left join baz.fooToGlarch, Bar bar join bar.foo" ).list();
 		s.createQuery( "from Baz baz left join baz.fooToGlarch join baz.fooSet" ).list();
 		s.createQuery( "from Baz baz left join baz.fooToGlarch join fetch baz.fooSet foo left join fetch foo.foo" )
 				.list();
 
 		list = s.createQuery(
 				"from Foo foo where foo.string='osama bin laden' and foo.boolean = true order by foo.string asc, foo.component.count desc"
 		).list();
 		assertTrue( "empty query", list.size()==0 );
 		Iterator iter = s.createQuery(
 				"from Foo foo where foo.string='osama bin laden' order by foo.string asc, foo.component.count desc"
 		).iterate();
 		assertTrue( "empty iterator", !iter.hasNext() );
 
 		list = s.createQuery( "select foo.foo from Foo foo" ).list();
 		assertTrue( "query", list.size()==1 );
 		assertTrue( "returned object", list.get(0)==foo.getFoo() );
 		foo.getFoo().setFoo(foo);
 		foo.setString("fizard");
 		//The following test is disabled for databases with no subselects...also for Interbase (not sure why).
 		if (
 				!(getDialect() instanceof MySQLDialect) &&
 				!(getDialect() instanceof HSQLDialect) &&
 				!(getDialect() instanceof MckoiDialect) &&
 				!(getDialect() instanceof SAPDBDialect) &&
 				!(getDialect() instanceof PointbaseDialect) &&
 				!(getDialect() instanceof DerbyDialect)
 		)  {
 			// && !db.equals("weblogic") {
 			if ( !( getDialect() instanceof InterbaseDialect ) ) {
 				list = s.createQuery( "from Foo foo where ? = some elements(foo.component.importantDates)" )
 						.setParameter( 0, new Date(), StandardBasicTypes.DATE )
 						.list();
 				assertTrue( "component query", list.size()==2 );
 			}
 			if( !( getDialect() instanceof TimesTenDialect)) {
 				list = s.createQuery( "from Foo foo where size(foo.component.importantDates) = 3" ).list(); //WAS: 4
 				assertTrue( "component query", list.size()==2 );
 				list = s.createQuery( "from Foo foo where 0 = size(foo.component.importantDates)" ).list();
 				assertTrue( "component query", list.size()==0 );
 			}
 			list = s.createQuery( "from Foo foo where exists elements(foo.component.importantDates)" ).list();
 			assertTrue( "component query", list.size()==2 );
 			s.createQuery( "from Foo foo where not exists (from Bar bar where bar.id = foo.id)" ).list();
 
 			s.createQuery(
 					"select foo.foo from Foo foo where foo = some(select x from Foo x where x.long > foo.foo.long)"
 			).list();
 			s.createQuery( "select foo.foo from Foo foo where foo = some(from Foo x where (x.long > foo.foo.long))" )
 					.list();
 			if ( !( getDialect() instanceof TimesTenDialect)) {
 				s.createQuery(
 						"select foo.foo from Foo foo where foo.long = some( select max(x.long) from Foo x where (x.long > foo.foo.long) group by x.foo )"
 				).list();
 			}
 			s.createQuery(
 					"from Foo foo where foo = some(select x from Foo x where x.long > foo.foo.long) and foo.foo.string='baz'"
 			).list();
 			s.createQuery(
 					"from Foo foo where foo.foo.string='baz' and foo = some(select x from Foo x where x.long > foo.foo.long)"
 			).list();
 			s.createQuery( "from Foo foo where foo = some(select x from Foo x where x.long > foo.foo.long)" ).list();
 
 			s.createQuery(
 					"select foo.string, foo.date, foo.foo.string, foo.id from Foo foo, Baz baz where foo in elements(baz.fooArray) and foo.string like 'foo'"
 			).iterate();
 		}
 		list = s.createQuery( "from Foo foo where foo.component.count is null order by foo.component.count" ).list();
 		assertTrue( "component query", list.size()==0 );
 		list = s.createQuery( "from Foo foo where foo.component.name='foo'" ).list();
 		assertTrue( "component query", list.size()==2 );
 		list = s.createQuery(
 				"select distinct foo.component.name, foo.component.name from Foo foo where foo.component.name='foo'"
 		).list();
 		assertTrue( "component query", list.size()==1 );
 		list = s.createQuery( "select distinct foo.component.name, foo.id from Foo foo where foo.component.name='foo'" )
 				.list();
 		assertTrue( "component query", list.size()==2 );
 		list = s.createQuery( "select foo.foo from Foo foo" ).list();
 		assertTrue( "query", list.size()==2 );
 		list = s.createQuery( "from Foo foo where foo.id=?" )
 				.setParameter( 0, foo.getKey(), StandardBasicTypes.STRING )
 				.list();
 		assertTrue( "id query", list.size()==1 );
 		list = s.createQuery( "from Foo foo where foo.key=?" )
 				.setParameter( 0, foo.getKey(), StandardBasicTypes.STRING )
 				.list();
 		assertTrue( "named id query", list.size()==1 );
 		assertTrue( "id query", list.get(0)==foo );
 		list = s.createQuery( "select foo.foo from Foo foo where foo.string='fizard'" ).list();
 		assertTrue( "query", list.size()==1 );
 		assertTrue( "returned object", list.get(0)==foo.getFoo() );
 		list = s.createQuery( "from Foo foo where foo.component.subcomponent.name='bar'" ).list();
 		assertTrue( "components of components", list.size()==2 );
 		list = s.createQuery( "select foo.foo from Foo foo where foo.foo.id=?" )
 				.setParameter( 0, foo.getFoo().getKey(), StandardBasicTypes.STRING )
 				.list();
 		assertTrue( "by id query", list.size()==1 );
 		assertTrue( "by id returned object", list.get(0)==foo.getFoo() );
 
 		s.createQuery( "from Foo foo where foo.foo = ?" ).setParameter( 0, foo.getFoo(), s.getTypeHelper().entity(Foo.class) ).list();
 
 		assertTrue( !s.createQuery( "from Bar bar where bar.string='a string' or bar.string='a string'" )
 				.iterate()
 				.hasNext() );
 
 		iter = s.createQuery( "select foo.component.name, elements(foo.component.importantDates) from Foo foo where foo.foo.id=?" )
 				.setParameter( 0, foo.getFoo().getKey(), StandardBasicTypes.STRING )
 				.iterate();
 		int i=0;
 		while ( iter.hasNext() ) {
 			i++;
 			Object[] row = (Object[]) iter.next();
 			assertTrue( row[0] instanceof String && ( row[1]==null || row[1] instanceof Date ) );
 		}
 		assertTrue(i==3); //WAS: 4
 		iter = s.createQuery( "select max( elements(foo.component.importantDates) ) from Foo foo group by foo.id" )
 				.iterate();
 		assertTrue( iter.next() instanceof Date );
 
 		list = s.createQuery(
 				"select foo.foo.foo.foo from Foo foo, Foo foo2 where"
 						+ " foo = foo2.foo and not not ( not foo.string='fizard' )"
 						+ " and foo2.string between 'a' and (foo.foo.string)"
 						+ ( ( getDialect() instanceof HSQLDialect || getDialect() instanceof InterbaseDialect || getDialect() instanceof TimesTenDialect ) ?
 						" and ( foo2.string in ( 'fiz', 'blah') or 1=1 )"
 						:
 						" and ( foo2.string in ( 'fiz', 'blah', foo.foo.string, foo.string, foo2.string ) )"
 				)
 		).list();
 		assertTrue( "complex query", list.size()==1 );
 		assertTrue( "returned object", list.get(0)==foo );
 		foo.setString("from BoogieDown  -tinsel town  =!@#$^&*())");
 		list = s.createQuery( "from Foo foo where foo.string='from BoogieDown  -tinsel town  =!@#$^&*())'" ).list();
 		assertTrue( "single quotes", list.size()==1 );
 		list = s.createQuery( "from Foo foo where not foo.string='foo''bar'" ).list();
 		assertTrue( "single quotes", list.size()==2 );
 		list = s.createQuery( "from Foo foo where foo.component.glarch.next is null" ).list();
 		assertTrue( "query association in component", list.size()==2 );
 		Bar bar = new Bar();
 		Baz baz = new Baz();
 		baz.setDefaults();
 		bar.setBaz(baz);
 		baz.setManyToAny( new ArrayList() );
 		baz.getManyToAny().add(bar);
 		baz.getManyToAny().add(foo);
 		s.save(bar);
 		s.save(baz);
 		list = s.createQuery(
 				" from Bar bar where bar.baz.count=667 and bar.baz.count!=123 and not bar.baz.name='1-E-1'"
 		).list();
 		assertTrue( "query many-to-one", list.size()==1 );
 		list = s.createQuery( " from Bar i where i.baz.name='Bazza'" ).list();
 		assertTrue( "query many-to-one", list.size()==1 );
 
 		Iterator rs = s.createQuery( "select count(distinct foo.foo) from Foo foo" ).iterate();
 		assertTrue( "count", ( (Long) rs.next() ).longValue()==2 );
 		assertTrue( !rs.hasNext() );
 		rs = s.createQuery( "select count(foo.foo.boolean) from Foo foo" ).iterate();
 		assertTrue( "count", ( (Long) rs.next() ).longValue()==2 );
 		assertTrue( !rs.hasNext() );
 		rs = s.createQuery( "select count(*), foo.int from Foo foo group by foo.int" ).iterate();
 		assertTrue( "count(*) group by", ( (Object[]) rs.next() )[0].equals( new Long(3) ) );
 		assertTrue( !rs.hasNext() );
 		rs = s.createQuery( "select sum(foo.foo.int) from Foo foo" ).iterate();
 		assertTrue( "sum", ( (Long) rs.next() ).longValue()==4 );
 		assertTrue( !rs.hasNext() );
 		rs = s.createQuery( "select count(foo) from Foo foo where foo.id=?" )
 				.setParameter( 0, foo.getKey(), StandardBasicTypes.STRING )
 				.iterate();
 		assertTrue( "id query count", ( (Long) rs.next() ).longValue()==1 );
 		assertTrue( !rs.hasNext() );
 
 		s.createQuery( "from Foo foo where foo.boolean = ?" )
 				.setParameter( 0, new Boolean(true), StandardBasicTypes.BOOLEAN )
 				.list();
 
 		s.createQuery( "select new Foo(fo.x) from Fo fo" ).list();
 		s.createQuery( "select new Foo(fo.integer) from Foo fo" ).list();
 
 		list = s.createQuery("select new Foo(fo.x) from Foo fo")
 			//.setComment("projection test")
 			.setCacheable(true)
 			.list();
 		assertTrue(list.size()==3);
 		list = s.createQuery("select new Foo(fo.x) from Foo fo")
 			//.setComment("projection test 2")
 			.setCacheable(true)
 			.list();
 		assertTrue(list.size()==3);
 
 		rs = s.createQuery( "select new Foo(fo.x) from Foo fo" ).iterate();
 		assertTrue( "projection iterate (results)", rs.hasNext() );
 		assertTrue( "projection iterate (return check)", Foo.class.isAssignableFrom( rs.next().getClass() ) );
 
 		ScrollableResults sr = s.createQuery("select new Foo(fo.x) from Foo fo").scroll();
 		assertTrue( "projection scroll (results)", sr.next() );
 		assertTrue( "projection scroll (return check)", Foo.class.isAssignableFrom( sr.get(0).getClass() ) );
 
 		list = s.createQuery( "select foo.long, foo.component.name, foo, foo.foo from Foo foo" ).list();
 		rs = list.iterator();
 		int count=0;
 		while ( rs.hasNext() ) {
 			count++;
 			Object[] row = (Object[]) rs.next();
 			assertTrue( row[0] instanceof Long );
 			assertTrue( row[1] instanceof String );
 			assertTrue( row[2] instanceof Foo );
 			assertTrue( row[3] instanceof Foo );
 		}
 		assertTrue(count!=0);
 		list = s.createQuery( "select avg(foo.float), max(foo.component.name), count(distinct foo.id) from Foo foo" )
 				.list();
 		rs = list.iterator();
 		count=0;
 		while ( rs.hasNext() ) {
 			count++;
 			Object[] row = (Object[]) rs.next();
 			assertTrue( row[0] instanceof Double );
 			assertTrue( row[1] instanceof String );
 			assertTrue( row[2] instanceof Long );
 		}
 		assertTrue(count!=0);
 		list = s.createQuery( "select foo.long, foo.component, foo, foo.foo from Foo foo" ).list();
 		rs = list.iterator();
 		count=0;
 		while ( rs.hasNext() ) {
 			count++;
 			Object[] row = (Object[]) rs.next();
 			assertTrue( row[0] instanceof Long );
 			assertTrue( row[1] instanceof FooComponent );
 			assertTrue( row[2] instanceof Foo );
 			assertTrue( row[3] instanceof Foo );
 		}
 		assertTrue(count!=0);
 
 		s.save( new Holder("ice T") );
 		s.save( new Holder("ice cube") );
 
 		assertTrue( s.createQuery( "from java.lang.Object as o" ).list().size()==15 );
 		assertTrue( s.createQuery( "from Named" ).list().size()==7 );
 		assertTrue( s.createQuery( "from Named n where n.name is not null" ).list().size()==4 );
 		iter = s.createQuery( "from Named n" ).iterate();
 		while ( iter.hasNext() ) {
 			assertTrue( iter.next() instanceof Named );
 		}
 
 		s.save( new Holder("bar") );
 		iter = s.createQuery( "from Named n0, Named n1 where n0.name = n1.name" ).iterate();
 		int cnt = 0;
 		while ( iter.hasNext() ) {
 			Object[] row = (Object[]) iter.next();
 			if ( row[0]!=row[1] ) cnt++;
 		}
 		if ( !(getDialect() instanceof HSQLDialect) ) {
 			assertTrue(cnt==2);
 			assertTrue( s.createQuery( "from Named n0, Named n1 where n0.name = n1.name" ).list().size()==7 );
 		}
 
 		Query qu = s.createQuery("from Named n where n.name = :name");
 		qu.getReturnTypes();
 		qu.getNamedParameters();
 
 		iter = s.createQuery( "from java.lang.Object" ).iterate();
 		int c = 0;
 		while ( iter.hasNext() ) {
 			iter.next();
 			c++;
 		}
 		assertTrue(c==16);
 
 		s.createQuery( "select baz.code, min(baz.count) from Baz baz group by baz.code" ).iterate();
 
 		iter = s.createQuery( "selecT baz from Baz baz where baz.stringDateMap['foo'] is not null or baz.stringDateMap['bar'] = ?" )
 				.setParameter( 0, new Date(), StandardBasicTypes.DATE )
 				.iterate();
 		assertFalse( iter.hasNext() );
 		list = s.createQuery( "select baz from Baz baz where baz.stringDateMap['now'] is not null" ).list();
 		assertTrue( list.size()==1 );
 		list = s.createQuery(
 				"select baz from Baz baz where baz.stringDateMap['now'] is not null and baz.stringDateMap['big bang'] < baz.stringDateMap['now']"
 		).list();
 		assertTrue( list.size()==1 );
 		list = s.createQuery( "select index(date) from Baz baz join baz.stringDateMap date" ).list();
 		System.out.println(list);
 		assertTrue( list.size()==2 );
 
 		s.createQuery(
 				"from Foo foo where foo.integer not between 1 and 5 and foo.string not in ('cde', 'abc') and foo.string is not null and foo.integer<=3"
 		).list();
 
 		s.createQuery( "from Baz baz inner join baz.collectionComponent.nested.foos foo where foo.string is null" )
 				.list();
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof MckoiDialect) && !(getDialect() instanceof SAPDBDialect) && !(getDialect() instanceof PointbaseDialect) )  {
 			s.createQuery(
 					"from Baz baz inner join baz.fooSet where '1' in (from baz.fooSet foo where foo.string is not null)"
 			).list();
 			s.createQuery(
 					"from Baz baz where 'a' in elements(baz.collectionComponent.nested.foos) and 1.0 in elements(baz.collectionComponent.nested.floats)"
 			).list();
 			s.createQuery(
 					"from Baz baz where 'b' in elements(baz.collectionComponent.nested.foos) and 1.0 in elements(baz.collectionComponent.nested.floats)"
 			).list();
 		}
 
 		s.createQuery( "from Foo foo join foo.foo where foo.foo in ('1','2','3')" ).list();
 		if ( !(getDialect() instanceof HSQLDialect) )
 			s.createQuery( "from Foo foo left join foo.foo where foo.foo in ('1','2','3')" ).list();
 		s.createQuery( "select foo.foo from Foo foo where foo.foo in ('1','2','3')" ).list();
 		s.createQuery( "select foo.foo.string from Foo foo where foo.foo in ('1','2','3')" ).list();
 		s.createQuery( "select foo.foo.string from Foo foo where foo.foo.string in ('1','2','3')" ).list();
 		s.createQuery( "select foo.foo.long from Foo foo where foo.foo.string in ('1','2','3')" ).list();
 		s.createQuery( "select count(*) from Foo foo where foo.foo.string in ('1','2','3') or foo.foo.long in (1,2,3)" )
 				.list();
 		s.createQuery( "select count(*) from Foo foo where foo.foo.string in ('1','2','3') group by foo.foo.long" )
 				.list();
 
 		s.createQuery( "from Foo foo1 left join foo1.foo foo2 left join foo2.foo where foo1.string is not null" )
 				.list();
 		s.createQuery( "from Foo foo1 left join foo1.foo.foo where foo1.string is not null" ).list();
 		s.createQuery( "from Foo foo1 left join foo1.foo foo2 left join foo1.foo.foo foo3 where foo1.string is not null" )
 				.list();
 
 		s.createQuery( "select foo.formula from Foo foo where foo.formula > 0" ).list();
 
 		int len = s.createQuery( "from Foo as foo join foo.foo as foo2 where foo2.id >'a' or foo2.id <'a'" ).list().size();
 		assertTrue(len==2);
 
 		for ( Object entity : s.createQuery( "from Holder" ).list() ) {
 			s.delete( entity );
 		}
 
 		txn.commit();
 		s.close();
 
 		s = openSession();
 		txn = s.beginTransaction();
 		baz = (Baz) s.createQuery("from Baz baz left outer join fetch baz.manyToAny").uniqueResult();
 		assertTrue( Hibernate.isInitialized( baz.getManyToAny() ) );
 		assertTrue( baz.getManyToAny().size()==2 );
 		BarProxy barp = (BarProxy) baz.getManyToAny().get(0);
 		s.createQuery( "from Baz baz join baz.manyToAny" ).list();
 		assertTrue( s.createQuery( "select baz from Baz baz join baz.manyToAny a where index(a) = 0" ).list().size()==1 );
 
 		FooProxy foop = (FooProxy) s.get( Foo.class, foo.getKey() );
 		assertTrue( foop == baz.getManyToAny().get(1) );
 
 		barp.setBaz(baz);
 		assertTrue(
 				s.createQuery( "select bar from Bar bar where bar.baz.stringDateMap['now'] is not null" ).list().size()==1 );
 		assertTrue(
 				s.createQuery(
 						"select bar from Bar bar join bar.baz b where b.stringDateMap['big bang'] < b.stringDateMap['now'] and b.stringDateMap['now'] is not null"
 				).list()
 						.size()==1 );
 		assertTrue(
 				s.createQuery(
 						"select bar from Bar bar where bar.baz.stringDateMap['big bang'] < bar.baz.stringDateMap['now'] and bar.baz.stringDateMap['now'] is not null"
 				).list()
 						.size()==1 );
 
 		list = s.createQuery( "select foo.string, foo.component, foo.id from Bar foo" ).list();
 		assertTrue ( ( (FooComponent) ( (Object[]) list.get(0) )[1] ).getName().equals("foo") );
 		list = s.createQuery( "select elements(baz.components) from Baz baz" ).list();
 		assertTrue( list.size()==2 );
 		list = s.createQuery( "select bc.name from Baz baz join baz.components bc" ).list();
 		assertTrue( list.size()==2 );
 		//list = s.find("select bc from Baz baz join baz.components bc");
 
 		s.createQuery("from Foo foo where foo.integer < 10 order by foo.string").setMaxResults(12).list();
 
 		s.delete(barp);
 		s.delete(baz);
 		s.delete( foop.getFoo() );
 		s.delete(foop);
 		txn.commit();
 		s.close();
 	}
 
 	@Test
 	public void testCascadeDeleteDetached() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		List list = new ArrayList();
 		list.add( new Fee() );
 		baz.setFees( list );
 		s.save( baz );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		s.getTransaction().commit();
 		s.close();
 
 		assertFalse( Hibernate.isInitialized( baz.getFees() ) );
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete( baz );
 		s.flush();
 		assertFalse( s.createQuery( "from Fee" ).iterate().hasNext() );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = new Baz();
 		list = new ArrayList();
 		list.add( new Fee() );
 		list.add( new Fee() );
 		baz.setFees(list);
 		s.save( baz );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.get( Baz.class, baz.getCode() );
 		Hibernate.initialize( baz.getFees() );
 		s.getTransaction().commit();
 		s.close();
 
 		assertTrue( baz.getFees().size() == 2 );
 
 		s = openSession();
 		s.beginTransaction();
 		s.delete(baz);
 		s.flush();
 		assertFalse( s.createQuery( "from Fee" ).iterate().hasNext() );
 		s.getTransaction().commit();
 		s.close();
 
 	}
 
 	@Test
 	public void testForeignKeys() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		Foo foo = new Foo();
 		List bag = new ArrayList();
 		bag.add(foo);
 		baz.setIdFooBag(bag);
 		baz.setFoo(foo);
 		s.save(baz);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.load( Baz.class, baz.getCode() );
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testNonlazyCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		s.save( baz );
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz = (Baz) s.createCriteria(Baz.class)
 			//.setComment("criteria test")
 			.setFetchMode( "stringDateMap", FetchMode.JOIN )
 			.uniqueResult();
 		assertTrue( Hibernate.isInitialized( baz.getFooToGlarch() ) );
 		assertTrue( Hibernate.isInitialized( baz.getFooComponentToFoo() ) );
 		assertTrue( !Hibernate.isInitialized( baz.getStringSet() ) );
 		assertTrue( Hibernate.isInitialized( baz.getStringDateMap() ) );
 		s.delete(baz);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testReuseDeletedCollection() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setDefaults();
 		s.save(baz);
 		s.flush();
 		s.delete(baz);
 		Baz baz2 = new Baz();
 		baz2.setStringArray( new String[] {"x-y-z"} );
 		s.save(baz2);
 		s.getTransaction().commit();
 		s.close();
 
 		baz2.setStringSet( baz.getStringSet() );
 		baz2.setStringArray( baz.getStringArray() );
 		baz2.setFooArray( baz.getFooArray() );
 
 		s = openSession();
 		s.beginTransaction();
 		s.update(baz2);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		baz2 = (Baz) s.load( Baz.class, baz2.getCode() );
 		assertTrue( baz2.getStringArray().length==3 );
 		assertTrue( baz2.getStringSet().size()==3 );
 		s.delete(baz2);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testPropertyRef() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Holder h = new Holder();
 		h.setName("foo");
 		Holder h2 = new Holder();
 		h2.setName("bar");
 		h.setOtherHolder(h2);
 		Serializable hid = s.save(h);
 		Qux q = new Qux();
 		q.setHolder(h2);
 		Serializable qid = s.save(q);
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		h = (Holder) s.load(Holder.class, hid);
 		assertEquals( h.getName(), "foo");
 		assertEquals( h.getOtherHolder().getName(), "bar");
 		Object[] res = (Object[]) s.createQuery( "from Holder h join h.otherHolder oh where h.otherHolder.name = 'bar'" )
 				.list()
 				.get(0);
 		assertTrue( res[0]==h );
 		q = (Qux) s.get(Qux.class, qid);
 		assertTrue( q.getHolder() == h.getOtherHolder() );
 		s.delete(h);
 		s.delete(q);
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testQueryCollectionOfValues() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		baz.setDefaults();
 		s.save(baz);
 		Glarch g = new Glarch();
 		Serializable gid = s.save(g);
 
 		if ( !(getDialect() instanceof MySQLDialect) && !(getDialect() instanceof HSQLDialect) /*&& !(dialect instanceof MckoiDialect)*/ && !(getDialect() instanceof SAPDBDialect) && !(getDialect() instanceof PointbaseDialect) && !(getDialect() instanceof TimesTenDialect) ) {
 			s.createFilter( baz.getFooArray(), "where size(this.bytes) > 0" ).list();
 			s.createFilter( baz.getFooArray(), "where 0 in elements(this.bytes)" ).list();
 		}
 		s.getTransaction().commit();
 		s.close();
 
 		s = openSession();
 		s.beginTransaction();
 		s.createQuery( "from Baz baz join baz.fooSet foo join foo.foo.foo foo2 where foo2.string = 'foo'" ).list();
 		s.createQuery( "from Baz baz join baz.fooArray foo join foo.foo.foo foo2 where foo2.string = 'foo'" ).list();
 		s.createQuery( "from Baz baz join baz.stringDateMap date where index(date) = 'foo'" ).list();
 		s.createQuery( "from Baz baz join baz.topGlarchez g where index(g) = 'A'" ).list();
 		s.createQuery( "select index(g) from Baz baz join baz.topGlarchez g" ).list();
 
 		assertTrue( s.createQuery( "from Baz baz left join baz.stringSet" ).list().size()==3 );
 		baz = (Baz) s.createQuery( "from Baz baz join baz.stringSet str where str='foo'" ).list().get(0);
 		assertTrue( !Hibernate.isInitialized( baz.getStringSet() ) );
 		baz = (Baz) s.createQuery( "from Baz baz left join fetch baz.stringSet" ).list().get(0);
 		assertTrue( Hibernate.isInitialized( baz.getStringSet() ) );
 		assertTrue( s.createQuery( "from Baz baz join baz.stringSet string where string='foo'" ).list().size()==1 );
 		assertTrue( s.createQuery( "from Baz baz inner join baz.components comp where comp.name='foo'" ).list().size()==1 );
 		//List bss = s.find("select baz, ss from Baz baz inner join baz.stringSet ss");
 		s.createQuery( "from Glarch g inner join g.fooComponents comp where comp.fee is not null" ).list();
 		s.createQuery( "from Glarch g inner join g.fooComponents comp join comp.fee fee where fee.count > 0" ).list();
 		s.createQuery( "from Glarch g inner join g.fooComponents comp where comp.fee.count is not null" ).list();
 
 		s.delete(baz);
 		s.delete( s.get(Glarch.class, gid) );
 		s.getTransaction().commit();
 		s.close();
 	}
 
 	@Test
 	public void testBatchLoad() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		Baz baz = new Baz();
 		SortedSet stringSet = new TreeSet();
 		stringSet.add("foo");
 		stringSet.add("bar");
 		Set fooSet = new HashSet();
 		for (int i=0; i<3; i++) {
 			Foo foo = new Foo();
 			s.save(foo);
 			fooSet.add(foo);
 		}
 		baz.setFooSet(fooSet);
 		baz.setStringSet(stringSet);
 		s.save(baz);
 		Baz baz2 = new Baz();
 		fooSet = new HashSet();
 		for (int i=0; i<2; i++) {
 			Foo foo = new Foo();
 			s.save(foo);
 			fooSet.add(foo);
 		}
 		baz2.setFooSet(fooSet);
 		s.save(baz2);
 		Baz baz3 = new Baz();
 		stringSet = new TreeSet();
 		stringSet.add("foo");
diff --git a/hibernate-core/src/test/java/org/hibernate/test/multitenancy/ConfigurationValidationTest.java b/hibernate-core/src/test/java/org/hibernate/test/multitenancy/ConfigurationValidationTest.java
index f258c62f57..b84e8e4435 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/multitenancy/ConfigurationValidationTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/multitenancy/ConfigurationValidationTest.java
@@ -1,55 +1,55 @@
 package org.hibernate.test.multitenancy;
 
 import org.junit.Test;
 
 import org.hibernate.ConnectionReleaseMode;
 import org.hibernate.MultiTenancyStrategy;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.jdbc.connections.spi.MultiTenantConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
 import org.hibernate.service.spi.ServiceException;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.testing.TestForIssue;
 import org.hibernate.testing.env.ConnectionProviderBuilder;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 /**
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 @TestForIssue(jiraKey = "HHH-7311")
 public class ConfigurationValidationTest extends BaseUnitTestCase {
 	@Test(expected = ServiceException.class)
 	public void testInvalidConnectionProvider() {
 		Configuration cfg = new Configuration();
 		cfg.getProperties().put( Environment.MULTI_TENANT, MultiTenancyStrategy.SCHEMA );
 		cfg.setProperty( Environment.MULTI_TENANT_CONNECTION_PROVIDER, "class.not.present.in.classpath" );
 		cfg.buildMappings();
-		ServiceRegistryImplementor serviceRegistry = (ServiceRegistryImplementor) new ServiceRegistryBuilder()
+		ServiceRegistryImplementor serviceRegistry = (ServiceRegistryImplementor) new StandardServiceRegistryBuilder()
 				.applySettings( cfg.getProperties() ).buildServiceRegistry();
 		cfg.buildSessionFactory( serviceRegistry );
 	}
 
 	@Test
 	public void testReleaseMode() {
 		Configuration cfg = new Configuration();
 		cfg.getProperties().put( Environment.MULTI_TENANT, MultiTenancyStrategy.SCHEMA );
 		cfg.getProperties().put( Environment.RELEASE_CONNECTIONS, ConnectionReleaseMode.AFTER_STATEMENT.name() );
 		cfg.buildMappings();
 
-		ServiceRegistryImplementor serviceRegistry = (ServiceRegistryImplementor) new ServiceRegistryBuilder()
+		ServiceRegistryImplementor serviceRegistry = (ServiceRegistryImplementor) new StandardServiceRegistryBuilder()
 				.applySettings( cfg.getProperties() )
 				.addService(
 						MultiTenantConnectionProvider.class,
 						new TestingConnectionProvider(
 								new TestingConnectionProvider.NamedConnectionProviderPair(
 										"acme",
 										ConnectionProviderBuilder.buildConnectionProvider( "acme" )
 								)
 						)
 				)
 				.buildServiceRegistry();
 
 		cfg.buildSessionFactory( serviceRegistry );
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/multitenancy/TestingConnectionProvider.java b/hibernate-core/src/test/java/org/hibernate/test/multitenancy/TestingConnectionProvider.java
index 64d78abae8..8ca54675f3 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/multitenancy/TestingConnectionProvider.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/multitenancy/TestingConnectionProvider.java
@@ -1,69 +1,69 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.multitenancy;
 
 import java.util.HashMap;
 import java.util.Map;
 
-import org.hibernate.service.jdbc.connections.spi.AbstractMultiTenantConnectionProvider;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.AbstractMultiTenantConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 
 /**
  * @author Steve Ebersole
  */
 public class TestingConnectionProvider extends AbstractMultiTenantConnectionProvider {
 	private Map<String,ConnectionProvider> connectionProviderMap;
 
 	public TestingConnectionProvider(Map<String, ConnectionProvider> connectionProviderMap) {
 		this.connectionProviderMap = connectionProviderMap;
 	}
 
 	public TestingConnectionProvider(NamedConnectionProviderPair... pairs) {
 		Map<String,ConnectionProvider> map = new HashMap<String, ConnectionProvider>();
 		for ( NamedConnectionProviderPair pair : pairs ) {
 			map.put( pair.name, pair.connectionProvider );
 		}
 		this.connectionProviderMap = map;
 	}
 
 	@Override
 	protected ConnectionProvider getAnyConnectionProvider() {
 		return connectionProviderMap.values().iterator().next();
 	}
 
 	@Override
 	protected ConnectionProvider selectConnectionProvider(String tenantIdentifier) {
 		return connectionProviderMap.get( tenantIdentifier );
 	}
 
 	public static class NamedConnectionProviderPair {
 		private final String name;
 		private final ConnectionProvider connectionProvider;
 
 		public NamedConnectionProviderPair(String name, ConnectionProvider connectionProvider) {
 			this.name = name;
 			this.connectionProvider = connectionProvider;
 		}
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/multitenancy/schema/SchemaBasedMultiTenancyTest.java b/hibernate-core/src/test/java/org/hibernate/test/multitenancy/schema/SchemaBasedMultiTenancyTest.java
index d20f253416..5ddcfc1837 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/multitenancy/schema/SchemaBasedMultiTenancyTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/multitenancy/schema/SchemaBasedMultiTenancyTest.java
@@ -1,300 +1,300 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.multitenancy.schema;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 
 import org.junit.After;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.HibernateException;
 import org.hibernate.MultiTenancyStrategy;
 import org.hibernate.Session;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.mapping.RootClass;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.jdbc.connections.internal.DriverManagerConnectionProviderImpl;
-import org.hibernate.service.jdbc.connections.spi.AbstractMultiTenantConnectionProvider;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
-import org.hibernate.service.jdbc.connections.spi.MultiTenantConnectionProvider;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
+import org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl;
+import org.hibernate.engine.jdbc.connections.spi.AbstractMultiTenantConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.MultiTenantConnectionProvider;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.testing.cache.CachingRegionFactory;
 import org.hibernate.testing.env.ConnectionProviderBuilder;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 import org.hibernate.tool.hbm2ddl.ConnectionHelper;
 import org.hibernate.tool.hbm2ddl.SchemaExport;
 
 /**
  * @author Steve Ebersole
  */
 public class SchemaBasedMultiTenancyTest extends BaseUnitTestCase {
 	private DriverManagerConnectionProviderImpl acmeProvider;
 	private DriverManagerConnectionProviderImpl jbossProvider;
 
 	private ServiceRegistryImplementor serviceRegistry;
 
 	protected SessionFactoryImplementor sessionFactory;
 
 	@Before
 	public void setUp() {
 		AbstractMultiTenantConnectionProvider multiTenantConnectionProvider = buildMultiTenantConnectionProvider();
 		Configuration cfg = buildConfiguration();
 
-		serviceRegistry = (ServiceRegistryImplementor) new ServiceRegistryBuilder()
+		serviceRegistry = (ServiceRegistryImplementor) new StandardServiceRegistryBuilder()
 				.applySettings( cfg.getProperties() )
 				.addService( MultiTenantConnectionProvider.class, multiTenantConnectionProvider )
 				.buildServiceRegistry();
 
 		sessionFactory = (SessionFactoryImplementor) cfg.buildSessionFactory( serviceRegistry );
 	}
 
 	protected Configuration buildConfiguration() {
 		Configuration cfg = new Configuration();
 		cfg.getProperties().put( Environment.MULTI_TENANT, MultiTenancyStrategy.SCHEMA );
 		cfg.setProperty( Environment.CACHE_REGION_FACTORY, CachingRegionFactory.class.getName() );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 		cfg.addAnnotatedClass( Customer.class );
 
 		cfg.buildMappings();
 		RootClass meta = (RootClass) cfg.getClassMapping( Customer.class.getName() );
 		meta.setCacheConcurrencyStrategy( "read-write" );
 
 		// do the acme export
 		new SchemaExport(
 				new ConnectionHelper() {
 					private Connection connection;
 					@Override
 					public void prepare(boolean needsAutoCommit) throws SQLException {
 						connection = acmeProvider.getConnection();
 					}
 
 					@Override
 					public Connection getConnection() throws SQLException {
 						return connection;
 					}
 
 					@Override
 					public void release() throws SQLException {
 						acmeProvider.closeConnection( connection );
 					}
 				},
 				cfg.generateDropSchemaScript( ConnectionProviderBuilder.getCorrespondingDialect() ),
 				cfg.generateSchemaCreationScript( ConnectionProviderBuilder.getCorrespondingDialect() )
 		).execute(		 // so stupid...
 						   false,	 // do not script the export (write it to file)
 						   true,	 // do run it against the database
 						   false,	 // do not *just* perform the drop
 						   false	// do not *just* perform the create
 		);
 
 		// do the jboss export
 		new SchemaExport(
 				new ConnectionHelper() {
 					private Connection connection;
 					@Override
 					public void prepare(boolean needsAutoCommit) throws SQLException {
 						connection = jbossProvider.getConnection();
 					}
 
 					@Override
 					public Connection getConnection() throws SQLException {
 						return connection;
 					}
 
 					@Override
 					public void release() throws SQLException {
 						jbossProvider.closeConnection( connection );
 					}
 				},
 				cfg.generateDropSchemaScript( ConnectionProviderBuilder.getCorrespondingDialect() ),
 				cfg.generateSchemaCreationScript( ConnectionProviderBuilder.getCorrespondingDialect() )
 		).execute( 		// so stupid...
 						   false, 	// do not script the export (write it to file)
 						   true, 	// do run it against the database
 						   false, 	// do not *just* perform the drop
 						   false	// do not *just* perform the create
 		);
 		return cfg;
 	}
 
 	private AbstractMultiTenantConnectionProvider buildMultiTenantConnectionProvider() {
 		acmeProvider = ConnectionProviderBuilder.buildConnectionProvider( "acme" );
 		jbossProvider = ConnectionProviderBuilder.buildConnectionProvider( "jboss" );
 		return new AbstractMultiTenantConnectionProvider() {
 			@Override
 			protected ConnectionProvider getAnyConnectionProvider() {
 				return acmeProvider;
 			}
 
 			@Override
 			protected ConnectionProvider selectConnectionProvider(String tenantIdentifier) {
 				if ( "acme".equals( tenantIdentifier ) ) {
 					return acmeProvider;
 				}
 				else if ( "jboss".equals( tenantIdentifier ) ) {
 					return jbossProvider;
 				}
 				throw new HibernateException( "Unknown tenant identifier" );
 			}
 		};
 	}
 
 	@After
 	public void tearDown() {
 		if ( sessionFactory != null ) {
 			sessionFactory.close();
 		}
 		if ( serviceRegistry != null ) {
 			serviceRegistry.destroy();
 		}
 		if ( jbossProvider != null ) {
 			jbossProvider.stop();
 		}
 		if ( acmeProvider != null ) {
 			acmeProvider.stop();
 		}
 	}
 
 	@Test
 	public void testBasicExpectedBehavior() {
 		Session session = getNewSession("jboss");
 		session.beginTransaction();
 		Customer steve = new Customer( 1L, "steve" );
 		session.save( steve );
 		session.getTransaction().commit();
 		session.close();
 
 		session = getNewSession("acme");
 		try {
 			session.beginTransaction();
 			Customer check = (Customer) session.get( Customer.class, steve.getId() );
 			Assert.assertNull( "tenancy not properly isolated", check );
 		}
 		finally {
 			session.getTransaction().commit();
 			session.close();
 		}
 
 		session = getNewSession("jboss");
 		session.beginTransaction();
 		session.delete( steve );
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	@Test
 	public void testSameIdentifiers() {
 		// create a customer 'steve' in jboss
 		Session session = getNewSession("jboss");
 		session.beginTransaction();
 		Customer steve = new Customer( 1L, "steve" );
 		session.save( steve );
 		session.getTransaction().commit();
 		session.close();
 
 		// now, create a customer 'john' in acme
 		session = getNewSession("acme");
 		session.beginTransaction();
 		Customer john = new Customer( 1L, "john" );
 		session.save( john );
 		session.getTransaction().commit();
 		session.close();
 
 		sessionFactory.getStatisticsImplementor().clear();
 
 		// make sure we get the correct people back, from cache
 		// first, jboss
 		{
 			session = getNewSession("jboss");
 			session.beginTransaction();
 			Customer customer = (Customer) session.load( Customer.class, 1L );
 			Assert.assertEquals( "steve", customer.getName() );
 			// also, make sure this came from second level
 			Assert.assertEquals( 1, sessionFactory.getStatisticsImplementor().getSecondLevelCacheHitCount() );
 			session.getTransaction().commit();
 			session.close();
 		}
 		sessionFactory.getStatisticsImplementor().clear();
 		// then, acme
 		{
 			session = getNewSession("acme");
 			session.beginTransaction();
 			Customer customer = (Customer) session.load( Customer.class, 1L );
 			Assert.assertEquals( "john", customer.getName() );
 			// also, make sure this came from second level
 			Assert.assertEquals( 1, sessionFactory.getStatisticsImplementor().getSecondLevelCacheHitCount() );
 			session.getTransaction().commit();
 			session.close();
 		}
 
 		// make sure the same works from datastore too
 		sessionFactory.getStatisticsImplementor().clear();
 		sessionFactory.getCache().evictEntityRegions();
 		// first jboss
 		{
 			session = getNewSession("jboss");
 			session.beginTransaction();
 			Customer customer = (Customer) session.load( Customer.class, 1L );
 			Assert.assertEquals( "steve", customer.getName() );
 			// also, make sure this came from second level
 			Assert.assertEquals( 0, sessionFactory.getStatisticsImplementor().getSecondLevelCacheHitCount() );
 			session.getTransaction().commit();
 			session.close();
 		}
 		sessionFactory.getStatisticsImplementor().clear();
 		// then, acme
 		{
 			session = getNewSession("acme");
 			session.beginTransaction();
 			Customer customer = (Customer) session.load( Customer.class, 1L );
 			Assert.assertEquals( "john", customer.getName() );
 			// also, make sure this came from second level
 			Assert.assertEquals( 0, sessionFactory.getStatisticsImplementor().getSecondLevelCacheHitCount() );
 			session.getTransaction().commit();
 			session.close();
 		}
 
 		session = getNewSession("jboss");
 		session.beginTransaction();
 		session.delete( steve );
 		session.getTransaction().commit();
 		session.close();
 
 		session = getNewSession("acme");
 		session.beginTransaction();
 		session.delete( john );
 		session.getTransaction().commit();
 		session.close();
 	}
 
 	protected Session getNewSession(String tenant) {
 		return sessionFactory.withOptions().tenantIdentifier( tenant ).openSession();
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/service/ClassLoaderServiceImplTest.java b/hibernate-core/src/test/java/org/hibernate/test/service/ClassLoaderServiceImplTest.java
index 1ada3caec3..7609a5ffc8 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/service/ClassLoaderServiceImplTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/service/ClassLoaderServiceImplTest.java
@@ -1,70 +1,70 @@
 package org.hibernate.test.service;
 
-import org.hibernate.service.classloading.internal.ClassLoaderServiceImpl;
+import org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl;
 import org.junit.Assert;
 import org.junit.Test;
 
 import javax.persistence.Entity;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 
 /**
  * @author Artem V. Navrotskiy
  * @author Emmanuel Bernard <emmanuel@hibernate.org>
  */
 public class ClassLoaderServiceImplTest {
     /**
      * Test for bug: HHH-7084
      */
     @Test
     public void testSystemClassLoaderNotOverriding() throws IOException, ClassNotFoundException {
         Class<?> testClass = Entity.class;
 
         // Check that class is accessible by SystemClassLoader.
         ClassLoader.getSystemClassLoader().loadClass(testClass.getName());
 
         // Create ClassLoader with overridden class.
         TestClassLoader anotherLoader = new TestClassLoader();
         anotherLoader.overrideClass(testClass);
         Class<?> anotherClass = anotherLoader.loadClass(testClass.getName());
         Assert.assertNotSame( testClass, anotherClass );
 
         // Check ClassLoaderServiceImpl().classForName() returns correct class (not from current ClassLoader).
         ClassLoaderServiceImpl loaderService = new ClassLoaderServiceImpl(anotherLoader);
         Class<Object> objectClass = loaderService.classForName(testClass.getName());
         Assert.assertSame("Should not return class loaded from the parent classloader of ClassLoaderServiceImpl",
 				objectClass, anotherClass);
     }
 
     private static class TestClassLoader extends ClassLoader {
         /**
          * Reloading class from binary file.
          *
          * @param originalClass Original class.
          * @throws IOException .
          */
         public void overrideClass(final Class<?> originalClass) throws IOException {
             String originalPath = "/" + originalClass.getName().replaceAll("\\.", "/") + ".class";
             InputStream inputStream = originalClass.getResourceAsStream(originalPath);
             Assert.assertNotNull(inputStream);
             try {
                 byte[] data = toByteArray( inputStream );
                 defineClass(originalClass.getName(), data, 0, data.length);
             } finally {
                 inputStream.close();
             }
         }
 
 		private byte[] toByteArray(InputStream inputStream) throws IOException {
 			ByteArrayOutputStream out = new ByteArrayOutputStream();
 			int read;
 			byte[] slice = new byte[2000];
 			while ( (read = inputStream.read(slice, 0, slice.length) ) != -1) {
 			  out.write( slice, 0, read );
 			}
 			out.flush();
 			return out.toByteArray();
 		}
     }
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/service/ServiceBootstrappingTest.java b/hibernate-core/src/test/java/org/hibernate/test/service/ServiceBootstrappingTest.java
index 12b5a287b7..ef7f279192 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/service/ServiceBootstrappingTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/service/ServiceBootstrappingTest.java
@@ -1,104 +1,104 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.service;
 
 import java.util.Properties;
 
 import org.junit.Test;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.engine.jdbc.spi.JdbcServices;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
-import org.hibernate.service.jdbc.connections.internal.DriverManagerConnectionProviderImpl;
-import org.hibernate.service.jdbc.connections.internal.UserSuppliedConnectionProviderImpl;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
+import org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl;
+import org.hibernate.engine.jdbc.connections.internal.UserSuppliedConnectionProviderImpl;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.testing.env.ConnectionProviderBuilder;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 /**
  * @author Steve Ebersole
  */
 public class ServiceBootstrappingTest extends BaseUnitTestCase {
 	@Test
 	public void testBasicBuild() {
-		StandardServiceRegistryImpl serviceRegistry = (StandardServiceRegistryImpl) new ServiceRegistryBuilder()
+		StandardServiceRegistryImpl serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder()
 				.applySettings( ConnectionProviderBuilder.getConnectionProviderProperties() )
 				.buildServiceRegistry();
 		JdbcServices jdbcServices = serviceRegistry.getService( JdbcServices.class );
 
 		assertTrue( jdbcServices.getDialect() instanceof H2Dialect );
 		assertTrue( jdbcServices.getConnectionProvider().isUnwrappableAs( DriverManagerConnectionProviderImpl.class ) );
 		assertFalse( jdbcServices.getSqlStatementLogger().isLogToStdout() );
 
 		serviceRegistry.destroy();
 	}
 
 	@Test
 	public void testBuildWithLogging() {
 		Properties props = ConnectionProviderBuilder.getConnectionProviderProperties();
 		props.put( Environment.SHOW_SQL, "true" );
 
-		StandardServiceRegistryImpl serviceRegistry = (StandardServiceRegistryImpl) new ServiceRegistryBuilder()
+		StandardServiceRegistryImpl serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder()
 				.applySettings( props )
 				.buildServiceRegistry();
 
 		JdbcServices jdbcServices = serviceRegistry.getService( JdbcServices.class );
 
 		assertTrue( jdbcServices.getDialect() instanceof H2Dialect );
 		assertTrue( jdbcServices.getConnectionProvider().isUnwrappableAs( DriverManagerConnectionProviderImpl.class ) );
 		assertTrue( jdbcServices.getSqlStatementLogger().isLogToStdout() );
 
 		serviceRegistry.destroy();
 	}
 
 	@Test
 	public void testBuildWithServiceOverride() {
-		StandardServiceRegistryImpl serviceRegistry = (StandardServiceRegistryImpl) new ServiceRegistryBuilder()
+		StandardServiceRegistryImpl serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder()
 				.applySettings( ConnectionProviderBuilder.getConnectionProviderProperties() )
 				.buildServiceRegistry();
 		JdbcServices jdbcServices = serviceRegistry.getService( JdbcServices.class );
 
 		assertTrue( jdbcServices.getDialect() instanceof H2Dialect );
 		assertTrue( jdbcServices.getConnectionProvider().isUnwrappableAs( DriverManagerConnectionProviderImpl.class ) );
 
 		Properties props = ConnectionProviderBuilder.getConnectionProviderProperties();
 		props.setProperty( Environment.DIALECT, H2Dialect.class.getName() );
 
-		serviceRegistry = (StandardServiceRegistryImpl) new ServiceRegistryBuilder()
+		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder()
 				.applySettings( props )
 				.addService( ConnectionProvider.class, new UserSuppliedConnectionProviderImpl() )
 				.buildServiceRegistry();
 		jdbcServices = serviceRegistry.getService( JdbcServices.class );
 
 		assertTrue( jdbcServices.getDialect() instanceof H2Dialect );
 		assertTrue( jdbcServices.getConnectionProvider().isUnwrappableAs( UserSuppliedConnectionProviderImpl.class ) );
 
 		serviceRegistry.destroy();
 	}
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/transaction/jdbc/TestExpectedUsage.java b/hibernate-core/src/test/java/org/hibernate/test/transaction/jdbc/TestExpectedUsage.java
index fcd64f33b0..accc188c0a 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/transaction/jdbc/TestExpectedUsage.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/transaction/jdbc/TestExpectedUsage.java
@@ -1,141 +1,141 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.transaction.jdbc;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.sql.Statement;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.ConnectionReleaseMode;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
 import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
 import org.hibernate.engine.transaction.spi.TransactionContext;
 import org.hibernate.engine.transaction.spi.TransactionImplementor;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.test.common.JournalingTransactionObserver;
 import org.hibernate.test.common.TransactionContextImpl;
 import org.hibernate.test.common.TransactionEnvironmentImpl;
 import org.hibernate.testing.env.ConnectionProviderBuilder;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * @author Steve Ebersole
  */
 public class TestExpectedUsage extends BaseUnitTestCase {
 	private StandardServiceRegistryImpl serviceRegistry;
 
 	@Before
 	public void setUp() throws Exception {
-		serviceRegistry = (StandardServiceRegistryImpl) new ServiceRegistryBuilder()
+		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder()
 				.applySettings( ConnectionProviderBuilder.getConnectionProviderProperties() )
 				.buildServiceRegistry();
 	}
 
 	@After
 	public void tearDown() throws Exception {
 		serviceRegistry.destroy();
 	}
 
 	@Test
 	public void testBasicUsage() {
 		final TransactionContext transactionContext = new TransactionContextImpl( new TransactionEnvironmentImpl( serviceRegistry ) ) {
 			@Override
 			public ConnectionReleaseMode getConnectionReleaseMode() {
 				return ConnectionReleaseMode.AFTER_TRANSACTION;
 			}
 		};
 
 		TransactionCoordinatorImpl transactionCoordinator = new TransactionCoordinatorImpl( null, transactionContext );
 		JournalingTransactionObserver observer = new JournalingTransactionObserver();
 		transactionCoordinator.addObserver( observer );
 
 		LogicalConnectionImplementor logicalConnection = transactionCoordinator.getJdbcCoordinator().getLogicalConnection();
 		Connection connection = logicalConnection.getShareableConnectionProxy();
 
 		// set up some tables to use
 		try {
 			Statement statement = connection.createStatement();
 			statement.execute( "drop table SANDBOX_JDBC_TST if exists" );
 			statement.execute( "create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )" );
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			assertTrue( logicalConnection.isPhysicallyConnected() );
 			statement.close();
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			assertTrue( logicalConnection.isPhysicallyConnected() ); // after_transaction specified
 		}
 		catch ( SQLException sqle ) {
 			fail( "incorrect exception type : SQLException" );
 		}
 
 		// ok, now we can get down to it...
 		TransactionImplementor txn = transactionCoordinator.getTransaction();  // same as Session#getTransaction
 		txn.begin();
 		assertEquals( 1, observer.getBegins() );
 		try {
 			PreparedStatement ps = connection.prepareStatement( "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )" );
 			ps.setLong( 1, 1 );
 			ps.setString( 2, "name" );
 			ps.execute();
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			ps.close();
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 
 			ps = connection.prepareStatement( "select * from SANDBOX_JDBC_TST" );
 			ps.executeQuery();
 			connection.prepareStatement( "delete from SANDBOX_JDBC_TST" ).execute();
 			// lets forget to close these...
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 
 			// and commit the transaction...
 			txn.commit();
 
 			// we should now have:
 			//		1) no resources because of after_transaction release mode
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			//		2) non-physically connected logical connection, again because of after_transaction release mode
 			assertFalse( logicalConnection.isPhysicallyConnected() );
 			//		3) transaction observer callbacks
 			assertEquals( 1, observer.getBeforeCompletions() );
 			assertEquals( 1, observer.getAfterCompletions() );
 		}
 		catch ( SQLException sqle ) {
 			fail( "incorrect exception type : SQLException" );
 		}
 		finally {
 			logicalConnection.close();
 		}
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/transaction/jta/BasicDrivingTest.java b/hibernate-core/src/test/java/org/hibernate/test/transaction/jta/BasicDrivingTest.java
index 397ef9546c..4230cba476 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/transaction/jta/BasicDrivingTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/transaction/jta/BasicDrivingTest.java
@@ -1,163 +1,163 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.transaction.jta;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
 import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
 import org.hibernate.engine.transaction.internal.jta.JtaTransactionFactory;
 import org.hibernate.engine.transaction.spi.TransactionContext;
 import org.hibernate.engine.transaction.spi.TransactionImplementor;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.test.common.JournalingTransactionObserver;
 import org.hibernate.test.common.TransactionContextImpl;
 import org.hibernate.test.common.TransactionEnvironmentImpl;
 import org.hibernate.testing.env.ConnectionProviderBuilder;
 import org.hibernate.testing.jta.TestingJtaBootstrap;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * Testing transaction handling when the JTA transaction facade is the driver.
  *
  * @author Steve Ebersole
  */
 public class BasicDrivingTest extends BaseUnitTestCase {
 	private StandardServiceRegistryImpl serviceRegistry;
 
 	@Before
 	@SuppressWarnings( {"unchecked"})
 	public void setUp() throws Exception {
 		Map configValues = new HashMap();
 		configValues.putAll( ConnectionProviderBuilder.getConnectionProviderProperties() );
 		configValues.put( Environment.TRANSACTION_STRATEGY, JtaTransactionFactory.class.getName() );
 		TestingJtaBootstrap.prepare( configValues );
-		serviceRegistry = (StandardServiceRegistryImpl) new ServiceRegistryBuilder()
+		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder()
 				.applySettings( configValues )
 				.buildServiceRegistry();
 	}
 
 	@After
 	public void tearDown() throws Exception {
 		serviceRegistry.destroy();
 	}
 
 	@Test
 	public void testBasicUsage() throws Throwable {
 		final TransactionContext transactionContext = new TransactionContextImpl( new TransactionEnvironmentImpl( serviceRegistry ) );
 
 		TransactionCoordinatorImpl transactionCoordinator = new TransactionCoordinatorImpl( null, transactionContext );
 		JournalingTransactionObserver observer = new JournalingTransactionObserver();
 		transactionCoordinator.addObserver( observer );
 
 		LogicalConnectionImplementor logicalConnection = transactionCoordinator.getJdbcCoordinator().getLogicalConnection();
 		Connection connection = logicalConnection.getShareableConnectionProxy();
 
 		// set up some tables to use
 		try {
 			Statement statement = connection.createStatement();
 			statement.execute( "drop table SANDBOX_JDBC_TST if exists" );
 			statement.execute( "create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )" );
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			assertTrue( logicalConnection.isPhysicallyConnected() );
 			statement.close();
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			assertFalse( logicalConnection.isPhysicallyConnected() ); // after_statement specified
 		}
 		catch ( SQLException sqle ) {
 			fail( "incorrect exception type : SQLException" );
 		}
 
 		// ok, now we can get down to it...
 		TransactionImplementor txn = transactionCoordinator.getTransaction();  // same as Session#getTransaction
 		txn.begin();
 		assertEquals( 1, observer.getBegins() );
 		assertTrue( txn.isInitiator() );
 		try {
 			PreparedStatement ps = connection.prepareStatement( "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )" );
 			ps.setLong( 1, 1 );
 			ps.setString( 2, "name" );
 			ps.execute();
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			ps.close();
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 
 			ps = connection.prepareStatement( "select * from SANDBOX_JDBC_TST" );
 			ps.executeQuery();
 			connection.prepareStatement( "delete from SANDBOX_JDBC_TST" ).execute();
 			// lets forget to close these...
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			assertTrue( logicalConnection.isPhysicallyConnected() );
 
 			// and commit the transaction...
 			txn.commit();
 
 			// we should now have:
 			//		1) no resources because of after_transaction release mode
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			//		2) non-physically connected logical connection, again because of after_transaction release mode
 			assertFalse( logicalConnection.isPhysicallyConnected() );
 			//		3) transaction observer callbacks
 			assertEquals( 1, observer.getBeforeCompletions() );
 			assertEquals( 1, observer.getAfterCompletions() );
 		}
 		catch ( SQLException sqle ) {
 			try {
 				serviceRegistry.getService( JtaPlatform.class ).retrieveTransactionManager().rollback();
 			}
 			catch (Exception ignore) {
 			}
 			fail( "incorrect exception type : SQLException" );
 		}
 		catch (Throwable reThrowable) {
 			try {
 				serviceRegistry.getService( JtaPlatform.class ).retrieveTransactionManager().rollback();
 			}
 			catch (Exception ignore) {
 			}
 			throw reThrowable;
 		}
 		finally {
 			logicalConnection.close();
 		}
 	}
 
 }
diff --git a/hibernate-core/src/test/java/org/hibernate/test/transaction/jta/ManagedDrivingTest.java b/hibernate-core/src/test/java/org/hibernate/test/transaction/jta/ManagedDrivingTest.java
index c983b85fd2..0524656987 100644
--- a/hibernate-core/src/test/java/org/hibernate/test/transaction/jta/ManagedDrivingTest.java
+++ b/hibernate-core/src/test/java/org/hibernate/test/transaction/jta/ManagedDrivingTest.java
@@ -1,178 +1,178 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.transaction.jta;
 
 import java.sql.Connection;
 import java.sql.PreparedStatement;
 import java.sql.SQLException;
 import java.sql.Statement;
 import java.util.HashMap;
 import java.util.Map;
 import javax.transaction.TransactionManager;
 
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.ConnectionReleaseMode;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.jdbc.spi.LogicalConnectionImplementor;
 import org.hibernate.engine.transaction.internal.TransactionCoordinatorImpl;
 import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
 import org.hibernate.engine.transaction.spi.TransactionContext;
 import org.hibernate.engine.transaction.spi.TransactionImplementor;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.test.common.JournalingTransactionObserver;
 import org.hibernate.test.common.TransactionContextImpl;
 import org.hibernate.test.common.TransactionEnvironmentImpl;
 import org.hibernate.testing.jta.TestingJtaBootstrap;
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * Testing transaction facade handling when the transaction is being driven by something other than the facade.
  *
  * @author Steve Ebersole
  */
 public class ManagedDrivingTest extends BaseUnitTestCase {
 	private StandardServiceRegistryImpl serviceRegistry;
 
 	@Before
 	@SuppressWarnings( {"unchecked"})
 	public void setUp() throws Exception {
 		Map configValues = new HashMap();
 		TestingJtaBootstrap.prepare( configValues );
 		configValues.put( Environment.TRANSACTION_STRATEGY, CMTTransactionFactory.class.getName() );
 
-		serviceRegistry = (StandardServiceRegistryImpl) new ServiceRegistryBuilder()
+		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder()
 				.applySettings( configValues )
 				.buildServiceRegistry();
 	}
 
 	@After
 	public void tearDown() throws Exception {
 		serviceRegistry.destroy();
 	}
 
 	@Test
 	public void testBasicUsage() throws Throwable {
 		final TransactionContext transactionContext = new TransactionContextImpl( new TransactionEnvironmentImpl( serviceRegistry ) ) {
 			@Override
 			public ConnectionReleaseMode getConnectionReleaseMode() {
 				return ConnectionReleaseMode.AFTER_STATEMENT;
 			}
 		};
 
 		final TransactionCoordinatorImpl transactionCoordinator = new TransactionCoordinatorImpl( null, transactionContext );
 		final JournalingTransactionObserver transactionObserver = new JournalingTransactionObserver();
 		transactionCoordinator.addObserver( transactionObserver );
 
 		final LogicalConnectionImplementor logicalConnection = transactionCoordinator.getJdbcCoordinator().getLogicalConnection();
 		Connection connection = logicalConnection.getShareableConnectionProxy();
 
 		// set up some tables to use
 		try {
 			Statement statement = connection.createStatement();
 			statement.execute( "drop table SANDBOX_JDBC_TST if exists" );
 			statement.execute( "create table SANDBOX_JDBC_TST ( ID integer, NAME varchar(100) )" );
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			assertTrue( logicalConnection.isPhysicallyConnected() );
 			statement.close();
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			assertFalse( logicalConnection.isPhysicallyConnected() ); // after_statement specified
 		}
 		catch ( SQLException sqle ) {
 			fail( "incorrect exception type : SQLException" );
 		}
 
 		JtaPlatform instance = serviceRegistry.getService( JtaPlatform.class );
 		TransactionManager transactionManager = instance.retrieveTransactionManager();
 
 		// start the cmt
 		transactionManager.begin();
 
 		// ok, now we can get down to it...
 		TransactionImplementor txn = transactionCoordinator.getTransaction();  // same as Session#getTransaction
 		txn.begin();
 		assertEquals( 1, transactionObserver.getBegins() );
 		assertFalse( txn.isInitiator() );
 		connection = logicalConnection.getShareableConnectionProxy();
 		try {
 			PreparedStatement ps = connection.prepareStatement( "insert into SANDBOX_JDBC_TST( ID, NAME ) values ( ?, ? )" );
 			ps.setLong( 1, 1 );
 			ps.setString( 2, "name" );
 			ps.execute();
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			ps.close();
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 
 			ps = connection.prepareStatement( "select * from SANDBOX_JDBC_TST" );
 			ps.executeQuery();
 			connection.prepareStatement( "delete from SANDBOX_JDBC_TST" ).execute();
 			// lets forget to close these...
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			assertTrue( logicalConnection.isPhysicallyConnected() );
 
 			// and commit the transaction...
 			txn.commit();
 
 			// since txn is not a driver, nothing should have changed...
 			assertTrue( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			assertTrue( logicalConnection.isPhysicallyConnected() );
 			assertEquals( 0, transactionObserver.getBeforeCompletions() );
 			assertEquals( 0, transactionObserver.getAfterCompletions() );
 
 			transactionManager.commit();
 			assertFalse( logicalConnection.getResourceRegistry().hasRegisteredResources() );
 			assertFalse( logicalConnection.isPhysicallyConnected() );
 			assertEquals( 1, transactionObserver.getBeforeCompletions() );
 			assertEquals( 1, transactionObserver.getAfterCompletions() );
 		}
 		catch ( SQLException sqle ) {
 			try {
 				transactionManager.rollback();
 			}
 			catch (Exception ignore) {
 			}
 			fail( "incorrect exception type : SQLException" );
 		}
 		catch (Throwable reThrowable) {
 			try {
 				transactionManager.rollback();
 			}
 			catch (Exception ignore) {
 			}
 			throw reThrowable;
 		}
 		finally {
 			logicalConnection.close();
 		}
 	}
 }
diff --git a/hibernate-ehcache/src/main/java/org/hibernate/cache/ehcache/AbstractEhcacheRegionFactory.java b/hibernate-ehcache/src/main/java/org/hibernate/cache/ehcache/AbstractEhcacheRegionFactory.java
index c0e3256ed8..9b9a28c2ec 100644
--- a/hibernate-ehcache/src/main/java/org/hibernate/cache/ehcache/AbstractEhcacheRegionFactory.java
+++ b/hibernate-ehcache/src/main/java/org/hibernate/cache/ehcache/AbstractEhcacheRegionFactory.java
@@ -1,236 +1,236 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.cache.ehcache;
 
 import java.net.URL;
 import java.util.Properties;
 
 import net.sf.ehcache.CacheManager;
 import net.sf.ehcache.Ehcache;
 import net.sf.ehcache.util.ClassLoaderUtil;
 import org.jboss.logging.Logger;
 
 import org.hibernate.cache.CacheException;
 import org.hibernate.cache.ehcache.internal.nonstop.NonstopAccessStrategyFactory;
 import org.hibernate.cache.ehcache.internal.regions.EhcacheCollectionRegion;
 import org.hibernate.cache.ehcache.internal.regions.EhcacheEntityRegion;
 import org.hibernate.cache.ehcache.internal.regions.EhcacheNaturalIdRegion;
 import org.hibernate.cache.ehcache.internal.regions.EhcacheQueryResultsRegion;
 import org.hibernate.cache.ehcache.internal.regions.EhcacheTimestampsRegion;
 import org.hibernate.cache.ehcache.internal.strategy.EhcacheAccessStrategyFactory;
 import org.hibernate.cache.ehcache.internal.strategy.EhcacheAccessStrategyFactoryImpl;
 import org.hibernate.cache.ehcache.internal.util.HibernateUtil;
 import org.hibernate.cache.ehcache.management.impl.ProviderMBeanRegistrationHelper;
 import org.hibernate.cache.spi.CacheDataDescription;
 import org.hibernate.cache.spi.CollectionRegion;
 import org.hibernate.cache.spi.EntityRegion;
 import org.hibernate.cache.spi.NaturalIdRegion;
 import org.hibernate.cache.spi.QueryResultsRegion;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cache.spi.TimestampsRegion;
 import org.hibernate.cache.spi.access.AccessType;
 import org.hibernate.cfg.Settings;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.service.spi.InjectService;
 
 /**
  * Abstract implementation of an Ehcache specific RegionFactory.
  *
  * @author Chris Dennis
  * @author Greg Luck
  * @author Emmanuel Bernard
  * @author Abhishek Sanoujam
  * @author Alex Snaps
  */
 abstract class AbstractEhcacheRegionFactory implements RegionFactory {
 
     /**
      * The Hibernate system property specifying the location of the ehcache configuration file name.
      * <p/>
      * If not set, ehcache.xml will be looked for in the root of the classpath.
      * <p/>
      * If set to say ehcache-1.xml, ehcache-1.xml will be looked for in the root of the classpath.
      */
     public static final String NET_SF_EHCACHE_CONFIGURATION_RESOURCE_NAME = "net.sf.ehcache.configurationResourceName";
 
     private static final EhCacheMessageLogger LOG = Logger.getMessageLogger(
             EhCacheMessageLogger.class,
             AbstractEhcacheRegionFactory.class.getName()
     );
 
     /**
      * MBean registration helper class instance for Ehcache Hibernate MBeans.
      */
     protected final ProviderMBeanRegistrationHelper mbeanRegistrationHelper = new ProviderMBeanRegistrationHelper();
 
     /**
      * Ehcache CacheManager that supplied Ehcache instances for this Hibernate RegionFactory.
      */
     protected volatile CacheManager manager;
 
     /**
      * Settings object for the Hibernate persistence unit.
      */
     protected Settings settings;
 
     /**
      * {@link EhcacheAccessStrategyFactory} for creating various access strategies
      */
     protected final EhcacheAccessStrategyFactory accessStrategyFactory =
             new NonstopAccessStrategyFactory( new EhcacheAccessStrategyFactoryImpl() );
 
     /**
      * Whether to optimize for minimals puts or minimal gets.
      * <p/>
      * Indicates whether when operating in non-strict read/write or read-only mode
      * Hibernate should optimize the access patterns for minimal puts or minimal gets.
      * In Ehcache we default to minimal puts since this should have minimal to no
      * affect on unclustered users, and has great benefit for clustered users.
      * <p/>
      * This setting can be overridden by setting the "hibernate.cache.use_minimal_puts"
      * property in the Hibernate configuration.
      *
      * @return true, optimize for minimal puts
      */
     public boolean isMinimalPutsEnabledByDefault() {
         return true;
     }
 
     /**
      * {@inheritDoc}
      */
     public long nextTimestamp() {
         return net.sf.ehcache.util.Timestamper.next();
     }
 
     /**
      * {@inheritDoc}
      */
     public EntityRegion buildEntityRegion(String regionName, Properties properties, CacheDataDescription metadata)
             throws CacheException {
         return new EhcacheEntityRegion( accessStrategyFactory, getCache( regionName ), settings, metadata, properties );
     }
     
     @Override
     public NaturalIdRegion buildNaturalIdRegion(String regionName, Properties properties, CacheDataDescription metadata)
             throws CacheException {
         return new EhcacheNaturalIdRegion( accessStrategyFactory, getCache( regionName ), settings, metadata, properties );
     }
 
     /**
      * {@inheritDoc}
      */
     public CollectionRegion buildCollectionRegion(String regionName, Properties properties, CacheDataDescription metadata)
             throws CacheException {
         return new EhcacheCollectionRegion(
                 accessStrategyFactory,
                 getCache( regionName ),
                 settings,
                 metadata,
                 properties
         );
     }
 
     /**
      * {@inheritDoc}
      */
     public QueryResultsRegion buildQueryResultsRegion(String regionName, Properties properties) throws CacheException {
         return new EhcacheQueryResultsRegion( accessStrategyFactory, getCache( regionName ), properties );
     }
 
     @InjectService
     public void setClassLoaderService(ClassLoaderService classLoaderService) {
         this.classLoaderService = classLoaderService;
     }
 
     private ClassLoaderService classLoaderService;
 
     /**
      * {@inheritDoc}
      */
     public TimestampsRegion buildTimestampsRegion(String regionName, Properties properties) throws CacheException {
         return new EhcacheTimestampsRegion( accessStrategyFactory, getCache( regionName ), properties );
     }
 
     private Ehcache getCache(String name) throws CacheException {
         try {
             Ehcache cache = manager.getEhcache( name );
             if ( cache == null ) {
                 LOG.unableToFindEhCacheConfiguration( name );
                 manager.addCache( name );
                 cache = manager.getEhcache( name );
                 LOG.debug( "started EHCache region: " + name );
             }
             HibernateUtil.validateEhcache( cache );
             return cache;
         }
         catch ( net.sf.ehcache.CacheException e ) {
             throw new CacheException( e );
         }
 
     }
 
     /**
      * Load a resource from the classpath.
      */
     protected URL loadResource(String configurationResourceName) {
         URL url = null;
         if ( classLoaderService != null ) {
             url = classLoaderService.locateResource( configurationResourceName );
         }
         if ( url == null ) {
             ClassLoader standardClassloader = ClassLoaderUtil.getStandardClassLoader();
             if ( standardClassloader != null ) {
                 url = standardClassloader.getResource( configurationResourceName );
             }
             if ( url == null ) {
                 url = AbstractEhcacheRegionFactory.class.getResource( configurationResourceName );
             }
         }
         if ( LOG.isDebugEnabled() ) {
             LOG.debugf(
                     "Creating EhCacheRegionFactory from a specified resource: %s.  Resolved to URL: %s",
                     configurationResourceName,
                     url
             );
         }
         if ( url == null ) {
 
             LOG.unableToLoadConfiguration( configurationResourceName );
         }
         return url;
     }
 
     /**
      * Default access-type used when the configured using JPA 2.0 config.  JPA 2.0 allows <code>@Cacheable(true)</code> to be attached to an
      * entity without any access type or usage qualification.
      * <p/>
      * We are conservative here in specifying {@link AccessType#READ_WRITE} so as to follow the mantra of "do no harm".
      * <p/>
      * This is a Hibernate 3.5 method.
      */
     public AccessType getDefaultAccessType() {
         return AccessType.READ_WRITE;
     }
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/EntityManagerFactoryBuilderImpl.java b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/EntityManagerFactoryBuilderImpl.java
index 7518266934..8c10ee5c81 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/EntityManagerFactoryBuilderImpl.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/EntityManagerFactoryBuilderImpl.java
@@ -1,1278 +1,1278 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jpa.boot.internal;
 
 import javax.persistence.AttributeConverter;
 import javax.persistence.Converter;
 import javax.persistence.Embeddable;
 import javax.persistence.Entity;
 import javax.persistence.EntityManagerFactory;
 import javax.persistence.EntityNotFoundException;
 import javax.persistence.MappedSuperclass;
 import javax.persistence.PersistenceException;
 import javax.persistence.spi.PersistenceUnitTransactionType;
 import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.Serializable;
 import java.lang.annotation.Annotation;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 import java.util.Set;
 import java.util.StringTokenizer;
 
 import org.jboss.jandex.AnnotationInstance;
 import org.jboss.jandex.ClassInfo;
 import org.jboss.jandex.CompositeIndex;
 import org.jboss.jandex.DotName;
 import org.jboss.jandex.Index;
 import org.jboss.jandex.IndexView;
 import org.jboss.jandex.Indexer;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.Interceptor;
 import org.hibernate.MappingException;
 import org.hibernate.MappingNotFoundException;
 import org.hibernate.SessionFactory;
 import org.hibernate.SessionFactoryObserver;
+import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.NamingStrategy;
 import org.hibernate.cfg.beanvalidation.BeanValidationIntegrator;
 import org.hibernate.id.factory.spi.MutableIdentifierGeneratorFactory;
 import org.hibernate.jpa.AvailableSettings;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.transaction.internal.jdbc.JdbcTransactionFactory;
 import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.jaxb.cfg.JaxbHibernateConfiguration;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.ValueHolder;
 import org.hibernate.jpa.boot.spi.EntityManagerFactoryBuilder;
 import org.hibernate.jpa.boot.spi.IntegratorProvider;
 import org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor;
 import org.hibernate.jpa.internal.EntityManagerFactoryImpl;
 import org.hibernate.jpa.internal.EntityManagerMessageLogger;
 import org.hibernate.jpa.event.spi.JpaIntegrator;
 import org.hibernate.jpa.internal.util.LogHelper;
 import org.hibernate.jpa.internal.util.PersistenceUnitTransactionTypeHelper;
 import org.hibernate.jpa.packaging.internal.NativeScanner;
 import org.hibernate.jpa.packaging.spi.NamedInputStream;
 import org.hibernate.jpa.packaging.spi.Scanner;
 import org.hibernate.jpa.spi.IdentifierGeneratorStrategyProvider;
 import org.hibernate.metamodel.source.annotations.JPADotNames;
 import org.hibernate.metamodel.source.annotations.JandexHelper;
 import org.hibernate.proxy.EntityNotFoundDelegate;
 import org.hibernate.secure.internal.JACCConfiguration;
-import org.hibernate.service.BootstrapServiceRegistry;
-import org.hibernate.service.BootstrapServiceRegistryBuilder;
+import org.hibernate.boot.registry.BootstrapServiceRegistry;
 import org.hibernate.service.ConfigLoader;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.classloading.internal.ClassLoaderServiceImpl;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 
 /**
  * @author Steve Ebersole
  */
 public class EntityManagerFactoryBuilderImpl implements EntityManagerFactoryBuilder {
     private static final EntityManagerMessageLogger LOG = Logger.getMessageLogger(
 			EntityManagerMessageLogger.class,
 			EntityManagerFactoryBuilderImpl.class.getName()
 	);
 
 	private static final String META_INF_ORM_XML = "META-INF/orm.xml";
 
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// New settings
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	/**
 	 * Names a {@link IntegratorProvider}
 	 */
 	public static final String INTEGRATOR_PROVIDER = "hibernate.integrator_provider";
 
 	/**
 	 * Names a Jandex {@link Index} instance to use.
 	 */
 	public static final String JANDEX_INDEX = "hibernate.jandex_index";
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	private final PersistenceUnitDescriptor persistenceUnit;
 	private final SettingsImpl settings = new SettingsImpl();
-	private final ServiceRegistryBuilder serviceRegistryBuilder;
+	private final StandardServiceRegistryBuilder serviceRegistryBuilder;
 	private final Map<?,?> configurationValues;
 
 	private final List<JaccDefinition> jaccDefinitions = new ArrayList<JaccDefinition>();
 	private final List<CacheRegionDefinition> cacheRegionDefinitions = new ArrayList<CacheRegionDefinition>();
 	// todo : would much prefer this as a local variable...
 	private final List<JaxbHibernateConfiguration.JaxbSessionFactory.JaxbMapping> cfgXmlNamedMappings = new ArrayList<JaxbHibernateConfiguration.JaxbSessionFactory.JaxbMapping>();
 	private Interceptor sessionFactoryInterceptor;
 	private NamingStrategy namingStrategy;
 	private SessionFactoryObserver suppliedSessionFactoryObserver;
 
 	private MetadataSources metadataSources;
 	private Configuration hibernateConfiguration;
 
 	private static EntityNotFoundDelegate jpaEntityNotFoundDelegate = new JpaEntityNotFoundDelegate();
 
 	private static class JpaEntityNotFoundDelegate implements EntityNotFoundDelegate, Serializable {
 		public void handleEntityNotFound(String entityName, Serializable id) {
 			throw new EntityNotFoundException( "Unable to find " + entityName  + " with id " + id );
 		}
 	}
 
 	public EntityManagerFactoryBuilderImpl(PersistenceUnitDescriptor persistenceUnit, Map integrationSettings) {
 		LogHelper.logPersistenceUnitInformation( persistenceUnit );
 
 		this.persistenceUnit = persistenceUnit;
 
 		if ( integrationSettings == null ) {
 			integrationSettings = Collections.emptyMap();
 		}
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// First we build the boot-strap service registry, which mainly handles class loader interactions
 		final BootstrapServiceRegistry bootstrapServiceRegistry = buildBootstrapServiceRegistry( integrationSettings );
 		// And the main service registry.  This is needed to start adding configuration values, etc
-		this.serviceRegistryBuilder = new ServiceRegistryBuilder( bootstrapServiceRegistry );
+		this.serviceRegistryBuilder = new StandardServiceRegistryBuilder( bootstrapServiceRegistry );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// Next we build a merged map of all the configuration values
 		this.configurationValues = mergePropertySources( persistenceUnit, integrationSettings, bootstrapServiceRegistry );
 		// add all merged configuration values into the service registry builder
 		this.serviceRegistryBuilder.applySettings( configurationValues );
 		// And being processing those configuration values
 		processProperties( bootstrapServiceRegistry );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// Next we do a preliminary pass at metadata processing, which involves:
 		//		1) scanning
 		ScanResult scanResult = scan( bootstrapServiceRegistry );
 		//		2) building a Jandex index
 		Set<String> collectedManagedClassNames = collectManagedClassNames( scanResult );
 		IndexView jandexIndex = locateOrBuildJandexIndex( collectedManagedClassNames, scanResult.getPackageNames(), bootstrapServiceRegistry );
 		//		3) building "metadata sources" to keep for later to use in building the SessionFactory
 		metadataSources = prepareMetadataSources( jandexIndex, collectedManagedClassNames, scanResult, bootstrapServiceRegistry );
 
 		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 		// push back class transformation to the environment; for the time being this only has any effect in EE
 		// container situations, calling back into PersistenceUnitInfo#addClassTransformer
 		final boolean useClassTransformer = "true".equals( configurationValues.remove( AvailableSettings.USE_CLASS_ENHANCER ) );
 		if ( useClassTransformer ) {
 			persistenceUnit.pushClassTransformer( metadataSources.collectMappingClassNames() );
 		}
 	}
 
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 	// temporary!
 	public Map<?, ?> getConfigurationValues() {
 		return Collections.unmodifiableMap( configurationValues );
 	}
 
 	public Configuration getHibernateConfiguration() {
 		return hibernateConfiguration;
 	}
 	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 
 	@SuppressWarnings("unchecked")
 	private MetadataSources prepareMetadataSources(
 			IndexView jandexIndex,
 			Set<String> collectedManagedClassNames,
 			ScanResult scanResult,
 			BootstrapServiceRegistry bootstrapServiceRegistry) {
 		// todo : this needs to tie into the metamodel branch...
 		MetadataSources metadataSources = new MetadataSources();
 
 		for ( String className : collectedManagedClassNames ) {
 			final ClassInfo classInfo = jandexIndex.getClassByName( DotName.createSimple( className ) );
 			if ( classInfo == null ) {
 				// Not really sure what this means.  Most likely it is explicitly listed in the persistence unit,
 				// but mapped via mapping file.  Anyway assume its a mapping class...
 				metadataSources.annotatedMappingClassNames.add( className );
 				continue;
 			}
 
 			// logic here assumes an entity is not also a converter...
 			AnnotationInstance converterAnnotation = JandexHelper.getSingleAnnotation(
 					classInfo.annotations(),
 					JPADotNames.CONVERTER
 			);
 			if ( converterAnnotation != null ) {
 				metadataSources.converterDescriptors.add(
 						new MetadataSources.ConverterDescriptor(
 								className,
 								JandexHelper.getValue( converterAnnotation, "autoApply", boolean.class )
 						)
 				);
 			}
 			else {
 				metadataSources.annotatedMappingClassNames.add( className );
 			}
 		}
 
 		metadataSources.packageNames.addAll( scanResult.getPackageNames() );
 
 		metadataSources.namedMappingFileInputStreams.addAll( scanResult.getHbmFiles() );
 
 		metadataSources.mappingFileResources.addAll( scanResult.getMappingFiles() );
 		final String explicitHbmXmls = (String) configurationValues.remove( AvailableSettings.HBXML_FILES );
 		if ( explicitHbmXmls != null ) {
 			metadataSources.mappingFileResources.addAll( Arrays.asList( StringHelper.split( ", ", explicitHbmXmls ) ) );
 		}
 		final List<String> explicitOrmXml = (List<String>) configurationValues.remove( AvailableSettings.XML_FILE_NAMES );
 		if ( explicitOrmXml != null ) {
 			metadataSources.mappingFileResources.addAll( explicitOrmXml );
 		}
 
 		return metadataSources;
 	}
 
 	private Set<String> collectManagedClassNames(ScanResult scanResult) {
 		Set<String> collectedNames = new HashSet<String>();
 		if ( persistenceUnit.getManagedClassNames() != null ) {
 			collectedNames.addAll( persistenceUnit.getManagedClassNames() );
 		}
 		collectedNames.addAll( scanResult.getManagedClassNames() );
 		return collectedNames;
 	}
 
 	private IndexView locateOrBuildJandexIndex(
 			Set<String> collectedManagedClassNames,
 			List<String> packageNames,
 			BootstrapServiceRegistry bootstrapServiceRegistry) {
 		// for now create a whole new Index to work with, eventually we need to:
 		//		1) accept an Index as an incoming config value
 		//		2) pass that Index along to the metamodel code...
 		//
 		// (1) is mocked up here, but JBoss AS does not currently pass in any Index to use...
 		IndexView jandexIndex = (IndexView) configurationValues.get( JANDEX_INDEX );
 		if ( jandexIndex == null ) {
 			jandexIndex = buildJandexIndex( collectedManagedClassNames, packageNames, bootstrapServiceRegistry );
 		}
 		return jandexIndex;
 	}
 
 	private IndexView buildJandexIndex(Set<String> classNamesSource, List<String> packageNames, BootstrapServiceRegistry bootstrapServiceRegistry) {
 		Indexer indexer = new Indexer();
 
 		for ( String className : classNamesSource ) {
 			indexResource( className.replace( '.', '/' ) + ".class", indexer, bootstrapServiceRegistry );
 		}
 
 		// add package-info from the configured packages
 		for ( String packageName : packageNames ) {
 			indexResource( packageName.replace( '.', '/' ) + "/package-info.class", indexer, bootstrapServiceRegistry );
 		}
 
 		// for now we just skip entities defined in (1) orm.xml files and (2) hbm.xml files.  this part really needs
 		// metamodel branch...
 
 		// for now, we also need to wrap this in a CompositeIndex until Jandex is updated to use a common interface
 		// between the 2...
 		return CompositeIndex.create( indexer.complete() );
 	}
 
 	private void indexResource(String resourceName, Indexer indexer, BootstrapServiceRegistry bootstrapServiceRegistry) {
 		InputStream stream = bootstrapServiceRegistry.getService( ClassLoaderService.class ).locateResourceStream( resourceName );
 		try {
 			indexer.index( stream );
 		}
 		catch ( IOException e ) {
 			throw persistenceException( "Unable to open input stream for resource " + resourceName, e );
 		}
 	}
 
 	/**
-	 * Builds the {@link BootstrapServiceRegistry} used to eventually build the {@link ServiceRegistryBuilder}; mainly
+	 * Builds the {@link BootstrapServiceRegistry} used to eventually build the {@link org.hibernate.boot.registry.StandardServiceRegistryBuilder}; mainly
 	 * used here during instantiation to define class-loading behavior.
 	 *
 	 * @param integrationSettings Any integration settings passed by the EE container or SE application
 	 *
 	 * @return The built BootstrapServiceRegistry
 	 */
 	private BootstrapServiceRegistry buildBootstrapServiceRegistry(Map integrationSettings) {
 		final BootstrapServiceRegistryBuilder bootstrapServiceRegistryBuilder = new BootstrapServiceRegistryBuilder();
 		bootstrapServiceRegistryBuilder.with( new JpaIntegrator() );
 
 		final IntegratorProvider integratorProvider = (IntegratorProvider) integrationSettings.get( INTEGRATOR_PROVIDER );
 		if ( integratorProvider != null ) {
 			integrationSettings.remove( INTEGRATOR_PROVIDER );
 			for ( Integrator integrator : integratorProvider.getIntegrators() ) {
 				bootstrapServiceRegistryBuilder.with( integrator );
 			}
 		}
 
 		ClassLoader classLoader = (ClassLoader) integrationSettings.get( org.hibernate.cfg.AvailableSettings.APP_CLASSLOADER );
 		if ( classLoader != null ) {
 			integrationSettings.remove( org.hibernate.cfg.AvailableSettings.APP_CLASSLOADER );
 		}
 		else {
 			classLoader = persistenceUnit.getClassLoader();
 		}
 		bootstrapServiceRegistryBuilder.withApplicationClassLoader( classLoader );
 
 		return bootstrapServiceRegistryBuilder.build();
 	}
 
 	@SuppressWarnings("unchecked")
 	private Map mergePropertySources(
 			PersistenceUnitDescriptor persistenceUnit,
 			Map integrationSettings,
 			final BootstrapServiceRegistry bootstrapServiceRegistry) {
 		final Map merged = new HashMap();
 		// first, apply persistence.xml-defined settings
 		if ( persistenceUnit.getProperties() != null ) {
 			merged.putAll( persistenceUnit.getProperties() );
 		}
 
 		merged.put( AvailableSettings.PERSISTENCE_UNIT_NAME, persistenceUnit.getName() );
 
 		// see if the persistence.xml settings named a Hibernate config file....
 		final ValueHolder<ConfigLoader> configLoaderHolder = new ValueHolder<ConfigLoader>(
 				new ValueHolder.DeferredInitializer<ConfigLoader>() {
 					@Override
 					public ConfigLoader initialize() {
 						return new ConfigLoader( bootstrapServiceRegistry );
 					}
 				}
 		);
 
 		{
 			final String cfgXmlResourceName = (String) merged.remove( AvailableSettings.CFG_FILE );
 			if ( StringHelper.isNotEmpty( cfgXmlResourceName ) ) {
 				// it does, so load those properties
 				JaxbHibernateConfiguration configurationElement = configLoaderHolder.getValue()
 						.loadConfigXmlResource( cfgXmlResourceName );
 				processHibernateConfigurationElement( configurationElement, merged );
 			}
 		}
 
 		// see if integration settings named a Hibernate config file....
 		{
 			final String cfgXmlResourceName = (String) integrationSettings.get( AvailableSettings.CFG_FILE );
 			if ( StringHelper.isNotEmpty( cfgXmlResourceName ) ) {
 				integrationSettings.remove( AvailableSettings.CFG_FILE );
 				// it does, so load those properties
 				JaxbHibernateConfiguration configurationElement = configLoaderHolder.getValue().loadConfigXmlResource(
 						cfgXmlResourceName
 				);
 				processHibernateConfigurationElement( configurationElement, merged );
 			}
 		}
 
 		// finally, apply integration-supplied settings (per JPA spec, integration settings should override other sources)
 		merged.putAll( integrationSettings );
 
 		if ( ! merged.containsKey( AvailableSettings.VALIDATION_MODE ) ) {
 			if ( persistenceUnit.getValidationMode() != null ) {
 				merged.put( AvailableSettings.VALIDATION_MODE, persistenceUnit.getValidationMode() );
 			}
 		}
 
 		if ( ! merged.containsKey( AvailableSettings.SHARED_CACHE_MODE ) ) {
 			if ( persistenceUnit.getSharedCacheMode() != null ) {
 				merged.put( AvailableSettings.SHARED_CACHE_MODE, persistenceUnit.getSharedCacheMode() );
 			}
 		}
 
 		// was getting NPE exceptions from the underlying map when just using #putAll, so going this safer route...
 		Iterator itr = merged.entrySet().iterator();
 		while ( itr.hasNext() ) {
 			final Map.Entry entry = (Map.Entry) itr.next();
 			if ( entry.getValue() == null ) {
 				itr.remove();
 			}
 		}
 
 		return merged;
 	}
 
 	@SuppressWarnings("unchecked")
 	private void processHibernateConfigurationElement(
 			JaxbHibernateConfiguration configurationElement,
 			Map mergeMap) {
 		if ( ! mergeMap.containsKey( org.hibernate.cfg.AvailableSettings.SESSION_FACTORY_NAME ) ) {
 			String cfgName = configurationElement.getSessionFactory().getName();
 			if ( cfgName != null ) {
 				mergeMap.put( org.hibernate.cfg.AvailableSettings.SESSION_FACTORY_NAME, cfgName );
 			}
 		}
 
 		for ( JaxbHibernateConfiguration.JaxbSessionFactory.JaxbProperty jaxbProperty : configurationElement.getSessionFactory().getProperty() ) {
 			mergeMap.put( jaxbProperty.getName(), jaxbProperty.getValue() );
 		}
 
 		for ( JaxbHibernateConfiguration.JaxbSessionFactory.JaxbMapping jaxbMapping : configurationElement.getSessionFactory().getMapping() ) {
 			cfgXmlNamedMappings.add( jaxbMapping );
 		}
 
 		for ( Object cacheDeclaration : configurationElement.getSessionFactory().getClassCacheOrCollectionCache() ) {
 			if ( JaxbHibernateConfiguration.JaxbSessionFactory.JaxbClassCache.class.isInstance( cacheDeclaration ) ) {
 				final JaxbHibernateConfiguration.JaxbSessionFactory.JaxbClassCache jaxbClassCache
 						= (JaxbHibernateConfiguration.JaxbSessionFactory.JaxbClassCache) cacheDeclaration;
 				cacheRegionDefinitions.add(
 						new CacheRegionDefinition(
 								CacheRegionDefinition.CacheType.ENTITY,
 								jaxbClassCache.getClazz(),
 								jaxbClassCache.getUsage().value(),
 								jaxbClassCache.getRegion(),
 								"all".equals( jaxbClassCache.getInclude() )
 						)
 				);
 			}
 			else {
 				final JaxbHibernateConfiguration.JaxbSessionFactory.JaxbCollectionCache jaxbCollectionCache
 						= (JaxbHibernateConfiguration.JaxbSessionFactory.JaxbCollectionCache) cacheDeclaration;
 				cacheRegionDefinitions.add(
 						new CacheRegionDefinition(
 								CacheRegionDefinition.CacheType.COLLECTION,
 								jaxbCollectionCache.getCollection(),
 								jaxbCollectionCache.getUsage().value(),
 								jaxbCollectionCache.getRegion(),
 								false
 						)
 				);
 			}
 		}
 
 		if ( configurationElement.getSecurity() != null ) {
 			final String contextId = configurationElement.getSecurity().getContext();
 			for ( JaxbHibernateConfiguration.JaxbSecurity.JaxbGrant grant : configurationElement.getSecurity().getGrant() ) {
 				jaccDefinitions.add(
 						new JaccDefinition(
 								contextId,
 								grant.getRole(),
 								grant.getEntityName(),
 								grant.getActions()
 						)
 				);
 			}
 		}
 	}
 
 	private void processProperties(BootstrapServiceRegistry bootstrapServiceRegistry) {
 		applyJdbcConnectionProperties();
 		applyTransactionProperties();
 
 		final Object validationFactory = configurationValues.get( AvailableSettings.VALIDATION_FACTORY );
 		if ( validationFactory != null ) {
 			BeanValidationIntegrator.validateFactory( validationFactory );
 		}
 
 		// flush before completion validation
 		if ( "true".equals( configurationValues.get( Environment.FLUSH_BEFORE_COMPLETION ) ) ) {
 			serviceRegistryBuilder.applySetting( Environment.FLUSH_BEFORE_COMPLETION, "false" );
 			LOG.definingFlushBeforeCompletionIgnoredInHem( Environment.FLUSH_BEFORE_COMPLETION );
 		}
 
 		for ( Map.Entry entry : configurationValues.entrySet() ) {
 			if ( entry.getKey() instanceof String ) {
 				final String keyString = (String) entry.getKey();
 
 				if ( AvailableSettings.INTERCEPTOR.equals( keyString ) ) {
 					sessionFactoryInterceptor = instantiateCustomClassFromConfiguration(
 							entry.getValue(),
 							Interceptor.class,
 							bootstrapServiceRegistry
 					);
 				}
 				else if ( AvailableSettings.SESSION_INTERCEPTOR.equals( keyString ) ) {
 					settings.setSessionInterceptorClass(
 							loadSessionInterceptorClass( entry.getValue(), bootstrapServiceRegistry )
 					);
 				}
 				else if ( AvailableSettings.NAMING_STRATEGY.equals( keyString ) ) {
 					namingStrategy = instantiateCustomClassFromConfiguration(
 							entry.getValue(),
 							NamingStrategy.class,
 							bootstrapServiceRegistry
 					);
 				}
 				else if ( AvailableSettings.SESSION_FACTORY_OBSERVER.equals( keyString ) ) {
 					suppliedSessionFactoryObserver = instantiateCustomClassFromConfiguration(
 							entry.getValue(),
 							SessionFactoryObserver.class,
 							bootstrapServiceRegistry
 					);
 				}
 				else if ( AvailableSettings.DISCARD_PC_ON_CLOSE.equals( keyString ) ) {
 					settings.setReleaseResourcesOnCloseEnabled( "true".equals( entry.getValue() ) );
 				}
 				else if ( keyString.startsWith( AvailableSettings.CLASS_CACHE_PREFIX ) ) {
 					addCacheRegionDefinition(
 							keyString.substring( AvailableSettings.CLASS_CACHE_PREFIX.length() + 1 ),
 							(String) entry.getValue(),
 							CacheRegionDefinition.CacheType.ENTITY
 					);
 				}
 				else if ( keyString.startsWith( AvailableSettings.COLLECTION_CACHE_PREFIX ) ) {
 					addCacheRegionDefinition(
 							keyString.substring( AvailableSettings.COLLECTION_CACHE_PREFIX.length() + 1 ),
 							(String) entry.getValue(),
 							CacheRegionDefinition.CacheType.COLLECTION
 					);
 				}
 				else if ( keyString.startsWith( AvailableSettings.JACC_PREFIX )
 						&& ! ( keyString.equals( AvailableSettings.JACC_CONTEXT_ID )
 						|| keyString.equals( AvailableSettings.JACC_ENABLED ) ) ) {
 					addJaccDefinition( (String) entry.getKey(), entry.getValue() );
 				}
 			}
 		}
 	}
 
 	private void applyJdbcConnectionProperties() {
 		if ( persistenceUnit.getJtaDataSource() != null ) {
 			serviceRegistryBuilder.applySetting( Environment.DATASOURCE, persistenceUnit.getJtaDataSource() );
 		}
 		else if ( persistenceUnit.getNonJtaDataSource() != null ) {
 			serviceRegistryBuilder.applySetting( Environment.DATASOURCE, persistenceUnit.getNonJtaDataSource() );
 		}
 		else {
 			final String driver = (String) configurationValues.get( AvailableSettings.JDBC_DRIVER );
 			if ( StringHelper.isNotEmpty( driver ) ) {
 				serviceRegistryBuilder.applySetting( org.hibernate.cfg.AvailableSettings.DRIVER, driver );
 			}
 			final String url = (String) configurationValues.get( AvailableSettings.JDBC_URL );
 			if ( StringHelper.isNotEmpty( url ) ) {
 				serviceRegistryBuilder.applySetting( org.hibernate.cfg.AvailableSettings.URL, url );
 			}
 			final String user = (String) configurationValues.get( AvailableSettings.JDBC_USER );
 			if ( StringHelper.isNotEmpty( user ) ) {
 				serviceRegistryBuilder.applySetting( org.hibernate.cfg.AvailableSettings.USER, user );
 			}
 			final String pass = (String) configurationValues.get( AvailableSettings.JDBC_PASSWORD );
 			if ( StringHelper.isNotEmpty( pass ) ) {
 				serviceRegistryBuilder.applySetting( org.hibernate.cfg.AvailableSettings.PASS, pass );
 			}
 		}
 	}
 
 	private void applyTransactionProperties() {
 		PersistenceUnitTransactionType txnType = PersistenceUnitTransactionTypeHelper.interpretTransactionType(
 				configurationValues.get( AvailableSettings.TRANSACTION_TYPE )
 		);
 		if ( txnType == null ) {
 			txnType = persistenceUnit.getTransactionType();
 		}
 		if ( txnType == null ) {
 			// is it more appropriate to have this be based on bootstrap entry point (EE vs SE)?
 			txnType = PersistenceUnitTransactionType.RESOURCE_LOCAL;
 		}
 		settings.setTransactionType( txnType );
 		boolean hasTxStrategy = configurationValues.containsKey( Environment.TRANSACTION_STRATEGY );
 		if ( hasTxStrategy ) {
 			LOG.overridingTransactionStrategyDangerous( Environment.TRANSACTION_STRATEGY );
 		}
 		else {
 			if ( txnType == PersistenceUnitTransactionType.JTA ) {
 				serviceRegistryBuilder.applySetting( Environment.TRANSACTION_STRATEGY, CMTTransactionFactory.class );
 			}
 			else if ( txnType == PersistenceUnitTransactionType.RESOURCE_LOCAL ) {
 				serviceRegistryBuilder.applySetting( Environment.TRANSACTION_STRATEGY, JdbcTransactionFactory.class );
 			}
 		}
 	}
 
 	private String jaccContextId;
 
 	private void addJaccDefinition(String key, Object value) {
 		if ( jaccContextId == null ) {
 			jaccContextId = (String) configurationValues.get( AvailableSettings.JACC_CONTEXT_ID );
 			if ( jaccContextId == null ) {
 				throw persistenceException(
 						"Entities have been configured for JACC, but "
 								+ AvailableSettings.JACC_CONTEXT_ID + " has not been set"
 				);
 			}
 		}
 
 		try {
 			final int roleStart = AvailableSettings.JACC_PREFIX.length() + 1;
 			final String role = key.substring( roleStart, key.indexOf( '.', roleStart ) );
 			final int classStart = roleStart + role.length() + 1;
 			final String clazz = key.substring( classStart, key.length() );
 
 			final JaccDefinition def = new JaccDefinition( jaccContextId, role, clazz, (String) value );
 
 			jaccDefinitions.add( def );
 
 		}
 		catch ( IndexOutOfBoundsException e ) {
 			throw persistenceException( "Illegal usage of " + AvailableSettings.JACC_PREFIX + ": " + key );
 		}
 	}
 
 	@SuppressWarnings("unchecked")
 	private Class<? extends Interceptor> loadSessionInterceptorClass(
 			Object value,
 			BootstrapServiceRegistry bootstrapServiceRegistry) {
 		if ( value == null ) {
 			return null;
 		}
 
 		Class theClass;
 		if ( Class.class.isInstance( value ) ) {
 			theClass = (Class) value;
 		}
 		else {
 			theClass = bootstrapServiceRegistry.getService( ClassLoaderService.class ).classForName( value.toString() );
 		}
 
 		try {
 			return (Class<? extends Interceptor>) theClass;
 		}
 		catch (ClassCastException e) {
 			throw persistenceException(
 					String.format(
 							"Specified Interceptor implementation class [%s] was not castable to Interceptor",
 							theClass.getName()
 					)
 			);
 		}
 	}
 
 	private void addCacheRegionDefinition(String role, String value, CacheRegionDefinition.CacheType cacheType) {
 		final StringTokenizer params = new StringTokenizer( value, ";, " );
 		if ( !params.hasMoreTokens() ) {
 			StringBuilder error = new StringBuilder( "Illegal usage of " );
 			if ( cacheType == CacheRegionDefinition.CacheType.ENTITY ) {
 				error.append( AvailableSettings.CLASS_CACHE_PREFIX )
 						.append( ": " )
 						.append( AvailableSettings.CLASS_CACHE_PREFIX );
 			}
 			else {
 				error.append( AvailableSettings.COLLECTION_CACHE_PREFIX )
 						.append( ": " )
 						.append( AvailableSettings.COLLECTION_CACHE_PREFIX );
 			}
 			error.append( '.' )
 					.append( role )
 					.append( ' ' )
 					.append( value )
 					.append( ".  Was expecting configuration, but found none" );
 			throw persistenceException( error.toString() );
 		}
 
 		String usage = params.nextToken();
 		String region = null;
 		if ( params.hasMoreTokens() ) {
 			region = params.nextToken();
 		}
 		boolean lazyProperty = true;
 		if ( cacheType == CacheRegionDefinition.CacheType.ENTITY ) {
 			if ( params.hasMoreTokens() ) {
 				lazyProperty = "all".equalsIgnoreCase( params.nextToken() );
 			}
 		}
 		else {
 			lazyProperty = false;
 		}
 
 		final CacheRegionDefinition def = new CacheRegionDefinition( cacheType, role, usage, region, lazyProperty );
 		cacheRegionDefinitions.add( def );
 	}
 
 	@SuppressWarnings("unchecked")
 	private <T> T instantiateCustomClassFromConfiguration(
 			Object value,
 			Class<T> type,
 			ServiceRegistry bootstrapServiceRegistry) {
 		if ( value == null ) {
 			return null;
 		}
 
 		if ( type.isInstance( value ) ) {
 			return (T) value;
 		}
 
 		final Class<? extends T> implementationClass;
 
 		if ( Class.class.isInstance( value ) ) {
 			try {
 				implementationClass = (Class<? extends T>) value;
 			}
 			catch (ClassCastException e) {
 				throw persistenceException(
 						String.format(
 								"Specified implementation class [%s] was not of expected type [%s]",
 								((Class) value).getName(),
 								type.getName()
 						)
 				);
 			}
 		}
 		else {
 			final String implementationClassName = value.toString();
 			try {
 				implementationClass = bootstrapServiceRegistry.getService( ClassLoaderService.class )
 						.classForName( implementationClassName );
 			}
 			catch (ClassCastException e) {
 				throw persistenceException(
 						String.format(
 								"Specified implementation class [%s] was not of expected type [%s]",
 								implementationClassName,
 								type.getName()
 						)
 				);
 			}
 		}
 
 		try {
 			return implementationClass.newInstance();
 		}
 		catch (Exception e) {
 			throw persistenceException(
 					String.format(
 							"Unable to instantiate specified implementation class [%s]",
 							implementationClass.getName()
 					),
 					e
 			);
 		}
 	}
 
 	@SuppressWarnings("unchecked")
 	private ScanResult scan(BootstrapServiceRegistry bootstrapServiceRegistry) {
 		Scanner scanner = locateOrBuildScanner( bootstrapServiceRegistry );
 		ScanningContext scanningContext = new ScanningContext();
 
 		final ScanResult scanResult = new ScanResult();
 		if ( persistenceUnit.getMappingFileNames() != null ) {
 			scanResult.getMappingFiles().addAll( persistenceUnit.getMappingFileNames() );
 		}
 
 		// dunno, but the old code did it...
 		scanningContext.setSearchOrm( ! scanResult.getMappingFiles().contains( META_INF_ORM_XML ) );
 
 		if ( persistenceUnit.getJarFileUrls() != null ) {
 			prepareAutoDetectionSettings( scanningContext, false );
 			for ( URL jar : persistenceUnit.getJarFileUrls() ) {
 				scanningContext.setUrl( jar );
 				scanInContext( scanner, scanningContext, scanResult );
 			}
 		}
 
 		prepareAutoDetectionSettings( scanningContext, persistenceUnit.isExcludeUnlistedClasses() );
 		scanningContext.setUrl( persistenceUnit.getPersistenceUnitRootUrl() );
 		scanInContext( scanner, scanningContext, scanResult );
 
 		return scanResult;
 	}
 
 	@SuppressWarnings("unchecked")
 	private Scanner locateOrBuildScanner(BootstrapServiceRegistry bootstrapServiceRegistry) {
 		final Object value = configurationValues.remove( AvailableSettings.SCANNER );
 		if ( value == null ) {
 			return new NativeScanner();
 		}
 
 		if ( Scanner.class.isInstance( value ) ) {
 			return (Scanner) value;
 		}
 
 		Class<? extends Scanner> scannerClass;
 		if ( Class.class.isInstance( value ) ) {
 			try {
 				scannerClass = (Class<? extends Scanner>) value;
 			}
 			catch ( ClassCastException e ) {
 				throw persistenceException( "Expecting Scanner implementation, but found " + ((Class) value).getName() );
 			}
 		}
 		else {
 			final String scannerClassName = value.toString();
 			try {
 				scannerClass = bootstrapServiceRegistry.getService( ClassLoaderService.class ).classForName( scannerClassName );
 			}
 			catch ( ClassCastException e ) {
 				throw persistenceException( "Expecting Scanner implementation, but found " + scannerClassName );
 			}
 		}
 
 		try {
 			return scannerClass.newInstance();
 		}
 		catch ( Exception e ) {
 			throw persistenceException( "Unable to instantiate Scanner class: " + scannerClass, e );
 		}
 	}
 
 	private void prepareAutoDetectionSettings(ScanningContext context, boolean excludeUnlistedClasses) {
 		final String detectionSetting = (String) configurationValues.get( AvailableSettings.AUTODETECTION );
 
 		if ( detectionSetting == null ) {
 			if ( excludeUnlistedClasses ) {
 				context.setDetectClasses( false );
 				context.setDetectHbmFiles( false );
 			}
 			else {
 				context.setDetectClasses( true );
 				context.setDetectHbmFiles( true );
 			}
 		}
 		else {
 			for ( String token : StringHelper.split( ", ", detectionSetting ) ) {
 				if ( "class".equalsIgnoreCase( token ) ) {
 					context.setDetectClasses( true );
 				}
 				if ( "hbm".equalsIgnoreCase( token ) ) {
 					context.setDetectClasses( true );
 				}
 			}
 		}
 	}
 
 	private void scanInContext(
 			Scanner scanner,
 			ScanningContext scanningContext,
 			ScanResult scanResult) {
 		if ( scanningContext.getUrl() == null ) {
 			// not sure i like just ignoring this being null, but this is exactly what the old code does...
 			LOG.containerProvidingNullPersistenceUnitRootUrl();
 			return;
 		}
 
 		try {
 			if ( scanningContext.isDetectClasses() ) {
 				Set<Package> matchingPackages = scanner.getPackagesInJar( scanningContext.url, new HashSet<Class<? extends Annotation>>(0) );
 				for ( Package pkg : matchingPackages ) {
 					scanResult.getPackageNames().add( pkg.getName() );
 				}
 
 				Set<Class<? extends Annotation>> annotationsToLookFor = new HashSet<Class<? extends Annotation>>();
 				annotationsToLookFor.add( Entity.class );
 				annotationsToLookFor.add( MappedSuperclass.class );
 				annotationsToLookFor.add( Embeddable.class );
 				annotationsToLookFor.add( Converter.class );
 				Set<Class<?>> matchingClasses = scanner.getClassesInJar( scanningContext.url, annotationsToLookFor );
 				for ( Class<?> clazz : matchingClasses ) {
 					scanResult.getManagedClassNames().add( clazz.getName() );
 				}
 			}
 
 			Set<String> patterns = new HashSet<String>();
 			if ( scanningContext.isSearchOrm() ) {
 				patterns.add( META_INF_ORM_XML );
 			}
 			if ( scanningContext.isDetectHbmFiles() ) {
 				patterns.add( "**/*.hbm.xml" );
 			}
 			if ( ! scanResult.getMappingFiles().isEmpty() ) {
 				patterns.addAll( scanResult.getMappingFiles() );
 			}
 			if ( patterns.size() != 0 ) {
 				Set<NamedInputStream> files = scanner.getFilesInJar( scanningContext.getUrl(), patterns );
 				for ( NamedInputStream file : files ) {
 					scanResult.getHbmFiles().add( file );
 					scanResult.getMappingFiles().remove( file.getName() );
 				}
 			}
 		}
 		catch (PersistenceException e ) {
 			throw e;
 		}
 		catch ( RuntimeException e ) {
 			throw persistenceException( "error trying to scan url: " + scanningContext.getUrl().toString(), e );
 		}
 	}
 
 	@Override
 	public void cancel() {
 		// todo : close the bootstrap registry (not critical, but nice to do)
 
 	}
 
 	@SuppressWarnings("unchecked")
 	public EntityManagerFactory buildEntityManagerFactory() {
 		// IMPL NOTE : TCCL handling here is temporary.
 		//		It is needed because this code still uses Hibernate Configuration and Hibernate commons-annotations
 		// 		in turn which relies on TCCL being set.
 
 		final ServiceRegistry serviceRegistry = buildServiceRegistry();
 		final ClassLoaderService classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 
 		return ( (ClassLoaderServiceImpl) classLoaderService ).withTccl(
 				new ClassLoaderServiceImpl.Work<EntityManagerFactoryImpl>() {
 					@Override
 					public EntityManagerFactoryImpl perform() {
 						hibernateConfiguration = buildHibernateConfiguration( serviceRegistry );
 
 						SessionFactoryImplementor sessionFactory;
 						try {
 							sessionFactory = (SessionFactoryImplementor) hibernateConfiguration.buildSessionFactory( serviceRegistry );
 						}
 						catch (MappingException e) {
 							throw persistenceException( "Unable to build Hibernate SessionFactory", e );
 						}
 
 						if ( suppliedSessionFactoryObserver != null ) {
 							sessionFactory.addObserver( suppliedSessionFactoryObserver );
 						}
 						sessionFactory.addObserver( new ServiceRegistryCloser() );
 
 						// NOTE : passing cfg is temporary until
 						return new EntityManagerFactoryImpl( persistenceUnit.getName(), sessionFactory, settings, configurationValues, hibernateConfiguration );
 					}
 				}
 		);
 	}
 
 	public ServiceRegistry buildServiceRegistry() {
 		return serviceRegistryBuilder.buildServiceRegistry();
 	}
 
 	public Configuration buildHibernateConfiguration(ServiceRegistry serviceRegistry) {
 		Properties props = new Properties();
 		props.putAll( configurationValues );
 		Configuration cfg = new Configuration().setProperties( props );
 
 		cfg.setEntityNotFoundDelegate( jpaEntityNotFoundDelegate );
 
 		if ( namingStrategy != null ) {
 			cfg.setNamingStrategy( namingStrategy );
 		}
 
 		if ( sessionFactoryInterceptor != null ) {
 			cfg.setInterceptor( sessionFactoryInterceptor );
 		}
 
 		final IdentifierGeneratorStrategyProvider strategyProvider = instantiateCustomClassFromConfiguration(
 				props.get( AvailableSettings.IDENTIFIER_GENERATOR_STRATEGY_PROVIDER ),
 				IdentifierGeneratorStrategyProvider.class,
 				serviceRegistry
 		);
 		if ( strategyProvider != null ) {
 			final MutableIdentifierGeneratorFactory identifierGeneratorFactory = cfg.getIdentifierGeneratorFactory();
 			for ( Map.Entry<String,Class<?>> entry : strategyProvider.getStrategies().entrySet() ) {
 				identifierGeneratorFactory.register( entry.getKey(), entry.getValue() );
 			}
 		}
 
 		if ( jaccDefinitions != null ) {
 			for ( JaccDefinition jaccDefinition : jaccDefinitions ) {
 				JACCConfiguration jaccCfg = new JACCConfiguration( jaccDefinition.contextId );
 				jaccCfg.addPermission( jaccDefinition.role, jaccDefinition.clazz, jaccDefinition.actions );
 			}
 		}
 
 		if ( cacheRegionDefinitions != null ) {
 			for ( CacheRegionDefinition cacheRegionDefinition : cacheRegionDefinitions ) {
 				if ( cacheRegionDefinition.cacheType == CacheRegionDefinition.CacheType.ENTITY ) {
 					cfg.setCacheConcurrencyStrategy(
 							cacheRegionDefinition.role,
 							cacheRegionDefinition.usage,
 							cacheRegionDefinition.region,
 							cacheRegionDefinition.cacheLazy
 					);
 				}
 				else {
 					cfg.setCollectionCacheConcurrencyStrategy(
 							cacheRegionDefinition.role,
 							cacheRegionDefinition.usage,
 							cacheRegionDefinition.region
 					);
 				}
 			}
 		}
 
 
 		// todo : need to have this use the metamodel codebase eventually...
 
 		for ( JaxbHibernateConfiguration.JaxbSessionFactory.JaxbMapping jaxbMapping : cfgXmlNamedMappings ) {
 			if ( jaxbMapping.getClazz() != null ) {
 				cfg.addAnnotatedClass(
 						serviceRegistry.getService( ClassLoaderService.class ).classForName( jaxbMapping.getClazz() )
 				);
 			}
 			else if ( jaxbMapping.getResource() != null ) {
 				cfg.addResource( jaxbMapping.getResource() );
 			}
 			else if ( jaxbMapping.getJar() != null ) {
 				cfg.addJar( new File( jaxbMapping.getJar() ) );
 			}
 			else if ( jaxbMapping.getPackage() != null ) {
 				cfg.addPackage( jaxbMapping.getPackage() );
 			}
 		}
 
 		List<Class> loadedAnnotatedClasses = (List<Class>) configurationValues.remove( AvailableSettings.LOADED_CLASSES );
 		if ( loadedAnnotatedClasses != null ) {
 			for ( Class cls : loadedAnnotatedClasses ) {
 				cfg.addAnnotatedClass( cls );
 			}
 		}
 
 		for ( String className : metadataSources.getAnnotatedMappingClassNames() ) {
 			cfg.addAnnotatedClass( serviceRegistry.getService( ClassLoaderService.class ).classForName( className ) );
 		}
 
 		for ( MetadataSources.ConverterDescriptor converterDescriptor : metadataSources.getConverterDescriptors() ) {
 			final Class<? extends AttributeConverter> converterClass;
 			try {
 				Class theClass = serviceRegistry.getService( ClassLoaderService.class ).classForName( converterDescriptor.converterClassName );
 				converterClass = (Class<? extends AttributeConverter>) theClass;
 			}
 			catch (ClassCastException e) {
 				throw persistenceException(
 						String.format(
 								"AttributeConverter implementation [%s] does not implement AttributeConverter interface",
 								converterDescriptor.converterClassName
 						)
 				);
 			}
 			cfg.addAttributeConverter( converterClass, converterDescriptor.autoApply );
 		}
 
 		for ( String resourceName : metadataSources.mappingFileResources ) {
 			Boolean useMetaInf = null;
 			try {
 				if ( resourceName.endsWith( META_INF_ORM_XML ) ) {
 					useMetaInf = true;
 				}
 				cfg.addResource( resourceName );
 			}
 			catch( MappingNotFoundException e ) {
 				if ( ! resourceName.endsWith( META_INF_ORM_XML ) ) {
 					throw persistenceException( "Unable to find XML mapping file in classpath: " + resourceName );
 				}
 				else {
 					useMetaInf = false;
 					//swallow it, the META-INF/orm.xml is optional
 				}
 			}
 			catch( MappingException me ) {
 				throw persistenceException( "Error while reading JPA XML file: " + resourceName, me );
 			}
 
 			if ( Boolean.TRUE.equals( useMetaInf ) ) {
 				LOG.exceptionHeaderFound( getExceptionHeader(), META_INF_ORM_XML );
 			}
 			else if (Boolean.FALSE.equals(useMetaInf)) {
 				LOG.exceptionHeaderNotFound( getExceptionHeader(), META_INF_ORM_XML );
 			}
 		}
 		for ( NamedInputStream namedInputStream : metadataSources.namedMappingFileInputStreams ) {
 			try {
 				//addInputStream has the responsibility to close the stream
 				cfg.addInputStream( new BufferedInputStream( namedInputStream.getStream() ) );
 			}
 			catch (MappingException me) {
 				//try our best to give the file name
 				if ( StringHelper.isEmpty( namedInputStream.getName() ) ) {
 					throw me;
 				}
 				else {
 					throw new MappingException("Error while parsing file: " + namedInputStream.getName(), me );
 				}
 			}
 		}
 		for ( String packageName : metadataSources.packageNames ) {
 			cfg.addPackage( packageName );
 		}
 		return cfg;
 	}
 
 	public static class ServiceRegistryCloser implements SessionFactoryObserver {
 		@Override
 		public void sessionFactoryCreated(SessionFactory sessionFactory) {
 			// nothing to do
 		}
 
 		@Override
 		public void sessionFactoryClosed(SessionFactory sessionFactory) {
 			SessionFactoryImplementor sfi = ( (SessionFactoryImplementor) sessionFactory );
 			sfi.getServiceRegistry().destroy();
 			ServiceRegistry basicRegistry = sfi.getServiceRegistry().getParentServiceRegistry();
 			( (ServiceRegistryImplementor) basicRegistry ).destroy();
 		}
 	}
 
 	private PersistenceException persistenceException(String message) {
 		return persistenceException( message, null );
 	}
 
 	private PersistenceException persistenceException(String message, Exception cause) {
 		return new PersistenceException(
 				getExceptionHeader() + message,
 				cause
 		);
 	}
 
 	private String getExceptionHeader() {
 		return "[PersistenceUnit: " + persistenceUnit.getName() + "] ";
 	}
 
 	public static class CacheRegionDefinition {
 		public static enum CacheType { ENTITY, COLLECTION }
 
 		public final CacheType cacheType;
 		public final String role;
 		public final String usage;
 		public final String region;
 		public final boolean cacheLazy;
 
 		public CacheRegionDefinition(
 				CacheType cacheType,
 				String role,
 				String usage,
 				String region, boolean cacheLazy) {
 			this.cacheType = cacheType;
 			this.role = role;
 			this.usage = usage;
 			this.region = region;
 			this.cacheLazy = cacheLazy;
 		}
 	}
 
 	public static class JaccDefinition {
 		public final String contextId;
 		public final String role;
 		public final String clazz;
 		public final String actions;
 
 		public JaccDefinition(String contextId, String role, String clazz, String actions) {
 			this.contextId = contextId;
 			this.role = role;
 			this.clazz = clazz;
 			this.actions = actions;
 		}
 	}
 
 	public static class ScanningContext {
 		private URL url;
 		private boolean detectClasses;
 		private boolean detectHbmFiles;
 		private boolean searchOrm;
 
 		public URL getUrl() {
 			return url;
 		}
 
 		public void setUrl(URL url) {
 			this.url = url;
 		}
 
 		public boolean isDetectClasses() {
 			return detectClasses;
 		}
 
 		public void setDetectClasses(boolean detectClasses) {
 			this.detectClasses = detectClasses;
 		}
 
 		public boolean isDetectHbmFiles() {
 			return detectHbmFiles;
 		}
 
 		public void setDetectHbmFiles(boolean detectHbmFiles) {
 			this.detectHbmFiles = detectHbmFiles;
 		}
 
 		public boolean isSearchOrm() {
 			return searchOrm;
 		}
 
 		public void setSearchOrm(boolean searchOrm) {
 			this.searchOrm = searchOrm;
 		}
 	}
 
 	private static class ScanResult {
 		private final List<String> managedClassNames = new ArrayList<String>();
 		private final List<String> packageNames = new ArrayList<String>();
 		private final List<NamedInputStream> hbmFiles = new ArrayList<NamedInputStream>();
 		private final List<String> mappingFiles = new ArrayList<String>();
 
 		public List<String> getManagedClassNames() {
 			return managedClassNames;
 		}
 
 		public List<String> getPackageNames() {
 			return packageNames;
 		}
 
 		public List<NamedInputStream> getHbmFiles() {
 			return hbmFiles;
 		}
 
 		public List<String> getMappingFiles() {
 			return mappingFiles;
 		}
 	}
 
 	public static class MetadataSources {
 		private final List<String> annotatedMappingClassNames = new ArrayList<String>();
 		private final List<ConverterDescriptor> converterDescriptors = new ArrayList<ConverterDescriptor>();
 		private final List<NamedInputStream> namedMappingFileInputStreams = new ArrayList<NamedInputStream>();
 		private final List<String> mappingFileResources = new ArrayList<String>();
 		private final List<String> packageNames = new ArrayList<String>();
 
 		public List<String> getAnnotatedMappingClassNames() {
 			return annotatedMappingClassNames;
 		}
 
 		public List<ConverterDescriptor> getConverterDescriptors() {
 			return converterDescriptors;
 		}
 
 		public List<NamedInputStream> getNamedMappingFileInputStreams() {
 			return namedMappingFileInputStreams;
 		}
 
 		public List<String> getPackageNames() {
 			return packageNames;
 		}
 
 		public List<String> collectMappingClassNames() {
 			// todo : the complete answer to this involves looking through the mapping files as well.
 			// 		Really need the metamodel branch code to do that properly
 			return annotatedMappingClassNames;
 		}
 
 		public static class ConverterDescriptor {
 			private final String converterClassName;
 			private final boolean autoApply;
 
 			public ConverterDescriptor(String converterClassName, boolean autoApply) {
 				this.converterClassName = converterClassName;
 				this.autoApply = autoApply;
 			}
 		}
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/PersistenceXmlParser.java b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/PersistenceXmlParser.java
index 60aff1bc0b..360a71ead4 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/PersistenceXmlParser.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/boot/internal/PersistenceXmlParser.java
@@ -1,479 +1,479 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jpa.boot.internal;
 
 import javax.persistence.PersistenceException;
 import javax.persistence.spi.PersistenceUnitTransactionType;
 import javax.xml.XMLConstants;
 import javax.xml.parsers.DocumentBuilder;
 import javax.xml.parsers.DocumentBuilderFactory;
 import javax.xml.parsers.ParserConfigurationException;
 import javax.xml.transform.dom.DOMSource;
 import javax.xml.transform.stream.StreamSource;
 import javax.xml.validation.Schema;
 import javax.xml.validation.SchemaFactory;
 import javax.xml.validation.Validator;
 import java.io.IOException;
 import java.io.InputStream;
 import java.net.URL;
 import java.net.URLConnection;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 
 import org.jboss.logging.Logger;
 import org.w3c.dom.Document;
 import org.w3c.dom.Element;
 import org.w3c.dom.Node;
 import org.w3c.dom.NodeList;
 import org.xml.sax.ErrorHandler;
 import org.xml.sax.InputSource;
 import org.xml.sax.SAXException;
 import org.xml.sax.SAXParseException;
 
 import org.hibernate.jpa.AvailableSettings;
 import org.hibernate.jpa.internal.EntityManagerMessageLogger;
 import org.hibernate.jpa.packaging.internal.JarVisitorFactory;
 import org.hibernate.jpa.internal.util.ConfigurationHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.metamodel.source.XsdException;
-import org.hibernate.service.classloading.internal.ClassLoaderServiceImpl;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.internal.ClassLoaderServiceImpl;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 /**
  * Used by Hibernate to parse {@code persistence.xml} files in SE environments.
  *
  * @author Steve Ebersole
  */
 public class PersistenceXmlParser {
     private static final EntityManagerMessageLogger LOG = Logger.getMessageLogger(
 			EntityManagerMessageLogger.class,
 			PersistenceXmlParser.class.getName()
 	);
 
 	private final ClassLoaderService classLoaderService;
 	private final PersistenceUnitTransactionType defaultTransactionType;
 
 	public static List<ParsedPersistenceXmlDescriptor> locatePersistenceUnits(Map integration) {
 		final PersistenceXmlParser parser = new PersistenceXmlParser(
 				ClassLoaderServiceImpl.fromConfigSettings( integration ),
 				PersistenceUnitTransactionType.RESOURCE_LOCAL
 		);
 
 		return parser.doResolve( integration );
 	}
 
 
 	public PersistenceXmlParser(ClassLoaderService classLoaderService, PersistenceUnitTransactionType defaultTransactionType) {
 		this.classLoaderService = classLoaderService;
 		this.defaultTransactionType = defaultTransactionType;
 	}
 
 	public List<ParsedPersistenceXmlDescriptor> doResolve(Map integration) {
 		final List<ParsedPersistenceXmlDescriptor> persistenceUnits = new ArrayList<ParsedPersistenceXmlDescriptor>();
 
 		final List<URL> xmlUrls = classLoaderService.locateResources( "META-INF/persistence.xml" );
 		if ( xmlUrls.isEmpty() ) {
 			LOG.unableToFindPersistenceXmlInClasspath();
 		}
 		else {
 			for ( URL xmlUrl : xmlUrls ) {
 				persistenceUnits.addAll( parsePersistenceXml( xmlUrl, integration ) );
 			}
 		}
 
 		return persistenceUnits;
 	}
 
 	private List<ParsedPersistenceXmlDescriptor> parsePersistenceXml(URL xmlUrl, Map integration) {
 		// todo : if implementing a "xml binding service" this should be part of it, binding persistence.xml : HHH-6145
 
 		final Document doc = loadUrl( xmlUrl );
 		final Element top = doc.getDocumentElement();
 
 		final List<ParsedPersistenceXmlDescriptor> persistenceUnits = new ArrayList<ParsedPersistenceXmlDescriptor>();
 
 		final NodeList children = top.getChildNodes();
 		for ( int i = 0; i < children.getLength() ; i++ ) {
 			if ( children.item( i ).getNodeType() == Node.ELEMENT_NODE ) {
 				final Element element = (Element) children.item( i );
 				final String tag = element.getTagName();
 				if ( tag.equals( "persistence-unit" ) ) {
 					final URL puRootUrl = JarVisitorFactory.getJarURLFromURLEntry( xmlUrl, "/META-INF/persistence.xml" );
 					ParsedPersistenceXmlDescriptor persistenceUnit = new ParsedPersistenceXmlDescriptor( puRootUrl );
 					bindPersistenceUnit( persistenceUnit, element );
 
 					// per JPA spec, any settings passed in to PersistenceProvider bootstrap methods should override
 					// values found in persistence.xml
 					if ( integration.containsKey( AvailableSettings.PROVIDER ) ) {
 						persistenceUnit.setProviderClassName( (String) integration.get( AvailableSettings.PROVIDER ) );
 					}
 					if ( integration.containsKey( AvailableSettings.TRANSACTION_TYPE ) ) {
 						String transactionType = (String) integration.get( AvailableSettings.TRANSACTION_TYPE );
 						persistenceUnit.setTransactionType( parseTransactionType( transactionType ) );
 					}
 					if ( integration.containsKey( AvailableSettings.JTA_DATASOURCE ) ) {
 						persistenceUnit.setJtaDataSource( integration.get( AvailableSettings.JTA_DATASOURCE ) );
 					}
 					if ( integration.containsKey( AvailableSettings.NON_JTA_DATASOURCE ) ) {
 						persistenceUnit.setNonJtaDataSource( integration.get( AvailableSettings.NON_JTA_DATASOURCE ) );
 					}
 
 					decodeTransactionType( persistenceUnit );
 
 					Properties properties = persistenceUnit.getProperties();
 					ConfigurationHelper.overrideProperties( properties, integration );
 
 					persistenceUnits.add( persistenceUnit );
 				}
 			}
 		}
 		return persistenceUnits;
 	}
 
 	private void decodeTransactionType(ParsedPersistenceXmlDescriptor persistenceUnit) {
 		// if transaction type is set already
 		// 		use that value
 		// else
 		//		if JTA DS
 		//			use JTA
 		//		else if NOT JTA DS
 		//			use RESOURCE_LOCAL
 		//		else
 		//			use defaultTransactionType
 		if ( persistenceUnit.getTransactionType() != null ) {
 			return;
 		}
 
 		if ( persistenceUnit.getJtaDataSource() != null ) {
 			persistenceUnit.setTransactionType( PersistenceUnitTransactionType.JTA );
 		}
 		else if ( persistenceUnit.getNonJtaDataSource() != null ) {
 			persistenceUnit.setTransactionType( PersistenceUnitTransactionType.RESOURCE_LOCAL );
 		}
 		else {
 			persistenceUnit.setTransactionType( defaultTransactionType );
 		}
 	}
 
 	private void bindPersistenceUnit(ParsedPersistenceXmlDescriptor persistenceUnit, Element persistenceUnitElement) {
 		final String name = persistenceUnitElement.getAttribute( "name" );
 		if ( StringHelper.isNotEmpty( name ) ) {
             LOG.tracef( "Persistence unit name from persistence.xml : %s", name );
 			persistenceUnit.setName( name );
 		}
 
 		final PersistenceUnitTransactionType transactionType = parseTransactionType(
 				persistenceUnitElement.getAttribute( "transaction-type" )
 		);
 		if ( transactionType != null ) {
 			persistenceUnit.setTransactionType( transactionType );
 		}
 
 
 		NodeList children = persistenceUnitElement.getChildNodes();
 		for ( int i = 0; i < children.getLength() ; i++ ) {
 			if ( children.item( i ).getNodeType() == Node.ELEMENT_NODE ) {
 				Element element = (Element) children.item( i );
 				String tag = element.getTagName();
 				if ( tag.equals( "non-jta-data-source" ) ) {
 					persistenceUnit.setNonJtaDataSource( extractContent( element ) );
 				}
 				else if ( tag.equals( "jta-data-source" ) ) {
 					persistenceUnit.setJtaDataSource( extractContent( element ) );
 				}
 				else if ( tag.equals( "provider" ) ) {
 					persistenceUnit.setProviderClassName( extractContent( element ) );
 				}
 				else if ( tag.equals( "class" ) ) {
 					persistenceUnit.addClasses( extractContent( element ) );
 				}
 				else if ( tag.equals( "mapping-file" ) ) {
 					persistenceUnit.addMappingFiles( extractContent( element ) );
 				}
 				else if ( tag.equals( "jar-file" ) ) {
 					persistenceUnit.addJarFileUrl( JarVisitorFactory.getURLFromPath( extractContent( element ) ) );
 				}
 				else if ( tag.equals( "exclude-unlisted-classes" ) ) {
 					persistenceUnit.setExcludeUnlistedClasses( true );
 				}
 				else if ( tag.equals( "delimited-identifiers" ) ) {
 					persistenceUnit.setUseQuotedIdentifiers( true );
 				}
 				else if ( tag.equals( "validation-mode" ) ) {
 					persistenceUnit.setValidationMode( extractContent( element ) );
 				}
 				else if ( tag.equals( "shared-cache-mode" ) ) {
 					persistenceUnit.setSharedCacheMode( extractContent( element ) );
 				}
 				else if ( tag.equals( "properties" ) ) {
 					NodeList props = element.getChildNodes();
 					for ( int j = 0; j < props.getLength() ; j++ ) {
 						if ( props.item( j ).getNodeType() == Node.ELEMENT_NODE ) {
 							Element propElement = (Element) props.item( j );
 							if ( !"property".equals( propElement.getTagName() ) ) {
 								continue;
 							}
 							String propName = propElement.getAttribute( "name" ).trim();
 							String propValue = propElement.getAttribute( "value" ).trim();
 							if ( StringHelper.isEmpty( propValue ) ) {
 								//fall back to the natural (Hibernate) way of description
 								propValue = extractContent( propElement, "" );
 							}
 							persistenceUnit.getProperties().put( propName, propValue );
 						}
 					}
 				}
 			}
 		}
 	}
 
 	private static String extractContent(Element element) {
 		return extractContent( element, null );
 	}
 
 	private static String extractContent(Element element, String defaultStr) {
 		if ( element == null ) {
 			return defaultStr;
 		}
 
 		NodeList children = element.getChildNodes();
 		StringBuilder result = new StringBuilder("");
 		for ( int i = 0; i < children.getLength() ; i++ ) {
 			if ( children.item( i ).getNodeType() == Node.TEXT_NODE ||
 					children.item( i ).getNodeType() == Node.CDATA_SECTION_NODE ) {
 				result.append( children.item( i ).getNodeValue() );
 			}
 		}
 		return result.toString().trim();
 	}
 
 	private static PersistenceUnitTransactionType parseTransactionType(String value) {
 		if ( StringHelper.isEmpty( value ) ) {
 			return null;
 		}
 		else if ( value.equalsIgnoreCase( "JTA" ) ) {
 			return PersistenceUnitTransactionType.JTA;
 		}
 		else if ( value.equalsIgnoreCase( "RESOURCE_LOCAL" ) ) {
 			return PersistenceUnitTransactionType.RESOURCE_LOCAL;
 		}
 		else {
 			throw new PersistenceException( "Unknown persistence unit transaction type : " + value );
 		}
 	}
 
 	private Document loadUrl(URL xmlUrl) {
 		final String resourceName = xmlUrl.toExternalForm();
 		try {
 			URLConnection conn = xmlUrl.openConnection();
 			conn.setUseCaches( false ); //avoid JAR locking on Windows and Tomcat
 			try {
 				InputStream inputStream = conn.getInputStream();
 				try {
 					final InputSource inputSource = new InputSource( inputStream );
 					try {
 						DocumentBuilder documentBuilder = documentBuilderFactory().newDocumentBuilder();
 						try {
 							Document document = documentBuilder.parse( inputSource );
 							validate( document );
 							return document;
 						}
 						catch (SAXException e) {
 							throw new PersistenceException( "Unexpected error parsing [" + resourceName + "]", e );
 						}
 						catch (IOException e) {
 							throw new PersistenceException( "Unexpected error parsing [" + resourceName + "]", e );
 						}
 					}
 					catch (ParserConfigurationException e) {
 						throw new PersistenceException( "Unable to generate javax.xml.parsers.DocumentBuilder instance", e );
 					}
 				}
 				finally {
 					try {
 						inputStream.close();
 					}
 					catch (Exception ignored) {
 					}
 				}
 			}
 			catch (IOException e) {
 				throw new PersistenceException( "Unable to obtain input stream from [" + resourceName + "]", e );
 			}
 		}
 		catch (IOException e) {
 			throw new PersistenceException( "Unable to access [" + resourceName + "]", e );
 		}
 	}
 
 	private void validate(Document document) {
 		// todo : add ability to disable validation...
 
 		final Validator validator;
 		final String version = document.getDocumentElement().getAttribute( "version" );
 		if ( "2.1".equals( version ) ) {
 			validator = v21Schema().newValidator();
 		}
 		else if ( "2.0".equals( version ) ) {
 			validator = v2Schema().newValidator();
 		}
 		else if ( "1.0".equals(  version ) ) {
 			validator = v1Schema().newValidator();
 		}
 		else {
 			throw new PersistenceException( "Unrecognized persistence.xml version [" + version + "]" );
 		}
 
 		List<SAXException> errors = new ArrayList<SAXException>();
 		validator.setErrorHandler( new ErrorHandlerImpl( errors ) );
 		try {
 			validator.validate( new DOMSource( document ) );
 		}
 		catch (SAXException e) {
 			errors.add( e );
 		}
 		catch (IOException e) {
 			throw new PersistenceException( "Unable to validate persistence.xml", e );
 		}
 
 		if ( errors.size() != 0 ) {
 			//report all errors in the exception
 			StringBuilder errorMessage = new StringBuilder( );
 			for ( SAXException error : errors ) {
 				errorMessage.append( extractInfo( error ) ).append( '\n' );
 			}
 			throw new PersistenceException( "Invalid persistence.xml.\n" + errorMessage.toString() );
 		}
 	}
 
 	private DocumentBuilderFactory documentBuilderFactory;
 
 	private DocumentBuilderFactory documentBuilderFactory() {
 		if ( documentBuilderFactory == null ) {
 			documentBuilderFactory = buildDocumentBuilderFactory();
 		}
 		return documentBuilderFactory;
 	}
 
 	private DocumentBuilderFactory buildDocumentBuilderFactory() {
 		DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
 		documentBuilderFactory.setNamespaceAware( true );
 		return documentBuilderFactory;
 	}
 
 	private Schema v21Schema;
 
 	private Schema v21Schema() {
 		if ( v21Schema == null ) {
 			v21Schema = resolveLocalSchema( "org/hibernate/ejb/persistence_2_1.xsd" );
 		}
 		return v21Schema;
 	}
 
 	private Schema v2Schema;
 
 	private Schema v2Schema() {
 		if ( v2Schema == null ) {
 			v2Schema = resolveLocalSchema( "org/hibernate/jpa/persistence_2_0.xsd" );
 		}
 		return v2Schema;
 	}
 
 	private Schema v1Schema;
 
 	private Schema v1Schema() {
 		if ( v1Schema == null ) {
 			v1Schema = resolveLocalSchema( "org/hibernate/jpa/persistence_1_0.xsd" );
 		}
 		return v1Schema;
 	}
 
 
 	private Schema resolveLocalSchema(String schemaName) {
 		// These XSD resources should be available on the Hibernate ClassLoader
 		final URL url = classLoaderService.locateResource( schemaName );
 		if ( url == null ) {
 			throw new XsdException( "Unable to locate schema [" + schemaName + "] via classpath", schemaName );
 		}
 		try {
 			InputStream schemaStream = url.openStream();
 			try {
 				StreamSource source = new StreamSource( url.openStream() );
 				SchemaFactory schemaFactory = SchemaFactory.newInstance( XMLConstants.W3C_XML_SCHEMA_NS_URI );
 				return schemaFactory.newSchema( source );
 			}
 			catch ( SAXException e ) {
 				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
 			}
 			catch ( IOException e ) {
 				throw new XsdException( "Unable to load schema [" + schemaName + "]", e, schemaName );
 			}
 			finally {
 				try {
 					schemaStream.close();
 				}
 				catch ( IOException e ) {
 					LOG.debugf( "Problem closing schema stream [%s]", e.toString() );
 				}
 			}
 		}
 		catch ( IOException e ) {
 			throw new XsdException( "Stream error handling schema url [" + url.toExternalForm() + "]", schemaName );
 		}
 	}
 
 
 	public static class ErrorHandlerImpl implements ErrorHandler {
 		private List<SAXException> errors;
 
 		ErrorHandlerImpl(List<SAXException> errors) {
 			this.errors = errors;
 		}
 
 		public void error(SAXParseException error) {
 			errors.add( error );
 		}
 
 		public void fatalError(SAXParseException error) {
 			errors.add( error );
 		}
 
 		public void warning(SAXParseException warn) {
 			LOG.trace( extractInfo( warn ) );
 		}
 	}
 
 	private static String extractInfo(SAXException error) {
 		if ( error instanceof SAXParseException ) {
 			return "Error parsing XML [line : " + ( (SAXParseException) error ).getLineNumber()
 					+ ", column : " + ( (SAXParseException) error ).getColumnNumber()
 					+ "] : " + error.getMessage();
 		}
 		else {
 			return "Error parsing XML : " + error.getMessage();
 		}
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/internal/jpa/CallbackProcessorImpl.java b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/internal/jpa/CallbackProcessorImpl.java
index cdbdb2569d..37c8c0a814 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/internal/jpa/CallbackProcessorImpl.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/internal/jpa/CallbackProcessorImpl.java
@@ -1,165 +1,164 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jpa.event.internal.jpa;
 
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.MappingException;
 import org.hibernate.jpa.event.spi.jpa.Callback;
-import org.hibernate.jpa.event.spi.jpa.CallbackRegistry;
 import org.hibernate.jpa.event.spi.jpa.ListenerFactory;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.metamodel.source.binder.JpaCallbackClass;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
-import org.hibernate.service.classloading.spi.ClassLoadingException;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoadingException;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * @author Steve Ebersole
  */
 public class CallbackProcessorImpl implements CallbackProcessor {
 	private static final Logger log = Logger.getLogger( CallbackProcessorImpl.class );
 
 	private final ListenerFactory jpaListenerFactory;
 	private final MetadataImplementor metadata;
 
 	private final ClassLoaderService classLoaderService;
 
 	public CallbackProcessorImpl(
 			ListenerFactory jpaListenerFactory,
 			MetadataImplementor metadata,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		this.jpaListenerFactory = jpaListenerFactory;
 		this.metadata = metadata;
 		this.classLoaderService = serviceRegistry.getService( ClassLoaderService.class );
 	}
 
 	@Override
 	public void processCallbacksForEntity(Object entityObject, CallbackRegistryImpl callbackRegistry) {
 		final EntityBinding entityBinding = (EntityBinding) entityObject;
 		final String entityClassName = entityBinding.getEntity().getClassName();
 		if ( entityClassName == null ) {
 			return;
 		}
 
 		try {
 			final Class entityClass = classLoaderService.classForName( entityClassName );
 			for ( Class annotationClass : CALLBACK_ANNOTATION_CLASSES ) {
 				callbackRegistry.addEntityCallbacks(
 						entityClass,
 						annotationClass,
 						collectCallbacks( entityBinding, entityClass, annotationClass )
 				);
 			}
 		}
 		catch (ClassLoadingException e) {
 			throw new MappingException( "entity class not found: " + entityClassName, e );
 		}
 	}
 
 	private Callback[] collectCallbacks(EntityBinding entityBinding, Class entityClass, Class annotationClass) {
 		final List<Callback> callbacks = new ArrayList<Callback>();
 		for ( JpaCallbackClass jpaCallbackClass : entityBinding.getJpaCallbackClasses() ) {
 			final Class listenerClass = classLoaderService.classForName( jpaCallbackClass.getName() );
 			final String methodName = jpaCallbackClass.getCallbackMethod( annotationClass );
 
 			log.debugf(
 					"Adding $s.%s as %s callback for entity %s",
 					listenerClass.getName(),
 					methodName,
 					annotationClass.getName(),
 					entityClass.getName()
 			);
 
 			final Callback callback = jpaCallbackClass.isListener()
 					? createListenerCallback( listenerClass, entityClass, methodName )
 					: createBeanCallback( listenerClass, methodName );
 			assert callback != null;
 			callbacks.add(callback);
 		}
 		return callbacks.toArray(new Callback[callbacks.size()]);
 	}
 
 	private Callback createListenerCallback(
 			Class listenerClass,
 			Class entityClass,
 			String methodName ) {
 		final Class<?> callbackSuperclass = listenerClass.getSuperclass();
 		if ( callbackSuperclass != null ) {
 			Callback callback = createListenerCallback( entityClass, callbackSuperclass, methodName );
 			if ( callback != null ) {
 				return callback;
 			}
 		}
 
 		final Object listenerInstance = jpaListenerFactory.buildListener( listenerClass );
 		for ( Method method : listenerClass.getDeclaredMethods() ) {
 			if ( !method.getName().equals(methodName) ) {
 				continue;
 			}
 
 			final Class<?>[] argTypes = method.getParameterTypes();
 			if (argTypes.length != 1) {
 				continue;
 			}
 
 			final Class<?> argType = argTypes[0];
 			if (argType != Object.class && argType != entityClass) {
 				continue;
 			}
 			if (!method.isAccessible()) {
 				method.setAccessible( true );
 			}
 
 			return new ListenerCallback( listenerInstance, method );
 		}
 		return null;
 	}
 
 	private Callback createBeanCallback( Class<?> callbackClass,
 												String methodName ) {
 		Class<?> callbackSuperclass = callbackClass.getSuperclass();
 		if (callbackSuperclass != null) {
 			Callback callback = createBeanCallback(callbackSuperclass, methodName);
 			if (callback != null) return callback;
 		}
 		for (Method method : callbackClass.getDeclaredMethods()) {
 			if (!method.getName().equals(methodName)) continue;
 			if (method.getParameterTypes().length != 0) continue;
 			if (!method.isAccessible()) method.setAccessible(true);
 			return new EntityCallback(method);
 		}
 		return null;
 	}
 
 	@Override
 	public void release() {
 		//To change body of implemented methods use File | Settings | File Templates.
 	}
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/spi/JpaIntegrator.java b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/spi/JpaIntegrator.java
index 0c05b5b9fb..41649e42d6 100644
--- a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/spi/JpaIntegrator.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/event/spi/JpaIntegrator.java
@@ -1,361 +1,360 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jpa.event.spi;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 import java.util.Iterator;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.spi.CascadeStyles;
 import org.hibernate.engine.spi.CascadingAction;
 import org.hibernate.engine.spi.CascadingActions;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.event.service.spi.DuplicationStrategy;
 import org.hibernate.event.service.spi.EventListenerGroup;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.jpa.AvailableSettings;
 import org.hibernate.jpa.event.internal.core.HibernateEntityManagerEventListener;
 import org.hibernate.jpa.event.internal.core.JpaAutoFlushEventListener;
 import org.hibernate.jpa.event.internal.core.JpaDeleteEventListener;
 import org.hibernate.jpa.event.internal.core.JpaFlushEntityEventListener;
 import org.hibernate.jpa.event.internal.core.JpaFlushEventListener;
 import org.hibernate.jpa.event.internal.core.JpaMergeEventListener;
 import org.hibernate.jpa.event.internal.core.JpaPersistEventListener;
 import org.hibernate.jpa.event.internal.core.JpaPersistOnFlushEventListener;
 import org.hibernate.jpa.event.internal.core.JpaPostDeleteEventListener;
 import org.hibernate.jpa.event.internal.core.JpaPostInsertEventListener;
 import org.hibernate.jpa.event.internal.core.JpaPostLoadEventListener;
 import org.hibernate.jpa.event.internal.core.JpaPostUpdateEventListener;
 import org.hibernate.jpa.event.internal.core.JpaSaveEventListener;
 import org.hibernate.jpa.event.internal.core.JpaSaveOrUpdateEventListener;
-import org.hibernate.jpa.event.internal.jpa.BeanManagerListenerFactory;
 import org.hibernate.jpa.event.internal.jpa.CallbackProcessor;
 import org.hibernate.jpa.event.internal.jpa.CallbackProcessorImpl;
 import org.hibernate.jpa.event.internal.jpa.CallbackRegistryConsumer;
 import org.hibernate.jpa.event.internal.jpa.CallbackRegistryImpl;
 import org.hibernate.jpa.event.internal.jpa.LegacyCallbackProcessor;
 import org.hibernate.jpa.event.spi.jpa.ListenerFactory;
 import org.hibernate.jpa.event.internal.jpa.StandardListenerFactory;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.metamodel.binding.EntityBinding;
 import org.hibernate.metamodel.source.MetadataImplementor;
 import org.hibernate.secure.internal.JACCPreDeleteEventListener;
 import org.hibernate.secure.internal.JACCPreInsertEventListener;
 import org.hibernate.secure.internal.JACCPreLoadEventListener;
 import org.hibernate.secure.internal.JACCPreUpdateEventListener;
 import org.hibernate.secure.internal.JACCSecurityListener;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.service.spi.ServiceRegistryImplementor;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * Hibernate EntityManager specific Integrator, performing JPA setup.
  *
  * @author Steve Ebersole
  */
 public class JpaIntegrator implements Integrator {
 	private ListenerFactory jpaListenerFactory;
 	private CallbackProcessor callbackProcessor;
 	private CallbackRegistryImpl callbackRegistry;
 
 	private static final DuplicationStrategy JPA_DUPLICATION_STRATEGY = new DuplicationStrategy() {
 		@Override
 		public boolean areMatch(Object listener, Object original) {
 			return listener.getClass().equals( original.getClass() ) &&
 					HibernateEntityManagerEventListener.class.isInstance( original );
 		}
 
 		@Override
 		public Action getAction() {
 			return Action.KEEP_ORIGINAL;
 		}
 	};
 
 	private static final DuplicationStrategy JACC_DUPLICATION_STRATEGY = new DuplicationStrategy() {
 		@Override
 		public boolean areMatch(Object listener, Object original) {
 			return listener.getClass().equals( original.getClass() ) &&
 					JACCSecurityListener.class.isInstance( original );
 		}
 
 		@Override
 		public Action getAction() {
 			return Action.KEEP_ORIGINAL;
 		}
 	};
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public void integrate(
 			Configuration configuration,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		// first, register the JPA-specific persist cascade style
 		CascadeStyles.registerCascadeStyle(
 				"persist",
 				new CascadeStyles.BaseCascadeStyle() {
 					@Override
 					public boolean doCascade(CascadingAction action) {
 						return action == JpaPersistEventListener.PERSIST_SKIPLAZY
 								|| action == CascadingActions.PERSIST_ON_FLUSH;
 					}
 
 					@Override
 					public String toString() {
 						return "STYLE_PERSIST_SKIPLAZY";
 					}
 				}
 		);
 
 
 		// then prepare listeners
 		final EventListenerRegistry eventListenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 
 		boolean isSecurityEnabled = configuration.getProperties().containsKey( AvailableSettings.JACC_ENABLED );
 
 		eventListenerRegistry.addDuplicationStrategy( JPA_DUPLICATION_STRATEGY );
 		eventListenerRegistry.addDuplicationStrategy( JACC_DUPLICATION_STRATEGY );
 
 		// op listeners
 		eventListenerRegistry.setListeners( EventType.AUTO_FLUSH, JpaAutoFlushEventListener.INSTANCE );
 		eventListenerRegistry.setListeners( EventType.DELETE, new JpaDeleteEventListener() );
 		eventListenerRegistry.setListeners( EventType.FLUSH_ENTITY, new JpaFlushEntityEventListener() );
 		eventListenerRegistry.setListeners( EventType.FLUSH, JpaFlushEventListener.INSTANCE );
 		eventListenerRegistry.setListeners( EventType.MERGE, new JpaMergeEventListener() );
 		eventListenerRegistry.setListeners( EventType.PERSIST, new JpaPersistEventListener() );
 		eventListenerRegistry.setListeners( EventType.PERSIST_ONFLUSH, new JpaPersistOnFlushEventListener() );
 		eventListenerRegistry.setListeners( EventType.SAVE, new JpaSaveEventListener() );
 		eventListenerRegistry.setListeners( EventType.SAVE_UPDATE, new JpaSaveOrUpdateEventListener() );
 
 		// pre op listeners
 		if ( isSecurityEnabled ) {
 			final String jaccContextId = configuration.getProperty( Environment.JACC_CONTEXTID );
 			eventListenerRegistry.prependListeners( EventType.PRE_DELETE, new JACCPreDeleteEventListener(jaccContextId) );
 			eventListenerRegistry.prependListeners( EventType.PRE_INSERT, new JACCPreInsertEventListener(jaccContextId) );
 			eventListenerRegistry.prependListeners( EventType.PRE_UPDATE, new JACCPreUpdateEventListener(jaccContextId) );
 			eventListenerRegistry.prependListeners( EventType.PRE_LOAD, new JACCPreLoadEventListener(jaccContextId) );
 		}
 
 		// post op listeners
 		eventListenerRegistry.prependListeners( EventType.POST_DELETE, new JpaPostDeleteEventListener() );
 		eventListenerRegistry.prependListeners( EventType.POST_INSERT, new JpaPostInsertEventListener() );
 		eventListenerRegistry.prependListeners( EventType.POST_LOAD, new JpaPostLoadEventListener() );
 		eventListenerRegistry.prependListeners( EventType.POST_UPDATE, new JpaPostUpdateEventListener() );
 
 		for ( Map.Entry<?,?> entry : configuration.getProperties().entrySet() ) {
 			if ( ! String.class.isInstance( entry.getKey() ) ) {
 				continue;
 			}
 			final String propertyName = (String) entry.getKey();
 			if ( ! propertyName.startsWith( AvailableSettings.EVENT_LISTENER_PREFIX ) ) {
 				continue;
 			}
 			final String eventTypeName = propertyName.substring( AvailableSettings.EVENT_LISTENER_PREFIX.length() + 1 );
 			final EventType eventType = EventType.resolveEventTypeByName( eventTypeName );
 			final EventListenerGroup eventListenerGroup = eventListenerRegistry.getEventListenerGroup( eventType );
 			for ( String listenerImpl : ( (String) entry.getValue() ).split( " ," ) ) {
 				eventListenerGroup.appendListener( instantiate( listenerImpl, serviceRegistry ) );
 			}
 		}
 
 		// handle JPA "entity listener classes"...
 
 		this.callbackRegistry = new CallbackRegistryImpl();
 		final Object beanManagerRef = configuration.getProperties().get( AvailableSettings.CDI_BEAN_MANAGER );
 		this.jpaListenerFactory = beanManagerRef == null
 				? new StandardListenerFactory()
 				: buildBeanManagerListenerFactory( beanManagerRef );
 		this.callbackProcessor = new LegacyCallbackProcessor( jpaListenerFactory, configuration.getReflectionManager() );
 
 		Iterator classes = configuration.getClassMappings();
 		while ( classes.hasNext() ) {
 			final PersistentClass clazz = (PersistentClass) classes.next();
 			if ( clazz.getClassName() == null ) {
 				// we can have non java class persisted by hibernate
 				continue;
 			}
 			callbackProcessor.processCallbacksForEntity( clazz.getClassName(), callbackRegistry );
 		}
 
 		for ( EventType eventType : EventType.values() ) {
 			final EventListenerGroup eventListenerGroup = eventListenerRegistry.getEventListenerGroup( eventType );
 			for ( Object listener : eventListenerGroup.listeners() ) {
 				if ( CallbackRegistryConsumer.class.isInstance( listener ) ) {
 					( (CallbackRegistryConsumer) listener ).injectCallbackRegistry( callbackRegistry );
 				}
 			}
 		}
 	}
 
 	private ListenerFactory buildBeanManagerListenerFactory(Object beanManagerRef) {
 		try {
 			// specifically using our classloader here...
 			final Class beanManagerListenerFactoryClass = getClass().getClassLoader()
 					.loadClass( "org.hibernate.jpa.event.internal.jpa.BeanManagerListenerFactory" );
 			final Method beanManagerListenerFactoryBuilderMethod = beanManagerListenerFactoryClass.getMethod(
 					"fromBeanManagerReference",
 					Object.class
 			);
 
 			try {
 				return (ListenerFactory) beanManagerListenerFactoryBuilderMethod.invoke( null, beanManagerRef );
 			}
 			catch (InvocationTargetException e) {
 				throw e.getTargetException();
 			}
 		}
 		catch (ReflectiveOperationException e) {
 			throw new HibernateException( "Could not access BeanManagerListenerFactory class to handle CDI extensions", e );
 		}
 		catch (RuntimeException e) {
 			throw e;
 		}
 		catch (Throwable e) {
 			throw new HibernateException( "Problem calling BeanManagerListenerFactory class to handle CDI extensions", e );
 		}
 	}
 
 	@Override
 	public void integrate(
 			MetadataImplementor metadata,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry ) {
 		// first, register the JPA-specific persist cascade style
 		CascadeStyles.registerCascadeStyle(
 				"persist",
 				new CascadeStyles.BaseCascadeStyle() {
 					@Override
 					public boolean doCascade(CascadingAction action) {
 						return action == JpaPersistEventListener.PERSIST_SKIPLAZY
 								|| action == CascadingActions.PERSIST_ON_FLUSH;
 					}
 
 					@Override
 					public String toString() {
 						return "STYLE_PERSIST_SKIPLAZY";
 					}
 				}
 		);
 
 		// then prepare listeners
         final EventListenerRegistry eventListenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 
         boolean isSecurityEnabled = sessionFactory.getProperties().containsKey( AvailableSettings.JACC_ENABLED );
 
         eventListenerRegistry.addDuplicationStrategy( JPA_DUPLICATION_STRATEGY );
         eventListenerRegistry.addDuplicationStrategy( JACC_DUPLICATION_STRATEGY );
 
         // op listeners
         eventListenerRegistry.setListeners( EventType.AUTO_FLUSH, JpaAutoFlushEventListener.INSTANCE );
         eventListenerRegistry.setListeners( EventType.DELETE, new JpaDeleteEventListener() );
         eventListenerRegistry.setListeners( EventType.FLUSH_ENTITY, new JpaFlushEntityEventListener() );
         eventListenerRegistry.setListeners( EventType.FLUSH, JpaFlushEventListener.INSTANCE );
         eventListenerRegistry.setListeners( EventType.MERGE, new JpaMergeEventListener() );
         eventListenerRegistry.setListeners( EventType.PERSIST, new JpaPersistEventListener() );
         eventListenerRegistry.setListeners( EventType.PERSIST_ONFLUSH, new JpaPersistOnFlushEventListener() );
         eventListenerRegistry.setListeners( EventType.SAVE, new JpaSaveEventListener() );
         eventListenerRegistry.setListeners( EventType.SAVE_UPDATE, new JpaSaveOrUpdateEventListener() );
 
         // pre op listeners
         if ( isSecurityEnabled ) {
             final String jaccContextId = sessionFactory.getProperties().getProperty( Environment.JACC_CONTEXTID );
             eventListenerRegistry.prependListeners( EventType.PRE_DELETE, new JACCPreDeleteEventListener(jaccContextId) );
             eventListenerRegistry.prependListeners( EventType.PRE_INSERT, new JACCPreInsertEventListener(jaccContextId) );
             eventListenerRegistry.prependListeners( EventType.PRE_UPDATE, new JACCPreUpdateEventListener(jaccContextId) );
             eventListenerRegistry.prependListeners( EventType.PRE_LOAD, new JACCPreLoadEventListener(jaccContextId) );
         }
 
         // post op listeners
         eventListenerRegistry.prependListeners( EventType.POST_DELETE, new JpaPostDeleteEventListener() );
         eventListenerRegistry.prependListeners( EventType.POST_INSERT, new JpaPostInsertEventListener() );
         eventListenerRegistry.prependListeners( EventType.POST_LOAD, new JpaPostLoadEventListener() );
         eventListenerRegistry.prependListeners( EventType.POST_UPDATE, new JpaPostUpdateEventListener() );
 
         for ( Map.Entry<?,?> entry : sessionFactory.getProperties().entrySet() ) {
             if ( ! String.class.isInstance( entry.getKey() ) ) {
                 continue;
             }
             final String propertyName = (String) entry.getKey();
             if ( ! propertyName.startsWith( AvailableSettings.EVENT_LISTENER_PREFIX ) ) {
                 continue;
             }
             final String eventTypeName = propertyName.substring( AvailableSettings.EVENT_LISTENER_PREFIX.length() + 1 );
             final EventType eventType = EventType.resolveEventTypeByName( eventTypeName );
             final EventListenerGroup eventListenerGroup = eventListenerRegistry.getEventListenerGroup( eventType );
             for ( String listenerImpl : ( (String) entry.getValue() ).split( " ," ) ) {
                 eventListenerGroup.appendListener( instantiate( listenerImpl, serviceRegistry ) );
             }
         }
 
 		// handle JPA "entity listener classes"...
 
 		this.callbackRegistry = new CallbackRegistryImpl();
 		final Object beanManagerRef = sessionFactory.getProperties().get( AvailableSettings.CDI_BEAN_MANAGER );
 		this.jpaListenerFactory = beanManagerRef == null
 				? new StandardListenerFactory()
 				: buildBeanManagerListenerFactory( beanManagerRef );
 		this.callbackProcessor = new CallbackProcessorImpl( jpaListenerFactory, metadata, serviceRegistry );
 
         for ( EntityBinding binding : metadata.getEntityBindings() ) {
 			callbackProcessor.processCallbacksForEntity( binding, callbackRegistry );
         }
 
         for ( EventType eventType : EventType.values() ) {
             final EventListenerGroup eventListenerGroup = eventListenerRegistry.getEventListenerGroup( eventType );
             for ( Object listener : eventListenerGroup.listeners() ) {
                 if ( CallbackRegistryConsumer.class.isInstance( listener ) ) {
                     ( (CallbackRegistryConsumer) listener ).injectCallbackRegistry( callbackRegistry );
                 }
             }
         }
 	}
 
 	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 		if ( callbackRegistry != null ) {
 			callbackRegistry.release();
 		}
 		if ( callbackProcessor != null ) {
 			callbackProcessor.release();
 		}
 		if ( jpaListenerFactory != null ) {
 			jpaListenerFactory.release();
 		}
 	}
 
 	private Object instantiate(String listenerImpl, ServiceRegistryImplementor serviceRegistry) {
 		try {
 			return serviceRegistry.getService( ClassLoaderService.class ).classForName( listenerImpl ).newInstance();
 		}
 		catch (Exception e) {
 			throw new HibernateException( "Could not instantiate requested listener [" + listenerImpl + "]", e );
         }
     }
 }
diff --git a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/spi/AbstractEntityManagerImpl.java b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/spi/AbstractEntityManagerImpl.java
index a81080cb9b..74d2444f5e 100755
--- a/hibernate-entitymanager/src/main/java/org/hibernate/jpa/spi/AbstractEntityManagerImpl.java
+++ b/hibernate-entitymanager/src/main/java/org/hibernate/jpa/spi/AbstractEntityManagerImpl.java
@@ -1,1128 +1,1128 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jpa.spi;
 
 import javax.persistence.CacheRetrieveMode;
 import javax.persistence.CacheStoreMode;
 import javax.persistence.EntityExistsException;
 import javax.persistence.EntityManager;
 import javax.persistence.EntityNotFoundException;
 import javax.persistence.EntityTransaction;
 import javax.persistence.FlushModeType;
 import javax.persistence.LockModeType;
 import javax.persistence.LockTimeoutException;
 import javax.persistence.NoResultException;
 import javax.persistence.NonUniqueResultException;
 import javax.persistence.OptimisticLockException;
 import javax.persistence.PersistenceContextType;
 import javax.persistence.PersistenceException;
 import javax.persistence.PessimisticLockException;
 import javax.persistence.PessimisticLockScope;
 import javax.persistence.Query;
 import javax.persistence.QueryTimeoutException;
 import javax.persistence.StoredProcedureQuery;
 import javax.persistence.SynchronizationType;
 import javax.persistence.TransactionRequiredException;
 import javax.persistence.Tuple;
 import javax.persistence.TupleElement;
 import javax.persistence.TypedQuery;
 import javax.persistence.criteria.CriteriaBuilder;
 import javax.persistence.criteria.CriteriaDelete;
 import javax.persistence.criteria.CriteriaQuery;
 import javax.persistence.criteria.CriteriaUpdate;
 import javax.persistence.criteria.Selection;
 import javax.persistence.metamodel.Metamodel;
 import javax.persistence.spi.PersistenceUnitTransactionType;
 import javax.transaction.Status;
 import javax.transaction.SystemException;
 import javax.transaction.TransactionManager;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.io.Serializable;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.AssertionFailure;
 import org.hibernate.CacheMode;
 import org.hibernate.FlushMode;
 import org.hibernate.HibernateException;
 import org.hibernate.LockMode;
 import org.hibernate.LockOptions;
 import org.hibernate.MappingException;
 import org.hibernate.ObjectDeletedException;
 import org.hibernate.ObjectNotFoundException;
 import org.hibernate.QueryException;
 import org.hibernate.SQLQuery;
 import org.hibernate.Session;
 import org.hibernate.StaleObjectStateException;
 import org.hibernate.StaleStateException;
 import org.hibernate.StoredProcedureCall;
 import org.hibernate.TransientObjectException;
 import org.hibernate.TypeMismatchException;
 import org.hibernate.UnresolvableObjectException;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.NotYetImplementedException;
 import org.hibernate.dialect.lock.LockingStrategyException;
 import org.hibernate.dialect.lock.OptimisticEntityLockException;
 import org.hibernate.dialect.lock.PessimisticEntityLockException;
 import org.hibernate.engine.ResultSetMappingDefinition;
 import org.hibernate.engine.query.spi.HQLQueryPlan;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryReturn;
 import org.hibernate.engine.query.spi.sql.NativeSQLQueryRootReturn;
 import org.hibernate.engine.spi.NamedSQLQueryDefinition;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
 import org.hibernate.engine.transaction.spi.JoinStatus;
 import org.hibernate.engine.transaction.spi.TransactionCoordinator;
 import org.hibernate.engine.transaction.spi.TransactionImplementor;
 import org.hibernate.engine.transaction.synchronization.spi.AfterCompletionAction;
 import org.hibernate.engine.transaction.synchronization.spi.ExceptionMapper;
 import org.hibernate.engine.transaction.synchronization.spi.ManagedFlushChecker;
 import org.hibernate.engine.transaction.synchronization.spi.SynchronizationCallbackCoordinator;
 import org.hibernate.internal.util.ReflectHelper;
 import org.hibernate.internal.util.collections.CollectionHelper;
 import org.hibernate.jpa.AvailableSettings;
 import org.hibernate.jpa.HibernateEntityManagerFactory;
 import org.hibernate.jpa.QueryHints;
 import org.hibernate.jpa.criteria.ValueHandlerFactory;
 import org.hibernate.jpa.criteria.compile.CompilableCriteria;
 import org.hibernate.jpa.criteria.compile.CriteriaCompiler;
 import org.hibernate.jpa.criteria.expression.CompoundSelectionImpl;
 import org.hibernate.jpa.internal.EntityManagerFactoryImpl;
 import org.hibernate.jpa.internal.EntityManagerMessageLogger;
 import org.hibernate.jpa.internal.QueryImpl;
 import org.hibernate.jpa.internal.StoredProcedureQueryImpl;
 import org.hibernate.jpa.internal.TransactionImpl;
 import org.hibernate.jpa.internal.util.CacheModeHelper;
 import org.hibernate.jpa.internal.util.ConfigurationHelper;
 import org.hibernate.jpa.internal.util.LockModeTypeHelper;
 import org.hibernate.proxy.HibernateProxy;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.transform.BasicTransformerAdapter;
 import org.hibernate.type.Type;
 
 
 /**
  * @author <a href="mailto:gavin@hibernate.org">Gavin King</a>
  * @author Emmanuel Bernard
  * @author Steve Ebersole
  * @author Hardy Ferentschik
  */
 @SuppressWarnings("unchecked")
 public abstract class AbstractEntityManagerImpl implements HibernateEntityManagerImplementor, Serializable {
 	private static final long serialVersionUID = 78818181L;
 
     private static final EntityManagerMessageLogger LOG = Logger.getMessageLogger(EntityManagerMessageLogger.class,
                                                                            AbstractEntityManagerImpl.class.getName());
 
 	private static final List<String> entityManagerSpecificProperties = new ArrayList<String>();
 
 	static {
 		entityManagerSpecificProperties.add( AvailableSettings.LOCK_SCOPE );
 		entityManagerSpecificProperties.add( AvailableSettings.LOCK_TIMEOUT );
 		entityManagerSpecificProperties.add( AvailableSettings.FLUSH_MODE );
 		entityManagerSpecificProperties.add( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE );
 		entityManagerSpecificProperties.add( AvailableSettings.SHARED_CACHE_STORE_MODE );
 		entityManagerSpecificProperties.add( QueryHints.SPEC_HINT_TIMEOUT );
 	}
 
 	private EntityManagerFactoryImpl entityManagerFactory;
 	protected transient TransactionImpl tx = new TransactionImpl( this );
 	protected PersistenceContextType persistenceContextType;
 	private SynchronizationType synchronizationType;
 	private PersistenceUnitTransactionType transactionType;
 	private Map<String, Object> properties;
 	private LockOptions lockOptions;
 
 	protected AbstractEntityManagerImpl(
 			EntityManagerFactoryImpl entityManagerFactory,
 			PersistenceContextType type,
 			SynchronizationType synchronizationType,
 			PersistenceUnitTransactionType transactionType,
 			Map properties) {
 		this.entityManagerFactory = entityManagerFactory;
 		this.persistenceContextType = type;
 		this.synchronizationType = synchronizationType;
 		this.transactionType = transactionType;
 
 		this.lockOptions = new LockOptions();
 		this.properties = new HashMap<String, Object>();
 		for ( String key : entityManagerSpecificProperties ) {
 			if ( entityManagerFactory.getProperties().containsKey( key ) ) {
 				this.properties.put( key, entityManagerFactory.getProperties().get( key ) );
 			}
 			if ( properties != null && properties.containsKey( key ) ) {
 				this.properties.put( key, properties.get( key ) );
 			}
 		}
 	}
 
 //	protected PersistenceUnitTransactionType transactionType() {
 //		return transactionType;
 //	}
 //
 //	protected SynchronizationType synchronizationType() {
 //		return synchronizationType;
 //	}
 //
 //	public boolean shouldAutoJoinTransactions() {
 //		// the Session should auto join only if using non-JTA transactions or if the synchronization type
 //		// was specified as SYNCHRONIZED
 //		return transactionType != PersistenceUnitTransactionType.JTA
 //				|| synchronizationType == SynchronizationType.SYNCHRONIZED;
 //	}
 
 	public PersistenceUnitTransactionType getTransactionType() {
 		return transactionType;
 	}
 
 	protected void postInit() {
 		//register in Sync if needed
 		if ( transactionType == PersistenceUnitTransactionType.JTA
 				&& synchronizationType == SynchronizationType.SYNCHRONIZED ) {
 			joinTransaction( false );
 		}
 
 		setDefaultProperties();
 		applyProperties();
 	}
 
 	private void applyProperties() {
 		getSession().setFlushMode( ConfigurationHelper.getFlushMode( properties.get( AvailableSettings.FLUSH_MODE ) ) );
 		setLockOptions( this.properties, this.lockOptions );
 		getSession().setCacheMode(
 				CacheModeHelper.interpretCacheMode(
 						currentCacheStoreMode(),
 						currentCacheRetrieveMode()
 				)
 		);
 	}
 
 	private Query applyProperties(Query query) {
 		if ( lockOptions.getLockMode() != LockMode.NONE ) {
 			query.setLockMode( getLockMode(lockOptions.getLockMode()));
 		}
 		Object queryTimeout;
 		if ( (queryTimeout = getProperties().get(QueryHints.SPEC_HINT_TIMEOUT)) != null ) {
 			query.setHint ( QueryHints.SPEC_HINT_TIMEOUT, queryTimeout );
 		}
 		Object lockTimeout;
 		if( (lockTimeout = getProperties().get( AvailableSettings.LOCK_TIMEOUT ))!=null){
 			query.setHint( AvailableSettings.LOCK_TIMEOUT, lockTimeout );
 		}
 		return query;
 	}
 
 	private CacheRetrieveMode currentCacheRetrieveMode() {
 		return determineCacheRetrieveMode( properties );
 	}
 
 	private CacheRetrieveMode determineCacheRetrieveMode(Map<String, Object> settings) {
 		return ( CacheRetrieveMode ) settings.get( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE );
 	}
 
 	private CacheStoreMode currentCacheStoreMode() {
 		return determineCacheStoreMode( properties );
 	}
 
 	private CacheStoreMode determineCacheStoreMode(Map<String, Object> settings) {
 		return ( CacheStoreMode ) properties.get( AvailableSettings.SHARED_CACHE_STORE_MODE );
 	}
 
 	private void setLockOptions(Map<String, Object> props, LockOptions options) {
 		Object lockScope = props.get( AvailableSettings.LOCK_SCOPE );
 		if ( lockScope instanceof String && PessimisticLockScope.valueOf( ( String ) lockScope ) == PessimisticLockScope.EXTENDED ) {
 			options.setScope( true );
 		}
 		else if ( lockScope instanceof PessimisticLockScope ) {
 			boolean extended = PessimisticLockScope.EXTENDED.equals( lockScope );
 			options.setScope( extended );
 		}
 		else if ( lockScope != null ) {
 			throw new PersistenceException( "Unable to parse " + AvailableSettings.LOCK_SCOPE + ": " + lockScope );
 		}
 
 		Object lockTimeout = props.get( AvailableSettings.LOCK_TIMEOUT );
 		int timeout = 0;
 		boolean timeoutSet = false;
 		if ( lockTimeout instanceof String ) {
 			timeout = Integer.parseInt( ( String ) lockTimeout );
 			timeoutSet = true;
 		}
 		else if ( lockTimeout instanceof Number ) {
 			timeout = ( (Number) lockTimeout ).intValue();
 			timeoutSet = true;
 		}
 		else if ( lockTimeout != null ) {
 			throw new PersistenceException( "Unable to parse " + AvailableSettings.LOCK_TIMEOUT + ": " + lockTimeout );
 		}
 		if ( timeoutSet ) {
 			if ( timeout < 0 ) {
 				options.setTimeOut( LockOptions.WAIT_FOREVER );
 			}
 			else if ( timeout == 0 ) {
 				options.setTimeOut( LockOptions.NO_WAIT );
 			}
 			else {
 				options.setTimeOut( timeout );
 			}
 		}
 	}
 
 	/**
 	 * Sets the default property values for the properties the entity manager supports and which are not already explicitly
 	 * set.
 	 */
 	private void setDefaultProperties() {
 		if ( properties.get( AvailableSettings.FLUSH_MODE ) == null ) {
 			properties.put( AvailableSettings.FLUSH_MODE, getSession().getFlushMode().toString() );
 		}
 		if ( properties.get( AvailableSettings.LOCK_SCOPE ) == null ) {
 			this.properties.put( AvailableSettings.LOCK_SCOPE, PessimisticLockScope.EXTENDED.name() );
 		}
 		if ( properties.get( AvailableSettings.LOCK_TIMEOUT ) == null ) {
 			properties.put( AvailableSettings.LOCK_TIMEOUT, LockOptions.WAIT_FOREVER );
 		}
 		if ( properties.get( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE ) == null ) {
 			properties.put( AvailableSettings.SHARED_CACHE_RETRIEVE_MODE, CacheModeHelper.DEFAULT_RETRIEVE_MODE );
 		}
 		if ( properties.get( AvailableSettings.SHARED_CACHE_STORE_MODE ) == null ) {
 			properties.put( AvailableSettings.SHARED_CACHE_STORE_MODE, CacheModeHelper.DEFAULT_STORE_MODE );
 		}
 	}
 
 	public Query createQuery(String jpaqlString) {
 		try {
 			return applyProperties( new QueryImpl<Object>( getSession().createQuery( jpaqlString ), this ) );
 		}
 		catch ( HibernateException he ) {
 			throw convert( he );
 		}
 	}
 
 	public <T> TypedQuery<T> createQuery(String jpaqlString, Class<T> resultClass) {
 		try {
 			// do the translation
 			org.hibernate.Query hqlQuery = getSession().createQuery( jpaqlString );
 
 			resultClassChecking( resultClass, hqlQuery );
 
 			// finally, build/return the query instance
 			return new QueryImpl<T>( hqlQuery, this );
 		}
 		catch ( HibernateException he ) {
 			throw convert( he );
 		}
 	}
 
 	protected void resultClassChecking(Class resultClass, org.hibernate.Query hqlQuery) {
 		// make sure the query is a select -> HHH-7192
 		final SessionImplementor session = unwrap( SessionImplementor.class );
 		final HQLQueryPlan queryPlan = session.getFactory().getQueryPlanCache().getHQLQueryPlan(
 				hqlQuery.getQueryString(),
 				false,
 				session.getLoadQueryInfluencers().getEnabledFilters()
 		);
 		if ( queryPlan.getTranslators()[0].isManipulationStatement() ) {
 			throw new IllegalArgumentException( "Update/delete queries cannot be typed" );
 		}
 
 		// do some return type validation checking
 		if ( Object[].class.equals( resultClass ) ) {
 			// no validation needed
 		}
 		else if ( Tuple.class.equals( resultClass ) ) {
 			TupleBuilderTransformer tupleTransformer = new TupleBuilderTransformer( hqlQuery );
 			hqlQuery.setResultTransformer( tupleTransformer  );
 		}
 		else {
 			final Class dynamicInstantiationClass = queryPlan.getDynamicInstantiationResultType();
 			if ( dynamicInstantiationClass != null ) {
 				if ( ! resultClass.isAssignableFrom( dynamicInstantiationClass ) ) {
 					throw new IllegalArgumentException(
 							"Mismatch in requested result type [" + resultClass.getName() +
 									"] and actual result type [" + dynamicInstantiationClass.getName() + "]"
 					);
 				}
 			}
 			else if ( hqlQuery.getReturnTypes().length == 1 ) {
 				// if we have only a single return expression, its java type should match with the requested type
 				if ( !resultClass.isAssignableFrom( hqlQuery.getReturnTypes()[0].getReturnedClass() ) ) {
 					throw new IllegalArgumentException(
 							"Type specified for TypedQuery [" +
 									resultClass.getName() +
 									"] is incompatible with query return type [" +
 									hqlQuery.getReturnTypes()[0].getReturnedClass() + "]"
 					);
 				}
 			}
 			else {
 				throw new IllegalArgumentException(
 						"Cannot create TypedQuery for query with more than one return using requested result type [" +
 								resultClass.getName() + "]"
 				);
 			}
 		}
 	}
 
 	public static class TupleBuilderTransformer extends BasicTransformerAdapter {
 		private List<TupleElement<?>> tupleElements;
 		private Map<String,HqlTupleElementImpl> tupleElementsByAlias;
 
 		public TupleBuilderTransformer(org.hibernate.Query hqlQuery) {
 			final Type[] resultTypes = hqlQuery.getReturnTypes();
 			final int tupleSize = resultTypes.length;
 
 			this.tupleElements = CollectionHelper.arrayList( tupleSize );
 
 			final String[] aliases = hqlQuery.getReturnAliases();
 			final boolean hasAliases = aliases != null && aliases.length > 0;
 			this.tupleElementsByAlias = hasAliases
 					? CollectionHelper.<String, HqlTupleElementImpl>mapOfSize( tupleSize )
 					: Collections.<String, HqlTupleElementImpl>emptyMap();
 
 			for ( int i = 0; i < tupleSize; i++ ) {
 				final HqlTupleElementImpl tupleElement = new HqlTupleElementImpl(
 						i,
 						aliases == null ? null : aliases[i],
 						resultTypes[i]
 				);
 				tupleElements.add( tupleElement );
 				if ( hasAliases ) {
 					final String alias = aliases[i];
 					if ( alias != null ) {
 						tupleElementsByAlias.put( alias, tupleElement );
 					}
 				}
 			}
 		}
 
 		@Override
 		public Object transformTuple(Object[] tuple, String[] aliases) {
 			if ( tuple.length != tupleElements.size() ) {
 				throw new IllegalArgumentException(
 						"Size mismatch between tuple result [" + tuple.length + "] and expected tuple elements [" +
 								tupleElements.size() + "]"
 				);
 			}
 			return new HqlTupleImpl( tuple );
 		}
 
 		public static class HqlTupleElementImpl<X> implements TupleElement<X> {
 			private final int position;
 			private final String alias;
 			private final Type hibernateType;
 
 			public HqlTupleElementImpl(int position, String alias, Type hibernateType) {
 				this.position = position;
 				this.alias = alias;
 				this.hibernateType = hibernateType;
 			}
 
 			@Override
 			public Class getJavaType() {
 				return hibernateType.getReturnedClass();
 			}
 
 			@Override
 			public String getAlias() {
 				return alias;
 			}
 
 			public int getPosition() {
 				return position;
 			}
 
 			public Type getHibernateType() {
 				return hibernateType;
 			}
 		}
 
 		public class HqlTupleImpl implements Tuple {
 			private Object[] tuple;
 
 			public HqlTupleImpl(Object[] tuple) {
 				this.tuple = tuple;
 			}
 
 			@Override
 			public <X> X get(String alias, Class<X> type) {
 				return (X) get( alias );
 			}
 
 			@Override
 			public Object get(String alias) {
 				HqlTupleElementImpl tupleElement = tupleElementsByAlias.get( alias );
 				if ( tupleElement == null ) {
 					throw new IllegalArgumentException( "Unknown alias [" + alias + "]" );
 				}
 				return tuple[ tupleElement.getPosition() ];
 			}
 
 			@Override
 			public <X> X get(int i, Class<X> type) {
 				return (X) get( i );
 			}
 
 			@Override
 			public Object get(int i) {
 				if ( i < 0 ) {
 					throw new IllegalArgumentException( "requested tuple index must be greater than zero" );
 				}
 				if ( i > tuple.length ) {
 					throw new IllegalArgumentException( "requested tuple index exceeds actual tuple size" );
 				}
 				return tuple[i];
 			}
 
 			@Override
 			public Object[] toArray() {
 				// todo : make a copy?
 				return tuple;
 			}
 
 			@Override
 			public List<TupleElement<?>> getElements() {
 				return tupleElements;
 			}
 
 			@Override
 			public <X> X get(TupleElement<X> tupleElement) {
 				if ( HqlTupleElementImpl.class.isInstance( tupleElement ) ) {
 					return get( ( (HqlTupleElementImpl) tupleElement ).getPosition(), tupleElement.getJavaType() );
 				}
 				else {
 					return get( tupleElement.getAlias(), tupleElement.getJavaType() );
 				}
 			}
 		}
 	}
 
 	public <T> QueryImpl<T> createQuery(
 			String jpaqlString,
 			Class<T> resultClass,
 			Selection selection,
 			Options options) {
 		try {
 			org.hibernate.Query hqlQuery = getSession().createQuery( jpaqlString );
 
 			if ( options.getValueHandlers() == null ) {
 				if ( options.getResultMetadataValidator() != null ) {
 					options.getResultMetadataValidator().validate( hqlQuery.getReturnTypes() );
 				}
 			}
 
 			// determine if we need a result transformer
 			List tupleElements = Tuple.class.equals( resultClass )
 					? ( ( CompoundSelectionImpl<Tuple> ) selection ).getCompoundSelectionItems()
 					: null;
 			if ( options.getValueHandlers() != null || tupleElements != null ) {
 				hqlQuery.setResultTransformer(
 						new CriteriaQueryTransformer( options.getValueHandlers(), tupleElements )
 				);
 			}
 			return new QueryImpl<T>( hqlQuery, this, options.getNamedParameterExplicitTypes() );
 		}
 		catch ( HibernateException he ) {
 			throw convert( he );
 		}
 	}
 
 	private static class CriteriaQueryTransformer extends BasicTransformerAdapter {
 		private final List<ValueHandlerFactory.ValueHandler> valueHandlers;
 		private final List tupleElements;
 
 		private CriteriaQueryTransformer(List<ValueHandlerFactory.ValueHandler> valueHandlers, List tupleElements) {
 			// todo : should these 2 sizes match *always*?
 			this.valueHandlers = valueHandlers;
 			this.tupleElements = tupleElements;
 		}
 
 		@Override
 		public Object transformTuple(Object[] tuple, String[] aliases) {
 			final Object[] valueHandlerResult;
 			if ( valueHandlers == null ) {
 				valueHandlerResult = tuple;
 			}
 			else {
 				valueHandlerResult = new Object[tuple.length];
 				for ( int i = 0; i < tuple.length; i++ ) {
 					ValueHandlerFactory.ValueHandler valueHandler = valueHandlers.get( i );
 					valueHandlerResult[i] = valueHandler == null
 							? tuple[i]
 							: valueHandler.convert( tuple[i] );
 				}
 			}
 
 			return tupleElements == null
 					? valueHandlerResult.length == 1 ? valueHandlerResult[0] : valueHandlerResult
 					: new TupleImpl( tuple );
 
 		}
 
 		private class TupleImpl implements Tuple {
 			private final Object[] tuples;
 
 			private TupleImpl(Object[] tuples) {
 				if ( tuples.length != tupleElements.size() ) {
 					throw new IllegalArgumentException(
 							"Size mismatch between tuple result [" + tuples.length
 									+ "] and expected tuple elements [" + tupleElements.size() + "]"
 					);
 				}
 				this.tuples = tuples;
 			}
 
 			public <X> X get(TupleElement<X> tupleElement) {
 				int index = tupleElements.indexOf( tupleElement );
 				if ( index < 0 ) {
 					throw new IllegalArgumentException(
 							"Requested tuple element did not correspond to element in the result tuple"
 					);
 				}
 				// index should be "in range" by nature of size check in ctor
 				return ( X ) tuples[index];
 			}
 
 			public Object get(String alias) {
 				int index = -1;
 				if ( alias != null ) {
 					alias = alias.trim();
 					if ( alias.length() > 0 ) {
 						int i = 0;
 						for ( TupleElement selection : ( List<TupleElement> ) tupleElements ) {
 							if ( alias.equals( selection.getAlias() ) ) {
 								index = i;
 								break;
 							}
 							i++;
 						}
 					}
 				}
 				if ( index < 0 ) {
 					throw new IllegalArgumentException(
 							"Given alias [" + alias + "] did not correspond to an element in the result tuple"
 					);
 				}
 				// index should be "in range" by nature of size check in ctor
 				return tuples[index];
 			}
 
 			public <X> X get(String alias, Class<X> type) {
 				return ( X ) get( alias );
 			}
 
 			public Object get(int i) {
 				if ( i >= tuples.length ) {
 					throw new IllegalArgumentException(
 							"Given index [" + i + "] was outside the range of result tuple size [" + tuples.length + "] "
 					);
 				}
 				return tuples[i];
 			}
 
 			public <X> X get(int i, Class<X> type) {
 				return ( X ) get( i );
 			}
 
 			public Object[] toArray() {
 				return tuples;
 			}
 
 			public List<TupleElement<?>> getElements() {
 				return tupleElements;
 			}
 		}
 	}
 
 	private CriteriaCompiler criteriaCompiler;
 
 	protected CriteriaCompiler criteriaCompiler() {
 		if ( criteriaCompiler == null ) {
 			criteriaCompiler = new CriteriaCompiler( this );
 		}
 		return criteriaCompiler;
 	}
 
 	public <T> TypedQuery<T> createQuery(CriteriaQuery<T> criteriaQuery) {
 		return (TypedQuery<T>) criteriaCompiler().compile( (CompilableCriteria) criteriaQuery );
 	}
 
 	@Override
 	public Query createQuery(CriteriaUpdate criteriaUpdate) {
 		return criteriaCompiler().compile( (CompilableCriteria) criteriaUpdate );
 	}
 
 	@Override
 	public Query createQuery(CriteriaDelete criteriaDelete) {
 		return criteriaCompiler().compile( (CompilableCriteria) criteriaDelete );
 	}
 
 	public Query createNamedQuery(String name) {
 		try {
 			org.hibernate.Query namedQuery = getSession().getNamedQuery( name );
 			try {
 				return new QueryImpl( namedQuery, this );
 			}
 			catch ( HibernateException he ) {
 				throw convert( he );
 			}
 		}
 		catch ( MappingException e ) {
 			throw new IllegalArgumentException( "Named query not found: " + name );
 		}
 	}
 
 	public <T> TypedQuery<T> createNamedQuery(String name, Class<T> resultClass) {
 		try {
 			/*
 			 * Get the named query.
 			 * If the named query is a SQL query, get the expected returned type from the query definition
 			 * or its associated result set mapping
 			 * If the named query is a HQL query, use getReturnType()
 			 */
 			org.hibernate.Query namedQuery = getSession().getNamedQuery( name );
 			//TODO clean this up to avoid downcasting
 			final SessionFactoryImplementor factoryImplementor = entityManagerFactory.getSessionFactory();
 			final NamedSQLQueryDefinition queryDefinition = factoryImplementor.getNamedSQLQuery( name );
 			try {
 				if ( queryDefinition != null ) {
 					Class<?> actualReturnedClass;
 
 					final NativeSQLQueryReturn[] queryReturns;
 					if ( queryDefinition.getQueryReturns() != null ) {
 						queryReturns = queryDefinition.getQueryReturns();
 					}
 					else if ( queryDefinition.getResultSetRef() != null ) {
 						final ResultSetMappingDefinition rsMapping = factoryImplementor.getResultSetMapping(
 								queryDefinition.getResultSetRef()
 						);
 						queryReturns = rsMapping.getQueryReturns();
 					}
 					else {
 						throw new AssertionFailure( "Unsupported named query model. Please report the bug in Hibernate EntityManager");
 					}
 					if ( queryReturns.length > 1 ) {
 						throw new IllegalArgumentException( "Cannot create TypedQuery for query with more than one return" );
 					}
 					final NativeSQLQueryReturn nativeSQLQueryReturn = queryReturns[0];
 					if ( nativeSQLQueryReturn instanceof NativeSQLQueryRootReturn ) {
 						final String entityClassName = ( ( NativeSQLQueryRootReturn ) nativeSQLQueryReturn ).getReturnEntityName();
 						try {
 							actualReturnedClass = ReflectHelper.classForName( entityClassName, AbstractEntityManagerImpl.class );
 						}
 						catch ( ClassNotFoundException e ) {
 							throw new AssertionFailure( "Unable to instantiate class declared on named native query: " + name + " " + entityClassName );
 						}
 						if ( !resultClass.isAssignableFrom( actualReturnedClass ) ) {
 							throw buildIncompatibleException( resultClass, actualReturnedClass );
 						}
 					}
 					else {
 						//TODO support other NativeSQLQueryReturn type. For now let it go.
 					}
 				}
 				else {
 					resultClassChecking( resultClass, namedQuery );
 				}
 				return new QueryImpl<T>( namedQuery, this );
 			}
 			catch ( HibernateException he ) {
 				throw convert( he );
 			}
 		}
 		catch ( MappingException e ) {
 			throw new IllegalArgumentException( "Named query not found: " + name );
 		}
 	}
 
 	private IllegalArgumentException buildIncompatibleException(Class<?> resultClass, Class<?> actualResultClass) {
 		return new IllegalArgumentException(
 							"Type specified for TypedQuery [" +
 									resultClass.getName() +
 									"] is incompatible with query return type [" +
 									actualResultClass + "]"
 					);
 	}
 
 	public Query createNativeQuery(String sqlString) {
 		try {
 			SQLQuery q = getSession().createSQLQuery( sqlString );
 			return new QueryImpl( q, this );
 		}
 		catch ( HibernateException he ) {
 			throw convert( he );
 		}
 	}
 
 	public Query createNativeQuery(String sqlString, Class resultClass) {
 		try {
 			SQLQuery q = getSession().createSQLQuery( sqlString );
 			q.addEntity( "alias1", resultClass.getName(), LockMode.READ );
 			return new QueryImpl( q, this );
 		}
 		catch ( HibernateException he ) {
 			throw convert( he );
 		}
 	}
 
 	public Query createNativeQuery(String sqlString, String resultSetMapping) {
 		try {
 			SQLQuery q = getSession().createSQLQuery( sqlString );
 			q.setResultSetMapping( resultSetMapping );
 			return new QueryImpl( q, this );
 		}
 		catch ( HibernateException he ) {
 			throw convert( he );
 		}
 	}
 
 	@Override
 	public StoredProcedureQuery createNamedStoredProcedureQuery(String name) {
 		throw new NotYetImplementedException();
 	}
 
 	@Override
 	public StoredProcedureQuery createStoredProcedureQuery(String procedureName) {
 		try {
 			StoredProcedureCall call = getSession().createStoredProcedureCall( procedureName );
 			return new StoredProcedureQueryImpl( call, this );
 		}
 		catch ( HibernateException he ) {
 			throw convert( he );
 		}
 	}
 
 	@Override
 	public StoredProcedureQuery createStoredProcedureQuery(String procedureName, Class... resultClasses) {
 		try {
 			StoredProcedureCall call = getSession().createStoredProcedureCall( procedureName, resultClasses );
 			return new StoredProcedureQueryImpl( call, this );
 		}
 		catch ( HibernateException he ) {
 			throw convert( he );
 		}
 	}
 
 	@Override
 	public StoredProcedureQuery createStoredProcedureQuery(String procedureName, String... resultSetMappings) {
 		throw new NotYetImplementedException();
 	}
 
 	@SuppressWarnings("unchecked")
 	public <T> T getReference(Class<T> entityClass, Object primaryKey) {
 		try {
 			return ( T ) getSession().load( entityClass, ( Serializable ) primaryKey );
 		}
 		catch ( MappingException e ) {
 			throw new IllegalArgumentException( e.getMessage(), e );
 		}
 		catch ( TypeMismatchException e ) {
 			throw new IllegalArgumentException( e.getMessage(), e );
 		}
 		catch ( ClassCastException e ) {
 			throw new IllegalArgumentException( e.getMessage(), e );
 		}
 		catch ( HibernateException he ) {
 			throw convert( he );
 		}
 	}
 
 	@SuppressWarnings("unchecked")
 	public <A> A find(Class<A> entityClass, Object primaryKey) {
 		return find( entityClass, primaryKey, null, null );
 	}
 
 	public <T> T find(Class<T> entityClass, Object primaryKey, Map<String, Object> properties) {
 		return find( entityClass, primaryKey, null, properties );
 	}
 
 	@SuppressWarnings("unchecked")
 	public <A> A find(Class<A> entityClass, Object primaryKey, LockModeType lockModeType) {
 		return find( entityClass, primaryKey, lockModeType, null );
 	}
 
 	public <A> A find(Class<A> entityClass, Object primaryKey, LockModeType lockModeType, Map<String, Object> properties) {
 		CacheMode previousCacheMode = getSession().getCacheMode();
 		CacheMode cacheMode = determineAppropriateLocalCacheMode( properties );
 		LockOptions lockOptions = null;
 		try {
 			getSession().setCacheMode( cacheMode );
 			if ( lockModeType != null ) {
 				lockOptions = getLockRequest( lockModeType, properties );
 				return ( A ) getSession().get(
 						entityClass, ( Serializable ) primaryKey, 
 						lockOptions
 				);
 			}
 			else {
 				return ( A ) getSession().get( entityClass, ( Serializable ) primaryKey );
 			}
 		}
 		catch ( ObjectDeletedException e ) {
 			//the spec is silent about people doing remove() find() on the same PC
 			return null;
 		}
 		catch ( ObjectNotFoundException e ) {
 			//should not happen on the entity itself with get
 			throw new IllegalArgumentException( e.getMessage(), e );
 		}
 		catch ( MappingException e ) {
 			throw new IllegalArgumentException( e.getMessage(), e );
 		}
 		catch ( TypeMismatchException e ) {
 			throw new IllegalArgumentException( e.getMessage(), e );
 		}
 		catch ( ClassCastException e ) {
 			throw new IllegalArgumentException( e.getMessage(), e );
 		}
 		catch ( HibernateException he ) {
 			throw convert( he, lockOptions );
 		}
 		finally {
 			getSession().setCacheMode( previousCacheMode );
 		}
 	}
 
 	public CacheMode determineAppropriateLocalCacheMode(Map<String, Object> localProperties) {
 		CacheRetrieveMode retrieveMode = null;
 		CacheStoreMode storeMode = null;
 		if ( localProperties != null ) {
 			retrieveMode = determineCacheRetrieveMode( localProperties );
 			storeMode = determineCacheStoreMode( localProperties );
 		}
 		if ( retrieveMode == null ) {
 			// use the EM setting
 			retrieveMode = determineCacheRetrieveMode( this.properties );
 		}
 		if ( storeMode == null ) {
 			// use the EM setting
 			storeMode = determineCacheStoreMode( this.properties );
 		}
 		return CacheModeHelper.interpretCacheMode( storeMode, retrieveMode );
 	}
 
 	private void checkTransactionNeeded() {
 		if ( persistenceContextType == PersistenceContextType.TRANSACTION && !isTransactionInProgress() ) {
 			//no need to mark as rollback, no tx in progress
 			throw new TransactionRequiredException(
 					"no transaction is in progress for a TRANSACTION type persistence context"
 			);
 		}
 	}
 
 	public void persist(Object entity) {
 		checkTransactionNeeded();
 		try {
 			getSession().persist( entity );
 		}
 		catch ( MappingException e ) {
 			throw new IllegalArgumentException( e.getMessage() );
 		}
 		catch ( RuntimeException e ) {
 			throw convert( e );
 		}
 	}
 
 	@SuppressWarnings("unchecked")
 	public <A> A merge(A entity) {
 		checkTransactionNeeded();
 		try {
 			return ( A ) getSession().merge( entity );
 		}
 		catch ( ObjectDeletedException sse ) {
 			throw new IllegalArgumentException( sse );
 		}
 		catch ( MappingException e ) {
 			throw new IllegalArgumentException( e.getMessage(), e );
 		}
 		catch ( RuntimeException e ) { //including HibernateException
 			throw convert( e );
 		}
 	}
 
 	public void remove(Object entity) {
 		checkTransactionNeeded();
 		try {
 			getSession().delete( entity );
 		}
 		catch ( MappingException e ) {
 			throw new IllegalArgumentException( e.getMessage(), e );
 		}
 		catch ( RuntimeException e ) { //including HibernateException
 			throw convert( e );
 		}
 	}
 
 	public void refresh(Object entity) {
 		refresh( entity, null, null );
 	}
 
 	public void refresh(Object entity, Map<String, Object> properties) {
 		refresh( entity, null, properties );
 	}
 
 	public void refresh(Object entity, LockModeType lockModeType) {
 		refresh( entity, lockModeType, null );
 	}
 
 	public void refresh(Object entity, LockModeType lockModeType, Map<String, Object> properties) {
 		checkTransactionNeeded();
 		CacheMode previousCacheMode = getSession().getCacheMode();
 		CacheMode localCacheMode = determineAppropriateLocalCacheMode( properties );
 		LockOptions lockOptions = null;
 		try {
 			getSession().setCacheMode( localCacheMode );
 			if ( !getSession().contains( entity ) ) {
 				throw new IllegalArgumentException( "Entity not managed" );
 			}
 			if ( lockModeType != null ) {
 				lockOptions = getLockRequest( lockModeType, properties );
 				getSession().refresh( entity, lockOptions );
 			}
 			else {
 				getSession().refresh( entity );
 			}
 		}
 		catch ( MappingException e ) {
 			throw new IllegalArgumentException( e.getMessage(), e );
 		}
 		catch ( HibernateException he ) {
 			throw convert( he, lockOptions );
 		}
 		finally {
 			getSession().setCacheMode( previousCacheMode );
 		}
 	}
 
 	public boolean contains(Object entity) {
 		try {
 			if ( entity != null
 					&& !( entity instanceof HibernateProxy )
 					&& getSession().getSessionFactory().getClassMetadata( entity.getClass() ) == null ) {
 				throw new IllegalArgumentException( "Not an entity:" + entity.getClass() );
 			}
 			return getSession().contains( entity );
 		}
 		catch ( MappingException e ) {
 			throw new IllegalArgumentException( e.getMessage(), e );
 		}
 		catch ( HibernateException he ) {
 			throw convert( he );
 		}
 	}
 
 	public LockModeType getLockMode(Object entity) {
 		if ( !contains( entity ) ) {
 			throw new IllegalArgumentException( "entity not in the persistence context" );
 		}
 		return getLockModeType( getSession().getCurrentLockMode( entity ) );
 	}
 
 	public void setProperty(String s, Object o) {
 		if ( entityManagerSpecificProperties.contains( s ) ) {
 			properties.put( s, o );
 			applyProperties();
         } else LOG.debugf("Trying to set a property which is not supported on entity manager level");
 	}
 
 	public Map<String, Object> getProperties() {
 		return Collections.unmodifiableMap( properties );
 	}
 
 	public void flush() {
 		if ( !isTransactionInProgress() ) {
 			throw new TransactionRequiredException( "no transaction is in progress" );
 		}
 		try {
 			getSession().flush();
 		}
 		catch ( RuntimeException e ) {
 			throw convert( e );
 		}
 	}
 
 	/**
 	 * return a Session
 	 *
 	 * @throws IllegalStateException if the entity manager is closed
 	 */
 	public abstract Session getSession();
 
 	/**
 	 * Return a Session (even if the entity manager is closed).
 	 *
 	 * @return A session.
 	 */
 	protected abstract Session getRawSession();
 
 	public EntityTransaction getTransaction() {
 		if ( transactionType == PersistenceUnitTransactionType.JTA ) {
 			throw new IllegalStateException( "A JTA EntityManager cannot use getTransaction()" );
 		}
 		return tx;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public EntityManagerFactoryImpl getEntityManagerFactory() {
 		return entityManagerFactory;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public HibernateEntityManagerFactory getFactory() {
 		return entityManagerFactory;
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public CriteriaBuilder getCriteriaBuilder() {
 		return getEntityManagerFactory().getCriteriaBuilder();
 	}
 
 	/**
 	 * {@inheritDoc}
 	 */
 	public Metamodel getMetamodel() {
 		return getEntityManagerFactory().getMetamodel();
 	}
 
 	public void setFlushMode(FlushModeType flushModeType) {
 		if ( flushModeType == FlushModeType.AUTO ) {
 			getSession().setFlushMode( FlushMode.AUTO );
 		}
 		else if ( flushModeType == FlushModeType.COMMIT ) {
 			getSession().setFlushMode( FlushMode.COMMIT );
 		}
diff --git a/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/BaseEntityManagerFunctionalTestCase.java b/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/BaseEntityManagerFunctionalTestCase.java
index 27df78bada..4fca26b4e3 100644
--- a/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/BaseEntityManagerFunctionalTestCase.java
+++ b/hibernate-entitymanager/src/test/java/org/hibernate/jpa/test/BaseEntityManagerFunctionalTestCase.java
@@ -1,339 +1,339 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.jpa.test;
 
 import javax.persistence.EntityManager;
 import javax.persistence.EntityManagerFactory;
 import javax.persistence.SharedCacheMode;
 import javax.persistence.ValidationMode;
 import javax.persistence.spi.PersistenceUnitTransactionType;
 import java.net.URL;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.jpa.AvailableSettings;
 import org.hibernate.jpa.internal.EntityManagerFactoryImpl;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.jpa.HibernatePersistenceProvider;
 import org.hibernate.jpa.boot.spi.Bootstrap;
 import org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 
 import org.junit.After;
 import org.junit.Before;
 
 import org.hibernate.testing.junit4.BaseUnitTestCase;
 
 /**
  * A base class for all ejb tests.
  *
  * @author Emmanuel Bernard
  * @author Hardy Ferentschik
  */
 public abstract class BaseEntityManagerFunctionalTestCase extends BaseUnitTestCase {
 	private static final Logger log = Logger.getLogger( BaseEntityManagerFunctionalTestCase.class );
 
 	// IMPL NOTE : Here we use @Before and @After (instead of @BeforeClassOnce and @AfterClassOnce like we do in
 	// BaseCoreFunctionalTestCase) because the old HEM test methodology was to create an EMF for each test method.
 
 	private static final Dialect dialect = Dialect.getDialect();
 
 	private StandardServiceRegistryImpl serviceRegistry;
 	private EntityManagerFactoryImpl entityManagerFactory;
 
 	private EntityManager em;
 	private ArrayList<EntityManager> isolatedEms = new ArrayList<EntityManager>();
 
 	protected Dialect getDialect() {
 		return dialect;
 	}
 
 	protected EntityManagerFactory entityManagerFactory() {
 		return entityManagerFactory;
 	}
 
 	protected StandardServiceRegistryImpl serviceRegistry() {
 		return serviceRegistry;
 	}
 
 	@Before
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public void buildEntityManagerFactory() throws Exception {
 		log.trace( "Building EntityManagerFactory" );
 
 		entityManagerFactory = (EntityManagerFactoryImpl) Bootstrap.getEntityManagerFactoryBuilder(
 				buildPersistenceUnitDescriptor(),
 				buildSettings()
 		).buildEntityManagerFactory();
 
 		serviceRegistry = (StandardServiceRegistryImpl) entityManagerFactory.getSessionFactory()
 				.getServiceRegistry()
 				.getParentServiceRegistry();
 
 		afterEntityManagerFactoryBuilt();
 	}
 
 	private PersistenceUnitDescriptor buildPersistenceUnitDescriptor() {
 		return new TestingPersistenceUnitDescriptorImpl( getClass().getSimpleName() );
 	}
 
 	public static class TestingPersistenceUnitDescriptorImpl implements PersistenceUnitDescriptor {
 		private final String name;
 
 		public TestingPersistenceUnitDescriptorImpl(String name) {
 			this.name = name;
 		}
 
 		@Override
 		public URL getPersistenceUnitRootUrl() {
 			return null;
 		}
 
 		@Override
 		public String getName() {
 			return name;
 		}
 
 		@Override
 		public String getProviderClassName() {
 			return HibernatePersistenceProvider.class.getName();
 		}
 
 		@Override
 		public boolean isUseQuotedIdentifiers() {
 			return false;
 		}
 
 		@Override
 		public boolean isExcludeUnlistedClasses() {
 			return false;
 		}
 
 		@Override
 		public PersistenceUnitTransactionType getTransactionType() {
 			return null;
 		}
 
 		@Override
 		public ValidationMode getValidationMode() {
 			return null;
 		}
 
 		@Override
 		public SharedCacheMode getSharedCacheMode() {
 			return null;
 		}
 
 		@Override
 		public List<String> getManagedClassNames() {
 			return null;
 		}
 
 		@Override
 		public List<String> getMappingFileNames() {
 			return null;
 		}
 
 		@Override
 		public List<URL> getJarFileUrls() {
 			return null;
 		}
 
 		@Override
 		public Object getNonJtaDataSource() {
 			return null;
 		}
 
 		@Override
 		public Object getJtaDataSource() {
 			return null;
 		}
 
 		@Override
 		public Properties getProperties() {
 			return null;
 		}
 
 		@Override
 		public ClassLoader getClassLoader() {
 			return null;
 		}
 
 		@Override
 		public void pushClassTransformer(List<String> entityClassNames) {
 		}
 	}
 
 	@SuppressWarnings("unchecked")
 	protected Map buildSettings() {
 		Map settings = getConfig();
 		addMappings( settings );
 
 		if ( createSchema() ) {
 			settings.put( org.hibernate.cfg.AvailableSettings.HBM2DDL_AUTO, "create-drop" );
 		}
 		settings.put( org.hibernate.cfg.AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS, "true" );
 		settings.put( org.hibernate.cfg.AvailableSettings.DIALECT, getDialect().getClass().getName() );
 		return settings;
 	}
 
 	@SuppressWarnings("unchecked")
 	protected void addMappings(Map settings) {
 		String[] mappings = getMappings();
 		if ( mappings != null ) {
 			settings.put( AvailableSettings.HBXML_FILES, StringHelper.join( ",", mappings ) );
 		}
 	}
 
 	protected static final String[] NO_MAPPINGS = new String[0];
 
 	protected String[] getMappings() {
 		return NO_MAPPINGS;
 	}
 
 	protected Map getConfig() {
 		Map<Object, Object> config = Environment.getProperties();
 		ArrayList<Class> classes = new ArrayList<Class>();
 
 		classes.addAll( Arrays.asList( getAnnotatedClasses() ) );
 		config.put( AvailableSettings.LOADED_CLASSES, classes );
 		for ( Map.Entry<Class, String> entry : getCachedClasses().entrySet() ) {
 			config.put( AvailableSettings.CLASS_CACHE_PREFIX + "." + entry.getKey().getName(), entry.getValue() );
 		}
 		for ( Map.Entry<String, String> entry : getCachedCollections().entrySet() ) {
 			config.put( AvailableSettings.COLLECTION_CACHE_PREFIX + "." + entry.getKey(), entry.getValue() );
 		}
 		if ( getEjb3DD().length > 0 ) {
 			ArrayList<String> dds = new ArrayList<String>();
 			dds.addAll( Arrays.asList( getEjb3DD() ) );
 			config.put( AvailableSettings.XML_FILE_NAMES, dds );
 		}
 
 		addConfigOptions( config );
 		return config;
 	}
 
 	protected void addConfigOptions(Map options) {
 	}
 
 	protected static final Class<?>[] NO_CLASSES = new Class[0];
 
 	protected Class<?>[] getAnnotatedClasses() {
 		return NO_CLASSES;
 	}
 
 	public Map<Class, String> getCachedClasses() {
 		return new HashMap<Class, String>();
 	}
 
 	public Map<String, String> getCachedCollections() {
 		return new HashMap<String, String>();
 	}
 
 	public String[] getEjb3DD() {
 		return new String[] { };
 	}
 
 	protected void afterEntityManagerFactoryBuilt() {
 	}
 
 	protected boolean createSchema() {
 		return true;
 	}
 
 
 	@After
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public void releaseResources() {
 		try {
 			releaseUnclosedEntityManagers();
 		}
 		finally {
 			if ( entityManagerFactory != null && entityManagerFactory.isOpen()) {
 				entityManagerFactory.close();
 			}
 		}
 		// Note we don't destroy the service registry as we are not the ones creating it
 	}
 
 	private void releaseUnclosedEntityManagers() {
 		releaseUnclosedEntityManager( this.em );
 
 		for ( EntityManager isolatedEm : isolatedEms ) {
 			releaseUnclosedEntityManager( isolatedEm );
 		}
 	}
 
 	private void releaseUnclosedEntityManager(EntityManager em) {
 		if ( em == null ) {
 			return;
 		}
 		if ( em.getTransaction().isActive() ) {
 			em.getTransaction().rollback();
             log.warn("You left an open transaction! Fix your test case. For now, we are closing it for you.");
 		}
 		if ( em.isOpen() ) {
 			// as we open an EM before the test runs, it will still be open if the test uses a custom EM.
 			// or, the person may have forgotten to close. So, do not raise a "fail", but log the fact.
 			em.close();
             log.warn("The EntityManager is not closed. Closing it.");
 		}
 	}
 
 	protected EntityManager getOrCreateEntityManager() {
 		if ( em == null || !em.isOpen() ) {
 			em = entityManagerFactory.createEntityManager();
 		}
 		return em;
 	}
 
 	protected EntityManager createIsolatedEntityManager() {
 		EntityManager isolatedEm = entityManagerFactory.createEntityManager();
 		isolatedEms.add( isolatedEm );
 		return isolatedEm;
 	}
 
 	protected EntityManager createIsolatedEntityManager(Map props) {
 		EntityManager isolatedEm = entityManagerFactory.createEntityManager(props);
 		isolatedEms.add( isolatedEm );
 		return isolatedEm;
 	}
 
 	protected EntityManager createEntityManager(Map properties) {
 		// always reopen a new EM and close the existing one
 		if ( em != null && em.isOpen() ) {
 			em.close();
 		}
 		em = entityManagerFactory.createEntityManager( properties );
 		return em;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/AuditConfiguration.java b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/AuditConfiguration.java
index 9ccd515913..1316da28d3 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/configuration/AuditConfiguration.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/configuration/AuditConfiguration.java
@@ -1,173 +1,173 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.configuration;
 
 import java.util.Map;
 import java.util.Properties;
 import java.util.WeakHashMap;
 
 import org.hibernate.MappingException;
 import org.hibernate.annotations.common.reflection.ReflectionManager;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.envers.entities.EntitiesConfigurations;
 import org.hibernate.envers.entities.PropertyData;
 import org.hibernate.envers.revisioninfo.ModifiedEntityNamesReader;
 import org.hibernate.envers.revisioninfo.RevisionInfoNumberReader;
 import org.hibernate.envers.revisioninfo.RevisionInfoQueryCreator;
 import org.hibernate.envers.strategy.AuditStrategy;
 import org.hibernate.envers.strategy.ValidityAuditStrategy;
 import org.hibernate.envers.synchronization.AuditProcessManager;
 import org.hibernate.envers.tools.reflection.ReflectionTools;
 import org.hibernate.property.Getter;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Stephanie Pau at Markit Group Plc
  */
 public class AuditConfiguration {
 	private final GlobalConfiguration globalCfg;
 	private final AuditEntitiesConfiguration auditEntCfg;
 	private final AuditProcessManager auditProcessManager;
 	private final AuditStrategy auditStrategy;
 	private final EntitiesConfigurations entCfg;
 	private final RevisionInfoQueryCreator revisionInfoQueryCreator;
 	private final RevisionInfoNumberReader revisionInfoNumberReader;
 	private final ModifiedEntityNamesReader modifiedEntityNamesReader;
 	private final ClassLoaderService classLoaderService;
 
 	public AuditEntitiesConfiguration getAuditEntCfg() {
 		return auditEntCfg;
 	}
 
 	public AuditProcessManager getSyncManager() {
 		return auditProcessManager;
 	}
 
 	public GlobalConfiguration getGlobalCfg() {
 		return globalCfg;
 	}
 
 	public EntitiesConfigurations getEntCfg() {
 		return entCfg;
 	}
 
 	public RevisionInfoQueryCreator getRevisionInfoQueryCreator() {
 		return revisionInfoQueryCreator;
 	}
 
 	public RevisionInfoNumberReader getRevisionInfoNumberReader() {
 		return revisionInfoNumberReader;
 	}
 
 	public ModifiedEntityNamesReader getModifiedEntityNamesReader() {
 		return modifiedEntityNamesReader;
 	}
 
 	public AuditStrategy getAuditStrategy() {
 		return auditStrategy;
 	}
 
 	public AuditConfiguration(Configuration cfg) {
 		this( cfg, null );
 	}
 
 	public AuditConfiguration(Configuration cfg, ClassLoaderService classLoaderService) {
 		Properties properties = cfg.getProperties();
 
 		ReflectionManager reflectionManager = cfg.getReflectionManager();
 		globalCfg = new GlobalConfiguration( properties );
 		RevisionInfoConfiguration revInfoCfg = new RevisionInfoConfiguration( globalCfg );
 		RevisionInfoConfigurationResult revInfoCfgResult = revInfoCfg.configure( cfg, reflectionManager );
 		auditEntCfg = new AuditEntitiesConfiguration( properties, revInfoCfgResult.getRevisionInfoEntityName() );
 		auditProcessManager = new AuditProcessManager( revInfoCfgResult.getRevisionInfoGenerator() );
 		revisionInfoQueryCreator = revInfoCfgResult.getRevisionInfoQueryCreator();
 		revisionInfoNumberReader = revInfoCfgResult.getRevisionInfoNumberReader();
 		modifiedEntityNamesReader = revInfoCfgResult.getModifiedEntityNamesReader();
 		this.classLoaderService = classLoaderService;
 		auditStrategy = initializeAuditStrategy(
 				revInfoCfgResult.getRevisionInfoClass(),
 				revInfoCfgResult.getRevisionInfoTimestampData()
 		);
 		entCfg = new EntitiesConfigurator().configure(
 				cfg, reflectionManager, globalCfg, auditEntCfg, auditStrategy,
 				revInfoCfgResult.getRevisionInfoXmlMapping(), revInfoCfgResult.getRevisionInfoRelationMapping()
 		);
 	}
 
 	private AuditStrategy initializeAuditStrategy(Class<?> revisionInfoClass, PropertyData revisionInfoTimestampData) {
 		AuditStrategy strategy;
 
 		try {
 
 			Class<?> auditStrategyClass = null;
 			if ( classLoaderService != null ) {
 				auditStrategyClass = classLoaderService.classForName( auditEntCfg.getAuditStrategyName() );
 			}
 			else {
 				auditStrategyClass = Thread.currentThread()
 						.getContextClassLoader()
 						.loadClass( auditEntCfg.getAuditStrategyName() );
 			}
 
 			strategy = (AuditStrategy) auditStrategyClass.newInstance();
 		}
 		catch ( Exception e ) {
 			throw new MappingException(
 					String.format( "Unable to create AuditStrategy[%s] instance.", auditEntCfg.getAuditStrategyName() ),
 					e
 			);
 		}
 
 		if ( strategy instanceof ValidityAuditStrategy ) {
 			// further initialization required
 			Getter revisionTimestampGetter = ReflectionTools.getGetter( revisionInfoClass, revisionInfoTimestampData );
 			( (ValidityAuditStrategy) strategy ).setRevisionTimestampGetter( revisionTimestampGetter );
 		}
 
 		return strategy;
 	}
 
 	//
 
 	private static Map<Configuration, AuditConfiguration> cfgs
 			= new WeakHashMap<Configuration, AuditConfiguration>();
 
 	public synchronized static AuditConfiguration getFor(Configuration cfg) {
 		return getFor( cfg, null );
 	}
 
 	public synchronized static AuditConfiguration getFor(Configuration cfg, ClassLoaderService classLoaderService) {
 		AuditConfiguration verCfg = cfgs.get( cfg );
 
 		if ( verCfg == null ) {
 			verCfg = new AuditConfiguration( cfg, classLoaderService );
 			cfgs.put( cfg, verCfg );
 
 			cfg.buildMappings();
 		}
 
 		return verCfg;
 	}
 }
diff --git a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversIntegrator.java b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversIntegrator.java
index a04d21fa1a..65f84b1df0 100644
--- a/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversIntegrator.java
+++ b/hibernate-envers/src/main/java/org/hibernate/envers/event/EnversIntegrator.java
@@ -1,92 +1,92 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.event;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.envers.configuration.AuditConfiguration;
 import org.hibernate.event.service.spi.EventListenerRegistry;
 import org.hibernate.event.spi.EventType;
 import org.hibernate.integrator.spi.Integrator;
 import org.hibernate.internal.CoreMessageLogger;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.service.classloading.spi.ClassLoaderService;
+import org.hibernate.boot.registry.classloading.spi.ClassLoaderService;
 import org.hibernate.service.spi.SessionFactoryServiceRegistry;
 
 /**
  * Provides integration for Envers into Hibernate, which mainly means registering the proper event listeners.
  *
  * @author Steve Ebersole
  */
 public class EnversIntegrator implements Integrator {
 	private static final CoreMessageLogger LOG = Logger.getMessageLogger( CoreMessageLogger.class, EnversIntegrator.class.getName() );
 
 	public static final String AUTO_REGISTER = "hibernate.listeners.envers.autoRegister";
 
 	@Override
 	public void integrate(
 			Configuration configuration,
 			SessionFactoryImplementor sessionFactory,
 			SessionFactoryServiceRegistry serviceRegistry) {
 		final boolean autoRegister = ConfigurationHelper.getBoolean( AUTO_REGISTER, configuration.getProperties(), true );
 		if ( !autoRegister ) {
 			LOG.debug( "Skipping Envers listener auto registration" );
 			return;
 		}
 
 		EventListenerRegistry listenerRegistry = serviceRegistry.getService( EventListenerRegistry.class );
 		listenerRegistry.addDuplicationStrategy( EnversListenerDuplicationStrategy.INSTANCE );
 
 		final AuditConfiguration enversConfiguration = AuditConfiguration.getFor( configuration, serviceRegistry.getService( ClassLoaderService.class ) );
 
         if (enversConfiguration.getEntCfg().hasAuditedEntities()) {
 		    listenerRegistry.appendListeners( EventType.POST_DELETE, new EnversPostDeleteEventListenerImpl( enversConfiguration ) );
 		    listenerRegistry.appendListeners( EventType.POST_INSERT, new EnversPostInsertEventListenerImpl( enversConfiguration ) );
 		    listenerRegistry.appendListeners( EventType.POST_UPDATE, new EnversPostUpdateEventListenerImpl( enversConfiguration ) );
 		    listenerRegistry.appendListeners( EventType.POST_COLLECTION_RECREATE, new EnversPostCollectionRecreateEventListenerImpl( enversConfiguration ) );
 		    listenerRegistry.appendListeners( EventType.PRE_COLLECTION_REMOVE, new EnversPreCollectionRemoveEventListenerImpl( enversConfiguration ) );
 		    listenerRegistry.appendListeners( EventType.PRE_COLLECTION_UPDATE, new EnversPreCollectionUpdateEventListenerImpl( enversConfiguration ) );
         }
 	}
 
 	@Override
 	public void disintegrate(SessionFactoryImplementor sessionFactory, SessionFactoryServiceRegistry serviceRegistry) {
 		// nothing to do afaik
 	}
 
 	/**
 	 * {@inheritDoc}
 	 *
 	 * @see org.hibernate.integrator.spi.Integrator#integrate(org.hibernate.metamodel.source.MetadataImplementor, org.hibernate.engine.spi.SessionFactoryImplementor, org.hibernate.service.spi.SessionFactoryServiceRegistry)
 	 */
 	@Override
 	public void integrate( MetadataImplementor metadata,
 	                       SessionFactoryImplementor sessionFactory,
 	                       SessionFactoryServiceRegistry serviceRegistry ) {
 	    // TODO: implement
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/BaseEnversJPAFunctionalTestCase.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/BaseEnversJPAFunctionalTestCase.java
index 3eea5518fa..8e76f72c47 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/BaseEnversJPAFunctionalTestCase.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/BaseEnversJPAFunctionalTestCase.java
@@ -1,305 +1,305 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test;
 
 import javax.persistence.EntityManager;
 import javax.persistence.EntityManagerFactory;
 import javax.transaction.SystemException;
 import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.Map;
 
 import org.jboss.logging.Logger;
 
 import org.hibernate.cfg.Configuration;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.jpa.test.PersistenceUnitDescriptorAdapter;
 import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
 import org.hibernate.envers.AuditReader;
 import org.hibernate.envers.AuditReaderFactory;
 import org.hibernate.envers.event.EnversIntegrator;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.jpa.AvailableSettings;
 import org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl;
 import org.hibernate.jpa.boot.spi.Bootstrap;
 import org.hibernate.jpa.boot.spi.PersistenceUnitDescriptor;
 import org.hibernate.jpa.internal.EntityManagerFactoryImpl;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 
 import org.junit.After;
 
 import org.hibernate.testing.AfterClassOnce;
 import org.hibernate.testing.BeforeClassOnce;
 import org.hibernate.testing.jta.TestingJtaPlatformImpl;
 import org.hibernate.testing.junit4.Helper;
 
 /**
  * @author Strong Liu (stliu@hibernate.org)
  */
 public abstract class BaseEnversJPAFunctionalTestCase extends AbstractEnversTest {
 	private static final Logger log = Logger.getLogger( BaseEnversJPAFunctionalTestCase.class );
 
 	private static final Dialect dialect = Dialect.getDialect();
 
 	private EntityManagerFactoryBuilderImpl entityManagerFactoryBuilder;
 	private StandardServiceRegistryImpl serviceRegistry;
 	private EntityManagerFactoryImpl entityManagerFactory;
 
 	private EntityManager em;
 	private AuditReader auditReader;
 	private ArrayList<EntityManager> isolatedEms = new ArrayList<EntityManager>();
 
 	protected Dialect getDialect() {
 		return dialect;
 	}
 
 	protected EntityManagerFactory entityManagerFactory() {
 		return entityManagerFactory;
 	}
 
 	protected StandardServiceRegistryImpl serviceRegistry() {
 		return serviceRegistry;
 	}
 
 	protected Configuration getCfg() {
 		return entityManagerFactoryBuilder.getHibernateConfiguration();
 	}
 
 	@BeforeClassOnce
 	@SuppressWarnings({ "UnusedDeclaration" })
 	public void buildEntityManagerFactory() throws Exception {
 		log.trace( "Building EntityManagerFactory" );
 
 		entityManagerFactoryBuilder = (EntityManagerFactoryBuilderImpl) Bootstrap.getEntityManagerFactoryBuilder(
 				buildPersistenceUnitDescriptor(),
 				buildSettings()
 		);
 		entityManagerFactory = (EntityManagerFactoryImpl) entityManagerFactoryBuilder.buildEntityManagerFactory();
 
 		serviceRegistry = (StandardServiceRegistryImpl) entityManagerFactory.getSessionFactory()
 				.getServiceRegistry()
 				.getParentServiceRegistry();
 
 		afterEntityManagerFactoryBuilt();
 	}
 
 	private PersistenceUnitDescriptor buildPersistenceUnitDescriptor() {
 		return new PersistenceUnitDescriptorAdapter();
 	}
 
 	private Map buildSettings() {
 		Map settings = getConfig();
 		addMappings( settings );
 
 		if ( createSchema() ) {
 			settings.put( org.hibernate.cfg.AvailableSettings.HBM2DDL_AUTO, "create-drop" );
 			final String secondSchemaName = createSecondSchema();
 			if ( StringHelper.isNotEmpty( secondSchemaName ) ) {
 				if ( !( getDialect() instanceof H2Dialect ) ) {
 					throw new UnsupportedOperationException( "Only H2 dialect supports creation of second schema." );
 				}
 				Helper.createH2Schema( secondSchemaName, settings );
 			}
 		}
 
 		if ( StringHelper.isNotEmpty( getAuditStrategy() ) ) {
 			settings.put( "org.hibernate.envers.audit_strategy", getAuditStrategy() );
 		}
 
 		if ( ! isAudit() ) {
 			settings.put( EnversIntegrator.AUTO_REGISTER, "false" );
 		}
 
 		settings.put( "org.hibernate.envers.use_revision_entity_with_native_id", "false" );
 
 		settings.put( org.hibernate.cfg.AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS, "true" );
 		settings.put( org.hibernate.cfg.AvailableSettings.DIALECT, getDialect().getClass().getName() );
 		return settings;
 	}
 
 	protected Map getConfig() {
 		Map<Object, Object> config = new HashMap<Object, Object>();
 
 		config.put( AvailableSettings.LOADED_CLASSES, Arrays.asList( getAnnotatedClasses() ) );
 
 		for ( Map.Entry<Class, String> entry : getCachedClasses().entrySet() ) {
 			config.put( AvailableSettings.CLASS_CACHE_PREFIX + "." + entry.getKey().getName(), entry.getValue() );
 		}
 
 		for ( Map.Entry<String, String> entry : getCachedCollections().entrySet() ) {
 			config.put( AvailableSettings.COLLECTION_CACHE_PREFIX + "." + entry.getKey(), entry.getValue() );
 		}
 
 		if ( getEjb3DD().length > 0 ) {
 			ArrayList<String> dds = new ArrayList<String>();
 			dds.addAll( Arrays.asList( getEjb3DD() ) );
 			config.put( AvailableSettings.XML_FILE_NAMES, dds );
 		}
 
 		addConfigOptions( config );
 
 		return config;
 	}
 
 	@SuppressWarnings("unchecked")
 	protected void addMappings(Map settings) {
 		String[] mappings = getMappings();
 		if ( mappings != null ) {
 			settings.put( AvailableSettings.HBXML_FILES, StringHelper.join( ",", mappings ) );
 		}
 	}
 
 	protected static final String[] NO_MAPPINGS = new String[0];
 
 	protected String[] getMappings() {
 		return NO_MAPPINGS;
 	}
 
 	protected void addConfigOptions(Map options) {
 	}
 
 	protected static final Class<?>[] NO_CLASSES = new Class[0];
 
 	protected Class<?>[] getAnnotatedClasses() {
 		return NO_CLASSES;
 	}
 
 	public Map<Class, String> getCachedClasses() {
 		return new HashMap<Class, String>();
 	}
 
 	public Map<String, String> getCachedCollections() {
 		return new HashMap<String, String>();
 	}
 
 	public String[] getEjb3DD() {
 		return new String[] { };
 	}
 
 	protected void afterEntityManagerFactoryBuilt() {
 	}
 
 	protected boolean createSchema() {
 		return true;
 	}
 
 	/**
 	 * Feature supported only by H2 dialect.
 	 * @return Provide not empty name to create second schema.
 	 */
 	protected String createSecondSchema() {
 		return null;
 	}
 
 	protected boolean isAudit() {
 		return true;
 	}
 
 	@AfterClassOnce
 	public void releaseEntityManagerFactory(){
 		if ( entityManagerFactory != null && entityManagerFactory.isOpen() ) {
 			entityManagerFactory.close();
 		}
 	}
 	@After
 	@SuppressWarnings({ "UnusedDeclaration" })
 	public void releaseUnclosedEntityManagers() {
 		releaseUnclosedEntityManager( this.em );
 		auditReader =null;
 		for ( EntityManager isolatedEm : isolatedEms ) {
 			releaseUnclosedEntityManager( isolatedEm );
 		}
 	}
 
 	private void releaseUnclosedEntityManager(EntityManager em) {
 		if ( em == null ) {
 			return;
 		}
 		if ( !em.isOpen() ) {
 			em = null;
 			return;
 		}
 		if ( JtaStatusHelper.isActive( TestingJtaPlatformImpl.INSTANCE.getTransactionManager() ) ) {
 			log.warn( "Cleaning up unfinished transaction" );
 			try {
 				TestingJtaPlatformImpl.INSTANCE.getTransactionManager().rollback();
 			}
 			catch (SystemException ignored) {
 			}
 		}
 		try{
 			if ( em.getTransaction().isActive() ) {
 				em.getTransaction().rollback();
 				log.warn( "You left an open transaction! Fix your test case. For now, we are closing it for you." );
 			}
 		}
 		catch ( IllegalStateException e ) {
 		}
 		if ( em.isOpen() ) {
 			// as we open an EM before the test runs, it will still be open if the test uses a custom EM.
 			// or, the person may have forgotten to close. So, do not raise a "fail", but log the fact.
 			em.close();
 			log.warn( "The EntityManager is not closed. Closing it." );
 		}
 	}
 	protected EntityManager getEntityManager(){
 		return getOrCreateEntityManager();
 	}
 	protected EntityManager getOrCreateEntityManager() {
 		if ( em == null || !em.isOpen() ) {
 			em = entityManagerFactory.createEntityManager();
 		}
 		return em;
 	}
 
 	protected AuditReader getAuditReader(){
 		if(auditReader!=null){
 			return auditReader;
 		}
 		return auditReader = AuditReaderFactory.get( getOrCreateEntityManager() );
 	}
 
 	protected EntityManager createIsolatedEntityManager() {
 		EntityManager isolatedEm = entityManagerFactory.createEntityManager();
 		isolatedEms.add( isolatedEm );
 		return isolatedEm;
 	}
 
 	protected EntityManager createIsolatedEntityManager(Map props) {
 		EntityManager isolatedEm = entityManagerFactory.createEntityManager( props );
 		isolatedEms.add( isolatedEm );
 		return isolatedEm;
 	}
 
 	protected EntityManager createEntityManager(Map properties) {
 		// always reopen a new EM and close the existing one
 		if ( em != null && em.isOpen() ) {
 			em.close();
 		}
 		em = entityManagerFactory.createEntityManager( properties );
 		return em;
 	}
 }
diff --git a/hibernate-envers/src/test/java/org/hibernate/envers/test/performance/AbstractEntityManagerTest.java b/hibernate-envers/src/test/java/org/hibernate/envers/test/performance/AbstractEntityManagerTest.java
index a4c6e56b39..da3fdd326a 100644
--- a/hibernate-envers/src/test/java/org/hibernate/envers/test/performance/AbstractEntityManagerTest.java
+++ b/hibernate-envers/src/test/java/org/hibernate/envers/test/performance/AbstractEntityManagerTest.java
@@ -1,152 +1,152 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2008-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.envers.test.performance;
 
 import java.io.IOException;
 import java.util.Arrays;
 import java.util.Properties;
 import javax.persistence.EntityManager;
 
+import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.jpa.test.PersistenceUnitDescriptorAdapter;
 import org.hibernate.envers.test.AbstractEnversTest;
 import org.junit.Before;
 
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.jpa.AvailableSettings;
 import org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl;
 import org.hibernate.jpa.boot.spi.Bootstrap;
 import org.hibernate.jpa.internal.EntityManagerFactoryImpl;
 import org.hibernate.envers.AuditReader;
 import org.hibernate.envers.AuditReaderFactory;
 import org.hibernate.envers.event.EnversIntegrator;
-import org.hibernate.service.BootstrapServiceRegistryBuilder;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.testing.AfterClassOnce;
 import org.hibernate.testing.BeforeClassOnce;
 
 /**
  * @author Adam Warski (adam at warski dot org)
  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)
  */
 public abstract class AbstractEntityManagerTest extends AbstractEnversTest {
     public static final Dialect DIALECT = Dialect.getDialect();
 
 	private EntityManagerFactoryBuilderImpl entityManagerFactoryBuilder;
 	private StandardServiceRegistryImpl serviceRegistry;
 	private EntityManagerFactoryImpl emf;
     private EntityManager entityManager;
     private AuditReader auditReader;
     private boolean audited;
 
     public void addConfigurationProperties(Properties configuration) {
 	}
 
     protected static Dialect getDialect() {
         return DIALECT;
     }
 
     private void closeEntityManager() {
         if (entityManager != null) {
             entityManager.close();
             entityManager = null;
         }
     }
 
     @Before
     public void newEntityManager() {
         closeEntityManager();
         
         entityManager = emf.createEntityManager();
 
         if (audited) {
             auditReader = AuditReaderFactory.get(entityManager);
         }
     }
 
     @BeforeClassOnce
     public void init() throws IOException {
         init(true, getAuditStrategy());
     }
 
     protected void init(boolean audited, String auditStrategy) throws IOException {
         this.audited = audited;
 
         Properties configurationProperties = new Properties();
 		configurationProperties.putAll( Environment.getProperties() );
         if (!audited) {
 			configurationProperties.setProperty(EnversIntegrator.AUTO_REGISTER, "false");
         }
 		if ( createSchema() ) {
 			configurationProperties.setProperty( Environment.HBM2DDL_AUTO, "create-drop" );
 			configurationProperties.setProperty( Environment.USE_NEW_ID_GENERATOR_MAPPINGS, "true" );
 			configurationProperties.setProperty("org.hibernate.envers.use_revision_entity_with_native_id", "false");
 		}
         if (auditStrategy != null && !"".equals(auditStrategy)) {
             configurationProperties.setProperty("org.hibernate.envers.audit_strategy", auditStrategy);
         }
 
         addConfigurationProperties( configurationProperties );
 
 		configurationProperties.put( AvailableSettings.LOADED_CLASSES, Arrays.asList( getAnnotatedClasses() ) );
 
 		entityManagerFactoryBuilder = (EntityManagerFactoryBuilderImpl) Bootstrap.getEntityManagerFactoryBuilder(
 				new PersistenceUnitDescriptorAdapter(),
 				configurationProperties
 		);
 
         emf = (EntityManagerFactoryImpl) entityManagerFactoryBuilder.buildEntityManagerFactory();
 
 		serviceRegistry = (StandardServiceRegistryImpl) emf.getSessionFactory().getServiceRegistry().getParentServiceRegistry();
 
         newEntityManager();
     }
 
 	protected Class[] getAnnotatedClasses() {
 		return new Class[0];
 	}
 
 	protected boolean createSchema() {
 		return true;
 	}
 
 	private BootstrapServiceRegistryBuilder createBootstrapRegistryBuilder() {
 		return new BootstrapServiceRegistryBuilder();
 	}
 
 	@AfterClassOnce
     public void close() {
         closeEntityManager();
         emf.close();
 		//NOTE we don't build the service registry so we don't destroy it
     }
 
     public EntityManager getEntityManager() {
         return entityManager;
     }
 
     public AuditReader getAuditReader() {
         return auditReader;
     }
 }
diff --git a/hibernate-infinispan/src/main/java/org/hibernate/cache/infinispan/tm/HibernateTransactionManagerLookup.java b/hibernate-infinispan/src/main/java/org/hibernate/cache/infinispan/tm/HibernateTransactionManagerLookup.java
index e852e20e88..7ece4bcec0 100644
--- a/hibernate-infinispan/src/main/java/org/hibernate/cache/infinispan/tm/HibernateTransactionManagerLookup.java
+++ b/hibernate-infinispan/src/main/java/org/hibernate/cache/infinispan/tm/HibernateTransactionManagerLookup.java
@@ -1,52 +1,52 @@
 /*
  * JBoss, Home of Professional Open Source.
  * Copyright 2009, Red Hat, Inc. and/or it's affiliates, and individual contributors
  * as indicated by the @author tags. See the copyright.txt file in the
  * distribution for a full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as
  * published by the Free Software Foundation; either version 2.1 of
  * the License, or (at your option) any later version.
  *
  * This software is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this software; if not, write to the Free
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
 package org.hibernate.cache.infinispan.tm;
 
 import java.util.Properties;
 import javax.transaction.TransactionManager;
 
 import org.hibernate.cfg.Settings;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 
 /**
  * HibernateTransactionManagerLookup.
  * 
  * @author Galder Zamarreo
  * @since 3.5
  */
 public class HibernateTransactionManagerLookup implements org.infinispan.transaction.lookup.TransactionManagerLookup {
 	private final JtaPlatform jtaPlatform;
 
 	public HibernateTransactionManagerLookup(Settings settings, Properties properties) {
 		if ( settings != null ) {
 			jtaPlatform = settings.getJtaPlatform();
 		}
 		else {
 			jtaPlatform = null;
 		}
 	}
 
 	public TransactionManager getTransactionManager() throws Exception {
 		return jtaPlatform == null ? null : jtaPlatform.retrieveTransactionManager();
 	}
    
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/AbstractEntityCollectionRegionTestCase.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/AbstractEntityCollectionRegionTestCase.java
index 6ee5e505d4..16e007b671 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/AbstractEntityCollectionRegionTestCase.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/AbstractEntityCollectionRegionTestCase.java
@@ -1,120 +1,120 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007, Red Hat, Inc. and/or it's affiliates or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors. All third-party contributions are
  * distributed under license by Red Hat, Inc. and/or it's affiliates.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cache.infinispan;
 
 import java.util.Properties;
 
 import org.junit.Test;
 
 import org.hibernate.cache.infinispan.InfinispanRegionFactory;
 import org.hibernate.cache.spi.CacheDataDescription;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cache.spi.TransactionalDataRegion;
 import org.hibernate.cache.spi.access.AccessType;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.test.cache.infinispan.util.CacheTestUtil;
 import org.hibernate.testing.ServiceRegistryBuilder;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Base class for tests of EntityRegion and CollectionRegion implementations.
  *
  * @author Galder Zamarreo
  * @since 3.5
  */
 public abstract class AbstractEntityCollectionRegionTestCase extends AbstractRegionImplTestCase {
 	@Test
 	public void testSupportedAccessTypes() throws Exception {
 		supportedAccessTypeTest();
 	}
 
 	private void supportedAccessTypeTest() throws Exception {
 		Configuration cfg = CacheTestUtil.buildConfiguration( "test", InfinispanRegionFactory.class, true, false );
 		String entityCfg = "entity";
 		cfg.setProperty( InfinispanRegionFactory.ENTITY_CACHE_RESOURCE_PROP, entityCfg );
 		InfinispanRegionFactory regionFactory = CacheTestUtil.startRegionFactory(
 				ServiceRegistryBuilder.buildServiceRegistry( cfg.getProperties() ),
 				cfg,
 				getCacheTestSupport()
 		);
 		supportedAccessTypeTest( regionFactory, cfg.getProperties() );
 	}
 
 	/**
 	 * Creates a Region using the given factory, and then ensure that it handles calls to
 	 * buildAccessStrategy as expected when all the various {@link AccessType}s are passed as
 	 * arguments.
 	 */
 	protected abstract void supportedAccessTypeTest(RegionFactory regionFactory, Properties properties);
 
 	@Test
 	public void testIsTransactionAware() throws Exception {
 		Configuration cfg = CacheTestUtil.buildConfiguration( "test", InfinispanRegionFactory.class, true, false );
 		InfinispanRegionFactory regionFactory = CacheTestUtil.startRegionFactory(
 				ServiceRegistryBuilder.buildServiceRegistry( cfg.getProperties() ),
 				cfg,
 				getCacheTestSupport()
 		);
 		TransactionalDataRegion region = (TransactionalDataRegion) createRegion(
 				regionFactory, "test/test", cfg.getProperties(), getCacheDataDescription()
 		);
 		assertTrue( "Region is transaction-aware", region.isTransactionAware() );
 		CacheTestUtil.stopRegionFactory( regionFactory, getCacheTestSupport() );
 //		cfg = CacheTestUtil.buildConfiguration( "test", InfinispanRegionFactory.class, true, false );
 //		// Make it non-transactional
 //		cfg.getProperties().remove( AvailableSettings.JTA_PLATFORM );
 //		regionFactory = CacheTestUtil.startRegionFactory(
-//				ServiceRegistryBuilder.buildServiceRegistry( cfg.getProperties() ),
+//				StandardServiceRegistryBuilder.buildServiceRegistry( cfg.getProperties() ),
 //				cfg,
 //				getCacheTestSupport()
 //		);
 //		region = (TransactionalDataRegion) createRegion(
 //				regionFactory, "test/test", cfg.getProperties(), getCacheDataDescription()
 //		);
 //		assertFalse( "Region is not transaction-aware", region.isTransactionAware() );
 //		CacheTestUtil.stopRegionFactory( regionFactory, getCacheTestSupport() );
 	}
 
 	@Test
 	public void testGetCacheDataDescription() throws Exception {
 		Configuration cfg = CacheTestUtil.buildConfiguration( "test", InfinispanRegionFactory.class, true, false );
 		InfinispanRegionFactory regionFactory = CacheTestUtil.startRegionFactory(
 				ServiceRegistryBuilder.buildServiceRegistry( cfg.getProperties() ),
 				cfg,
 				getCacheTestSupport()
 		);
 		TransactionalDataRegion region = (TransactionalDataRegion) createRegion(
 				regionFactory, "test/test", cfg.getProperties(), getCacheDataDescription()
 		);
 		CacheDataDescription cdd = region.getCacheDataDescription();
 		assertNotNull( cdd );
 		CacheDataDescription expected = getCacheDataDescription();
 		assertEquals( expected.isMutable(), cdd.isMutable() );
 		assertEquals( expected.isVersioned(), cdd.isVersioned() );
 		assertEquals( expected.getVersionComparator(), cdd.getVersionComparator() );
 	}
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/AbstractGeneralDataRegionTestCase.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/AbstractGeneralDataRegionTestCase.java
index babe5f8e48..88d2530530 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/AbstractGeneralDataRegionTestCase.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/AbstractGeneralDataRegionTestCase.java
@@ -1,231 +1,232 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007, Red Hat, Inc. and/or it's affiliates or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors. All third-party contributions are
  * distributed under license by Red Hat, Inc. and/or it's affiliates.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cache.infinispan;
 
 import java.util.Set;
 
 import org.infinispan.transaction.tm.BatchModeTransactionManager;
 import org.jboss.logging.Logger;
 import org.junit.Test;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cache.infinispan.InfinispanRegionFactory;
 import org.hibernate.cache.infinispan.util.CacheAdapter;
 import org.hibernate.cache.spi.GeneralDataRegion;
 import org.hibernate.cache.spi.QueryResultsRegion;
 import org.hibernate.cache.spi.Region;
 import org.hibernate.cfg.Configuration;
-import org.hibernate.service.ServiceRegistryBuilder;
+
 import org.hibernate.test.cache.infinispan.util.CacheTestUtil;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 
 /**
  * Base class for tests of QueryResultsRegion and TimestampsRegion.
  *
  * @author Galder Zamarreo
  * @since 3.5
  */
 public abstract class AbstractGeneralDataRegionTestCase extends AbstractRegionImplTestCase {
 	private static final Logger log = Logger.getLogger( AbstractGeneralDataRegionTestCase.class );
 
 	protected static final String KEY = "Key";
 
 	protected static final String VALUE1 = "value1";
 	protected static final String VALUE2 = "value2";
 
 	protected Configuration createConfiguration() {
 		return CacheTestUtil.buildConfiguration( "test", InfinispanRegionFactory.class, false, true );
 	}
 
 	@Override
 	protected void putInRegion(Region region, Object key, Object value) {
 		((GeneralDataRegion) region).put( key, value );
 	}
 
 	@Override
 	protected void removeFromRegion(Region region, Object key) {
 		((GeneralDataRegion) region).evict( key );
 	}
 
 	@Test
 	public void testEvict() throws Exception {
 		evictOrRemoveTest();
 	}
 
 	private void evictOrRemoveTest() throws Exception {
 		Configuration cfg = createConfiguration();
 		InfinispanRegionFactory regionFactory = CacheTestUtil.startRegionFactory(
-				new ServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
+				new StandardServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
 				cfg,
 				getCacheTestSupport()
 		);
 		boolean invalidation = false;
 
 		// Sleep a bit to avoid concurrent FLUSH problem
 		avoidConcurrentFlush();
 
 		GeneralDataRegion localRegion = (GeneralDataRegion) createRegion(
 				regionFactory,
 				getStandardRegionName( REGION_PREFIX ), cfg.getProperties(), null
 		);
 
 		cfg = createConfiguration();
 		regionFactory = CacheTestUtil.startRegionFactory(
-				new ServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
+				new StandardServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
 				cfg,
 				getCacheTestSupport()
 		);
 
 		GeneralDataRegion remoteRegion = (GeneralDataRegion) createRegion(
 				regionFactory,
 				getStandardRegionName( REGION_PREFIX ),
 				cfg.getProperties(),
 				null
 		);
 
 		assertNull( "local is clean", localRegion.get( KEY ) );
 		assertNull( "remote is clean", remoteRegion.get( KEY ) );
 
       regionPut(localRegion);
       assertEquals( VALUE1, localRegion.get( KEY ) );
 
 		// allow async propagation
 		sleep( 250 );
 		Object expected = invalidation ? null : VALUE1;
 		assertEquals( expected, remoteRegion.get( KEY ) );
 
       regionEvict(localRegion);
 
       // allow async propagation
 		sleep( 250 );
 		assertEquals( null, localRegion.get( KEY ) );
 		assertEquals( null, remoteRegion.get( KEY ) );
 	}
 
    protected void regionEvict(GeneralDataRegion region) throws Exception {
       region.evict(KEY);
    }
 
    protected void regionPut(GeneralDataRegion region) throws Exception {
       region.put(KEY, VALUE1);
    }
 
    protected abstract String getStandardRegionName(String regionPrefix);
 
 	/**
 	 * Test method for {@link QueryResultsRegion#evictAll()}.
 	 * <p/>
 	 * FIXME add testing of the "immediately without regard for transaction isolation" bit in the
 	 * CollectionRegionAccessStrategy API.
 	 */
 	public void testEvictAll() throws Exception {
 		evictOrRemoveAllTest( "entity" );
 	}
 
 	private void evictOrRemoveAllTest(String configName) throws Exception {
 		Configuration cfg = createConfiguration();
 		InfinispanRegionFactory regionFactory = CacheTestUtil.startRegionFactory(
-				new ServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
+				new StandardServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
 				cfg,
 				getCacheTestSupport()
 		);
 		CacheAdapter localCache = getInfinispanCache( regionFactory );
 
 		// Sleep a bit to avoid concurrent FLUSH problem
 		avoidConcurrentFlush();
 
 		GeneralDataRegion localRegion = (GeneralDataRegion) createRegion(
 				regionFactory,
 				getStandardRegionName( REGION_PREFIX ),
 				cfg.getProperties(),
 				null
 		);
 
 		cfg = createConfiguration();
 		regionFactory = CacheTestUtil.startRegionFactory(
-				new ServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
+				new StandardServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
 				cfg,
 				getCacheTestSupport()
 		);
 		CacheAdapter remoteCache = getInfinispanCache( regionFactory );
 
 		// Sleep a bit to avoid concurrent FLUSH problem
 		avoidConcurrentFlush();
 
 		GeneralDataRegion remoteRegion = (GeneralDataRegion) createRegion(
 				regionFactory,
 				getStandardRegionName( REGION_PREFIX ),
 				cfg.getProperties(),
 				null
 		);
 
 		Set keys = localCache.keySet();
 		assertEquals( "No valid children in " + keys, 0, getValidKeyCount( keys ) );
 
 		keys = remoteCache.keySet();
 		assertEquals( "No valid children in " + keys, 0, getValidKeyCount( keys ) );
 
 		assertNull( "local is clean", localRegion.get( KEY ) );
 		assertNull( "remote is clean", remoteRegion.get( KEY ) );
 
       regionPut(localRegion);
       assertEquals( VALUE1, localRegion.get( KEY ) );
 
 		// Allow async propagation
 		sleep( 250 );
 
       regionPut(remoteRegion);
       assertEquals( VALUE1, remoteRegion.get( KEY ) );
 
 		// Allow async propagation
 		sleep( 250 );
 
 		localRegion.evictAll();
 
 		// allow async propagation
 		sleep( 250 );
 		// This should re-establish the region root node in the optimistic case
 		assertNull( localRegion.get( KEY ) );
 		assertEquals( "No valid children in " + keys, 0, getValidKeyCount( localCache.keySet() ) );
 
 		// Re-establishing the region root on the local node doesn't
 		// propagate it to other nodes. Do a get on the remote node to re-establish
 		// This only adds a node in the case of optimistic locking
 		assertEquals( null, remoteRegion.get( KEY ) );
 		assertEquals( "No valid children in " + keys, 0, getValidKeyCount( remoteCache.keySet() ) );
 
 		assertEquals( "local is clean", null, localRegion.get( KEY ) );
 		assertEquals( "remote is clean", null, remoteRegion.get( KEY ) );
 	}
 
 	protected void rollback() {
 		try {
 			BatchModeTransactionManager.getInstance().rollback();
 		}
 		catch (Exception e) {
 			log.error( e.getMessage(), e );
 		}
 	}
 }
\ No newline at end of file
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/InfinispanRegionFactoryTestCase.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/InfinispanRegionFactoryTestCase.java
index f2601409ef..02edfd8bee 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/InfinispanRegionFactoryTestCase.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/InfinispanRegionFactoryTestCase.java
@@ -1,562 +1,562 @@
 /*
  * JBoss, Home of Professional Open Source.
  * Copyright 2009, Red Hat, Inc. and/or it's affiliates, and individual contributors
  * as indicated by the @author tags. See the copyright.txt file in the
  * distribution for a full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as
  * published by the Free Software Foundation; either version 2.1 of
  * the License, or (at your option) any later version.
  *
  * This software is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this software; if not, write to the Free
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
 package org.hibernate.test.cache.infinispan;
 
 import java.util.Properties;
 import javax.transaction.TransactionManager;
 
 import org.infinispan.config.Configuration;
 import org.infinispan.config.Configuration.CacheMode;
 import org.infinispan.eviction.EvictionStrategy;
 import org.infinispan.manager.DefaultCacheManager;
 import org.infinispan.manager.EmbeddedCacheManager;
 import org.junit.Test;
 
 import org.hibernate.cache.CacheException;
 import org.hibernate.cache.infinispan.InfinispanRegionFactory;
 import org.hibernate.cache.infinispan.collection.CollectionRegionImpl;
 import org.hibernate.cache.infinispan.entity.EntityRegionImpl;
 import org.hibernate.cache.infinispan.query.QueryResultsRegionImpl;
 import org.hibernate.cache.infinispan.timestamp.TimestampsRegionImpl;
 import org.hibernate.cache.infinispan.tm.HibernateTransactionManagerLookup;
 import org.hibernate.cache.infinispan.util.CacheAdapter;
 import org.hibernate.cfg.Settings;
-import org.hibernate.service.jta.platform.internal.AbstractJtaPlatform;
-import org.hibernate.service.jta.platform.internal.JBossStandAloneJtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.internal.AbstractJtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.internal.JBossStandAloneJtaPlatform;
 import org.hibernate.testing.ServiceRegistryBuilder;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 import static org.junit.Assert.assertTrue;
 import static org.junit.Assert.fail;
 
 /**
  * InfinispanRegionFactoryTestCase.
  * 
  * @author Galder Zamarreo
  * @since 3.5
  */
 public class InfinispanRegionFactoryTestCase  {
    @Test
    public void testConfigurationProcessing() {
       final String person = "com.acme.Person";
       final String addresses = "com.acme.Person.addresses";
       Properties p = new Properties();
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.cfg", "person-cache");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.eviction.strategy", "LRU");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.eviction.wake_up_interval", "2000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.eviction.max_entries", "5000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.lifespan", "60000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.max_idle", "30000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.cfg", "person-addresses-cache");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.expiration.lifespan", "120000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.expiration.max_idle", "60000");
       p.setProperty("hibernate.cache.infinispan.query.cfg", "my-query-cache");
       p.setProperty("hibernate.cache.infinispan.query.eviction.strategy", "FIFO");
       p.setProperty("hibernate.cache.infinispan.query.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.query.eviction.max_entries", "10000");
 
       InfinispanRegionFactory factory = createRegionFactory(p);
 
       assertEquals("entity", factory.getTypeOverrides().get("entity").getCacheName());
       assertEquals("entity", factory.getTypeOverrides().get("collection").getCacheName());
       assertEquals("timestamps", factory.getTypeOverrides().get("timestamps").getCacheName());
 
       assertEquals("person-cache", factory.getTypeOverrides().get(person).getCacheName());
       assertEquals(EvictionStrategy.LRU, factory.getTypeOverrides().get(person).getEvictionStrategy());
       assertEquals(2000, factory.getTypeOverrides().get(person).getEvictionWakeUpInterval());
       assertEquals(5000, factory.getTypeOverrides().get(person).getEvictionMaxEntries());
       assertEquals(60000, factory.getTypeOverrides().get(person).getExpirationLifespan());
       assertEquals(30000, factory.getTypeOverrides().get(person).getExpirationMaxIdle());
 
       assertEquals("person-addresses-cache", factory.getTypeOverrides().get(addresses).getCacheName());
       assertEquals(120000, factory.getTypeOverrides().get(addresses).getExpirationLifespan());
       assertEquals(60000, factory.getTypeOverrides().get(addresses).getExpirationMaxIdle());
 
       assertEquals("my-query-cache", factory.getTypeOverrides().get("query").getCacheName());
       assertEquals(EvictionStrategy.FIFO, factory.getTypeOverrides().get("query").getEvictionStrategy());
       assertEquals(3000, factory.getTypeOverrides().get("query").getEvictionWakeUpInterval());
       assertEquals(10000, factory.getTypeOverrides().get("query").getEvictionMaxEntries());
    }
 
    @Test
    public void testBuildEntityCollectionRegionsPersonPlusEntityCollectionOverrides() {
       final String person = "com.acme.Person";
       final String address = "com.acme.Address";
       final String car = "com.acme.Car";
       final String addresses = "com.acme.Person.addresses";
       final String parts = "com.acme.Car.parts";
       Properties p = new Properties();
       // First option, cache defined for entity and overrides for generic entity data type and entity itself.
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.cfg", "person-cache");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.eviction.strategy", "LRU");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.eviction.wake_up_interval", "2000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.eviction.max_entries", "5000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.lifespan", "60000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.max_idle", "30000");
       p.setProperty("hibernate.cache.infinispan.entity.cfg", "myentity-cache");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.strategy", "FIFO");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.max_entries", "20000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.cfg", "addresses-cache");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.eviction.strategy", "FIFO");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.eviction.wake_up_interval", "2500");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.eviction.max_entries", "5500");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.expiration.lifespan", "65000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.addresses.expiration.max_idle", "35000");
       p.setProperty("hibernate.cache.infinispan.collection.cfg", "mycollection-cache");
       p.setProperty("hibernate.cache.infinispan.collection.eviction.strategy", "LRU");
       p.setProperty("hibernate.cache.infinispan.collection.eviction.wake_up_interval", "3500");
       p.setProperty("hibernate.cache.infinispan.collection.eviction.max_entries", "25000");
       InfinispanRegionFactory factory = createRegionFactory(p);
       EmbeddedCacheManager manager = factory.getCacheManager();
       try {
          assertFalse(manager.getGlobalConfiguration().isExposeGlobalJmxStatistics());
          assertNotNull(factory.getTypeOverrides().get(person));
          assertFalse(factory.getDefinedConfigurations().contains(person));
          assertNotNull(factory.getTypeOverrides().get(addresses));
          assertFalse(factory.getDefinedConfigurations().contains(addresses));
          CacheAdapter cache = null;
 
          EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion(person, p, null);
          assertNotNull(factory.getTypeOverrides().get(person));
          assertTrue(factory.getDefinedConfigurations().contains(person));
          assertNull(factory.getTypeOverrides().get(address));
          cache = region.getCacheAdapter();
          Configuration cacheCfg = cache.getConfiguration();
          assertEquals(EvictionStrategy.LRU, cacheCfg.getEvictionStrategy());
          assertEquals(2000, cacheCfg.getEvictionWakeUpInterval());
          assertEquals(5000, cacheCfg.getEvictionMaxEntries());
          assertEquals(60000, cacheCfg.getExpirationLifespan());
          assertEquals(30000, cacheCfg.getExpirationMaxIdle());
          assertFalse(cacheCfg.isExposeJmxStatistics());
 
          region = (EntityRegionImpl) factory.buildEntityRegion(address, p, null);
          assertNotNull(factory.getTypeOverrides().get(person));
          assertTrue(factory.getDefinedConfigurations().contains(person));
          assertNull(factory.getTypeOverrides().get(address));
          cache = region.getCacheAdapter();
          cacheCfg = cache.getConfiguration();
          assertEquals(EvictionStrategy.FIFO, cacheCfg.getEvictionStrategy());
          assertEquals(3000, cacheCfg.getEvictionWakeUpInterval());
          assertEquals(20000, cacheCfg.getEvictionMaxEntries());
          assertFalse(cacheCfg.isExposeJmxStatistics());
 
          region = (EntityRegionImpl) factory.buildEntityRegion(car, p, null);
          assertNotNull(factory.getTypeOverrides().get(person));
          assertTrue(factory.getDefinedConfigurations().contains(person));
          assertNull(factory.getTypeOverrides().get(address));
          cache = region.getCacheAdapter();
          cacheCfg = cache.getConfiguration();
          assertEquals(EvictionStrategy.FIFO, cacheCfg.getEvictionStrategy());
          assertEquals(3000, cacheCfg.getEvictionWakeUpInterval());
          assertEquals(20000, cacheCfg.getEvictionMaxEntries());
          assertFalse(cacheCfg.isExposeJmxStatistics());
 
          CollectionRegionImpl collectionRegion = (CollectionRegionImpl) factory.buildCollectionRegion(addresses, p, null);
          assertNotNull(factory.getTypeOverrides().get(addresses));
          assertTrue(factory.getDefinedConfigurations().contains(person));
          assertNull(factory.getTypeOverrides().get(parts));
          cache = collectionRegion .getCacheAdapter();
          cacheCfg = cache.getConfiguration();
          assertEquals(EvictionStrategy.FIFO, cacheCfg.getEvictionStrategy());
          assertEquals(2500, cacheCfg.getEvictionWakeUpInterval());
          assertEquals(5500, cacheCfg.getEvictionMaxEntries());
          assertEquals(65000, cacheCfg.getExpirationLifespan());
          assertEquals(35000, cacheCfg.getExpirationMaxIdle());
          assertFalse(cacheCfg.isExposeJmxStatistics());
 
          collectionRegion = (CollectionRegionImpl) factory.buildCollectionRegion(parts, p, null);
          assertNotNull(factory.getTypeOverrides().get(addresses));
          assertTrue(factory.getDefinedConfigurations().contains(addresses));
          assertNull(factory.getTypeOverrides().get(parts));
          cache = collectionRegion.getCacheAdapter();
          cacheCfg = cache.getConfiguration();
          assertEquals(EvictionStrategy.LRU, cacheCfg.getEvictionStrategy());
          assertEquals(3500, cacheCfg.getEvictionWakeUpInterval());
          assertEquals(25000, cacheCfg.getEvictionMaxEntries());
          assertFalse(cacheCfg.isExposeJmxStatistics());
 
          collectionRegion = (CollectionRegionImpl) factory.buildCollectionRegion(parts, p, null);
          assertNotNull(factory.getTypeOverrides().get(addresses));
          assertTrue(factory.getDefinedConfigurations().contains(addresses));
          assertNull(factory.getTypeOverrides().get(parts));
          cache = collectionRegion.getCacheAdapter();
          cacheCfg = cache.getConfiguration();
          assertEquals(EvictionStrategy.LRU, cacheCfg.getEvictionStrategy());
          assertEquals(3500, cacheCfg.getEvictionWakeUpInterval());
          assertEquals(25000, cacheCfg.getEvictionMaxEntries());
          assertFalse(cacheCfg.isExposeJmxStatistics());
       } finally {
          factory.stop();
       }
    }
 
    @Test
    public void testBuildEntityCollectionRegionOverridesOnly() {
       CacheAdapter cache;
       Properties p = new Properties();
       p.setProperty("hibernate.cache.infinispan.entity.eviction.strategy", "FIFO");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.max_entries", "30000");
       p.setProperty("hibernate.cache.infinispan.collection.eviction.strategy", "LRU");
       p.setProperty("hibernate.cache.infinispan.collection.eviction.wake_up_interval", "3500");
       p.setProperty("hibernate.cache.infinispan.collection.eviction.max_entries", "35000");
       InfinispanRegionFactory factory = createRegionFactory(p);
       factory.getCacheManager();
       try {
          EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion("com.acme.Address", p, null);
          assertNull(factory.getTypeOverrides().get("com.acme.Address"));
          cache = region.getCacheAdapter();
          Configuration cacheCfg = cache.getConfiguration();
          assertEquals(EvictionStrategy.FIFO, cacheCfg.getEvictionStrategy());
          assertEquals(3000, cacheCfg.getEvictionWakeUpInterval());
          assertEquals(30000, cacheCfg.getEvictionMaxEntries());
          assertEquals(100000, cacheCfg.getExpirationMaxIdle());
 
          CollectionRegionImpl collectionRegion = (CollectionRegionImpl) factory.buildCollectionRegion("com.acme.Person.addresses", p, null);
          assertNull(factory.getTypeOverrides().get("com.acme.Person.addresses"));
          cache = collectionRegion.getCacheAdapter();
          cacheCfg = cache.getConfiguration();
          assertEquals(EvictionStrategy.LRU, cacheCfg.getEvictionStrategy());
          assertEquals(3500, cacheCfg.getEvictionWakeUpInterval());
          assertEquals(35000, cacheCfg.getEvictionMaxEntries());
          assertEquals(100000, cacheCfg.getExpirationMaxIdle());
       } finally {
          factory.stop();
       }
    }
    @Test
    public void testBuildEntityRegionPersonPlusEntityOverridesWithoutCfg() {
       final String person = "com.acme.Person";
       Properties p = new Properties();
       // Third option, no cache defined for entity and overrides for generic entity data type and entity itself.
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.eviction.strategy", "LRU");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.lifespan", "60000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.max_idle", "30000");
       p.setProperty("hibernate.cache.infinispan.entity.cfg", "myentity-cache");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.strategy", "FIFO");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.max_entries", "10000");
       InfinispanRegionFactory factory = createRegionFactory(p);
       EmbeddedCacheManager manager = factory.getCacheManager();
       try {
          assertNotNull(factory.getTypeOverrides().get(person));
          assertFalse(factory.getDefinedConfigurations().contains(person));
          EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion(person, p, null);
          assertNotNull(factory.getTypeOverrides().get(person));
          assertTrue(factory.getDefinedConfigurations().contains(person));
          CacheAdapter cache = region.getCacheAdapter();
          Configuration cacheCfg = cache.getConfiguration();
          assertEquals(EvictionStrategy.LRU, cacheCfg.getEvictionStrategy());
          assertEquals(3000, cacheCfg.getEvictionWakeUpInterval());
          assertEquals(10000, cacheCfg.getEvictionMaxEntries());
          assertEquals(60000, cacheCfg.getExpirationLifespan());
          assertEquals(30000, cacheCfg.getExpirationMaxIdle());
       } finally {
          factory.stop();
       }
    }
    @Test
    public void testTimestampValidation() {
       Properties p = new Properties();
       final DefaultCacheManager manager = new DefaultCacheManager();
       InfinispanRegionFactory factory = createRegionFactory(manager, p);
       Configuration config = new Configuration();
       config.setCacheMode(CacheMode.INVALIDATION_SYNC);
       manager.defineConfiguration("timestamps", config);
       try {
          factory.start(null, p);
          fail("Should have failed saying that invalidation is not allowed for timestamp caches.");
       } catch(CacheException ce) {
       }
    }
     @Test
    public void testBuildDefaultTimestampsRegion() {
       final String timestamps = "org.hibernate.cache.spi.UpdateTimestampsCache";
       Properties p = new Properties();
       InfinispanRegionFactory factory = createRegionFactory(p);
       EmbeddedCacheManager manager = factory.getCacheManager();
       try {
          assertTrue(factory.getDefinedConfigurations().contains("timestamps"));
          assertTrue(factory.getTypeOverrides().get("timestamps").getCacheName().equals("timestamps"));
          Configuration config = new Configuration();
          config.setFetchInMemoryState(false);
          manager.defineConfiguration("timestamps", config);
          TimestampsRegionImpl region = (TimestampsRegionImpl) factory.buildTimestampsRegion(timestamps, p);
          CacheAdapter cache = region.getCacheAdapter();
          Configuration cacheCfg = cache.getConfiguration();
          assertEquals(EvictionStrategy.NONE, cacheCfg.getEvictionStrategy());
          assertEquals(CacheMode.REPL_ASYNC, cacheCfg.getCacheMode());
          assertTrue(cacheCfg.isUseLazyDeserialization());
          assertFalse(cacheCfg.isExposeJmxStatistics());
       } finally {
          factory.stop();
       }
    }
    @Test
    public void testBuildDiffCacheNameTimestampsRegion() {
       final String timestamps = "org.hibernate.cache.spi.UpdateTimestampsCache";
       Properties p = new Properties();
       p.setProperty("hibernate.cache.infinispan.timestamps.cfg", "unrecommended-timestamps");
       InfinispanRegionFactory factory = createRegionFactory(p);
       EmbeddedCacheManager manager = factory.getCacheManager();
       try {
          assertFalse(factory.getDefinedConfigurations().contains("timestamp"));
          assertTrue(factory.getDefinedConfigurations().contains("unrecommended-timestamps"));
          assertTrue(factory.getTypeOverrides().get("timestamps").getCacheName().equals("unrecommended-timestamps"));
          Configuration config = new Configuration();
          config.setFetchInMemoryState(false);
          config.setCacheMode(CacheMode.REPL_SYNC);
          manager.defineConfiguration("unrecommended-timestamps", config);
          TimestampsRegionImpl region = (TimestampsRegionImpl) factory.buildTimestampsRegion(timestamps, p);
          CacheAdapter cache = region.getCacheAdapter();
          Configuration cacheCfg = cache.getConfiguration();
          assertEquals(EvictionStrategy.NONE, cacheCfg.getEvictionStrategy());
          assertEquals(CacheMode.REPL_SYNC, cacheCfg.getCacheMode());
          assertFalse(cacheCfg.isUseLazyDeserialization());
          assertFalse(cacheCfg.isExposeJmxStatistics());
       } finally {
          factory.stop();
       }
    }
    @Test
    public void testBuildTimestamRegionWithCacheNameOverride() {
       final String timestamps = "org.hibernate.cache.spi.UpdateTimestampsCache";
       Properties p = new Properties();
       p.setProperty("hibernate.cache.infinispan.timestamps.cfg", "mytimestamps-cache");
       InfinispanRegionFactory factory = createRegionFactory(p);
       try {
          factory.buildTimestampsRegion(timestamps, p);
          assertTrue(factory.getDefinedConfigurations().contains("mytimestamps-cache"));
       } finally {
          factory.stop();
       }
    }
    @Test
    public void testBuildTimestamRegionWithFifoEvictionOverride() {
       final String timestamps = "org.hibernate.cache.spi.UpdateTimestampsCache";
       Properties p = new Properties();
       p.setProperty("hibernate.cache.infinispan.timestamps.cfg", "mytimestamps-cache");
       p.setProperty("hibernate.cache.infinispan.timestamps.eviction.strategy", "FIFO");
       p.setProperty("hibernate.cache.infinispan.timestamps.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.timestamps.eviction.max_entries", "10000");
       InfinispanRegionFactory factory = null;
       try {
          factory = createRegionFactory(p);
          factory.buildTimestampsRegion(timestamps, p);
          assertTrue(factory.getDefinedConfigurations().contains("mytimestamps-cache"));
          fail("Should fail cos no eviction configurations are allowed for timestamp caches");
       } catch(CacheException ce) {
       } finally {
          if (factory != null) factory.stop();
       }
    }
    @Test
    public void testBuildTimestamRegionWithNoneEvictionOverride() {
       final String timestamps = "org.hibernate.cache.spi.UpdateTimestampsCache";
       Properties p = new Properties();
       p.setProperty("hibernate.cache.infinispan.timestamps.cfg", "timestamps-none-eviction");
       p.setProperty("hibernate.cache.infinispan.timestamps.eviction.strategy", "NONE");
       p.setProperty("hibernate.cache.infinispan.timestamps.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.timestamps.eviction.max_entries", "10000");
       InfinispanRegionFactory factory = createRegionFactory(p);
       EmbeddedCacheManager manager = factory.getCacheManager();
       manager.getGlobalConfiguration().setTransportClass(null);
       try {
          factory.buildTimestampsRegion(timestamps, p);
          assertTrue(factory.getDefinedConfigurations().contains("timestamps-none-eviction"));
       } finally {
          factory.stop();
       }
    }
    @Test
    public void testBuildQueryRegion() {
       final String query = "org.hibernate.cache.internal.StandardQueryCache";
       Properties p = new Properties();
       InfinispanRegionFactory factory = createRegionFactory(p);
       EmbeddedCacheManager manager = factory.getCacheManager();
       manager.getGlobalConfiguration().setTransportClass(null);
       try {
          assertTrue(factory.getDefinedConfigurations().contains("local-query"));
          QueryResultsRegionImpl region = (QueryResultsRegionImpl) factory.buildQueryResultsRegion(query, p);
          CacheAdapter cache = region.getCacheAdapter();
          Configuration cacheCfg = cache.getConfiguration();
          assertEquals(CacheMode.LOCAL, cacheCfg.getCacheMode());
          assertFalse(cacheCfg.isExposeJmxStatistics());
       } finally {
          factory.stop();
       }
    }
    @Test
    public void testBuildQueryRegionWithCustomRegionName() {
       final String queryRegionName = "myquery";
       Properties p = new Properties();
       p.setProperty("hibernate.cache.infinispan.myquery.cfg", "timestamps-none-eviction");
       p.setProperty("hibernate.cache.infinispan.myquery.eviction.strategy", "FIFO");
       p.setProperty("hibernate.cache.infinispan.myquery.eviction.wake_up_interval", "2222");
       p.setProperty("hibernate.cache.infinispan.myquery.eviction.max_entries", "11111");
       InfinispanRegionFactory factory = createRegionFactory(p);
       EmbeddedCacheManager manager = factory.getCacheManager();
       manager.getGlobalConfiguration().setTransportClass(null);
       try {
          assertTrue(factory.getDefinedConfigurations().contains("local-query"));
          QueryResultsRegionImpl region = (QueryResultsRegionImpl) factory.buildQueryResultsRegion(queryRegionName, p);
          assertNotNull(factory.getTypeOverrides().get(queryRegionName));
          assertTrue(factory.getDefinedConfigurations().contains(queryRegionName));
          CacheAdapter cache = region.getCacheAdapter();
          Configuration cacheCfg = cache.getConfiguration();
          assertEquals(EvictionStrategy.FIFO, cacheCfg.getEvictionStrategy());
          assertEquals(2222, cacheCfg.getEvictionWakeUpInterval());
          assertEquals(11111, cacheCfg.getEvictionMaxEntries());
       } finally {
          factory.stop();
       }
    }
    @Test
    public void testEnableStatistics() {
       Properties p = new Properties();
       p.setProperty("hibernate.cache.infinispan.statistics", "true");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.lifespan", "60000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.max_idle", "30000");
       p.setProperty("hibernate.cache.infinispan.entity.cfg", "myentity-cache");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.strategy", "FIFO");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.max_entries", "10000");
       InfinispanRegionFactory factory = createRegionFactory(p);
       EmbeddedCacheManager manager = factory.getCacheManager();
       try {
          assertTrue(manager.getGlobalConfiguration().isExposeGlobalJmxStatistics());
          EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion("com.acme.Address", p, null);
          CacheAdapter cache = region.getCacheAdapter();
          assertTrue(factory.getTypeOverrides().get("entity").isExposeStatistics());
          assertTrue(cache.getConfiguration().isExposeJmxStatistics());
 
          region = (EntityRegionImpl) factory.buildEntityRegion("com.acme.Person", p, null);
          cache = region.getCacheAdapter();
          assertTrue(factory.getTypeOverrides().get("com.acme.Person").isExposeStatistics());
          assertTrue(cache.getConfiguration().isExposeJmxStatistics());
 
          final String query = "org.hibernate.cache.internal.StandardQueryCache";
          QueryResultsRegionImpl queryRegion = (QueryResultsRegionImpl) factory.buildQueryResultsRegion(query, p);
          cache = queryRegion.getCacheAdapter();
          assertTrue(factory.getTypeOverrides().get("query").isExposeStatistics());
          assertTrue(cache.getConfiguration().isExposeJmxStatistics());
 
          final String timestamps = "org.hibernate.cache.spi.UpdateTimestampsCache";
          Configuration config = new Configuration();
          config.setFetchInMemoryState(false);
          manager.defineConfiguration("timestamps", config);
          TimestampsRegionImpl timestampsRegion = (TimestampsRegionImpl) factory.buildTimestampsRegion(timestamps, p);
          cache = timestampsRegion.getCacheAdapter();
          assertTrue(factory.getTypeOverrides().get("timestamps").isExposeStatistics());
          assertTrue(cache.getConfiguration().isExposeJmxStatistics());
 
          CollectionRegionImpl collectionRegion = (CollectionRegionImpl) factory.buildCollectionRegion("com.acme.Person.addresses", p, null);
          cache = collectionRegion.getCacheAdapter();
          assertTrue(factory.getTypeOverrides().get("collection").isExposeStatistics());
          assertTrue(cache.getConfiguration().isExposeJmxStatistics());
       } finally {
          factory.stop();
       }
    }
    @Test
    public void testDisableStatistics() {
       Properties p = new Properties();
       p.setProperty("hibernate.cache.infinispan.statistics", "false");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.lifespan", "60000");
       p.setProperty("hibernate.cache.infinispan.com.acme.Person.expiration.max_idle", "30000");
       p.setProperty("hibernate.cache.infinispan.entity.cfg", "myentity-cache");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.strategy", "FIFO");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.wake_up_interval", "3000");
       p.setProperty("hibernate.cache.infinispan.entity.eviction.max_entries", "10000");
       InfinispanRegionFactory factory = createRegionFactory(p);
       EmbeddedCacheManager manager = factory.getCacheManager();
       try {
          assertFalse(manager.getGlobalConfiguration().isExposeGlobalJmxStatistics());
          EntityRegionImpl region = (EntityRegionImpl) factory.buildEntityRegion("com.acme.Address", p, null);
          CacheAdapter cache = region.getCacheAdapter();
          assertFalse(factory.getTypeOverrides().get("entity").isExposeStatistics());
          assertFalse(cache.getConfiguration().isExposeJmxStatistics());
 
          region = (EntityRegionImpl) factory.buildEntityRegion("com.acme.Person", p, null);
          cache = region.getCacheAdapter();
          assertFalse(factory.getTypeOverrides().get("com.acme.Person").isExposeStatistics());
          assertFalse(cache.getConfiguration().isExposeJmxStatistics());
 
          final String query = "org.hibernate.cache.internal.StandardQueryCache";
          QueryResultsRegionImpl queryRegion = (QueryResultsRegionImpl) factory.buildQueryResultsRegion(query, p);
          cache = queryRegion.getCacheAdapter();
          assertFalse(factory.getTypeOverrides().get("query").isExposeStatistics());
          assertFalse(cache.getConfiguration().isExposeJmxStatistics());
 
          final String timestamps = "org.hibernate.cache.spi.UpdateTimestampsCache";
          Configuration config = new Configuration();
          config.setFetchInMemoryState(false);
          manager.defineConfiguration("timestamps", config);
          TimestampsRegionImpl timestampsRegion = (TimestampsRegionImpl) factory.buildTimestampsRegion(timestamps, p);
          cache = timestampsRegion.getCacheAdapter();
          assertFalse(factory.getTypeOverrides().get("timestamps").isExposeStatistics());
          assertFalse(cache.getConfiguration().isExposeJmxStatistics());
 
          CollectionRegionImpl collectionRegion = (CollectionRegionImpl) factory.buildCollectionRegion("com.acme.Person.addresses", p, null);
          cache = collectionRegion.getCacheAdapter();
          assertFalse(factory.getTypeOverrides().get("collection").isExposeStatistics());
          assertFalse(cache.getConfiguration().isExposeJmxStatistics());
       } finally {
          factory.stop();
       }
    }
 
    private InfinispanRegionFactory createRegionFactory(Properties p) {
       return createRegionFactory(null, p);
    }
 
    private InfinispanRegionFactory createRegionFactory(final EmbeddedCacheManager manager, Properties p) {
       final InfinispanRegionFactory factory = new InfinispanRegionFactory() {
          @Override
          protected org.infinispan.transaction.lookup.TransactionManagerLookup createTransactionManagerLookup(Settings settings, Properties properties) {
             return new HibernateTransactionManagerLookup(null, null) {
                @Override
                public TransactionManager getTransactionManager() throws Exception {
                   AbstractJtaPlatform jta = new JBossStandAloneJtaPlatform();
                   jta.injectServices(ServiceRegistryBuilder.buildServiceRegistry());
                   return jta.getTransactionManager();
                }
             };
          }
 
          @Override
          protected EmbeddedCacheManager createCacheManager(Properties properties) throws CacheException {
             if (manager != null)
                return manager;
             else
                return super.createCacheManager(properties);
          }
       };
       factory.start(null, p);
       return factory;
    }
 
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/NodeEnvironment.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/NodeEnvironment.java
index abeea66625..dd4d31de8c 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/NodeEnvironment.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/NodeEnvironment.java
@@ -1,155 +1,155 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cache.infinispan;
 
 import java.util.HashMap;
 import java.util.Map;
 import java.util.concurrent.Callable;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cache.infinispan.InfinispanRegionFactory;
 import org.hibernate.cache.infinispan.collection.CollectionRegionImpl;
 import org.hibernate.cache.infinispan.entity.EntityRegionImpl;
 import org.hibernate.cache.infinispan.util.FlagAdapter;
 import org.hibernate.cache.spi.CacheDataDescription;
 import org.hibernate.cfg.Configuration;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.test.cache.infinispan.util.CacheTestUtil;
 
 import static org.hibernate.cache.infinispan.util.CacheHelper.withinTx;
 
 /**
  * Defines the environment for a node.
  *
  * @author Steve Ebersole
  */
 public class NodeEnvironment {
 	private final Configuration configuration;
 
 	private StandardServiceRegistryImpl serviceRegistry;
 	private InfinispanRegionFactory regionFactory;
 
 	private Map<String,EntityRegionImpl> entityRegionMap;
 	private Map<String,CollectionRegionImpl> collectionRegionMap;
 
 	public NodeEnvironment(Configuration configuration) {
 		this.configuration = configuration;
 	}
 
 	public Configuration getConfiguration() {
 		return configuration;
 	}
 
 	public StandardServiceRegistryImpl getServiceRegistry() {
 		return serviceRegistry;
 	}
 
 	public EntityRegionImpl getEntityRegion(String name, CacheDataDescription cacheDataDescription) {
 		if ( entityRegionMap == null ) {
 			entityRegionMap = new HashMap<String, EntityRegionImpl>();
 			return buildAndStoreEntityRegion( name, cacheDataDescription );
 		}
 		EntityRegionImpl region = entityRegionMap.get( name );
 		if ( region == null ) {
 			region = buildAndStoreEntityRegion( name, cacheDataDescription );
 		}
 		return region;
 	}
 
 	private EntityRegionImpl buildAndStoreEntityRegion(String name, CacheDataDescription cacheDataDescription) {
 		EntityRegionImpl region = (EntityRegionImpl) regionFactory.buildEntityRegion(
 				name,
 				configuration.getProperties(),
 				cacheDataDescription
 		);
 		entityRegionMap.put( name, region );
 		return region;
 	}
 
 	public CollectionRegionImpl getCollectionRegion(String name, CacheDataDescription cacheDataDescription) {
 		if ( collectionRegionMap == null ) {
 			collectionRegionMap = new HashMap<String, CollectionRegionImpl>();
 			return buildAndStoreCollectionRegion( name, cacheDataDescription );
 		}
 		CollectionRegionImpl region = collectionRegionMap.get( name );
 		if ( region == null ) {
 			region = buildAndStoreCollectionRegion( name, cacheDataDescription );
 			collectionRegionMap.put( name, region );
 		}
 		return region;
 	}
 
 	private CollectionRegionImpl buildAndStoreCollectionRegion(String name, CacheDataDescription cacheDataDescription) {
 		CollectionRegionImpl region;
 		region = (CollectionRegionImpl) regionFactory.buildCollectionRegion(
 				name,
 				configuration.getProperties(),
 				cacheDataDescription
 		);
 		return region;
 	}
 
 	public void prepare() throws Exception {
-		serviceRegistry = (StandardServiceRegistryImpl) new ServiceRegistryBuilder()
+		serviceRegistry = (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder()
 				.applySettings( configuration.getProperties() )
 				.buildServiceRegistry();
 		regionFactory = CacheTestUtil.startRegionFactory( serviceRegistry, configuration );
 	}
 
 	public void release() throws Exception {
 		if ( entityRegionMap != null ) {
 			for ( final EntityRegionImpl region : entityRegionMap.values() ) {
 				withinTx(region.getTransactionManager(), new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                   region.getCacheAdapter().withFlags(FlagAdapter.CACHE_MODE_LOCAL).clear();
                   return null;
                }
             });
 				region.getCacheAdapter().stop();
 			}
 			entityRegionMap.clear();
 		}
 		if ( collectionRegionMap != null ) {
 			for ( final CollectionRegionImpl collectionRegion : collectionRegionMap.values() ) {
             withinTx(collectionRegion.getTransactionManager(), new Callable<Void>() {
                @Override
                public Void call() throws Exception {
                   collectionRegion.getCacheAdapter().withFlags( FlagAdapter.CACHE_MODE_LOCAL ).clear();
                   return null;
                }
             });
 				collectionRegion.getCacheAdapter().stop();
 			}
 			collectionRegionMap.clear();
 		}
 		if ( regionFactory != null ) {
 // Currently the RegionFactory is shutdown by its registration with the CacheTestSetup from CacheTestUtil when built
 			regionFactory.stop();
 		}
 		if ( serviceRegistry != null ) {
 			serviceRegistry.destroy();
 		}
 	}
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/ConcurrentWriteTest.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/ConcurrentWriteTest.java
index 2c92b77d6d..7ef3ca0ebc 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/ConcurrentWriteTest.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/ConcurrentWriteTest.java
@@ -1,557 +1,557 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cache.infinispan.functional;
 
 import java.io.PrintWriter;
 import java.io.StringWriter;
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Random;
 import java.util.Set;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CyclicBarrier;
 import java.util.concurrent.ExecutorService;
 import java.util.concurrent.Executors;
 import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 import javax.transaction.TransactionManager;
 
 import org.infinispan.util.logging.Log;
 import org.infinispan.util.logging.LogFactory;
 import org.junit.Test;
 
 import org.hibernate.FlushMode;
 import org.hibernate.Session;
 import org.hibernate.cache.infinispan.InfinispanRegionFactory;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cfg.Configuration;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.stat.SecondLevelCacheStatistics;
 import org.hibernate.test.cache.infinispan.functional.cluster.DualNodeConnectionProviderImpl;
 import org.hibernate.test.cache.infinispan.functional.cluster.DualNodeJtaPlatformImpl;
 import org.hibernate.test.cache.infinispan.functional.cluster.DualNodeJtaTransactionManagerImpl;
 import org.hibernate.test.cache.infinispan.functional.cluster.DualNodeTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 
 /**
  * @author nikita_tovstoles@mba.berkeley.edu
  * @author Galder Zamarreo
  */
 public class ConcurrentWriteTest extends SingleNodeTestCase {
 	private static final Log log = LogFactory.getLog( ConcurrentWriteTest.class );
 	private static final boolean trace = log.isTraceEnabled();
 	/**
 	 * when USER_COUNT==1, tests pass, when >4 tests fail
 	 */
 	private static final int USER_COUNT = 5;
 	private static final int ITERATION_COUNT = 150;
 	private static final int THINK_TIME_MILLIS = 10;
 	private static final long LAUNCH_INTERVAL_MILLIS = 10;
 	private static final Random random = new Random();
 
 	/**
 	 * kill switch used to stop all users when one fails
 	 */
 	private static volatile boolean TERMINATE_ALL_USERS = false;
 
 	/**
 	 * collection of IDs of all customers participating in this test
 	 */
 	private Set<Integer> customerIDs = new HashSet<Integer>();
 
 	private TransactionManager tm;
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( DualNodeTestCase.NODE_ID_PROP, DualNodeTestCase.LOCAL );
 		cfg.setProperty( DualNodeTestCase.NODE_ID_FIELD, DualNodeTestCase.LOCAL );
 	}
 
 	@Override
 	protected boolean getUseQueryCache() {
 		return true;
 	}
 
 	@Override
 	protected TransactionManager getTransactionManager() {
 		return DualNodeJtaTransactionManagerImpl.getInstance( DualNodeTestCase.LOCAL );
 	}
 
 	@Override
 	protected Class<? extends RegionFactory> getCacheRegionFactory() {
 		return InfinispanRegionFactory.class;
 	}
 
 	@Override
 	protected Class<? extends ConnectionProvider> getConnectionProviderClass() {
 		return DualNodeConnectionProviderImpl.class;
 	}
 
 	@Override
 	protected Class<? extends JtaPlatform> getJtaPlatform() {
 		return DualNodeJtaPlatformImpl.class;
 	}
 
 	@Override
 	protected void prepareTest() throws Exception {
 		super.prepareTest();
 		TERMINATE_ALL_USERS = false;
 	}
 
 	@Override
 	protected void cleanupTest() throws Exception {
 		try {
 			super.cleanupTest();
 		}
 		finally {
 			cleanup();
 			// DualNodeJtaTransactionManagerImpl.cleanupTransactions();
 			// DualNodeJtaTransactionManagerImpl.cleanupTransactionManagers();
 		}
 	}
 
 	@Test
 	public void testPingDb() throws Exception {
 		try {
 			beginTx();
 			sessionFactory()
 					.getCurrentSession()
 					.createQuery( "from " + Customer.class.getName() )
 					.list();
 		}
 		catch (Exception e) {
 			setRollbackOnlyTx( e );
 //         setRollbackOnly();
 //         fail("failed to query DB; exception=" + e);
 		}
 		finally {
 			commitOrRollbackTx();
 		}
 	}
 
 	@Test
 	public void testSingleUser() throws Exception {
 		// setup
 sessionFactory().getStatistics().clear();
 		Customer customer = createCustomer( 0 );
 		final Integer customerId = customer.getId();
 		getCustomerIDs().add( customerId );
 
 		assertNull( "contact exists despite not being added", getFirstContact( customerId ) );
 
 		// check that cache was hit
 		SecondLevelCacheStatistics customerSlcs = sessionFactory()
 				.getStatistics()
 				.getSecondLevelCacheStatistics( Customer.class.getName() );
 		assertEquals( customerSlcs.getPutCount(), 1 );
 		assertEquals( customerSlcs.getElementCountInMemory(), 1 );
 		assertEquals( customerSlcs.getEntries().size(), 1 );
 
 		log.infof( "Add contact to customer {0}", customerId );
 		SecondLevelCacheStatistics contactsCollectionSlcs = sessionFactory()
 				.getStatistics()
 				.getSecondLevelCacheStatistics( Customer.class.getName() + ".contacts" );
 		assertEquals( 1, contactsCollectionSlcs.getPutCount() );
 		assertEquals( 1, contactsCollectionSlcs.getElementCountInMemory() );
 		assertEquals( 1, contactsCollectionSlcs.getEntries().size() );
 
 		final Contact contact = addContact( customerId );
 		assertNotNull( "contact returned by addContact is null", contact );
 		assertEquals(
 				"Customer.contacts cache was not invalidated after addContact", 0,
 				contactsCollectionSlcs.getElementCountInMemory()
 		);
 
 		assertNotNull( "Contact missing after successful add call", getFirstContact( customerId ) );
 
 		// read everyone's contacts
 		readEveryonesFirstContact();
 
 		removeContact( customerId );
 		assertNull( "contact still exists after successful remove call", getFirstContact( customerId ) );
 
 	}
 
 	@Test
 	public void testManyUsers() throws Throwable {
 		try {
 			// setup - create users
 			for ( int i = 0; i < USER_COUNT; i++ ) {
 				Customer customer = createCustomer( 0 );
 				getCustomerIDs().add( customer.getId() );
 			}
 			assertEquals( "failed to create enough Customers", USER_COUNT, getCustomerIDs().size() );
 
 			final ExecutorService executor = Executors.newFixedThreadPool( USER_COUNT );
 
 			CyclicBarrier barrier = new CyclicBarrier( USER_COUNT + 1 );
 			List<Future<Void>> futures = new ArrayList<Future<Void>>( USER_COUNT );
 			for ( Integer customerId : getCustomerIDs() ) {
 				Future<Void> future = executor.submit( new UserRunner( customerId, barrier ) );
 				futures.add( future );
 				Thread.sleep( LAUNCH_INTERVAL_MILLIS ); // rampup
 			}
 //         barrier.await(); // wait for all threads to be ready
 			barrier.await( 2, TimeUnit.MINUTES ); // wait for all threads to finish
 			log.info( "All threads finished, let's shutdown the executor and check whether any exceptions were reported" );
 			for ( Future<Void> future : futures ) {
 				future.get();
 			}
 			log.info( "All future gets checked" );
 		}
 		catch (Throwable t) {
 			log.error( "Error running test", t );
 			throw t;
 		}
 	}
 
 	public void cleanup() throws Exception {
 		getCustomerIDs().clear();
 		String deleteContactHQL = "delete from Contact";
 		String deleteCustomerHQL = "delete from Customer";
 		beginTx();
 		try {
 			Session session = sessionFactory().getCurrentSession();
 			session.createQuery( deleteContactHQL ).setFlushMode( FlushMode.AUTO ).executeUpdate();
 			session.createQuery( deleteCustomerHQL ).setFlushMode( FlushMode.AUTO ).executeUpdate();
 		}
 		catch (Exception e) {
 			setRollbackOnlyTx( e );
 		}
 		finally {
 			commitOrRollbackTx();
 		}
 	}
 
 	private Customer createCustomer(int nameSuffix) throws Exception {
 		Customer customer = null;
 		beginTx();
 		try {
 			customer = new Customer();
 			customer.setName( "customer_" + nameSuffix );
 			customer.setContacts( new HashSet<Contact>() );
 			sessionFactory().getCurrentSession().persist( customer );
 		}
 		catch (Exception e) {
 			setRollbackOnlyTx( e );
 		}
 		finally {
 			commitOrRollbackTx();
 		}
 		return customer;
 	}
 
 	/**
 	 * read first contact of every Customer participating in this test. this forces concurrent cache
 	 * writes of Customer.contacts Collection cache node
 	 *
 	 * @return who cares
 	 * @throws java.lang.Exception
 	 */
 	private void readEveryonesFirstContact() throws Exception {
 		beginTx();
 		try {
 			for ( Integer customerId : getCustomerIDs() ) {
 				if ( TERMINATE_ALL_USERS ) {
 					setRollbackOnlyTx();
 					return;
 				}
 				Customer customer = (Customer) sessionFactory()
 						.getCurrentSession()
 						.load( Customer.class, customerId );
 				Set<Contact> contacts = customer.getContacts();
 				if ( !contacts.isEmpty() ) {
 					contacts.iterator().next();
 				}
 			}
 		}
 		catch (Exception e) {
 			setRollbackOnlyTx( e );
 		}
 		finally {
 			commitOrRollbackTx();
 		}
 	}
 
    /**
     * -load existing Customer -get customer's contacts; return 1st one
     * 
     * @param customerId
     * @return first Contact or null if customer has none
     */
    private Contact getFirstContact(Integer customerId) throws Exception {
       assert customerId != null;
       Contact firstContact = null;
       beginTx();
       try {
          final Customer customer = (Customer) sessionFactory()
 				 .getCurrentSession()
 				 .load(Customer.class, customerId);
          Set<Contact> contacts = customer.getContacts();
          firstContact = contacts.isEmpty() ? null : contacts.iterator().next();
          if (TERMINATE_ALL_USERS)
             setRollbackOnlyTx();
       } catch (Exception e) {
          setRollbackOnlyTx(e);
       } finally {
          commitOrRollbackTx();
       }
       return firstContact;
    }
 
    /**
     * -load existing Customer -create a new Contact and add to customer's contacts
     *
     * @param customerId
     * @return added Contact
     */
    private Contact addContact(Integer customerId) throws Exception {
       assert customerId != null;
       Contact contact = null;
       beginTx();
       try {
          final Customer customer = (Customer) sessionFactory()
 				 .getCurrentSession()
 				 .load(Customer.class, customerId);
          contact = new Contact();
          contact.setName("contact name");
          contact.setTlf("wtf is tlf?");
          contact.setCustomer(customer);
          customer.getContacts().add(contact);
          // assuming contact is persisted via cascade from customer
          if (TERMINATE_ALL_USERS)
             setRollbackOnlyTx();
       } catch (Exception e) {
          setRollbackOnlyTx(e);
       } finally {
          commitOrRollbackTx();
       }
       return contact;
    }
 
    /**
     * remove existing 'contact' from customer's list of contacts
     *
     * @param customerId
     * @throws IllegalStateException
     *            if customer does not own a contact
     */
    private void removeContact(Integer customerId) throws Exception {
       assert customerId != null;
 
 		beginTx();
 		try {
 			Customer customer = (Customer) sessionFactory()
 					.getCurrentSession()
 					.load( Customer.class, customerId );
 			Set<Contact> contacts = customer.getContacts();
 			if ( contacts.size() != 1 ) {
 				throw new IllegalStateException(
 						"can't remove contact: customer id=" + customerId
 								+ " expected exactly 1 contact, " + "actual count=" + contacts.size()
 				);
 			}
 
 			Contact contact = contacts.iterator().next();
 			contacts.remove( contact );
 			contact.setCustomer( null );
 
 			// explicitly delete Contact because hbm has no 'DELETE_ORPHAN' cascade?
 			// getEnvironment().getSessionFactory().getCurrentSession().delete(contact); //appears to
 			// not be needed
 
 			// assuming contact is persisted via cascade from customer
 
 			if ( TERMINATE_ALL_USERS ) {
 				setRollbackOnlyTx();
 			}
 		}
 		catch (Exception e) {
 			setRollbackOnlyTx( e );
 		}
 		finally {
 			commitOrRollbackTx();
 		}
 	}
 
 	/**
 	 * @return the customerIDs
 	 */
 	public Set<Integer> getCustomerIDs() {
 		return customerIDs;
 	}
 
 	private String statusOfRunnersToString(Set<UserRunner> runners) {
 		assert runners != null;
 
 		StringBuilder sb = new StringBuilder(
 				"TEST CONFIG [userCount=" + USER_COUNT
 						+ ", iterationsPerUser=" + ITERATION_COUNT + ", thinkTimeMillis="
 						+ THINK_TIME_MILLIS + "] " + " STATE of UserRunners: "
 		);
 
 		for ( UserRunner r : runners ) {
 			sb.append( r.toString() + System.getProperty( "line.separator" ) );
 		}
 		return sb.toString();
 	}
 
 	class UserRunner implements Callable<Void> {
 		private final CyclicBarrier barrier;
 		final private Integer customerId;
 		private int completedIterations = 0;
 		private Throwable causeOfFailure;
 
 		public UserRunner(Integer cId, CyclicBarrier barrier) {
 			assert cId != null;
 			this.customerId = cId;
 			this.barrier = barrier;
 		}
 
 		private boolean contactExists() throws Exception {
 			return getFirstContact( customerId ) != null;
 		}
 
 		public Void call() throws Exception {
 			// name this thread for easier log tracing
 			Thread.currentThread().setName( "UserRunnerThread-" + getCustomerId() );
 			log.info( "Wait for all executions paths to be ready to perform calls" );
 			try {
 //            barrier.await();
 				for ( int i = 0; i < ITERATION_COUNT && !TERMINATE_ALL_USERS; i++ ) {
 					contactExists();
 					if ( trace ) {
 						log.trace( "Add contact for customer " + customerId );
 					}
 					addContact( customerId );
 					if ( trace ) {
 						log.trace( "Added contact" );
 					}
 					thinkRandomTime();
 					contactExists();
 					thinkRandomTime();
 					if ( trace ) {
 						log.trace( "Read all customers' first contact" );
 					}
 					// read everyone's contacts
 					readEveryonesFirstContact();
 					if ( trace ) {
 						log.trace( "Read completed" );
 					}
 					thinkRandomTime();
 					if ( trace ) {
 						log.trace( "Remove contact of customer" + customerId );
 					}
 					removeContact( customerId );
 					if ( trace ) {
 						log.trace( "Removed contact" );
 					}
 					contactExists();
 					thinkRandomTime();
 					++completedIterations;
 					if ( log.isTraceEnabled() ) {
 						log.tracef( "Iteration completed {0}", completedIterations );
 					}
 				}
 			}
 			catch (Throwable t) {
 				TERMINATE_ALL_USERS = true;
 				log.error( "Error", t );
 				throw new Exception( t );
 				// rollback current transaction if any
 				// really should not happen since above methods all follow begin-commit-rollback pattern
 				// try {
 				// if
 				// (DualNodeJtaTransactionManagerImpl.getInstance(DualNodeTestUtil.LOCAL).getTransaction()
 				// != null) {
 				// DualNodeJtaTransactionManagerImpl.getInstance(DualNodeTestUtil.LOCAL).rollback();
 				// }
 				// } catch (SystemException ex) {
 				// throw new RuntimeException("failed to rollback tx", ex);
 				// }
 			}
 			finally {
 				log.info( "Wait for all execution paths to finish" );
 				barrier.await();
 			}
 			return null;
 		}
 
 		public boolean isSuccess() {
 			return ITERATION_COUNT == getCompletedIterations();
 		}
 
 		public int getCompletedIterations() {
 			return completedIterations;
 		}
 
 		public Throwable getCauseOfFailure() {
 			return causeOfFailure;
 		}
 
 		public Integer getCustomerId() {
 			return customerId;
 		}
 
 		@Override
 		public String toString() {
 			return super.toString() + "[customerId=" + getCustomerId() + " iterationsCompleted="
 					+ getCompletedIterations() + " completedAll=" + isSuccess() + " causeOfFailure="
 					+ (this.causeOfFailure != null ? getStackTrace( causeOfFailure ) : "") + "] ";
 		}
 	}
 
 	public static String getStackTrace(Throwable throwable) {
 		StringWriter sw = new StringWriter();
 		PrintWriter pw = new PrintWriter( sw, true );
 		throwable.printStackTrace( pw );
 		return sw.getBuffer().toString();
 	}
 
 	/**
 	 * sleep between 0 and THINK_TIME_MILLIS.
 	 *
 	 * @throws RuntimeException if sleep is interrupted or TERMINATE_ALL_USERS flag was set to true i n the
 	 * meantime
 	 */
 	private void thinkRandomTime() {
 		try {
 			Thread.sleep( random.nextInt( THINK_TIME_MILLIS ) );
 		}
 		catch (InterruptedException ex) {
 			throw new RuntimeException( "sleep interrupted", ex );
 		}
 
 		if ( TERMINATE_ALL_USERS ) {
 			throw new RuntimeException( "told to terminate (because a UserRunner had failed)" );
 		}
 	}
 
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/SingleNodeTestCase.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/SingleNodeTestCase.java
index a270cd252f..d383500b38 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/SingleNodeTestCase.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/SingleNodeTestCase.java
@@ -1,151 +1,151 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cache.infinispan.functional;
 
 import javax.transaction.Status;
 import javax.transaction.TransactionManager;
 
 import org.infinispan.util.logging.Log;
 import org.infinispan.util.logging.LogFactory;
 import org.junit.Before;
 
 import org.hibernate.cache.infinispan.InfinispanRegionFactory;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
 import org.hibernate.engine.transaction.spi.TransactionFactory;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.test.cache.infinispan.tm.JtaPlatformImpl;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 /**
  * @author Galder Zamarreo
  * @since 3.5
  */
 public abstract class SingleNodeTestCase extends BaseCoreFunctionalTestCase {
 	private static final Log log = LogFactory.getLog( SingleNodeTestCase.class );
 	protected TransactionManager tm;
 
 	@Before
 	public void prepare() {
 		tm = getTransactionManager();
 	}
 
 	protected TransactionManager getTransactionManager() {
 		try {
 			Class<? extends JtaPlatform> jtaPlatformClass = getJtaPlatform();
 			if ( jtaPlatformClass == null ) {
 				return null;
 			}
 			else {
 				return jtaPlatformClass.newInstance().retrieveTransactionManager();
 			}
 		}
 		catch (Exception e) {
 			log.error( "Error", e );
 			throw new RuntimeException( e );
 		}
 	}
 
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 				"cache/infinispan/functional/Item.hbm.xml",
 				"cache/infinispan/functional/Customer.hbm.xml",
 				"cache/infinispan/functional/Contact.hbm.xml"
 		};
 	}
 
 	@Override
 	public String getCacheConcurrencyStrategy() {
 		return "transactional";
 	}
 
 	protected Class<? extends RegionFactory> getCacheRegionFactory() {
 		return InfinispanRegionFactory.class;
 	}
 
 	protected Class<? extends TransactionFactory> getTransactionFactoryClass() {
 		return CMTTransactionFactory.class;
 	}
 
 	protected Class<? extends ConnectionProvider> getConnectionProviderClass() {
 		return org.hibernate.test.cache.infinispan.tm.XaConnectionProvider.class;
 	}
 
 	protected Class<? extends JtaPlatform> getJtaPlatform() {
 		return JtaPlatformImpl.class;
 	}
 
 	protected boolean getUseQueryCache() {
 		return true;
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.USE_SECOND_LEVEL_CACHE, "true" );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 		cfg.setProperty( Environment.USE_QUERY_CACHE, String.valueOf( getUseQueryCache() ) );
 		cfg.setProperty( Environment.CACHE_REGION_FACTORY, getCacheRegionFactory().getName() );
 
 		if ( getJtaPlatform() != null ) {
 			cfg.getProperties().put( AvailableSettings.JTA_PLATFORM, getJtaPlatform() );
 		}
 		cfg.setProperty( Environment.TRANSACTION_STRATEGY, getTransactionFactoryClass().getName() );
 		cfg.setProperty( Environment.CONNECTION_PROVIDER, getConnectionProviderClass().getName() );
 	}
 
 	protected void beginTx() throws Exception {
 		tm.begin();
 	}
 
 	protected void setRollbackOnlyTx() throws Exception {
 		tm.setRollbackOnly();
 	}
 
 	protected void setRollbackOnlyTx(Exception e) throws Exception {
 		log.error( "Error", e );
 		tm.setRollbackOnly();
 		throw e;
 	}
 
 	protected void setRollbackOnlyTxExpected(Exception e) throws Exception {
 		log.debug( "Expected behaivour", e );
 		tm.setRollbackOnly();
 	}
 
 	protected void commitOrRollbackTx() throws Exception {
 		if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 			tm.commit();
 		}
 		else {
 			tm.rollback();
 		}
 	}
 
 }
\ No newline at end of file
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/bulk/BulkOperationsTestCase.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/bulk/BulkOperationsTestCase.java
index 2a92e251a2..ffc9da4ac4 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/bulk/BulkOperationsTestCase.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/bulk/BulkOperationsTestCase.java
@@ -1,420 +1,420 @@
 /*
  * JBoss, Home of Professional Open Source.
  * Copyright 2009, Red Hat, Inc. and/or it's affiliates, and individual contributors
  * as indicated by the @author tags. See the copyright.txt file in the
  * distribution for a full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as
  * published by the Free Software Foundation; either version 2.1 of
  * the License, or (at your option) any later version.
  *
  * This software is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this software; if not, write to the Free
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
 package org.hibernate.test.cache.infinispan.functional.bulk;
 
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 import javax.transaction.Status;
 import javax.transaction.TransactionManager;
 
 import org.junit.Test;
 
 import org.hibernate.FlushMode;
 import org.hibernate.Session;
 import org.hibernate.cache.infinispan.InfinispanRegionFactory;
 import org.hibernate.cache.spi.RegionFactory;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
 import org.hibernate.engine.transaction.spi.TransactionFactory;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.stat.SecondLevelCacheStatistics;
 import org.hibernate.test.cache.infinispan.functional.Contact;
 import org.hibernate.test.cache.infinispan.functional.Customer;
 import org.hibernate.test.cache.infinispan.tm.JtaPlatformImpl;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNotNull;
 import static org.junit.Assert.assertNull;
 
 /**
  * BulkOperationsTestCase.
  *
  * @author Galder Zamarreo
  * @since 3.5
  */
 public class BulkOperationsTestCase extends BaseCoreFunctionalTestCase {
 	private TransactionManager tm;
 
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 				"cache/infinispan/functional/Contact.hbm.xml",
 				"cache/infinispan/functional/Customer.hbm.xml"
 		};
 	}
 
 	@Override
 	public String getCacheConcurrencyStrategy() {
 		return "transactional";
 	}
 
 	protected Class<? extends RegionFactory> getCacheRegionFactory() {
 		return InfinispanRegionFactory.class;
 	}
 
 	protected Class<? extends TransactionFactory> getTransactionFactoryClass() {
 		return CMTTransactionFactory.class;
 	}
 
 	protected Class<? extends ConnectionProvider> getConnectionProviderClass() {
 		return org.hibernate.test.cache.infinispan.tm.XaConnectionProvider.class;
 	}
 
 	protected JtaPlatform getJtaPlatform() {
 		return new JtaPlatformImpl();
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		super.configure( cfg );
 		cfg.setProperty( Environment.USE_SECOND_LEVEL_CACHE, "true" );
 		cfg.setProperty( Environment.GENERATE_STATISTICS, "true" );
 		cfg.setProperty( Environment.USE_QUERY_CACHE, "false" );
 		cfg.setProperty( Environment.CACHE_REGION_FACTORY, getCacheRegionFactory().getName() );
 		cfg.setProperty( Environment.TRANSACTION_STRATEGY, getTransactionFactoryClass().getName() );
 		cfg.getProperties().put( AvailableSettings.JTA_PLATFORM, getJtaPlatform() );
 		cfg.setProperty( Environment.CONNECTION_PROVIDER, getConnectionProviderClass().getName() );
 	}
 
 	@Test
 	public void testBulkOperations() throws Throwable {
 		boolean cleanedUp = false;
 		try {
 			tm = getJtaPlatform().retrieveTransactionManager();
 
 			createContacts();
 
 			List<Integer> rhContacts = getContactsByCustomer( "Red Hat" );
 			assertNotNull( "Red Hat contacts exist", rhContacts );
 			assertEquals( "Created expected number of Red Hat contacts", 10, rhContacts.size() );
 
 			SecondLevelCacheStatistics contactSlcs = sessionFactory()
 					.getStatistics()
 					.getSecondLevelCacheStatistics( Contact.class.getName() );
 			assertEquals( 20, contactSlcs.getElementCountInMemory() );
 
 			assertEquals( "Deleted all Red Hat contacts", 10, deleteContacts() );
 			assertEquals( 0, contactSlcs.getElementCountInMemory() );
 
 			List<Integer> jbContacts = getContactsByCustomer( "JBoss" );
 			assertNotNull( "JBoss contacts exist", jbContacts );
 			assertEquals( "JBoss contacts remain", 10, jbContacts.size() );
 
 			for ( Integer id : rhContacts ) {
 				assertNull( "Red Hat contact " + id + " cannot be retrieved", getContact( id ) );
 			}
 			rhContacts = getContactsByCustomer( "Red Hat" );
 			if ( rhContacts != null ) {
 				assertEquals( "No Red Hat contacts remain", 0, rhContacts.size() );
 			}
 
 			updateContacts( "Kabir", "Updated" );
 			assertEquals( 0, contactSlcs.getElementCountInMemory() );
 			for ( Integer id : jbContacts ) {
 				Contact contact = getContact( id );
 				assertNotNull( "JBoss contact " + id + " exists", contact );
 				String expected = ("Kabir".equals( contact.getName() )) ? "Updated" : "2222";
 				assertEquals( "JBoss contact " + id + " has correct TLF", expected, contact.getTlf() );
 			}
 
 			List<Integer> updated = getContactsByTLF( "Updated" );
 			assertNotNull( "Got updated contacts", updated );
 			assertEquals( "Updated contacts", 5, updated.size() );
 
 			updateContactsWithOneManual( "Kabir", "UpdatedAgain" );
 			assertEquals( contactSlcs.getElementCountInMemory(), 0 );
 			for ( Integer id : jbContacts ) {
 				Contact contact = getContact( id );
 				assertNotNull( "JBoss contact " + id + " exists", contact );
 				String expected = ("Kabir".equals( contact.getName() )) ? "UpdatedAgain" : "2222";
 				assertEquals( "JBoss contact " + id + " has correct TLF", expected, contact.getTlf() );
 			}
 
 			updated = getContactsByTLF( "UpdatedAgain" );
 			assertNotNull( "Got updated contacts", updated );
 			assertEquals( "Updated contacts", 5, updated.size() );
 		}
 		catch (Throwable t) {
 			cleanedUp = true;
 			cleanup( true );
 			throw t;
 		}
 		finally {
 			// cleanup the db so we can run this test multiple times w/o restarting the cluster
 			if ( !cleanedUp ) {
 				cleanup( false );
 			}
 		}
 	}
 
 	public void createContacts() throws Exception {
 		tm.begin();
 		try {
 			for ( int i = 0; i < 10; i++ ) {
 				createCustomer( i );
 			}
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				tm.rollback();
 			}
 		}
 	}
 
 	public int deleteContacts() throws Exception {
 		String deleteHQL = "delete Contact where customer in ";
 		deleteHQL += " (select customer FROM Customer as customer ";
 		deleteHQL += " where customer.name = :cName)";
 
 		tm.begin();
 		try {
 			Session session = sessionFactory().getCurrentSession();
 			int rowsAffected = session.createQuery( deleteHQL ).setFlushMode( FlushMode.AUTO )
 					.setParameter( "cName", "Red Hat" ).executeUpdate();
 			tm.commit();
 			return rowsAffected;
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				try {
 					tm.rollback();
 				}
 				catch (Exception ee) {
 					// ignored
 				}
 			}
 		}
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	public List<Integer> getContactsByCustomer(String customerName) throws Exception {
 		String selectHQL = "select contact.id from Contact contact";
 		selectHQL += " where contact.customer.name = :cName";
 
 		tm.begin();
 		try {
 
 			Session session = sessionFactory().getCurrentSession();
 			return session.createQuery( selectHQL )
 					.setFlushMode( FlushMode.AUTO )
 					.setParameter( "cName", customerName )
 					.list();
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				tm.rollback();
 			}
 		}
 	}
 
 	@SuppressWarnings( {"unchecked"})
 	public List<Integer> getContactsByTLF(String tlf) throws Exception {
 		String selectHQL = "select contact.id from Contact contact";
 		selectHQL += " where contact.tlf = :cTLF";
 
 		tm.begin();
 		try {
 			Session session = sessionFactory().getCurrentSession();
 			return session.createQuery( selectHQL )
 					.setFlushMode( FlushMode.AUTO )
 					.setParameter( "cTLF", tlf )
 					.list();
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				tm.rollback();
 			}
 		}
 	}
 
 	public int updateContacts(String name, String newTLF) throws Exception {
 		String updateHQL = "update Contact set tlf = :cNewTLF where name = :cName";
 		tm.begin();
 		try {
 			Session session = sessionFactory().getCurrentSession();
 			return session.createQuery( updateHQL )
 					.setFlushMode( FlushMode.AUTO )
 					.setParameter( "cNewTLF", newTLF )
 					.setParameter( "cName", name )
 					.executeUpdate();
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				tm.rollback();
 			}
 		}
 	}
 
 	public int updateContactsWithOneManual(String name, String newTLF) throws Exception {
 		String queryHQL = "from Contact c where c.name = :cName";
 		String updateHQL = "update Contact set tlf = :cNewTLF where name = :cName";
 		tm.begin();
 		try {
 			Session session = sessionFactory().getCurrentSession();
 			@SuppressWarnings("unchecked")
 			List<Contact> list = session.createQuery( queryHQL ).setParameter( "cName", name ).list();
 			list.get( 0 ).setTlf( newTLF );
 			return session.createQuery( updateHQL )
 					.setFlushMode( FlushMode.AUTO )
 					.setParameter( "cNewTLF", newTLF )
 					.setParameter( "cName", name )
 					.executeUpdate();
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				tm.rollback();
 			}
 		}
 	}
 
 	public Contact getContact(Integer id) throws Exception {
 		tm.begin();
 		try {
 			Session session = sessionFactory().getCurrentSession();
 			return (Contact) session.get( Contact.class, id );
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				tm.rollback();
 			}
 		}
 	}
 
 	public void cleanup(boolean ignore) throws Exception {
 		String deleteContactHQL = "delete from Contact";
 		String deleteCustomerHQL = "delete from Customer";
 		tm.begin();
 		try {
 			Session session = sessionFactory().getCurrentSession();
 			session.createQuery( deleteContactHQL ).setFlushMode( FlushMode.AUTO ).executeUpdate();
 			session.createQuery( deleteCustomerHQL ).setFlushMode( FlushMode.AUTO ).executeUpdate();
 		}
 		catch (Exception e) {
 			tm.setRollbackOnly();
 			throw e;
 		}
 		finally {
 			if ( tm.getStatus() == Status.STATUS_ACTIVE ) {
 				tm.commit();
 			}
 			else {
 				if ( !ignore ) {
 					try {
 						tm.rollback();
 					}
 					catch (Exception ee) {
 						// ignored
 					}
 				}
 			}
 		}
 	}
 
 	private Customer createCustomer(int id) throws Exception {
 		System.out.println( "CREATE CUSTOMER " + id );
 		try {
 			Customer customer = new Customer();
 			customer.setName( (id % 2 == 0) ? "JBoss" : "Red Hat" );
 			Set<Contact> contacts = new HashSet<Contact>();
 
 			Contact kabir = new Contact();
 			kabir.setCustomer( customer );
 			kabir.setName( "Kabir" );
 			kabir.setTlf( "1111" );
 			contacts.add( kabir );
 
 			Contact bill = new Contact();
 			bill.setCustomer( customer );
 			bill.setName( "Bill" );
 			bill.setTlf( "2222" );
 			contacts.add( bill );
 
 			customer.setContacts( contacts );
 
 			Session s = openSession();
 			s.getTransaction().begin();
 			s.persist( customer );
 			s.getTransaction().commit();
 			s.close();
 
 			return customer;
 		}
 		finally {
 			System.out.println( "CREATE CUSTOMER " + id + " -  END" );
 		}
 	}
 
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/cluster/DualNodeConnectionProviderImpl.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/cluster/DualNodeConnectionProviderImpl.java
index 53afc9aa93..78318ae252 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/cluster/DualNodeConnectionProviderImpl.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/cluster/DualNodeConnectionProviderImpl.java
@@ -1,116 +1,116 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007, Red Hat, Inc. and/or it's affiliates or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors. All third-party contributions are
  * distributed under license by Red Hat, Inc. and/or it's affiliates.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cache.infinispan.functional.cluster;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.Map;
 
 import org.hibernate.HibernateException;
 import org.hibernate.service.UnknownUnwrapTypeException;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.spi.Configurable;
 import org.hibernate.service.spi.Stoppable;
 import org.hibernate.testing.env.ConnectionProviderBuilder;
 
 /**
  * A {@link ConnectionProvider} implementation adding JTA-style transactionality around the returned
  * connections using the {@link DualNodeJtaTransactionManagerImpl}.
  * 
  * @author Brian Stansberry
  */
 public class DualNodeConnectionProviderImpl implements ConnectionProvider, Configurable {
    private static ConnectionProvider actualConnectionProvider = ConnectionProviderBuilder.buildConnectionProvider();
    private String nodeId;
    private boolean isTransactional;
 
 	@Override
 	public boolean isUnwrappableAs(Class unwrapType) {
 		return DualNodeConnectionProviderImpl.class.isAssignableFrom( unwrapType ) ||
 				ConnectionProvider.class.isAssignableFrom( unwrapType );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> T unwrap(Class<T> unwrapType) {
 		if ( DualNodeConnectionProviderImpl.class.isAssignableFrom( unwrapType ) ) {
 			return (T) this;
 		}
 		else if ( ConnectionProvider.class.isAssignableFrom( unwrapType ) ) {
 			return (T) actualConnectionProvider;
 		}
 		else {
 			throw new UnknownUnwrapTypeException( unwrapType );
 		}
 	}
 
    public static ConnectionProvider getActualConnectionProvider() {
       return actualConnectionProvider;
    }
 
    public void setNodeId(String nodeId) throws HibernateException {
       if (nodeId == null) {
          throw new HibernateException( "nodeId not configured" );
 	  }
 	  this.nodeId = nodeId;
    }
 
    public Connection getConnection() throws SQLException {
       DualNodeJtaTransactionImpl currentTransaction = DualNodeJtaTransactionManagerImpl
                .getInstance(nodeId).getCurrentTransaction();
       if (currentTransaction == null) {
          isTransactional = false;
          return actualConnectionProvider.getConnection();
       } else {
          isTransactional = true;
          Connection connection = currentTransaction.getEnlistedConnection();
          if (connection == null) {
             connection = actualConnectionProvider.getConnection();
             currentTransaction.enlistConnection(connection);
          }
          return connection;
       }
    }
 
    public void closeConnection(Connection conn) throws SQLException {
       if (!isTransactional) {
          conn.close();
       }
    }
 
    public void close() throws HibernateException {
 	   if ( actualConnectionProvider instanceof Stoppable ) {
 		   ( ( Stoppable ) actualConnectionProvider ).stop();
 	   }
    }
 
    public boolean supportsAggressiveRelease() {
       return true;
    }
 
 	@Override
 	public void configure(Map configurationValues) {
 		nodeId = (String) configurationValues.get( "nodeId" );
 	}
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/cluster/DualNodeJtaPlatformImpl.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/cluster/DualNodeJtaPlatformImpl.java
index 80fe23837e..ac8f980aad 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/cluster/DualNodeJtaPlatformImpl.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/cluster/DualNodeJtaPlatformImpl.java
@@ -1,87 +1,87 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cache.infinispan.functional.cluster;
 
 import java.util.Map;
 import javax.transaction.Synchronization;
 import javax.transaction.SystemException;
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 import org.hibernate.HibernateException;
 import org.hibernate.TransactionException;
 import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 import org.hibernate.service.spi.Configurable;
 
 /**
  * @author Steve Ebersole
  */
 public class DualNodeJtaPlatformImpl implements JtaPlatform, Configurable {
 	private String nodeId;
 
 	@Override
 	public void configure(Map configurationValues) {
       nodeId = (String) configurationValues.get( DualNodeTestCase.NODE_ID_PROP );
       if ( nodeId == null ) {
 		  throw new HibernateException(DualNodeTestCase.NODE_ID_PROP + " not configured");
 	  }
 	}
 
 	@Override
 	public TransactionManager retrieveTransactionManager() {
 		return DualNodeJtaTransactionManagerImpl.getInstance( nodeId );
 	}
 
 	@Override
 	public UserTransaction retrieveUserTransaction() {
 		throw new TransactionException( "UserTransaction not used in these tests" );
 	}
 
 	@Override
 	public Object getTransactionIdentifier(Transaction transaction) {
 		return transaction;
 	}
 
 	@Override
 	public boolean canRegisterSynchronization() {
 		return JtaStatusHelper.isActive( retrieveTransactionManager() );
 	}
 
 	@Override
 	public void registerSynchronization(Synchronization synchronization) {
 		try {
 			retrieveTransactionManager().getTransaction().registerSynchronization( synchronization );
 		}
 		catch (Exception e) {
 			throw new TransactionException( "Could not obtain transaction from TM" );
 		}
 	}
 
 	@Override
 	public int getCurrentStatus() throws SystemException {
 		return JtaStatusHelper.getStatus( retrieveTransactionManager() );
 	}
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/cluster/DualNodeTestCase.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/cluster/DualNodeTestCase.java
index 4735d0693a..d75ef850d6 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/cluster/DualNodeTestCase.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/functional/cluster/DualNodeTestCase.java
@@ -1,189 +1,189 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2009-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cache.infinispan.functional.cluster;
 
 import org.infinispan.util.logging.Log;
 import org.infinispan.util.logging.LogFactory;
 import org.junit.After;
 import org.junit.Before;
 
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.testing.junit4.BaseCoreFunctionalTestCase;
 
 /**
  * @author Galder Zamarreo
  * @since 3.5
  */
 public abstract class DualNodeTestCase extends BaseCoreFunctionalTestCase {
 	private static final Log log = LogFactory.getLog( DualNodeTestCase.class );
 
 	public static final String NODE_ID_PROP = "hibernate.test.cluster.node.id";
 	public static final String NODE_ID_FIELD = "nodeId";
 	public static final String LOCAL = "local";
 	public static final String REMOTE = "remote";
 
 	private SecondNodeEnvironment secondNodeEnvironment;
 
 	@Override
 	public String[] getMappings() {
 		return new String[] {
 				"cache/infinispan/functional/Contact.hbm.xml", "cache/infinispan/functional/Customer.hbm.xml"
 		};
 	}
 
 	@Override
 	public String getCacheConcurrencyStrategy() {
 		return "transactional";
 	}
 
 	@Override
 	public void configure(Configuration cfg) {
 		standardConfigure( cfg );
 		cfg.setProperty( NODE_ID_PROP, LOCAL );
 		cfg.setProperty( NODE_ID_FIELD, LOCAL );
 	}
 
 	@Override
 	protected void cleanupTest() throws Exception {
 		cleanupTransactionManagement();
 	}
 
 	protected void cleanupTransactionManagement() {
 		DualNodeJtaTransactionManagerImpl.cleanupTransactions();
 		DualNodeJtaTransactionManagerImpl.cleanupTransactionManagers();
 	}
 
 	@Before
 	public void prepare() throws Exception {
 		secondNodeEnvironment = new SecondNodeEnvironment();
 	}
 
 	@After
 	public void unPrepare() {
 		if ( secondNodeEnvironment != null ) {
 			secondNodeEnvironment.shutDown();
 		}
 	}
 
 	protected SecondNodeEnvironment secondNodeEnvironment() {
 		return secondNodeEnvironment;
 	}
 
 	protected Class getCacheRegionFactory() {
 		return ClusterAwareRegionFactory.class;
 	}
 
 	protected Class getConnectionProviderClass() {
 		return DualNodeConnectionProviderImpl.class;
 	}
 
 	protected Class getJtaPlatformClass() {
 		return DualNodeJtaPlatformImpl.class;
 	}
 
 	protected Class getTransactionFactoryClass() {
 		return CMTTransactionFactory.class;
 	}
 
 	protected void sleep(long ms) {
 		try {
 			Thread.sleep( ms );
 		}
 		catch (InterruptedException e) {
 			log.warn( "Interrupted during sleep", e );
 		}
 	}
 
 	protected boolean getUseQueryCache() {
 		return true;
 	}
 
 	protected void configureSecondNode(Configuration cfg) {
 
 	}
 
 	protected void standardConfigure(Configuration cfg) {
 		super.configure( cfg );
 
 		cfg.setProperty( Environment.CONNECTION_PROVIDER, getConnectionProviderClass().getName() );
 		cfg.setProperty( AvailableSettings.JTA_PLATFORM, getJtaPlatformClass().getName() );
 		cfg.setProperty( Environment.TRANSACTION_STRATEGY, getTransactionFactoryClass().getName() );
 		cfg.setProperty( Environment.CACHE_REGION_FACTORY, getCacheRegionFactory().getName() );
 		cfg.setProperty( Environment.USE_QUERY_CACHE, String.valueOf( getUseQueryCache() ) );
 	}
 
 	public class SecondNodeEnvironment {
 		private Configuration configuration;
 		private StandardServiceRegistryImpl serviceRegistry;
 		private SessionFactoryImplementor sessionFactory;
 
 		public SecondNodeEnvironment() {
 			configuration = constructConfiguration();
 			standardConfigure( configuration );
 			configuration.setProperty( NODE_ID_PROP, REMOTE );
 			configuration.setProperty( NODE_ID_FIELD, REMOTE );
 			configureSecondNode( configuration );
 			addMappings(configuration);
 			configuration.buildMappings();
 			applyCacheSettings( configuration );
 			afterConfigurationBuilt( configuration );
 			serviceRegistry = buildServiceRegistry( configuration );
 			sessionFactory = (SessionFactoryImplementor) configuration.buildSessionFactory( serviceRegistry );
 		}
 
 		public Configuration getConfiguration() {
 			return configuration;
 		}
 
 		public StandardServiceRegistryImpl getServiceRegistry() {
 			return serviceRegistry;
 		}
 
 		public SessionFactoryImplementor getSessionFactory() {
 			return sessionFactory;
 		}
 
 		public void shutDown() {
 			if ( sessionFactory != null ) {
 				try {
 					sessionFactory.close();
 				}
 				catch (Exception ignore) {
 				}
 			}
 			if ( serviceRegistry != null ) {
 				try {
 					serviceRegistry.destroy();
 				}
 				catch (Exception ignore) {
 				}
 			}
 		}
 	}
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/query/QueryRegionImplTestCase.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/query/QueryRegionImplTestCase.java
index 7d52f2df21..3991bd708c 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/query/QueryRegionImplTestCase.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/query/QueryRegionImplTestCase.java
@@ -1,357 +1,358 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007, Red Hat, Inc. and/or it's affiliates or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors. All third-party contributions are
  * distributed under license by Red Hat, Inc. and/or it's affiliates.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cache.infinispan.query;
 
 import java.util.Properties;
 import java.util.concurrent.Callable;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.TimeUnit;
 
 import junit.framework.AssertionFailedError;
 import org.infinispan.notifications.Listener;
 import org.infinispan.notifications.cachelistener.annotation.CacheEntryVisited;
 import org.infinispan.notifications.cachelistener.event.CacheEntryVisitedEvent;
 import org.infinispan.transaction.tm.BatchModeTransactionManager;
 import org.infinispan.util.concurrent.IsolationLevel;
 import org.jboss.logging.Logger;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cache.infinispan.InfinispanRegionFactory;
 import org.hibernate.cache.infinispan.util.CacheAdapter;
 import org.hibernate.cache.infinispan.util.CacheAdapterImpl;
 import org.hibernate.cache.infinispan.util.CacheHelper;
 import org.hibernate.cache.internal.StandardQueryCache;
 import org.hibernate.cache.spi.CacheDataDescription;
 import org.hibernate.cache.spi.GeneralDataRegion;
 import org.hibernate.cache.spi.QueryResultsRegion;
 import org.hibernate.cache.spi.Region;
 import org.hibernate.cfg.Configuration;
-import org.hibernate.service.ServiceRegistryBuilder;
+
 import org.hibernate.test.cache.infinispan.AbstractGeneralDataRegionTestCase;
 import org.hibernate.test.cache.infinispan.util.CacheTestUtil;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertFalse;
 import static org.junit.Assert.assertTrue;
 
 /**
  * Tests of QueryResultRegionImpl.
  *
  * @author Galder Zamarreo
  * @since 3.5
  */
 public class QueryRegionImplTestCase extends AbstractGeneralDataRegionTestCase {
 	private static final Logger log = Logger.getLogger( QueryRegionImplTestCase.class );
 
 	@Override
 	protected Region createRegion(
 			InfinispanRegionFactory regionFactory,
 			String regionName,
 			Properties properties,
 			CacheDataDescription cdd) {
 		return regionFactory.buildQueryResultsRegion( regionName, properties );
 	}
 
 	@Override
 	protected String getStandardRegionName(String regionPrefix) {
 		return regionPrefix + "/" + StandardQueryCache.class.getName();
 	}
 
    @Override
    protected void regionPut(final GeneralDataRegion region) throws Exception {
       CacheHelper.withinTx(BatchModeTransactionManager.getInstance(), new Callable<Void>() {
          @Override
          public Void call() throws Exception {
             region.put(KEY, VALUE1);
             return null;
          }
       });
    }
 
    @Override
    protected void regionEvict(final GeneralDataRegion region) throws Exception {
       CacheHelper.withinTx(BatchModeTransactionManager.getInstance(), new Callable<Void>() {
          @Override
          public Void call() throws Exception {
             region.evict(KEY);
             return null;
          }
       });
    }
 
    @Override
 	protected CacheAdapter getInfinispanCache(InfinispanRegionFactory regionFactory) {
 		return CacheAdapterImpl.newInstance(regionFactory.getCacheManager().getCache( "local-query" ).getAdvancedCache());
 	}
 
 	@Override
 	protected Configuration createConfiguration() {
 		return CacheTestUtil.buildCustomQueryCacheConfiguration( "test", "replicated-query" );
 	}
 
 	private void putDoesNotBlockGetTest() throws Exception {
 		Configuration cfg = createConfiguration();
 		InfinispanRegionFactory regionFactory = CacheTestUtil.startRegionFactory(
-				new ServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
+				new StandardServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
 				cfg,
 				getCacheTestSupport()
 		);
 
 		// Sleep a bit to avoid concurrent FLUSH problem
 		avoidConcurrentFlush();
 
 		final QueryResultsRegion region = regionFactory.buildQueryResultsRegion(
 				getStandardRegionName( REGION_PREFIX ),
 				cfg.getProperties()
 		);
 
 		region.put( KEY, VALUE1 );
 		assertEquals( VALUE1, region.get( KEY ) );
 
 		final CountDownLatch readerLatch = new CountDownLatch( 1 );
 		final CountDownLatch writerLatch = new CountDownLatch( 1 );
 		final CountDownLatch completionLatch = new CountDownLatch( 1 );
 		final ExceptionHolder holder = new ExceptionHolder();
 
 		Thread reader = new Thread() {
 			@Override
 			public void run() {
 				try {
 					BatchModeTransactionManager.getInstance().begin();
 					log.debug( "Transaction began, get value for key" );
 					assertTrue( VALUE2.equals( region.get( KEY ) ) == false );
 					BatchModeTransactionManager.getInstance().commit();
 				}
 				catch (AssertionFailedError e) {
 					holder.a1 = e;
 					rollback();
 				}
 				catch (Exception e) {
 					holder.e1 = e;
 					rollback();
 				}
 				finally {
 					readerLatch.countDown();
 				}
 			}
 		};
 
 		Thread writer = new Thread() {
 			@Override
 			public void run() {
 				try {
 					BatchModeTransactionManager.getInstance().begin();
 					log.debug( "Put value2" );
 					region.put( KEY, VALUE2 );
 					log.debug( "Put finished for value2, await writer latch" );
 					writerLatch.await();
 					log.debug( "Writer latch finished" );
 					BatchModeTransactionManager.getInstance().commit();
 					log.debug( "Transaction committed" );
 				}
 				catch (Exception e) {
 					holder.e2 = e;
 					rollback();
 				}
 				finally {
 					completionLatch.countDown();
 				}
 			}
 		};
 
 		reader.setDaemon( true );
 		writer.setDaemon( true );
 
 		writer.start();
 		assertFalse( "Writer is blocking", completionLatch.await( 100, TimeUnit.MILLISECONDS ) );
 
 		// Start the reader
 		reader.start();
 		assertTrue( "Reader finished promptly", readerLatch.await( 1000000000, TimeUnit.MILLISECONDS ) );
 
 		writerLatch.countDown();
 		assertTrue( "Reader finished promptly", completionLatch.await( 100, TimeUnit.MILLISECONDS ) );
 
 		assertEquals( VALUE2, region.get( KEY ) );
 
 		if ( holder.a1 != null ) {
 			throw holder.a1;
 		}
 		else if ( holder.a2 != null ) {
 			throw holder.a2;
 		}
 
 		assertEquals( "writer saw no exceptions", null, holder.e1 );
 		assertEquals( "reader saw no exceptions", null, holder.e2 );
 	}
 
 	public void testGetDoesNotBlockPut() throws Exception {
 		getDoesNotBlockPutTest();
 	}
 
 	private void getDoesNotBlockPutTest() throws Exception {
 		Configuration cfg = createConfiguration();
 		InfinispanRegionFactory regionFactory = CacheTestUtil.startRegionFactory(
-				new ServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
+				new StandardServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
 				cfg,
 				getCacheTestSupport()
 		);
 
 		// Sleep a bit to avoid concurrent FLUSH problem
 		avoidConcurrentFlush();
 
 		final QueryResultsRegion region = regionFactory.buildQueryResultsRegion(
 				getStandardRegionName( REGION_PREFIX ),
 				cfg.getProperties()
 		);
 
 		region.put( KEY, VALUE1 );
 		assertEquals( VALUE1, region.get( KEY ) );
 
 		// final Fqn rootFqn = getRegionFqn(getStandardRegionName(REGION_PREFIX), REGION_PREFIX);
 		final CacheAdapter jbc = getInfinispanCache( regionFactory );
 
 		final CountDownLatch blockerLatch = new CountDownLatch( 1 );
 		final CountDownLatch writerLatch = new CountDownLatch( 1 );
 		final CountDownLatch completionLatch = new CountDownLatch( 1 );
 		final ExceptionHolder holder = new ExceptionHolder();
 
 		Thread blocker = new Thread() {
 
 			@Override
 			public void run() {
 				// Fqn toBlock = new Fqn(rootFqn, KEY);
 				GetBlocker blocker = new GetBlocker( blockerLatch, KEY );
 				try {
 					jbc.addListener( blocker );
 
 					BatchModeTransactionManager.getInstance().begin();
 					region.get( KEY );
 					BatchModeTransactionManager.getInstance().commit();
 				}
 				catch (Exception e) {
 					holder.e1 = e;
 					rollback();
 				}
 				finally {
 					jbc.removeListener( blocker );
 				}
 			}
 		};
 
 		Thread writer = new Thread() {
 
 			@Override
 			public void run() {
 				try {
 					writerLatch.await();
 
 					BatchModeTransactionManager.getInstance().begin();
 					region.put( KEY, VALUE2 );
 					BatchModeTransactionManager.getInstance().commit();
 				}
 				catch (Exception e) {
 					holder.e2 = e;
 					rollback();
 				}
 				finally {
 					completionLatch.countDown();
 				}
 			}
 		};
 
 		blocker.setDaemon( true );
 		writer.setDaemon( true );
 
 		boolean unblocked = false;
 		try {
 			blocker.start();
 			writer.start();
 
 			assertFalse( "Blocker is blocking", completionLatch.await( 100, TimeUnit.MILLISECONDS ) );
 			// Start the writer
 			writerLatch.countDown();
 			assertTrue( "Writer finished promptly", completionLatch.await( 100, TimeUnit.MILLISECONDS ) );
 
 			blockerLatch.countDown();
 			unblocked = true;
 
 			if ( IsolationLevel.REPEATABLE_READ.equals( jbc.getConfiguration().getIsolationLevel() ) ) {
 				assertEquals( VALUE1, region.get( KEY ) );
 			}
 			else {
 				assertEquals( VALUE2, region.get( KEY ) );
 			}
 
 			if ( holder.a1 != null ) {
 				throw holder.a1;
 			}
 			else if ( holder.a2 != null ) {
 				throw holder.a2;
 			}
 
 			assertEquals( "blocker saw no exceptions", null, holder.e1 );
 			assertEquals( "writer saw no exceptions", null, holder.e2 );
 		}
 		finally {
 			if ( !unblocked ) {
 				blockerLatch.countDown();
 			}
 		}
 	}
 
 	@Listener
 	public class GetBlocker {
 
 		private CountDownLatch latch;
 		// private Fqn fqn;
 		private Object key;
 
 		GetBlocker(
 				CountDownLatch latch,
 				Object key
 		) {
 			this.latch = latch;
 			this.key = key;
 		}
 
 		@CacheEntryVisited
 		public void nodeVisisted(CacheEntryVisitedEvent event) {
 			if ( event.isPre() && event.getKey().equals( key ) ) {
 				try {
 					latch.await();
 				}
 				catch (InterruptedException e) {
 					log.error( "Interrupted waiting for latch", e );
 				}
 			}
 		}
 	}
 
 	private class ExceptionHolder {
 		Exception e1;
 		Exception e2;
 		AssertionFailedError a1;
 		AssertionFailedError a2;
 	}
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/timestamp/TimestampsRegionImplTestCase.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/timestamp/TimestampsRegionImplTestCase.java
index b0dffd9576..29e2ba7329 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/timestamp/TimestampsRegionImplTestCase.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/timestamp/TimestampsRegionImplTestCase.java
@@ -1,211 +1,212 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007, Red Hat, Inc. and/or it's affiliates or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors. All third-party contributions are
  * distributed under license by Red Hat, Inc. and/or it's affiliates.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cache.infinispan.timestamp;
 
 import java.util.Properties;
 
 import org.infinispan.AdvancedCache;
 import org.infinispan.notifications.Listener;
 import org.infinispan.notifications.cachelistener.annotation.CacheEntryActivated;
 import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;
 import org.infinispan.notifications.cachelistener.annotation.CacheEntryEvicted;
 import org.infinispan.notifications.cachelistener.annotation.CacheEntryInvalidated;
 import org.infinispan.notifications.cachelistener.annotation.CacheEntryLoaded;
 import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;
 import org.infinispan.notifications.cachelistener.annotation.CacheEntryPassivated;
 import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;
 import org.infinispan.notifications.cachelistener.annotation.CacheEntryVisited;
 import org.infinispan.notifications.cachelistener.event.Event;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cache.infinispan.InfinispanRegionFactory;
 import org.hibernate.cache.infinispan.impl.ClassLoaderAwareCache;
 import org.hibernate.cache.infinispan.timestamp.TimestampsRegionImpl;
 import org.hibernate.cache.infinispan.util.CacheAdapter;
 import org.hibernate.cache.infinispan.util.CacheAdapterImpl;
 import org.hibernate.cache.infinispan.util.FlagAdapter;
 import org.hibernate.cache.spi.CacheDataDescription;
 import org.hibernate.cache.spi.Region;
 import org.hibernate.cache.spi.UpdateTimestampsCache;
 import org.hibernate.cfg.Configuration;
-import org.hibernate.service.ServiceRegistryBuilder;
+
 import org.hibernate.test.cache.infinispan.AbstractGeneralDataRegionTestCase;
 import org.hibernate.test.cache.infinispan.functional.classloader.Account;
 import org.hibernate.test.cache.infinispan.functional.classloader.AccountHolder;
 import org.hibernate.test.cache.infinispan.functional.classloader.SelectedClassnameClassLoader;
 import org.hibernate.test.cache.infinispan.util.CacheTestUtil;
 
 /**
  * Tests of TimestampsRegionImpl.
  * 
  * @author Galder Zamarreo
  * @since 3.5
  */
 public class TimestampsRegionImplTestCase extends AbstractGeneralDataRegionTestCase {
 
     @Override
    protected String getStandardRegionName(String regionPrefix) {
       return regionPrefix + "/" + UpdateTimestampsCache.class.getName();
    }
 
    @Override
    protected Region createRegion(InfinispanRegionFactory regionFactory, String regionName, Properties properties, CacheDataDescription cdd) {
       return regionFactory.buildTimestampsRegion(regionName, properties);
    }
 
    @Override
    protected CacheAdapter getInfinispanCache(InfinispanRegionFactory regionFactory) {
       return CacheAdapterImpl.newInstance(regionFactory.getCacheManager().getCache("timestamps").getAdvancedCache());
    }
 
    public void testClearTimestampsRegionInIsolated() throws Exception {
       Configuration cfg = createConfiguration();
       InfinispanRegionFactory regionFactory = CacheTestUtil.startRegionFactory(
-			  new ServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
+			  new StandardServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
 			  cfg,
 			  getCacheTestSupport()
 	  );
       // Sleep a bit to avoid concurrent FLUSH problem
       avoidConcurrentFlush();
 
       Configuration cfg2 = createConfiguration();
       InfinispanRegionFactory regionFactory2 = CacheTestUtil.startRegionFactory(
-			  new ServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
+			  new StandardServiceRegistryBuilder().applySettings( cfg.getProperties() ).buildServiceRegistry(),
 			  cfg2,
 			  getCacheTestSupport()
 	  );
       // Sleep a bit to avoid concurrent FLUSH problem
       avoidConcurrentFlush();
 
       TimestampsRegionImpl region = (TimestampsRegionImpl) regionFactory.buildTimestampsRegion(getStandardRegionName(REGION_PREFIX), cfg.getProperties());
       TimestampsRegionImpl region2 = (TimestampsRegionImpl) regionFactory2.buildTimestampsRegion(getStandardRegionName(REGION_PREFIX), cfg2.getProperties());
 //      QueryResultsRegion region2 = regionFactory2.buildQueryResultsRegion(getStandardRegionName(REGION_PREFIX), cfg2.getProperties());
 
 //      ClassLoader cl = Thread.currentThread().getContextClassLoader();
 //      Thread.currentThread().setContextClassLoader(cl.getParent());
 //      log.info("TCCL is " + cl.getParent());
 
       Account acct = new Account();
       acct.setAccountHolder(new AccountHolder());
       region.getCacheAdapter().withFlags(FlagAdapter.FORCE_SYNCHRONOUS).put(acct, "boo");
 
 //      region.put(acct, "boo");
 //
 //      region.evictAll();
 
 //      Account acct = new Account();
 //      acct.setAccountHolder(new AccountHolder());
 
 
 
    }
 
    @Override
    protected Configuration createConfiguration() {
       return CacheTestUtil.buildConfiguration("test", MockInfinispanRegionFactory.class, false, true);
    }
 
    public static class MockInfinispanRegionFactory extends InfinispanRegionFactory {
 
       public MockInfinispanRegionFactory() {
       }
 
       public MockInfinispanRegionFactory(Properties props) {
          super(props);
       }
 
 //      @Override
 //      protected TimestampsRegionImpl createTimestampsRegion(CacheAdapter cacheAdapter, String regionName) {
 //         return new MockTimestampsRegionImpl(cacheAdapter, regionName, getTransactionManager(), this);
 //      }
 
       @Override
       protected AdvancedCache createCacheWrapper(AdvancedCache cache) {
          return new ClassLoaderAwareCache(cache, Thread.currentThread().getContextClassLoader()) {
             @Override
             public void addListener(Object listener) {
                super.addListener(new MockClassLoaderAwareListener(listener, this));
             }
          };
       }
 
       //      @Override
 //      protected EmbeddedCacheManager createCacheManager(Properties properties) throws CacheException {
 //         try {
 //            EmbeddedCacheManager manager = new DefaultCacheManager(InfinispanRegionFactory.DEF_INFINISPAN_CONFIG_RESOURCE);
 //            org.infinispan.config.Configuration ispnCfg = new org.infinispan.config.Configuration();
 //            ispnCfg.setCacheMode(org.infinispan.config.Configuration.CacheMode.REPL_SYNC);
 //            manager.defineConfiguration("timestamps", ispnCfg);
 //            return manager;
 //         } catch (IOException e) {
 //            throw new CacheException("Unable to create default cache manager", e);
 //         }
 //      }
 
       @Listener      
       public static class MockClassLoaderAwareListener extends ClassLoaderAwareCache.ClassLoaderAwareListener {
          MockClassLoaderAwareListener(Object listener, ClassLoaderAwareCache cache) {
             super(listener, cache);
          }
 
          @CacheEntryActivated
          @CacheEntryCreated
          @CacheEntryEvicted
          @CacheEntryInvalidated
          @CacheEntryLoaded
          @CacheEntryModified
          @CacheEntryPassivated
          @CacheEntryRemoved
          @CacheEntryVisited
          public void event(Event event) throws Throwable {
             ClassLoader cl = Thread.currentThread().getContextClassLoader();
             String notFoundPackage = "org.hibernate.test.cache.infinispan.functional.classloader";
             String[] notFoundClasses = { notFoundPackage + ".Account", notFoundPackage + ".AccountHolder" };
             SelectedClassnameClassLoader visible = new SelectedClassnameClassLoader(null, null, notFoundClasses, cl);
             Thread.currentThread().setContextClassLoader(visible);
             super.event(event);
             Thread.currentThread().setContextClassLoader(cl);            
          }
       }
    }
 
 //   @Listener
 //   public static class MockTimestampsRegionImpl extends TimestampsRegionImpl {
 //
 //      public MockTimestampsRegionImpl(CacheAdapter cacheAdapter, String name, TransactionManager transactionManager, RegionFactory factory) {
 //         super(cacheAdapter, name, transactionManager, factory);
 //      }
 //
 //      @CacheEntryModified
 //      public void nodeModified(CacheEntryModifiedEvent event) {
 ////         ClassLoader cl = Thread.currentThread().getContextClassLoader();
 ////         String notFoundPackage = "org.hibernate.test.cache.infinispan.functional.classloader";
 ////         String[] notFoundClasses = { notFoundPackage + ".Account", notFoundPackage + ".AccountHolder" };
 ////         SelectedClassnameClassLoader visible = new SelectedClassnameClassLoader(null, null, notFoundClasses, cl);
 ////         Thread.currentThread().setContextClassLoader(visible);
 //         super.nodeModified(event);
 ////         Thread.currentThread().setContextClassLoader(cl);
 //      }
 //   }
 
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/tm/JBossStandaloneJtaExampleTest.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/tm/JBossStandaloneJtaExampleTest.java
index bc6b699a1e..73e2388a78 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/tm/JBossStandaloneJtaExampleTest.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/tm/JBossStandaloneJtaExampleTest.java
@@ -1,318 +1,318 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors. All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cache.infinispan.tm;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.Iterator;
 import java.util.Properties;
 import javax.naming.Context;
 import javax.naming.InitialContext;
 import javax.naming.Name;
 import javax.naming.NameNotFoundException;
 import javax.naming.Reference;
 import javax.naming.StringRefAddr;
 import javax.transaction.Status;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 import org.enhydra.jdbc.standard.StandardXADataSource;
 import org.infinispan.transaction.lookup.JBossStandaloneJTAManagerLookup;
 import org.infinispan.util.logging.Log;
 import org.infinispan.util.logging.LogFactory;
 import org.jboss.util.naming.NonSerializableFactory;
 import org.jnp.interfaces.NamingContext;
 import org.jnp.server.Main;
 import org.jnp.server.NamingServer;
 import org.junit.After;
 import org.junit.Before;
 import org.junit.Test;
 
 import org.hibernate.Session;
 import org.hibernate.SessionFactory;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.jta.platform.internal.JBossStandAloneJtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.internal.JBossStandAloneJtaPlatform;
 import org.hibernate.stat.Statistics;
 import org.hibernate.test.cache.infinispan.functional.Item;
 import org.hibernate.testing.ServiceRegistryBuilder;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertNull;
 
 /**
  * This is an example test based on http://community.jboss.org/docs/DOC-14617 that shows how to interact with
  * Hibernate configured with Infinispan second level cache provider using JTA transactions.
  *
  * In this test, an XADataSource wrapper is in use where we have associated our transaction manager to it so that
  * commits/rollbacks are propagated to the database as well.
  *
  * @author Galder Zamarreo
  * @since 3.5
  */
 public class JBossStandaloneJtaExampleTest {
    private static final Log log = LogFactory.getLog(JBossStandaloneJtaExampleTest.class);
    private static final JBossStandaloneJTAManagerLookup lookup = new JBossStandaloneJTAManagerLookup();
    Context ctx;
    Main jndiServer;
    private ServiceRegistry serviceRegistry;
 
    @Before
    public void setUp() throws Exception {
       jndiServer = startJndiServer();
       ctx = createJndiContext();
       // Inject configuration to initialise transaction manager from config classloader
       lookup.init(new org.infinispan.config.Configuration());
       bindTransactionManager();
       bindUserTransaction();
       bindDataSource();
    }
 
    @After
    public void tearDown() throws Exception {
       try {
          ctx.close();
          jndiServer.stop();
 	  }
 	  finally {
 		  if ( serviceRegistry != null ) {
 			  ServiceRegistryBuilder.destroy( serviceRegistry );
 		  }
 	  }
    }
    @Test
    public void testPersistAndLoadUnderJta() throws Exception {
       Item item;
       SessionFactory sessionFactory = buildSessionFactory();
       try {
          UserTransaction ut = (UserTransaction) ctx.lookup("UserTransaction");
          ut.begin();
          try {
             Session session = sessionFactory.openSession();
             session.getTransaction().begin();
             item = new Item("anItem", "An item owned by someone");
             session.persist(item);
             session.getTransaction().commit();
             session.close();
          } catch(Exception e) {
             ut.setRollbackOnly();
             throw e;
          } finally {
             if (ut.getStatus() == Status.STATUS_ACTIVE)
                ut.commit();
             else
                ut.rollback();
          }
 
          ut = (UserTransaction) ctx.lookup("UserTransaction");
          ut.begin();
          try {
             Session session = sessionFactory.openSession();
             session.getTransaction().begin();
             Item found = (Item) session.load(Item.class, item.getId());
             Statistics stats = session.getSessionFactory().getStatistics();
             log.info(stats.toString());
             assertEquals(item.getDescription(), found.getDescription());
             assertEquals(0, stats.getSecondLevelCacheMissCount());
             assertEquals(1, stats.getSecondLevelCacheHitCount());
             session.delete(found);
             session.getTransaction().commit();
             session.close();
          } catch(Exception e) {
             ut.setRollbackOnly();
             throw e;
          } finally {
             if (ut.getStatus() == Status.STATUS_ACTIVE)
                ut.commit();
             else
                ut.rollback();
          }
 
          ut = (UserTransaction) ctx.lookup("UserTransaction");
          ut.begin();
          try {
             Session session = sessionFactory.openSession();
             session.getTransaction().begin();
             assertNull(session.get(Item.class, item.getId()));
             session.getTransaction().commit();
             session.close();
          } catch(Exception e) {
             ut.setRollbackOnly();
             throw e;
          } finally {
             if (ut.getStatus() == Status.STATUS_ACTIVE)
                ut.commit();
             else
                ut.rollback();
          }
       } finally {
          if (sessionFactory != null)
             sessionFactory.close();
       }
 
    }
 
    public static class ExtendedXADataSource extends StandardXADataSource { // XAPOOL
       @Override
       public Connection getConnection() throws SQLException {
 
          if (getTransactionManager() == null) { // although already set before, it results null again after retrieving the datasource by jndi
             TransactionManager tm;  // this is because the TransactionManager information is not serialized.
             try {
                tm = lookup.getTransactionManager();
             } catch (Exception e) {
                throw new SQLException(e);
             }
             setTransactionManager(tm);  //  resets the TransactionManager on the datasource retrieved by jndi,
             //  this makes the datasource JTA-aware
          }
 
          // According to Enhydra documentation, here we must return the connection of our XAConnection
          // see http://cvs.forge.objectweb.org/cgi-bin/viewcvs.cgi/xapool/xapool/examples/xapooldatasource/DatabaseHelper.java?sortby=rev
          return super.getXAConnection().getConnection();
       }
 
       @Override
       public <T> T unwrap(Class<T> iface) throws SQLException {
          return null;  // JDK6 stuff
       }
 
       @Override
       public boolean isWrapperFor(Class<?> iface) throws SQLException {
          return false;  // JDK6 stuff
       }
    }
 
    private Main startJndiServer() throws Exception {
       // Create an in-memory jndi
       NamingServer namingServer = new NamingServer();
       NamingContext.setLocal(namingServer);
       Main namingMain = new Main();
       namingMain.setInstallGlobalService(true);
       namingMain.setPort(-1);
       namingMain.start();
       return namingMain;
    }
 
    private Context createJndiContext() throws Exception {
       Properties props = new Properties();
       props.put(Context.INITIAL_CONTEXT_FACTORY, "org.jnp.interfaces.NamingContextFactory");
       props.put("java.naming.factory.url.pkgs", "org.jboss.naming:org.jnp.interfaces");
       return new InitialContext(props);
    }
 
    private void bindTransactionManager() throws Exception {
       // as JBossTransactionManagerLookup extends JNDITransactionManagerLookup we must also register the TransactionManager
       bind("java:/TransactionManager", lookup.getTransactionManager(), lookup.getTransactionManager().getClass(), ctx);
    }
 
    private void bindUserTransaction() throws Exception {
       // also the UserTransaction must be registered on jndi: org.hibernate.engine.transaction.internal.jta.JtaTransactionFactory#getUserTransaction() requires this
       bind("UserTransaction", lookup.getUserTransaction(), lookup.getUserTransaction().getClass(), ctx);
    }
 
    private void bindDataSource() throws Exception {
       ExtendedXADataSource xads = new ExtendedXADataSource();
       xads.setDriverName("org.h2.Driver");
       xads.setUrl("jdbc:h2:mem:db1;DB_CLOSE_DELAY=-1;MVCC=TRUE");
       ctx.bind("java:/MyDatasource", xads);
    }
 
    /**
     * Helper method that binds the a non serializable object to the JNDI tree.
     *
     * @param jndiName  Name under which the object must be bound
     * @param who       Object to bind in JNDI
     * @param classType Class type under which should appear the bound object
     * @param ctx       Naming context under which we bind the object
     * @throws Exception Thrown if a naming exception occurs during binding
     */
    private void bind(String jndiName, Object who, Class classType, Context ctx) throws Exception {
       // Ah ! This service isn't serializable, so we use a helper class
       NonSerializableFactory.bind(jndiName, who);
       Name n = ctx.getNameParser("").parse(jndiName);
       while (n.size() > 1) {
          String ctxName = n.get(0);
          try {
             ctx = (Context) ctx.lookup(ctxName);
          } catch (NameNotFoundException e) {
             System.out.println("Creating subcontext:" + ctxName);
             ctx = ctx.createSubcontext(ctxName);
          }
          n = n.getSuffix(1);
       }
 
       // The helper class NonSerializableFactory uses address type nns, we go on to
       // use the helper class to bind the service object in JNDI
       StringRefAddr addr = new StringRefAddr("nns", jndiName);
       Reference ref = new Reference(classType.getName(), addr, NonSerializableFactory.class.getName(), null);
       ctx.rebind(n.get(0), ref);
    }
 
    private void unbind(String jndiName, Context ctx) throws Exception {
       NonSerializableFactory.unbind(jndiName);
       ctx.unbind(jndiName);
    }
 
    private SessionFactory buildSessionFactory() {
       // Extra options located in src/test/resources/hibernate.properties
       Configuration cfg = new Configuration();
       cfg.setProperty(Environment.DIALECT, "org.hibernate.dialect.HSQLDialect");
       cfg.setProperty(Environment.HBM2DDL_AUTO, "create-drop");
       cfg.setProperty(Environment.DATASOURCE, "java:/MyDatasource");
       cfg.setProperty(Environment.JNDI_CLASS, "org.jnp.interfaces.NamingContextFactory");
       cfg.setProperty(Environment.TRANSACTION_MANAGER_STRATEGY, "org.hibernate.transaction.JBossTransactionManagerLookup");
       cfg.setProperty(Environment.TRANSACTION_STRATEGY, "org.hibernate.transaction.JTATransactionFactory");
       cfg.setProperty(Environment.CURRENT_SESSION_CONTEXT_CLASS, "jta");
       cfg.setProperty(Environment.RELEASE_CONNECTIONS, "auto");
       cfg.setProperty(Environment.USE_SECOND_LEVEL_CACHE, "true");
       cfg.setProperty(Environment.USE_QUERY_CACHE, "true");
       cfg.setProperty(Environment.CACHE_REGION_FACTORY, "org.hibernate.cache.infinispan.InfinispanRegionFactory");
 
       Properties envProps = Environment.getProperties();
       envProps.put(AvailableSettings.JTA_PLATFORM, new JBossStandAloneJtaPlatform());
       serviceRegistry = ServiceRegistryBuilder.buildServiceRegistry(envProps);
 
       String[] mappings = new String[]{"org/hibernate/test/cache/infinispan/functional/Item.hbm.xml"};
       for (String mapping : mappings) {
          cfg.addResource(mapping, Thread.currentThread().getContextClassLoader());
       }
       cfg.buildMappings();
       Iterator iter = cfg.getClassMappings();
       while (iter.hasNext()) {
          PersistentClass clazz = (PersistentClass) iter.next();
          cfg.setCacheConcurrencyStrategy(clazz.getEntityName(), "transactional");
       }
       iter = cfg.getCollectionMappings();
       while (iter.hasNext()) {
          Collection coll = (Collection) iter.next();
          cfg.setCollectionCacheConcurrencyStrategy(coll.getRole(), "transactional");
       }
       return cfg.buildSessionFactory( serviceRegistry );
    }
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/tm/JtaPlatformImpl.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/tm/JtaPlatformImpl.java
index 95db052882..20e0674c09 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/tm/JtaPlatformImpl.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/tm/JtaPlatformImpl.java
@@ -1,74 +1,74 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cache.infinispan.tm;
 
 import javax.transaction.Synchronization;
 import javax.transaction.SystemException;
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 import org.hibernate.TransactionException;
 import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 
 /**
  * @author Steve Ebersole
  */
 public class JtaPlatformImpl implements JtaPlatform {
 	@Override
 	public TransactionManager retrieveTransactionManager() {
 		return XaTransactionManagerImpl.getInstance();
 	}
 
 	@Override
 	public UserTransaction retrieveUserTransaction() {
 		throw new TransactionException( "UserTransaction not used in these tests" );
 	}
 
 	@Override
 	public Object getTransactionIdentifier(Transaction transaction) {
 		return transaction;
 	}
 
 	@Override
 	public boolean canRegisterSynchronization() {
 		return JtaStatusHelper.isActive( XaTransactionManagerImpl.getInstance() );
 	}
 
 	@Override
 	public void registerSynchronization(Synchronization synchronization) {
 		try {
 			XaTransactionManagerImpl.getInstance().getTransaction().registerSynchronization( synchronization );
 		}
 		catch (Exception e) {
 			throw new TransactionException( "Could not obtain transaction from TM" );
 		}
 	}
 
 	@Override
 	public int getCurrentStatus() throws SystemException {
 		return JtaStatusHelper.getStatus( XaTransactionManagerImpl.getInstance() );
 	}
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/tm/XaConnectionProvider.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/tm/XaConnectionProvider.java
index e0ec86a820..2be132d95c 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/tm/XaConnectionProvider.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/tm/XaConnectionProvider.java
@@ -1,105 +1,105 @@
 /*
  * JBoss, Home of Professional Open Source.
  * Copyright 2009, Red Hat, Inc. and/or it's affiliates, and individual contributors
  * as indicated by the @author tags. See the copyright.txt file in the
  * distribution for a full listing of individual contributors.
  *
  * This is free software; you can redistribute it and/or modify it
  * under the terms of the GNU Lesser General Public License as
  * published by the Free Software Foundation; either version 2.1 of
  * the License, or (at your option) any later version.
  *
  * This software is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  * Lesser General Public License for more details.
  *
  * You should have received a copy of the GNU Lesser General Public
  * License along with this software; if not, write to the Free
  * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  */
 package org.hibernate.test.cache.infinispan.tm;
 
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.Properties;
 
 import org.hibernate.HibernateException;
 import org.hibernate.service.UnknownUnwrapTypeException;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.spi.Stoppable;
 import org.hibernate.testing.env.ConnectionProviderBuilder;
 
 /**
  * XaConnectionProvider.
  *
  * @author Galder Zamarreo
  * @since 3.5
  */
 public class XaConnectionProvider implements ConnectionProvider {
 	private static ConnectionProvider actualConnectionProvider = ConnectionProviderBuilder.buildConnectionProvider();
 	private boolean isTransactional;
 
 	public static ConnectionProvider getActualConnectionProvider() {
 		return actualConnectionProvider;
 	}
 
 	@Override
 	public boolean isUnwrappableAs(Class unwrapType) {
 		return XaConnectionProvider.class.isAssignableFrom( unwrapType ) ||
 				ConnectionProvider.class.equals( unwrapType ) ||
 				actualConnectionProvider.getClass().isAssignableFrom( unwrapType );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> T unwrap(Class<T> unwrapType) {
 		if ( XaConnectionProvider.class.isAssignableFrom( unwrapType ) ) {
 			return (T) this;
 		}
 		else if ( ConnectionProvider.class.isAssignableFrom( unwrapType ) ||
 				actualConnectionProvider.getClass().isAssignableFrom( unwrapType ) ) {
 			return (T) getActualConnectionProvider();
 		}
 		else {
 			throw new UnknownUnwrapTypeException( unwrapType );
 		}
 	}
 
 	public void configure(Properties props) throws HibernateException {
 	}
 
 	public Connection getConnection() throws SQLException {
 		XaTransactionImpl currentTransaction = XaTransactionManagerImpl.getInstance().getCurrentTransaction();
 		if ( currentTransaction == null ) {
 			isTransactional = false;
 			return actualConnectionProvider.getConnection();
 		}
 		else {
 			isTransactional = true;
 			Connection connection = currentTransaction.getEnlistedConnection();
 			if ( connection == null ) {
 				connection = actualConnectionProvider.getConnection();
 				currentTransaction.enlistConnection( connection );
 			}
 			return connection;
 		}
 	}
 
 	public void closeConnection(Connection conn) throws SQLException {
 		if ( !isTransactional ) {
 			conn.close();
 		}
 	}
 
 	public void close() throws HibernateException {
 		if ( actualConnectionProvider instanceof Stoppable ) {
 			((Stoppable) actualConnectionProvider).stop();
 		}
 	}
 
 	public boolean supportsAggressiveRelease() {
 		return true;
 	}
 }
diff --git a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/util/BatchModeJtaPlatform.java b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/util/BatchModeJtaPlatform.java
index 6d6f75d17d..a53aced180 100644
--- a/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/util/BatchModeJtaPlatform.java
+++ b/hibernate-infinispan/src/test/java/org/hibernate/test/cache/infinispan/util/BatchModeJtaPlatform.java
@@ -1,82 +1,82 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.test.cache.infinispan.util;
 
 import javax.transaction.Synchronization;
 import javax.transaction.SystemException;
 import javax.transaction.Transaction;
 import javax.transaction.TransactionManager;
 import javax.transaction.UserTransaction;
 
 import org.infinispan.transaction.tm.BatchModeTransactionManager;
 
 import org.hibernate.HibernateException;
 import org.hibernate.TransactionException;
 import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
-import org.hibernate.service.jta.platform.spi.JtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.spi.JtaPlatform;
 
 /**
  * @author Steve Ebersole
  */
 public class BatchModeJtaPlatform implements JtaPlatform {
 	@Override
 	public TransactionManager retrieveTransactionManager() {
         try {
             return BatchModeTransactionManager.getInstance();
         }
         catch (Exception e) {
             throw new HibernateException("Failed getting BatchModeTransactionManager", e);
         }
 	}
 
 	@Override
 	public UserTransaction retrieveUserTransaction() {
         throw new UnsupportedOperationException();
 	}
 
 	@Override
 	public Object getTransactionIdentifier(Transaction transaction) {
 		return transaction;
 	}
 
 	@Override
 	public boolean canRegisterSynchronization() {
 		return JtaStatusHelper.isActive( retrieveTransactionManager() );
 	}
 
 	@Override
 	public void registerSynchronization(Synchronization synchronization) {
 		try {
 			retrieveTransactionManager().getTransaction().registerSynchronization( synchronization );
 		}
 		catch (Exception e) {
 			throw new TransactionException( "Could not obtain transaction from TM" );
 		}
 	}
 
 	@Override
 	public int getCurrentStatus() throws SystemException {
 		return JtaStatusHelper.getStatus( retrieveTransactionManager() );
 	}
 }
diff --git a/hibernate-proxool/src/main/java/org/hibernate/service/jdbc/connections/internal/ProxoolConnectionProvider.java b/hibernate-proxool/src/main/java/org/hibernate/service/jdbc/connections/internal/ProxoolConnectionProvider.java
index 116116b5fc..a4ac220c2c 100644
--- a/hibernate-proxool/src/main/java/org/hibernate/service/jdbc/connections/internal/ProxoolConnectionProvider.java
+++ b/hibernate-proxool/src/main/java/org/hibernate/service/jdbc/connections/internal/ProxoolConnectionProvider.java
@@ -1,242 +1,242 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2007, Red Hat Middleware LLC or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors. All third-party contributions are
  * distributed under license by Red Hat Middleware LLC.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.service.jdbc.connections.internal;
 
 import java.sql.Connection;
 import java.sql.DriverManager;
 import java.sql.SQLException;
 import java.util.Properties;
 
 import org.jboss.logging.Logger;
 import org.logicalcobwebs.proxool.ProxoolException;
 import org.logicalcobwebs.proxool.ProxoolFacade;
 import org.logicalcobwebs.proxool.configuration.JAXPConfigurator;
 import org.logicalcobwebs.proxool.configuration.PropertyConfigurator;
 
 import org.hibernate.HibernateException;
 import org.hibernate.cfg.Environment;
 import org.hibernate.internal.util.ConfigHelper;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.service.UnknownUnwrapTypeException;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 
 /**
  * A connection provider that uses a Proxool connection pool. Hibernate will use this by
  * default if the <tt>hibernate.proxool.*</tt> properties are set.
  * @see ConnectionProvider
  */
 public class ProxoolConnectionProvider implements ConnectionProvider {
 
     public static final ProxoolMessageLogger LOG = Logger.getMessageLogger(ProxoolMessageLogger.class, ProxoolConnectionProvider.class.getName());
 
 	private static final String PROXOOL_JDBC_STEM = "proxool.";
 
 	private String proxoolAlias;
 
 	// TRUE if the pool is borrowed from the outside, FALSE if we used to create it
 	private boolean existingPool;
 
 	// Not null if the Isolation level has been specified in the configuration file.
 	// Otherwise, it is left to the Driver's default value.
 	private Integer isolation;
 
 	private boolean autocommit;
 
 	/**
 	 * Grab a connection
 	 * @return a JDBC connection
 	 * @throws SQLException
 	 */
 	public Connection getConnection() throws SQLException {
 	    // get a connection from the pool (thru DriverManager, cfr. Proxool doc)
 		Connection c = DriverManager.getConnection(proxoolAlias);
 
 		// set the Transaction Isolation if defined
 		if (isolation!=null) c.setTransactionIsolation( isolation.intValue() );
 
 		// toggle autoCommit to false if set
 		if ( c.getAutoCommit()!=autocommit ) c.setAutoCommit(autocommit);
 
 		// return the connection
 		return c;
 	}
 
 	@Override
 	public boolean isUnwrappableAs(Class unwrapType) {
 		return ConnectionProvider.class.equals( unwrapType ) ||
 				ProxoolConnectionProvider.class.isAssignableFrom( unwrapType );
 	}
 
 	@Override
 	@SuppressWarnings( {"unchecked"})
 	public <T> T unwrap(Class<T> unwrapType) {
 		if ( ConnectionProvider.class.equals( unwrapType ) ||
 				ProxoolConnectionProvider.class.isAssignableFrom( unwrapType ) ) {
 			return (T) this;
 		}
 		else {
 			throw new UnknownUnwrapTypeException( unwrapType );
 		}
 	}
 
 	/**
 	 * Dispose of a used connection.
 	 * @param conn a JDBC connection
 	 * @throws SQLException
 	 */
 	public void closeConnection(Connection conn) throws SQLException {
 		conn.close();
 	}
 
 	/**
 	 * Initialize the connection provider from given properties.
 	 * @param props <tt>SessionFactory</tt> properties
 	 */
 	public void configure(Properties props) throws HibernateException {
 
 		// Get the configurator files (if available)
 		String jaxpFile = props.getProperty(Environment.PROXOOL_XML);
 		String propFile = props.getProperty(Environment.PROXOOL_PROPERTIES);
 		String externalConfig = props.getProperty(Environment.PROXOOL_EXISTING_POOL);
 
 		// Default the Proxool alias setting
 		proxoolAlias = props.getProperty(Environment.PROXOOL_POOL_ALIAS);
 
 		// Configured outside of Hibernate (i.e. Servlet container, or Java Bean Container
 		// already has Proxool pools running, and this provider is to just borrow one of these
 		if ( "true".equals(externalConfig) ) {
 
 			// Validate that an alias name was provided to determine which pool to use
 			if ( !StringHelper.isNotEmpty( proxoolAlias ) ) {
                 String msg = LOG.unableToConfigureProxoolProviderToUseExistingInMemoryPool(Environment.PROXOOL_POOL_ALIAS);
                 LOG.error(msg);
 				throw new HibernateException( msg );
 			}
 			// Append the stem to the proxool pool alias
 			proxoolAlias = PROXOOL_JDBC_STEM + proxoolAlias;
 
 			// Set the existing pool flag to true
 			existingPool = true;
 
             LOG.configuringProxoolProviderUsingExistingPool(proxoolAlias);
 
 			// Configured using the JAXP Configurator
 		}
 		else if ( StringHelper.isNotEmpty( jaxpFile ) ) {
 
             LOG.configuringProxoolProviderUsingJaxpConfigurator(jaxpFile);
 
 			// Validate that an alias name was provided to determine which pool to use
 			if ( !StringHelper.isNotEmpty( proxoolAlias ) ) {
                 String msg = LOG.unableToConfigureProxoolProviderToUseJaxp(Environment.PROXOOL_POOL_ALIAS);
                 LOG.error(msg);
 				throw new HibernateException( msg );
 			}
 
 			try {
 				JAXPConfigurator.configure( ConfigHelper.getConfigStreamReader( jaxpFile ), false );
 			}
 			catch ( ProxoolException e ) {
                 String msg = LOG.unableToLoadJaxpConfiguratorFile(jaxpFile);
                 LOG.error(msg, e);
 				throw new HibernateException( msg, e );
 			}
 
 			// Append the stem to the proxool pool alias
 			proxoolAlias = PROXOOL_JDBC_STEM + proxoolAlias;
             LOG.configuringProxoolProviderToUsePoolAlias(proxoolAlias);
 
 			// Configured using the Properties File Configurator
 		}
 		else if ( StringHelper.isNotEmpty( propFile ) ) {
 
             LOG.configuringProxoolProviderUsingPropertiesFile(propFile);
 
 			// Validate that an alias name was provided to determine which pool to use
 			if ( !StringHelper.isNotEmpty( proxoolAlias ) ) {
                 String msg = LOG.unableToConfigureProxoolProviderToUsePropertiesFile(Environment.PROXOOL_POOL_ALIAS);
                 LOG.error(msg);
 				throw new HibernateException( msg );
 			}
 
 			try {
 				PropertyConfigurator.configure( ConfigHelper.getConfigProperties( propFile ) );
 			}
 			catch ( ProxoolException e ) {
                 String msg = LOG.unableToLoadPropertyConfiguratorFile(propFile);
                 LOG.error(msg, e);
 				throw new HibernateException( msg, e );
 			}
 
 			// Append the stem to the proxool pool alias
 			proxoolAlias = PROXOOL_JDBC_STEM + proxoolAlias;
             LOG.configuringProxoolProviderToUsePoolAlias(proxoolAlias);
 		}
 
 		// Remember Isolation level
 		isolation = ConfigurationHelper.getInteger(Environment.ISOLATION, props);
         if (isolation != null) LOG.jdbcIsolationLevel(Environment.isolationLevelToString(isolation.intValue()));
 
 		autocommit = ConfigurationHelper.getBoolean(Environment.AUTOCOMMIT, props);
         LOG.autoCommmitMode(autocommit);
 	}
 
 	/**
 	 * Release all resources held by this provider. JavaDoc requires a second sentence.
 	 * @throws HibernateException
 	 */
 	public void close() throws HibernateException {
 
 		// If the provider was leeching off an existing pool don't close it
 		if (existingPool) {
 			return;
 		}
 
 		// We have created the pool ourselves, so shut it down
 		try {
 			if ( ProxoolFacade.getAliases().length == 1 ) {
 				ProxoolFacade.shutdown( 0 );
 			}
 			else {
 				ProxoolFacade.removeConnectionPool(proxoolAlias.substring(PROXOOL_JDBC_STEM.length()));
 			}
 		}
 		catch (Exception e) {
 			// If you're closing down the ConnectionProvider chances are an
 			// is not a real big deal, just warn
             String msg = LOG.exceptionClosingProxoolPool();
             LOG.warn(msg, e);
             throw new HibernateException(msg, e);
 		}
 	}
 
 	/**
 	 * @see ConnectionProvider#supportsAggressiveRelease()
 	 */
 	public boolean supportsAggressiveRelease() {
 		return false;
 	}
 
 }
diff --git a/hibernate-testing/src/main/java/org/hibernate/testing/ServiceRegistryBuilder.java b/hibernate-testing/src/main/java/org/hibernate/testing/ServiceRegistryBuilder.java
index 902d14ce91..efab4e2d63 100644
--- a/hibernate-testing/src/main/java/org/hibernate/testing/ServiceRegistryBuilder.java
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/ServiceRegistryBuilder.java
@@ -1,49 +1,50 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.testing;
 
 import java.util.Map;
 
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.Environment;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 
 /**
  * @author Steve Ebersole
  */
 public class ServiceRegistryBuilder {
 	public static StandardServiceRegistryImpl buildServiceRegistry() {
 		return buildServiceRegistry( Environment.getProperties() );
 	}
 
 	public static StandardServiceRegistryImpl buildServiceRegistry(Map serviceRegistryConfig) {
-		return (StandardServiceRegistryImpl) new org.hibernate.service.ServiceRegistryBuilder()
+		return (StandardServiceRegistryImpl) new StandardServiceRegistryBuilder()
 				.applySettings( serviceRegistryConfig )
 				.buildServiceRegistry();
 	}
 
 	public static void destroy(ServiceRegistry serviceRegistry) {
 		( (StandardServiceRegistryImpl) serviceRegistry ).destroy();
 	}
 }
diff --git a/hibernate-testing/src/main/java/org/hibernate/testing/env/ConnectionProviderBuilder.java b/hibernate-testing/src/main/java/org/hibernate/testing/env/ConnectionProviderBuilder.java
index 443a13a346..e7aef85b82 100644
--- a/hibernate-testing/src/main/java/org/hibernate/testing/env/ConnectionProviderBuilder.java
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/env/ConnectionProviderBuilder.java
@@ -1,82 +1,82 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2010-2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.testing.env;
 
 import java.util.Properties;
 
 import org.hibernate.cfg.Environment;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.H2Dialect;
-import org.hibernate.service.jdbc.connections.internal.DriverManagerConnectionProviderImpl;
+import org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl;
 
 /**
  * Defines the JDBC connection information (currently H2) used by Hibernate for unit (not functional!) tests
  *
  * @author Steve Ebersole
  */
 public class ConnectionProviderBuilder {
 	public static final String DRIVER = "org.h2.Driver";
 	public static final String URL = "jdbc:h2:mem:%s;DB_CLOSE_DELAY=-1;MVCC=TRUE";
 	public static final String USER = "sa";
 	public static final String PASS = "";
 
 	public static Properties getConnectionProviderProperties(String dbName) {
 		Properties props = new Properties( null );
 		props.put( Environment.DRIVER, DRIVER );
 		props.put( Environment.URL, String.format( URL, dbName ) );
 		props.put( Environment.USER, USER );
 		props.put( Environment.PASS, PASS );
 		return props;
 	}
 
 	public static Properties getConnectionProviderProperties() {
 		return getConnectionProviderProperties( "db1" );
 	}
 
 	public static DriverManagerConnectionProviderImpl buildConnectionProvider() {
 		return buildConnectionProvider( false );
 	}
 
 	public static DriverManagerConnectionProviderImpl buildConnectionProvider(String dbName) {
 		return buildConnectionProvider( getConnectionProviderProperties( dbName ), false );
 	}
 
 	public static DriverManagerConnectionProviderImpl buildConnectionProvider(final boolean allowAggressiveRelease) {
 		return buildConnectionProvider( getConnectionProviderProperties( "db1" ), allowAggressiveRelease );
 	}
 
 	private static DriverManagerConnectionProviderImpl buildConnectionProvider(Properties props, final boolean allowAggressiveRelease) {
 		DriverManagerConnectionProviderImpl connectionProvider = new DriverManagerConnectionProviderImpl() {
 			public boolean supportsAggressiveRelease() {
 				return allowAggressiveRelease;
 			}
 		};
 		connectionProvider.configure( props );
 		return connectionProvider;
 	}
 
 	public static Dialect getCorrespondingDialect() {
 		return new H2Dialect();
 	}
 }
diff --git a/hibernate-testing/src/main/java/org/hibernate/testing/jta/JtaAwareConnectionProviderImpl.java b/hibernate-testing/src/main/java/org/hibernate/testing/jta/JtaAwareConnectionProviderImpl.java
index 74ec5f1e1e..c429a64c39 100644
--- a/hibernate-testing/src/main/java/org/hibernate/testing/jta/JtaAwareConnectionProviderImpl.java
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/jta/JtaAwareConnectionProviderImpl.java
@@ -1,270 +1,269 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.testing.jta;
 
 import javax.sql.DataSource;
 import javax.transaction.SystemException;
 import javax.transaction.Transaction;
 import javax.transaction.xa.XAException;
 import javax.transaction.xa.XAResource;
 import javax.transaction.xa.Xid;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 
 import org.hibernate.cfg.Environment;
-import org.hibernate.engine.transaction.internal.jta.JtaStatusHelper;
-import org.hibernate.service.jdbc.connections.internal.ConnectionProviderInitiator;
-import org.hibernate.service.jdbc.connections.internal.DriverManagerConnectionProviderImpl;
-import org.hibernate.service.jdbc.connections.spi.ConnectionProvider;
+import org.hibernate.engine.jdbc.connections.internal.ConnectionProviderInitiator;
+import org.hibernate.engine.jdbc.connections.internal.DriverManagerConnectionProviderImpl;
+import org.hibernate.engine.jdbc.connections.spi.ConnectionProvider;
 import org.hibernate.service.spi.Configurable;
 import org.hibernate.service.spi.Stoppable;
 
 /**
  * A {@link DataSource} implementation intended for testing Hibernate/JTA interaction.  In that limited scope we
  * only ever have one single resource (the database connection) so we do not at all care about full-blown XA
  * semantics.  This class behaves accordingly.  This class also assumes usage of and access to JBossTS/Arjuna.
  *
  * @author Steve Ebersole
  * @author Jonathan Halliday
  */
 public class JtaAwareConnectionProviderImpl implements ConnectionProvider, Configurable, Stoppable {
 	private static final String CONNECTION_KEY = "_database_connection";
 
 	private DriverManagerConnectionProviderImpl delegate;
 
 	private List<Connection> nonEnlistedConnections = new ArrayList<Connection>();
 
 	@Override
 	public void configure(Map configurationValues) {
 		Properties connectionSettings = new Properties();
 		transferSetting( Environment.DRIVER, configurationValues, connectionSettings );
 		transferSetting( Environment.URL, configurationValues, connectionSettings );
 		transferSetting( Environment.USER, configurationValues, connectionSettings );
 		transferSetting( Environment.PASS, configurationValues, connectionSettings );
 		transferSetting( Environment.ISOLATION, configurationValues, connectionSettings );
 		Properties passThroughSettings = ConnectionProviderInitiator.getConnectionProperties( configurationValues );
 		if ( passThroughSettings != null ) {
 			for ( String setting : passThroughSettings.stringPropertyNames() ) {
 				transferSetting( Environment.CONNECTION_PREFIX + '.' + setting, configurationValues, connectionSettings );
 			}
 		}
 		connectionSettings.setProperty( Environment.AUTOCOMMIT, "false" );
 
 		delegate = new DriverManagerConnectionProviderImpl();
 		delegate.configure( connectionSettings );
 	}
 
 	@SuppressWarnings("unchecked")
 	private static void transferSetting(String settingName, Map source, Map target) {
 		Object value = source.get( settingName );
 		if ( value != null ) {
 			target.put( settingName, value );
 		}
 	}
 
 	@Override
 	public void stop() {
 		delegate.stop();
 	}
 
 	@Override
 	public Connection getConnection() throws SQLException {
 		Transaction currentTransaction = findCurrentTransaction();
 
 		try {
 			if ( currentTransaction == null ) {
 				// this block handles non enlisted connections ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 				Connection connection = delegate.getConnection();
 				nonEnlistedConnections.add( connection );
 				return connection;
 			}
 
 			// this portion handles enlisted connections ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 			Connection connection = (Connection) TestingJtaPlatformImpl.synchronizationRegistry().getResource(
 					CONNECTION_KEY
 			);
 			if ( connection == null ) {
 				connection = delegate.getConnection();
 				TestingJtaPlatformImpl.synchronizationRegistry().putResource( CONNECTION_KEY, connection );
 
 				XAResourceWrapper xaResourceWrapper = new XAResourceWrapper( this, connection );
 				currentTransaction.enlistResource( xaResourceWrapper );
 			}
 			return connection;
 		}
 		catch (SQLException e) {
 			throw e;
 		}
 		catch (Exception e) {
 			throw new SQLException(e);
 		}
 	}
 
 	@Override
 	public void closeConnection(Connection conn) throws SQLException {
 		if ( conn == null ) {
 			return;
 		}
 
 		if ( nonEnlistedConnections.contains( conn ) ) {
 			nonEnlistedConnections.remove( conn );
 			delegate.closeConnection( conn );
 		}
 		else {
 			// do nothing.  part of the enlistment contract here is that the XAResource wrapper
 			// takes that responsibility.
 		}
 	}
 
 	@Override
 	public boolean supportsAggressiveRelease() {
 		return true;
 	}
 
 	protected Transaction findCurrentTransaction() {
 		try {
 			return TestingJtaPlatformImpl.transactionManager().getTransaction();
 		}
 		catch (SystemException e) {
 			throw new IllegalStateException( "Could not locate current transaction" );
 		}
 	}
 
 	@Override
 	public boolean isUnwrappableAs(Class unwrapType) {
 		return delegate.isUnwrappableAs( unwrapType );
 	}
 
 	@Override
 	public <T> T unwrap(Class<T> unwrapType) {
 		return delegate.unwrap( unwrapType );
 	}
 
 	private void delist(Connection connection) {
 		// todo : verify the incoming connection is the currently enlisted one?
 		TestingJtaPlatformImpl.synchronizationRegistry().putResource( CONNECTION_KEY, null );
 		try {
 			delegate.closeConnection( connection );
 		}
 		catch (SQLException e) {
 			System.err.println( "!!!Error trying to close JDBC connection from delist callbacks!!!" );
 		}
 	}
 
 	public static class XAResourceWrapper implements XAResource {
 		private final JtaAwareConnectionProviderImpl pool;
 		private final Connection connection;
 		private int transactionTimeout;
 
 		public XAResourceWrapper(JtaAwareConnectionProviderImpl pool, Connection connection) {
 			this.pool = pool;
 			this.connection = connection;
 		}
 
 		@Override
 		public int prepare(Xid xid) throws XAException {
 			throw new RuntimeException("this should never be called");
 		}
 
 		@Override
 		public void commit(Xid xid, boolean onePhase) throws XAException {
 			if (!onePhase) {
 				throw new IllegalArgumentException( "must be one phase" );
 			}
 
 			try {
 				connection.commit();
 			}
 			catch(SQLException e) {
 				throw new XAException( e.toString() );
 			}
 			finally {
 				try {
 					pool.delist( connection );
 				}
 				catch (Exception ignore) {
 				}
 			}
 		}
 
 		@Override
 		public void rollback(Xid xid) throws XAException {
 
 			try {
 				connection.rollback();
 			}
 			catch(SQLException e) {
 				throw new XAException( e.toString() );
 			}
 			finally {
 				try {
 					pool.delist( connection );
 				}
 				catch (Exception ignore) {
 				}
 			}
 		}
 
 		@Override
 		public void end(Xid xid, int i) throws XAException {
 			// noop
 		}
 
 		@Override
 		public void start(Xid xid, int i) throws XAException {
 			// noop
 		}
 
 
 		@Override
 		public void forget(Xid xid) throws XAException {
 			// noop
 		}
 
 		@Override
 		public int getTransactionTimeout() throws XAException {
 			return transactionTimeout;
 		}
 
 		@Override
 		public boolean setTransactionTimeout(int i) throws XAException {
 			transactionTimeout = i;
 			return true;
 		}
 
 		@Override
 		public boolean isSameRM(XAResource xaResource) throws XAException {
 			return xaResource != null && xaResource == this;
 		}
 
 		@Override
 		public Xid[] recover(int i) throws XAException {
 			return new Xid[0];
 		}
 	}
 }
diff --git a/hibernate-testing/src/main/java/org/hibernate/testing/jta/TestingJtaPlatformImpl.java b/hibernate-testing/src/main/java/org/hibernate/testing/jta/TestingJtaPlatformImpl.java
index 5cac046eb0..fc607fd48e 100644
--- a/hibernate-testing/src/main/java/org/hibernate/testing/jta/TestingJtaPlatformImpl.java
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/jta/TestingJtaPlatformImpl.java
@@ -1,131 +1,131 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2012, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.testing.jta;
 
 import javax.transaction.Status;
 import javax.transaction.TransactionManager;
 import javax.transaction.TransactionSynchronizationRegistry;
 import javax.transaction.UserTransaction;
 
 import com.arjuna.ats.arjuna.common.ObjectStoreEnvironmentBean;
 import com.arjuna.ats.internal.arjuna.objectstore.VolatileStore;
 import com.arjuna.common.internal.util.propertyservice.BeanPopulator;
 
-import org.hibernate.service.jta.platform.internal.AbstractJtaPlatform;
-import org.hibernate.service.jta.platform.internal.JtaSynchronizationStrategy;
-import org.hibernate.service.jta.platform.internal.SynchronizationRegistryAccess;
-import org.hibernate.service.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy;
+import org.hibernate.engine.transaction.jta.platform.internal.AbstractJtaPlatform;
+import org.hibernate.engine.transaction.jta.platform.internal.JtaSynchronizationStrategy;
+import org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryAccess;
+import org.hibernate.engine.transaction.jta.platform.internal.SynchronizationRegistryBasedSynchronizationStrategy;
 
 /**
  * A test-specific implementation of the JtaPlatform contract for testing JTA-based functionality.
  *
  * @author Steve Ebersole
  */
 public class TestingJtaPlatformImpl extends AbstractJtaPlatform {
 	public static final TestingJtaPlatformImpl INSTANCE = new TestingJtaPlatformImpl();
 
 	private final TransactionManager transactionManager;
 	private final UserTransaction userTransaction;
 	private final TransactionSynchronizationRegistry synchronizationRegistry;
 
 	private final JtaSynchronizationStrategy synchronizationStrategy;
 
 	public TestingJtaPlatformImpl() {
 		BeanPopulator
 				.getDefaultInstance( ObjectStoreEnvironmentBean.class )
 				.setObjectStoreType( VolatileStore.class.getName() );
 
 		BeanPopulator
 				.getNamedInstance( ObjectStoreEnvironmentBean.class, "communicationStore" )
 				.setObjectStoreType( VolatileStore.class.getName() );
 
 		BeanPopulator
 				.getNamedInstance( ObjectStoreEnvironmentBean.class, "stateStore" )
 				.setObjectStoreType( VolatileStore.class.getName() );
 
 		transactionManager = com.arjuna.ats.jta.TransactionManager.transactionManager();
 		userTransaction = com.arjuna.ats.jta.UserTransaction.userTransaction();
 		synchronizationRegistry =
 				new com.arjuna.ats.internal.jta.transaction.arjunacore.TransactionSynchronizationRegistryImple();
 
 		synchronizationStrategy = new SynchronizationRegistryBasedSynchronizationStrategy(
 				new SynchronizationRegistryAccess() {
 					@Override
 					public TransactionSynchronizationRegistry getSynchronizationRegistry() {
 						return synchronizationRegistry;
 					}
 				}
 		);
 	}
 
 	public static TransactionManager transactionManager() {
 		return INSTANCE.retrieveTransactionManager();
 	}
 
 	public static UserTransaction userTransaction() {
 		return INSTANCE.retrieveUserTransaction();
 	}
 
 	public static TransactionSynchronizationRegistry synchronizationRegistry() {
 		return INSTANCE.synchronizationRegistry;
 	}
 
 	/**
 	 * Used by envers...
 	 */
 	public static void tryCommit() throws Exception {
 		if ( transactionManager().getStatus() == Status.STATUS_MARKED_ROLLBACK ) {
 			transactionManager().rollback();
 		}
 		else {
 			transactionManager().commit();
 		}
 	}
 
 	@Override
 	protected TransactionManager locateTransactionManager() {
 		return transactionManager;
 	}
 
 	@Override
 	protected boolean canCacheTransactionManager() {
 		return true;
 	}
 
 	@Override
 	protected UserTransaction locateUserTransaction() {
 		return userTransaction;
 	}
 
 	@Override
 	protected boolean canCacheUserTransaction() {
 		return true;
 	}
 
 	@Override
 	protected JtaSynchronizationStrategy getSynchronizationStrategy() {
 		return synchronizationStrategy;
 	}
 
 }
diff --git a/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseCoreFunctionalTestCase.java b/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseCoreFunctionalTestCase.java
index 02658301fe..e73668362c 100644
--- a/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseCoreFunctionalTestCase.java
+++ b/hibernate-testing/src/main/java/org/hibernate/testing/junit4/BaseCoreFunctionalTestCase.java
@@ -1,549 +1,549 @@
 /*
  * Hibernate, Relational Persistence for Idiomatic Java
  *
  * Copyright (c) 2011, Red Hat Inc. or third-party contributors as
  * indicated by the @author tags or express copyright attribution
  * statements applied by the authors.  All third-party contributions are
  * distributed under license by Red Hat Inc.
  *
  * This copyrighted material is made available to anyone wishing to use, modify,
  * copy, or redistribute it subject to the terms and conditions of the GNU
  * Lesser General Public License, as published by the Free Software Foundation.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
  * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
  * for more details.
  *
  * You should have received a copy of the GNU Lesser General Public License
  * along with this distribution; if not, write to:
  * Free Software Foundation, Inc.
  * 51 Franklin Street, Fifth Floor
  * Boston, MA  02110-1301  USA
  */
 package org.hibernate.testing.junit4;
 
 import java.io.InputStream;
 import java.sql.Blob;
 import java.sql.Clob;
 import java.sql.Connection;
 import java.sql.SQLException;
 import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.Properties;
 
 import org.junit.After;
 import org.junit.Before;
 
 import org.hibernate.HibernateException;
 import org.hibernate.Interceptor;
 import org.hibernate.Session;
+import org.hibernate.boot.registry.StandardServiceRegistryBuilder;
 import org.hibernate.cfg.AvailableSettings;
 import org.hibernate.cfg.Configuration;
 import org.hibernate.cfg.Environment;
 import org.hibernate.cfg.Mappings;
 import org.hibernate.dialect.Dialect;
 import org.hibernate.dialect.H2Dialect;
 import org.hibernate.engine.spi.SessionFactoryImplementor;
 import org.hibernate.engine.spi.SessionImplementor;
 import org.hibernate.internal.util.StringHelper;
 import org.hibernate.internal.util.config.ConfigurationHelper;
 import org.hibernate.jdbc.AbstractReturningWork;
 import org.hibernate.jdbc.Work;
 import org.hibernate.mapping.Collection;
 import org.hibernate.mapping.PersistentClass;
 import org.hibernate.mapping.Property;
 import org.hibernate.mapping.SimpleValue;
 import org.hibernate.metamodel.MetadataSources;
 import org.hibernate.metamodel.source.MetadataImplementor;
-import org.hibernate.service.BootstrapServiceRegistry;
-import org.hibernate.service.BootstrapServiceRegistryBuilder;
+import org.hibernate.boot.registry.BootstrapServiceRegistry;
+import org.hibernate.boot.registry.BootstrapServiceRegistryBuilder;
 import org.hibernate.service.ServiceRegistry;
-import org.hibernate.service.ServiceRegistryBuilder;
-import org.hibernate.service.config.spi.ConfigurationService;
-import org.hibernate.service.internal.StandardServiceRegistryImpl;
+import org.hibernate.engine.config.spi.ConfigurationService;
+import org.hibernate.boot.registry.internal.StandardServiceRegistryImpl;
 import org.hibernate.testing.AfterClassOnce;
 import org.hibernate.testing.BeforeClassOnce;
 import org.hibernate.testing.OnExpectedFailure;
 import org.hibernate.testing.OnFailure;
 import org.hibernate.testing.SkipLog;
 import org.hibernate.testing.cache.CachingRegionFactory;
 
 import static org.junit.Assert.fail;
 
 /**
  * Applies functional testing logic for core Hibernate testing on top of {@link BaseUnitTestCase}
  *
  * @author Steve Ebersole
  */
 @SuppressWarnings( {"deprecation"} )
 public abstract class BaseCoreFunctionalTestCase extends BaseUnitTestCase {
 	public static final String VALIDATE_DATA_CLEANUP = "hibernate.test.validateDataCleanup";
 	public static final String USE_NEW_METADATA_MAPPINGS = "hibernate.test.new_metadata_mappings";
 
 	public static final Dialect DIALECT = Dialect.getDialect();
 
 	private boolean isMetadataUsed;
 	private Configuration configuration;
 	private StandardServiceRegistryImpl serviceRegistry;
 	private SessionFactoryImplementor sessionFactory;
 
 	protected Session session;
 
 	protected static Dialect getDialect() {
 		return DIALECT;
 	}
 
 	protected Configuration configuration() {
 		return configuration;
 	}
 
 	protected StandardServiceRegistryImpl serviceRegistry() {
 		return serviceRegistry;
 	}
 
 	protected SessionFactoryImplementor sessionFactory() {
 		return sessionFactory;
 	}
 
 	protected Session openSession() throws HibernateException {
 		session = sessionFactory().openSession();
 		return session;
 	}
 
 	protected Session openSession(Interceptor interceptor) throws HibernateException {
 		session = sessionFactory().withOptions().interceptor( interceptor ).openSession();
 		return session;
 	}
 
 
 	// before/after test class ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@BeforeClassOnce
 	@SuppressWarnings( {"UnusedDeclaration"})
 	protected void buildSessionFactory() {
 		// for now, build the configuration to get all the property settings
 		configuration = constructAndConfigureConfiguration();
 		serviceRegistry = buildServiceRegistry( configuration );
 		isMetadataUsed = serviceRegistry.getService( ConfigurationService.class ).getSetting(
 				USE_NEW_METADATA_MAPPINGS,
 				new ConfigurationService.Converter<Boolean>() {
 					@Override
 					public Boolean convert(Object value) {
 						return Boolean.parseBoolean( ( String ) value );
 					}
 				},
 				false
 		);
 		if ( isMetadataUsed ) {
 			sessionFactory = ( SessionFactoryImplementor ) buildMetadata( serviceRegistry ).buildSessionFactory();
 		}
 		else {
 			// this is done here because Configuration does not currently support 4.0 xsd
 			afterConstructAndConfigureConfiguration( configuration );
 			sessionFactory = ( SessionFactoryImplementor ) configuration.buildSessionFactory( serviceRegistry );
 		}
 		afterSessionFactoryBuilt();
 	}
 
 	private MetadataImplementor buildMetadata(ServiceRegistry serviceRegistry) {
 		 	MetadataSources sources = new MetadataSources( serviceRegistry );
 			addMappings( sources );
 			return (MetadataImplementor) sources.buildMetadata();
 	}
 
 	// TODO: is this still needed?
 	protected Configuration buildConfiguration() {
 		Configuration cfg = constructAndConfigureConfiguration();
 		afterConstructAndConfigureConfiguration( cfg );
 		return cfg;
 	}
 
 	private Configuration constructAndConfigureConfiguration() {
 		Configuration cfg = constructConfiguration();
 		configure( cfg );
 		return cfg;
 	}
 
 	private void afterConstructAndConfigureConfiguration(Configuration cfg) {
 		addMappings( cfg );
 		cfg.buildMappings();
 		applyCacheSettings( cfg );
 		afterConfigurationBuilt( cfg );
 	}
 
 	protected Configuration constructConfiguration() {
 		Configuration configuration = new Configuration()
 				.setProperty(Environment.CACHE_REGION_FACTORY, CachingRegionFactory.class.getName()  );
 		configuration.setProperty( AvailableSettings.USE_NEW_ID_GENERATOR_MAPPINGS, "true" );
 		if ( createSchema() ) {
 			configuration.setProperty( Environment.HBM2DDL_AUTO, "create-drop" );
 			final String secondSchemaName = createSecondSchema();
 			if ( StringHelper.isNotEmpty( secondSchemaName ) ) {
 				if ( !( getDialect() instanceof H2Dialect ) ) {
 					throw new UnsupportedOperationException( "Only H2 dialect supports creation of second schema." );
 				}
 				Helper.createH2Schema( secondSchemaName, configuration );
 			}
 		}
 		configuration.setProperty( Environment.DIALECT, getDialect().getClass().getName() );
 		return configuration;
 	}
 
 	protected void configure(Configuration configuration) {
 	}
 
 	protected void addMappings(Configuration configuration) {
 		String[] mappings = getMappings();
 		if ( mappings != null ) {
 			for ( String mapping : mappings ) {
 				configuration.addResource(
 						getBaseForMappings() + mapping,
 						getClass().getClassLoader()
 				);
 			}
 		}
 		Class<?>[] annotatedClasses = getAnnotatedClasses();
 		if ( annotatedClasses != null ) {
 			for ( Class<?> annotatedClass : annotatedClasses ) {
 				configuration.addAnnotatedClass( annotatedClass );
 			}
 		}
 		String[] annotatedPackages = getAnnotatedPackages();
 		if ( annotatedPackages != null ) {
 			for ( String annotatedPackage : annotatedPackages ) {
 				configuration.addPackage( annotatedPackage );
 			}
 		}
 		String[] xmlFiles = getXmlFiles();
 		if ( xmlFiles != null ) {
 			for ( String xmlFile : xmlFiles ) {
 				InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( xmlFile );
 				configuration.addInputStream( is );
 			}
 		}
 	}
 
 	protected void addMappings(MetadataSources sources) {
 		String[] mappings = getMappings();
 		if ( mappings != null ) {
 			for ( String mapping : mappings ) {
 				sources.addResource(
 						getBaseForMappings() + mapping
 				);
 			}
 		}
 		Class<?>[] annotatedClasses = getAnnotatedClasses();
 		if ( annotatedClasses != null ) {
 			for ( Class<?> annotatedClass : annotatedClasses ) {
 				sources.addAnnotatedClass( annotatedClass );
 			}
 		}
 		String[] annotatedPackages = getAnnotatedPackages();
 		if ( annotatedPackages != null ) {
 			for ( String annotatedPackage : annotatedPackages ) {
 				sources.addPackage( annotatedPackage );
 			}
 		}
 		String[] xmlFiles = getXmlFiles();
 		if ( xmlFiles != null ) {
 			for ( String xmlFile : xmlFiles ) {
 				InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream( xmlFile );
 				sources.addInputStream( is );
 			}
 		}
 	}
 
 	protected static final String[] NO_MAPPINGS = new String[0];
 
 	protected String[] getMappings() {
 		return NO_MAPPINGS;
 	}
 
 	protected String getBaseForMappings() {
 		return "org/hibernate/test/";
 	}
 
 	protected static final Class<?>[] NO_CLASSES = new Class[0];
 
 	protected Class<?>[] getAnnotatedClasses() {
 		return NO_CLASSES;
 	}
 
 	protected String[] getAnnotatedPackages() {
 		return NO_MAPPINGS;
 	}
 
 	protected String[] getXmlFiles() {
 		// todo : rename to getOrmXmlFiles()
 		return NO_MAPPINGS;
 	}
 
 	protected void applyCacheSettings(Configuration configuration) {
 		if ( getCacheConcurrencyStrategy() != null ) {
 			Iterator itr = configuration.getClassMappings();
 			while ( itr.hasNext() ) {
 				PersistentClass clazz = (PersistentClass) itr.next();
 				Iterator props = clazz.getPropertyClosureIterator();
 				boolean hasLob = false;
 				while ( props.hasNext() ) {
 					Property prop = (Property) props.next();
 					if ( prop.getValue().isSimpleValue() ) {
 						String type = ( (SimpleValue) prop.getValue() ).getTypeName();
 						if ( "blob".equals(type) || "clob".equals(type) ) {
 							hasLob = true;
 						}
 						if ( Blob.class.getName().equals(type) || Clob.class.getName().equals(type) ) {
 							hasLob = true;
 						}
 					}
 				}
 				if ( !hasLob && !clazz.isInherited() && overrideCacheStrategy() ) {
 					configuration.setCacheConcurrencyStrategy( clazz.getEntityName(), getCacheConcurrencyStrategy() );
 				}
 			}
 			itr = configuration.getCollectionMappings();
 			while ( itr.hasNext() ) {
 				Collection coll = (Collection) itr.next();
 				configuration.setCollectionCacheConcurrencyStrategy( coll.getRole(), getCacheConcurrencyStrategy() );
 			}
 		}
 	}
 
 	protected boolean overrideCacheStrategy() {
 		return true;
 	}
 
 	protected String getCacheConcurrencyStrategy() {
 		return null;
 	}
 
 	protected void afterConfigurationBuilt(Configuration configuration) {
 		afterConfigurationBuilt( configuration.createMappings(), getDialect() );
 	}
 
 	protected void afterConfigurationBuilt(Mappings mappings, Dialect dialect) {
 	}
 
 	protected StandardServiceRegistryImpl buildServiceRegistry(Configuration configuration) {
 		Properties properties = new Properties();
 		properties.putAll( configuration.getProperties() );
 		Environment.verifyProperties( properties );
 		ConfigurationHelper.resolvePlaceHolders( properties );
 
 		final BootstrapServiceRegistry bootstrapServiceRegistry = generateBootstrapRegistry( properties );
-		ServiceRegistryBuilder registryBuilder = new ServiceRegistryBuilder( bootstrapServiceRegistry )
+		StandardServiceRegistryBuilder registryBuilder = new StandardServiceRegistryBuilder( bootstrapServiceRegistry )
 				.applySettings( properties );
 		prepareBasicRegistryBuilder( registryBuilder );
 		return (StandardServiceRegistryImpl) registryBuilder.buildServiceRegistry();
 	}
 
 	protected BootstrapServiceRegistry generateBootstrapRegistry(Properties properties) {
 		final BootstrapServiceRegistryBuilder builder = new BootstrapServiceRegistryBuilder();
 		prepareBootstrapRegistryBuilder( builder );
 		return builder.build();
 	}
 
 	protected void prepareBootstrapRegistryBuilder(BootstrapServiceRegistryBuilder builder) {
 	}
 
-	protected void prepareBasicRegistryBuilder(ServiceRegistryBuilder serviceRegistryBuilder) {
+	protected void prepareBasicRegistryBuilder(StandardServiceRegistryBuilder serviceRegistryBuilder) {
 	}
 
 	protected void afterSessionFactoryBuilt() {
 	}
 
 	protected boolean createSchema() {
 		return true;
 	}
 
 	/**
 	 * Feature supported only by H2 dialect.
 	 * @return Provide not empty name to create second schema.
 	 */
 	protected String createSecondSchema() {
 		return null;
 	}
 
 	protected boolean rebuildSessionFactoryOnError() {
 		return true;
 	}
 
 	@AfterClassOnce
 	@SuppressWarnings( {"UnusedDeclaration"})
 	private void releaseSessionFactory() {
 		if ( sessionFactory == null ) {
 			return;
 		}
 		sessionFactory.close();
 		sessionFactory = null;
 		configuration = null;
         if(serviceRegistry == null){
             return;
         }
         serviceRegistry.destroy();
         serviceRegistry=null;
 	}
 
 	@OnFailure
 	@OnExpectedFailure
 	@SuppressWarnings( {"UnusedDeclaration"})
 	public void onFailure() {
 		if ( rebuildSessionFactoryOnError() ) {
 			rebuildSessionFactory();
 		}
 	}
 
 	protected void rebuildSessionFactory() {
 		if ( sessionFactory == null ) {
 			return;
 		}
 		sessionFactory.close();
 		serviceRegistry.destroy();
 
 		serviceRegistry = buildServiceRegistry( configuration );
 		if ( isMetadataUsed ) {
 			// need to rebuild metadata because serviceRegistry was recreated
 			sessionFactory = ( SessionFactoryImplementor ) buildMetadata( serviceRegistry ).buildSessionFactory();
 		}
 		else {
 			sessionFactory = ( SessionFactoryImplementor ) configuration.buildSessionFactory( serviceRegistry );
 		}
 		afterSessionFactoryBuilt();
 	}
 
 
 	// before/after each test ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 	@Before
 	public final void beforeTest() throws Exception {
 		prepareTest();
 	}
 
 	protected void prepareTest() throws Exception {
 	}
 
 	@After
 	public final void afterTest() throws Exception {
 		if ( isCleanupTestDataRequired() ) {
 			cleanupTestData();
 		}
 		cleanupTest();
 
 		cleanupSession();
 
 		assertAllDataRemoved();
 
 	}
 
 	protected void cleanupCache() {
 		if ( sessionFactory != null ) {
 			sessionFactory.getCache().evictCollectionRegions();
 			sessionFactory.getCache().evictDefaultQueryRegion();
 			sessionFactory.getCache().evictEntityRegions();
 			sessionFactory.getCache().evictQueryRegions();
 			sessionFactory.getCache().evictNaturalIdRegions();
 		}
 	}
 	protected boolean isCleanupTestDataRequired(){return false;}
 	protected void cleanupTestData() throws Exception {
 		Session s = openSession();
 		s.beginTransaction();
 		s.createQuery( "delete from java.lang.Object" ).executeUpdate();
 		s.getTransaction().commit();
 		s.close();
 	}
 
 
 	private void cleanupSession() {
 		if ( session != null && ! ( (SessionImplementor) session ).isClosed() ) {
 			if ( session.isConnected() ) {
 				session.doWork( new RollbackWork() );
 			}
 			session.close();
 		}
 		session = null;
 	}
 
 	public class RollbackWork implements Work {
 		public void execute(Connection connection) throws SQLException {
 			connection.rollback();
 		}
 	}
 
 	protected void cleanupTest() throws Exception {
 	}
 
 	@SuppressWarnings( {"UnnecessaryBoxing", "UnnecessaryUnboxing"})
 	protected void assertAllDataRemoved() {
 		if ( !createSchema() ) {
 			return; // no tables were created...
 		}
 		if ( !Boolean.getBoolean( VALIDATE_DATA_CLEANUP ) ) {
 			return;
 		}
 
 		Session tmpSession = sessionFactory.openSession();
 		try {
 			List list = tmpSession.createQuery( "select o from java.lang.Object o" ).list();
 
 			Map<String,Integer> items = new HashMap<String,Integer>();
 			if ( !list.isEmpty() ) {
 				for ( Object element : list ) {
 					Integer l = items.get( tmpSession.getEntityName( element ) );
 					if ( l == null ) {
 						l = 0;
 					}
 					l = l + 1 ;
 					items.put( tmpSession.getEntityName( element ), l );
 					System.out.println( "Data left: " + element );
 				}
 				fail( "Data is left in the database: " + items.toString() );
 			}
 		}
 		finally {
 			try {
 				tmpSession.close();
 			}
 			catch( Throwable t ) {
 				// intentionally empty
 			}
 		}
 	}
 
 	protected boolean readCommittedIsolationMaintained(String scenario) {
 		int isolation = java.sql.Connection.TRANSACTION_READ_UNCOMMITTED;
 		Session testSession = null;
 		try {
 			testSession = openSession();
 			isolation = testSession.doReturningWork(
 					new AbstractReturningWork<Integer>() {
 						@Override
 						public Integer execute(Connection connection) throws SQLException {
 							return connection.getTransactionIsolation();
 						}
 					}
 			);
 		}
 		catch( Throwable ignore ) {
 		}
 		finally {
 			if ( testSession != null ) {
 				try {
 					testSession.close();
 				}
 				catch( Throwable ignore ) {
 				}
 			}
 		}
 		if ( isolation < java.sql.Connection.TRANSACTION_READ_COMMITTED ) {
 			SkipLog.reportSkip( "environment does not support at least read committed isolation", scenario );
 			return false;
 		}
 		else {
 			return true;
 		}
 	}
 }
